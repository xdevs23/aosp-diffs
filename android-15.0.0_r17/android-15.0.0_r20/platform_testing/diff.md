```diff
diff --git a/build/tasks/tests/instrumentation_metric_test_list.mk b/build/tasks/tests/instrumentation_metric_test_list.mk
index b13b47edd..8a23a69d1 100644
--- a/build/tasks/tests/instrumentation_metric_test_list.mk
+++ b/build/tasks/tests/instrumentation_metric_test_list.mk
@@ -22,6 +22,7 @@ instrumentation_metric_tests := \
     BlobStorePerfTests \
     CorePerfTests \
     ContentCapturePerfTests \
+    CoroutineTracingPerfTests \
     DocumentsUIAppPerfTests \
     MtpServicePerfTests \
     RsBlasBenchmark \
diff --git a/build/tasks/tests/instrumentation_test_list.mk b/build/tasks/tests/instrumentation_test_list.mk
index b4e528906..e75c40d3c 100644
--- a/build/tasks/tests/instrumentation_test_list.mk
+++ b/build/tasks/tests/instrumentation_test_list.mk
@@ -74,19 +74,6 @@ instrumentation_tests := \
     ExtServicesUnitTests-sminus \
     FrameworksNetSmokeTests \
     FlickerLibTest \
-    FlickerTestsOther \
-    FlickerTestsAppClose \
-    FlickerTestsIme \
-    FlickerTestsQuickswitch \
-    FlickerTestsRotation \
-    FlickerTestApp \
-    WMShellFlickerTestsOther \
-    WMShellFlickerTestsBubbles \
-    WMShellFlickerTestsPip1 \
-    WMShellFlickerTestsPip2 \
-    WMShellFlickerTestsPip3 \
-    WMShellFlickerTestsSplitScreenGroup1 \
-    WMShellFlickerTestsSplitScreenGroup2 \
     WMShellUnitTests \
     trace_config_detailed.textproto \
     perfetto_trace_processor_shell \
diff --git a/build/tasks/tests/native_test_list.mk b/build/tasks/tests/native_test_list.mk
index bf671731f..11530607b 100644
--- a/build/tasks/tests/native_test_list.mk
+++ b/build/tasks/tests/native_test_list.mk
@@ -92,6 +92,8 @@ native_tests := \
     libminijail_unittest_gtest \
     libnativehelper_tests \
     libnetworkstats_test \
+    libnfc-nci-jni-tests\
+    libnfc-nci-tests\
     libprocinfo_test \
     librenderengine_test \
     libtextclassifier_tests-tplus \
@@ -119,7 +121,6 @@ native_tests := \
     netd_integration_test \
     netd_unit_test \
     netdutils_test \
-    nfc_test_utils \
     num-traits_test_src_lib \
     num-traits_test_tests_cast \
     perfetto_integrationtests \
diff --git a/build/tasks/tests/platform_test_list.mk b/build/tasks/tests/platform_test_list.mk
index 5001d290d..cf889d8ce 100644
--- a/build/tasks/tests/platform_test_list.mk
+++ b/build/tasks/tests/platform_test_list.mk
@@ -110,6 +110,8 @@ platform_tests += \
     VersatileTestApp_None \
     VoiceInteraction \
     WifiStrengthScannerUtil \
+    wifi_direct_mobly_snippet \
+    wifi_aware_snippet_new \
 
 ifneq ($(strip $(BOARD_PERFSETUP_SCRIPT)),)
 platform_tests += perf-setup
diff --git a/libraries/annotations/src/android/platform/test/annotations/OptionalPresubmit.java b/libraries/annotations/src/android/platform/test/annotations/OptionalPresubmit.java
new file mode 100644
index 000000000..fb32aea16
--- /dev/null
+++ b/libraries/annotations/src/android/platform/test/annotations/OptionalPresubmit.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a test to be added to Presubmit, not blocking a change's submission.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD, ElementType.TYPE})
+public @interface OptionalPresubmit {}
diff --git a/libraries/annotations/src/py/NonApiTest.py b/libraries/annotations/src/py/NonApiTest.py
index 935d21f20..159ccf1a6 100644
--- a/libraries/annotations/src/py/NonApiTest.py
+++ b/libraries/annotations/src/py/NonApiTest.py
@@ -15,7 +15,7 @@
 """NonApiTest decorator."""
 
 from typing import List
-from ReasonType import ReasonType
+from .ReasonType import ReasonType
 
 
 class NonApiTest(object):
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoFacetBarHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoFacetBarHelper.java
index dcaea4bdd..df62fd4da 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoFacetBarHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoFacetBarHelper.java
@@ -23,7 +23,11 @@ public interface IAutoFacetBarHelper extends IAppHelper {
         PHONE("PHONE"),
         APP_GRID("APP_GRID"),
         HVAC("HVAC"),
-        NOTIFICATION("NOTIFICATION");
+        NOTIFICATION("NOTIFICATION"),
+        BLUETOOTH("BLUETOOTH"),
+        WIFI("WIFI"),
+        BRIGHTNESS("BRIGHTNESS"),
+        SOUND("SOUND");
 
         private String mFacetIcon;
 
@@ -45,7 +49,11 @@ public interface IAutoFacetBarHelper extends IAppHelper {
         PHONE("PHONE"),
         APP_GRID("APP_GRID"),
         HVAC("HVAC"),
-        NOTIFICATION("NOTIFICATION");
+        NOTIFICATION("NOTIFICATION"),
+        BLUETOOTH("BLUETOOTH"),
+        WIFI("WIFI"),
+        BRIGHTNESS("BRIGHTNESS"),
+        SOUND("SOUND");
 
         private String mAppResource;
 
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoStatusBarHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoStatusBarHelper.java
index e1ce259fd..dfacd6691 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoStatusBarHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoStatusBarHelper.java
@@ -283,4 +283,18 @@ public interface IAutoStatusBarHelper extends IAppHelper {
      * <p>Checks if sound settings page title is present
      */
     boolean hasSoundSettingsPageTitle();
+
+    /**
+     * Setup expectations: None
+     *
+     * <p>Get the current time Zone
+     */
+    String getCurrentTimeZone();
+
+    /**
+     * Setup expectations: None
+     *
+     * <p>Get the Device current time Zone
+     */
+    String getDeviceCurrentTimeZone();
 }
diff --git a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUserHelper.java b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUserHelper.java
index f0188f872..75e0b2d76 100644
--- a/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUserHelper.java
+++ b/libraries/app-helpers/interfaces/auto/src/android/platform/helpers/IAutoUserHelper.java
@@ -66,6 +66,20 @@ public interface IAutoUserHelper extends IAppHelper {
      */
     void switchUser(String userFrom, String userTo);
 
+    /**
+     * Setup expectation: Profiles and Accounts setting is open.
+     *
+     * <p>This method is to switch user using profile icon.
+     */
+    void switchUsingUserIcon(String user);
+
+    /**
+     * Setup expectation: Profiles and Accounts setting is open.
+     *
+     * <p>This returns username from profile and account settings.
+     */
+    String getProfileNameFromSettings();
+
     /**
      * Setup expectation: Profiles and Accounts setting is open.
      *
diff --git a/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IAlarmHelper.java b/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IAlarmHelper.java
index d90c328cf..e60297457 100644
--- a/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IAlarmHelper.java
+++ b/libraries/app-helpers/interfaces/common/src/android/platform/helpers/IAlarmHelper.java
@@ -21,7 +21,7 @@ public interface IAlarmHelper extends IAppHelper {
         AM("am_label"),
         PM("pm_label");
 
-        private String mDisplayName;
+        private final String mDisplayName;
 
         AmPm(String displayName) {
             mDisplayName = displayName;
diff --git a/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/ICamera2Helper.java b/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/ICamera2Helper.java
index b12269c16..5749cc14b 100644
--- a/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/ICamera2Helper.java
+++ b/libraries/app-helpers/interfaces/handheld/src/android/platform/helpers/ICamera2Helper.java
@@ -33,17 +33,17 @@ public interface ICamera2Helper extends IAppHelper {
         VIDEO("video"),
         STILL_CAPTURE("still-capture");
 
-        private String name;
+        private final String mName;
 
         /** Stores the provided name as an enum field. */
         ModeType(String name) {
-            this.name = name;
+            this.mName = name;
         }
 
         /** Returns a programmer-friendly name for the {@code ModeType}. */
         @Override
         public String toString() {
-            return name;
+            return mName;
         }
 
         /**
@@ -64,17 +64,17 @@ public interface ICamera2Helper extends IAppHelper {
         FRONT("front"),
         BACK("back");
 
-        private String name;
+        private final String mName;
 
         /** Stores the provided name as an enum field. */
         CameraType(String name) {
-            this.name = name;
+            this.mName = name;
         }
 
         /** Returns a programmer-friendly name for the {@CameraType}. */
         @Override
         public String toString() {
-            return name;
+            return mName;
         }
 
         /**
diff --git a/libraries/app-helpers/spectatio/spectatio-util/Android.bp b/libraries/app-helpers/spectatio/spectatio-util/Android.bp
index d1363c5aa..d6f956984 100644
--- a/libraries/app-helpers/spectatio/spectatio-util/Android.bp
+++ b/libraries/app-helpers/spectatio/spectatio-util/Android.bp
@@ -25,7 +25,9 @@ java_library {
         "androidx.test.uiautomator_uiautomator",
         "gson",
         "guava",
+        "escapevelocity",
     ],
     srcs: ["src/**/*.java"],
     sdk_version: "test_current",
+    min_sdk_version: "33",
 }
diff --git a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/UiElement.java b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/UiElement.java
index 980940359..0259a649d 100644
--- a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/UiElement.java
+++ b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/UiElement.java
@@ -131,6 +131,8 @@ public class UiElement {
                 return By.textContains(mValue);
             case JsonConfigConstants.DESCRIPTION:
                 return By.desc(Pattern.compile(mValue, Pattern.CASE_INSENSITIVE));
+            case JsonConfigConstants.DESCRIPTION_CONTAINS:
+                return By.descContains(mValue);
             case JsonConfigConstants.CLASS:
                 if (mPackage != null && !mPackage.isEmpty()) {
                     return By.clazz(mPackage, mValue);
@@ -179,6 +181,9 @@ public class UiElement {
             case JsonConfigConstants.DESCRIPTION:
                 s.desc(Pattern.compile(mValue, Pattern.CASE_INSENSITIVE));
                 break;
+            case JsonConfigConstants.DESCRIPTION_CONTAINS:
+                s.descContains(mValue);
+                break;
             case JsonConfigConstants.CLASS:
                 if (mPackage != null && !mPackage.isEmpty()) {
                     s.clazz(mPackage, mValue);
diff --git a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/validators/ValidateUiElement.java b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/validators/ValidateUiElement.java
index 4ccd2a558..911b48919 100644
--- a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/validators/ValidateUiElement.java
+++ b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/configs/validators/ValidateUiElement.java
@@ -48,6 +48,7 @@ public class ValidateUiElement implements JsonDeserializer<UiElement> {
                     JsonConfigConstants.TEXT,
                     JsonConfigConstants.TEXT_CONTAINS,
                     JsonConfigConstants.DESCRIPTION,
+                    JsonConfigConstants.DESCRIPTION_CONTAINS,
                     JsonConfigConstants.CLASS,
                     JsonConfigConstants.DISPLAY_ID,
                     JsonConfigConstants.HAS_ANCESTOR,
diff --git a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/constants/JsonConfigConstants.java b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/constants/JsonConfigConstants.java
index be0a6697e..b43483f3d 100644
--- a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/constants/JsonConfigConstants.java
+++ b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/constants/JsonConfigConstants.java
@@ -42,6 +42,7 @@ public class JsonConfigConstants {
     public static final String TEXT = "TEXT";
     public static final String TEXT_CONTAINS = "TEXT_CONTAINS";
     public static final String DESCRIPTION = "DESCRIPTION";
+    public static final String DESCRIPTION_CONTAINS = "DESCRIPTION_CONTAINS";
     public static final String CLASS = "CLASS";
     public static final String DISPLAY_ID = "DISPLAY_ID";
     public static final String HAS_ANCESTOR = "HAS_ANCESTOR";
diff --git a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/utils/SpectatioUiUtil.java b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/utils/SpectatioUiUtil.java
index 83a2e33d6..074631af2 100644
--- a/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/utils/SpectatioUiUtil.java
+++ b/libraries/app-helpers/spectatio/spectatio-util/src/android/platform/spectatio/utils/SpectatioUiUtil.java
@@ -21,9 +21,11 @@ import android.graphics.Point;
 import android.graphics.Rect;
 import android.os.RemoteException;
 import android.os.SystemClock;
+import android.os.UserHandle;
 import android.platform.spectatio.exceptions.MissingUiElementException;
 import android.util.Log;
 import android.view.KeyEvent;
+import com.google.escapevelocity.Template;
 
 import androidx.test.uiautomator.By;
 import androidx.test.uiautomator.BySelector;
@@ -35,10 +37,16 @@ import androidx.test.uiautomator.Until;
 import com.google.common.base.Strings;
 
 import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 
 public class SpectatioUiUtil {
     private static final String LOG_TAG = SpectatioUiUtil.class.getSimpleName();
@@ -283,19 +291,52 @@ public class SpectatioUiUtil {
      */
     public String executeShellCommand(String command) {
         validateText(command, /* type= */ "Command");
+        String populatedCommand = populateShellCommand(command);
+        Log.d(
+                LOG_TAG,
+                String.format(
+                        "Initial command: %s. Populated command: %s",
+                        command, populatedCommand));
         try {
-            return mDevice.executeShellCommand(command);
+            return mDevice.executeShellCommand(populatedCommand);
         } catch (IOException e) {
             // ignore
             Log.e(
                     LOG_TAG,
                     String.format(
                             "The shell command failed to run: %s, Error: %s",
-                            command, e.getMessage()));
+                            populatedCommand, e.getMessage()));
             return "";
         }
     }
 
+    private String populateShellCommand(String command) {
+        String populatedCommand = command;
+
+        // Map of supported substitutions
+        Map<String, String> vars = new HashMap<>();
+        vars.put("user_id", String.valueOf(UserHandle.CURRENT.myUserId()));
+
+        try (InputStreamReader reader =
+                new InputStreamReader(
+                        new ByteArrayInputStream(command.getBytes(StandardCharsets.UTF_8)))) {
+            Template template = Template.parseFrom(reader);
+            populatedCommand = template.evaluate(vars);
+            Log.d(
+                    LOG_TAG,
+                    String.format(
+                            "Initial command: %s. Populated command: %s",
+                            command, populatedCommand));
+        } catch (IOException e) {
+            Log.e(
+                    LOG_TAG,
+                    String.format(
+                            "Error populating the shell command template %s, Error: %s",
+                            command, e.getMessage()));
+        }
+        return populatedCommand;
+    }
+
     /** Find and return the UI Object that matches the given selector */
     public UiObject2 findUiObject(BySelector selector) {
         validateSelector(selector, /* action= */ "Find UI Object");
@@ -481,6 +522,11 @@ public class SpectatioUiUtil {
         return mDevice.hasObject(By.pkg(packageName).depth(0));
     }
 
+    /** Click at the specified location on the device */
+    public void click(int x, int y) throws IOException {
+        mDevice.click(x, y);
+    }
+
     public void swipeUp() {
         // Swipe Up From bottom of screen to the top in one step
         swipe(SwipeDirection.BOTTOM_TO_TOP, /*numOfSteps*/ MAX_SWIPE_STEPS);
@@ -579,7 +625,7 @@ public class SpectatioUiUtil {
                 padYStart = bounds.bottom / 4 * 3;
                 break;
             case DEFAULT:
-                break; // handled above the switch
+                break; // handled above the switch.
         }
 
         switch (swipeDirection) {
@@ -623,9 +669,13 @@ public class SpectatioUiUtil {
         return swipePoints;
     }
 
-    private Rect getScreenBounds() {
-        Point dimensions = mDevice.getDisplaySizeDp();
-        return new Rect(0, 0, dimensions.x, dimensions.y);
+    /** Returns a Rect representing the bounds of the screen */
+    public Rect getScreenBounds() {
+        return new Rect(
+            /* left= */ 0,
+            /* top= */ 0,
+            /* right= */ mDevice.getDisplayWidth(),
+            /* bottom= */ mDevice.getDisplayHeight());
     }
 
     public void swipeRight(UiObject2 uiObject) {
@@ -794,14 +844,15 @@ public class SpectatioUiUtil {
         return null;
     }
 
-    private String getViewHierarchy() {
+    /** Returns the view hierarchy as XML, as output by `adb shell uiautomator dump`. */
+    public String getViewHierarchy() {
         try {
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             mDevice.dumpWindowHierarchy(outputStream);
             outputStream.close();
             return outputStream.toString();
         } catch (IOException ex) {
-            throw new IllegalStateException("Unable to get view hierarchy.");
+            throw new IllegalStateException("Unable to get view hierarchy.", ex);
         }
     }
 
@@ -950,20 +1001,23 @@ public class SpectatioUiUtil {
 
     private UiObject2 validateAndGetScrollableObject(BySelector scrollableSelector)
             throws MissingUiElementException {
-        UiObject2 scrollableObject = findUiObject(scrollableSelector);
-        validateUiObjectAndThrowMissingUiElementException(
-                scrollableObject, scrollableSelector, /* action= */ "Scroll");
-        if (!scrollableObject.isScrollable()) {
-            scrollableObject = scrollableObject.findObject(By.scrollable(true));
-        }
-        if ((scrollableObject == null) || !scrollableObject.isScrollable()) {
-            throw new IllegalStateException(
-                    String.format(
-                            "Cannot scroll; UI Object for selector %s is not scrollable and has no"
-                                    + " scrollable children.",
-                            scrollableSelector));
+        List<UiObject2> scrollableObjects = findUiObjects(scrollableSelector);
+        for (UiObject2 scrollableObject : scrollableObjects) {
+            validateUiObjectAndThrowMissingUiElementException(
+                    scrollableObject, scrollableSelector, /* action= */ "Scroll");
+            if (!scrollableObject.isScrollable()) {
+                scrollableObject = scrollableObject.findObject(By.scrollable(true));
+            }
+            if (scrollableObject != null && scrollableObject.isScrollable()) {
+                // if there are multiple, return the first UiObject that is scrollable
+                return scrollableObject;
+            }
         }
-        return scrollableObject;
+        throw new IllegalStateException(
+                String.format(
+                        "Cannot scroll; Could not find UI Object for selector %s that is scrollable"
+                                + " or have scrollable children.",
+                        scrollableSelector));
     }
 
     /**
diff --git a/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json b/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
index df31cb9e1..028764fe0 100644
--- a/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
+++ b/libraries/automotive-helpers/auto-default-config/resources/assets/defaultSpectatioConfig.json
@@ -68,13 +68,14 @@
     "OPEN_APP_GRID_COMMAND": "am start -n com.android.car.carlauncher/.GASAppGridActivity",
     "OPEN_NOTIFICATIONS_COMMAND": "service call statusbar 1",
     "STOP_SETTING_APP_COMMAND": "am force-stop com.android.car.settings",
-    "OPEN_SETTINGS_COMMAND": "am start -a android.settings.SETTINGS",
+    "OPEN_SETTINGS_COMMAND": "am start -a android.settings.SETTINGS --user $user_id",
     "MEDIA_LAUNCH_COMMAND": "am start -a android.car.intent.action.MEDIA_TEMPLATE -e android.car.intent.extra.MEDIA_COMPONENT com.android.bluetooth/com.android.bluetooth.avrcpcontroller.BluetoothMediaBrowserService",
     "MEDIA_LAUNCH_BLUETOOTH_AUDIO_COMMAND": "am start -a android.car.intent.action.MEDIA_TEMPLATE -e android.car.intent.extra.MEDIA_COMPONENT com.google.android.bluetooth/com.android.bluetooth.avrcpcontroller.BluetoothMediaBrowserService",
     "NIGHT_MODE_COMMAND": "dumpsys activity service com.android.car/.CarService day-night-mode  night",
     "DAY_MODE_COMMAND": "dumpsys activity service com.android.car/.CarService day-night-mode  day",
     "OPEN_SYSTEM_UI": "am crash com.android.systemui",
-    "OPEN_CAR_UI": "am crash com.android.car"
+    "OPEN_CAR_UI": "am crash com.android.car",
+    "DATE_COMMAND": "date"
   },
   "UI_ELEMENTS": {
     "MAKE_CALL": {
@@ -566,6 +567,31 @@
       "VALUE": "hvac_panel",
       "PACKAGE": "com.android.systemui"
     },
+    "STATUS_BAR_DISPLAY_SETTINGS": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "qc_display_footer_button",
+      "PACKAGE": "com.android.systemui"
+    },
+    "STATUS_BAR_WIFI_SETTINGS": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "qc_connectivity_footer_button",
+      "PACKAGE": "com.android.systemui"
+    },
+    "STATUS_BAR_SOUND_SETTINGS": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "qc_sound_footer_button",
+      "PACKAGE": "com.android.systemui"
+    },
+    "WIFI_FACET_BUTTON": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "connectivity_panel_button",
+      "PACKAGE": "com.android.systemui"
+    },
+    "SOUND_FACET_BUTTON": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "volume_panel",
+      "PACKAGE": "com.android.systemui"
+    },
     "NOTIFICATION_FACET_BUTTON": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "notifications",
@@ -1429,7 +1455,7 @@
     },
     "MINIMIZED_MEDIA_CONTROLS": {
       "TYPE": "RESOURCE_ID",
-      "VALUE": "minimized_playback_controls",
+      "VALUE": "minimized_control_bar_layout",
       "PACKAGE": "com.android.car.media"
     },
     "ARTIST_TITLE": {
@@ -1583,6 +1609,11 @@
       "VALUE": "entity_header_summary",
       "PACKAGE": "com.android.car.settings"
     },
+    "DEVICE_HEADER_TITLE": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "entity_header_title",
+      "PACKAGE": "com.android.car.settings"
+    },
     "DEVICE_CONNECTION_TEXT": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "button1Text",
@@ -1646,6 +1677,11 @@
       "TYPE": "TEXT",
       "VALUE": "Settings"
     },
+    "SETTINGS_BACK_NAV_ICON": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "car_ui_toolbar_nav_icon",
+      "PACKAGE": "com.chassis.car.ui.plugin"
+    },
     "SETTINGS_SCROLL_FORWARD_BUTTON": {
       "TYPE": "RESOURCE_ID",
       "VALUE": "car_ui_scrollbar_page_down",
@@ -2223,6 +2259,11 @@
       "TYPE": "TEXT",
       "VALUE": "Text-to-speech output"
     },
+    "SOFT_KEYBOARD_HIDE_BUTTON": {
+      "TYPE": "RESOURCE_ID",
+      "VALUE": "key_pos_hide_keyboard",
+      "PACKAGE": "com.google.android.apps.automotive.inputmethod"
+    },
     "UNIT_SYSTEM_SETTINGS_SPEED": {
       "TYPE": "TEXT",
       "VALUE": "Speed"
diff --git a/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java b/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
index b81d2482e..f16d0539f 100644
--- a/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
+++ b/libraries/automotive-helpers/auto-default-config/src/android/platform/helpers/AutomotiveConfigConstants.java
@@ -362,6 +362,7 @@ public class AutomotiveConfigConstants {
     public static final String TOGGLE_BLUETOOTH = "TOGGLE_BLUETOOTH";
     public static final String TOGGLE_DEVICE_BLUETOOTH = "TOGGLE_DEVICE_BLUETOOTH";
     public static final String DEVICE_HEADER_SUMMARY = "DEVICE_HEADER_SUMMARY";
+    public static final String DEVICE_HEADER_TITLE = "DEVICE_HEADER_TITLE";
     public static final String DEVICE_CONNECTION_TEXT = "DEVICE_CONNECTION_TOGGLE";
 
     public static final String DEVICE_CONNECTION_BUTTON = "DEVICE_CONNECTION_BUTTON";
@@ -400,6 +401,7 @@ public class AutomotiveConfigConstants {
     public static final String SETTINGS_SUB_SETTING_SCROLL_ELEMENT =
             "SETTINGS_SUB_SETTING_SCROLL_ELEMENT";
     public static final String SETTINGS_TITLE_TEXT = "SETTINGS_TITLE_TEXT";
+    public static final String SETTINGS_BACK_NAV_ICON = "SETTINGS_BACK_NAV_ICON";
     public static final String LOCATION_SETTINGS_RECENTLY_ACCESSED_MAPS =
             "LOCATION_SETTINGS_RECENTLY_ACCESSED_MAPS";
     public static final String LOCATION_SETTINGS_VIEW_ALL = "LOCATION_SETTINGS_VIEW_ALL";
@@ -508,6 +510,11 @@ public class AutomotiveConfigConstants {
     public static final String NOTIFICATION_FACET_BUTTON = "NOTIFICATION_FACET_BUTTON";
     public static final String HVAC_FACET_BUTTON = "HVAC_FACET_BUTTON";
     public static final String HVAC_PANEL = "HVAC_PANEL";
+    public static final String WIFI_FACET_BUTTON = "WIFI_FACET_BUTTON";
+    public static final String SOUND_FACET_BUTTON = "SOUND_FACET_BUTTON";
+    public static final String STATUS_BAR_WIFI_SETTINGS = "STATUS_BAR_WIFI_SETTINGS";
+    public static final String STATUS_BAR_DISPLAY_SETTINGS = "STATUS_BAR_DISPLAY_SETTINGS";
+    public static final String STATUS_BAR_SOUND_SETTINGS = "STATUS_BAR_SOUND_SETTINGS";
 
     // APP info Setting UI ELEMENTS
     public static final String RECENTLY_OPENED_UI_ELEMENT = "RECENTLY_OPENED_UI_ELEMENT";
@@ -555,6 +562,7 @@ public class AutomotiveConfigConstants {
     public static final String CONNECTED_WIFI = "CONNECTED_WIFI";
     public static final String FORGET_WIFI = "FORGET_WIFI";
     public static final String CLOCK_TIME = "CLOCK_TIME";
+    public static final String DATE_COMMAND = "DATE_COMMAND";
 
     // Quick Controls
     public static final String HOME_BLUETOOTH_BUTTON = "HOME_BLUETOOTH_BUTTON";
@@ -705,4 +713,7 @@ public class AutomotiveConfigConstants {
             "UNIT_SYSTEM_SETTINGS_TEMPERATURE";
     public static final String UNIT_SYSTEM_SETTINGS_PRESSURE = "UNIT_SYSTEM_SETTINGS_PRESSURE";
     public static final String LANGUAGES_INPUT_IN_SYSTEM = "LANGUAGES_INPUT_IN_SYSTEM";
+
+    // Soft Keyboard UI elements
+    public static final String SOFT_KEYBOARD_HIDE_BUTTON = "SOFT_KEYBOARD_HIDE_BUTTON";
 }
diff --git a/libraries/automotive-helpers/facet-bar-helper/src/android/platform/helpers/FacetBarHelperImpl.java b/libraries/automotive-helpers/facet-bar-helper/src/android/platform/helpers/FacetBarHelperImpl.java
index f02d678be..ec3182231 100644
--- a/libraries/automotive-helpers/facet-bar-helper/src/android/platform/helpers/FacetBarHelperImpl.java
+++ b/libraries/automotive-helpers/facet-bar-helper/src/android/platform/helpers/FacetBarHelperImpl.java
@@ -36,6 +36,10 @@ public class FacetBarHelperImpl extends AbstractStandardAppHelper implements IAu
         FACET_BAR.APP_GRID.setFacetIcon(AutomotiveConfigConstants.APP_GRID_FACET_BUTTON);
         FACET_BAR.HVAC.setFacetIcon(AutomotiveConfigConstants.HVAC_FACET_BUTTON);
         FACET_BAR.NOTIFICATION.setFacetIcon(AutomotiveConfigConstants.NOTIFICATION_FACET_BUTTON);
+        FACET_BAR.BLUETOOTH.setFacetIcon(AutomotiveConfigConstants.STATUS_BAR_BLUETOOTH_BUTTON);
+        FACET_BAR.WIFI.setFacetIcon(AutomotiveConfigConstants.WIFI_FACET_BUTTON);
+        FACET_BAR.BRIGHTNESS.setFacetIcon(AutomotiveConfigConstants.STATUS_BAR_BRIGHTNESS_BUTTON);
+        FACET_BAR.SOUND.setFacetIcon(AutomotiveConfigConstants.SOUND_FACET_BUTTON);
 
         // Set App Verification
         VERIFY_OPEN_APP.HOME.setAppResourceForVerification(
@@ -46,6 +50,14 @@ public class FacetBarHelperImpl extends AbstractStandardAppHelper implements IAu
         VERIFY_OPEN_APP.HVAC.setAppResourceForVerification(AutomotiveConfigConstants.HVAC_PANEL);
         VERIFY_OPEN_APP.NOTIFICATION.setAppResourceForVerification(
                 AutomotiveConfigConstants.NOTIFICATION_VIEW);
+        VERIFY_OPEN_APP.BLUETOOTH.setAppResourceForVerification(
+                AutomotiveConfigConstants.STATUS_BAR_BLUETOOTH_SETTINGS);
+        VERIFY_OPEN_APP.WIFI.setAppResourceForVerification(
+                AutomotiveConfigConstants.STATUS_BAR_WIFI_SETTINGS);
+        VERIFY_OPEN_APP.BRIGHTNESS.setAppResourceForVerification(
+                AutomotiveConfigConstants.STATUS_BAR_DISPLAY_SETTINGS);
+        VERIFY_OPEN_APP.SOUND.setAppResourceForVerification(
+                AutomotiveConfigConstants.STATUS_BAR_SOUND_SETTINGS);
     }
 
     /** {@inheritDoc} */
diff --git a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
index ec48a6d08..86ae8c765 100644
--- a/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
+++ b/libraries/automotive-helpers/media-center-app-helper/src/android/platform/helpers/MediaCenterHelperImpl.java
@@ -36,9 +36,7 @@ import androidx.test.uiautomator.UiObjectNotFoundException;
 import java.util.List;
 import java.util.regex.Pattern;
 
-/**
- * Helper class for functional test for Mediacenter test
- */
+/** Helper class for functional test for Mediacenter test */
 public class MediaCenterHelperImpl extends AbstractStandardAppHelper implements IAutoMediaHelper {
 
     private MediaSessionManager mMediaSessionManager;
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
index c6265d1d3..32e3bd959 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingHelperImpl.java
@@ -331,12 +331,26 @@ public class SettingHelperImpl extends AbstractStandardAppHelper implements IAut
         while (count > 0
                 && isAppInForeground()
                 && getSpectatioUiUtil().findUiObjects(titleText) == null) {
-            getSpectatioUiUtil().pressBack();
+            pressSettingsBackNavIcon();
             getSpectatioUiUtil().wait5Seconds(); // to avoid stale object error
             count--;
         }
     }
 
+    private void pressSettingsBackNavIcon() {
+        UiObject2 navIcon =
+                getSpectatioUiUtil()
+                        .findUiObject(
+                                getUiElementFromConfig(
+                                        AutomotiveConfigConstants.SETTINGS_BACK_NAV_ICON));
+        if (navIcon == null) {
+            // if there is no nav button, use device back for confirmation dialog case
+            getSpectatioUiUtil().pressBack();
+            return;
+        }
+        getSpectatioUiUtil().clickAndWait(navIcon);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void openMenuWith(String... menuOptions) {
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingUserHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingUserHelperImpl.java
index ec517a358..91991745a 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingUserHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingUserHelperImpl.java
@@ -88,7 +88,7 @@ public class SettingUserHelperImpl extends AbstractStandardAppHelper implements
     public void addUser() {
         clickbutton(AutomotiveConfigConstants.USER_SETTINGS_ADD_PROFILE);
         clickbutton(AutomotiveConfigConstants.USER_SETTINGS_OK);
-        getSpectatioUiUtil().wait5Seconds();
+        getSpectatioUiUtil().waitNSeconds(WAIT_SEC);
     }
     // opens permission page of a user
     @Override
@@ -164,7 +164,6 @@ public class SettingUserHelperImpl extends AbstractStandardAppHelper implements
     @Override
     public void switchUser(String userFrom, String userTo) {
         int count = 0;
-        goToQuickSettings();
         BySelector userFromSelector = By.text(userFrom);
         UiObject2 userFromObject = getSpectatioUiUtil().findUiObject(userFromSelector);
         getSpectatioUiUtil().validateUiObject(userFromObject, String.format("User %s", userFrom));
@@ -184,13 +183,35 @@ public class SettingUserHelperImpl extends AbstractStandardAppHelper implements
         }
     }
 
+    @Override
+    public void switchUsingUserIcon(String userNameConfigKey) {
+        int count = 0;
+        clickbutton(AutomotiveConfigConstants.HOME_PROFILE_ICON_BUTTON);
+        clickbutton(userNameConfigKey);
+        while ((getSpectatioUiUtil()
+                                .findUiObject(
+                                        getUiElementFromConfig(
+                                                AutomotiveConfigConstants.HOME_BOTTOM_CARD))
+                        == null)
+                && count < MAX_WAIT_COUNT) {
+            getSpectatioUiUtil().waitNSeconds(WAIT_SEC);
+            count++;
+        }
+    }
+
+    @Override
+    public String getProfileNameFromSettings() {
+        BySelector profileNameSelector =
+                getUiElementFromConfig(AutomotiveConfigConstants.DEVICE_HEADER_TITLE);
+        UiObject2 profileName = getSpectatioUiUtil().findUiObject(profileNameSelector);
+        String profileNameText = profileName.getText();
+        return profileNameText;
+    }
+
     // add User via quick settings
     @Override
     public void addUserQuickSettings(String userFrom) {
         goToQuickSettings();
-        BySelector userFromSelector = By.text(userFrom);
-        UiObject2 userFromObject = getSpectatioUiUtil().findUiObject(userFromSelector);
-        getSpectatioUiUtil().validateUiObject(userFromObject, String.format("user %s", userFrom));
         getSpectatioUiUtil().wait1Second();
         addUser();
     }
@@ -253,7 +274,7 @@ public class SettingUserHelperImpl extends AbstractStandardAppHelper implements
 
     // go to quick Settings for switching User
     private void goToQuickSettings() {
-        clickbutton(AutomotiveConfigConstants.USER_SETTINGS_MAKE_TIME_PATTERN);
+        clickbutton(AutomotiveConfigConstants.HOME_PROFILE_ICON_BUTTON);
     }
     // checks whether the Add profile button is visible
     @Override
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
index 1376a0bac..d03530cd0 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsAppInfoHelperImpl.java
@@ -311,8 +311,8 @@ public class SettingsAppInfoHelperImpl extends AbstractStandardAppHelper
                                                     .APP_INFO_SETTINGS_DONT_ALLOW_ANYWAY_BUTTON));
             getSpectatioUiUtil().clickAndWait(dont_allow_anyway_btn);
         }
-        getSpectatioUiUtil().pressBack();
-        getSpectatioUiUtil().pressBack();
+        pressSettingsBackNavIcon();
+        pressSettingsBackNavIcon();
     }
 
     /** {@inheritDoc} */
@@ -444,11 +444,24 @@ public class SettingsAppInfoHelperImpl extends AbstractStandardAppHelper
 
         assertTrue(
                 "Could not return from individual permission screen.",
-                getSpectatioUiUtil().pressBack()); // Return to the general permissions screen
+                pressSettingsBackNavIcon()); // Return to the general permissions screen
 
         return appNums;
     }
 
+    private boolean pressSettingsBackNavIcon() {
+        UiObject2 navIcon =
+                getSpectatioUiUtil()
+                        .findUiObject(
+                                getUiElementFromConfig(
+                                        AutomotiveConfigConstants.SETTINGS_BACK_NAV_ICON));
+        if (navIcon != null) {
+            getSpectatioUiUtil().clickAndWait(navIcon);
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Assumes unique text fields on the permission app list screens, except for the first text
      * field, containing the permission title. For example, this method assumes that no two apps
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsDateTimeHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsDateTimeHelperImpl.java
index fe099d6dd..13faa6388 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsDateTimeHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsDateTimeHelperImpl.java
@@ -133,7 +133,19 @@ public class SettingsDateTimeHelperImpl extends AbstractStandardAppHelper
         setCalendar(1, day_string);
         setCalendar(0, month_string);
         setCalendar(2, year_string);
-        getSpectatioUiUtil().pressBack();
+        pressSettingsBackNavIcon();
+    }
+
+    private void pressSettingsBackNavIcon() {
+        UiObject2 navIcon =
+                getSpectatioUiUtil()
+                        .findUiObject(
+                                getUiElementFromConfig(
+                                        AutomotiveConfigConstants.SETTINGS_BACK_NAV_ICON));
+        getSpectatioUiUtil()
+                .validateUiObject(
+                        navIcon, "Could not press back; unable to find settings back nav icon");
+        getSpectatioUiUtil().clickAndWait(navIcon);
     }
 
     private void setCalendar(int index, String s) {
@@ -216,7 +228,7 @@ public class SettingsDateTimeHelperImpl extends AbstractStandardAppHelper
         setTime(2, minute_string, currentTime);
         setTime(0, String.valueOf(hour), currentTime);
         setTime(1, am_pm, currentTime);
-        getSpectatioUiUtil().pressBack();
+        pressSettingsBackNavIcon();
     }
 
     /** {@inheritDoc} */
@@ -254,7 +266,7 @@ public class SettingsDateTimeHelperImpl extends AbstractStandardAppHelper
         }
         setTime(2, minute_string, currentTime);
         setTime(0, hour_string, currentTime);
-        getSpectatioUiUtil().pressBack();
+        pressSettingsBackNavIcon();
     }
 
     private void setTime(int index, String s, String currentTime) {
diff --git a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
index 5fc26162a..8da2bd912 100644
--- a/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
+++ b/libraries/automotive-helpers/settings-app-helper/src/android/platform/helpers/SettingsSystemHelperImpl.java
@@ -29,6 +29,7 @@ import androidx.test.uiautomator.UiObject2;
 import java.text.SimpleDateFormat;
 import java.time.Month;
 import java.util.Date;
+import java.util.List;
 
 /** Helper class for functional tests of System settings */
 public class SettingsSystemHelperImpl extends AbstractStandardAppHelper
@@ -360,18 +361,23 @@ public class SettingsSystemHelperImpl extends AbstractStandardAppHelper
     @Override
     public boolean verifyUsageinGB(String option) {
         boolean isUsageinGB = false;
-        UiObject2 targetObject =
+        List<UiObject2> scrollElements =
                 getSpectatioUiUtil()
-                        .findUiObject(
+                        .findUiObjects(
                                 getUiElementFromConfig(
                                         AutomotiveConfigConstants
                                                 .SETTINGS_UI_SUB_SETTING_SCROLL_ELEMENT));
-        UiObject2 target =
-                getSpectatioUiUtil()
-                        .findUiObjectInGivenElement(targetObject, getUiElementFromConfig(option));
-        String targetText = getSummeryText(target);
-        if (targetText.contains("GB")) {
-            isUsageinGB = true;
+        for (UiObject2 element : scrollElements) {
+            UiObject2 foundObject =
+                    getSpectatioUiUtil()
+                            .findUiObjectInGivenElement(element, getUiElementFromConfig(option));
+            if (foundObject != null) {
+                // there may be multiple matches the 'option' config on screen, such as 'System'
+                String targetText = getSummeryText(foundObject);
+                if (targetText != null && targetText.contains("GB")) {
+                    isUsageinGB = true;
+                }
+            }
         }
         return isUsageinGB;
     }
@@ -432,7 +438,19 @@ public class SettingsSystemHelperImpl extends AbstractStandardAppHelper
             getSpectatioUiUtil().clickAndWait(buildNumber);
             getSpectatioUiUtil().wait1Second();
         }
-        getSpectatioUiUtil().pressBack();
+        pressSettingsBackNavIcon();
         getSpectatioUiUtil().waitForIdle();
     }
+
+    private void pressSettingsBackNavIcon() {
+        UiObject2 navIcon =
+                getSpectatioUiUtil()
+                        .findUiObject(
+                                getUiElementFromConfig(
+                                        AutomotiveConfigConstants.SETTINGS_BACK_NAV_ICON));
+        getSpectatioUiUtil()
+                .validateUiObject(
+                        navIcon, "Could not press back; unable to find settings back nav icon");
+        getSpectatioUiUtil().clickAndWait(navIcon);
+    }
 }
diff --git a/libraries/automotive-helpers/status-bar-helper/src/android/platform/helpers/StatusBarHelperImpl.java b/libraries/automotive-helpers/status-bar-helper/src/android/platform/helpers/StatusBarHelperImpl.java
index eaf9c2233..77f48c52e 100644
--- a/libraries/automotive-helpers/status-bar-helper/src/android/platform/helpers/StatusBarHelperImpl.java
+++ b/libraries/automotive-helpers/status-bar-helper/src/android/platform/helpers/StatusBarHelperImpl.java
@@ -25,6 +25,7 @@ import androidx.test.uiautomator.UiObject2;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
+import java.util.TimeZone;
 
 /** Helper file for status bar tests */
 public class StatusBarHelperImpl extends AbstractStandardAppHelper implements IAutoStatusBarHelper {
@@ -425,6 +426,24 @@ public class StatusBarHelperImpl extends AbstractStandardAppHelper implements IA
         return time;
     }
 
+    @Override
+    public String getCurrentTimeZone() {
+        TimeZone currentTimeInZone = TimeZone.getDefault();
+        String currentTimeZoneId = currentTimeInZone.getID();
+        return currentTimeZoneId;
+    }
+
+    @Override
+    public String getDeviceCurrentTimeZone() {
+        String deviceCurrentDateTime =
+                getSpectatioUiUtil()
+                        .executeShellCommand(
+                                getCommandFromConfig(AutomotiveConfigConstants.DATE_COMMAND));
+        String[] dateTime = deviceCurrentDateTime.split(" ");
+        String deviceCurrentTimeZone = dateTime[dateTime.length - 2];
+        return deviceCurrentTimeZone;
+    }
+
     @Override
     public boolean changeToDayMode() {
         String dayModeResult =
diff --git a/libraries/collectors-helper/memory/src/com/android/helpers/MemhogHelper.java b/libraries/collectors-helper/memory/src/com/android/helpers/MemhogHelper.java
index 32c55afc7..99be2a0db 100644
--- a/libraries/collectors-helper/memory/src/com/android/helpers/MemhogHelper.java
+++ b/libraries/collectors-helper/memory/src/com/android/helpers/MemhogHelper.java
@@ -18,8 +18,8 @@ package com.android.helpers;
 import android.os.SystemClock;
 import android.util.Log;
 
-import androidx.test.uiautomator.UiDevice;
 import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.test.uiautomator.UiDevice;
 
 import java.io.IOException;
 import java.util.Locale;
@@ -32,8 +32,11 @@ public class MemhogHelper {
     // Location of memhog on the device, defined in heavyweight-memhog.gcl.
     private static final String MEMHOG_FILE_PATH = "/data/local/tmp/memhog";
     private static final String MEMHOG_PROC_ID_CMD = "pidof memhog";
-    private static final String MEMHOG_START_CMD =
+    private static final String MEMHOG_START_HOG_CMD =
             "%s -m %d -s -1 -M -r 1 </dev/null &>/dev/null &";
+    private static final String MEMHOG_START_HEADROOM_CMD =
+            "%s -m %d -r -1 --read --file /data/local/tmp/memhog.file --chunk 20M --chunk-delay"
+                    + " 2000000 </dev/null &>/dev/null &";
     private static final String MEMHOG_STOP_CMD = "pkill memhog";
 
     private static final int MEMHOG_START_RETRY_COUNT = 3;
@@ -44,10 +47,35 @@ public class MemhogHelper {
 
     private UiDevice mUiDevice;
 
-    // Starts memhog with the specified amount of memory in bytes.
+    /** Starts memhog in the "hog" mode with the specified amount of memory in bytes. */
     public boolean startMemhog(long memorySizeBytes) {
+        return startMemhog("hog", memorySizeBytes);
+    }
+
+    /**
+     * Starts memhog with the specified mode and amount of memory in bytes. The mode is can be "hog"
+     * to cause memhog to mlock <code>memorySizeBytes</code> in memory, or "headroom" to cause
+     * memhog to continuously allocate up to a max of <code>memorySizeBytes</code> of easily
+     * reclaimable memory.
+     */
+    public boolean startMemhog(String mode, long memorySizeBytes) {
         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
         Log.i(TAG, "Starting memhog.");
+        final String startCmd;
+        switch (mode) {
+            case "hog":
+                startCmd = MEMHOG_START_HOG_CMD;
+                break;
+
+            case "headroom":
+                startCmd = MEMHOG_START_HEADROOM_CMD;
+                break;
+
+            default:
+                Log.e(TAG, "Unsupported memhog mode '" + mode + "'");
+                return false;
+        }
+
         new Thread() {
             @Override
             public void run() {
@@ -57,11 +85,7 @@ public class MemhogHelper {
                     // Makes memhog executable, then runs it.
                     uiDevice.executeShellCommand(String.format(CHMOD_CMD, MEMHOG_FILE_PATH));
                     uiDevice.executeShellCommand(
-                            String.format(
-                                    Locale.US,
-                                    MEMHOG_START_CMD,
-                                    MEMHOG_FILE_PATH,
-                                    memorySizeBytes));
+                            String.format(Locale.US, startCmd, MEMHOG_FILE_PATH, memorySizeBytes));
                 } catch (IOException e) {
                     Log.e(TAG, "Failed to start memhog: " + e.getMessage());
                 }
diff --git a/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java b/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
index a73d48d48..90ca854e1 100644
--- a/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
+++ b/libraries/collectors-helper/perfetto/src/com/android/helpers/PerfettoHelper.java
@@ -18,11 +18,13 @@ package com.android.helpers;
 
 import android.app.UiAutomation;
 import android.os.ParcelFileDescriptor;
+import android.os.ParcelFileDescriptor.AutoCloseInputStream;
+import android.os.ParcelFileDescriptor.AutoCloseOutputStream;
 import android.os.SystemClock;
 import android.util.Log;
 
 import androidx.annotation.VisibleForTesting;
-import androidx.test.InstrumentationRegistry;
+import androidx.test.platform.app.InstrumentationRegistry;
 import androidx.test.uiautomator.UiDevice;
 
 import java.io.File;
@@ -32,6 +34,7 @@ import java.io.PrintWriter;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.Set;
 
 /**
@@ -85,6 +88,7 @@ public class PerfettoHelper {
     private boolean mTrackPerfettoPidFlag;
     private String mTrackPerfettoRootDir = "sdcard/";
     private File mPerfettoPidFile;
+    private boolean mShouldUseContentProvider;
 
     /** Set content of the perfetto configuration to be used when tracing */
     public PerfettoHelper setTextProtoConfig(String value) {
@@ -463,6 +467,11 @@ public class PerfettoHelper {
         return false;
     }
 
+    private int getCurrentUserId() throws IOException {
+        String userId = mUIDevice.executeShellCommand("am get-current-user");
+        return Integer.parseInt(userId.trim());
+    }
+
     /**
      * Copy the temporary perfetto trace output file from /data/misc/perfetto-traces/ to given
      * destinationFile.
@@ -485,22 +494,86 @@ public class PerfettoHelper {
         }
 
         // Copy the collected trace from /data/misc/perfetto-traces/trace_output.perfetto-trace to
-        // destinationFile
+        // destinationFile.
         try {
-            String moveResult = mUIDevice.executeShellCommand(String.format(
-                    MOVE_CMD, PERFETTO_TMP_OUTPUT_FILE, destinationFile));
-            if (!moveResult.isEmpty()) {
-                Log.e(LOG_TAG, String.format(
-                        "Unable to move perfetto output file from %s to %s due to %s",
-                        PERFETTO_TMP_OUTPUT_FILE, destinationFile, moveResult));
-                return false;
+            int userId = getCurrentUserId();
+            // For user 0, move the file directly since the content provider is not installed (see
+            // aosp/3284729).
+            boolean useContentProvider = userId != 0 && mShouldUseContentProvider;
+            Log.v(
+                    LOG_TAG,
+                    String.format(
+                            "Going to use content provider to move temp perfetto file: %b. User id:"
+                                + " %d and mShouldUseContentProvider: %b",
+                            useContentProvider, userId, mShouldUseContentProvider));
+            if (!useContentProvider) {
+                String moveResult =
+                        mUIDevice.executeShellCommand(
+                                String.format(MOVE_CMD, PERFETTO_TMP_OUTPUT_FILE, destinationFile));
+                if (!moveResult.isEmpty()) {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "Unable to move perfetto output file from %s to %s due to %s",
+                                    PERFETTO_TMP_OUTPUT_FILE, destinationFile, moveResult));
+                    return false;
+                }
+                return true;
             }
+
+            // For users other than 0, use the tradefed content provider.
+            UiAutomation uiAutomation =
+                    InstrumentationRegistry.getInstrumentation().getUiAutomation();
+
+            // cat the trace file. This is necessary because the test app doesn't have access to
+            // /data/misc/perfetto-traces.
+            String cmd = String.format("cat %s", PERFETTO_TMP_OUTPUT_FILE);
+            ParcelFileDescriptor fdCatStdout = uiAutomation.executeShellCommand(cmd);
+
+            // Use 'content write' to write the trace to the destination file.
+            String uri =
+                    String.format("content://android.tradefed.contentprovider/%s", destinationFile);
+            cmd = String.format(Locale.US, "content write --user %d --uri %s", userId, uri);
+            Log.i(LOG_TAG, String.format("Executing: %s", cmd));
+            ParcelFileDescriptor[] fds = uiAutomation.executeShellCommandRwe(cmd);
+            ParcelFileDescriptor fdStdout = fds[0];
+            ParcelFileDescriptor fdStdin = fds[1];
+            ParcelFileDescriptor fdStderr = fds[2];
+
+            // Transfer stdout of 'cat' to stdin of 'content write'.
+            try (AutoCloseOutputStream contentOutputStream = new AutoCloseOutputStream(fdStdin);
+                    AutoCloseInputStream catInputStream = new AutoCloseInputStream(fdCatStdout)) {
+                catInputStream.transferTo(contentOutputStream);
+            }
+
+            // Check stdout and stderr of 'content write'.
+            try (AutoCloseInputStream stdoutInputStream = new AutoCloseInputStream(fdStdout);
+                    AutoCloseInputStream stderrInputStream = new AutoCloseInputStream(fdStderr)) {
+                String stdout = new String(stdoutInputStream.readAllBytes());
+                String stderr = new String(stderrInputStream.readAllBytes());
+                if (!stdout.isEmpty() || !stderr.isEmpty()) {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "'content write' failed:\nstdout: %s\nstderr: %s",
+                                    stdout, stderr));
+                    return false;
+                }
+            }
+
+            // Delete the trace file from the temporary location.
+            mUIDevice.executeShellCommand(String.format(REMOVE_CMD, PERFETTO_TMP_OUTPUT_FILE));
+
         } catch (IOException ioe) {
-            Log.e(LOG_TAG,
-                    "Unable to move the perfetto trace file to destination file."
-                            + ioe.getMessage());
+            Log.e(
+                    LOG_TAG,
+                    String.format(
+                            "Unable to move the perfetto trace file from %s to %s",
+                            PERFETTO_TMP_OUTPUT_FILE, destinationFile),
+                    ioe);
             return false;
         }
+
         return true;
     }
 
@@ -543,4 +616,8 @@ public class PerfettoHelper {
     public String getPerfettoFilePrefix() {
         return PERFETTO_PID_FILE_PREFIX;
     }
+
+    public void setShouldUseContentProvider(boolean shouldUseContentProvider) {
+        mShouldUseContentProvider = shouldUseContentProvider;
+    }
 }
diff --git a/libraries/compatibility-common-util/Android.bp b/libraries/compatibility-common-util/Android.bp
index 6095f31aa..530269a0b 100644
--- a/libraries/compatibility-common-util/Android.bp
+++ b/libraries/compatibility-common-util/Android.bp
@@ -50,3 +50,17 @@ java_library {
     // b/267831518: Pin tradefed and dependencies to Java 11.
     java_version: "11",
 }
+
+java_library_static {
+    name: "xts-annotations",
+    host_supported: true,
+    srcs: [
+        "src/com/android/compatibility/common/util/GmsTest.java",
+        "src/com/android/compatibility/common/util/CddTest.java",
+        "src/com/android/compatibility/common/util/VsrTest.java",
+        "src/com/android/compatibility/common/util/ApiTest.java",
+    ],
+    sdk_version: "current", // To allow use from CTS
+    // b/267831518: Pin tradefed and dependencies to Java 11.
+    java_version: "11",
+}
diff --git a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
index 52ed0a0a2..00e11e617 100644
--- a/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
+++ b/libraries/device-collectors/src/main/java/android/device/collectors/PerfettoTracingStrategy.java
@@ -98,6 +98,8 @@ public abstract class PerfettoTracingStrategy {
     // For USB disconnected cases you may want this option to be true. This option makes sure
     // the device does not go to sleep while collecting.
     public static final String PERFETTO_START_BG_WAIT = "perfetto_start_bg_wait";
+    // Argument to indicate whenever to move the temp trace using tf contend provider.
+    public static final String SHOULD_USE_CONTENT_PROVIDER = "perfetto_should_use_content_provider";
 
     @VisibleForTesting
     static final String HOLD_WAKELOCK_WHILE_COLLECTING = "hold_wakelock_while_collecting";
@@ -429,7 +431,7 @@ public abstract class PerfettoTracingStrategy {
                 args.getString(PERFETTO_CONFIG_OUTPUT_FILE_PREFIX, DEFAULT_PERFETTO_PREFIX);
 
         mPerfettoHelper.setTrackPerfettoPidFlag(
-                Boolean.parseBoolean(args.getString(PERFETTO_PERSIST_PID_TRACK)));
+                Boolean.parseBoolean(args.getString(PERFETTO_PERSIST_PID_TRACK, "true")));
         if (mPerfettoHelper.getTrackPerfettoPidFlag()) {
             mPerfettoHelper.setTrackPerfettoRootDir(
                     args.getString(PERFETTO_PID_TRACK_ROOT, DEFAULT_PERFETTO_PID_TRACK_ROOT));
@@ -459,6 +461,11 @@ public abstract class PerfettoTracingStrategy {
         // By default, this flag is set to false to collect the metrics on test failure.
         mSkipTestFailureMetrics = "true".equals(args.getString(SKIP_TEST_FAILURE_METRICS));
         mSkipTestSuccessMetrics = "true".equals(args.getString(SKIP_TEST_SUCCESS_METRICS));
+
+        // By default, use content provider to move the trace file.
+        boolean shouldUseContentProvider =
+                Boolean.parseBoolean(args.getString(SHOULD_USE_CONTENT_PROVIDER, "true"));
+        mPerfettoHelper.setShouldUseContentProvider(shouldUseContentProvider);
     }
 
     /**
diff --git a/libraries/device-collectors/src/main/java/android/device/preparers/MemhogPreparer.java b/libraries/device-collectors/src/main/java/android/device/preparers/MemhogPreparer.java
index 7cf82bcd6..ce6d45809 100644
--- a/libraries/device-collectors/src/main/java/android/device/preparers/MemhogPreparer.java
+++ b/libraries/device-collectors/src/main/java/android/device/preparers/MemhogPreparer.java
@@ -20,6 +20,7 @@ import android.device.collectors.DataRecord;
 import android.device.collectors.annotations.OptionClass;
 import android.os.Bundle;
 import android.util.Log;
+
 import com.android.helpers.MemhogHelper;
 
 import org.junit.runner.Description;
@@ -29,7 +30,9 @@ import org.junit.runner.Result;
 public final class MemhogPreparer extends BaseMetricListener {
     private static final String TAG = MemhogPreparer.class.getSimpleName();
     private static final String MEMORY_SIZE_BYTES = "memory_size_bytes";
+    private static final String MODE = "mode";
     private static final String DEFAULT_MEMORY_SIZE_BYTES = "1337";
+    private static final String DEFAULT_MODE = "hog";
 
     private boolean mMemhogStarted;
 
@@ -43,10 +46,13 @@ public final class MemhogPreparer extends BaseMetricListener {
     public void onTestRunStart(DataRecord runData, Description description) {
         Bundle args = getArgsBundle();
 
+        String mMode = args.getString(MODE, DEFAULT_MODE);
+
         // Amount of memory (in bytes) to be allocated.
         long mMemorySizeBytes =
                 Long.parseLong(args.getString(MEMORY_SIZE_BYTES, DEFAULT_MEMORY_SIZE_BYTES));
-        mMemhogStarted = mMemhogHelper.startMemhog(mMemorySizeBytes);
+
+        mMemhogStarted = mMemhogHelper.startMemhog(mMode, mMemorySizeBytes);
         if (!mMemhogStarted) {
             throw new IllegalStateException("Memhog failed to start.");
         }
diff --git a/libraries/flag-helpers/junit/Android.bp b/libraries/flag-helpers/junit/Android.bp
index a5c837cdd..f842b6840 100644
--- a/libraries/flag-helpers/junit/Android.bp
+++ b/libraries/flag-helpers/junit/Android.bp
@@ -59,6 +59,7 @@ java_library_host {
     name: "flag-junit-host",
     srcs: ["src_host/**/*.java"],
     static_libs: [
+        "aconfig_host_device_paths_java",
         "flag-junit-base",
         "flag-util",
         "libaconfig_java_proto_full",
diff --git a/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/DeviceFlags.java b/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/DeviceFlags.java
index 7149a2269..3fa247ebe 100644
--- a/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/DeviceFlags.java
+++ b/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/DeviceFlags.java
@@ -19,6 +19,7 @@ package android.platform.test.flag.junit.host;
 import android.aconfig.Aconfig.flag_permission;
 import android.aconfig.Aconfig.flag_state;
 import android.aconfig.Aconfig.parsed_flags;
+import android.aconfig.HostDeviceProtos;
 import android.platform.test.flag.util.Flag;
 import android.platform.test.flag.util.FlagReadException;
 
@@ -53,13 +54,6 @@ import javax.annotation.Nullable;
 public class DeviceFlags {
     private static final String DUMP_DEVICE_CONFIG_CMD = "device_config list";
 
-    /**
-     * Partitions that contain the aconfig_flags.pb files. Should be consistent with the partitions
-     * defined in core/packaging/flags.mk.
-     */
-    private static final List<String> FLAG_PARTITIONS =
-            List.of("product", "system", "system_ext", "vendor");
-
     /**
      * The key is the flag name with namespace ({namespace}/{flagName} for legacy flags,
      * {namespace}/{packageName}.{flagName} for aconfig flags.
@@ -146,10 +140,26 @@ public class DeviceFlags {
     private parsed_flags getAconfigParsedFlags(ITestDevice testDevice) throws FlagReadException {
         parsed_flags.Builder builder = parsed_flags.newBuilder();
 
-        for (String flagPartition : FLAG_PARTITIONS) {
+        List<String> protoPaths =
+                HostDeviceProtos.parsedFlagsProtoPaths(
+                        command -> {
+                            try {
+                                // TODO(b/365157972): get the proto paths on user build devices.
+                                if (testDevice.getProperty("ro.build.type").equals("user")) {
+                                    return "";
+                                }
+
+                                String adbResult = testDevice.executeAdbCommand(command.split(" "));
+                                LogUtil.CLog.i(
+                                        "Adb command result for '%s': %s", command, adbResult);
+                                return adbResult;
+                            } catch (DeviceNotAvailableException e) {
+                                throw new FlagReadException("ALL_FLAGS", e);
+                            }
+                        });
+
+        for (String aconfigFlagsPbFilePath : protoPaths) {
             try {
-                String aconfigFlagsPbFilePath =
-                        String.format("/%s/etc/aconfig_flags.pb", flagPartition);
                 if (!testDevice.doesFileExist(aconfigFlagsPbFilePath)) {
                     LogUtil.CLog.i("Aconfig flags file %s does not exist", aconfigFlagsPbFilePath);
                     continue;
diff --git a/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/HostFlagsValueProvider.java b/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/HostFlagsValueProvider.java
index b0328944c..9925bb82d 100644
--- a/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/HostFlagsValueProvider.java
+++ b/libraries/flag-helpers/junit/src_host/android/platform/test/flag/junit/host/HostFlagsValueProvider.java
@@ -21,6 +21,7 @@ import android.platform.test.flag.junit.IFlagsValueProvider;
 import android.platform.test.flag.util.FlagReadException;
 
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.log.LogUtil;
 
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
@@ -95,7 +96,8 @@ public class HostFlagsValueProvider implements IFlagsValueProvider {
         String value = mDeviceFlags.getFlagValue(flag);
 
         if (value == null) {
-            throw new FlagReadException(flag, "Flag does not exist.");
+            LogUtil.CLog.i("Flag %s is not found, treating as false.", flag);
+            return false;
         }
 
         if (!IFlagsValueProvider.isBooleanValue(value)) {
diff --git a/libraries/flag-helpers/junit/test/src/android/platform/test/flag/junit/example/ExampleFlagsParameterizedTest.java b/libraries/flag-helpers/junit/test/src/android/platform/test/flag/junit/example/ExampleFlagsParameterizedTest.java
index b117ea475..7cedf639b 100644
--- a/libraries/flag-helpers/junit/test/src/android/platform/test/flag/junit/example/ExampleFlagsParameterizedTest.java
+++ b/libraries/flag-helpers/junit/test/src/android/platform/test/flag/junit/example/ExampleFlagsParameterizedTest.java
@@ -16,10 +16,8 @@
 
 package android.platform.test.flag.junit.example;
 
-import static android.platform.test.flag.junit.SetFlagsRule.DefaultInitValueType.NULL_DEFAULT;
 
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 import android.platform.test.annotations.DisableFlags;
@@ -66,26 +64,26 @@ public class ExampleFlagsParameterizedTest {
 
     @Rule public final SetFlagsRule mSetFlagsRule;
 
-    // assertNotNull is used to call out when a flag is accessible
+    // unused variables are used to call out when a flag is accessible
     // but will have different values depending on the parameterization.
 
     @Test
     public void runTestWithAllFlagCombinations() {
-        assertNotNull(Flags.flagName3());
-        assertNotNull(Flags.flagName4());
+        boolean unusedFlag3 = Flags.flagName3();
+        boolean unusedFlag4 = Flags.flagName4();
     }
 
     @Test
     @EnableFlags(Flags.FLAG_FLAG_NAME3)
     public void runTestWithFlag3Enabled() {
         assertTrue(Flags.flagName3());
-        assertNotNull(Flags.flagName4());
+        boolean unusedFlag4 = Flags.flagName4();
     }
 
     @Test
     @DisableFlags(Flags.FLAG_FLAG_NAME4)
     public void runTestWithFlag4Disabled() {
-        assertNotNull(Flags.flagName3());
+        boolean unusedFlag3 = Flags.flagName3();
         assertFalse(Flags.flagName4());
     }
 
diff --git a/libraries/flicker/appHelpers/Android.bp b/libraries/flicker/appHelpers/Android.bp
index 922f08306..036c894c7 100644
--- a/libraries/flicker/appHelpers/Android.bp
+++ b/libraries/flicker/appHelpers/Android.bp
@@ -28,6 +28,7 @@ java_library {
         "src/**/apphelpers/*.kt",
     ],
     static_libs: [
+        "flickerlib-helpers",
         "flickerlib-parsers",
         "launcher-aosp-tapl",
     ],
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BasePipAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BasePipAppHelper.kt
new file mode 100644
index 000000000..955529069
--- /dev/null
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BasePipAppHelper.kt
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.device.apphelpers
+
+import android.app.Instrumentation
+import android.graphics.Rect
+import android.graphics.Region
+import android.tools.datatypes.coversMoreThan
+import android.tools.helpers.FIND_TIMEOUT
+import android.tools.helpers.GestureHelper
+import android.tools.helpers.SYSTEMUI_PACKAGE
+import android.tools.traces.ConditionsFactory
+import android.tools.traces.component.IComponentNameMatcher
+import android.tools.traces.parsers.WindowManagerStateHelper
+import android.util.Log
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.Until
+
+abstract class BasePipAppHelper(
+    instrumentation: Instrumentation,
+    appName: String,
+    componentMatcher: IComponentNameMatcher,
+) : StandardAppHelper(instrumentation, appName, componentMatcher), PipApp {
+    private val gestureHelper: GestureHelper = GestureHelper(instrumentation)
+
+    open fun clickObject(resId: String) {
+        val selector = By.res(packageName, resId)
+        val obj = uiDevice.findObject(selector) ?: error("Could not find `$resId` object")
+
+        obj.click()
+    }
+
+    override fun waitForPip(wmHelper: WindowManagerStateHelper) {
+        wmHelper
+            .StateSyncBuilder()
+            .withWindowSurfaceAppeared(this)
+            .withPipShown()
+            .waitForAndVerify()
+    }
+
+    /** Drags the PIP window to the provided final coordinates without releasing the pointer. */
+    override fun dragPipWindowAwayFromEdgeWithoutRelease(
+        wmHelper: WindowManagerStateHelper,
+        steps: Int,
+    ) {
+        val initWindowRect = Rect(getWindowRect(wmHelper))
+
+        // initial pointer at the center of the window
+        val initialCoord =
+            GestureHelper.Tuple(
+                initWindowRect.centerX().toFloat(),
+                initWindowRect.centerY().toFloat(),
+            )
+
+        // the offset to the right (or left) of the window center to drag the window to
+        val offset = 50
+
+        // the actual final x coordinate with the offset included;
+        // if the pip window is closer to the right edge of the display the offset is negative
+        // otherwise the offset is positive
+        val endX =
+            initWindowRect.centerX() + offset * (if (isCloserToRightEdge(wmHelper)) -1 else 1)
+        val finalCoord = GestureHelper.Tuple(endX.toFloat(), initWindowRect.centerY().toFloat())
+
+        // drag to the final coordinate
+        gestureHelper.dragWithoutRelease(initialCoord, finalCoord, steps)
+    }
+
+    /**
+     * Releases the primary pointer.
+     *
+     * Injects the release of the primary pointer if the primary pointer info was cached after
+     * another gesture was injected without pointer release.
+     */
+    override fun releasePipAfterDragging() {
+        gestureHelper.releasePrimaryPointer()
+    }
+
+    /**
+     * Drags the PIP window away from the screen edge while not crossing the display center.
+     *
+     * @throws IllegalStateException if default display bounds are not available
+     */
+    override fun dragPipWindowAwayFromEdge(wmHelper: WindowManagerStateHelper, steps: Int) {
+        val initWindowRect = Rect(getWindowRect(wmHelper))
+
+        // initial pointer at the center of the window
+        val startX = initWindowRect.centerX()
+        val y = initWindowRect.centerY()
+
+        val displayRect =
+            wmHelper.currentState.wmState.getDefaultDisplay()?.displayRect
+                ?: throw IllegalStateException("Default display is null")
+
+        // the offset to the right (or left) of the display center to drag the window to
+        val offset = 20
+
+        // the actual final x coordinate with the offset included;
+        // if the pip window is closer to the right edge of the display the offset is positive
+        // otherwise the offset is negative
+        val endX = displayRect.centerX() + offset * (if (isCloserToRightEdge(wmHelper)) 1 else -1)
+
+        // drag the window to the left but not beyond the center of the display
+        uiDevice.drag(startX, y, endX, y, steps)
+    }
+
+    /**
+     * Returns true if PIP window is closer to the right edge of the display than left.
+     *
+     * @throws IllegalStateException if default display bounds are not available
+     */
+    override fun isCloserToRightEdge(wmHelper: WindowManagerStateHelper): Boolean {
+        val windowRect = getWindowRect(wmHelper)
+
+        val displayRect =
+            wmHelper.currentState.wmState.getDefaultDisplay()?.displayRect
+                ?: throw IllegalStateException("Default display is null")
+
+        return windowRect.centerX() > displayRect.centerX()
+    }
+
+    /**
+     * Expands the PIP window by using the pinch out gesture.
+     *
+     * @param percent The percentage by which to increase the pip window size.
+     * @throws IllegalArgumentException if percentage isn't between 0.0f and 1.0f
+     */
+    override fun pinchOpenPipWindow(
+        wmHelper: WindowManagerStateHelper,
+        percent: Float,
+        steps: Int,
+    ) {
+        // the percentage must be between 0.0f and 1.0f
+        if (percent <= 0.0f || percent > 1.0f) {
+            throw IllegalArgumentException("Percent must be between 0.0f and 1.0f")
+        }
+
+        val windowRect = getWindowRect(wmHelper)
+
+        // first pointer's initial x coordinate is halfway between the left edge and the center
+        val initLeftX = (windowRect.centerX() - windowRect.width() / 4).toFloat()
+        // second pointer's initial x coordinate is halfway between the right edge and the center
+        val initRightX = (windowRect.centerX() + windowRect.width() / 4).toFloat()
+
+        // horizontal distance the window should increase by
+        val distIncrease = windowRect.width() * percent
+
+        // final x-coordinates
+        val finalLeftX = initLeftX - (distIncrease / 2)
+        val finalRightX = initRightX + (distIncrease / 2)
+
+        // y-coordinate is the same throughout this animation
+        val yCoord = windowRect.centerY().toFloat()
+
+        var adjustedSteps = MIN_STEPS_TO_ANIMATE
+
+        // if distance per step is at least 1, then we can use the number of steps requested
+        if (distIncrease.toInt() / (steps * 2) >= 1) {
+            adjustedSteps = steps
+        }
+
+        // if the distance per step is less than 1, carry out the animation in two steps
+        gestureHelper.pinch(
+            GestureHelper.Tuple(initLeftX, yCoord),
+            GestureHelper.Tuple(initRightX, yCoord),
+            GestureHelper.Tuple(finalLeftX, yCoord),
+            GestureHelper.Tuple(finalRightX, yCoord),
+            adjustedSteps,
+        )
+
+        waitForPipWindowToExpandFrom(wmHelper, Region(windowRect))
+    }
+
+    /**
+     * Minimizes the PIP window by using the pinch in gesture.
+     *
+     * @param percent The percentage by which to decrease the pip window size.
+     * @throws IllegalArgumentException if percentage isn't between 0.0f and 1.0f
+     */
+    override fun pinchInPipWindow(wmHelper: WindowManagerStateHelper, percent: Float, steps: Int) {
+        // the percentage must be between 0.0f and 1.0f
+        if (percent <= 0.0f || percent > 1.0f) {
+            throw IllegalArgumentException("Percent must be between 0.0f and 1.0f")
+        }
+
+        val windowRect = getWindowRect(wmHelper)
+
+        // first pointer's initial x coordinate is halfway between the left edge and the center
+        val initLeftX = (windowRect.centerX() - windowRect.width() / 4).toFloat()
+        // second pointer's initial x coordinate is halfway between the right edge and the center
+        val initRightX = (windowRect.centerX() + windowRect.width() / 4).toFloat()
+
+        // decrease by the distance specified through the percentage
+        val distDecrease = windowRect.width() * percent
+
+        // get the final x-coordinates and make sure they are not passing the center of the window
+        val finalLeftX = Math.min(initLeftX + (distDecrease / 2), windowRect.centerX().toFloat())
+        val finalRightX = Math.max(initRightX - (distDecrease / 2), windowRect.centerX().toFloat())
+
+        // y-coordinate is the same throughout this animation
+        val yCoord = windowRect.centerY().toFloat()
+
+        var adjustedSteps = MIN_STEPS_TO_ANIMATE
+
+        // if distance per step is at least 1, then we can use the number of steps requested
+        if (distDecrease.toInt() / (steps * 2) >= 1) {
+            adjustedSteps = steps
+        }
+
+        // if the distance per step is less than 1, carry out the animation in two steps
+        gestureHelper.pinch(
+            GestureHelper.Tuple(initLeftX, yCoord),
+            GestureHelper.Tuple(initRightX, yCoord),
+            GestureHelper.Tuple(finalLeftX, yCoord),
+            GestureHelper.Tuple(finalRightX, yCoord),
+            adjustedSteps,
+        )
+
+        waitForPipWindowToMinimizeFrom(wmHelper, Region(windowRect))
+    }
+
+    /** Returns the pip window bounds. */
+    override fun getWindowRect(wmHelper: WindowManagerStateHelper): Rect {
+        val windowRegion = wmHelper.getWindowRegion(this)
+        require(!windowRegion.isEmpty) { "Unable to find a PIP window in the current state" }
+        return windowRegion.bounds
+    }
+
+    /** Taps the pip window and dismisses it by clicking on the X button. */
+    open fun closePipWindow(wmHelper: WindowManagerStateHelper) {
+        val windowRect = getWindowRect(wmHelper)
+        uiDevice.click(windowRect.centerX(), windowRect.centerY())
+        // search and interact with the dismiss button
+        val dismissSelector = By.res(SYSTEMUI_PACKAGE, "dismiss")
+        uiDevice.wait(Until.hasObject(dismissSelector), FIND_TIMEOUT)
+        val dismissPipObject =
+            uiDevice.findObject(dismissSelector) ?: error("PIP window dismiss button not found")
+        val dismissButtonBounds = dismissPipObject.visibleBounds
+        uiDevice.click(dismissButtonBounds.centerX(), dismissButtonBounds.centerY())
+
+        // Wait for animation to complete.
+        wmHelper.StateSyncBuilder().withPipGone().withHomeActivityVisible().waitForAndVerify()
+    }
+
+    open fun tapPipToShowMenu(wmHelper: WindowManagerStateHelper) {
+        val windowRect = getWindowRect(wmHelper)
+        uiDevice.click(windowRect.centerX(), windowRect.centerY())
+        // search and interact with the dismiss button
+        val dismissSelector = By.res(SYSTEMUI_PACKAGE, "dismiss")
+        uiDevice.wait(Until.hasObject(dismissSelector), FIND_TIMEOUT)
+    }
+
+    /** Close the pip window by pressing the expand button */
+    fun expandPipWindowToApp(wmHelper: WindowManagerStateHelper) {
+        val windowRect = getWindowRect(wmHelper)
+        uiDevice.click(windowRect.centerX(), windowRect.centerY())
+        // search and interact with the expand button
+        val expandSelector = By.res(SYSTEMUI_PACKAGE, "expand_button")
+        uiDevice.wait(Until.hasObject(expandSelector), FIND_TIMEOUT)
+        val expandPipObject =
+            uiDevice.findObject(expandSelector) ?: error("PIP window expand button not found")
+        val expandButtonBounds = expandPipObject.visibleBounds
+        uiDevice.click(expandButtonBounds.centerX(), expandButtonBounds.centerY())
+        wmHelper.StateSyncBuilder().withPipGone().withFullScreenApp(this).waitForAndVerify()
+    }
+
+    /** Double click on the PIP window to expand it */
+    override fun doubleClickPipWindow(wmHelper: WindowManagerStateHelper) {
+        val windowRect = getWindowRect(wmHelper)
+        Log.d(TAG, "First click")
+        uiDevice.click(windowRect.centerX(), windowRect.centerY())
+        Log.d(TAG, "Second click")
+        uiDevice.click(windowRect.centerX(), windowRect.centerY())
+        Log.d(TAG, "Wait for app transition to end")
+        wmHelper.StateSyncBuilder().withAppTransitionIdle().waitForAndVerify()
+        waitForPipWindowToExpandFrom(wmHelper, Region(windowRect))
+    }
+
+    private fun waitForPipWindowToExpandFrom(
+        wmHelper: WindowManagerStateHelper,
+        windowRect: Region,
+    ) {
+        wmHelper
+            .StateSyncBuilder()
+            .add("pipWindowExpanded") {
+                val pipAppWindow =
+                    it.wmState.visibleWindows.firstOrNull { window ->
+                        this.windowMatchesAnyOf(window)
+                    } ?: return@add false
+                val pipRegion = pipAppWindow.frameRegion
+                return@add pipRegion.coversMoreThan(windowRect)
+            }
+            .waitForAndVerify()
+    }
+
+    private fun waitForPipWindowToMinimizeFrom(
+        wmHelper: WindowManagerStateHelper,
+        windowRect: Region,
+    ) {
+        wmHelper
+            .StateSyncBuilder()
+            .add("pipWindowMinimized") {
+                val pipAppWindow =
+                    it.wmState.visibleWindows.firstOrNull { window ->
+                        this.windowMatchesAnyOf(window)
+                    }
+                Log.d(TAG, "window $pipAppWindow")
+                if (pipAppWindow == null) return@add false
+                val pipRegion = pipAppWindow.frameRegion
+                Log.d(
+                    TAG,
+                    "region " + pipRegion + " covers " + windowRect.coversMoreThan(pipRegion),
+                )
+                return@add windowRect.coversMoreThan(pipRegion)
+            }
+            .waitForAndVerify()
+    }
+
+    /**
+     * Waits until the PIP window snaps horizontally to the provided bounds.
+     *
+     * @param finalBounds the bounds to wait for PIP window to snap to
+     */
+    override fun waitForPipToSnapTo(wmHelper: WindowManagerStateHelper, finalBounds: Rect) {
+        wmHelper
+            .StateSyncBuilder()
+            .add("pipWindowSnapped") {
+                val pipAppWindow =
+                    it.wmState.visibleWindows.firstOrNull { window ->
+                        this.windowMatchesAnyOf(window)
+                    } ?: return@add false
+                val pipRegionBounds = pipAppWindow.frameRegion.bounds
+                return@add pipRegionBounds.left == finalBounds.left &&
+                    pipRegionBounds.right == finalBounds.right
+            }
+            .add(ConditionsFactory.isWMStateComplete())
+            .waitForAndVerify()
+    }
+
+    companion object {
+        private const val TAG = "BasePipAppHelper"
+        // minimum number of steps to take, when animating gestures, needs to be 2
+        // so that there is at least a single intermediate layer that flicker tests can check
+        private const val MIN_STEPS_TO_ANIMATE = 2
+    }
+}
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
index b089070c7..994c6f288 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/BrowserAppHelper.kt
@@ -21,6 +21,7 @@ import android.content.Intent
 import android.content.pm.PackageManager
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /**
@@ -35,13 +36,10 @@ class BrowserAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getBrowserName(pkgManager),
-        getBrowserComponent(pkgManager)
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getBrowserName(pkgManager),
+    appComponent: IComponentNameMatcher = getBrowserComponent(pkgManager),
+) : StandardAppHelper(instrumentation, appName, appComponent) {
     override val openAppIntent =
         pkgManager.getLaunchIntentForPackage(packageName)
             ?: error("Unable to find intent for browser")
@@ -62,7 +60,7 @@ constructor(
             return resolveInfo.loadLabel(pkgManager).toString()
         }
 
-        private fun getBrowserComponent(pkgManager: PackageManager): ComponentNameMatcher {
+        private fun getBrowserComponent(pkgManager: PackageManager): IComponentNameMatcher {
             val intent = getBrowserIntent()
             val resolveInfo =
                 pkgManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY)
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalculatorAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalculatorAppHelper.kt
index 78a31fdea..e8b871ed5 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalculatorAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalculatorAppHelper.kt
@@ -18,6 +18,7 @@ package android.tools.device.apphelpers
 
 import android.app.Instrumentation
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /**
@@ -27,12 +28,12 @@ import androidx.test.platform.app.InstrumentationRegistry
  */
 class CalculatorAppHelper
 @JvmOverloads
-constructor(instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()) :
-    StandardAppHelper(
-        instrumentation,
-        "Calculator",
+constructor(
+    instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
+    appName: String = "Calculator",
+    appComponent: IComponentNameMatcher =
         ComponentNameMatcher(
             packageName = "com.google.android.calculator",
-            className = "com.android.calculator2.Calculator"
-        )
-    )
+            className = "com.android.calculator2.Calculator",
+        ),
+) : StandardAppHelper(instrumentation, appName, appComponent)
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalendarAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalendarAppHelper.kt
index 3e9a3b05b..17d58c09f 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalendarAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CalendarAppHelper.kt
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /** Helper to launch the Calendar app. */
@@ -29,13 +30,10 @@ class CalendarAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getCalendarLauncherName(pkgManager),
-        getCalendarComponent(pkgManager)
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getCalendarLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getCalendarComponent(pkgManager),
+) : StandardAppHelper(instrumentation, appName, appComponent) {
     companion object {
         private fun getCalendarIntent(): Intent {
             val epochEventStartTime = 0
@@ -57,7 +55,7 @@ constructor(
             val resolveInfo = getResolveInfo(pkgManager)
             return ComponentNameMatcher(
                 resolveInfo.activityInfo.packageName,
-                className = resolveInfo.activityInfo.name
+                className = resolveInfo.activityInfo.name,
             )
         }
 
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CameraAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CameraAppHelper.kt
index 198973312..61cfd7b46 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CameraAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/CameraAppHelper.kt
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
 import android.provider.MediaStore
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /** Helper to launch the Camera app. */
@@ -29,13 +30,10 @@ class CameraAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getCameraLauncherName(pkgManager),
-        getCameraComponent(pkgManager)
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getCameraLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getCameraComponent(pkgManager),
+) : StandardAppHelper(instrumentation, appName, appComponent) {
 
     override val openAppIntent =
         pkgManager.getLaunchIntentForPackage(packageName)
@@ -51,7 +49,7 @@ constructor(
         private fun getCameraComponent(pkgManager: PackageManager): ComponentNameMatcher =
             ComponentNameMatcher(
                 getResolveInfo(pkgManager).activityInfo.packageName,
-                className = ""
+                className = "",
             )
 
         private fun getCameraLauncherName(pkgManager: PackageManager): String =
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/ClockAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/ClockAppHelper.kt
index ab389f7ea..9afb4f917 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/ClockAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/ClockAppHelper.kt
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
 import android.provider.AlarmClock
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /** Helper to launch the Camera app. */
@@ -29,13 +30,10 @@ class ClockAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getClockLauncherName(pkgManager),
-        getClockComponent(pkgManager)
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getClockLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getClockComponent(pkgManager),
+) : StandardAppHelper(instrumentation, appName, appComponent) {
 
     override val openAppIntent =
         pkgManager.getLaunchIntentForPackage(packageName)
@@ -51,7 +49,7 @@ constructor(
         private fun getClockComponent(pkgManager: PackageManager): ComponentNameMatcher =
             ComponentNameMatcher(
                 getResolveInfo(pkgManager).activityInfo.packageName,
-                className = ""
+                className = "",
             )
 
         private fun getClockLauncherName(pkgManager: PackageManager): String =
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/GmailAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/GmailAppHelper.kt
index 580c8bbff..30c44c98e 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/GmailAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/GmailAppHelper.kt
@@ -18,17 +18,18 @@ package android.tools.device.apphelpers
 
 import android.app.Instrumentation
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /** Helper to launch the Gmail app (not compatible with AOSP) */
 class GmailAppHelper
 @JvmOverloads
-constructor(instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()) :
-    StandardAppHelper(
-        instrumentation,
-        "Gmail",
+constructor(
+    instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
+    appName: String = "Gmail",
+    appComponent: IComponentNameMatcher =
         ComponentNameMatcher(
             packageName = "com.google.android.gm",
-            className = "com.google.android.gm.ConversationListActivityGmail"
-        )
-    )
+            className = "com.google.android.gm.ConversationListActivityGmail",
+        ),
+) : StandardAppHelper(instrumentation, appName, appComponent)
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
index f4bf7c6fa..e9a66bd84 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/IStandardAppHelper.kt
@@ -38,7 +38,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
     fun launchViaIntent(
         expectedPackageName: String = "",
         action: String? = null,
-        stringExtras: Map<String, String> = mapOf()
+        stringExtras: Map<String, String> = mapOf(),
     )
 
     /**
@@ -54,7 +54,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
             wmHelper
                 .StateSyncBuilder()
                 .add(ConditionsFactory.isWMStateComplete())
-                .withAppTransitionIdle()
+                .withAppTransitionIdle(),
     )
 
     /**
@@ -69,7 +69,7 @@ interface IStandardAppHelper : IComponentNameMatcher {
             wmHelper
                 .StateSyncBuilder()
                 .add(ConditionsFactory.isWMStateComplete())
-                .withAppTransitionIdle()
+                .withAppTransitionIdle(),
     )
 
     fun isAvailable(): Boolean
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MapsAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MapsAppHelper.kt
index bc3892b6e..3e71fe0a2 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MapsAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MapsAppHelper.kt
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.UiObject2
@@ -33,13 +34,10 @@ class MapsAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getMapLauncherName(pkgManager),
-        getMapComponent(pkgManager)
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getMapLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getMapComponent(pkgManager),
+) : BasePipAppHelper(instrumentation, appName, appComponent) {
 
     /** Search for a specific query in Maps and select the first address matching the query */
     fun doSearch(query: String) {
@@ -138,9 +136,8 @@ constructor(
             val firstAddressResult =
                 uiDevice.wait(
                     Until.findObject(By.pkg(UI_PACKAGE).clazz(UI_TEXTVIEW_CLASS).text(pattern)),
-                    if (retry == 0) SEARCH_TIMEOUT_IN_MSECS else 0
-                )
-                    ?: continue
+                    if (retry == 0) SEARCH_TIMEOUT_IN_MSECS else 0,
+                ) ?: continue
             firstAddressResult.click()
             uiDevice.waitForIdle()
             return
@@ -155,21 +152,21 @@ constructor(
     private fun getSelectableSearchBar(wait_time: Long = WAIT_TIMEOUT): UiObject2? {
         return uiDevice.wait(
             Until.findObject(By.res(UI_PACKAGE, UI_SELECTABLE_SEARCHBAR_ID)),
-            wait_time
+            wait_time,
         )
     }
 
     private fun getEditableSearchBar(wait_time: Long = WAIT_TIMEOUT): UiObject2? {
         return uiDevice.wait(
             Until.findObject(By.res(UI_PACKAGE, UI_EDITABLE_SEARCHBAR_ID)),
-            wait_time
+            wait_time,
         )
     }
 
     private fun getDirectionsButton(wait_time: Long = WAIT_TIMEOUT): UiObject2? {
         return uiDevice.wait(
             Until.findObject(By.descContains(UI_DIRECTIONS_BUTTON_DESC)),
-            wait_time
+            wait_time,
         )
     }
 
@@ -238,7 +235,7 @@ constructor(
             val resolveInfo = getResolveInfo(pkgManager)
             return ComponentNameMatcher(
                 resolveInfo.activityInfo.packageName,
-                className = resolveInfo.activityInfo.name
+                className = resolveInfo.activityInfo.name,
             )
         }
 
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MessagingAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MessagingAppHelper.kt
index c71497525..460bf6d23 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MessagingAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/MessagingAppHelper.kt
@@ -21,6 +21,7 @@ import android.content.Intent
 import android.content.pm.PackageManager
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.platform.app.InstrumentationRegistry
 
 /**
@@ -32,13 +33,10 @@ class MessagingAppHelper
 @JvmOverloads
 constructor(
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getMessagesName(pkgManager),
-        getMessagesComponent(pkgManager),
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getMessagesName(pkgManager),
+    appComponent: IComponentNameMatcher = getMessagesComponent(pkgManager),
+) : StandardAppHelper(instrumentation, appName, appComponent) {
     override val openAppIntent =
         pkgManager.getLaunchIntentForPackage(packageName) ?: error("Unable to find intent for SMS")
 
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/NetflixAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/NetflixAppHelper.kt
index 48986be92..220d25768 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/NetflixAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/NetflixAppHelper.kt
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.UiObject2
 import androidx.test.uiautomator.Until
@@ -33,13 +34,10 @@ import androidx.test.uiautomator.Until
  */
 class NetflixAppHelper(
     instrumentation: Instrumentation,
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getNetflixLauncherName(pkgManager),
-        getNetflixComponent(pkgManager),
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getNetflixLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getNetflixComponent(pkgManager),
+) : BasePipAppHelper(instrumentation, appName, appComponent) {
 
     fun waitForVideoPlaying() {
         getPauseButton()
@@ -61,7 +59,7 @@ class NetflixAppHelper(
             val netflixVideoIntent =
                 Intent(
                     Intent.ACTION_VIEW,
-                    Uri.parse(String.format(INTENT_WATCH_VIDEO_PATTERN, videoId))
+                    Uri.parse(String.format(INTENT_WATCH_VIDEO_PATTERN, videoId)),
                 )
             netflixVideoIntent.setPackage(PACKAGE_NAME)
             netflixVideoIntent.setClassName(PACKAGE_NAME, WATCH_CLASS_NAME)
@@ -84,7 +82,7 @@ class NetflixAppHelper(
             val resolveInfo = getResolveInfo(pkgManager)
             return ComponentNameMatcher(
                 resolveInfo.activityInfo.packageName,
-                className = resolveInfo.activityInfo.name
+                className = resolveInfo.activityInfo.name,
             )
         }
 
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/PipApp.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/PipApp.kt
new file mode 100644
index 000000000..1baf993a7
--- /dev/null
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/PipApp.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.device.apphelpers
+
+import android.graphics.Rect
+import android.tools.traces.component.IComponentNameMatcher
+import android.tools.traces.parsers.WindowManagerStateHelper
+
+interface PipApp : IStandardAppHelper, IComponentNameMatcher {
+    fun waitForPip(wmHelper: WindowManagerStateHelper)
+
+    fun isCloserToRightEdge(wmHelper: WindowManagerStateHelper): Boolean
+
+    fun pinchOpenPipWindow(wmHelper: WindowManagerStateHelper, percent: Float, steps: Int)
+
+    fun pinchInPipWindow(wmHelper: WindowManagerStateHelper, percent: Float, steps: Int)
+
+    fun getWindowRect(wmHelper: WindowManagerStateHelper): Rect
+
+    fun releasePipAfterDragging()
+
+    fun waitForPipToSnapTo(wmHelper: WindowManagerStateHelper, finalBounds: Rect)
+
+    fun dragPipWindowAwayFromEdgeWithoutRelease(wmHelper: WindowManagerStateHelper, steps: Int)
+
+    fun dragPipWindowAwayFromEdge(wmHelper: WindowManagerStateHelper, steps: Int)
+
+    fun doubleClickPipWindow(wmHelper: WindowManagerStateHelper)
+}
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
index 84785bb01..c771c230f 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/StandardAppHelper.kt
@@ -41,7 +41,7 @@ import com.android.launcher3.tapl.LauncherInstrumentation
 open class StandardAppHelper(
     val instrumentation: Instrumentation,
     val appName: String,
-    val componentMatcher: ComponentNameMatcher,
+    val componentMatcher: IComponentNameMatcher,
 ) : IStandardAppHelper, IComponentNameMatcher by componentMatcher {
     constructor(
         instr: Instrumentation,
@@ -62,8 +62,6 @@ open class StandardAppHelper(
 
     override val packageName = componentMatcher.packageName
 
-    val packageNameMatcher = ComponentNameMatcher(componentMatcher.packageName, "")
-
     override val className = componentMatcher.className
 
     protected val uiDevice: UiDevice = UiDevice.getInstance(instrumentation)
@@ -124,7 +122,7 @@ open class StandardAppHelper(
 
     private fun launchAppViaIntent(
         action: String? = null,
-        stringExtras: Map<String, String> = mapOf()
+        stringExtras: Map<String, String> = mapOf(),
     ) {
         withTracing("${this::class.simpleName}#launchAppViaIntent") {
             val intent = openAppIntent
@@ -138,7 +136,7 @@ open class StandardAppHelper(
     override fun launchViaIntent(
         expectedPackageName: String,
         action: String?,
-        stringExtras: Map<String, String>
+        stringExtras: Map<String, String>,
     ) {
         launchAppViaIntent(action, stringExtras)
         val appSelector = getAppSelector(expectedPackageName)
@@ -151,7 +149,7 @@ open class StandardAppHelper(
         launchedAppComponentMatcherOverride: IComponentMatcher?,
         action: String?,
         stringExtras: Map<String, String>,
-        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder
+        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
     ) {
         launchAppViaIntent(action, stringExtras)
         doWaitShown(launchedAppComponentMatcherOverride, waitConditionsBuilder)
@@ -162,7 +160,7 @@ open class StandardAppHelper(
         wmHelper: WindowManagerStateHelper,
         intent: Intent,
         launchedAppComponentMatcherOverride: IComponentMatcher?,
-        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder
+        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
     ) {
         withTracing("${this::class.simpleName}#launchViaIntent") {
             context.startActivity(intent)
@@ -172,7 +170,7 @@ open class StandardAppHelper(
 
     private fun doWaitShown(
         launchedAppComponentMatcherOverride: IComponentMatcher? = null,
-        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder
+        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
     ) {
         withTracing("${this::class.simpleName}#doWaitShown") {
             val expectedWindow = launchedAppComponentMatcherOverride ?: componentMatcher
@@ -196,7 +194,7 @@ open class StandardAppHelper(
 
     private fun doWaitShownHeavy(
         expectedWindow: IComponentMatcher,
-        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder
+        waitConditionsBuilder: WindowManagerStateHelper.StateSyncBuilder,
     ) {
         val builder = waitConditionsBuilder.withWindowSurfaceAppeared(expectedWindow)
         builder.waitForAndVerify()
diff --git a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/YouTubeAppHelper.kt b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/YouTubeAppHelper.kt
index e30190f99..f4a71a265 100644
--- a/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/YouTubeAppHelper.kt
+++ b/libraries/flicker/appHelpers/src/android/tools/device/apphelpers/YouTubeAppHelper.kt
@@ -23,6 +23,7 @@ import android.content.pm.ResolveInfo
 import android.graphics.Rect
 import android.net.Uri
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.IComponentNameMatcher
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.UiObject2
 import androidx.test.uiautomator.Until
@@ -34,13 +35,10 @@ import androidx.test.uiautomator.Until
  */
 class YouTubeAppHelper(
     instrumentation: Instrumentation,
-    pkgManager: PackageManager = instrumentation.context.packageManager
-) :
-    StandardAppHelper(
-        instrumentation,
-        getYoutubeLauncherName(pkgManager),
-        getYoutubeComponent(pkgManager),
-    ) {
+    pkgManager: PackageManager = instrumentation.context.packageManager,
+    appName: String = getYoutubeLauncherName(pkgManager),
+    appComponent: IComponentNameMatcher = getYoutubeComponent(pkgManager),
+) : BasePipAppHelper(instrumentation, appName, appComponent) {
 
     fun waitForVideoPlaying() {
         displayControls()
@@ -49,10 +47,7 @@ class YouTubeAppHelper(
 
     fun enterFullscreen() {
         displayControls()
-        val fullscreenButton = getFullscreenButton()
-        if (fullscreenButton != null) {
-            fullscreenButton.click()
-        }
+        getFullscreenButton()?.click()
     }
 
     /**
@@ -102,7 +97,7 @@ class YouTubeAppHelper(
             val youTubeVideoIntent =
                 Intent(
                     Intent.ACTION_VIEW,
-                    Uri.parse(String.format(INTENT_WATCH_VIDEO_PATTERN, videoId))
+                    Uri.parse(String.format(INTENT_WATCH_VIDEO_PATTERN, videoId)),
                 )
             youTubeVideoIntent.setPackage(PACKAGE_NAME)
             youTubeVideoIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
@@ -124,7 +119,7 @@ class YouTubeAppHelper(
             val resolveInfo = getResolveInfo(pkgManager)
             return ComponentNameMatcher(
                 resolveInfo.activityInfo.packageName,
-                className = resolveInfo.activityInfo.name
+                className = resolveInfo.activityInfo.name,
             )
         }
 
diff --git a/libraries/flicker/src/android/tools/device/flicker/rules/FlickerServiceRule.kt b/libraries/flicker/src/android/tools/device/flicker/rules/FlickerServiceRule.kt
index c3e1e3515..02a3cfcac 100644
--- a/libraries/flicker/src/android/tools/device/flicker/rules/FlickerServiceRule.kt
+++ b/libraries/flicker/src/android/tools/device/flicker/rules/FlickerServiceRule.kt
@@ -18,7 +18,7 @@ package android.tools.device.flicker.rules
 
 @Deprecated(
     "Please use the version in the android.tools.flicker.rules package instead",
-    replaceWith = ReplaceWith("android.tools.flicker.rules.FlickerServiceRule")
+    replaceWith = ReplaceWith("android.tools.flicker.rules.FlickerServiceRule"),
 )
 class FlickerServiceRule(enabled: Boolean = true, failTestOnFlicker: Boolean = enabled) :
     android.tools.flicker.rules.FlickerServiceRule(enabled, failTestOnFlicker)
diff --git a/libraries/flicker/src/android/tools/flicker/AssertionInvocationGroup.kt b/libraries/flicker/src/android/tools/flicker/AssertionInvocationGroup.kt
index 6ea98017d..e5bf51761 100644
--- a/libraries/flicker/src/android/tools/flicker/AssertionInvocationGroup.kt
+++ b/libraries/flicker/src/android/tools/flicker/AssertionInvocationGroup.kt
@@ -18,5 +18,5 @@ package android.tools.flicker
 
 enum class AssertionInvocationGroup {
     BLOCKING,
-    NON_BLOCKING
+    NON_BLOCKING,
 }
diff --git a/libraries/flicker/src/android/tools/flicker/FlickerServiceResultsCollector.kt b/libraries/flicker/src/android/tools/flicker/FlickerServiceResultsCollector.kt
index 8ef0babcd..1b7ff4d55 100644
--- a/libraries/flicker/src/android/tools/flicker/FlickerServiceResultsCollector.kt
+++ b/libraries/flicker/src/android/tools/flicker/FlickerServiceResultsCollector.kt
@@ -40,13 +40,15 @@ import org.junit.runner.notification.Failure
  * Collects all the Flicker Service's metrics which are then uploaded for analysis and monitoring to
  * the CrystalBall database.
  */
-class FlickerServiceResultsCollector(
+class FlickerServiceResultsCollector
+@JvmOverloads
+constructor(
     private val tracesCollector: TracesCollector,
     private val flickerService: FlickerService =
         FlickerService(FlickerConfig().use(FlickerServiceConfig.DEFAULT)),
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
     private val collectMetricsPerTest: Boolean = true,
-    private val reportOnlyForPassingTests: Boolean = true
+    private val reportOnlyForPassingTests: Boolean = true,
 ) : BaseMetricListener(), IFlickerServiceResultsCollector {
     private var hasFailedTest = false
     private var testSkipped = false
@@ -151,7 +153,7 @@ class FlickerServiceResultsCollector(
                 testData,
                 results,
                 testScenario ?: error("Test scenario should not be null"),
-                testData
+                testData,
             )
         }
     }
@@ -175,7 +177,7 @@ class FlickerServiceResultsCollector(
                 runData,
                 results,
                 testRunScenario ?: error("Test run scenario should not be null"),
-                runData
+                runData,
             )
         }
     }
@@ -183,7 +185,7 @@ class FlickerServiceResultsCollector(
     private fun collectFlickerMetrics(
         dataRecord: DataRecord,
         reader: Reader,
-        description: Description? = null
+        description: Description? = null,
     ): Collection<AssertionResult>? {
         return errorReportingBlock {
             return@errorReportingBlock try {
@@ -239,7 +241,7 @@ class FlickerServiceResultsCollector(
 
     private fun collectMetrics(
         data: DataRecord,
-        aggregatedResults: Map<String, AggregatedFlickerResult>
+        aggregatedResults: Map<String, AggregatedFlickerResult>,
     ) {
         val it = aggregatedResults.entries.iterator()
 
@@ -284,7 +286,7 @@ class FlickerServiceResultsCollector(
         record: DataRecord,
         results: Collection<AssertionResult>?,
         scenario: Scenario,
-        dataRecord: DataRecord
+        dataRecord: DataRecord,
     ) {
         val status = if (executionErrors.isEmpty()) OK_STATUS_CODE else EXECUTION_ERROR_STATUS_CODE
         record.addStringMetric(FAAS_STATUS_KEY, status.toString())
diff --git a/libraries/flicker/src/android/tools/flicker/FlickerServiceTracesCollector.kt b/libraries/flicker/src/android/tools/flicker/FlickerServiceTracesCollector.kt
index cda41c59a..68b89dabe 100644
--- a/libraries/flicker/src/android/tools/flicker/FlickerServiceTracesCollector.kt
+++ b/libraries/flicker/src/android/tools/flicker/FlickerServiceTracesCollector.kt
@@ -28,9 +28,9 @@ import android.util.Log
 import java.io.File
 import kotlin.io.path.createTempDirectory
 
-class FlickerServiceTracesCollector(
-    private val outputDir: File = createTempDirectory().toFile(),
-) : TracesCollector {
+class FlickerServiceTracesCollector
+@JvmOverloads
+constructor(private val outputDir: File = createTempDirectory().toFile()) : TracesCollector {
     private var scenario: Scenario? = null
 
     private val traceMonitors = ALL_MONITORS.filter { it.traceType != TraceType.SCREEN_RECORDING }
diff --git a/libraries/flicker/src/android/tools/flicker/FlickerTag.kt b/libraries/flicker/src/android/tools/flicker/FlickerTag.kt
index d67bbca89..452ca00b7 100644
--- a/libraries/flicker/src/android/tools/flicker/FlickerTag.kt
+++ b/libraries/flicker/src/android/tools/flicker/FlickerTag.kt
@@ -17,6 +17,6 @@
 package android.tools.flicker
 
 object FlickerTag {
-    val TRANSITION_START = 89001
-    val TRANSITION_END = 89002
+    const val TRANSITION_START = 89001
+    const val TRANSITION_END = 89002
 }
diff --git a/libraries/flicker/src/android/tools/flicker/IFlickerServiceResultsCollector.kt b/libraries/flicker/src/android/tools/flicker/IFlickerServiceResultsCollector.kt
index 72d684e5a..08f64a214 100644
--- a/libraries/flicker/src/android/tools/flicker/IFlickerServiceResultsCollector.kt
+++ b/libraries/flicker/src/android/tools/flicker/IFlickerServiceResultsCollector.kt
@@ -23,10 +23,16 @@ import org.junit.runner.notification.Failure
 
 interface IFlickerServiceResultsCollector {
     val executionErrors: List<Throwable>
+
     fun testStarted(description: Description)
+
     fun testFailure(failure: Failure)
+
     fun testSkipped(description: Description)
+
     fun testFinished(description: Description)
+
     fun resultsForTest(description: Description): Collection<AssertionResult>
+
     fun detectedScenariosForTest(description: Description): Collection<ScenarioId>
 }
diff --git a/libraries/flicker/src/android/tools/flicker/ScenarioInstanceImpl.kt b/libraries/flicker/src/android/tools/flicker/ScenarioInstanceImpl.kt
index ff828c60b..451591bfa 100644
--- a/libraries/flicker/src/android/tools/flicker/ScenarioInstanceImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/ScenarioInstanceImpl.kt
@@ -28,7 +28,9 @@ import android.tools.traces.events.ICujType
 import android.tools.traces.wm.Transition
 import android.tools.withTracing
 
-data class ScenarioInstanceImpl(
+data class ScenarioInstanceImpl
+@JvmOverloads
+constructor(
     override val config: FlickerConfigEntry,
     override val startRotation: Rotation,
     override val endRotation: Rotation,
@@ -66,7 +68,7 @@ data class ScenarioInstanceImpl(
                     reader,
                     template.createAssertions(this),
                     stabilityGroup,
-                    assertionExtraData
+                    assertionExtraData,
                 )
             }
         }
@@ -74,10 +76,11 @@ data class ScenarioInstanceImpl(
     override fun toString() = key
 
     companion object {
+        @JvmStatic
         fun fromSlice(
             traceSlice: TraceSlice,
             reader: Reader,
-            config: FlickerConfigEntry
+            config: FlickerConfigEntry,
         ): ScenarioInstanceImpl {
             val layersTrace = reader.readLayersTrace() ?: error("Missing layers trace")
             val startTimestamp = traceSlice.startTimestamp
@@ -96,7 +99,7 @@ data class ScenarioInstanceImpl(
                 endTimestamp = endTimestamp,
                 associatedCuj = traceSlice.associatedCuj,
                 associatedTransition = traceSlice.associatedTransition,
-                reader = reader.slice(startTimestamp, endTimestamp)
+                reader = reader.slice(startTimestamp, endTimestamp),
             )
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/TracesCollector.kt b/libraries/flicker/src/android/tools/flicker/TracesCollector.kt
index ac0a2eb37..79137b24f 100644
--- a/libraries/flicker/src/android/tools/flicker/TracesCollector.kt
+++ b/libraries/flicker/src/android/tools/flicker/TracesCollector.kt
@@ -21,6 +21,8 @@ import android.tools.io.Reader
 
 interface TracesCollector {
     fun start(scenario: Scenario)
+
     fun stop(): Reader
+
     fun cleanup()
 }
diff --git a/libraries/flicker/src/android/tools/flicker/Utils.kt b/libraries/flicker/src/android/tools/flicker/Utils.kt
index 71bd1c5c3..2e9675c27 100644
--- a/libraries/flicker/src/android/tools/flicker/Utils.kt
+++ b/libraries/flicker/src/android/tools/flicker/Utils.kt
@@ -34,14 +34,16 @@ import android.tools.traces.wm.TransitionChange
 import android.tools.traces.wm.WindowManagerTrace
 import androidx.test.platform.app.InstrumentationRegistry
 import java.io.File
+import java.util.function.Consumer
 import kotlin.io.path.createTempDirectory
 
 object Utils {
     // Order matters since this is used to start traces in the order the monitors are defined here
     // and stop them in reverse order.
+    @JvmField
     val ALL_MONITORS: List<TraceMonitor> =
         mutableListOf<TraceMonitor>(
-                ScreenRecorder(InstrumentationRegistry.getInstrumentation().targetContext),
+                ScreenRecorder(InstrumentationRegistry.getInstrumentation().targetContext)
             )
             .apply {
                 val perfettoMonitorBuilder = PerfettoTraceMonitor.newBuilder()
@@ -82,14 +84,16 @@ object Utils {
                 this.add(EventLogMonitor())
             }
 
+    @JvmStatic
+    @JvmOverloads
     fun captureTrace(
         scenario: Scenario,
         outputDir: File = createTempDirectory().toFile(),
         monitors: List<TraceMonitor> = ALL_MONITORS,
-        actions: (writer: ResultWriter) -> Unit
+        actions: Consumer<ResultWriter>,
     ): Reader {
         val writer = ResultWriter().forScenario(scenario).withOutputDir(outputDir).setRunComplete()
-        monitors.fold({ actions.invoke(writer) }) { action, monitor ->
+        monitors.fold({ actions.accept(writer) }) { action, monitor ->
             { monitor.withTracing(writer) { action() } }
         }()
         val result = writer.write()
@@ -111,7 +115,7 @@ fun String.camelToSnakeCase(): String {
 fun isAppTransitionChange(
     transitionChange: TransitionChange,
     layersTrace: LayersTrace?,
-    wmTrace: WindowManagerTrace?
+    wmTrace: WindowManagerTrace?,
 ): Boolean {
     require(layersTrace != null || wmTrace != null) {
         "Requires at least one of wm of layers trace to not be null"
diff --git a/libraries/flicker/src/android/tools/flicker/annotation/FlickerConfigProvider.kt b/libraries/flicker/src/android/tools/flicker/annotation/FlickerConfigProvider.kt
index c440cff4f..8f3be00fb 100644
--- a/libraries/flicker/src/android/tools/flicker/annotation/FlickerConfigProvider.kt
+++ b/libraries/flicker/src/android/tools/flicker/annotation/FlickerConfigProvider.kt
@@ -19,7 +19,7 @@ package android.tools.flicker.annotation
 @Target(
     AnnotationTarget.FUNCTION,
     AnnotationTarget.PROPERTY_GETTER,
-    AnnotationTarget.PROPERTY_SETTER
+    AnnotationTarget.PROPERTY_SETTER,
 )
 @Retention(AnnotationRetention.RUNTIME)
 annotation class FlickerConfigProvider
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/ArtifactAssertionRunner.kt b/libraries/flicker/src/android/tools/flicker/assertions/ArtifactAssertionRunner.kt
index 2bc654c52..30a6410a2 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/ArtifactAssertionRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/ArtifactAssertionRunner.kt
@@ -31,7 +31,7 @@ import android.tools.withTracing
  */
 class ArtifactAssertionRunner(
     private val result: IResultData,
-    resultReader: Reader = ResultReaderWithLru(result, TRACE_CONFIG_REQUIRE_CHANGES)
+    resultReader: Reader = ResultReaderWithLru(result, TRACE_CONFIG_REQUIRE_CHANGES),
 ) : BaseAssertionRunner(resultReader) {
     override fun doUpdateStatus(newStatus: RunStatus) {
         withTracing("ArtifactAssertionRunner#doUpdateStatus") { result.updateStatus(newStatus) }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/Assertion.kt b/libraries/flicker/src/android/tools/flicker/assertions/Assertion.kt
index 279d61bfe..dbb12441e 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/Assertion.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/Assertion.kt
@@ -24,5 +24,6 @@ package android.tools.flicker.assertions
 interface Assertion<T> {
     val isOptional: Boolean
     val name: String
+
     operator fun invoke(target: T)
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataFactory.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataFactory.kt
index 1fc290d21..d3e67dcf9 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataFactory.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataFactory.kt
@@ -29,7 +29,7 @@ import kotlin.reflect.KClass
  */
 class AssertionDataFactory(
     stateSubject: KClass<out FlickerSubject>,
-    private val traceSubject: KClass<out FlickerTraceSubject<*>>
+    private val traceSubject: KClass<out FlickerTraceSubject<*>>,
 ) : AssertionStateDataFactory(stateSubject) {
 
     /**
@@ -48,7 +48,7 @@ class AssertionDataFactory(
         return AssertionDataImpl(
             tag = Tag.ALL,
             expectedSubjectClass = traceSubject,
-            assertion = closedAssertion as FlickerSubject.() -> Unit
+            assertion = closedAssertion as FlickerSubject.() -> Unit,
         )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataImpl.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataImpl.kt
index c23791567..e8709ccde 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionDataImpl.kt
@@ -26,7 +26,7 @@ data class AssertionDataImpl(
     /** Expected run result type */
     val expectedSubjectClass: KClass<out FlickerSubject>,
     /** Assertion command */
-    val assertion: FlickerSubject.() -> Unit
+    val assertion: FlickerSubject.() -> Unit,
 ) : AssertionData {
     override fun checkAssertion(run: SubjectsParser) {
         val subject = run.getSubjectOfType(tag, expectedSubjectClass)
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionFactory.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionFactory.kt
index 6441bc06a..1c049b392 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionFactory.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionFactory.kt
@@ -74,7 +74,7 @@ class AssertionFactory {
      */
     fun createWmTagAssertion(
         tag: String,
-        assertion: WindowManagerStateSubject.() -> Unit
+        assertion: WindowManagerStateSubject.() -> Unit,
     ): AssertionData =
         withTracing("createWmTagAssertion") {
             wmAssertionFactory.createTagAssertion(tag, assertion as FlickerSubject.() -> Unit)
@@ -88,7 +88,7 @@ class AssertionFactory {
      */
     fun createWmVisibleRegionAssertion(
         componentMatcher: IComponentMatcher,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     ): AssertionData =
         withTracing("createWmVisibleRegionAssertion") {
             val closedAssertion: WindowManagerTraceSubject.() -> Unit = {
@@ -145,7 +145,7 @@ class AssertionFactory {
      */
     fun createLayersTagAssertion(
         tag: String,
-        assertion: LayerTraceEntrySubject.() -> Unit
+        assertion: LayerTraceEntrySubject.() -> Unit,
     ): AssertionData =
         withTracing("createLayersTagAssertion") {
             layersAssertionFactory.createTagAssertion(tag, assertion as FlickerSubject.() -> Unit)
@@ -164,7 +164,7 @@ class AssertionFactory {
     fun createLayersVisibleRegionAssertion(
         componentMatcher: IComponentMatcher,
         useCompositionEngineRegionOnly: Boolean = true,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     ): AssertionData =
         withTracing("createLayersVisibleRegionAssertion") {
             val closedAssertion: LayersTraceSubject.() -> Unit = {
@@ -193,7 +193,7 @@ class AssertionFactory {
         withTracing("createEventLogAssertion") {
             eventLogAssertionFactory.createTagAssertion(
                 Tag.ALL,
-                assertion as FlickerSubject.() -> Unit
+                assertion as FlickerSubject.() -> Unit,
             )
         }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionResult.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionResult.kt
index 421ccb35c..7f9bcc601 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionResult.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionResult.kt
@@ -40,6 +40,6 @@ interface AssertionResult {
     enum class Status {
         PASS,
         FAIL,
-        ASSUMPTION_VIOLATION
+        ASSUMPTION_VIOLATION,
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionResultImpl.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionResultImpl.kt
index b3e357401..275a9121a 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionResultImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionResultImpl.kt
@@ -26,5 +26,5 @@ internal data class AssertionResultImpl(
     override val assertionData: Collection<AssertionData>,
     override val assumptionViolations: Collection<AssumptionViolatedException>,
     override val assertionErrors: Collection<FlickerAssertionError>,
-    override val stabilityGroup: AssertionInvocationGroup
+    override val stabilityGroup: AssertionInvocationGroup,
 ) : AssertionResult
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionStateDataFactory.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionStateDataFactory.kt
index 516d06c4b..d3f455b1b 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionStateDataFactory.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionStateDataFactory.kt
@@ -35,7 +35,7 @@ open class AssertionStateDataFactory(private val stateSubject: KClass<out Flicke
         AssertionDataImpl(
             tag = Tag.START,
             expectedSubjectClass = stateSubject,
-            assertion = assertion
+            assertion = assertion,
         )
 
     /**
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/AssertionsChecker.kt b/libraries/flicker/src/android/tools/flicker/assertions/AssertionsChecker.kt
index e734d51a9..d153b75cb 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/AssertionsChecker.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/AssertionsChecker.kt
@@ -19,6 +19,7 @@ package android.tools.flicker.assertions
 import android.tools.flicker.subject.FlickerSubject
 import android.tools.flicker.subject.exceptions.ExceptionMessageBuilder
 import android.tools.flicker.subject.exceptions.SubjectAssertionError
+import android.tools.function.AssertionPredicate
 
 /**
  * Runs sequences of assertions on sequences of subjects.
@@ -35,12 +36,12 @@ class AssertionsChecker<T : FlickerSubject> {
     internal fun isEmpty() = assertions.isEmpty()
 
     /** Add [assertion] to a new [CompoundAssertion] block. */
-    fun add(name: String, isOptional: Boolean = false, assertion: (T) -> Unit) {
+    fun add(name: String, isOptional: Boolean = false, assertion: AssertionPredicate<T>) {
         assertions.add(CompoundAssertion(assertion, name, isOptional))
     }
 
     /** Append [assertion] to the last existing set of assertions. */
-    fun append(name: String, isOptional: Boolean = false, assertion: (T) -> Unit) {
+    fun append(name: String, isOptional: Boolean = false, assertion: AssertionPredicate<T>) {
         assertions.last().add(assertion, name, isOptional)
     }
 
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/BaseAssertionRunner.kt b/libraries/flicker/src/android/tools/flicker/assertions/BaseAssertionRunner.kt
index 11bb56488..1dc5efee7 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/BaseAssertionRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/BaseAssertionRunner.kt
@@ -28,7 +28,7 @@ import android.tools.withTracing
  */
 abstract class BaseAssertionRunner(
     private val resultReader: Reader,
-    private val innerRunner: AssertionRunner = ReaderAssertionRunner(resultReader)
+    private val innerRunner: AssertionRunner = ReaderAssertionRunner(resultReader),
 ) : AssertionRunner by innerRunner {
     protected abstract fun doUpdateStatus(newStatus: RunStatus)
 
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/BaseFlickerTest.kt b/libraries/flicker/src/android/tools/flicker/assertions/BaseFlickerTest.kt
index 446b89dd9..4888b295b 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/BaseFlickerTest.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/BaseFlickerTest.kt
@@ -60,7 +60,7 @@ abstract class BaseFlickerTest(
 
     override fun assertWmVisibleRegion(
         componentMatcher: IComponentMatcher,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     ) {
         withTracing("assertWmVisibleRegion") {
             val assertionData =
@@ -100,14 +100,14 @@ abstract class BaseFlickerTest(
     override fun assertLayersVisibleRegion(
         componentMatcher: IComponentMatcher,
         useCompositionEngineRegionOnly: Boolean,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     ) {
         withTracing("assertLayersVisibleRegion") {
             val assertionData =
                 assertionFactory.createLayersVisibleRegionAssertion(
                     componentMatcher,
                     useCompositionEngineRegionOnly,
-                    assertion
+                    assertion,
                 )
             doProcess(assertionData)
         }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/CompoundAssertion.kt b/libraries/flicker/src/android/tools/flicker/assertions/CompoundAssertion.kt
index 42c697396..e410ed856 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/CompoundAssertion.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/CompoundAssertion.kt
@@ -16,8 +16,11 @@
 
 package android.tools.flicker.assertions
 
+import android.tools.function.AssertionPredicate
+
 /** Utility class to store assertions composed of multiple individual assertions */
-class CompoundAssertion<T>(assertion: (T) -> Unit, name: String, optional: Boolean) : Assertion<T> {
+class CompoundAssertion<T>(assertion: AssertionPredicate<T>, name: String, optional: Boolean) :
+    Assertion<T> {
     private val assertions = mutableListOf<NamedAssertion<T>>()
 
     init {
@@ -63,7 +66,7 @@ class CompoundAssertion<T>(assertion: (T) -> Unit, name: String, optional: Boole
     }
 
     /** Adds a new assertion to the list */
-    fun add(assertion: (T) -> Unit, name: String, optional: Boolean) {
+    fun add(assertion: AssertionPredicate<T>, name: String, optional: Boolean) {
         assertions.add(NamedAssertion(assertion, name, optional))
     }
 
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/FlickerTest.kt b/libraries/flicker/src/android/tools/flicker/assertions/FlickerTest.kt
index 9d8d8c9cf..8b47bcec1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/FlickerTest.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/FlickerTest.kt
@@ -55,7 +55,7 @@ interface FlickerTest {
 
     fun assertWmVisibleRegion(
         componentMatcher: IComponentMatcher,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     )
 
     /**
@@ -99,7 +99,7 @@ interface FlickerTest {
     fun assertLayersVisibleRegion(
         componentMatcher: IComponentMatcher,
         useCompositionEngineRegionOnly: Boolean = true,
-        assertion: RegionTraceSubject.() -> Unit
+        assertion: RegionTraceSubject.() -> Unit,
     )
 
     /**
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/NamedAssertion.kt b/libraries/flicker/src/android/tools/flicker/assertions/NamedAssertion.kt
index cec4694e1..5f09db742 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/NamedAssertion.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/NamedAssertion.kt
@@ -16,6 +16,8 @@
 
 package android.tools.flicker.assertions
 
+import android.tools.function.AssertionPredicate
+
 /**
  * Utility class to store assertions with an identifier to help generate more useful debug data when
  * dealing with multiple assertions.
@@ -25,11 +27,12 @@ package android.tools.flicker.assertions
  * @param isOptional If the assertion is optional (can fail) or not (must pass)
  */
 open class NamedAssertion<T>(
-    val predicate: (T) -> Unit,
+    val predicate: AssertionPredicate<T>,
     override val name: String,
-    override val isOptional: Boolean = false
+    override val isOptional: Boolean = false,
 ) : Assertion<T> {
-    override operator fun invoke(target: T) = predicate(target)
+    override operator fun invoke(target: T) = predicate.verify(target)
+
     override fun toString(): String = "Assertion($name)${if (isOptional) "[optional]" else ""}"
 
     /**
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/ReaderAssertionRunner.kt b/libraries/flicker/src/android/tools/flicker/assertions/ReaderAssertionRunner.kt
index d3354bc41..2334a45d0 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/ReaderAssertionRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/ReaderAssertionRunner.kt
@@ -24,7 +24,7 @@ import org.junit.AssumptionViolatedException
 
 class ReaderAssertionRunner(
     private val resultReader: Reader,
-    private val subjectsParser: SubjectsParser = SubjectsParser(resultReader)
+    private val subjectsParser: SubjectsParser = SubjectsParser(resultReader),
 ) : AssertionRunner {
     override fun runAssertion(assertion: AssertionData): Throwable? =
         withTracing("ReaderAssertionRunner#runAssertion") {
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/ScenarioAssertionImpl.kt b/libraries/flicker/src/android/tools/flicker/assertions/ScenarioAssertionImpl.kt
index 91848ed4f..e598fd087 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/ScenarioAssertionImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/ScenarioAssertionImpl.kt
@@ -31,7 +31,7 @@ data class ScenarioAssertionImpl(
     private val assertionData: Collection<AssertionData>,
     override val stabilityGroup: AssertionInvocationGroup,
     private val assertionExtraData: Map<String, String>,
-    private val assertionRunner: AssertionRunner = ReaderAssertionRunner(reader)
+    private val assertionRunner: AssertionRunner = ReaderAssertionRunner(reader),
 ) : ScenarioAssertion {
     init {
         require(assertionData.isNotEmpty()) { "Expected at least one assertion data object." }
@@ -52,7 +52,7 @@ data class ScenarioAssertionImpl(
                 throw IllegalArgumentException(
                     "Expected all assertion exceptions to be " +
                         "FlickerAssertionErrors or AssumptionViolatedExceptions",
-                    unexpectedExceptions.first()
+                    unexpectedExceptions.first(),
                 )
             }
 
@@ -69,7 +69,7 @@ data class ScenarioAssertionImpl(
                     assumptionViolations =
                         assertionExceptions.filterIsInstance<AssumptionViolatedException>(),
                     assertionErrors,
-                    stabilityGroup
+                    stabilityGroup,
                 )
                 .also { log(it) }
         }
@@ -82,13 +82,13 @@ data class ScenarioAssertionImpl(
                 Log.w(
                     "$FLICKER_TAG-SERVICE",
                     "${result.name} ASSUMPTION VIOLATION :: " +
-                        result.assumptionViolations.map { it.message }
+                        result.assumptionViolations.map { it.message },
                 )
             AssertionResult.Status.PASS -> Log.d("$FLICKER_TAG-SERVICE", "${result.name} PASSED")
             AssertionResult.Status.FAIL ->
                 Log.e(
                     "$FLICKER_TAG-SERVICE",
-                    "${result.name} FAILED :: " + result.assertionErrors.map { it.message }
+                    "${result.name} FAILED :: " + result.assertionErrors.map { it.message },
                 )
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt b/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
index 2bb63cfdb..c24944c1c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertions/SubjectsParser.kt
@@ -39,7 +39,7 @@ import kotlin.reflect.KClass
 open class SubjectsParser(private val resultReader: Reader) {
     fun getSubjectOfType(
         tag: String,
-        expectedSubjectClass: KClass<out FlickerSubject>
+        expectedSubjectClass: KClass<out FlickerSubject>,
     ): FlickerSubject? {
         return when {
             tag == Tag.ALL && expectedSubjectClass == WindowManagerTraceSubject::class ->
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/AssertionTemplate.kt b/libraries/flicker/src/android/tools/flicker/assertors/AssertionTemplate.kt
index 8c5fd589a..7672c5ba1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/AssertionTemplate.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/AssertionTemplate.kt
@@ -23,10 +23,11 @@ import android.tools.flicker.assertions.ServiceFlickerTest
 import android.tools.flicker.assertions.SubjectsParser
 
 /** Base class for a FaaS assertion */
-abstract class AssertionTemplate(name: String? = null) {
+abstract class AssertionTemplate @JvmOverloads constructor(name: String? = null) {
     protected open val name =
         this::class.simpleName
-            ?: name ?: error("Must provide a name to assertions when using anonymous classes.")
+            ?: name
+            ?: error("Must provide a name to assertions when using anonymous classes.")
     val id
         get() = AssertionId(name)
 
@@ -71,5 +72,5 @@ abstract class AssertionTemplate(name: String? = null) {
 
 data class Assertion(
     val flickerAssertions: List<AssertionData>,
-    val genericAssertions: List<Throwable>
+    val genericAssertions: List<Throwable>,
 )
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/ComponentTemplate.kt b/libraries/flicker/src/android/tools/flicker/assertors/ComponentTemplate.kt
index c320a3b59..d68cbba8d 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/ComponentTemplate.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/ComponentTemplate.kt
@@ -17,17 +17,18 @@
 package android.tools.flicker.assertors
 
 import android.tools.flicker.ScenarioInstance
+import android.tools.function.Supplier
 import android.tools.traces.component.IComponentMatcher
 
 data class ComponentTemplate(
     val name: String,
-    val build: (scenarioInstance: ScenarioInstance) -> IComponentMatcher
-) {
+    private val matcher: Supplier<ScenarioInstance, IComponentMatcher>,
+) : Supplier<ScenarioInstance, IComponentMatcher> by matcher {
     override fun equals(other: Any?): Boolean {
-        return other is ComponentTemplate && name == other.name && build == other.build
+        return other is ComponentTemplate && name == other.name && matcher == other.matcher
     }
 
     override fun hashCode(): Int {
-        return name.hashCode() * 39 + build.hashCode()
+        return name.hashCode() * 39 + matcher.hashCode()
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesInvisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesInvisible.kt
index 5b3995974..2c51de6f8 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesInvisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesInvisible.kt
@@ -28,10 +28,7 @@ class AppLayerBecomesInvisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers {
-            isVisible(component.build(scenarioInstance))
-                .then()
-                .isInvisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher).then().isInvisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesVisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesVisible.kt
index 802cc35a1..69cf8259c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesVisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerBecomesVisible.kt
@@ -31,20 +31,20 @@ class AppLayerBecomesVisible(private val component: ComponentTemplate) :
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         // The app launch transition can finish when the splashscreen or SnapshotStartingWindows
         // are shown before the app window and layers are actually shown. (b/284302118)
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
-            isInvisible(component.build(scenarioInstance))
+            isInvisible(matcher)
                 .then()
                 .isVisible(ComponentNameMatcher.SNAPSHOT, isOptional = true)
                 .then()
                 .isVisible(ComponentNameMatcher.SPLASH_SCREEN, isOptional = true)
                 .then()
-                .isVisible(component.build(scenarioInstance), isOptional = true)
+                .isVisible(matcher, isOptional = true)
         }
 
         flicker.assertLayersEnd {
             isVisible(
-                ComponentNameMatcher.SNAPSHOT.or(ComponentNameMatcher.SPLASH_SCREEN)
-                    .or(component.build(scenarioInstance))
+                ComponentNameMatcher.SNAPSHOT.or(ComponentNameMatcher.SPLASH_SCREEN).or(matcher)
             )
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtEnd.kt
index aabeb2c4c..35e2a028e 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtEnd.kt
@@ -29,7 +29,7 @@ class AppLayerCoversFullScreenAtEnd(private val component: ComponentTemplate) :
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
 
-            visibleRegion(component.build(scenarioInstance).or(ComponentNameMatcher.LETTERBOX))
+            visibleRegion(component.get(scenarioInstance).or(ComponentNameMatcher.LETTERBOX))
                 .coversExactly(displayBounds)
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtStart.kt
index 5c3952e0e..6a4f95fb1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerCoversFullScreenAtStart.kt
@@ -28,7 +28,7 @@ class AppLayerCoversFullScreenAtStart(private val component: ComponentTemplate)
         flicker.assertLayersStart {
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
-            visibleRegion(component.build(scenarioInstance).or(ComponentNameMatcher.LETTERBOX))
+            visibleRegion(component.get(scenarioInstance).or(ComponentNameMatcher.LETTERBOX))
                 .coversExactly(displayBounds)
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIncreasesInSize.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIncreasesInSize.kt
index 802619958..ad6ae97f8 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIncreasesInSize.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIncreasesInSize.kt
@@ -25,7 +25,7 @@ class AppLayerIncreasesInSize(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        val layerMatcher = component.build(scenarioInstance)
+        val layerMatcher = component.get(scenarioInstance)
         flicker.assertLayers {
             val layerList = layers { layerMatcher.layerMatchesAnyOf(it) && it.isVisible }
             layerList.zipWithNext { previous, current ->
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtEnd.kt
index 3f847f461..1fc7c315f 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtEnd.kt
@@ -25,6 +25,6 @@ class AppLayerIsInvisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersEnd { isInvisible(component.build(scenarioInstance)) }
+        flicker.assertLayersEnd { isInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtStart.kt
index bbace4946..7df34b1f3 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsInvisibleAtStart.kt
@@ -25,6 +25,6 @@ class AppLayerIsInvisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersStart { isInvisible(component.build(scenarioInstance)) }
+        flicker.assertLayersStart { isInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAlways.kt
index 87b8171a3..9ad9a75e4 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAlways.kt
@@ -25,6 +25,7 @@ class AppLayerIsVisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers { isVisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtEnd.kt
index 5e2018612..2a6a36134 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtEnd.kt
@@ -31,7 +31,7 @@ class AppLayerIsVisibleAtEnd(private val component: ComponentTemplate) :
         flicker.assertLayersEnd {
             isVisible(
                 ComponentNameMatcher.SNAPSHOT.or(ComponentNameMatcher.SPLASH_SCREEN)
-                    .or(component.build(scenarioInstance))
+                    .or(component.get(scenarioInstance))
             )
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtStart.kt
index b7a3ec58a..2d04dc7cb 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerIsVisibleAtStart.kt
@@ -25,6 +25,6 @@ class AppLayerIsVisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersStart { isVisible(component.build(scenarioInstance)) }
+        flicker.assertLayersStart { isVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReducesInSize.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReducesInSize.kt
index 97440edfc..4b13d1942 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReducesInSize.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReducesInSize.kt
@@ -25,7 +25,7 @@ class AppLayerReducesInSize(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        val layerMatcher = component.build(scenarioInstance)
+        val layerMatcher = component.get(scenarioInstance)
         flicker.assertLayers {
             val layerList = layers { layerMatcher.layerMatchesAnyOf(it) && it.isVisible }
             layerList.zipWithNext { previous, current ->
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerRemainInsideDisplayBounds.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerRemainInsideDisplayBounds.kt
index 380c91d18..db8ac86ae 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerRemainInsideDisplayBounds.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerRemainInsideDisplayBounds.kt
@@ -27,12 +27,11 @@ class AppLayerRemainInsideDisplayBounds(private val component: ComponentTemplate
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
             containsAtLeastOneDisplay().invoke("appLayerRemainInsideDisplayBounds") { subject ->
                 subject.entry.displays.forEach { display ->
-                    subject
-                        .visibleRegion(component.build(scenarioInstance))
-                        .coversAtMost(display.layerStackSpace)
+                    subject.visibleRegion(matcher).coversAtMost(display.layerStackSpace)
                 }
             }
         }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReplacesLauncher.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReplacesLauncher.kt
index aa9f42669..8f046a552 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReplacesLauncher.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppLayerReplacesLauncher.kt
@@ -34,10 +34,7 @@ class AppLayerReplacesLauncher(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers {
-            isVisible(ComponentNameMatcher.LAUNCHER)
-                .then()
-                .isVisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(ComponentNameMatcher.LAUNCHER).then().isVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowAlignsWithOnlyOneDisplayCornerAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowAlignsWithOnlyOneDisplayCornerAtEnd.kt
index 66d651931..363f6fc93 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowAlignsWithOnlyOneDisplayCornerAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowAlignsWithOnlyOneDisplayCornerAtEnd.kt
@@ -27,8 +27,8 @@ class AppWindowAlignsWithOnlyOneDisplayCornerAtEnd(private val component: Compon
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
-            val displayAppBounds = WindowUtils.getInsetDisplayBounds()
-            val windowBounds = visibleRegion(component.build(scenarioInstance)).region.bounds
+            val displayAppBounds = WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation)
+            val windowBounds = visibleRegion(component.get(scenarioInstance)).region.bounds
 
             val onRightSide = windowBounds.right == displayAppBounds.right
             val onLeftSide = windowBounds.left == displayAppBounds.left
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesInvisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesInvisible.kt
index 967ca685a..44e2a8dd2 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesInvisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesInvisible.kt
@@ -28,10 +28,7 @@ class AppWindowBecomesInvisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm {
-            isAppWindowVisible(component.build(scenarioInstance))
-                .then()
-                .isAppWindowInvisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isAppWindowVisible(matcher).then().isAppWindowInvisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesPinned.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesPinned.kt
index eb81c699a..c1a2234bb 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesPinned.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesPinned.kt
@@ -25,10 +25,11 @@ class AppWindowBecomesPinned(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
-            invoke("appWindowIsNotPinned") { it.isNotPinned(component.build(scenarioInstance)) }
+            invoke("appWindowIsNotPinned") { it.isNotPinned(matcher) }
                 .then()
-                .invoke("appWindowIsPinned") { it.isPinned(component.build(scenarioInstance)) }
+                .invoke("appWindowIsPinned") { it.isPinned(matcher) }
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesTopWindow.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesTopWindow.kt
index 1b20bdbbb..4f20a1b03 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesTopWindow.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesTopWindow.kt
@@ -29,7 +29,7 @@ class AppWindowBecomesTopWindow(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        val testApp = component.build(scenarioInstance)
+        val testApp = component.get(scenarioInstance)
         flicker.assertWm {
             isAppWindowNotOnTop(testApp)
                 .then()
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesVisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesVisible.kt
index a029bda25..d05bbe374 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesVisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowBecomesVisible.kt
@@ -31,20 +31,20 @@ class AppWindowBecomesVisible(private val component: ComponentTemplate) :
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         // The app launch transition can finish when the splashscreen or SnapshotStartingWindows
         // are shown before the app window and layers are actually shown. (b/284302118)
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
-            isAppWindowInvisible(component.build(scenarioInstance))
+            isAppWindowInvisible(matcher)
                 .then()
                 .isAppWindowVisible(ComponentNameMatcher.SNAPSHOT, isOptional = true)
                 .then()
                 .isAppWindowVisible(ComponentNameMatcher.SPLASH_SCREEN, isOptional = true)
                 .then()
-                .isAppWindowVisible(component.build(scenarioInstance), isOptional = true)
+                .isAppWindowVisible(matcher, isOptional = true)
         }
 
         flicker.assertWmEnd {
             isAppWindowVisible(
-                ComponentNameMatcher.SNAPSHOT.or(ComponentNameMatcher.SPLASH_SCREEN)
-                    .or(component.build(scenarioInstance))
+                ComponentNameMatcher.SNAPSHOT.or(ComponentNameMatcher.SPLASH_SCREEN).or(matcher)
             )
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtEnd.kt
index dd2211e62..4cc15d4d4 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtEnd.kt
@@ -28,7 +28,7 @@ class AppWindowCoversFullScreenAtEnd(private val component: ComponentTemplate) :
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
 
-            visibleRegion(component.build(scenarioInstance)).coversExactly(displayBounds)
+            visibleRegion(component.get(scenarioInstance)).coversExactly(displayBounds)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtStart.kt
index 75f773365..7efa11dd4 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversFullScreenAtStart.kt
@@ -28,7 +28,7 @@ class AppWindowCoversFullScreenAtStart(private val component: ComponentTemplate)
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
 
-            visibleRegion(component.build(scenarioInstance)).coversExactly(displayBounds)
+            visibleRegion(component.get(scenarioInstance)).coversExactly(displayBounds)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversLeftHalfScreenAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversLeftHalfScreenAtEnd.kt
index 9530032bf..ba8153f89 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversLeftHalfScreenAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversLeftHalfScreenAtEnd.kt
@@ -23,12 +23,26 @@ import android.tools.helpers.WindowUtils
 
 class AppWindowCoversLeftHalfScreenAtEnd(
     private val component: ComponentTemplate,
+    private val coverageDifferenceThresholdRatio: Double? = null,
 ) : AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
-            val expectedBounds = WindowUtils.getInsetDisplayBounds().apply { right = centerX() }
-            visibleRegion(component.build(scenarioInstance)).coversExactly(expectedBounds)
+            if (coverageDifferenceThresholdRatio == null) {
+                // Build expected bounds of half the display
+                val expectedBounds =
+                    WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation).apply {
+                        right = centerX()
+                    }
+                visibleRegion(component.get(scenarioInstance)).coversExactly(expectedBounds)
+            } else {
+                // Build expected bounds of half the display (minus given threshold)
+                val expectedBounds =
+                    WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation).apply {
+                        right = (centerX() * (1 - coverageDifferenceThresholdRatio)).toInt()
+                    }
+                visibleRegion(component.get(scenarioInstance)).coversAtLeast(expectedBounds)
+            }
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversRightHalfScreenAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversRightHalfScreenAtEnd.kt
index a694a6616..8fbf13aba 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversRightHalfScreenAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowCoversRightHalfScreenAtEnd.kt
@@ -23,13 +23,26 @@ import android.tools.helpers.WindowUtils
 
 class AppWindowCoversRightHalfScreenAtEnd(
     private val component: ComponentTemplate,
+    private val coverageDifferenceThresholdRatio: Double? = null,
 ) : AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
-            // Build expected bounds of half the display
-            val expectedBounds = WindowUtils.getInsetDisplayBounds().apply { left = centerX() }
-            visibleRegion(component.build(scenarioInstance)).coversExactly(expectedBounds)
+            if (coverageDifferenceThresholdRatio == null) {
+                // Build expected bounds of half the display
+                val expectedBounds =
+                    WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation).apply {
+                        left = centerX()
+                    }
+                visibleRegion(component.get(scenarioInstance)).coversExactly(expectedBounds)
+            } else {
+                // Build expected bounds of half the display (minus given threshold)
+                val expectedBounds =
+                    WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation).apply {
+                        left = (centerX() * (1 + coverageDifferenceThresholdRatio)).toInt()
+                    }
+                visibleRegion(component.get(scenarioInstance)).coversAtLeast(expectedBounds)
+            }
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasDesktopModeInitialBoundsAtTheEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasDesktopModeInitialBoundsAtTheEnd.kt
index 1df08d52a..3be9b2af2 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasDesktopModeInitialBoundsAtTheEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasDesktopModeInitialBoundsAtTheEnd.kt
@@ -32,7 +32,7 @@ class AppWindowHasDesktopModeInitialBoundsAtTheEnd(private val component: Compon
         flicker.assertLayersEnd {
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
-            val stableBounds = WindowUtils.getInsetDisplayBounds()
+            val stableBounds = WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation)
             val desktopModeInitialBoundsScale =
                 SystemProperties.getInt("persist.wm.debug.desktop_mode_initial_bounds_scale", 75) /
                     100f
@@ -49,7 +49,7 @@ class AppWindowHasDesktopModeInitialBoundsAtTheEnd(private val component: Compon
             // Position the task in screen bounds
             outBounds.offset(xOffset, yOffset)
 
-            visibleRegion(component.build(scenarioInstance)).coversExactly(outBounds)
+            visibleRegion(component.get(scenarioInstance)).coversExactly(outBounds)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxBoundsInOnlyOneDimension.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxBoundsInOnlyOneDimension.kt
index 5ffeb71c4..b3d53a69e 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxBoundsInOnlyOneDimension.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxBoundsInOnlyOneDimension.kt
@@ -26,13 +26,15 @@ class AppWindowHasMaxBoundsInOnlyOneDimension(private val component: ComponentTe
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
-            val maxDisplayBounds = WindowUtils.getInsetDisplayBounds()
-            val windowBounds = visibleRegion(component.build(scenarioInstance)).region.bounds
+            val maxDisplayBounds = WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation)
+            val windowBounds = visibleRegion(component.get(scenarioInstance)).region.bounds
 
-            val hasMaxHeight = windowBounds.top == maxDisplayBounds.top
-                    && windowBounds.bottom == maxDisplayBounds.bottom
-            val hasMaxWidth = windowBounds.left == maxDisplayBounds.left
-                    && windowBounds.right == maxDisplayBounds.right
+            val hasMaxHeight =
+                windowBounds.top == maxDisplayBounds.top &&
+                    windowBounds.bottom == maxDisplayBounds.bottom
+            val hasMaxWidth =
+                windowBounds.left == maxDisplayBounds.left &&
+                    windowBounds.right == maxDisplayBounds.right
             val isMaxInOneDimension = hasMaxHeight.xor(hasMaxWidth)
 
             check { "only one max bounds" }.that(isMaxInOneDimension).isEqual(true)
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayHeight.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayHeight.kt
index 29f1ce224..b53d07e54 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayHeight.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayHeight.kt
@@ -26,8 +26,8 @@ class AppWindowHasMaxDisplayHeight(private val component: ComponentTemplate) :
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
-            val expectedBounds = WindowUtils.getInsetDisplayBounds()
-            visibleRegion(component.build(scenarioInstance))
+            val expectedBounds = WindowUtils.getInsetDisplayBounds(scenarioInstance.startRotation)
+            visibleRegion(component.get(scenarioInstance))
                 .hasSameTopPosition(expectedBounds)
                 .hasSameBottomPosition(expectedBounds)
         }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayWidth.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayWidth.kt
index be3106e90..da355b0fe 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayWidth.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasMaxDisplayWidth.kt
@@ -28,7 +28,7 @@ class AppWindowHasMaxDisplayWidth(private val component: ComponentTemplate) :
             val displayBounds =
                 entry.physicalDisplayBounds ?: error("Missing physical display bounds")
 
-            visibleRegion(component.build(scenarioInstance))
+            visibleRegion(component.get(scenarioInstance))
                 .hasSameLeftPosition(displayBounds)
                 .hasSameRightPosition(displayBounds)
         }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasSizeOfAtLeast.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasSizeOfAtLeast.kt
index 7d38478ce..689e12d46 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasSizeOfAtLeast.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowHasSizeOfAtLeast.kt
@@ -24,14 +24,14 @@ import android.tools.flicker.assertors.ComponentTemplate
 class AppWindowHasSizeOfAtLeast(
     private val component: ComponentTemplate,
     private val minimumWidth: Int,
-    private val minimumHeight: Int
+    private val minimumHeight: Int,
 ) : AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertLayersEnd {
             val minimumSize = Region(0, 0, minimumWidth, minimumHeight)
 
-            visibleRegion(component.build(scenarioInstance)).notSmallerThan(minimumSize)
+            visibleRegion(component.get(scenarioInstance)).notSmallerThan(minimumSize)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowInsideDisplayBoundsAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowInsideDisplayBoundsAtEnd.kt
index fc0f1439d..74c30035b 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowInsideDisplayBoundsAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowInsideDisplayBoundsAtEnd.kt
@@ -27,7 +27,7 @@ class AppWindowInsideDisplayBoundsAtEnd(private val component: ComponentTemplate
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWmEnd {
             val display = wmState.getDefaultDisplay()!!
-            visibleRegion(component.build(scenarioInstance)).coversAtMost(display.displayRect)
+            visibleRegion(component.get(scenarioInstance)).coversAtMost(display.displayRect)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtEnd.kt
index 501f44224..745d1a20c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtEnd.kt
@@ -25,6 +25,6 @@ class AppWindowIsInvisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmEnd { isAppWindowInvisible(component.build(scenarioInstance)) }
+        flicker.assertWmEnd { isAppWindowInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtStart.kt
index 10677ae0c..3c269169d 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsInvisibleAtStart.kt
@@ -24,6 +24,6 @@ class AppWindowIsInvisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmStart { isAppWindowInvisible(component.build(scenarioInstance)) }
+        flicker.assertWmStart { isAppWindowInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsTopWindowAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsTopWindowAtStart.kt
index b54a51b77..6ef9a910b 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsTopWindowAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsTopWindowAtStart.kt
@@ -24,6 +24,6 @@ class AppWindowIsTopWindowAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmStart { isAppWindowOnTop(component.build(scenarioInstance)) }
+        flicker.assertWmStart { isAppWindowOnTop(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAlways.kt
index 63123517c..8d4d15589 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAlways.kt
@@ -25,6 +25,7 @@ class AppWindowIsVisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm { isAppWindowVisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isAppWindowVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtEnd.kt
index 5c3a92b14..14102b2d5 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtEnd.kt
@@ -24,6 +24,6 @@ class AppWindowIsVisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmEnd { isAppWindowVisible(component.build(scenarioInstance)) }
+        flicker.assertWmEnd { isAppWindowVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtStart.kt
index 8120733ba..431ee948a 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowIsVisibleAtStart.kt
@@ -24,6 +24,6 @@ class AppWindowIsVisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmStart { isAppWindowVisible(component.build(scenarioInstance)) }
+        flicker.assertWmStart { isAppWindowVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowMaintainsAspectRatioAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowMaintainsAspectRatioAlways.kt
index cabec060f..cd8721cd2 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowMaintainsAspectRatioAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowMaintainsAspectRatioAlways.kt
@@ -23,10 +23,9 @@ import android.tools.flicker.assertors.ComponentTemplate
 class AppWindowMaintainsAspectRatioAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
-            val desktopWindowLayerList = layers {
-                component.build(scenarioInstance).layerMatchesAnyOf(it) && it.isVisible
-            }
+            val desktopWindowLayerList = layers { matcher.layerMatchesAnyOf(it) && it.isVisible }
             desktopWindowLayerList.zipWithNext { previous, current ->
                 current.visibleRegion.isSameAspectRatio(previous.visibleRegion)
             }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtEnd.kt
index d044b9f6e..65dd7536d 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtEnd.kt
@@ -24,6 +24,6 @@ class AppWindowOnTopAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmEnd { isAppWindowOnTop(component.build(scenarioInstance)) }
+        flicker.assertWmEnd { isAppWindowOnTop(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtStart.kt
index 41e2f2040..834913f9e 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowOnTopAtStart.kt
@@ -24,6 +24,6 @@ class AppWindowOnTopAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmStart { isAppWindowOnTop(component.build(scenarioInstance)) }
+        flicker.assertWmStart { isAppWindowOnTop(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowRemainInsideDisplayBounds.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowRemainInsideDisplayBounds.kt
index be4191683..af5110634 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowRemainInsideDisplayBounds.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowRemainInsideDisplayBounds.kt
@@ -27,12 +27,11 @@ class AppWindowRemainInsideDisplayBounds(private val component: ComponentTemplat
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
             containsAtLeastOneDisplay().invoke("appWindowRemainInsideDisplayBounds") { entry ->
                 val display = entry.wmState.getDefaultDisplay()!!
-                entry
-                    .visibleRegion(component.build(scenarioInstance))
-                    .coversAtMost(display.displayRect)
+                entry.visibleRegion(matcher).coversAtMost(display.displayRect)
             }
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReplacesLauncherAsTopWindow.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReplacesLauncherAsTopWindow.kt
index bb50409e5..bc2b569a1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReplacesLauncherAsTopWindow.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReplacesLauncherAsTopWindow.kt
@@ -29,10 +29,9 @@ class AppWindowReplacesLauncherAsTopWindow(private val component: ComponentTempl
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
-            isAppWindowOnTop(ComponentNameMatcher.LAUNCHER)
-                .then()
-                .isAppWindowOnTop(component.build(scenarioInstance))
+            isAppWindowOnTop(ComponentNameMatcher.LAUNCHER).then().isAppWindowOnTop(matcher)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReturnsToStartBoundsAndPosition.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReturnsToStartBoundsAndPosition.kt
index 24fb29095..9555aa405 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReturnsToStartBoundsAndPosition.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/AppWindowReturnsToStartBoundsAndPosition.kt
@@ -24,9 +24,10 @@ import kotlin.math.abs
 class AppWindowReturnsToStartBoundsAndPosition(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
-            val startRegion = first().visibleRegion(component.build(scenarioInstance))
-            val endRegion = last().visibleRegion(component.build(scenarioInstance))
+            val startRegion = first().visibleRegion(matcher)
+            val endRegion = last().visibleRegion(matcher)
 
             val heightDiff = startRegion.region.bounds.height() - endRegion.region.bounds.height()
             val widthDiff = startRegion.region.bounds.width() - endRegion.region.bounds.width()
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/FocusChanges.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/FocusChanges.kt
index 558aee1e9..dad650668 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/FocusChanges.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/FocusChanges.kt
@@ -26,14 +26,14 @@ val ANY_MATCH_COMPONENT = ComponentTemplate("ANY") { _ -> ComponentNameMatcher("
 
 class FocusChanges(
     private val fromComponent: ComponentTemplate = ANY_MATCH_COMPONENT,
-    private val toComponent: ComponentTemplate = ANY_MATCH_COMPONENT
+    private val toComponent: ComponentTemplate = ANY_MATCH_COMPONENT,
 ) : AssertionTemplateWithComponent(fromComponent, toComponent) {
 
     // TODO: Make parent call this when appropriate
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         val layersTrace = scenarioInstance.reader.readLayersTrace()
-        val fromComponent = fromComponent.build(scenarioInstance)
-        val toComponent = toComponent.build(scenarioInstance)
+        val fromComponent = fromComponent.get(scenarioInstance)
+        val toComponent = toComponent.get(scenarioInstance)
 
         val fromPackage =
             if (fromComponent is IComponentNameMatcher) {
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/HasAtMostOneWindowMatching.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/HasAtMostOneWindowMatching.kt
index 760acba6c..0195dd6c0 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/HasAtMostOneWindowMatching.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/HasAtMostOneWindowMatching.kt
@@ -30,7 +30,7 @@ class HasAtMostOneWindowMatching(private val component: ComponentTemplate) :
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         flicker.assertWm {
             invoke("HasAtMostOneWindowMatching") {
-                val matcher = component.build(scenarioInstance)
+                val matcher = component.get(scenarioInstance)
                 val windowCount =
                     it.wmState.windowStates.count { window -> matcher.windowMatchesAnyOf(window) }
                 require(windowCount <= 1) { "Matched more than 1 $matcher" }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherReplacesAppLayer.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherReplacesAppLayer.kt
index bae2601d3..f2de26af1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherReplacesAppLayer.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherReplacesAppLayer.kt
@@ -33,10 +33,7 @@ class LauncherReplacesAppLayer(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers {
-            isVisible(component.build(scenarioInstance))
-                .then()
-                .isVisible(ComponentNameMatcher.LAUNCHER)
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher).then().isVisible(ComponentNameMatcher.LAUNCHER) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesOutOfTop.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesOutOfTop.kt
index 92c0bc5a9..d4a1e929f 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesOutOfTop.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesOutOfTop.kt
@@ -16,6 +16,7 @@
 
 package android.tools.flicker.assertors.assertions
 
+import android.tools.flicker.config.common.Components
 import android.tools.flicker.config.common.Components.LAUNCHER
 
 /** Checks that [Components.LAUNCHER] starts on top and moves out of top during the transition */
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesToTop.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesToTop.kt
index 9cd13cb3f..39158d4ef 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesToTop.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowMovesToTop.kt
@@ -16,6 +16,7 @@
 
 package android.tools.flicker.assertors.assertions
 
+import android.tools.flicker.config.common.Components
 import android.tools.flicker.config.common.Components.LAUNCHER
 
 /** Checks that [Components.LAUNCHER] starts not on top and moves to top during the transition */
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowReplacesAppAsTopWindow.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowReplacesAppAsTopWindow.kt
index e6b38b178..13168449c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowReplacesAppAsTopWindow.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LauncherWindowReplacesAppAsTopWindow.kt
@@ -19,6 +19,7 @@ package android.tools.flicker.assertors.assertions
 import android.tools.flicker.ScenarioInstance
 import android.tools.flicker.assertions.FlickerTest
 import android.tools.flicker.assertors.ComponentTemplate
+import android.tools.flicker.config.common.Components
 import android.tools.traces.component.ComponentNameMatcher
 
 /**
@@ -28,10 +29,9 @@ import android.tools.traces.component.ComponentNameMatcher
 class LauncherWindowReplacesAppAsTopWindow(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
-            isAppWindowOnTop(component.build(scenarioInstance))
-                .then()
-                .isAppWindowOnTop(ComponentNameMatcher.LAUNCHER)
+            isAppWindowOnTop(matcher).then().isAppWindowOnTop(ComponentNameMatcher.LAUNCHER)
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesInvisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesInvisible.kt
index 8fcbdaf55..49b4d4470 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesInvisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesInvisible.kt
@@ -27,10 +27,7 @@ class LayerBecomesInvisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers {
-            isVisible(component.build(scenarioInstance))
-                .then()
-                .isInvisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher).then().isInvisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesVisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesVisible.kt
index e9fa50869..d8b147acb 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesVisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerBecomesVisible.kt
@@ -27,10 +27,7 @@ class LayerBecomesVisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers {
-            isInvisible(component.build(scenarioInstance))
-                .then()
-                .isVisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isInvisible(matcher).then().isVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAlways.kt
index 6a1985b71..aa7dfada3 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAlways.kt
@@ -25,6 +25,7 @@ class LayerIsInvisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers { isVisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtEnd.kt
index 18086b5f0..4a85e8a77 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtEnd.kt
@@ -25,6 +25,6 @@ class LayerIsInvisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersEnd { isInvisible(component.build(scenarioInstance)) }
+        flicker.assertLayersEnd { isInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtStart.kt
index 9825b01ce..5b5a951ff 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsInvisibleAtStart.kt
@@ -25,6 +25,6 @@ class LayerIsInvisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersStart { isInvisible(component.build(scenarioInstance)) }
+        flicker.assertLayersStart { isInvisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAlways.kt
index e01a066de..a26e9988f 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAlways.kt
@@ -25,6 +25,7 @@ class LayerIsVisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayers { isVisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertLayers { isVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtEnd.kt
index e7987670f..3983fee9f 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtEnd.kt
@@ -25,6 +25,6 @@ class LayerIsVisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersEnd { isVisible(component.build(scenarioInstance)) }
+        flicker.assertLayersEnd { isVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtStart.kt
index c75ddb8fc..f019da204 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerIsVisibleAtStart.kt
@@ -25,6 +25,6 @@ class LayerIsVisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertLayersStart { isVisible(component.build(scenarioInstance)) }
+        flicker.assertLayersStart { isVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerReduces.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerReduces.kt
index ffd0b449d..156b8eb26 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerReduces.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerReduces.kt
@@ -23,10 +23,9 @@ import android.tools.flicker.assertors.ComponentTemplate
 class LayerReduces(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
-            val pipLayerList = layers {
-                component.build(scenarioInstance).layerMatchesAnyOf(it) && it.isVisible
-            }
+            val pipLayerList = layers { matcher.layerMatchesAnyOf(it) && it.isVisible }
             pipLayerList.zipWithNext { previous, current ->
                 current.visibleRegion.notBiggerThan(previous.visibleRegion.region)
             }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerRemainInsideVisibleBounds.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerRemainInsideVisibleBounds.kt
index c91923378..b82a15d73 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerRemainInsideVisibleBounds.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/LayerRemainInsideVisibleBounds.kt
@@ -28,12 +28,13 @@ class LayerRemainInsideVisibleBounds(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
             subjects.forEach {
                 val displayBounds =
                     it.entry.physicalDisplayBounds ?: error("Missing physical display bounds")
 
-                it.visibleRegion(component.build(scenarioInstance)).coversAtMost(displayBounds)
+                it.visibleRegion(matcher).coversAtMost(displayBounds)
             }
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesInvisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesInvisible.kt
index 074cc414f..9388046e1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesInvisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesInvisible.kt
@@ -28,10 +28,7 @@ open class NonAppWindowBecomesInvisible(private val component: ComponentTemplate
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm {
-            isNonAppWindowVisible(component.build(scenarioInstance))
-                .then()
-                .isNonAppWindowInvisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isNonAppWindowVisible(matcher).then().isNonAppWindowInvisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesVisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesVisible.kt
index 8d3b614ff..74acafcd9 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesVisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowBecomesVisible.kt
@@ -28,10 +28,7 @@ class NonAppWindowBecomesVisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm {
-            isNonAppWindowInvisible(component.build(scenarioInstance))
-                .then()
-                .isAppWindowVisible(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isNonAppWindowInvisible(matcher).then().isAppWindowVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsInvisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsInvisibleAlways.kt
index 0a269d89d..de8288cbc 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsInvisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsInvisibleAlways.kt
@@ -25,6 +25,7 @@ class NonAppWindowIsInvisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm { isNonAppWindowInvisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isNonAppWindowInvisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAlways.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAlways.kt
index cd0d8af69..2eafd28da 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAlways.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAlways.kt
@@ -25,6 +25,7 @@ class NonAppWindowIsVisibleAlways(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm { isNonAppWindowVisible(component.build(scenarioInstance)) }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isNonAppWindowVisible(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtEnd.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtEnd.kt
index 3ad50b13c..5e06247c5 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtEnd.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtEnd.kt
@@ -25,6 +25,6 @@ class NonAppWindowIsVisibleAtEnd(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmEnd { isNonAppWindowVisible(component.build(scenarioInstance)) }
+        flicker.assertWmEnd { isNonAppWindowVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtStart.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtStart.kt
index 1f72b74d2..c21cb2d04 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtStart.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/NonAppWindowIsVisibleAtStart.kt
@@ -25,6 +25,6 @@ class NonAppWindowIsVisibleAtStart(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWmStart { isNonAppWindowVisible(component.build(scenarioInstance)) }
+        flicker.assertWmStart { isNonAppWindowVisible(component.get(scenarioInstance)) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/PipWindowBecomesInvisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/PipWindowBecomesInvisible.kt
index 15cb3b192..1034d9a4c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/PipWindowBecomesInvisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/PipWindowBecomesInvisible.kt
@@ -28,16 +28,11 @@ class PipWindowBecomesInvisible(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertWm {
-            invoke("hasPipWindow") {
-                    it.isPinned(component.build(scenarioInstance))
-                        .isAppWindowVisible(component.build(scenarioInstance))
-                }
+            invoke("hasPipWindow") { it.isPinned(matcher).isAppWindowVisible(matcher) }
                 .then()
-                .invoke("!hasPipWindow") {
-                    it.isNotPinned(component.build(scenarioInstance))
-                        .isAppWindowInvisible(component.build(scenarioInstance))
-                }
+                .invoke("!hasPipWindow") { it.isNotPinned(matcher).isAppWindowInvisible(matcher) }
         }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/RotationLayerAppearsAndVanishes.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/RotationLayerAppearsAndVanishes.kt
index d91210039..d56b765ea 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/RotationLayerAppearsAndVanishes.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/RotationLayerAppearsAndVanishes.kt
@@ -29,12 +29,13 @@ class RotationLayerAppearsAndVanishes(private val component: ComponentTemplate)
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
-            isVisible(component.build(scenarioInstance))
+            isVisible(matcher)
                 .then()
                 .isVisible(ComponentNameMatcher.ROTATION)
                 .then()
-                .isVisible(component.build(scenarioInstance))
+                .isVisible(matcher)
                 .isInvisible(ComponentNameMatcher.ROTATION)
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsBecomesVisible.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsBecomesVisible.kt
index 26de3164d..89a1b1cf1 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsBecomesVisible.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsBecomesVisible.kt
@@ -27,11 +27,11 @@ import android.tools.traces.component.IComponentMatcher
 
 class SplitAppLayerBoundsBecomesVisible(
     private val component: ComponentTemplate,
-    val isPrimaryApp: Boolean
+    val isPrimaryApp: Boolean,
 ) : AssertionTemplateWithComponent(component) {
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        val splitScreenDivider = SPLIT_SCREEN_DIVIDER.build(scenarioInstance)
-        val app = component.build(scenarioInstance)
+        val splitScreenDivider = SPLIT_SCREEN_DIVIDER.get(scenarioInstance)
+        val app = component.get(scenarioInstance)
 
         val landscapePosLeft: Boolean
         val portraitPosTop: Boolean
@@ -53,7 +53,7 @@ class SplitAppLayerBoundsBecomesVisible(
                     app,
                     splitScreenDivider,
                     landscapePosLeft,
-                    portraitPosTop
+                    portraitPosTop,
                 )
         }
     }
@@ -63,14 +63,14 @@ class SplitAppLayerBoundsBecomesVisible(
             component: IComponentMatcher,
             splitScreenDivider: IComponentMatcher,
             landscapePosLeft: Boolean,
-            portraitPosTop: Boolean
+            portraitPosTop: Boolean,
         ): LayersTraceSubject {
             return invoke("splitAppLayerBoundsSnapToDivider") {
                 it.splitAppLayerBoundsSnapToDivider(
                     component,
                     splitScreenDivider,
                     landscapePosLeft,
-                    portraitPosTop
+                    portraitPosTop,
                 )
             }
         }
@@ -79,7 +79,7 @@ class SplitAppLayerBoundsBecomesVisible(
             component: IComponentMatcher,
             splitScreenDivider: IComponentMatcher,
             landscapePosLeft: Boolean,
-            portraitPosTop: Boolean
+            portraitPosTop: Boolean,
         ): LayerTraceEntrySubject {
             val activeDisplay =
                 this.entry.displays.firstOrNull { it.isOn && !it.isVirtual }
@@ -100,14 +100,14 @@ class SplitAppLayerBoundsBecomesVisible(
                                     0,
                                     0,
                                     (dividerRegion.bounds.left + dividerRegion.bounds.right) / 2,
-                                    activeDisplay.layerStackSpace.bottom
+                                    activeDisplay.layerStackSpace.bottom,
                                 )
                             } else {
                                 Region(
                                     (dividerRegion.bounds.left + dividerRegion.bounds.right) / 2,
                                     0,
                                     activeDisplay.layerStackSpace.right,
-                                    activeDisplay.layerStackSpace.bottom
+                                    activeDisplay.layerStackSpace.bottom,
                                 )
                             }
                         } else {
@@ -116,14 +116,14 @@ class SplitAppLayerBoundsBecomesVisible(
                                     0,
                                     0,
                                     activeDisplay.layerStackSpace.right,
-                                    (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2
+                                    (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2,
                                 )
                             } else {
                                 Region(
                                     0,
                                     (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2,
                                     activeDisplay.layerStackSpace.right,
-                                    activeDisplay.layerStackSpace.bottom
+                                    activeDisplay.layerStackSpace.bottom,
                                 )
                             }
                         }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsSnapToDivider.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsSnapToDivider.kt
index 690346560..512376236 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsSnapToDivider.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/SplitAppLayerBoundsSnapToDivider.kt
@@ -30,9 +30,10 @@ class SplitAppLayerBoundsSnapToDivider(private val component: ComponentTemplate)
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         val wmTrace = scenarioInstance.reader.readWmTrace() ?: return
 
+        val matcher = component.get(scenarioInstance)
         flicker.assertLayers {
             invoke("splitAppLayerBoundsSnapToDivider") {
-                it.visibleRegion(component.build(scenarioInstance))
+                it.visibleRegion(matcher)
                     .coversAtMost(it.calculateExpectedDisplaySize(scenarioInstance, wmTrace))
             }
         }
@@ -41,13 +42,13 @@ class SplitAppLayerBoundsSnapToDivider(private val component: ComponentTemplate)
     companion object {
         private fun LayerTraceEntrySubject.calculateExpectedDisplaySize(
             scenarioInstance: ScenarioInstance,
-            wmTrace: WindowManagerTrace
+            wmTrace: WindowManagerTrace,
         ): Region {
             // TODO: Replace with always on tracing available data
             val landscapePosLeft = !wmTrace.isTablet
             val portraitPosTop = true // TODO: Figure out how to know if we are top or bottom app
 
-            val splitScreenDivider = SPLIT_SCREEN_DIVIDER.build(scenarioInstance)
+            val splitScreenDivider = SPLIT_SCREEN_DIVIDER.get(scenarioInstance)
 
             val displaySize =
                 entry.displays
@@ -65,14 +66,14 @@ class SplitAppLayerBoundsSnapToDivider(private val component: ComponentTemplate)
                         0,
                         0,
                         (dividerRegion.bounds.left + dividerRegion.bounds.right) / 2,
-                        displaySize.height
+                        displaySize.height,
                     )
                 } else {
                     Region(
                         (dividerRegion.bounds.left + dividerRegion.bounds.right) / 2,
                         0,
                         displaySize.width,
-                        displaySize.height
+                        displaySize.height,
                     )
                 }
             } else {
@@ -81,14 +82,14 @@ class SplitAppLayerBoundsSnapToDivider(private val component: ComponentTemplate)
                         0,
                         0,
                         displaySize.width,
-                        (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2
+                        (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2,
                     )
                 } else {
                     Region(
                         0,
                         (dividerRegion.bounds.top + dividerRegion.bounds.bottom) / 2,
                         displaySize.width,
-                        displaySize.height
+                        displaySize.height,
                     )
                 }
             }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowBecomesPinned.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowBecomesPinned.kt
index 39901ed4d..12e0611f9 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowBecomesPinned.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowBecomesPinned.kt
@@ -28,7 +28,7 @@ class WindowBecomesPinned(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        val component = component.build(scenarioInstance)
+        val component = component.get(scenarioInstance)
         flicker.assertWm { isNotPinned(component).then().isPinned(component) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesOutOfTop.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesOutOfTop.kt
index be29861a4..865b165e5 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesOutOfTop.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesOutOfTop.kt
@@ -25,10 +25,7 @@ open class WindowMovesOutOfTop(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm {
-            isAppWindowOnTop(component.build(scenarioInstance))
-                .then()
-                .isAppWindowNotOnTop(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isAppWindowOnTop(matcher).then().isAppWindowNotOnTop(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesToTop.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesToTop.kt
index e67cb7f73..a76bec1b5 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesToTop.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowMovesToTop.kt
@@ -25,10 +25,7 @@ open class WindowMovesToTop(private val component: ComponentTemplate) :
     AssertionTemplateWithComponent(component) {
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
-        flicker.assertWm {
-            isAppWindowNotOnTop(component.build(scenarioInstance))
-                .then()
-                .isAppWindowOnTop(component.build(scenarioInstance))
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { isAppWindowNotOnTop(matcher).then().isAppWindowOnTop(matcher) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowRemainInsideVisibleBounds.kt b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowRemainInsideVisibleBounds.kt
index df182bcf2..edff6e65c 100644
--- a/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowRemainInsideVisibleBounds.kt
+++ b/libraries/flicker/src/android/tools/flicker/assertors/assertions/WindowRemainInsideVisibleBounds.kt
@@ -30,8 +30,7 @@ class WindowRemainInsideVisibleBounds(private val component: ComponentTemplate)
     /** {@inheritDoc} */
     override fun doEvaluate(scenarioInstance: ScenarioInstance, flicker: FlickerTest) {
         val displayBounds = Rect() // TODO: Get display bounds from wmSubject
-        flicker.assertWm {
-            visibleRegion(component.build(scenarioInstance)).coversAtMost(displayBounds)
-        }
+        val matcher = component.get(scenarioInstance)
+        flicker.assertWm { visibleRegion(matcher).coversAtMost(displayBounds) }
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/AssertionEntry.kt b/libraries/flicker/src/android/tools/flicker/config/AssertionEntry.kt
index a2dd905c3..e6efd2d9e 100644
--- a/libraries/flicker/src/android/tools/flicker/config/AssertionEntry.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/AssertionEntry.kt
@@ -21,5 +21,5 @@ import android.tools.flicker.assertors.AssertionTemplate
 
 data class AssertionEntry(
     val template: AssertionTemplate,
-    var stabilityGroup: AssertionInvocationGroup
+    var stabilityGroup: AssertionInvocationGroup,
 )
diff --git a/libraries/flicker/src/android/tools/flicker/config/AssertionTemplates.kt b/libraries/flicker/src/android/tools/flicker/config/AssertionTemplates.kt
index 450d69776..5a06364de 100644
--- a/libraries/flicker/src/android/tools/flicker/config/AssertionTemplates.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/AssertionTemplates.kt
@@ -113,16 +113,13 @@ object AssertionTemplates {
                     AppWindowIsTopWindowAtStart(CLOSING_APPS),
                     VisibleLayersShownMoreThanOneConsecutiveEntry(
                         listOf(ComponentNameMatcher.NAV_BAR)
-                    )
+                    ),
                 )
                 .associateBy({ it }, { AssertionInvocationGroup.BLOCKING })
 
     val APP_LAUNCH_FROM_HOME_ASSERTIONS =
         APP_LAUNCH_ASSERTIONS +
-            listOf(
-                    AppLayerIsVisibleAtStart(LAUNCHER),
-                    AppLayerIsInvisibleAtEnd(LAUNCHER),
-                )
+            listOf(AppLayerIsVisibleAtStart(LAUNCHER), AppLayerIsInvisibleAtEnd(LAUNCHER))
                 .associateBy({ it }, { AssertionInvocationGroup.BLOCKING })
 
     val APP_LAUNCH_FROM_LOCK_ASSERTIONS =
@@ -168,7 +165,7 @@ object AssertionTemplates {
                     WindowRemainInsideVisibleBounds(PIP_APP),
                     WindowBecomesPinned(PIP_APP),
                     LayerBecomesVisible(LAUNCHER),
-                    HasAtMostOneWindowMatching(PIP_DISMISS_OVERLAY)
+                    HasAtMostOneWindowMatching(PIP_DISMISS_OVERLAY),
                 )
                 .associateBy({ it }, { AssertionInvocationGroup.BLOCKING })
 
@@ -180,11 +177,11 @@ object AssertionTemplates {
                     AppLayerBecomesVisible(SPLIT_SCREEN_SECONDARY_APP),
                     SplitAppLayerBoundsBecomesVisible(
                         SPLIT_SCREEN_PRIMARY_APP,
-                        isPrimaryApp = true
+                        isPrimaryApp = true,
                     ),
                     SplitAppLayerBoundsBecomesVisible(
                         SPLIT_SCREEN_SECONDARY_APP,
-                        isPrimaryApp = false
+                        isPrimaryApp = false,
                     ),
                     AppWindowBecomesVisible(SPLIT_SCREEN_PRIMARY_APP),
                     AppWindowBecomesVisible(SPLIT_SCREEN_SECONDARY_APP),
diff --git a/libraries/flicker/src/android/tools/flicker/config/FlickerConfig.kt b/libraries/flicker/src/android/tools/flicker/config/FlickerConfig.kt
index c04d06b35..d5aa553cf 100644
--- a/libraries/flicker/src/android/tools/flicker/config/FlickerConfig.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/FlickerConfig.kt
@@ -25,13 +25,13 @@ interface FlickerConfig {
     fun registerScenario(
         scenario: ScenarioId,
         extractor: ScenarioExtractor,
-        assertions: Map<AssertionTemplate, AssertionInvocationGroup>? = null
+        assertions: Map<AssertionTemplate, AssertionInvocationGroup>? = null,
     ): FlickerConfig
 
     fun registerAssertions(
         scenario: ScenarioId,
         vararg assertions: AssertionTemplate,
-        stabilityGroup: AssertionInvocationGroup = AssertionInvocationGroup.BLOCKING
+        stabilityGroup: AssertionInvocationGroup = AssertionInvocationGroup.BLOCKING,
     ): FlickerConfig
 
     fun getEntries(): Collection<FlickerConfigEntry>
@@ -41,7 +41,7 @@ interface FlickerConfig {
     fun overrideAssertionStabilityGroup(
         scenario: ScenarioId,
         assertionId: AssertionId,
-        stabilityGroup: AssertionInvocationGroup
+        stabilityGroup: AssertionInvocationGroup,
     ): FlickerConfig
 
     fun unregisterAssertion(scenario: ScenarioId, assertionId: AssertionId): FlickerConfig
diff --git a/libraries/flicker/src/android/tools/flicker/config/FlickerConfigImpl.kt b/libraries/flicker/src/android/tools/flicker/config/FlickerConfigImpl.kt
index 7fd780af0..bc44fc389 100644
--- a/libraries/flicker/src/android/tools/flicker/config/FlickerConfigImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/FlickerConfigImpl.kt
@@ -36,7 +36,7 @@ internal class FlickerConfigImpl : FlickerConfig {
     override fun registerScenario(
         scenario: ScenarioId,
         extractor: ScenarioExtractor,
-        assertions: Map<AssertionTemplate, AssertionInvocationGroup>?
+        assertions: Map<AssertionTemplate, AssertionInvocationGroup>?,
     ) = apply {
         require(!registry.containsKey(scenario)) {
             "${this::class.simpleName} already has a registered scenario with name '$scenario'."
@@ -53,7 +53,7 @@ internal class FlickerConfigImpl : FlickerConfig {
     override fun registerAssertions(
         scenario: ScenarioId,
         vararg assertions: AssertionTemplate,
-        stabilityGroup: AssertionInvocationGroup
+        stabilityGroup: AssertionInvocationGroup,
     ) = apply {
         val entry = registry[scenario]
         require(entry != null) { "No scenario named '$scenario' registered." }
@@ -69,7 +69,7 @@ internal class FlickerConfigImpl : FlickerConfig {
                     entry.scenarioId,
                     entry.extractor,
                     entry.assertions.toMutableMap().apply { this[assertion] = stabilityGroup },
-                    entry.enabled
+                    entry.enabled,
                 )
         }
     }
@@ -81,7 +81,7 @@ internal class FlickerConfigImpl : FlickerConfig {
     override fun overrideAssertionStabilityGroup(
         scenario: ScenarioId,
         assertionId: AssertionId,
-        stabilityGroup: AssertionInvocationGroup
+        stabilityGroup: AssertionInvocationGroup,
     ) = apply {
         val entry = registry[scenario]
         require(entry != null) { "No scenario named '$scenario' registered." }
@@ -97,7 +97,7 @@ internal class FlickerConfigImpl : FlickerConfig {
                 entry.scenarioId,
                 entry.extractor,
                 entry.assertions.toMutableMap().apply { this[targetAssertion] = stabilityGroup },
-                entry.enabled
+                entry.enabled,
             )
     }
 
@@ -116,7 +116,7 @@ internal class FlickerConfigImpl : FlickerConfig {
                 entry.scenarioId,
                 entry.extractor,
                 entry.assertions.toMutableMap().apply { this.remove(targetAssertion) },
-                entry.enabled
+                entry.enabled,
             )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/FlickerServiceConfig.kt b/libraries/flicker/src/android/tools/flicker/config/FlickerServiceConfig.kt
index dd5440202..dd71393e4 100644
--- a/libraries/flicker/src/android/tools/flicker/config/FlickerServiceConfig.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/FlickerServiceConfig.kt
@@ -53,7 +53,7 @@ object FlickerServiceConfig {
                 SplitScreen.SCENARIOS,
                 Suw.SCENARIOS,
                 Taskbar.SCENARIOS,
-                Wallpaper.SCENARIOS
+                Wallpaper.SCENARIOS,
             )
             .flatten()
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/TransitionFilters.kt b/libraries/flicker/src/android/tools/flicker/config/TransitionFilters.kt
index 9f6d918de..b5473de9b 100644
--- a/libraries/flicker/src/android/tools/flicker/config/TransitionFilters.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/TransitionFilters.kt
@@ -34,7 +34,7 @@ object TransitionFilters {
         ts.filter { t ->
             t.changes.any {
                 it.transitMode == TransitionType.OPEN || // cold launch
-                it.transitMode == TO_FRONT // warm launch
+                    it.transitMode == TO_FRONT // warm launch
             }
         }
     }
@@ -95,7 +95,9 @@ object TransitionFilters {
                             isLauncherTopLevelTaskLayer(it.layerId, layersTrace)
                     } == 1 &&
                     (openingAppLayers.count() == 1 || openingAppLayers.count() == 5) &&
-                    (closingAppLayers.count() == 1 || closingAppLayers.count() == 5)
+                    // Fullscreen: 1 app + 1 recents
+                    // SplitScreen: 2 apps + 2 split containers + 1 split root + 1 recents
+                    (closingAppLayers.count() == 2 || closingAppLayers.count() == 6)
             }
 
         var quickswitchFromLauncherTransitions =
@@ -127,10 +129,10 @@ object TransitionFilters {
                         it.wmData.merge(
                             WmTransitionData(
                                 createTime = createTimeAdjustedForTolerance,
-                                sendTime = createTimeAdjustedForTolerance
+                                sendTime = createTimeAdjustedForTolerance,
                             )
                         ),
-                    shellData = it.shellData
+                    shellData = it.shellData,
                 )
             }
 
@@ -177,7 +179,7 @@ object TransitionFilters {
                     type = transition.wmData.type,
                     changes = listOf(closingAppChange, openingAppChange),
                 ),
-                transition.shellData
+                transition.shellData,
             )
         )
     }
@@ -188,8 +190,7 @@ object TransitionFilters {
                 entry.flattenedLayers.firstOrNull { layer ->
                     ComponentNameMatcher.LAUNCHER.or(ComponentNameMatcher.AOSP_LAUNCHER)
                         .layerMatchesAnyOf(layer)
-                }
-                    ?: return@any false
+                } ?: return@any false
 
             var curLayer = launcherLayer
             while (!curLayer.isTask && curLayer.parent != null) {
diff --git a/libraries/flicker/src/android/tools/flicker/config/appclose/AppCloseToHome.kt b/libraries/flicker/src/android/tools/flicker/config/appclose/AppCloseToHome.kt
index ce0e4f975..f6cf2fa77 100644
--- a/libraries/flicker/src/android/tools/flicker/config/appclose/AppCloseToHome.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/appclose/AppCloseToHome.kt
@@ -34,5 +34,5 @@ val APP_CLOSE_TO_HOME =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.CLOSE_APP_TO_LAUNCHER_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/appclose/Components.kt b/libraries/flicker/src/android/tools/flicker/config/appclose/Components.kt
index ffdd70bcc..6923a8337 100644
--- a/libraries/flicker/src/android/tools/flicker/config/appclose/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/appclose/Components.kt
@@ -32,14 +32,14 @@ object Components {
             closingAppFrom(
                 scenarioInstance.associatedTransition ?: error("Missing associated transition"),
                 scenarioInstance.reader.readLayersTrace(),
-                scenarioInstance.reader.readWmTrace()
+                scenarioInstance.reader.readWmTrace(),
             )
         }
 
     private fun closingAppFrom(
         transition: Transition,
         layersTrace: LayersTrace?,
-        wmTrace: WindowManagerTrace?
+        wmTrace: WindowManagerTrace?,
     ): IComponentMatcher {
         val targetChanges =
             transition.changes.filter {
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunch.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunch.kt
index 3b38221ef..ef3212e9d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunch.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunch.kt
@@ -23,6 +23,6 @@ internal object AppLaunch {
             AppLaunchFromNotification,
             AppLaunchFromRecents,
             AppLaunchFromStatusBarCallChip,
-            AppLaunchFromWidget
+            AppLaunchFromWidget,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromIcon.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromIcon.kt
index b6ab64e60..72931bba9 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromIcon.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromIcon.kt
@@ -35,5 +35,5 @@ val AppLaunchFromIcon =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromNotification.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromNotification.kt
index 3361d210a..b4eb7acad 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromNotification.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromNotification.kt
@@ -35,5 +35,5 @@ val AppLaunchFromNotification =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromRecents.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromRecents.kt
index 1018a421b..54a06a8d0 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromRecents.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromRecents.kt
@@ -35,5 +35,5 @@ val AppLaunchFromRecents =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromStatusBarCallChip.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromStatusBarCallChip.kt
index 5d04b307e..bf95949d5 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromStatusBarCallChip.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromStatusBarCallChip.kt
@@ -35,5 +35,5 @@ val AppLaunchFromStatusBarCallChip =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromWidget.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromWidget.kt
index e35a0cf3a..a8c530111 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromWidget.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/AppLaunchFromWidget.kt
@@ -35,5 +35,5 @@ val AppLaunchFromWidget =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/applaunch/Components.kt b/libraries/flicker/src/android/tools/flicker/config/applaunch/Components.kt
index 6864a0313..34201dc13 100644
--- a/libraries/flicker/src/android/tools/flicker/config/applaunch/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/applaunch/Components.kt
@@ -32,14 +32,14 @@ object Components {
             openingAppFrom(
                 scenarioInstance.associatedTransition ?: error("Missing associated transition"),
                 scenarioInstance.reader.readLayersTrace(),
-                scenarioInstance.reader.readWmTrace()
+                scenarioInstance.reader.readWmTrace(),
             )
         }
 
     private fun openingAppFrom(
         transition: Transition,
         layersTrace: LayersTrace?,
-        wmTrace: WindowManagerTrace?
+        wmTrace: WindowManagerTrace?,
     ): IComponentMatcher {
         val targetChanges =
             transition.changes.filter {
diff --git a/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt b/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
index eba258ea5..e2b466109 100644
--- a/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/desktopmode/Components.kt
@@ -39,11 +39,19 @@ object Components {
             getDesktopAppForScenario(scenarioInstance.type, associatedTransition)
         }
 
+    val SIMPLE_APP =
+        ComponentTemplate("SIMPLE_APP") {
+            ComponentNameMatcher(
+                "com.android.server.wm.flicker.testapp",
+                "com.android.server.wm.flicker.testapp.SimpleActivity",
+            )
+        }
+
     val NON_RESIZABLE_APP =
         ComponentTemplate("NON_RESIZABLE_APP") {
             ComponentNameMatcher(
                 "com.android.server.wm.flicker.testapp",
-                "com.android.server.wm.flicker.testapp.NonResizeableActivity"
+                "com.android.server.wm.flicker.testapp.NonResizeableActivity",
             )
         }
 
@@ -51,13 +59,13 @@ object Components {
         ComponentTemplate("DesktopWallpaper") {
             ComponentNameMatcher(
                 SYSTEMUI_PACKAGE,
-                "com.android.wm.shell.desktopmode.DesktopWallpaperActivity"
+                "com.android.wm.shell.desktopmode.DesktopWallpaperActivity",
             )
         }
 
     private fun getDesktopAppForScenario(
         type: ScenarioId,
-        associatedTransition: Transition
+        associatedTransition: Transition,
     ): IComponentMatcher {
         return when (type) {
             ScenarioId("END_DRAG_TO_DESKTOP") -> {
@@ -71,11 +79,18 @@ object Components {
                     associatedTransition.changes.first { it.transitMode == TransitionType.CLOSE }
                 FullComponentIdMatcher(change.windowId, change.layerId)
             }
+            ScenarioId("OPEN_UNLIMITED_APPS"),
             ScenarioId("CASCADE_APP") -> {
                 val change =
                     associatedTransition.changes.first { it.transitMode == TransitionType.OPEN }
                 FullComponentIdMatcher(change.windowId, change.layerId)
             }
+            ScenarioId("MINIMIZE_APP"),
+            ScenarioId("MINIMIZE_LAST_APP") -> {
+                val change =
+                    associatedTransition.changes.first { it.transitMode == TransitionType.TO_BACK }
+                FullComponentIdMatcher(change.windowId, change.layerId)
+            }
             ScenarioId("CORNER_RESIZE"),
             ScenarioId("CORNER_RESIZE_TO_MINIMUM_SIZE"),
             ScenarioId("CORNER_RESIZE_TO_MAXIMUM_SIZE"),
@@ -85,10 +100,16 @@ object Components {
             ScenarioId("SNAP_RESIZE_LEFT_WITH_BUTTON"),
             ScenarioId("SNAP_RESIZE_RIGHT_WITH_BUTTON"),
             ScenarioId("MAXIMIZE_APP"),
-            ScenarioId("MAXIMIZE_APP_NON_RESIZABLE") -> {
+            ScenarioId("MAXIMIZE_APP_NON_RESIZABLE"),
+            ScenarioId("MINIMIZE_AUTO_PIP_APP") -> {
                 val change = associatedTransition.changes.first()
                 FullComponentIdMatcher(change.windowId, change.layerId)
             }
+            ScenarioId("BRING_APPS_TO_FRONT") -> {
+                val change =
+                    associatedTransition.changes.first { it.transitMode == TransitionType.TO_FRONT }
+                FullComponentIdMatcher(change.windowId, change.layerId)
+            }
             else -> error("Unsupported transition type")
         }
     }
diff --git a/libraries/flicker/src/android/tools/flicker/config/foldables/FoldablesUnfoldAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/foldables/FoldablesUnfoldAnimation.kt
index 77ff9a4aa..244eb986b 100644
--- a/libraries/flicker/src/android/tools/flicker/config/foldables/FoldablesUnfoldAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/foldables/FoldablesUnfoldAnimation.kt
@@ -32,7 +32,7 @@ val FoldablesUnfoldAnimation =
             TaggedScenarioExtractorBuilder()
                 .setTargetTag(CujType.CUJ_UNFOLD_ANIM)
                 .setTransitionMatcher(
-                    TaggedCujTransitionMatcher(associatedTransitionRequired = false),
+                    TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/gesturenav/Quickswitch.kt b/libraries/flicker/src/android/tools/flicker/config/gesturenav/Quickswitch.kt
index de98e5e46..a189234fb 100644
--- a/libraries/flicker/src/android/tools/flicker/config/gesturenav/Quickswitch.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/gesturenav/Quickswitch.kt
@@ -35,8 +35,8 @@ val Quickswitch =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(
                         TransitionFilters.QUICK_SWITCH_TRANSITION_FILTER,
-                        finalTransform = TransitionFilters.QUICK_SWITCH_TRANSITION_POST_PROCESSING
+                        finalTransform = TransitionFilters.QUICK_SWITCH_TRANSITION_POST_PROCESSING,
                     )
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/gesturenav/SwipeToRecentsFromApp.kt b/libraries/flicker/src/android/tools/flicker/config/gesturenav/SwipeToRecentsFromApp.kt
index 8f567ecdc..e6f569b0d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/gesturenav/SwipeToRecentsFromApp.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/gesturenav/SwipeToRecentsFromApp.kt
@@ -36,5 +36,5 @@ val SwipeToRecents =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.CLOSE_APP_TO_LAUNCHER_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsHideAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsHideAnimation.kt
index 88cc92295..49134b91e 100644
--- a/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsHideAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsHideAnimation.kt
@@ -35,7 +35,7 @@ val ImeInsetsHideAnimation =
             AssertionTemplates.COMMON_ASSERTIONS +
                 mapOf(
                     NonAppWindowBecomesInvisible(IME) to AssertionInvocationGroup.BLOCKING,
-                    LayerBecomesInvisible(IME) to AssertionInvocationGroup.BLOCKING
+                    LayerBecomesInvisible(IME) to AssertionInvocationGroup.BLOCKING,
                 ),
         extractor =
             TaggedScenarioExtractorBuilder()
@@ -43,5 +43,5 @@ val ImeInsetsHideAnimation =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsShowAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsShowAnimation.kt
index 6a649b562..81a4a7f02 100644
--- a/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsShowAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/ime/ImeInsetsShowAnimation.kt
@@ -34,10 +34,10 @@ val ImeInsetsShowAnimation =
             AssertionTemplates.COMMON_ASSERTIONS +
                 mapOf(
                     NonAppWindowBecomesVisible(IME) to AssertionInvocationGroup.BLOCKING,
-                    LayerBecomesVisible(IME) to AssertionInvocationGroup.BLOCKING
+                    LayerBecomesVisible(IME) to AssertionInvocationGroup.BLOCKING,
                 ),
         extractor =
             TaggedScenarioExtractorBuilder()
                 .setTargetTag(CujType.CUJ_IME_INSETS_SHOW_ANIMATION)
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/Launcher.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/Launcher.kt
index d0bd0a102..4637e1ede 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/Launcher.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/Launcher.kt
@@ -24,6 +24,6 @@ internal object Launcher {
             LauncherAllAppsOpen,
             LauncherAllAppsScroll,
             LauncherRecentsScrolling,
-            LauncherUnlockEntranceAnimation
+            LauncherUnlockEntranceAnimation,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseSwipe.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseSwipe.kt
index 13e6c5606..543929cdc 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseSwipe.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseSwipe.kt
@@ -34,5 +34,5 @@ val LauncherAllAppsCloseSwipe =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseToHome.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseToHome.kt
index d726fefa6..14fae4e9d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseToHome.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsCloseToHome.kt
@@ -35,5 +35,5 @@ val LauncherAllAppsCloseToHome =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.CLOSE_APP_TO_LAUNCHER_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsOpen.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsOpen.kt
index 67f0b07e3..a57a81f41 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsOpen.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsOpen.kt
@@ -34,5 +34,5 @@ val LauncherAllAppsOpen =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsScroll.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsScroll.kt
index 032f1557e..0c381596d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsScroll.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherAllAppsScroll.kt
@@ -34,5 +34,5 @@ val LauncherAllAppsScroll =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherRecentsScrolling.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherRecentsScrolling.kt
index 71810d4df..12445f59b 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherRecentsScrolling.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherRecentsScrolling.kt
@@ -34,5 +34,5 @@ val LauncherRecentsScrolling =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherUnlockEntranceAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherUnlockEntranceAnimation.kt
index 21b291b2a..b4e6edee7 100644
--- a/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherUnlockEntranceAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/launcher/LauncherUnlockEntranceAnimation.kt
@@ -34,5 +34,5 @@ val LauncherUnlockEntranceAnimation =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/Lockscreen.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/Lockscreen.kt
index f3568b10f..662facc6b 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/Lockscreen.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/Lockscreen.kt
@@ -29,6 +29,6 @@ internal object Lockscreen {
             LockscreenPinDisappear,
             LockscreenTransitionFromAod,
             LockscreenTransitionToAod,
-            LockscreenUnlockAnimation
+            LockscreenUnlockAnimation,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenAppLaunchCamera.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenAppLaunchCamera.kt
index 69365588e..e21d02244 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenAppLaunchCamera.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenAppLaunchCamera.kt
@@ -35,5 +35,5 @@ val LockscreenAppLaunchCamera =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenOcclusion.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenOcclusion.kt
index 9afffc011..e26d6f7db 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenOcclusion.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenOcclusion.kt
@@ -34,5 +34,5 @@ val LockscreenOcclusion =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordAppear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordAppear.kt
index 7403e3424..eb1dcc545 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordAppear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordAppear.kt
@@ -34,5 +34,5 @@ val LockscreenPasswordAppear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordDisappear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordDisappear.kt
index fb3b1fce6..4cb069922 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordDisappear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPasswordDisappear.kt
@@ -34,5 +34,5 @@ val LockscreenPasswordDisappear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternAppear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternAppear.kt
index dc43c8407..a81af3e99 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternAppear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternAppear.kt
@@ -34,5 +34,5 @@ val LockscreenPatternAppear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternDisappear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternDisappear.kt
index b6224cd46..a02e7c544 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternDisappear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPatternDisappear.kt
@@ -34,5 +34,5 @@ val LockscreenPatternDisappear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinAppear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinAppear.kt
index a22541ec7..61ccc5c4a 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinAppear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinAppear.kt
@@ -34,5 +34,5 @@ val LockscreenPinAppear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinDisappear.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinDisappear.kt
index fb9e06d71..9a24bb7cb 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinDisappear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenPinDisappear.kt
@@ -34,5 +34,5 @@ val LockscreenPinDisappear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionFromAod.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionFromAod.kt
index 9d1fae914..995ae0580 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionFromAod.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionFromAod.kt
@@ -34,5 +34,5 @@ val LockscreenTransitionFromAod =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionToAod.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionToAod.kt
index 76e73f9ce..a81de6e85 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionToAod.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenTransitionToAod.kt
@@ -34,5 +34,5 @@ val LockscreenTransitionToAod =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenUnlockAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenUnlockAnimation.kt
index 83d4fa97b..30769cb2e 100644
--- a/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenUnlockAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/lockscreen/LockscreenUnlockAnimation.kt
@@ -34,5 +34,5 @@ val LockscreenUnlockAnimation =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/Notification.kt b/libraries/flicker/src/android/tools/flicker/config/notification/Notification.kt
index 5a52afaa0..2154dba79 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/Notification.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/Notification.kt
@@ -34,6 +34,6 @@ internal object Notification {
             NotificationRemove,
             NotificationRowExpand,
             NotificationRowSwipe,
-            NotificationScrollFling
+            NotificationScrollFling,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAdd.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAdd.kt
index fbf8da193..477af6de4 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAdd.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAdd.kt
@@ -34,5 +34,5 @@ val NotificationAdd =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromHistory.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromHistory.kt
index 7e852c65c..14bc482bd 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromHistory.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromHistory.kt
@@ -35,5 +35,5 @@ val NotificationAppLaunchFromHistory =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromMediaPlayer.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromMediaPlayer.kt
index 9d62a2148..efbc2ed03 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromMediaPlayer.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromMediaPlayer.kt
@@ -35,5 +35,5 @@ val NotificationAppLaunchFromMediaPlayer =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromQsTile.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromQsTile.kt
index 315f46142..d58e88759 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromQsTile.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromQsTile.kt
@@ -35,5 +35,5 @@ val NotificationAppLaunchFromQsTile =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromSettingsButton.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromSettingsButton.kt
index 7cb08bfcb..57a2ede5a 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromSettingsButton.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationAppLaunchFromSettingsButton.kt
@@ -35,5 +35,5 @@ val NotificationAppLaunchFromSettingsButton =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.OPEN_APP_TRANSITION_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationClearAll.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationClearAll.kt
index e8f45a06f..27ff0083f 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationClearAll.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationClearAll.kt
@@ -34,5 +34,5 @@ val NotificationClearAll =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationDialogOpen.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationDialogOpen.kt
index ecf323286..299c1fcb0 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationDialogOpen.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationDialogOpen.kt
@@ -34,5 +34,5 @@ val NotificationDialogOpen =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationExpandCollapse.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationExpandCollapse.kt
index 8f977f440..b166d877f 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationExpandCollapse.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationExpandCollapse.kt
@@ -34,5 +34,5 @@ val NotificationExpandCollapse =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpAppear.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpAppear.kt
index 9ed1ba4f4..da374ad2c 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpAppear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpAppear.kt
@@ -34,5 +34,5 @@ val NotificationHeadsUpAppear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpDisappear.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpDisappear.kt
index 0b7cee7c5..eb8bab745 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpDisappear.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationHeadsUpDisappear.kt
@@ -34,5 +34,5 @@ val NotificationHeadsUpDisappear =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsExpandCollapse.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsExpandCollapse.kt
index 9258be3b8..92ebf345d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsExpandCollapse.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsExpandCollapse.kt
@@ -34,5 +34,5 @@ val NotificationQsExpandCollapse =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsScrollSwipe.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsScrollSwipe.kt
index a53700452..2fe6a7dba 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsScrollSwipe.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationQsScrollSwipe.kt
@@ -34,5 +34,5 @@ val NotificationQsScrollSwipe =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRemove.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRemove.kt
index bdc781f32..f1e92a106 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRemove.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRemove.kt
@@ -34,5 +34,5 @@ val NotificationRemove =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowExpand.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowExpand.kt
index eaa7f085f..ad2aa942f 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowExpand.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowExpand.kt
@@ -34,5 +34,5 @@ val NotificationRowExpand =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowSwipe.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowSwipe.kt
index b16182427..a7edd97d9 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowSwipe.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationRowSwipe.kt
@@ -34,5 +34,5 @@ val NotificationRowSwipe =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationScrollFling.kt b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationScrollFling.kt
index 29b049a71..08e5eecf8 100644
--- a/libraries/flicker/src/android/tools/flicker/config/notification/NotificationScrollFling.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/notification/NotificationScrollFling.kt
@@ -34,5 +34,5 @@ val NotificationScrollFling =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/EntireTrace.kt b/libraries/flicker/src/android/tools/flicker/config/others/EntireTrace.kt
index e47b51db5..03c7a8744 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/EntireTrace.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/EntireTrace.kt
@@ -26,5 +26,5 @@ val EntireTrace =
         assertions = AssertionTemplates.ENTIRE_TRACE_ASSERTIONS,
         extractor = EntireTraceExtractor(),
         enabled = true,
-        scenarioId = ScenarioId("ENTIRE_TRACE")
+        scenarioId = ScenarioId("ENTIRE_TRACE"),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/Others.kt b/libraries/flicker/src/android/tools/flicker/config/others/Others.kt
index 14d0b6960..e8634abed 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/Others.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/Others.kt
@@ -28,6 +28,6 @@ internal object Others {
             OthersTakeScreenshot,
             OthersUserDialogOpen,
             OthersUserSwitch,
-            OthersVolumeControl
+            OthersVolumeControl,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersBiometricPromptTransition.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersBiometricPromptTransition.kt
index a8cfd4437..4c13a2a4e 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersBiometricPromptTransition.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersBiometricPromptTransition.kt
@@ -34,5 +34,5 @@ val OthersBiometricPromptTransition =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedEnterTransition.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedEnterTransition.kt
index cbc8aaa20..50730fde5 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedEnterTransition.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedEnterTransition.kt
@@ -34,5 +34,5 @@ val OthersOneHandedEnterTransition =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedExitTransition.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedExitTransition.kt
index 738ec3113..22a04a9c0 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedExitTransition.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersOneHandedExitTransition.kt
@@ -34,5 +34,5 @@ val OthersOneHandedExitTransition =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOff.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOff.kt
index 0b68e5966..2a2abe1ee 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOff.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOff.kt
@@ -34,5 +34,5 @@ val OthersScreenOff =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOffShowAod.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOffShowAod.kt
index d2c41eaf1..bd8a3eeb5 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOffShowAod.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersScreenOffShowAod.kt
@@ -34,5 +34,5 @@ val OthersScreenOffShowAod =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersTakeScreenshot.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersTakeScreenshot.kt
index 1b55ea060..12c4576ab 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersTakeScreenshot.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersTakeScreenshot.kt
@@ -34,5 +34,5 @@ val OthersTakeScreenshot =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersUserDialogOpen.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersUserDialogOpen.kt
index 0ad0f3f57..b4c3cec67 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersUserDialogOpen.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersUserDialogOpen.kt
@@ -34,5 +34,5 @@ val OthersUserDialogOpen =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersUserSwitch.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersUserSwitch.kt
index 60cff09ed..4afe42ba7 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersUserSwitch.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersUserSwitch.kt
@@ -34,5 +34,5 @@ val OthersUserSwitch =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/others/OthersVolumeControl.kt b/libraries/flicker/src/android/tools/flicker/config/others/OthersVolumeControl.kt
index 1416c9a6c..0d1f41cce 100644
--- a/libraries/flicker/src/android/tools/flicker/config/others/OthersVolumeControl.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/others/OthersVolumeControl.kt
@@ -34,5 +34,5 @@ val OthersVolumeControl =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/pip/AppCloseToPip.kt b/libraries/flicker/src/android/tools/flicker/config/pip/AppCloseToPip.kt
index 5aef2a199..f2ed98243 100644
--- a/libraries/flicker/src/android/tools/flicker/config/pip/AppCloseToPip.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/pip/AppCloseToPip.kt
@@ -56,11 +56,11 @@ val AppCloseToPip =
                                     cujEntry.cuj,
                                     closeToHomeCuj.startTimestamp,
                                     cujEntry.endTimestamp,
-                                    cujEntry.canceled
+                                    cujEntry.canceled,
                                 )
                             }
                         }
                     }
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/pip/Components.kt b/libraries/flicker/src/android/tools/flicker/config/pip/Components.kt
index 5a8eb81df..4e8d0f3e5 100644
--- a/libraries/flicker/src/android/tools/flicker/config/pip/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/pip/Components.kt
@@ -36,8 +36,7 @@ object Components {
                 val change =
                     associatedTransition.changes.firstOrNull {
                         it.transitMode == TransitionType.TO_BACK
-                    }
-                        ?: error("Missing to back change")
+                    } ?: error("Missing to back change")
                 FullComponentIdMatcher(change.windowId, change.layerId)
             } else {
                 error("Unhandled case - can't get PiP app for this case")
diff --git a/libraries/flicker/src/android/tools/flicker/config/pip/PipTransition.kt b/libraries/flicker/src/android/tools/flicker/config/pip/PipTransition.kt
index ee23e4c7b..6c2460852 100644
--- a/libraries/flicker/src/android/tools/flicker/config/pip/PipTransition.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/pip/PipTransition.kt
@@ -34,5 +34,5 @@ val PipTransition =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsPageScroll.kt b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsPageScroll.kt
index 26720d424..4f4f8fc6e 100644
--- a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsPageScroll.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsPageScroll.kt
@@ -34,5 +34,5 @@ val SettingsPageScroll =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsSlider.kt b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsSlider.kt
index 4390de280..995db0947 100644
--- a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsSlider.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsSlider.kt
@@ -34,5 +34,5 @@ val SettingsSlider =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsToggle.kt b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsToggle.kt
index e77bfdfdd..b3da3a52b 100644
--- a/libraries/flicker/src/android/tools/flicker/config/settings/SettingsToggle.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/settings/SettingsToggle.kt
@@ -34,5 +34,5 @@ val SettingsToggle =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenAvd.kt b/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenAvd.kt
index 570799a1c..81fda75f1 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenAvd.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenAvd.kt
@@ -34,5 +34,5 @@ val SplashscreenAvd =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenExitAnimation.kt b/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenExitAnimation.kt
index 91035f00a..5d4e54d69 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenExitAnimation.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splashscreen/SplashscreenExitAnimation.kt
@@ -34,5 +34,5 @@ val SplashscreenExitAnimation =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/splitscreen/Components.kt b/libraries/flicker/src/android/tools/flicker/config/splitscreen/Components.kt
index a5384e09f..d805a9b43 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splitscreen/Components.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splitscreen/Components.kt
@@ -88,7 +88,7 @@ object Components {
 
     private fun getSplitscreenOpeningComponentMatchers(
         associatedTransition: Transition,
-        layersTrace: LayersTrace
+        layersTrace: LayersTrace,
     ): List<IComponentMatcher> {
         // Task (part of changes)
         // - Task (part of changes)
diff --git a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenEnter.kt b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenEnter.kt
index 8a14aac3f..5e61e009d 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenEnter.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenEnter.kt
@@ -30,5 +30,5 @@ val SplitScreenEnter =
         extractor =
             ShellTransitionScenarioExtractor(
                 transitionMatcher = TransitionFilters.ENTER_SPLIT_SCREEN_MATCHER
-            )
+            ),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenExit.kt b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenExit.kt
index c03f323a8..094660c39 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenExit.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenExit.kt
@@ -35,5 +35,5 @@ val SplitScreenExit =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(TransitionFilters.EXIT_SPLIT_SCREEN_FILTER)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenResize.kt b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenResize.kt
index 789a18a5b..39229cf98 100644
--- a/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenResize.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/splitscreen/SplitScreenResize.kt
@@ -36,11 +36,11 @@ val SplitScreenResize =
                     TaggedCujTransitionMatcher(
                         TransitionFilters.RESIZE_SPLIT_SCREEN_FILTER,
                         // No match will be found when resizing all the way to dismissing
-                        associatedTransitionRequired = false
+                        associatedTransitionRequired = false,
                     )
                 )
                 // If we don't find a matching transition, we probably dismissed splitscreen so
                 // don't consider as a splitscreen resize scenario.
                 .setIgnoreIfNoMatchingTransition(true)
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/suw/Suw.kt b/libraries/flicker/src/android/tools/flicker/config/suw/Suw.kt
index c3290149c..94dfce659 100644
--- a/libraries/flicker/src/android/tools/flicker/config/suw/Suw.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/suw/Suw.kt
@@ -22,6 +22,6 @@ internal object Suw {
             SuwLoadingScreenForStatus,
             SuwLoadingToNextFlow,
             SuwLoadingToShowInfoWithActions,
-            SuwShowFunctionScreenWithActions
+            SuwShowFunctionScreenWithActions,
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingScreenForStatus.kt b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingScreenForStatus.kt
index dcd57dab6..a0f043414 100644
--- a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingScreenForStatus.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingScreenForStatus.kt
@@ -34,5 +34,5 @@ val SuwLoadingScreenForStatus =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToNextFlow.kt b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToNextFlow.kt
index c8a666063..eb467b267 100644
--- a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToNextFlow.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToNextFlow.kt
@@ -34,5 +34,5 @@ val SuwLoadingToNextFlow =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToShowInfoWithActions.kt b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToShowInfoWithActions.kt
index fe3ffe0e8..ee7758451 100644
--- a/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToShowInfoWithActions.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/suw/SuwLoadingToShowInfoWithActions.kt
@@ -34,5 +34,5 @@ val SuwLoadingToShowInfoWithActions =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/suw/SuwShowFunctionScreenWithActions.kt b/libraries/flicker/src/android/tools/flicker/config/suw/SuwShowFunctionScreenWithActions.kt
index 5bfb799d0..8d009e425 100644
--- a/libraries/flicker/src/android/tools/flicker/config/suw/SuwShowFunctionScreenWithActions.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/suw/SuwShowFunctionScreenWithActions.kt
@@ -34,5 +34,5 @@ val SuwShowFunctionScreenWithActions =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarCollapse.kt b/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarCollapse.kt
index 58dca7cee..306576668 100644
--- a/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarCollapse.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarCollapse.kt
@@ -34,5 +34,5 @@ val TaskbarCollapse =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarExpand.kt b/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarExpand.kt
index fa180634e..4dfa5e5cb 100644
--- a/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarExpand.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/taskbar/TaskbarExpand.kt
@@ -34,5 +34,5 @@ val TaskbarExpand =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/config/wallpaper/WallpaperTransition.kt b/libraries/flicker/src/android/tools/flicker/config/wallpaper/WallpaperTransition.kt
index 3da04b3b4..a459fdb68 100644
--- a/libraries/flicker/src/android/tools/flicker/config/wallpaper/WallpaperTransition.kt
+++ b/libraries/flicker/src/android/tools/flicker/config/wallpaper/WallpaperTransition.kt
@@ -34,5 +34,5 @@ val WallpaperTransition =
                 .setTransitionMatcher(
                     TaggedCujTransitionMatcher(associatedTransitionRequired = false)
                 )
-                .build()
+                .build(),
     )
diff --git a/libraries/flicker/src/android/tools/flicker/datastore/CachedAssertionRunner.kt b/libraries/flicker/src/android/tools/flicker/datastore/CachedAssertionRunner.kt
index bc1abc7f0..4a96c27f0 100644
--- a/libraries/flicker/src/android/tools/flicker/datastore/CachedAssertionRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/datastore/CachedAssertionRunner.kt
@@ -32,7 +32,7 @@ import android.tools.withTracing
 class CachedAssertionRunner(
     private val scenario: Scenario,
     resultReader: Reader =
-        android.tools.flicker.datastore.CachedResultReader(scenario, TRACE_CONFIG_REQUIRE_CHANGES)
+        android.tools.flicker.datastore.CachedResultReader(scenario, TRACE_CONFIG_REQUIRE_CHANGES),
 ) : BaseAssertionRunner(resultReader) {
     override fun doUpdateStatus(newStatus: RunStatus) {
         return withTracing("${this::class.simpleName}#doUpdateStatus") {
diff --git a/libraries/flicker/src/android/tools/flicker/datastore/CachedResultReader.kt b/libraries/flicker/src/android/tools/flicker/datastore/CachedResultReader.kt
index 0a92d8374..928bf3e9a 100644
--- a/libraries/flicker/src/android/tools/flicker/datastore/CachedResultReader.kt
+++ b/libraries/flicker/src/android/tools/flicker/datastore/CachedResultReader.kt
@@ -28,8 +28,8 @@ class CachedResultReader(
     private val reader: Reader =
         ResultReaderWithLru(
             android.tools.flicker.datastore.DataStore.getResult(scenario),
-            traceConfig
-        )
+            traceConfig,
+        ),
 ) : Reader by reader {
     override fun toString(): String = "$scenario ($reader)"
 }
diff --git a/libraries/flicker/src/android/tools/flicker/datastore/DataStore.kt b/libraries/flicker/src/android/tools/flicker/datastore/DataStore.kt
index ba331eafa..8c69a8205 100644
--- a/libraries/flicker/src/android/tools/flicker/datastore/DataStore.kt
+++ b/libraries/flicker/src/android/tools/flicker/datastore/DataStore.kt
@@ -31,7 +31,7 @@ object DataStore {
     data class Backup(
         val cachedResults: MutableMap<Scenario, IResultData>,
         val cachedFlickerServiceAssertions:
-            MutableMap<Scenario, Map<ScenarioInstance, Collection<ScenarioAssertion>>>
+            MutableMap<Scenario, Map<ScenarioInstance, Collection<ScenarioAssertion>>>,
     )
 
     @VisibleForTesting
@@ -43,7 +43,7 @@ object DataStore {
     fun backup(): android.tools.flicker.datastore.DataStore.Backup {
         return android.tools.flicker.datastore.DataStore.Backup(
             android.tools.flicker.datastore.DataStore.cachedResults.toMutableMap(),
-            android.tools.flicker.datastore.DataStore.cachedFlickerServiceAssertions.toMutableMap()
+            android.tools.flicker.datastore.DataStore.cachedFlickerServiceAssertions.toMutableMap(),
         )
     }
 
@@ -97,7 +97,7 @@ object DataStore {
 
     fun addFlickerServiceAssertions(
         scenario: Scenario,
-        groupedAssertions: Map<ScenarioInstance, Collection<ScenarioAssertion>>
+        groupedAssertions: Map<ScenarioInstance, Collection<ScenarioAssertion>>,
     ) {
         if (android.tools.flicker.datastore.DataStore.containsFlickerServiceResult(scenario)) {
             error("Result for $scenario already in data store")
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/ShellTransitionScenarioExtractor.kt b/libraries/flicker/src/android/tools/flicker/extractors/ShellTransitionScenarioExtractor.kt
index 39635910a..d2936f248 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/ShellTransitionScenarioExtractor.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/ShellTransitionScenarioExtractor.kt
@@ -18,9 +18,8 @@ package android.tools.flicker.extractors
 
 import android.tools.io.Reader
 
-class ShellTransitionScenarioExtractor(
-    private val transitionMatcher: ITransitionMatcher,
-) : ScenarioExtractor {
+class ShellTransitionScenarioExtractor(private val transitionMatcher: ITransitionMatcher) :
+    ScenarioExtractor {
     override fun extract(reader: Reader): List<TraceSlice> {
         val transitionsTrace = reader.readTransitionsTrace() ?: error("Missing transitions trace")
         val completeTransitions = transitionsTrace.entries.filter { !it.isIncomplete }
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/TaggedCujTransitionMatcher.kt b/libraries/flicker/src/android/tools/flicker/extractors/TaggedCujTransitionMatcher.kt
index 719e6e454..cf81dbfea 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/TaggedCujTransitionMatcher.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/TaggedCujTransitionMatcher.kt
@@ -53,7 +53,7 @@ class TaggedCujTransitionMatcher(
                 "${
                     transitions.joinToString(",\n") {
                             Transition.Formatter(reader.readLayersTrace(),
-                                    reader.readWmTrace()).format(it)
+                                    reader.readWmTrace(),).format(it)
                         }.prependIndent()
                     }\n" +
                 "]"
@@ -76,7 +76,7 @@ class TaggedCujTransitionMatcher(
                                 "the following transitions (CUJ=${cujEntry.cuj.name}" +
                                 "[${cujEntry.startTimestamp},${cujEntry.endTimestamp}]):\n " +
                                 formattedTransitions(transitions),
-                            e
+                            e,
                         )
                     }
 
@@ -149,7 +149,7 @@ object TransitionTransforms {
                 isTrampolinedOpenTransition(
                     transitions.first(),
                     transitions.drop(1).first(),
-                    reader
+                    reader,
                 )
         ) {
             // Remove the trampoline transition
@@ -183,7 +183,7 @@ object TransitionTransforms {
     private fun isTrampolinedOpenTransition(
         firstTransition: Transition,
         secondTransition: Transition,
-        reader: Reader
+        reader: Reader,
     ): Boolean {
         val candidateTaskLayers =
             firstTransition.changes
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractor.kt b/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractor.kt
index a616cd2a4..a150b46cb 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractor.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractor.kt
@@ -34,7 +34,7 @@ class TaggedScenarioExtractor(
     private val ignoreIfNoMatchingTransition: Boolean = false,
 ) : ScenarioExtractor {
     companion object {
-        val LOG_TAG = "FlickerTaggedScenarioExtractor"
+        const val LOG_TAG = "FlickerTaggedScenarioExtractor"
     }
 
     override fun extract(reader: Reader): List<TraceSlice> {
@@ -60,7 +60,7 @@ class TaggedScenarioExtractor(
                     LOG_TAG,
                     "Got more than one associated transition: " +
                         "[${associatedTransitions?.joinToString()}]. " +
-                        "Picking first transition in list."
+                        "Picking first transition in list.",
                 )
             }
 
@@ -82,7 +82,7 @@ class TaggedScenarioExtractor(
                 startTimestamp,
                 endTimestamp,
                 associatedCuj = cujEntry.cuj,
-                associatedTransition = associatedTransition
+                associatedTransition = associatedTransition,
             )
         }
     }
@@ -90,7 +90,7 @@ class TaggedScenarioExtractor(
     private fun estimateScenarioStartTimestamp(
         cujEntry: Cuj,
         associatedTransition: Transition?,
-        reader: Reader
+        reader: Reader,
     ): Timestamp {
         val interpolatedStartTimestamp =
             if (associatedTransition != null) {
@@ -103,33 +103,33 @@ class TaggedScenarioExtractor(
             elapsedNanos =
                 min(
                     cujEntry.startTimestamp.elapsedNanos,
-                    interpolatedStartTimestamp?.elapsedNanos ?: cujEntry.startTimestamp.elapsedNanos
+                    interpolatedStartTimestamp?.elapsedNanos ?: cujEntry.startTimestamp.elapsedNanos,
                 ),
             systemUptimeNanos =
                 min(
                     cujEntry.startTimestamp.systemUptimeNanos,
                     interpolatedStartTimestamp?.systemUptimeNanos
-                        ?: cujEntry.startTimestamp.systemUptimeNanos
+                        ?: cujEntry.startTimestamp.systemUptimeNanos,
                 ),
             unixNanos =
                 min(
                     cujEntry.startTimestamp.unixNanos,
-                    interpolatedStartTimestamp?.unixNanos ?: cujEntry.startTimestamp.unixNanos
-                )
+                    interpolatedStartTimestamp?.unixNanos ?: cujEntry.startTimestamp.unixNanos,
+                ),
         )
     }
 
     private fun estimateScenarioEndTimestamp(
         cujEntry: Cuj,
         associatedTransition: Transition?,
-        reader: Reader
+        reader: Reader,
     ): Timestamp {
         val interpolatedEndTimestamp =
             if (associatedTransition != null) {
                 Utils.interpolateFinishTimestampFromTransition(
                     associatedTransition,
                     reader,
-                    cujEntry.toString()
+                    cujEntry.toString(),
                 )
             } else {
                 val layersTrace = reader.readLayersTrace() ?: error("Missing layers trace")
@@ -143,9 +143,9 @@ class TaggedScenarioExtractor(
             systemUptimeNanos =
                 max(
                     cujEntry.endTimestamp.systemUptimeNanos,
-                    interpolatedEndTimestamp.systemUptimeNanos
+                    interpolatedEndTimestamp.systemUptimeNanos,
                 ),
-            unixNanos = max(cujEntry.endTimestamp.unixNanos, interpolatedEndTimestamp.unixNanos)
+            unixNanos = max(cujEntry.endTimestamp.unixNanos, interpolatedEndTimestamp.unixNanos),
         )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractorBuilder.kt b/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractorBuilder.kt
index 5c772ba3e..ef8c0c928 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractorBuilder.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/TaggedScenarioExtractorBuilder.kt
@@ -51,7 +51,7 @@ class TaggedScenarioExtractorBuilder {
             transitionMatcher,
             adjustCuj,
             additionalCujFilter,
-            ignoreIfNoMatchingTransition
+            ignoreIfNoMatchingTransition,
         )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/extractors/TraceSlice.kt b/libraries/flicker/src/android/tools/flicker/extractors/TraceSlice.kt
index 63e91531f..29d692528 100644
--- a/libraries/flicker/src/android/tools/flicker/extractors/TraceSlice.kt
+++ b/libraries/flicker/src/android/tools/flicker/extractors/TraceSlice.kt
@@ -24,7 +24,7 @@ data class TraceSlice(
     val startTimestamp: Timestamp,
     val endTimestamp: Timestamp,
     val associatedTransition: Transition? = null,
-    val associatedCuj: ICujType? = null
+    val associatedCuj: ICujType? = null,
 ) {
     init {
         require(startTimestamp.hasAllTimestamps) {
diff --git a/libraries/flicker/src/android/tools/flicker/junit/AbstractFlickerRunnerDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/AbstractFlickerRunnerDecorator.kt
index ebbb01707..8a1f46df1 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/AbstractFlickerRunnerDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/AbstractFlickerRunnerDecorator.kt
@@ -24,7 +24,7 @@ import org.junit.runners.model.TestClass
 abstract class AbstractFlickerRunnerDecorator(
     protected val testClass: TestClass,
     protected val inner: IFlickerJUnitDecorator?,
-    protected val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
+    protected val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
 ) : IFlickerJUnitDecorator {
     override fun doValidateConstructor(): List<Throwable> {
         val errors = mutableListOf<Throwable>()
diff --git a/libraries/flicker/src/android/tools/flicker/junit/AnonymousInjectedTestCase.kt b/libraries/flicker/src/android/tools/flicker/junit/AnonymousInjectedTestCase.kt
index 8f71a04d3..35c129603 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/AnonymousInjectedTestCase.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/AnonymousInjectedTestCase.kt
@@ -23,7 +23,7 @@ class AnonymousInjectedTestCase(
     method: Method,
     name: String,
     injectedBy: IFlickerJUnitDecorator,
-    val assertion: () -> Unit
+    val assertion: () -> Unit,
 ) : InjectedTestCase(method, name, injectedBy) {
     override fun execute(description: Description) {
         assertion()
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerBuilderProvider.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerBuilderProvider.kt
index 9ef09f266..833501925 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerBuilderProvider.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerBuilderProvider.kt
@@ -20,6 +20,6 @@ package android.tools.flicker.junit
 @Target(
     AnnotationTarget.FUNCTION,
     AnnotationTarget.PROPERTY_GETTER,
-    AnnotationTarget.PROPERTY_SETTER
+    AnnotationTarget.PROPERTY_SETTER,
 )
 annotation class FlickerBuilderProvider
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerParametersRunnerFactory.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerParametersRunnerFactory.kt
index 2af051a4c..5e5e3ed74 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerParametersRunnerFactory.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerParametersRunnerFactory.kt
@@ -43,7 +43,7 @@ class FlickerParametersRunnerFactory : ParametersRunnerFactory {
             TestWithParameters(
                 /*name */ "[${scenario.description}]",
                 /* testClass */ test.testClass,
-                /* parameters */ test.parameters
+                /* parameters */ test.parameters,
             )
         return LegacyFlickerJUnit4ClassRunner(newTest, scenario, arguments)
     }
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceCachedTestCase.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceCachedTestCase.kt
index 46a8000b1..ecbf40550 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceCachedTestCase.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceCachedTestCase.kt
@@ -49,13 +49,13 @@ class FlickerServiceCachedTestCase(
 
             metricBundle.putString(
                 getKeyForAssertionResult(result),
-                if (result.status == AssertionResult.Status.PASS) "0" else "1"
+                if (result.status == AssertionResult.Status.PASS) "0" else "1",
             )
             SendToInstrumentation.sendBundle(instrumentation, metricBundle)
 
             Assume.assumeTrue(
                 "FaaS Test was non blocking - skipped",
-                !skipNonBlocking || result.stabilityGroup == AssertionInvocationGroup.BLOCKING
+                !skipNonBlocking || result.stabilityGroup == AssertionInvocationGroup.BLOCKING,
             )
             result.assertionErrors.firstOrNull()?.let { throw it }
         } catch (e: Throwable) {
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
index d971252f2..22ad87f36 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceDecorator.kt
@@ -50,7 +50,7 @@ class FlickerServiceDecorator(
     private val skipNonBlocking: Boolean,
     inner: IFlickerJUnitDecorator?,
     instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    flickerService: FlickerService? = null
+    flickerService: FlickerService? = null,
 ) : AbstractFlickerRunnerDecorator(testClass, inner, instrumentation) {
     private val flickerService by lazy { flickerService ?: FlickerService(getFlickerConfig()) }
 
@@ -86,7 +86,7 @@ class FlickerServiceDecorator(
                                 Utils.notifyRunnerProgress(
                                     testClassName,
                                     "Running setup",
-                                    instrumentation
+                                    instrumentation,
                                 )
                                 val befores = testClass.getAnnotatedMethods(Before::class.java)
                                 befores.forEach { it.invokeExplosively(test) }
@@ -94,7 +94,7 @@ class FlickerServiceDecorator(
                                 Utils.notifyRunnerProgress(
                                     testClassName,
                                     "Running transition",
-                                    instrumentation
+                                    instrumentation,
                                 )
                                 writer.setTransitionStartTime(now())
                                 method.invokeExplosively(test)
@@ -103,7 +103,7 @@ class FlickerServiceDecorator(
                                 Utils.notifyRunnerProgress(
                                     testClassName,
                                     "Running teardown",
-                                    instrumentation
+                                    instrumentation,
                                 )
                                 val afters = testClass.getAnnotatedMethods(After::class.java)
                                 afters.forEach { it.invokeExplosively(test) }
@@ -117,7 +117,7 @@ class FlickerServiceDecorator(
                         Utils.notifyRunnerProgress(
                             testClassName,
                             "Computing Flicker service tests",
-                            instrumentation
+                            instrumentation,
                         )
                         try {
                             flickerServiceMethodsFor[method] =
@@ -270,14 +270,13 @@ class FlickerServiceDecorator(
     private fun computeFlickerServiceTests(
         reader: Reader,
         testScenario: Scenario,
-        method: FrameworkMethod
+        method: FrameworkMethod,
     ): Collection<InjectedTestCase> {
         val expectedScenarios =
             (method.annotations
                     .filterIsInstance<ExpectedScenarios>()
                     .firstOrNull()
-                    ?.expectedScenarios
-                    ?: emptyArray())
+                    ?.expectedScenarios ?: emptyArray())
                 .map { ScenarioId(it) }
                 .toSet()
 
@@ -289,7 +288,7 @@ class FlickerServiceDecorator(
             flickerService,
             instrumentation,
             this,
-            skipNonBlocking
+            skipNonBlocking,
         )
     }
 
@@ -297,7 +296,7 @@ class FlickerServiceDecorator(
         private fun getDetectedScenarios(
             testScenario: Scenario,
             reader: Reader,
-            flickerService: FlickerService
+            flickerService: FlickerService,
         ): Collection<ScenarioId> {
             val groupedAssertions = getGroupedAssertions(testScenario, reader, flickerService)
             return groupedAssertions.keys.map { it.type }.distinct()
@@ -321,7 +320,7 @@ class FlickerServiceDecorator(
                 val groupedAssertions = detectedScenarios.associateWith { it.generateAssertions() }
                 android.tools.flicker.datastore.DataStore.addFlickerServiceAssertions(
                     testScenario,
-                    groupedAssertions
+                    groupedAssertions,
                 )
             }
 
@@ -379,7 +378,7 @@ class FlickerServiceDecorator(
                 AnonymousInjectedTestCase(
                     getCachedResultMethod(),
                     "FaaS_DetectedExpectedScenarios$paramString",
-                    injectedBy = caller
+                    injectedBy = caller,
                 ) {
                     val metricBundle = Bundle()
                     metricBundle.putString(FLICKER_ASSERTIONS_COUNT_KEY, "${faasTestCases.size}")
diff --git a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunner.kt b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunner.kt
index d69d927d9..4409395cb 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunner.kt
@@ -52,7 +52,7 @@ class FlickerServiceJUnit4ClassRunner
 constructor(
     testClass: Class<*>?,
     paramString: String? = null,
-    private val arguments: Bundle = InstrumentationRegistry.getArguments()
+    private val arguments: Bundle = InstrumentationRegistry.getArguments(),
 ) : BlockJUnit4ClassRunner(testClass), IFlickerJUnitDecorator {
 
     private val onlyBlocking: Boolean
@@ -63,7 +63,7 @@ constructor(
             this.testClass,
             paramString = paramString,
             onlyBlocking,
-            inner = this
+            inner = this,
         )
 
     private var initialized: Boolean? = null
diff --git a/libraries/flicker/src/android/tools/flicker/junit/IFlickerJUnitDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/IFlickerJUnitDecorator.kt
index 06bc9783e..d09b938ed 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/IFlickerJUnitDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/IFlickerJUnitDecorator.kt
@@ -34,5 +34,6 @@ interface IFlickerJUnitDecorator {
     fun getMethodInvoker(method: FrameworkMethod, test: Any): Statement
 
     fun shouldRunBeforeOn(method: FrameworkMethod): Boolean
+
     fun shouldRunAfterOn(method: FrameworkMethod): Boolean
 }
diff --git a/libraries/flicker/src/android/tools/flicker/junit/InjectedTestCase.kt b/libraries/flicker/src/android/tools/flicker/junit/InjectedTestCase.kt
index c05e9f56c..838ddba60 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/InjectedTestCase.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/InjectedTestCase.kt
@@ -23,7 +23,7 @@ import org.junit.runners.model.FrameworkMethod
 abstract class InjectedTestCase(
     method: Method,
     private val _name: String,
-    val injectedBy: IFlickerJUnitDecorator
+    val injectedBy: IFlickerJUnitDecorator,
 ) : FrameworkMethod(method) {
     override fun invokeExplosively(target: Any?, vararg params: Any?): Any {
         error("Shouldn't have reached here")
@@ -34,6 +34,7 @@ abstract class InjectedTestCase(
     abstract fun execute(description: Description)
 
     override fun toString() = _name
+
     override fun equals(other: Any?): Boolean {
         if (this === other) return true
         if (other !is InjectedTestCase) return false
diff --git a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerDecorator.kt
index 7d473d794..81c690420 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerDecorator.kt
@@ -30,7 +30,7 @@ class LegacyFlickerDecorator(
     testClass: TestClass,
     val scenario: Scenario?,
     val transitionRunner: ITransitionRunner,
-    inner: IFlickerJUnitDecorator? = null
+    inner: IFlickerJUnitDecorator? = null,
 ) : AbstractFlickerRunnerDecorator(testClass, inner) {
     override fun getChildDescription(method: FrameworkMethod): Description {
         return inner?.getChildDescription(method)
diff --git a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunner.kt b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunner.kt
index a2b49d363..a07b75660 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunner.kt
@@ -74,12 +74,13 @@ import org.junit.runners.parameterized.TestWithParameters
 class LegacyFlickerJUnit4ClassRunner(
     test: TestWithParameters?,
     private val scenario: Scenario?,
-    private val arguments: Bundle = InstrumentationRegistry.getArguments()
+    private val arguments: Bundle = InstrumentationRegistry.getArguments(),
 ) : BlockJUnit4ClassRunnerWithParameters(test), IFlickerJUnitDecorator {
     private val onlyBlocking
         get() =
             scenario?.getConfigValue<Boolean>(Scenario.FAAS_BLOCKING)
-                ?: arguments.getString(Scenario.FAAS_BLOCKING)?.toBoolean() ?: true
+                ?: arguments.getString(Scenario.FAAS_BLOCKING)?.toBoolean()
+                ?: true
 
     @VisibleForTesting
     val transitionRunner =
@@ -121,7 +122,7 @@ class LegacyFlickerJUnit4ClassRunner(
             transitionRunner,
             arguments = arguments,
             skipNonBlocking = onlyBlocking,
-            inner = LegacyFlickerDecorator(this.testClass, scenario, transitionRunner, inner = this)
+            inner = LegacyFlickerDecorator(this.testClass, scenario, transitionRunner, inner = this),
         )
 
     init {
diff --git a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerServiceDecorator.kt b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerServiceDecorator.kt
index c4d1d809c..73e644787 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerServiceDecorator.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerServiceDecorator.kt
@@ -43,7 +43,7 @@ class LegacyFlickerServiceDecorator(
     private val transitionRunner: ITransitionRunner,
     private val skipNonBlocking: Boolean,
     private val arguments: Bundle,
-    inner: IFlickerJUnitDecorator?
+    inner: IFlickerJUnitDecorator?,
 ) : AbstractFlickerRunnerDecorator(testClass, inner) {
     private val flickerService by lazy { FlickerService(getFlickerConfig()) }
 
@@ -67,7 +67,7 @@ class LegacyFlickerServiceDecorator(
             Description.createTestDescription(
                 testClass.javaClass,
                 "${method.name}[${scenario.description}]",
-                *method.annotations
+                *method.annotations,
             )
         } else {
             inner?.getChildDescription(method) ?: error("Descriptor not found")
@@ -144,7 +144,7 @@ class LegacyFlickerServiceDecorator(
             if (filterComponents.size != 2) {
                 Log.e(
                     LOG_TAG,
-                    "Invalid filter-tests instrumentation argument supplied, $testFilter."
+                    "Invalid filter-tests instrumentation argument supplied, $testFilter.",
                 )
                 continue
             }
@@ -162,20 +162,20 @@ class LegacyFlickerServiceDecorator(
      */
     private fun computeFlickerServiceTests(
         test: Any,
-        testScenario: Scenario
+        testScenario: Scenario,
     ): Collection<InjectedTestCase> {
         if (!android.tools.flicker.datastore.DataStore.containsResult(testScenario)) {
             val description =
                 Description.createTestDescription(
                     this::class.java.simpleName,
-                    "computeFlickerServiceTests"
+                    "computeFlickerServiceTests",
                 )
             transitionRunner.runTransition(testScenario, test, description)
         }
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 testScenario,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
 
         val expectedScenarios =
diff --git a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerTraceCollector.kt b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerTraceCollector.kt
index f36561081..6df311e9d 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerTraceCollector.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/LegacyFlickerTraceCollector.kt
@@ -31,7 +31,7 @@ class LegacyFlickerTraceCollector(private val scenario: Scenario) : TracesCollec
         Log.d("FAAS", "LegacyFlickerTraceCollector#stop")
         return android.tools.flicker.datastore.CachedResultReader(
             scenario,
-            TRACE_CONFIG_REQUIRE_CHANGES
+            TRACE_CONFIG_REQUIRE_CHANGES,
         )
     }
 
diff --git a/libraries/flicker/src/android/tools/flicker/junit/RuleContainer.kt b/libraries/flicker/src/android/tools/flicker/junit/RuleContainer.kt
index 65a5b14f5..29bc4b8f8 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/RuleContainer.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/RuleContainer.kt
@@ -67,7 +67,7 @@ internal class RuleContainer {
         method: FrameworkMethod?,
         description: Description?,
         target: Any?,
-        statement: Statement
+        statement: Statement,
     ): Statement {
         if (methodRules.isEmpty() && testRules.isEmpty()) {
             return statement
diff --git a/libraries/flicker/src/android/tools/flicker/junit/Utils.kt b/libraries/flicker/src/android/tools/flicker/junit/Utils.kt
index b8126d2eb..6944c4796 100644
--- a/libraries/flicker/src/android/tools/flicker/junit/Utils.kt
+++ b/libraries/flicker/src/android/tools/flicker/junit/Utils.kt
@@ -38,7 +38,7 @@ object Utils {
         ConditionList(
             listOf(
                 ConditionsFactory.isWMStateComplete(),
-                ConditionsFactory.hasLayersAnimating().negate()
+                ConditionsFactory.hasLayersAnimating().negate(),
             )
         )
 
@@ -51,7 +51,7 @@ object Utils {
     internal fun notifyRunnerProgress(
         scenario: Scenario,
         msg: String,
-        instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
+        instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
     ) {
         notifyRunnerProgress(scenario.key, msg, instrumentation)
     }
@@ -59,7 +59,7 @@ object Utils {
     internal fun notifyRunnerProgress(
         scenarioName: String,
         msg: String,
-        instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
+        instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
     ) {
         Log.d(FLICKER_RUNNER_TAG, "$scenarioName - $msg")
         val results = Bundle()
@@ -71,6 +71,6 @@ object Utils {
         Description.createTestDescription(
             description?.className,
             "${description?.displayName}-$suffix",
-            description?.annotations?.toTypedArray()
+            description?.annotations?.toTypedArray(),
         )
 }
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/FlickerBuilder.kt b/libraries/flicker/src/android/tools/flicker/legacy/FlickerBuilder.kt
index 96e032bff..5adf16e56 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/FlickerBuilder.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/FlickerBuilder.kt
@@ -25,8 +25,8 @@ import android.tools.traces.monitors.NoTraceMonitor
 import android.tools.traces.monitors.ScreenRecorder
 import android.tools.traces.parsers.WindowManagerStateHelper
 import androidx.test.uiautomator.UiDevice
-import org.junit.rules.TestRule
 import java.io.File
+import org.junit.rules.TestRule
 
 /** Build Flicker tests using Flicker DSL */
 @FlickerDslMarker
@@ -40,7 +40,7 @@ class FlickerBuilder(
     private val teardownCommands: MutableList<FlickerTestData.() -> Any> = mutableListOf(),
     val device: UiDevice = UiDevice.getInstance(instrumentation),
     private val rules: MutableList<TestRule> = mutableListOf(),
-    private val traceMonitors: MutableList<ITransitionMonitor> = ALL_MONITORS.toMutableList()
+    private val traceMonitors: MutableList<ITransitionMonitor> = ALL_MONITORS.toMutableList(),
 ) {
     private var usingExistingTraces = false
 
@@ -76,7 +76,7 @@ class FlickerBuilder(
         transitionCommands.add(command)
     }
 
-    /** Adds JUnit rules to be executed with the provided transitions.*/
+    /** Adds JUnit rules to be executed with the provided transitions. */
     fun withRules(vararg rules: TestRule) {
         this.rules.addAll(rules)
     }
@@ -86,7 +86,7 @@ class FlickerBuilder(
         val perfetto: File,
         val wmTransitions: File,
         val shellTransitions: File,
-        val eventLog: File
+        val eventLog: File,
     )
 
     /** Use pre-executed results instead of running transitions to get the traces */
@@ -125,23 +125,23 @@ class FlickerBuilder(
             transitionCommands,
             teardownCommands,
             rules,
-            wmHelper
+            wmHelper,
         )
     }
 
     /** Returns a copy of the current builder with the changes of [block] applied */
     fun copy(block: FlickerBuilder.() -> Unit) =
         FlickerBuilder(
-            instrumentation,
-            outputDir.absoluteFile,
-            wmHelper,
-            setupCommands.toMutableList(),
-            transitionCommands.toMutableList(),
-            teardownCommands.toMutableList(),
-            device,
-            rules.toMutableList(),
-            traceMonitors.toMutableList(),
-        )
+                instrumentation,
+                outputDir.absoluteFile,
+                wmHelper,
+                setupCommands.toMutableList(),
+                transitionCommands.toMutableList(),
+                teardownCommands.toMutableList(),
+                device,
+                rules.toMutableList(),
+                traceMonitors.toMutableList(),
+            )
             .apply(block)
 
     private fun addMonitor(newMonitor: ITransitionMonitor?) {
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestData.kt b/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestData.kt
index 1a9212d5a..205dac861 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestData.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestData.kt
@@ -20,8 +20,8 @@ import android.app.Instrumentation
 import android.tools.traces.monitors.ITransitionMonitor
 import android.tools.traces.parsers.WindowManagerStateHelper
 import androidx.test.uiautomator.UiDevice
-import org.junit.rules.TestRule
 import java.io.File
+import org.junit.rules.TestRule
 
 interface FlickerTestData {
     /** Instrumentation to run the tests */
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestDataImpl.kt b/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestDataImpl.kt
index 2f49a97f2..ede0f0258 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestDataImpl.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/FlickerTestDataImpl.kt
@@ -22,8 +22,8 @@ import android.tools.traces.parsers.WindowManagerStateHelper
 import android.tools.traces.surfaceflinger.LayersTrace
 import android.tools.traces.wm.WindowManagerTrace
 import androidx.test.uiautomator.UiDevice
-import org.junit.rules.TestRule
 import java.io.File
+import org.junit.rules.TestRule
 
 /**
  * Defines the runner for the flicker tests. This component is responsible for running the flicker
@@ -49,5 +49,5 @@ open class FlickerTestDataImpl(
     /** JUnit rules to be executed around transition */
     override val rules: List<TestRule>,
     /** Helper object for WM Synchronization */
-    override val wmHelper: WindowManagerStateHelper
+    override val wmHelper: WindowManagerStateHelper,
 ) : AbstractFlickerTestData()
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTest.kt b/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTest.kt
index 47c34b067..ff802ee48 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTest.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTest.kt
@@ -37,8 +37,8 @@ data class LegacyFlickerTest(
     private val subjectsParserProvider: (Reader) -> SubjectsParser = { SubjectsParser(it) },
     private val runnerProvider: (Scenario) -> AssertionRunner = {
         val reader = resultReaderProvider(it)
-        android.tools.flicker.datastore.CachedAssertionRunner(it, reader)
-    }
+        CachedAssertionRunner(it, reader)
+    },
 ) : BaseFlickerTest() {
     var scenario: ScenarioImpl = ScenarioBuilder().createEmptyScenario() as ScenarioImpl
         private set
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTestFactory.kt b/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTestFactory.kt
index 9fae94cd6..724ac005e 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTestFactory.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/LegacyFlickerTestFactory.kt
@@ -37,7 +37,7 @@ object LegacyFlickerTestFactory {
     fun nonRotationTests(
         supportedRotations: List<Rotation> = listOf(Rotation.ROTATION_0, Rotation.ROTATION_90),
         supportedNavigationModes: List<NavBar> = listOf(NavBar.MODE_3BUTTON, NavBar.MODE_GESTURAL),
-        extraArgs: Map<String, Any> = emptyMap()
+        extraArgs: Map<String, Any> = emptyMap(),
     ): List<FlickerTest> {
         return supportedNavigationModes.flatMap { navBarMode ->
             supportedRotations.map { rotation ->
@@ -56,7 +56,7 @@ object LegacyFlickerTestFactory {
     fun rotationTests(
         supportedRotations: List<Rotation> = listOf(Rotation.ROTATION_0, Rotation.ROTATION_90),
         supportedNavigationModes: List<NavBar> = listOf(NavBar.MODE_3BUTTON, NavBar.MODE_GESTURAL),
-        extraArgs: Map<String, Any> = emptyMap()
+        extraArgs: Map<String, Any> = emptyMap(),
     ): List<FlickerTest> {
         return supportedNavigationModes.flatMap { navBarMode ->
             supportedRotations
@@ -70,7 +70,7 @@ object LegacyFlickerTestFactory {
         navBarMode: NavBar,
         startRotation: Rotation,
         endRotation: Rotation,
-        extraArgs: Map<String, Any>
+        extraArgs: Map<String, Any>,
     ) =
         LegacyFlickerTest(
             ScenarioBuilder()
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/runner/SetupTeardownRule.kt b/libraries/flicker/src/android/tools/flicker/legacy/runner/SetupTeardownRule.kt
index 91cbc5e3c..32c047367 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/runner/SetupTeardownRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/runner/SetupTeardownRule.kt
@@ -45,7 +45,7 @@ class SetupTeardownRule(
     private val instrumentation: Instrumentation,
     private val setupCommands: List<FlickerTestData.() -> Any> = flicker.transitionSetup,
     private val teardownCommands: List<FlickerTestData.() -> Any> = flicker.transitionTeardown,
-    private val wmHelper: WindowManagerStateHelper = flicker.wmHelper
+    private val wmHelper: WindowManagerStateHelper = flicker.wmHelper,
 ) : TestRule {
     override fun apply(base: Statement?, description: Description?): Statement {
         return object : Statement() {
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/runner/TraceMonitorRule.kt b/libraries/flicker/src/android/tools/flicker/legacy/runner/TraceMonitorRule.kt
index 23a6475e2..25da135c4 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/runner/TraceMonitorRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/runner/TraceMonitorRule.kt
@@ -43,7 +43,7 @@ class TraceMonitorRule(
     private val scenario: Scenario,
     private val wmHelper: WindowManagerStateHelper,
     private val resultWriter: ResultWriter,
-    private val instrumentation: Instrumentation
+    private val instrumentation: Instrumentation,
 ) : TestRule {
     override fun apply(base: Statement?, description: Description?): Statement {
         return object : Statement() {
@@ -54,7 +54,7 @@ class TraceMonitorRule(
                     Log.e(
                         FLICKER_TAG,
                         "Failed to start trace monitors" +
-                            " - stopping all trace monitors to recover a clean state"
+                            " - stopping all trace monitors to recover a clean state",
                     )
                     runCatching { doStopMonitors(description) }
                     throw e
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionExecutionRule.kt b/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionExecutionRule.kt
index 289b81ab5..439627b7e 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionExecutionRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionExecutionRule.kt
@@ -51,7 +51,7 @@ class TransitionExecutionRule(
     private val scenario: Scenario,
     private val instrumentation: Instrumentation = flicker.instrumentation,
     private val commands: List<FlickerTestData.() -> Any> = flicker.transitions,
-    private val wmHelper: WindowManagerStateHelper = flicker.wmHelper
+    private val wmHelper: WindowManagerStateHelper = flicker.wmHelper,
 ) : TestRule {
     private var tags = mutableSetOf<String>()
 
@@ -83,7 +83,7 @@ class TransitionExecutionRule(
                 FlickerTag.TRANSITION_START,
                 now.unixNanos,
                 now.elapsedNanos,
-                now.systemUptimeNanos
+                now.systemUptimeNanos,
             )
             flicker.setCreateTagListener { doCreateTag(it) }
             doValidate()
@@ -101,7 +101,7 @@ class TransitionExecutionRule(
                 FlickerTag.TRANSITION_END,
                 now.unixNanos,
                 now.elapsedNanos,
-                now.systemUptimeNanos
+                now.systemUptimeNanos,
             )
             flicker.clearTagListener()
         }
diff --git a/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionRunner.kt b/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionRunner.kt
index 7371af17c..257ba3bda 100644
--- a/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionRunner.kt
+++ b/libraries/flicker/src/android/tools/flicker/legacy/runner/TransitionRunner.kt
@@ -41,7 +41,7 @@ import org.junit.runner.Description
 class TransitionRunner(
     private val scenario: Scenario,
     private val instrumentation: Instrumentation,
-    private val resultWriter: ResultWriter = android.tools.flicker.datastore.CachedResultWriter()
+    private val resultWriter: ResultWriter = android.tools.flicker.datastore.CachedResultWriter(),
 ) {
     /** Executes [flicker] transition and returns the result */
     fun execute(flicker: FlickerTestData, description: Description?): IResultData {
@@ -75,29 +75,30 @@ class TransitionRunner(
     private fun buildTestRuleChain(flicker: FlickerTestData): RuleChain {
         val errorRule = ArtifactSaverRule()
 
-        val rules = listOf(
-            StopAllTracesRule(),
-            UnlockScreenRule(),
-            NavigationModeRule(scenario.navBarMode.value, false),
-            LaunchAppRule(MessagingAppHelper(instrumentation), clearCacheAfterParsing = false),
-            RemoveAllTasksButHomeRule(),
-            ChangeDisplayOrientationRule(
-                scenario.startRotation,
-                resetOrientationAfterTest = false,
-                clearCacheAfterParsing = false
-            ),
-            PressHomeRule(),
-            TraceMonitorRule(
-                flicker.traceMonitors,
-                scenario,
-                flicker.wmHelper,
-                resultWriter,
-                instrumentation
-            ),
-            *flicker.rules.toTypedArray(),
-            SetupTeardownRule(flicker, resultWriter, scenario, instrumentation),
-            TransitionExecutionRule(flicker, resultWriter, scenario, instrumentation)
-        )
+        val rules =
+            listOf(
+                StopAllTracesRule(),
+                UnlockScreenRule(),
+                NavigationModeRule(scenario.navBarMode.value, false),
+                LaunchAppRule(MessagingAppHelper(instrumentation), clearCacheAfterParsing = false),
+                RemoveAllTasksButHomeRule(),
+                ChangeDisplayOrientationRule(
+                    scenario.startRotation,
+                    resetOrientationAfterTest = false,
+                    clearCacheAfterParsing = false,
+                ),
+                PressHomeRule(),
+                TraceMonitorRule(
+                    flicker.traceMonitors,
+                    scenario,
+                    flicker.wmHelper,
+                    resultWriter,
+                    instrumentation,
+                ),
+                *flicker.rules.toTypedArray(),
+                SetupTeardownRule(flicker, resultWriter, scenario, instrumentation),
+                TransitionExecutionRule(flicker, resultWriter, scenario, instrumentation),
+            )
 
         return rules.foldIndexed(RuleChain.outerRule(errorRule)) { index, chain, rule ->
             chain.around(rule).let {
diff --git a/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt b/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
index 1dc70d706..cdb33ed5f 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/ArtifactSaverRule.kt
@@ -25,6 +25,7 @@ import org.junit.runner.Description
 
 class ArtifactSaverRule : TestWatcher() {
     private var handled = false
+
     override fun failed(e: Throwable, description: Description?) {
         if (handled) {
             return
diff --git a/libraries/flicker/src/android/tools/flicker/rules/ChangeDisplayOrientationRule.kt b/libraries/flicker/src/android/tools/flicker/rules/ChangeDisplayOrientationRule.kt
index c85d3774f..e07ccffd9 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/ChangeDisplayOrientationRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/ChangeDisplayOrientationRule.kt
@@ -47,7 +47,7 @@ constructor(
     private val targetOrientation: Rotation,
     private val resetOrientationAfterTest: Boolean = true,
     private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
-    private val clearCacheAfterParsing: Boolean = true
+    private val clearCacheAfterParsing: Boolean = true,
 ) : TestWatcher() {
     private var initialOrientation = Rotation.ROTATION_0
 
@@ -56,7 +56,7 @@ constructor(
             Log.v(
                 FLICKER_TAG,
                 "Changing display orientation to " +
-                    "$targetOrientation ${targetOrientation.description}"
+                    "$targetOrientation ${targetOrientation.description}",
             )
             val wm =
                 instrumentation.context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
@@ -82,8 +82,8 @@ constructor(
             wmHelper: WindowManagerStateHelper =
                 WindowManagerStateHelper(
                     instrumentation,
-                    clearCacheAfterParsing = clearCacheAfterParsing
-                )
+                    clearCacheAfterParsing = clearCacheAfterParsing,
+                ),
         ) {
             val device: UiDevice = UiDevice.getInstance(instrumentation)
 
diff --git a/libraries/flicker/src/android/tools/flicker/rules/FlickerServiceRule.kt b/libraries/flicker/src/android/tools/flicker/rules/FlickerServiceRule.kt
index 7576eb879..ce951b728 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/FlickerServiceRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/FlickerServiceRule.kt
@@ -56,7 +56,7 @@ constructor(
         FlickerServiceResultsCollector(
             flickerService = FlickerService(config),
             tracesCollector = FlickerServiceTracesCollector(getDefaultFlickerOutputDir()),
-            instrumentation = InstrumentationRegistry.getInstrumentation()
+            instrumentation = InstrumentationRegistry.getInstrumentation(),
         ),
 ) : TestWatcher() {
     private val enabled: Boolean =
@@ -66,14 +66,12 @@ constructor(
     private val failTestOnFlicker: Boolean =
         InstrumentationRegistry.getArguments().getString("faas:failTestOnFlicker")?.let {
             it.toBoolean()
-        }
-            ?: failTestOnFlicker
+        } ?: failTestOnFlicker
 
     private val failTestOnServiceError: Boolean =
         InstrumentationRegistry.getArguments().getString("faas:failTestOnServiceError")?.let {
             it.toBoolean()
-        }
-            ?: failTestOnServiceError
+        } ?: failTestOnServiceError
 
     private var testFailed = false
     private var testSkipped = false
diff --git a/libraries/flicker/src/android/tools/flicker/rules/LaunchAppRule.kt b/libraries/flicker/src/android/tools/flicker/rules/LaunchAppRule.kt
index c71d83731..5d96b0cb8 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/LaunchAppRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/LaunchAppRule.kt
@@ -46,7 +46,7 @@ constructor(
     private val instrumentation: Instrumentation = appHelper.instrumentation,
     private val clearCacheAfterParsing: Boolean = true,
     private val wmHelper: WindowManagerStateHelper =
-        WindowManagerStateHelper(clearCacheAfterParsing = clearCacheAfterParsing)
+        WindowManagerStateHelper(clearCacheAfterParsing = clearCacheAfterParsing),
 ) : TestWatcher() {
     @JvmOverloads
     constructor(
@@ -55,12 +55,12 @@ constructor(
         instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
         clearCache: Boolean = true,
         wmHelper: WindowManagerStateHelper =
-            WindowManagerStateHelper(clearCacheAfterParsing = clearCache)
+            WindowManagerStateHelper(clearCacheAfterParsing = clearCache),
     ) : this(
         StandardAppHelper(instrumentation, appName, componentMatcher),
         instrumentation,
         clearCache,
-        wmHelper
+        wmHelper,
     )
 
     override fun starting(description: Description?) {
diff --git a/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt b/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
index a2a08e47a..4809a57a5 100644
--- a/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
+++ b/libraries/flicker/src/android/tools/flicker/rules/RemoveAllTasksButHomeRule.kt
@@ -51,7 +51,7 @@ class RemoveAllTasksButHomeRule() : TestWatcher() {
                 WindowConfiguration.ACTIVITY_TYPE_STANDARD,
                 WindowConfiguration.ACTIVITY_TYPE_ASSISTANT,
                 WindowConfiguration.ACTIVITY_TYPE_RECENTS,
-                WindowConfiguration.ACTIVITY_TYPE_UNDEFINED
+                WindowConfiguration.ACTIVITY_TYPE_UNDEFINED,
             )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/CheckSubjectBuilder.kt b/libraries/flicker/src/android/tools/flicker/subject/CheckSubjectBuilder.kt
index 04b72ef19..01e259cbe 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/CheckSubjectBuilder.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/CheckSubjectBuilder.kt
@@ -25,7 +25,7 @@ data class CheckSubjectBuilder(
     private val timestamp: Timestamp,
     private val extraFacts: List<Fact>,
     private val reader: Reader?,
-    private val lazyMessage: () -> String
+    private val lazyMessage: () -> String,
 ) {
     fun <T> that(actual: T?): CheckSubject<T> {
         return CheckSubject(actual, timestamp, extraFacts, reader, lazyMessage)
diff --git a/libraries/flicker/src/android/tools/flicker/subject/FlickerSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/FlickerSubject.kt
index 04abb83b3..bd979c236 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/FlickerSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/FlickerSubject.kt
@@ -29,8 +29,4 @@ abstract class FlickerSubject {
     fun check(lazyMessage: () -> String): CheckSubjectBuilder {
         return CheckSubjectBuilder(this.timestamp, this.selfFacts, this.reader, lazyMessage)
     }
-
-    companion object {
-        const val ASSERTION_TAG = "Assertion"
-    }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/FlickerSubjectException.kt b/libraries/flicker/src/android/tools/flicker/subject/FlickerSubjectException.kt
index 76be10aed..1cdf369b0 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/FlickerSubjectException.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/FlickerSubjectException.kt
@@ -20,11 +20,10 @@ import android.tools.Timestamp
 import android.tools.flicker.assertions.Fact
 
 /** Exception thrown by flicker subjects */
-class FlickerSubjectException(
-    timestamp: Timestamp,
-    val facts: List<Fact>,
-    override val cause: Throwable? = null
-) : AssertionError() {
+class FlickerSubjectException
+@JvmOverloads
+constructor(timestamp: Timestamp, val facts: List<Fact>, override val cause: Throwable? = null) :
+    AssertionError() {
     private val errorType: String =
         if (cause == null) "Flicker assertion error" else "Unknown error"
     override val message = buildString {
diff --git a/libraries/flicker/src/android/tools/flicker/subject/FlickerTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/FlickerTraceSubject.kt
index be04ee94a..9fd0da072 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/FlickerTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/FlickerTraceSubject.kt
@@ -20,6 +20,7 @@ import android.tools.Timestamps
 import android.tools.flicker.assertions.AssertionsChecker
 import android.tools.flicker.subject.exceptions.ExceptionMessageBuilder
 import android.tools.flicker.subject.exceptions.SubjectAssertionError
+import android.tools.function.AssertionPredicate
 
 /** Base subject for flicker trace assertions */
 abstract class FlickerTraceSubject<EntrySubject : FlickerSubject> : FlickerSubject() {
@@ -43,7 +44,7 @@ abstract class FlickerTraceSubject<EntrySubject : FlickerSubject> : FlickerSubje
     protected fun addAssertion(
         name: String,
         isOptional: Boolean = false,
-        assertion: (EntrySubject) -> Unit
+        assertion: AssertionPredicate<EntrySubject>,
     ) {
         if (newAssertionBlock) {
             assertionsChecker.add(name, isOptional, assertion)
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientEntrySubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientEntrySubject.kt
index c6549d128..d48d61d85 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientEntrySubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientEntrySubject.kt
@@ -17,6 +17,7 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.ImeClientEntry
 import android.tools.traces.inputmethod.ImeClientTrace
@@ -33,17 +34,20 @@ import android.tools.traces.inputmethod.ImeClientTrace
  *      .invoke { myCustomAssertion(this) }
  *  ```
  */
-class ImeClientEntrySubject(
+class ImeClientEntrySubject
+@JvmOverloads
+constructor(
     val entry: ImeClientEntry,
     val trace: ImeClientTrace?,
-    override val reader: Reader? = null
+    override val reader: Reader? = null,
 ) : FlickerSubject(), IImeClientSubject<ImeClientEntrySubject> {
     override val timestamp = entry.timestamp
 
     /** Executes a custom [assertion] on the current subject */
-    operator fun invoke(assertion: (ImeClientEntry) -> Unit): ImeClientEntrySubject = apply {
-        assertion(this.entry)
-    }
+    operator fun invoke(assertion: AssertionPredicate<ImeClientEntry>): ImeClientEntrySubject =
+        apply {
+            assertion.verify(this.entry)
+        }
 
     /** {@inheritDoc} */
     override fun isEmpty(): ImeClientEntrySubject = apply {
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientTraceSubject.kt
index f6684533f..f75d2537e 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/ImeClientTraceSubject.kt
@@ -17,9 +17,11 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.ImeClientEntry
 import android.tools.traces.inputmethod.ImeClientTrace
+import java.util.function.Predicate
 
 /**
  * Truth subject for [ImeClientTrace] objects, used to make assertions over behaviors that occur
@@ -35,7 +37,8 @@ import android.tools.traces.inputmethod.ImeClientTrace
  *  ```
  */
 class ImeClientTraceSubject
-private constructor(val trace: ImeClientTrace, override val reader: Reader? = null) :
+@JvmOverloads
+constructor(val trace: ImeClientTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<ImeClientEntrySubject>(), IImeClientSubject<ImeClientTraceSubject> {
 
     override val subjects by lazy { trace.entries.map { ImeClientEntrySubject(it, trace, reader) } }
@@ -54,16 +57,17 @@ private constructor(val trace: ImeClientTrace, override val reader: Reader? = nu
     }
 
     /** Executes a custom [assertion] on the current subject */
+    @JvmOverloads
     operator fun invoke(
         name: String,
         isOptional: Boolean = false,
-        assertion: (ImeClientEntrySubject) -> Unit
+        assertion: AssertionPredicate<ImeClientEntrySubject>,
     ): ImeClientTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 
     /**
      * @return List of [ImeClientEntrySubject]s matching [predicate] in the order they appear in the
      *   trace
      */
-    fun imeClientEntriesThat(predicate: (ImeClientEntry) -> Boolean): List<ImeClientEntrySubject> =
-        subjects.filter { predicate(it.entry) }
+    fun imeClientEntriesThat(predicate: Predicate<ImeClientEntry>): List<ImeClientEntrySubject> =
+        subjects.filter { predicate.test(it.entry) }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceEntrySubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceEntrySubject.kt
index c4974eb1c..6685023c3 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceEntrySubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceEntrySubject.kt
@@ -17,6 +17,7 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.InputMethodManagerServiceEntry
 import android.tools.traces.inputmethod.InputMethodManagerServiceTrace
@@ -33,17 +34,19 @@ import android.tools.traces.inputmethod.InputMethodManagerServiceTrace
  *      .invoke { myCustomAssertion(this) }
  *  ```
  */
-class InputMethodManagerServiceEntrySubject(
+class InputMethodManagerServiceEntrySubject
+@JvmOverloads
+constructor(
     val entry: InputMethodManagerServiceEntry,
     val trace: InputMethodManagerServiceTrace?,
-    override val reader: Reader? = null
+    override val reader: Reader? = null,
 ) : FlickerSubject(), IInputMethodManagerServiceSubject<InputMethodManagerServiceEntrySubject> {
     override val timestamp = entry.timestamp
 
     /** Executes a custom [assertion] on the current subject */
     operator fun invoke(
-        assertion: (InputMethodManagerServiceEntry) -> Unit
-    ): InputMethodManagerServiceEntrySubject = apply { assertion(this.entry) }
+        assertion: AssertionPredicate<InputMethodManagerServiceEntry>
+    ): InputMethodManagerServiceEntrySubject = apply { assertion.verify(this.entry) }
 
     /** {@inheritDoc} */
     override fun isEmpty(): InputMethodManagerServiceEntrySubject = apply {
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceTraceSubject.kt
index cfc45693b..0b7d90267 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodManagerServiceTraceSubject.kt
@@ -17,9 +17,11 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.InputMethodManagerServiceEntry
 import android.tools.traces.inputmethod.InputMethodManagerServiceTrace
+import java.util.function.Predicate
 
 /**
  * Truth subject for [InputMethodManagerServiceTrace] objects, used to make assertions over
@@ -34,10 +36,8 @@ import android.tools.traces.inputmethod.InputMethodManagerServiceTrace
  * ```
  */
 class InputMethodManagerServiceTraceSubject
-private constructor(
-    val trace: InputMethodManagerServiceTrace,
-    override val reader: Reader? = null
-) :
+@JvmOverloads
+constructor(val trace: InputMethodManagerServiceTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<InputMethodManagerServiceEntrySubject>(),
     IInputMethodManagerServiceSubject<InputMethodManagerServiceTraceSubject> {
 
@@ -59,10 +59,11 @@ private constructor(
     }
 
     /** Executes a custom [assertion] on the current subject */
+    @JvmOverloads
     operator fun invoke(
         name: String,
         isOptional: Boolean = false,
-        assertion: (InputMethodManagerServiceEntrySubject) -> Unit
+        assertion: AssertionPredicate<InputMethodManagerServiceEntrySubject>,
     ): InputMethodManagerServiceTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 
     /**
@@ -70,6 +71,6 @@ private constructor(
      *   they appear in the trace
      */
     fun imeClientEntriesThat(
-        predicate: (InputMethodManagerServiceEntry) -> Boolean
-    ): List<InputMethodManagerServiceEntrySubject> = subjects.filter { predicate(it.entry) }
+        predicate: Predicate<InputMethodManagerServiceEntry>
+    ): List<InputMethodManagerServiceEntrySubject> = subjects.filter { predicate.test(it.entry) }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceEntrySubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceEntrySubject.kt
index 7fe878162..1eb22ff1c 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceEntrySubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceEntrySubject.kt
@@ -17,6 +17,7 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.InputMethodServiceEntry
 import android.tools.traces.inputmethod.InputMethodServiceTrace
@@ -33,17 +34,19 @@ import android.tools.traces.inputmethod.InputMethodServiceTrace
  *      .invoke { myCustomAssertion(this) }
  * ```
  */
-class InputMethodServiceEntrySubject(
+class InputMethodServiceEntrySubject
+@JvmOverloads
+constructor(
     val entry: InputMethodServiceEntry,
     val trace: InputMethodServiceTrace?,
-    override val reader: Reader? = null
+    override val reader: Reader? = null,
 ) : FlickerSubject(), IInputMethodServiceSubject<InputMethodServiceEntrySubject> {
     override val timestamp = entry.timestamp
 
     /** Executes a custom [assertion] on the current subject */
     operator fun invoke(
-        assertion: (InputMethodServiceEntry) -> Unit
-    ): InputMethodServiceEntrySubject = apply { assertion(this.entry) }
+        assertion: AssertionPredicate<InputMethodServiceEntry>
+    ): InputMethodServiceEntrySubject = apply { assertion.verify(this.entry) }
 
     /** {@inheritDoc} */
     override fun isEmpty(): InputMethodServiceEntrySubject = apply {
diff --git a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceTraceSubject.kt
index b89001110..cfbb83e6f 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/inputmethod/InputMethodServiceTraceSubject.kt
@@ -17,9 +17,11 @@
 package android.tools.flicker.subject.inputmethod
 
 import android.tools.flicker.subject.FlickerTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.inputmethod.InputMethodServiceEntry
 import android.tools.traces.inputmethod.InputMethodServiceTrace
+import java.util.function.Predicate
 
 /**
  * Truth subject for [InputMethodServiceTrace] objects, used to make assertions over behaviors that
@@ -32,7 +34,8 @@ import android.tools.traces.inputmethod.InputMethodServiceTrace
  * myCustomAssertion(this) } }
  */
 class InputMethodServiceTraceSubject
-private constructor(val trace: InputMethodServiceTrace, override val reader: Reader? = null) :
+@JvmOverloads
+constructor(val trace: InputMethodServiceTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<InputMethodServiceEntrySubject>(),
     IInputMethodServiceSubject<InputMethodServiceTraceSubject> {
 
@@ -54,10 +57,11 @@ private constructor(val trace: InputMethodServiceTrace, override val reader: Rea
     }
 
     /** Executes a custom [assertion] on the current subject */
+    @JvmOverloads
     operator fun invoke(
         name: String,
         isOptional: Boolean = false,
-        assertion: (InputMethodServiceEntrySubject) -> Unit
+        assertion: AssertionPredicate<InputMethodServiceEntrySubject>,
     ): InputMethodServiceTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 
     /**
@@ -65,6 +69,6 @@ private constructor(val trace: InputMethodServiceTrace, override val reader: Rea
      *   appear in the trace
      */
     fun imeClientEntriesThat(
-        predicate: (InputMethodServiceEntry) -> Boolean
-    ): List<InputMethodServiceEntrySubject> = subjects.filter { predicate(it.entry) }
+        predicate: Predicate<InputMethodServiceEntry>
+    ): List<InputMethodServiceEntrySubject> = subjects.filter { predicate.test(it.entry) }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/layers/ILayerSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/layers/ILayerSubject.kt
index a445fd52f..03c6ed8ea 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/layers/ILayerSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/layers/ILayerSubject.kt
@@ -39,7 +39,7 @@ interface ILayerSubject<LayerSubjectType, RegionSubjectType> {
      */
     fun visibleRegion(
         componentMatcher: IComponentMatcher? = null,
-        useCompositionEngineRegionOnly: Boolean = true
+        useCompositionEngineRegionOnly: Boolean = true,
     ): RegionSubjectType
 
     /**
diff --git a/libraries/flicker/src/android/tools/flicker/subject/layers/LayerSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/layers/LayerSubject.kt
index b40fce5a7..ce3950f93 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/layers/LayerSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/layers/LayerSubject.kt
@@ -20,6 +20,7 @@ import android.tools.datatypes.Size
 import android.tools.flicker.assertions.Fact
 import android.tools.flicker.subject.FlickerSubject
 import android.tools.flicker.subject.region.RegionSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.surfaceflinger.Layer
 
@@ -42,15 +43,19 @@ import android.tools.traces.surfaceflinger.Layer
  *        .invoke { myCustomAssertion(this) }
  * ```
  */
-class LayerSubject(
-    public override val reader: Reader? = null,
+class LayerSubject
+@JvmOverloads
+constructor(
     override val timestamp: Timestamp,
-    val layer: Layer
+    val layer: Layer,
+    public override val reader: Reader? = null,
 ) : FlickerSubject() {
     val isVisible: Boolean
         get() = layer.isVisible
+
     val isInvisible: Boolean
         get() = !layer.isVisible
+
     val name: String
         get() = layer.name
 
@@ -71,7 +76,9 @@ class LayerSubject(
     override val selfFacts = listOf(Fact("Frame", layer.currFrame), Fact("Layer", layer.name))
 
     /** If the [layer] exists, executes a custom [assertion] on the current subject */
-    operator fun invoke(assertion: (Layer) -> Unit): LayerSubject = apply { assertion(this.layer) }
+    operator fun invoke(assertion: AssertionPredicate<Layer>): LayerSubject = apply {
+        assertion.verify(this.layer)
+    }
 
     /**
      * Asserts that current subject has an [Layer.activeBuffer]
diff --git a/libraries/flicker/src/android/tools/flicker/subject/layers/LayerTraceEntrySubject.kt b/libraries/flicker/src/android/tools/flicker/subject/layers/LayerTraceEntrySubject.kt
index 63bde12a4..aa83a9a94 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/layers/LayerTraceEntrySubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/layers/LayerTraceEntrySubject.kt
@@ -27,6 +27,7 @@ import android.tools.flicker.subject.exceptions.IncorrectVisibilityException
 import android.tools.flicker.subject.exceptions.InvalidElementException
 import android.tools.flicker.subject.exceptions.InvalidPropertyException
 import android.tools.flicker.subject.region.RegionSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.component.ComponentNameMatcher
 import android.tools.traces.component.ComponentSplashScreenMatcher
@@ -36,6 +37,7 @@ import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.surfaceflinger.LayerTraceEntry
 import android.tools.traces.surfaceflinger.LayersTrace
 import androidx.core.graphics.toRect
+import java.util.function.Predicate
 
 /**
  * Subject for [LayerTraceEntry] objects, used to make assertions over behaviors that occur on a
@@ -61,19 +63,22 @@ import androidx.core.graphics.toRect
  *        .invoke { myCustomAssertion(this) }
  * ```
  */
-class LayerTraceEntrySubject(
+class LayerTraceEntrySubject
+@JvmOverloads
+constructor(
     val entry: LayerTraceEntry,
     override val reader: Reader? = null,
     val trace: LayersTrace? = null,
 ) : FlickerSubject(), ILayerSubject<LayerTraceEntrySubject, RegionSubject> {
     override val timestamp = entry.timestamp
 
-    val subjects by lazy { entry.flattenedLayers.map { LayerSubject(reader, timestamp, it) } }
+    val subjects by lazy { entry.flattenedLayers.map { LayerSubject(timestamp, it, reader) } }
 
     /** Executes a custom [assertion] on the current subject */
-    operator fun invoke(assertion: (LayerTraceEntry) -> Unit): LayerTraceEntrySubject = apply {
-        assertion(this.entry)
-    }
+    operator fun invoke(assertion: AssertionPredicate<LayerTraceEntry>): LayerTraceEntrySubject =
+        apply {
+            assertion.verify(this.entry)
+        }
 
     /** {@inheritDoc} */
     override fun isEmpty(): LayerTraceEntrySubject = apply {
@@ -96,7 +101,7 @@ class LayerTraceEntrySubject(
     /** {@inheritDoc} */
     override fun visibleRegion(
         componentMatcher: IComponentMatcher?,
-        useCompositionEngineRegionOnly: Boolean
+        useCompositionEngineRegionOnly: Boolean,
     ): RegionSubject {
         val selectedLayers =
             if (componentMatcher == null) {
@@ -114,7 +119,7 @@ class LayerTraceEntrySubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher?.toLayerIdentifier() ?: "<any>",
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
                     .addExtraDescription(
                         Fact("Use composition engine region", useCompositionEngineRegionOnly)
@@ -140,7 +145,7 @@ class LayerTraceEntrySubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toLayerIdentifier(),
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -157,7 +162,7 @@ class LayerTraceEntrySubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toLayerIdentifier(),
-                        expectElementExists = false
+                        expectElementExists = false,
                     )
                     .setActual(foundElements.map { Fact("Found", it) })
             throw InvalidElementException(errorMsgBuilder)
@@ -181,7 +186,7 @@ class LayerTraceEntrySubject(
                     .forSubject(this)
                     .forIncorrectVisibility(
                         componentMatcher.toLayerIdentifier(),
-                        expectElementVisible = true
+                        expectElementVisible = true,
                     )
                     .setActual(failedEntries)
             throw IncorrectVisibilityException(errorMsgBuilder)
@@ -212,7 +217,7 @@ class LayerTraceEntrySubject(
                 .forSubject(this)
                 .forIncorrectVisibility(
                     componentMatcher.toLayerIdentifier(),
-                    expectElementVisible = false
+                    expectElementVisible = false,
                 )
                 .setActual(failedEntries)
         throw IncorrectVisibilityException(errorMsgBuilder)
@@ -231,13 +236,13 @@ class LayerTraceEntrySubject(
             if (matchingSubjects.isEmpty()) {
                 errorMsgBuilder.forInvalidElement(
                     componentMatcher.toLayerIdentifier(),
-                    expectElementExists = true
+                    expectElementExists = true,
                 )
             } else {
                 errorMsgBuilder
                     .forIncorrectVisibility(
                         "Splash screen for ${componentMatcher.toLayerIdentifier()}",
-                        expectElementVisible = true
+                        expectElementVisible = true,
                     )
                     .setActual(
                         matchingSubjects
@@ -350,16 +355,8 @@ class LayerTraceEntrySubject(
      * @param predicate to search for a layer
      * @return [LayerSubject] that can be used to make assertions
      */
-    fun layer(predicate: (Layer) -> Boolean): LayerSubject? =
-        subjects.firstOrNull { predicate(it.layer) }
-
-    private fun getActivityRecordFor(layer: Layer): Layer? {
-        if (layer.name.startsWith("ActivityRecord{")) {
-            return layer
-        }
-        val parent = layer.parent ?: return null
-        return getActivityRecordFor(parent)
-    }
+    fun layer(predicate: Predicate<Layer>): LayerSubject? =
+        subjects.firstOrNull { predicate.test(it.layer) }
 
     override fun toString(): String {
         return "LayerTraceEntrySubject($entry)"
diff --git a/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
index 6f495678f..7f37abc64 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/layers/LayersTraceSubject.kt
@@ -21,14 +21,17 @@ import android.tools.flicker.subject.exceptions.ExceptionMessageBuilder
 import android.tools.flicker.subject.exceptions.InvalidElementException
 import android.tools.flicker.subject.exceptions.InvalidPropertyException
 import android.tools.flicker.subject.region.RegionTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.component.ComponentNameMatcher
 import android.tools.traces.component.EdgeExtensionComponentMatcher
 import android.tools.traces.component.IComponentMatcher
 import android.tools.traces.component.IComponentNameMatcher
+import android.tools.traces.component.SurfaceViewBackgroundMatcher
 import android.tools.traces.region.RegionTrace
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.surfaceflinger.LayersTrace
+import java.util.function.Predicate
 
 /**
  * Subject for [LayersTrace] objects, used to make assertions over behaviors that occur throughout a
@@ -55,7 +58,9 @@ import android.tools.traces.surfaceflinger.LayersTrace
  *    }
  * ```
  */
-class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? = null) :
+class LayersTraceSubject
+@JvmOverloads
+constructor(val trace: LayersTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<LayerTraceEntrySubject>(),
     ILayerSubject<LayersTraceSubject, RegionTraceSubject> {
 
@@ -99,8 +104,8 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
     /**
      * @return List of [LayerSubject]s matching [predicate] in the order they appear on the trace
      */
-    fun layers(predicate: (Layer) -> Boolean): List<LayerSubject> =
-        subjects.mapNotNull { it.layer { layer -> predicate(layer) } }
+    fun layers(predicate: Predicate<Layer>): List<LayerSubject> =
+        subjects.mapNotNull { it.layer { layer -> predicate.test(layer) } }
 
     /** Checks that all visible layers are shown for more than one consecutive entry */
     fun visibleLayersShownMoreThanOneConsecutiveEntry(
@@ -202,11 +207,11 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
     /** See [isSplashScreenVisibleFor] */
     fun isSplashScreenVisibleFor(
         componentMatcher: IComponentNameMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): LayersTraceSubject = apply {
         addAssertion(
             "isSplashScreenVisibleFor(${componentMatcher.toLayerIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isSplashScreenVisibleFor(componentMatcher)
         }
@@ -223,14 +228,14 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
     /** {@inheritDoc} */
     override fun visibleRegion(
         componentMatcher: IComponentMatcher?,
-        useCompositionEngineRegionOnly: Boolean
+        useCompositionEngineRegionOnly: Boolean,
     ): RegionTraceSubject {
         val regionTrace =
             RegionTrace(
                 componentMatcher,
                 subjects.map {
                     it.visibleRegion(componentMatcher, useCompositionEngineRegionOnly).regionEntry
-                }
+                },
             )
         return RegionTraceSubject(regionTrace, reader)
     }
@@ -256,10 +261,11 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
     }
 
     /** Executes a custom [assertion] on the current subject */
+    @JvmOverloads
     operator fun invoke(
         name: String,
         isOptional: Boolean = false,
-        assertion: (LayerTraceEntrySubject) -> Unit
+        assertion: AssertionPredicate<LayerTraceEntrySubject>,
     ): LayersTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 
     fun hasFrameSequence(name: String, frameNumbers: Iterable<Long>): LayersTraceSubject =
@@ -267,7 +273,7 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
 
     fun hasFrameSequence(
         componentMatcher: IComponentMatcher,
-        frameNumbers: Iterable<Long>
+        frameNumbers: Iterable<Long>,
     ): LayersTraceSubject = apply {
         val firstFrame = frameNumbers.first()
         val entries =
@@ -297,7 +303,7 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toLayerIdentifier(),
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
                     .addExtraDescription("With frame sequence", frameNumbers.joinToString(","))
             throw InvalidElementException(errorMsgBuilder)
@@ -316,9 +322,10 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
      *
      * @param timestamp of the entry
      */
+    @JvmOverloads
     fun getEntryBySystemUpTime(
         timestamp: Long,
-        byElapsedTimestamp: Boolean = false
+        byElapsedTimestamp: Boolean = false,
     ): LayerTraceEntrySubject {
         return if (byElapsedTimestamp) {
             subjects.first { it.entry.elapsedTimestamp == timestamp }
@@ -328,6 +335,7 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
     }
 
     companion object {
+        @JvmField
         val VISIBLE_FOR_MORE_THAN_ONE_ENTRY_IGNORE_LAYERS =
             listOf(
                 ComponentNameMatcher.SPLASH_SCREEN,
@@ -339,7 +347,8 @@ class LayersTraceSubject(val trace: LayersTrace, override val reader: Reader? =
                 ComponentNameMatcher.TRANSITION_SNAPSHOT,
                 ComponentNameMatcher.FLOATING_ROTATION_BUTTON,
                 ComponentNameMatcher.WIRED_CHARGING_ANIMATION,
-                EdgeExtensionComponentMatcher()
+                EdgeExtensionComponentMatcher(),
+                SurfaceViewBackgroundMatcher(),
             )
     }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
index 28a5caf0b..80bbe1d16 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/region/RegionSubject.kt
@@ -28,6 +28,7 @@ import android.tools.datatypes.uncoveredRegion
 import android.tools.flicker.subject.FlickerSubject
 import android.tools.flicker.subject.exceptions.ExceptionMessageBuilder
 import android.tools.flicker.subject.exceptions.IncorrectRegionException
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.region.RegionEntry
 import androidx.core.graphics.toRect
@@ -36,38 +37,44 @@ import kotlin.math.abs
 /**
  * Subject for [Region] objects, used to make assertions over behaviors that occur on a rectangle.
  */
-class RegionSubject(
+class RegionSubject
+@JvmOverloads
+constructor(
     val regionEntry: RegionEntry,
     override val timestamp: Timestamp,
     override val reader: Reader? = null,
 ) : FlickerSubject(), IRegionSubject {
 
     /** Custom constructor for existing android regions */
+    @JvmOverloads
     constructor(
         region: Region?,
         timestamp: Timestamp,
-        reader: Reader? = null
+        reader: Reader? = null,
     ) : this(RegionEntry(region ?: Region(), timestamp), timestamp, reader)
 
     /** Custom constructor for existing rects */
+    @JvmOverloads
     constructor(
         rect: Rect?,
         timestamp: Timestamp,
-        reader: Reader? = null
+        reader: Reader? = null,
     ) : this(Region(rect ?: Rect()), timestamp, reader)
 
     /** Custom constructor for existing rects */
+    @JvmOverloads
     constructor(
         rect: RectF?,
         timestamp: Timestamp,
-        reader: Reader? = null
+        reader: Reader? = null,
     ) : this(rect?.toRect(), timestamp, reader)
 
     /** Custom constructor for existing regions */
+    @JvmOverloads
     constructor(
         regions: Collection<Region>,
         timestamp: Timestamp,
-        reader: Reader? = null
+        reader: Reader? = null,
     ) : this(mergeRegions(regions), timestamp, reader)
 
     val region = regionEntry.region
@@ -109,6 +116,10 @@ class RegionSubject(
         }
     }
 
+    operator fun invoke(assertion: AssertionPredicate<Region>): RegionSubject = apply {
+        assertion.verify(regionEntry.region)
+    }
+
     /** Subtracts [other] from this subject [region] */
     fun minus(other: Region): RegionSubject {
         val remainingRegion = Region(this.region)
@@ -136,13 +147,13 @@ class RegionSubject(
             name = "top position. Expected to be higher or equal",
             other,
             { it.top },
-            { thisV, otherV -> thisV <= otherV }
+            { thisV, otherV -> thisV <= otherV },
         )
         assertCompare(
             name = "bottom position. Expected to be higher or equal",
             other,
             { it.bottom },
-            { thisV, otherV -> thisV <= otherV }
+            { thisV, otherV -> thisV <= otherV },
         )
     }
 
@@ -159,13 +170,13 @@ class RegionSubject(
             name = "top position. Expected to be lower or equal",
             other,
             { it.top },
-            { thisV, otherV -> thisV >= otherV }
+            { thisV, otherV -> thisV >= otherV },
         )
         assertCompare(
             name = "bottom position. Expected to be lower or equal",
             other,
             { it.bottom },
-            { thisV, otherV -> thisV >= otherV }
+            { thisV, otherV -> thisV >= otherV },
         )
     }
 
@@ -176,13 +187,13 @@ class RegionSubject(
             name = "left position. Expected to be lower or equal",
             other,
             { it.left },
-            { thisV, otherV -> thisV >= otherV }
+            { thisV, otherV -> thisV >= otherV },
         )
         assertCompare(
             name = "right position. Expected to be lower or equal",
             other,
             { it.right },
-            { thisV, otherV -> thisV >= otherV }
+            { thisV, otherV -> thisV >= otherV },
         )
     }
 
@@ -199,13 +210,13 @@ class RegionSubject(
             name = "top position. Expected to be higher",
             other,
             { it.top },
-            { thisV, otherV -> thisV < otherV }
+            { thisV, otherV -> thisV < otherV },
         )
         assertCompare(
             name = "bottom position. Expected to be higher",
             other,
             { it.bottom },
-            { thisV, otherV -> thisV < otherV }
+            { thisV, otherV -> thisV < otherV },
         )
     }
 
@@ -228,13 +239,13 @@ class RegionSubject(
             name = "top position. Expected to be lower",
             other,
             { it.top },
-            { thisV, otherV -> thisV > otherV }
+            { thisV, otherV -> thisV > otherV },
         )
         assertCompare(
             name = "bottom position. Expected to be lower",
             other,
             { it.bottom },
-            { thisV, otherV -> thisV > otherV }
+            { thisV, otherV -> thisV > otherV },
         )
     }
 
@@ -308,11 +319,11 @@ class RegionSubject(
                     .addExtraDescription("Threshold", threshold)
                     .addExtraDescription(
                         "Horizontally positioned to the right",
-                        horizontallyPositionedToTheRight
+                        horizontallyPositionedToTheRight,
                     )
                     .addExtraDescription(
                         "Vertically positioned to the bottom",
-                        verticallyPositionedToTheBottom
+                        verticallyPositionedToTheBottom,
                     )
             throw IncorrectRegionException(errorMsgBuilder)
         }
@@ -455,7 +466,7 @@ class RegionSubject(
     fun isSameAspectRatio(
         numerator: Int,
         denominator: Int,
-        threshold: Double = 0.1
+        threshold: Double = 0.1,
     ): RegionSubject {
         val region = Region()
         region.set(Rect(0, 0, numerator, denominator))
@@ -466,7 +477,7 @@ class RegionSubject(
         name: String,
         other: Region,
         valueProvider: (Rect) -> T,
-        boundsCheck: (T, T) -> Boolean
+        boundsCheck: (T, T) -> Boolean,
     ) {
         val thisValue = valueProvider(region.bounds)
         val otherValue = valueProvider(other.bounds)
@@ -486,7 +497,7 @@ class RegionSubject(
     private fun <T : Comparable<T>> assertEquals(
         name: String,
         other: Region,
-        valueProvider: (Rect) -> T
+        valueProvider: (Rect) -> T,
     ) = assertCompare(name, other, valueProvider) { thisV, otherV -> thisV == otherV }
 
     private fun assertLeftRightAndAreaEquals(other: Region) {
diff --git a/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
index efd2c05fa..8b1da1f51 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/region/RegionTraceSubject.kt
@@ -19,6 +19,7 @@ package android.tools.flicker.subject.region
 import android.graphics.Rect
 import android.graphics.Region
 import android.tools.flicker.subject.FlickerTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.region.RegionTrace
 
@@ -26,7 +27,9 @@ import android.tools.traces.region.RegionTrace
  * Subject for [RegionTrace] objects, used to make assertions over behaviors that occur on a
  * sequence of regions.
  */
-class RegionTraceSubject(val trace: RegionTrace, override val reader: Reader? = null) :
+class RegionTraceSubject
+@JvmOverloads
+constructor(val trace: RegionTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<RegionSubject>(), IRegionSubject {
 
     override val subjects by lazy { trace.entries.map { RegionSubject(it, it.timestamp, reader) } }
@@ -173,4 +176,11 @@ class RegionTraceSubject(val trace: RegionTrace, override val reader: Reader? =
     override fun hasSameTopPosition(displayRect: Rect): RegionTraceSubject = apply {
         addAssertion("hasSameTopPosition($displayRect)") { it.hasSameTopPosition(displayRect) }
     }
+
+    @JvmOverloads
+    operator fun invoke(
+        name: String,
+        isOptional: Boolean = false,
+        assertion: AssertionPredicate<RegionSubject>,
+    ): RegionTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 }
diff --git a/libraries/flicker/src/android/tools/flicker/subject/wm/IWindowManagerSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/wm/IWindowManagerSubject.kt
index eff4a7a3c..2bf145617 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/wm/IWindowManagerSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/wm/IWindowManagerSubject.kt
@@ -65,7 +65,7 @@ interface IWindowManagerSubject<WMSubjectType, RegionSubjectType> {
      */
     fun isAboveWindow(
         aboveWindowComponentMatcher: IComponentMatcher,
-        belowWindowComponentMatcher: IComponentMatcher
+        belowWindowComponentMatcher: IComponentMatcher,
     ): WMSubjectType
 
     /**
@@ -111,7 +111,7 @@ interface IWindowManagerSubject<WMSubjectType, RegionSubjectType> {
      */
     fun hasRotation(
         rotation: Rotation,
-        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY,
     ): WMSubjectType
 
     /**
diff --git a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerStateSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerStateSubject.kt
index 46b3fb555..6346b1369 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerStateSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerStateSubject.kt
@@ -26,11 +26,13 @@ import android.tools.flicker.subject.exceptions.InvalidElementException
 import android.tools.flicker.subject.exceptions.InvalidPropertyException
 import android.tools.flicker.subject.exceptions.SubjectAssertionError
 import android.tools.flicker.subject.region.RegionSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.component.ComponentNameMatcher
 import android.tools.traces.component.IComponentMatcher
 import android.tools.traces.wm.WindowManagerState
 import android.tools.traces.wm.WindowState
+import java.util.function.Predicate
 
 /**
  * Subject for [WindowManagerState] objects, used to make assertions over behaviors that occur on a
@@ -56,14 +58,16 @@ import android.tools.traces.wm.WindowState
  *        .invoke { myCustomAssertion(this) }
  * ```
  */
-class WindowManagerStateSubject(
+class WindowManagerStateSubject
+@JvmOverloads
+constructor(
     val wmState: WindowManagerState,
     override val reader: Reader? = null,
     val trace: WindowManagerTraceSubject? = null,
 ) : FlickerSubject(), IWindowManagerSubject<WindowManagerStateSubject, RegionSubject> {
     override val timestamp = wmState.timestamp
 
-    val subjects by lazy { wmState.windowStates.map { WindowStateSubject(reader, timestamp, it) } }
+    val subjects by lazy { wmState.windowStates.map { WindowStateSubject(timestamp, it, reader) } }
 
     val appWindows: List<WindowStateSubject>
         get() = subjects.filter { wmState.appWindows.contains(it.windowState) }
@@ -84,10 +88,9 @@ class WindowManagerStateSubject(
         get() = subjects.filter { wmState.visibleAppWindows.contains(it.windowState) }
 
     /** Executes a custom [assertion] on the current subject */
-    operator fun invoke(assertion: (WindowManagerState) -> Unit): WindowManagerStateSubject =
-        apply {
-            assertion(this.wmState)
-        }
+    operator fun invoke(
+        assertion: AssertionPredicate<WindowManagerState>
+    ): WindowManagerStateSubject = apply { assertion.verify(this.wmState) }
 
     /** {@inheritDoc} */
     override fun isEmpty(): WindowManagerStateSubject = apply {
@@ -115,7 +118,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher?.toWindowIdentifier() ?: "<any>",
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -152,7 +155,7 @@ class WindowManagerStateSubject(
     /** {@inheritDoc} */
     override fun isAboveWindow(
         aboveWindowComponentMatcher: IComponentMatcher,
-        belowWindowComponentMatcher: IComponentMatcher
+        belowWindowComponentMatcher: IComponentMatcher,
     ): WindowManagerStateSubject = apply {
         contains(aboveWindowComponentMatcher)
         contains(belowWindowComponentMatcher)
@@ -214,7 +217,7 @@ class WindowManagerStateSubject(
                         .forSubject(this)
                         .forInvalidElement(
                             componentMatcher.toWindowIdentifier(),
-                            expectElementExists = true
+                            expectElementExists = true,
                         )
                         .addExtraDescription("Type", "App window")
                 throw InvalidElementException(errorMsgBuilder)
@@ -314,7 +317,7 @@ class WindowManagerStateSubject(
                         .forSubject(this)
                         .forInvalidElement(
                             componentMatcher.toActivityIdentifier(),
-                            expectElementExists = true
+                            expectElementExists = true,
                         )
                 throw InvalidElementException(errorMsgBuilder)
             }
@@ -345,7 +348,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toActivityIdentifier(),
-                        expectElementExists = false
+                        expectElementExists = false,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -361,7 +364,7 @@ class WindowManagerStateSubject(
                         .forSubject(this)
                         .forInvalidElement(
                             componentMatcher.toWindowIdentifier(),
-                            expectElementExists = false
+                            expectElementExists = false,
                         )
                 throw InvalidElementException(errorMsgBuilder)
             }
@@ -458,9 +461,7 @@ class WindowManagerStateSubject(
     /** {@inheritDoc} */
     override fun isKeyguardShowing(): WindowManagerStateSubject = apply {
         check { "Keyguard or AOD showing" }
-            .that(
-                wmState.isKeyguardShowing || wmState.isAodShowing,
-            )
+            .that(wmState.isKeyguardShowing || wmState.isAodShowing)
             .isEqual(true)
     }
 
@@ -474,37 +475,9 @@ class WindowManagerStateSubject(
         componentMatcher: IComponentMatcher
     ): WindowManagerStateSubject = apply { checkWindowIsInvisible(nonAppWindows, componentMatcher) }
 
-    private fun checkWindowIsVisible(
-        subjectList: List<WindowStateSubject>,
-        componentMatcher: IComponentMatcher
-    ) {
-        // Check existence of window.
-        contains(subjectList, componentMatcher)
-
-        val foundWindows =
-            subjectList.filter { componentMatcher.windowMatchesAnyOf(it.windowState) }
-
-        val visibleWindows =
-            wmState.visibleWindows.filter { visibleWindow ->
-                foundWindows.any { it.windowState == visibleWindow }
-            }
-
-        if (visibleWindows.isEmpty()) {
-            val errorMsgBuilder =
-                ExceptionMessageBuilder()
-                    .forSubject(this)
-                    .forIncorrectVisibility(
-                        componentMatcher.toWindowIdentifier(),
-                        expectElementVisible = true
-                    )
-                    .setActual(foundWindows.map { Fact("Is invisible", it.name) })
-            throw IncorrectVisibilityException(errorMsgBuilder)
-        }
-    }
-
     private fun checkWindowIsInvisible(
         subjectList: List<WindowStateSubject>,
-        componentMatcher: IComponentMatcher
+        componentMatcher: IComponentMatcher,
     ) {
         val foundWindows =
             subjectList.filter { componentMatcher.windowMatchesAnyOf(it.windowState) }
@@ -520,7 +493,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forIncorrectVisibility(
                         componentMatcher.toWindowIdentifier(),
-                        expectElementVisible = false
+                        expectElementVisible = false,
                     )
                     .setActual(visibleWindows.map { Fact("Is visible", it.name) })
             throw IncorrectVisibilityException(errorMsgBuilder)
@@ -529,7 +502,7 @@ class WindowManagerStateSubject(
 
     private fun contains(
         subjectList: List<WindowStateSubject>,
-        componentMatcher: IComponentMatcher
+        componentMatcher: IComponentMatcher,
     ) {
         if (!componentMatcher.windowMatchesAnyOf(subjectList.map { it.windowState })) {
             val errorMsgBuilder =
@@ -537,7 +510,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toWindowIdentifier(),
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -545,7 +518,7 @@ class WindowManagerStateSubject(
 
     private fun createIncorrectVisibilityException(
         componentMatcher: IComponentMatcher,
-        expectElementVisible: Boolean
+        expectElementVisible: Boolean,
     ) =
         IncorrectVisibilityException(
             ExceptionMessageBuilder()
@@ -559,7 +532,7 @@ class WindowManagerStateSubject(
                 .forSubject(this)
                 .forInvalidElement(
                     componentMatcher.toWindowIdentifier(),
-                    expectElementExists = true
+                    expectElementExists = true,
                 )
         )
 
@@ -625,7 +598,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forInvalidElement(
                         componentMatcher.toActivityIdentifier(),
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -640,7 +613,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forInvalidElement(
                         ComponentNameMatcher.SNAPSHOT.toWindowIdentifier(),
-                        expectElementExists = true
+                        expectElementExists = true,
                     )
             throw InvalidElementException(errorMsgBuilder)
         }
@@ -651,7 +624,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forIncorrectVisibility(
                         componentMatcher.toActivityIdentifier(),
-                        expectElementVisible = true
+                        expectElementVisible = true,
                     )
             throw IncorrectVisibilityException(errorMsgBuilder)
         }
@@ -662,7 +635,7 @@ class WindowManagerStateSubject(
                     .forSubject(this)
                     .forIncorrectVisibility(
                         ComponentNameMatcher.SNAPSHOT.toWindowIdentifier(),
-                        expectElementVisible = true
+                        expectElementVisible = true,
                     )
             throw IncorrectVisibilityException(errorMsgBuilder)
         }
@@ -705,8 +678,8 @@ class WindowManagerStateSubject(
      *
      * @param predicate to search for a subject
      */
-    fun windowState(predicate: (WindowState) -> Boolean): WindowStateSubject? =
-        subjects.firstOrNull { predicate(it.windowState) }
+    fun windowState(predicate: Predicate<WindowState>): WindowStateSubject? =
+        subjects.firstOrNull { predicate.test(it.windowState) }
 
     override fun toString(): String {
         return "WindowManagerStateSubject($wmState)"
diff --git a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerTraceSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerTraceSubject.kt
index 44df60b48..557fc8942 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerTraceSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowManagerTraceSubject.kt
@@ -19,12 +19,14 @@ package android.tools.flicker.subject.wm
 import android.tools.Rotation
 import android.tools.flicker.subject.FlickerTraceSubject
 import android.tools.flicker.subject.region.RegionTraceSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.component.ComponentNameMatcher
 import android.tools.traces.component.IComponentMatcher
 import android.tools.traces.region.RegionTrace
 import android.tools.traces.wm.WindowManagerTrace
 import android.tools.traces.wm.WindowState
+import java.util.function.Predicate
 
 /**
  * Subject for [WindowManagerTrace] objects, used to make assertions over behaviors that occur
@@ -51,10 +53,9 @@ import android.tools.traces.wm.WindowState
  *    }
  * ```
  */
-class WindowManagerTraceSubject(
-    val trace: WindowManagerTrace,
-    override val reader: Reader? = null
-) :
+class WindowManagerTraceSubject
+@JvmOverloads
+constructor(val trace: WindowManagerTrace, override val reader: Reader? = null) :
     FlickerTraceSubject<WindowManagerStateSubject>(),
     IWindowManagerSubject<WindowManagerTraceSubject, RegionTraceSubject> {
 
@@ -106,8 +107,8 @@ class WindowManagerTraceSubject(
      *
      * To search
      */
-    fun windowStates(predicate: (WindowState) -> Boolean): List<WindowStateSubject> {
-        return subjects.mapNotNull { it.windowState { window -> predicate(window) } }
+    fun windowStates(predicate: Predicate<WindowState>): List<WindowStateSubject> {
+        return subjects.mapNotNull { it.windowState { window -> predicate.test(window) } }
     }
 
     /** {@inheritDoc} */
@@ -117,7 +118,7 @@ class WindowManagerTraceSubject(
     /** See [notContains] */
     fun notContains(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("notContains(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.notContains(componentMatcher)
@@ -132,11 +133,11 @@ class WindowManagerTraceSubject(
     /** See [isAboveAppWindowVisible] */
     fun isAboveAppWindowVisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isAboveAppWindowVisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isAboveAppWindowVisible(componentMatcher)
         }
@@ -150,11 +151,11 @@ class WindowManagerTraceSubject(
     /** See [isAboveAppWindowInvisible] */
     fun isAboveAppWindowInvisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isAboveAppWindowInvisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isAboveAppWindowInvisible(componentMatcher)
         }
@@ -168,11 +169,11 @@ class WindowManagerTraceSubject(
     /** See [isBelowAppWindowVisible] */
     fun isBelowAppWindowVisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isBelowAppWindowVisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isBelowAppWindowVisible(componentMatcher)
         }
@@ -186,11 +187,11 @@ class WindowManagerTraceSubject(
     /** See [isBelowAppWindowInvisible] */
     fun isBelowAppWindowInvisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isBelowAppWindowInvisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isBelowAppWindowInvisible(componentMatcher)
         }
@@ -204,11 +205,11 @@ class WindowManagerTraceSubject(
     /** See [isNonAppWindowVisible] */
     fun isNonAppWindowVisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isNonAppWindowVisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isNonAppWindowVisible(componentMatcher)
         }
@@ -222,11 +223,11 @@ class WindowManagerTraceSubject(
     /** See [isNonAppWindowInvisible] */
     fun isNonAppWindowInvisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isNonAppWindowInvisible(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isNonAppWindowInvisible(componentMatcher)
         }
@@ -239,7 +240,7 @@ class WindowManagerTraceSubject(
     /** See [isAppWindowOnTop] */
     fun isAppWindowOnTop(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("isAppWindowOnTop(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isAppWindowOnTop(componentMatcher)
@@ -254,7 +255,7 @@ class WindowManagerTraceSubject(
     /** See [isAppWindowNotOnTop] */
     fun isAppWindowNotOnTop(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("appWindowNotOnTop(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isAppWindowNotOnTop(componentMatcher)
@@ -269,7 +270,7 @@ class WindowManagerTraceSubject(
     /** See [isAppWindowVisible] */
     fun isAppWindowVisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("isAppWindowVisible(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isAppWindowVisible(componentMatcher)
@@ -303,11 +304,11 @@ class WindowManagerTraceSubject(
     /** See [isAppSnapshotStartingWindowVisibleFor] */
     fun isAppSnapshotStartingWindowVisibleFor(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "isAppSnapshotStartingWindowVisibleFor(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.isAppSnapshotStartingWindowVisibleFor(componentMatcher)
         }
@@ -321,7 +322,7 @@ class WindowManagerTraceSubject(
     /** See [isAppWindowInvisible] */
     fun isAppWindowInvisible(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("isAppWindowInvisible(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isAppWindowInvisible(componentMatcher)
@@ -339,7 +340,7 @@ class WindowManagerTraceSubject(
     /** {@inheritDoc} */
     override fun isAboveWindow(
         aboveWindowComponentMatcher: IComponentMatcher,
-        belowWindowComponentMatcher: IComponentMatcher
+        belowWindowComponentMatcher: IComponentMatcher,
     ): WindowManagerTraceSubject = apply {
         val aboveWindowTitle = aboveWindowComponentMatcher.toWindowIdentifier()
         val belowWindowTitle = belowWindowComponentMatcher.toWindowIdentifier()
@@ -353,7 +354,7 @@ class WindowManagerTraceSubject(
         val regionTrace =
             RegionTrace(
                 componentMatcher,
-                subjects.map { it.visibleRegion(componentMatcher).regionEntry }
+                subjects.map { it.visibleRegion(componentMatcher).regionEntry },
             )
 
         return RegionTraceSubject(regionTrace, reader)
@@ -366,7 +367,7 @@ class WindowManagerTraceSubject(
     /** See [contains] */
     fun contains(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("contains(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.contains(componentMatcher)
@@ -381,11 +382,11 @@ class WindowManagerTraceSubject(
     /** See [containsAboveAppWindow] */
     fun containsAboveAppWindow(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "containsAboveAppWindow(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.containsAboveAppWindow(componentMatcher)
         }
@@ -398,7 +399,7 @@ class WindowManagerTraceSubject(
     /** See [containsAppWindow] */
     fun containsAppWindow(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("containsAppWindow(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.containsAboveAppWindow(componentMatcher)
@@ -413,11 +414,11 @@ class WindowManagerTraceSubject(
     /** See [containsBelowAppWindow] */
     fun containsBelowAppWindow(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion(
             "containsBelowAppWindows(${componentMatcher.toWindowIdentifier()})",
-            isOptional
+            isOptional,
         ) {
             it.containsBelowAppWindow(componentMatcher)
         }
@@ -431,7 +432,7 @@ class WindowManagerTraceSubject(
     /** See [containsNonAppWindow] */
     fun containsNonAppWindow(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("containsNonAppWindow(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.containsNonAppWindow(componentMatcher)
@@ -464,7 +465,7 @@ class WindowManagerTraceSubject(
     fun hasRotation(
         rotation: Rotation,
         displayId: Int,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("hasRotation($rotation, display=$displayId)", isOptional) {
             it.hasRotation(rotation, displayId)
@@ -478,7 +479,7 @@ class WindowManagerTraceSubject(
     /** See [isNotPinned] */
     fun isNotPinned(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("isNotPinned(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isNotPinned(componentMatcher)
@@ -510,7 +511,7 @@ class WindowManagerTraceSubject(
     /** See [isPinned] */
     fun isPinned(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("isPinned(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.isPinned(componentMatcher)
@@ -547,7 +548,7 @@ class WindowManagerTraceSubject(
     /** See [notContainsAppWindow] */
     fun notContainsAppWindow(
         componentMatcher: IComponentMatcher,
-        isOptional: Boolean
+        isOptional: Boolean,
     ): WindowManagerTraceSubject = apply {
         addAssertion("notContainsAppWindow(${componentMatcher.toWindowIdentifier()})", isOptional) {
             it.notContainsAppWindow(componentMatcher)
@@ -586,7 +587,7 @@ class WindowManagerTraceSubject(
     operator fun invoke(
         name: String,
         isOptional: Boolean = false,
-        assertion: (WindowManagerStateSubject) -> Unit
+        assertion: AssertionPredicate<WindowManagerStateSubject>,
     ): WindowManagerTraceSubject = apply { addAssertion(name, isOptional, assertion) }
 
     /** Run the assertions for all trace entries within the specified time range */
diff --git a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowStateSubject.kt b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowStateSubject.kt
index 4905da9fb..34287d705 100644
--- a/libraries/flicker/src/android/tools/flicker/subject/wm/WindowStateSubject.kt
+++ b/libraries/flicker/src/android/tools/flicker/subject/wm/WindowStateSubject.kt
@@ -20,6 +20,7 @@ import android.tools.Timestamp
 import android.tools.flicker.assertions.Fact
 import android.tools.flicker.subject.FlickerSubject
 import android.tools.flicker.subject.region.RegionSubject
+import android.tools.function.AssertionPredicate
 import android.tools.io.Reader
 import android.tools.traces.wm.WindowState
 
@@ -41,10 +42,12 @@ import android.tools.traces.wm.WindowState
  *        { myCustomAssertion(this) }
  * ```
  */
-class WindowStateSubject(
-    override val reader: Reader? = null,
+class WindowStateSubject
+@JvmOverloads
+constructor(
     override val timestamp: Timestamp,
-    val windowState: WindowState
+    val windowState: WindowState,
+    override val reader: Reader? = null,
 ) : FlickerSubject() {
     val isVisible: Boolean = windowState.isVisible
     val isInvisible: Boolean = !windowState.isVisible
@@ -55,8 +58,8 @@ class WindowStateSubject(
     override val selfFacts = listOf(Fact("Window title", windowState.title))
 
     /** If the [windowState] exists, executes a custom [assertion] on the current subject */
-    operator fun invoke(assertion: (WindowState) -> Unit): WindowStateSubject = apply {
-        assertion(this.windowState)
+    operator fun invoke(assertion: AssertionPredicate<WindowState>): WindowStateSubject = apply {
+        assertion.verify(this.windowState)
     }
 
     override fun toString(): String {
diff --git a/libraries/flicker/src/android/tools/function/AssertionPredicate.kt b/libraries/flicker/src/android/tools/function/AssertionPredicate.kt
new file mode 100644
index 000000000..2a1e62f60
--- /dev/null
+++ b/libraries/flicker/src/android/tools/function/AssertionPredicate.kt
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.function
+
+fun interface AssertionPredicate<T> {
+    fun verify(element: T)
+}
diff --git a/libraries/flicker/test/src/android/tools/TestUtils.kt b/libraries/flicker/test/src/android/tools/TestUtils.kt
index 36ae437fa..30b820b7e 100644
--- a/libraries/flicker/test/src/android/tools/TestUtils.kt
+++ b/libraries/flicker/test/src/android/tools/TestUtils.kt
@@ -68,7 +68,7 @@ internal fun getTraceReaderFromScenario(scenario: String): Reader {
             LegacyTransitionTraceParser()
                 .parse(
                     scenarioTraces.wmTransitions.readBytes(),
-                    scenarioTraces.shellTransitions.readBytes()
+                    scenarioTraces.shellTransitions.readBytes(),
                 ),
         transactionsTrace = transactionsTrace,
         eventLog = EventLogParser().parse(scenarioTraces.eventLog.readBytes()),
@@ -87,7 +87,7 @@ fun getScenarioTraces(scenario: String): FlickerBuilder.TraceFiles {
             "layers_and_transactions_trace$PERFETTO_EXT" to { perfettoTrace = it },
             "wm_transition_trace$WINSCOPE_EXT" to { wmTransitionTrace = it },
             "shell_transition_trace$WINSCOPE_EXT" to { shellTransitionTrace = it },
-            "eventlog$WINSCOPE_EXT" to { eventLog = it }
+            "eventlog$WINSCOPE_EXT" to { eventLog = it },
         )
     for ((traceFileName, resultSetter) in traces.entries) {
         val traceBytes = readAsset("scenarios/$scenario/$traceFileName")
@@ -109,7 +109,7 @@ fun createMockedFlicker(
     setup: List<FlickerTestData.() -> Unit> = emptyList(),
     teardown: List<FlickerTestData.() -> Unit> = emptyList(),
     transitions: List<FlickerTestData.() -> Unit> = emptyList(),
-    extraMonitor: ITransitionMonitor? = null
+    extraMonitor: ITransitionMonitor? = null,
 ): FlickerTestData {
     val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
     val uiDevice: UiDevice = UiDevice.getInstance(instrumentation)
@@ -117,7 +117,7 @@ fun createMockedFlicker(
     val monitors: MutableList<ITransitionMonitor> =
         mutableListOf(
             WindowManagerTraceMonitor(),
-            PerfettoTraceMonitor.newBuilder().enableLayersTrace().build()
+            PerfettoTraceMonitor.newBuilder().enableLayersTrace().build(),
         )
     extraMonitor?.let { monitors.add(it) }
     Mockito.`when`(mockedFlicker.wmHelper).thenReturn(WindowManagerStateHelper())
diff --git a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceResultsCollectorTest.kt b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceResultsCollectorTest.kt
index a79675272..17b256dac 100644
--- a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceResultsCollectorTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceResultsCollectorTest.kt
@@ -79,7 +79,7 @@ class FlickerServiceResultsCollectorTest {
         Mockito.verify(testData)
             .addStringMetric(
                 Mockito.eq(FlickerServiceResultsCollector.FAAS_RESULTS_FILE_PATH_KEY),
-                Mockito.anyString()
+                Mockito.anyString(),
             )
         // No other calls to addStringMetric
         Mockito.verify(testData, Mockito.times(2))
@@ -227,7 +227,7 @@ class FlickerServiceResultsCollectorTest {
             listOf(
                 mockSuccessfulAssertionResult,
                 mockSuccessfulAssertionResult,
-                mockFailedAssertionResult
+                mockFailedAssertionResult,
             )
         val collector = createCollector(assertionResults = assertionResults)
         val runData = DataRecord()
@@ -358,7 +358,7 @@ class FlickerServiceResultsCollectorTest {
                     wmTrace = MockWindowManagerTraceBuilder().build(),
                     layersTrace = MockLayersTraceBuilder().build(),
                     transitionsTrace = TransitionsTrace(emptyList()),
-                    transactionsTrace = null
+                    transactionsTrace = null,
                 )
             )
         val mockFlickerService = Mockito.mock(FlickerService::class.java)
diff --git a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceRuleTest.kt b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceRuleTest.kt
index 07c930564..70ee1b544 100644
--- a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceRuleTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceRuleTest.kt
@@ -107,7 +107,7 @@ class FlickerServiceRuleTest {
         val testRule =
             FlickerServiceRule(
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = false
+                failTestOnFlicker = false,
             )
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
 
@@ -127,7 +127,7 @@ class FlickerServiceRuleTest {
         val testRule =
             FlickerServiceRule(
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = true
+                failTestOnFlicker = true,
             )
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
 
@@ -155,7 +155,7 @@ class FlickerServiceRuleTest {
         val testRule =
             FlickerServiceRule(
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = true
+                failTestOnFlicker = true,
             )
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
 
@@ -201,7 +201,7 @@ class FlickerServiceRuleTest {
             FlickerServiceRule(
                 enabled = false,
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = true
+                failTestOnFlicker = true,
             )
 
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
@@ -226,7 +226,7 @@ class FlickerServiceRuleTest {
         val testRule =
             FlickerServiceRule(
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = true
+                failTestOnFlicker = true,
             )
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
 
@@ -248,7 +248,7 @@ class FlickerServiceRuleTest {
         val testRule =
             FlickerServiceRule(
                 metricsCollector = mockFlickerServiceResultsCollector,
-                failTestOnFlicker = true
+                failTestOnFlicker = true,
             )
         val mockDescription = Description.createTestDescription(this::class.java, "mockTest")
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceTest.kt b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceTest.kt
index 0071d44a4..58ea97b91 100644
--- a/libraries/flicker/test/src/android/tools/flicker/FlickerServiceTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/FlickerServiceTest.kt
@@ -44,7 +44,7 @@ class FlickerServiceTest {
             FlickerConfigEntry(
                 scenarioId = ScenarioId("TEST_SCENARIO"),
                 extractor = mockScenarioExtractor,
-                assertions = emptyMap()
+                assertions = emptyMap(),
             )
 
         val traceSlice =
@@ -68,7 +68,7 @@ class FlickerServiceTest {
             FlickerConfigEntry(
                 scenarioId = ScenarioId("TEST_SCENARIO"),
                 extractor = mockScenarioExtractor,
-                assertions = emptyMap()
+                assertions = emptyMap(),
             )
 
         val traceSlice =
diff --git a/libraries/flicker/test/src/android/tools/flicker/ScenarioInstanceTest.kt b/libraries/flicker/test/src/android/tools/flicker/ScenarioInstanceTest.kt
index 4f66f996f..0dfa24a5b 100644
--- a/libraries/flicker/test/src/android/tools/flicker/ScenarioInstanceTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/ScenarioInstanceTest.kt
@@ -51,7 +51,7 @@ class ScenarioInstanceTest {
                                 object : AssertionTemplate("myAssertionSingle") {
                                     override fun doEvaluate(
                                         scenarioInstance: ScenarioInstance,
-                                        flicker: FlickerTest
+                                        flicker: FlickerTest,
                                     ) {
                                         flicker.assertLayers {
                                             throw SimpleFlickerAssertionError(errorMessage)
@@ -61,7 +61,7 @@ class ScenarioInstanceTest {
                                 object : AssertionTemplate("myAssertionMultiple") {
                                     override fun doEvaluate(
                                         scenarioInstance: ScenarioInstance,
-                                        flicker: FlickerTest
+                                        flicker: FlickerTest,
                                     ) {
                                         flicker.assertLayers {
                                             // No errors
@@ -76,9 +76,9 @@ class ScenarioInstanceTest {
                                             // No errors
                                         }
                                     }
-                                } to AssertionInvocationGroup.BLOCKING
+                                } to AssertionInvocationGroup.BLOCKING,
                             ),
-                        enabled = true
+                        enabled = true,
                     ),
                 startRotation = Rotation.ROTATION_0,
                 endRotation = Rotation.ROTATION_90,
@@ -135,7 +135,7 @@ class ScenarioInstanceTest {
                                 object : AssertionTemplate("myAssertion1") {
                                     override fun doEvaluate(
                                         scenarioInstance: ScenarioInstance,
-                                        flicker: FlickerTest
+                                        flicker: FlickerTest,
                                     ) {
                                         throw SimpleFlickerAssertionError(errorMessage)
                                     }
@@ -143,16 +143,16 @@ class ScenarioInstanceTest {
                                 object : AssertionTemplate("myAssertion2") {
                                     override fun doEvaluate(
                                         scenarioInstance: ScenarioInstance,
-                                        flicker: FlickerTest
+                                        flicker: FlickerTest,
                                     ) {
                                         flicker.assertLayers {
                                             throw SimpleFlickerAssertionError("Some flicker error")
                                         }
                                         throw SimpleFlickerAssertionError(errorMessage)
                                     }
-                                } to AssertionInvocationGroup.BLOCKING
+                                } to AssertionInvocationGroup.BLOCKING,
                             ),
-                        enabled = true
+                        enabled = true,
                     ),
                 startRotation = Rotation.ROTATION_0,
                 endRotation = Rotation.ROTATION_90,
diff --git a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionDataFactoryTest.kt b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionDataFactoryTest.kt
index a3e94b52b..5e4a848d8 100644
--- a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionDataFactoryTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionDataFactoryTest.kt
@@ -28,6 +28,7 @@ class AssertionDataFactoryTest : AssertionStateDataFactoryTest() {
     override val wmAssertionFactory: AssertionStateDataFactory
         get() =
             AssertionDataFactory(WindowManagerStateSubject::class, WindowManagerTraceSubject::class)
+
     override val layersAssertionFactory: AssertionStateDataFactory
         get() = AssertionDataFactory(LayerTraceEntrySubject::class, LayersTraceSubject::class)
 
@@ -37,13 +38,13 @@ class AssertionDataFactoryTest : AssertionStateDataFactoryTest() {
             (wmAssertionFactory as AssertionDataFactory).createTraceAssertion {}
                 as AssertionDataImpl,
             WindowManagerTraceSubject::class,
-            Tag.ALL
+            Tag.ALL,
         )
         validate(
             (layersAssertionFactory as AssertionDataFactory).createTraceAssertion {}
                 as AssertionDataImpl,
             LayersTraceSubject::class,
-            Tag.ALL
+            Tag.ALL,
         )
     }
 }
diff --git a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionStateDataFactoryTest.kt b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionStateDataFactoryTest.kt
index 354c86c1f..bc75a020d 100644
--- a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionStateDataFactoryTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionStateDataFactoryTest.kt
@@ -42,17 +42,17 @@ open class AssertionStateDataFactoryTest {
         validate(
             wmAssertionFactory.createStartStateAssertion {},
             WindowManagerStateSubject::class,
-            Tag.START
+            Tag.START,
         )
         validate(
             layersAssertionFactory.createStartStateAssertion {},
             LayerTraceEntrySubject::class,
-            Tag.START
+            Tag.START,
         )
         validate(
             eventLogAssertionFactory.createStartStateAssertion {},
             EventLogSubject::class,
-            Tag.START
+            Tag.START,
         )
     }
 
@@ -61,17 +61,17 @@ open class AssertionStateDataFactoryTest {
         validate(
             wmAssertionFactory.createEndStateAssertion {},
             WindowManagerStateSubject::class,
-            Tag.END
+            Tag.END,
         )
         validate(
             layersAssertionFactory.createEndStateAssertion {},
             LayerTraceEntrySubject::class,
-            Tag.END
+            Tag.END,
         )
         validate(
             eventLogAssertionFactory.createEndStateAssertion {},
             EventLogSubject::class,
-            Tag.END
+            Tag.END,
         )
     }
 
@@ -80,12 +80,12 @@ open class AssertionStateDataFactoryTest {
         validate(
             wmAssertionFactory.createTagAssertion(TAG) {},
             WindowManagerStateSubject::class,
-            TAG
+            TAG,
         )
         validate(
             layersAssertionFactory.createTagAssertion(TAG) {},
             LayerTraceEntrySubject::class,
-            TAG
+            TAG,
         )
         validate(eventLogAssertionFactory.createTagAssertion(TAG) {}, EventLogSubject::class, TAG)
     }
@@ -93,7 +93,7 @@ open class AssertionStateDataFactoryTest {
     protected fun validate(
         assertionData: AssertionDataImpl,
         expectedSubject: KClass<*>,
-        expectedTag: String
+        expectedTag: String,
     ) {
         Truth.assertWithMessage("Subject")
             .that(assertionData.expectedSubjectClass)
diff --git a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionsCheckerTest.kt b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionsCheckerTest.kt
index f55448fb9..2812c688a 100644
--- a/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionsCheckerTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/assertions/AssertionsCheckerTest.kt
@@ -147,7 +147,6 @@ class AssertionsCheckerTest {
 
         companion object {
             /** User-defined entry point */
-            @JvmStatic
             fun assertThat(entry: SimpleEntry): SimpleEntrySubject {
                 return SimpleEntrySubject(entry)
             }
diff --git a/libraries/flicker/test/src/android/tools/flicker/assertions/ScenarioAssertionTest.kt b/libraries/flicker/test/src/android/tools/flicker/assertions/ScenarioAssertionTest.kt
index 713e8e5f5..adf061eec 100644
--- a/libraries/flicker/test/src/android/tools/flicker/assertions/ScenarioAssertionTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/assertions/ScenarioAssertionTest.kt
@@ -40,7 +40,7 @@ class ScenarioAssertionTest {
                 assertionData = listOf(mockAssertionData),
                 stabilityGroup = AssertionInvocationGroup.BLOCKING,
                 assertionExtraData = mapOf("extraKey" to "extraValue"),
-                assertionRunner = mockAssertionRunner
+                assertionRunner = mockAssertionRunner,
             )
 
         Mockito.`when`(mockAssertionRunner.runAssertion(mockAssertionData))
@@ -73,7 +73,7 @@ class ScenarioAssertionTest {
                 reader = mockReader,
                 assertionData = assertionTemplate.createAssertions(mockScenarioInstance),
                 stabilityGroup = AssertionInvocationGroup.BLOCKING,
-                assertionExtraData = mapOf()
+                assertionExtraData = mapOf(),
             )
 
         val result = scenarioAssertion.execute()
@@ -103,7 +103,7 @@ class ScenarioAssertionTest {
                 reader = mockReader,
                 assertionData = assertionTemplate.createAssertions(mockScenarioInstance),
                 stabilityGroup = AssertionInvocationGroup.BLOCKING,
-                assertionExtraData = mapOf()
+                assertionExtraData = mapOf(),
             )
 
         val result = scenarioAssertion.execute()
diff --git a/libraries/flicker/test/src/android/tools/flicker/config/FlickerConfigTest.kt b/libraries/flicker/test/src/android/tools/flicker/config/FlickerConfigTest.kt
index 25b753a10..a03f98921 100644
--- a/libraries/flicker/test/src/android/tools/flicker/config/FlickerConfigTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/config/FlickerConfigTest.kt
@@ -58,7 +58,7 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
 
         val entries = registry.getEntries()
@@ -109,7 +109,7 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
         registry.unregisterAssertion(SOME_SCENARIO, assertion.id)
 
@@ -141,12 +141,12 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
         registry.overrideAssertionStabilityGroup(
             SOME_SCENARIO,
             assertion.id,
-            AssertionInvocationGroup.NON_BLOCKING
+            AssertionInvocationGroup.NON_BLOCKING,
         )
 
         val entries = registry.getEntries()
@@ -188,12 +188,12 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion1 to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion1 to AssertionInvocationGroup.BLOCKING),
         )
         registry.registerAssertions(
             SOME_SCENARIO,
             assertion2,
-            stabilityGroup = AssertionInvocationGroup.NON_BLOCKING
+            stabilityGroup = AssertionInvocationGroup.NON_BLOCKING,
         )
 
         val entries = registry.getEntries()
@@ -250,7 +250,7 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
 
         val error =
@@ -258,7 +258,7 @@ class FlickerConfigTest {
                 registry.registerScenario(
                     SOME_SCENARIO,
                     EXTRACTOR_FOR_SOME_SCENARIO,
-                    mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+                    mapOf(assertion to AssertionInvocationGroup.BLOCKING),
                 )
             }
         Truth.assertThat(error)
@@ -280,7 +280,7 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
 
         val error =
@@ -328,12 +328,12 @@ class FlickerConfigTest {
         registry.registerScenario(
             SOME_SCENARIO,
             EXTRACTOR_FOR_SOME_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
         registry.registerScenario(
             SOME_OTHER_SCENARIO,
             EXTRACTOR_FOR_SOME_OTHER_SCENARIO,
-            mapOf(assertion to AssertionInvocationGroup.BLOCKING)
+            mapOf(assertion to AssertionInvocationGroup.BLOCKING),
         )
     }
 
@@ -347,7 +347,7 @@ class FlickerConfigTest {
                     }
                 },
             assertions = mapOf(),
-            enabled = true
+            enabled = true,
         )
     }
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/datastore/CachedResultReaderTest.kt b/libraries/flicker/test/src/android/tools/flicker/datastore/CachedResultReaderTest.kt
index c1867d52d..22f5c82c4 100644
--- a/libraries/flicker/test/src/android/tools/flicker/datastore/CachedResultReaderTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/datastore/CachedResultReaderTest.kt
@@ -45,7 +45,7 @@ class CachedResultReaderTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         val actual = reader.readEventLogTrace()
         Truth.assertWithMessage("Event log size").that(actual).isNotNull()
diff --git a/libraries/flicker/test/src/android/tools/flicker/datastore/Consts.kt b/libraries/flicker/test/src/android/tools/flicker/datastore/Consts.kt
index ece31c293..9ccde2051 100644
--- a/libraries/flicker/test/src/android/tools/flicker/datastore/Consts.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/datastore/Consts.kt
@@ -28,13 +28,13 @@ object Consts {
         ResultData(
             _artifact = TestArtifact("TEST_RESULT"),
             _transitionTimeRange = TransitionTimeRange(Timestamps.empty(), Timestamps.empty()),
-            _executionError = null
+            _executionError = null,
         )
 
     internal val RESULT_FAILURE =
         ResultData(
             _artifact = TestArtifact("RESULT_FAILURE"),
             _transitionTimeRange = TransitionTimeRange(Timestamps.empty(), Timestamps.empty()),
-            _executionError = null
+            _executionError = null,
         )
 }
diff --git a/libraries/flicker/test/src/android/tools/flicker/extractor/ShellTransitionScenarioExtractorTest.kt b/libraries/flicker/test/src/android/tools/flicker/extractor/ShellTransitionScenarioExtractorTest.kt
index a03b69f2d..00bd472d5 100644
--- a/libraries/flicker/test/src/android/tools/flicker/extractor/ShellTransitionScenarioExtractorTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/extractor/ShellTransitionScenarioExtractorTest.kt
@@ -76,7 +76,7 @@ class ShellTransitionScenarioExtractorTest {
                 Timestamps.from(
                     unixNanos = 1682433264342452347,
                     systemUptimeNanos = 2766599071189,
-                    elapsedNanos = 2755182606546
+                    elapsedNanos = 2755182606546,
                 )
             )
         Truth.assertThat(slices.first().endTimestamp)
@@ -84,7 +84,7 @@ class ShellTransitionScenarioExtractorTest {
                 Timestamps.from(
                     unixNanos = 1682433277025674745,
                     systemUptimeNanos = 2767865667794,
-                    elapsedNanos = 2767949503328
+                    elapsedNanos = 2767949503328,
                 )
             )
         Truth.assertThat(slices.first().associatedTransition)
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceCachedTestCaseTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceCachedTestCaseTest.kt
index 456269ed7..b2d679db2 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceCachedTestCaseTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceCachedTestCaseTest.kt
@@ -88,7 +88,7 @@ class FlickerServiceCachedTestCaseTest {
                         "${FlickerServiceResultsCollector.FAAS_METRICS_PREFIX}::" +
                             assertionResult.name
                     ) == "0"
-                }
+                },
             )
     }
 
@@ -145,7 +145,7 @@ class FlickerServiceCachedTestCaseTest {
                         "${FlickerServiceResultsCollector.FAAS_METRICS_PREFIX}::" +
                             assertionResult.name
                     ) == "1"
-                }
+                },
             )
     }
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceDecoratorTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceDecoratorTest.kt
index eea378ba3..5b78fde05 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceDecoratorTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceDecoratorTest.kt
@@ -73,7 +73,7 @@ class FlickerServiceDecoratorTest {
                 skipNonBlocking = false,
                 inner = innerDecorator,
                 instrumentation = instrumentation,
-                flickerService = flickerService
+                flickerService = flickerService,
             )
         decorator.getTestMethods(test)
 
@@ -83,7 +83,7 @@ class FlickerServiceDecoratorTest {
                 KotlinMockito.argThat<Bundle> {
                     this.getString(Instrumentation.REPORT_KEY_STREAMRESULT)
                         ?.contains("Running setup") ?: false
-                }
+                },
             )
         Mockito.verify(instrumentation)
             .sendStatus(
@@ -91,7 +91,7 @@ class FlickerServiceDecoratorTest {
                 KotlinMockito.argThat {
                     this.getString(Instrumentation.REPORT_KEY_STREAMRESULT)
                         ?.contains("Running transition") ?: false
-                }
+                },
             )
         Mockito.verify(instrumentation)
             .sendStatus(
@@ -99,7 +99,7 @@ class FlickerServiceDecoratorTest {
                 KotlinMockito.argThat {
                     this.getString(Instrumentation.REPORT_KEY_STREAMRESULT)
                         ?.contains("Running teardown") ?: false
-                }
+                },
             )
     }
 
@@ -142,7 +142,7 @@ class FlickerServiceDecoratorTest {
                 skipNonBlocking = false,
                 inner = innerDecorator,
                 instrumentation = instrumentation,
-                flickerService = flickerService
+                flickerService = flickerService,
             )
 
         // This should not throw
@@ -188,7 +188,7 @@ class FlickerServiceDecoratorTest {
                         object : AssertionTemplate("myMockAssertion") {
                             override fun doEvaluate(
                                 scenarioInstance: ScenarioInstance,
-                                flicker: FlickerTest
+                                flicker: FlickerTest,
                             ) {
                                 flicker.assertLayers {
                                     // Does nothing
@@ -196,7 +196,7 @@ class FlickerServiceDecoratorTest {
                             }
                         } to AssertionInvocationGroup.BLOCKING
                     ),
-                enabled = true
+                enabled = true,
             )
 
         val mockScenarioInstance1 =
@@ -206,7 +206,7 @@ class FlickerServiceDecoratorTest {
                 endRotation = Rotation.ROTATION_0,
                 startTimestamp = CrossPlatform.timestamp.from(10),
                 endTimestamp = CrossPlatform.timestamp.from(20),
-                reader = Mockito.mock(Reader::class.java)
+                reader = Mockito.mock(Reader::class.java),
             )
 
         val mockScenarioInstance2 =
@@ -216,7 +216,7 @@ class FlickerServiceDecoratorTest {
                 endRotation = Rotation.ROTATION_0,
                 startTimestamp = CrossPlatform.timestamp.from(10),
                 endTimestamp = CrossPlatform.timestamp.from(20),
-                reader = Mockito.mock(Reader::class.java)
+                reader = Mockito.mock(Reader::class.java),
             )
 
         Mockito.`when`(flickerService.detectScenarios(KotlinMockito.any(Reader::class.java)))
@@ -230,7 +230,7 @@ class FlickerServiceDecoratorTest {
                 skipNonBlocking = false,
                 inner = innerDecorator,
                 instrumentation = instrumentation,
-                flickerService = flickerService
+                flickerService = flickerService,
             )
 
         val methods = decorator.getTestMethods(test)
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
index fbd573615..d4c5db571 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/FlickerServiceJUnit4ClassRunnerTest.kt
@@ -91,6 +91,7 @@ class FlickerServiceJUnit4ClassRunnerTest {
         Mockito.verify(notifier, Mockito.atLeast(2))
             .fireTestFinished(ArgumentMatchers.argThat { it.methodName.contains("FaaS") })
     }
+
     /** Below are all the mock test classes uses for testing purposes */
     @RunWith(FlickerServiceJUnit4ClassRunner::class)
     open class SimpleTest {
@@ -130,7 +131,7 @@ class FlickerServiceJUnit4ClassRunnerTest {
                                     object : AssertionTemplate("myBlockingAssertion") {
                                         override fun doEvaluate(
                                             scenarioInstance: ScenarioInstance,
-                                            flicker: FlickerTest
+                                            flicker: FlickerTest,
                                         ) {
                                             flicker.assertWm {
                                                 // Random test
@@ -141,16 +142,16 @@ class FlickerServiceJUnit4ClassRunnerTest {
                                     object : AssertionTemplate("myNonBlockingAssertion") {
                                         override fun doEvaluate(
                                             scenarioInstance: ScenarioInstance,
-                                            flicker: FlickerTest
+                                            flicker: FlickerTest,
                                         ) {
                                             flicker.assertWm {
                                                 // Random test
                                                 visibleWindowsShownMoreThanOneConsecutiveEntry()
                                             }
                                         }
-                                    } to AssertionInvocationGroup.NON_BLOCKING
+                                    } to AssertionInvocationGroup.NON_BLOCKING,
                                 ),
-                            enabled = true
+                            enabled = true,
                         )
                     )
             }
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerDecoratorTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerDecoratorTest.kt
index 1a5e3a2f4..9d8223ca2 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerDecoratorTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerDecoratorTest.kt
@@ -49,7 +49,7 @@ class LegacyFlickerDecoratorTest {
             TestWithParameters(
                 "test",
                 TestClass(TestUtils.DummyTestClassValid::class.java),
-                listOf(TestUtils.VALID_ARGS_EMPTY)
+                listOf(TestUtils.VALID_ARGS_EMPTY),
             )
         val mockTransitionRunner = Mockito.mock(ITransitionRunner::class.java)
         val inner = Mockito.mock(IFlickerJUnitDecorator::class.java)
@@ -68,7 +68,7 @@ class LegacyFlickerDecoratorTest {
             TestWithParameters(
                 "test",
                 TestClass(TestUtils.DummyTestClassValid::class.java),
-                listOf(TestUtils.VALID_ARGS_EMPTY)
+                listOf(TestUtils.VALID_ARGS_EMPTY),
             )
         val mockTransitionRunner = Mockito.mock(ITransitionRunner::class.java)
         val inner = Mockito.mock(IFlickerJUnitDecorator::class.java)
@@ -86,12 +86,7 @@ class LegacyFlickerDecoratorTest {
         val description = decorator.getChildDescription(method)
         val invokerTest = TestUtils.DummyTestClassValid(LegacyFlickerTest())
 
-        decorator
-            .getMethodInvoker(
-                method,
-                test = invokerTest,
-            )
-            .evaluate()
+        decorator.getMethodInvoker(method, test = invokerTest).evaluate()
 
         Mockito.verify(mockTransitionRunner).runTransition(scenario, invokerTest, description)
     }
@@ -104,7 +99,7 @@ class LegacyFlickerDecoratorTest {
             TestWithParameters(
                 "test",
                 TestClass(TestUtils.DummyTestClassValid::class.java),
-                listOf(TestUtils.VALID_ARGS_EMPTY)
+                listOf(TestUtils.VALID_ARGS_EMPTY),
             )
         val transitionRunner = LegacyFlickerJUnit4ClassRunner(test, scenario).transitionRunner
 
@@ -121,10 +116,7 @@ class LegacyFlickerDecoratorTest {
 
         repeat(3) {
             decorator
-                .getMethodInvoker(
-                    method,
-                    test = TestUtils.DummyTestClassValid(LegacyFlickerTest()),
-                )
+                .getMethodInvoker(method, test = TestUtils.DummyTestClassValid(LegacyFlickerTest()))
                 .evaluate()
         }
 
@@ -143,7 +135,7 @@ class LegacyFlickerDecoratorTest {
         assertFailProviderMethod(
             TestUtils.DummyTestClassEmpty::class,
             expectedExceptions =
-                listOf("One object should be annotated with @FlickerBuilderProvider")
+                listOf("One object should be annotated with @FlickerBuilderProvider"),
         )
     }
 
@@ -152,7 +144,7 @@ class LegacyFlickerDecoratorTest {
         assertFailProviderMethod(
             TestUtils.DummyTestClassMultipleProvider::class,
             expectedExceptions =
-                listOf("Only one object should be annotated with @FlickerBuilderProvider")
+                listOf("Only one object should be annotated with @FlickerBuilderProvider"),
         )
     }
 
@@ -160,7 +152,7 @@ class LegacyFlickerDecoratorTest {
     fun failStaticProviderMethod() {
         assertFailProviderMethod(
             TestUtils.DummyTestClassProviderStatic::class,
-            expectedExceptions = listOf("Method myMethod() should not be static")
+            expectedExceptions = listOf("Method myMethod() should not be static"),
         )
     }
 
@@ -172,8 +164,8 @@ class LegacyFlickerDecoratorTest {
                 listOf(
                     "Method myMethod() should be public",
                     "Method myMethod() should return a " +
-                        "${FlickerBuilder::class.java.simpleName} object"
-                )
+                        "${FlickerBuilder::class.java.simpleName} object",
+                ),
         )
     }
 
@@ -196,7 +188,7 @@ class LegacyFlickerDecoratorTest {
                 test.testClass,
                 scenario = null,
                 mockTransitionRunner,
-                inner = null
+                inner = null,
             )
         val failures = decorator.doValidateInstanceMethods()
         Truth.assertWithMessage("Failure count").that(failures).hasSize(expectedExceptions.count())
@@ -218,7 +210,7 @@ class LegacyFlickerDecoratorTest {
                 test.testClass,
                 scenario = null,
                 mockTransitionRunner,
-                inner = null
+                inner = null,
             )
         val failures = decorator.doValidateConstructor()
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunnerTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunnerTest.kt
index 88139509a..45e2c51b4 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunnerTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerJUnit4ClassRunnerTest.kt
@@ -322,7 +322,7 @@ class LegacyFlickerJUnit4ClassRunnerTest {
                                     object : AssertionTemplate("BlockingAssertion") {
                                         override fun doEvaluate(
                                             scenarioInstance: ScenarioInstance,
-                                            flicker: FlickerTest
+                                            flicker: FlickerTest,
                                         ) {
                                             flicker.assertLayers {}
                                         }
@@ -330,12 +330,12 @@ class LegacyFlickerJUnit4ClassRunnerTest {
                                     object : AssertionTemplate("NonBlockingAssertion") {
                                         override fun doEvaluate(
                                             scenarioInstance: ScenarioInstance,
-                                            flicker: FlickerTest
+                                            flicker: FlickerTest,
                                         ) {
                                             flicker.assertLayersEnd {}
                                         }
-                                    } to AssertionInvocationGroup.NON_BLOCKING
-                                )
+                                    } to AssertionInvocationGroup.NON_BLOCKING,
+                                ),
                         )
                     )
         }
@@ -418,7 +418,7 @@ class LegacyFlickerJUnit4ClassRunnerTest {
 
         private fun createRunner(
             baseTest: TestWithParameters,
-            arguments: Bundle = InstrumentationRegistry.getArguments()
+            arguments: Bundle = InstrumentationRegistry.getArguments(),
         ) =
             FlickerParametersRunnerFactory()
                 .createRunnerForTestWithParameters(baseTest, arguments = arguments)
diff --git a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerServiceDecoratorTest.kt b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerServiceDecoratorTest.kt
index a6eac3748..889613de3 100644
--- a/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerServiceDecoratorTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/junit/LegacyFlickerServiceDecoratorTest.kt
@@ -44,7 +44,7 @@ class LegacyFlickerServiceDecoratorTest {
             TestWithParameters(
                 "test",
                 TestClass(TestUtils.DummyTestClassValid::class.java),
-                listOf(TestUtils.VALID_ARGS_EMPTY)
+                listOf(TestUtils.VALID_ARGS_EMPTY),
             )
         val mockTransitionRunner = Mockito.mock(ITransitionRunner::class.java)
         val decorator =
@@ -54,7 +54,7 @@ class LegacyFlickerServiceDecoratorTest {
                 mockTransitionRunner,
                 skipNonBlocking = false,
                 arguments = InstrumentationRegistry.getArguments(),
-                inner = null
+                inner = null,
             )
         var failures = decorator.doValidateConstructor()
         Truth.assertWithMessage("Failure count").that(failures).isEmpty()
@@ -69,7 +69,7 @@ class LegacyFlickerServiceDecoratorTest {
             TestWithParameters(
                 "test",
                 TestClass(LegacyFlickerJUnit4ClassRunnerTest.SimpleFaasTest::class.java),
-                listOf(TestUtils.VALID_ARGS_EMPTY)
+                listOf(TestUtils.VALID_ARGS_EMPTY),
             )
         val transitionRunner = LegacyFlickerJUnit4ClassRunner(test, TEST_SCENARIO).transitionRunner
         val decorator =
@@ -79,7 +79,7 @@ class LegacyFlickerServiceDecoratorTest {
                 transitionRunner,
                 skipNonBlocking = false,
                 arguments = InstrumentationRegistry.getArguments(),
-                inner = null
+                inner = null,
             )
         val methods =
             decorator.getTestMethods(
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestFactoryTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestFactoryTest.kt
index 98b1069c9..1bde98496 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestFactoryTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestFactoryTest.kt
@@ -54,7 +54,7 @@ class LegacyFlickerTestFactoryTest {
                 Rotation.ROTATION_0,
                 Rotation.ROTATION_90,
                 Rotation.ROTATION_180,
-                Rotation.ROTATION_270
+                Rotation.ROTATION_270,
             )
         val actual = LegacyFlickerTestFactory.rotationTests(supportedRotations = rotations)
         // Should have config for each rotation pair
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestTest.kt
index 145bae34c..2dcd5538f 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/LegacyFlickerTestTest.kt
@@ -62,7 +62,7 @@ class LegacyFlickerTestTest {
             TraceType.SF,
             predicate,
             TestTraces.LayerTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -73,7 +73,7 @@ class LegacyFlickerTestTest {
             TraceType.SF,
             predicate,
             TestTraces.LayerTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -84,7 +84,7 @@ class LegacyFlickerTestTest {
             TraceType.SF,
             predicate,
             TestTraces.LayerTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -120,7 +120,7 @@ class LegacyFlickerTestTest {
             predicate,
             if (android.tracing.Flags.perfettoWmTracing()) TestTraces.WMTrace.FILE
             else TestTraces.LegacyWMTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -132,7 +132,7 @@ class LegacyFlickerTestTest {
             predicate,
             if (android.tracing.Flags.perfettoWmTracing()) TestTraces.WMTrace.FILE
             else TestTraces.LegacyWMTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -144,7 +144,7 @@ class LegacyFlickerTestTest {
             predicate,
             if (android.tracing.Flags.perfettoWmTracing()) TestTraces.WMTrace.FILE
             else TestTraces.LegacyWMTrace.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -153,7 +153,7 @@ class LegacyFlickerTestTest {
         val predicate: (FlickerTest) -> Unit = { it.assertWm { executionCount++ } }
         doExecuteAssertionWithoutTraceAndVerifyNotExecuted(
             if (android.tracing.Flags.perfettoWmTracing()) TraceType.PERFETTO else TraceType.WM,
-            predicate
+            predicate,
         )
     }
 
@@ -162,7 +162,7 @@ class LegacyFlickerTestTest {
         val predicate: (FlickerTest) -> Unit = { it.assertWmStart { executionCount++ } }
         doExecuteAssertionWithoutTraceAndVerifyNotExecuted(
             if (android.tracing.Flags.perfettoWmTracing()) TraceType.PERFETTO else TraceType.WM,
-            predicate
+            predicate,
         )
     }
 
@@ -171,7 +171,7 @@ class LegacyFlickerTestTest {
         val predicate: (FlickerTest) -> Unit = { it.assertWmEnd { executionCount++ } }
         doExecuteAssertionWithoutTraceAndVerifyNotExecuted(
             if (android.tracing.Flags.perfettoWmTracing()) TraceType.PERFETTO else TraceType.WM,
-            predicate
+            predicate,
         )
     }
 
@@ -183,7 +183,7 @@ class LegacyFlickerTestTest {
             predicate,
             if (android.tracing.Flags.perfettoWmTracing()) TestTraces.WMTrace.FILE
             else TestTraces.LegacyWMTrace.FILE,
-            expectedExecutionCount = 0
+            expectedExecutionCount = 0,
         )
     }
 
@@ -194,7 +194,7 @@ class LegacyFlickerTestTest {
             TraceType.EVENT_LOG,
             predicate,
             TestTraces.EventLog.FILE,
-            expectedExecutionCount = 2
+            expectedExecutionCount = 2,
         )
     }
 
@@ -216,20 +216,20 @@ class LegacyFlickerTestTest {
 
     private fun doExecuteAssertionWithoutTraceAndVerifyNotExecuted(
         traceType: TraceType,
-        predicate: (FlickerTest) -> Unit
+        predicate: (FlickerTest) -> Unit,
     ) =
         doWriteTraceExecuteAssertionAndVerify(
             traceType,
             predicate,
             file = null,
-            expectedExecutionCount = 0
+            expectedExecutionCount = 0,
         )
 
     private fun doWriteTraceExecuteAssertionAndVerify(
         traceType: TraceType,
         predicate: (FlickerTest) -> Unit,
         file: File?,
-        expectedExecutionCount: Int
+        expectedExecutionCount: Int,
     ) {
         val writer = newTestCachedResultWriter()
         if (file != null) {
@@ -245,8 +245,8 @@ class LegacyFlickerTestTest {
                         reader =
                             ResultReader(
                                 android.tools.flicker.datastore.DataStore.getResult(it),
-                                TRACE_CONFIG_REQUIRE_CHANGES
-                            )
+                                TRACE_CONFIG_REQUIRE_CHANGES,
+                            ),
                     )
                 }
             )
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/SetupTeardownRuleTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/SetupTeardownRuleTest.kt
index 87cdff08b..a9ac6c8bf 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/SetupTeardownRuleTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/SetupTeardownRuleTest.kt
@@ -84,7 +84,7 @@ class SetupTeardownRuleTest {
     companion object {
         private fun createRule(
             setupCommands: List<FlickerTestData.() -> Unit>,
-            teardownCommands: List<FlickerTestData.() -> Unit>
+            teardownCommands: List<FlickerTestData.() -> Unit>,
         ): SetupTeardownRule {
             val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
             val mockedFlicker = Mockito.mock(AbstractFlickerTestData::class.java)
@@ -95,7 +95,7 @@ class SetupTeardownRuleTest {
                 instrumentation,
                 setupCommands,
                 teardownCommands,
-                WindowManagerStateHelper()
+                WindowManagerStateHelper(),
             )
         }
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TraceMonitorRuleTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TraceMonitorRuleTest.kt
index 1e924600f..ea2baf4de 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TraceMonitorRuleTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TraceMonitorRuleTest.kt
@@ -40,10 +40,7 @@ class TraceMonitorRuleTest {
     private val monitorWithExceptionStart =
         createMonitor({ error(Consts.FAILURE) }, { setResultExecutionCount++ })
     private val monitorWithExceptionStop =
-        createMonitor(
-            { startExecutionCount++ },
-            { error(Consts.FAILURE) },
-        )
+        createMonitor({ startExecutionCount++ }, { error(Consts.FAILURE) })
     private val monitorWithoutException =
         createMonitor({ startExecutionCount++ }, { setResultExecutionCount++ })
 
@@ -125,13 +122,13 @@ class TraceMonitorRuleTest {
                 TEST_SCENARIO,
                 WindowManagerStateHelper(),
                 ResultWriter(),
-                instrumentation
+                instrumentation,
             )
         }
 
         private fun createMonitor(
             onStart: () -> Unit,
-            onSetResult: (ResultWriter) -> Unit
+            onSetResult: (ResultWriter) -> Unit,
         ): ITransitionMonitor =
             object : ITransitionMonitor {
                 override fun start() {
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionExecutionRuleTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionExecutionRuleTest.kt
index 8713be57d..e5c006460 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionExecutionRuleTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionExecutionRuleTest.kt
@@ -189,7 +189,7 @@ class TransitionExecutionRuleTest {
 
         private fun createRule(
             commands: List<FlickerTestData.() -> Unit>,
-            writer: ResultWriter = newTestResultWriter()
+            writer: ResultWriter = newTestResultWriter(),
         ): TransitionExecutionRule {
             val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
             val mockedFlicker = Mockito.mock(AbstractFlickerTestData::class.java)
@@ -201,7 +201,7 @@ class TransitionExecutionRuleTest {
                 TEST_SCENARIO,
                 instrumentation,
                 commands,
-                WindowManagerStateHelper()
+                WindowManagerStateHelper(),
             )
         }
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionRunnerTest.kt b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionRunnerTest.kt
index cc8cd3ef5..7139cd908 100644
--- a/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionRunnerTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/legacy/runner/TransitionRunnerTest.kt
@@ -77,7 +77,7 @@ class TransitionRunnerTest {
                 setup = listOf(runSetup),
                 teardown = listOf(runTeardown),
                 transitions = listOf(runTransition),
-                extraMonitor = dummyMonitor
+                extraMonitor = dummyMonitor,
             )
         val result = runner.execute(mockedFlicker, Consts.description(this))
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
@@ -98,7 +98,7 @@ class TransitionRunnerTest {
             createMockedFlicker(
                 setup = listOf(runSetup),
                 teardown = listOf(runTeardown),
-                extraMonitor = dummyMonitor
+                extraMonitor = dummyMonitor,
             )
         val result = runner.execute(mockedFlicker, Consts.description(this))
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
@@ -119,7 +119,7 @@ class TransitionRunnerTest {
                 setup = listOf(runSetup),
                 teardown = listOf(runTeardown),
                 transitions = listOf(throwError),
-                extraMonitor = dummyMonitor
+                extraMonitor = dummyMonitor,
             )
         val result = runner.execute(mockedFlicker, Consts.description(this))
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
@@ -140,7 +140,7 @@ class TransitionRunnerTest {
                 setup = listOf(runSetup, throwError),
                 teardown = listOf(runTeardown),
                 transitions = listOf(runTransition),
-                extraMonitor = dummyMonitor
+                extraMonitor = dummyMonitor,
             )
         val result = runner.execute(mockedFlicker, Consts.description(this))
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
@@ -161,7 +161,7 @@ class TransitionRunnerTest {
                 setup = listOf(runSetup),
                 teardown = listOf(runTeardown, throwError),
                 transitions = listOf(runTransition),
-                extraMonitor = dummyMonitor
+                extraMonitor = dummyMonitor,
             )
         val result = runner.execute(mockedFlicker, Consts.description(this))
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/events/EventLogSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/events/EventLogSubjectTest.kt
index 933f67cc6..9721a9411 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/events/EventLogSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/events/EventLogSubjectTest.kt
@@ -45,7 +45,7 @@ class EventLogSubjectTest {
                                 "test",
                                 0,
                                 "0",
-                                0
+                                0,
                             ),
                             FocusEvent(
                                 Timestamps.from(unixNanos = 0),
@@ -54,7 +54,7 @@ class EventLogSubjectTest {
                                 "test",
                                 0,
                                 "0",
-                                0
+                                0,
                             ),
                             FocusEvent(
                                 Timestamps.from(unixNanos = 0),
@@ -63,7 +63,7 @@ class EventLogSubjectTest {
                                 "test",
                                 0,
                                 "0",
-                                0
+                                0,
                             ),
                             FocusEvent(
                                 Timestamps.from(unixNanos = 0),
@@ -72,10 +72,10 @@ class EventLogSubjectTest {
                                 "test",
                                 0,
                                 "0",
-                                0
-                            )
+                                0,
+                            ),
                         )
-                    )
+                    ),
             )
         val subjectsParser = SubjectsParser(reader)
 
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
index d3f7e278d..1da678e19 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/surfaceflinger/LayersTraceSubjectTest.kt
@@ -203,7 +203,7 @@ class LayersTraceSubjectTest {
         val launcherComponent =
             ComponentNameMatcher(
                 "com.google.android.apps.nexuslauncher",
-                "com.google.android.apps.nexuslauncher.NexusLauncherActivity#1"
+                "com.google.android.apps.nexuslauncher.NexusLauncherActivity#1",
             )
         LayersTraceSubject(trace, reader)
             .visibleLayersShownMoreThanOneConsecutiveEntry(listOf(launcherComponent))
@@ -338,7 +338,7 @@ class LayersTraceSubjectTest {
             getLayerTraceReaderFromAsset(
                 "layers_trace_snapshotStartingWindowLayerCoversExactlyApp.perfetto-trace",
                 from = Timestamps.from(systemUptimeNanos = 1688243428961872440),
-                to = Timestamps.from(systemUptimeNanos = 1688243432147782644)
+                to = Timestamps.from(systemUptimeNanos = 1688243432147782644),
             )
         val component =
             ComponentNameMatcher(FLICKER_APP_PACKAGE, "$FLICKER_APP_PACKAGE.ImeActivity")
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
index 4cd510bb4..b91ddc922 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerStateSubjectTest.kt
@@ -339,8 +339,8 @@ class WindowManagerStateSubjectTest {
                     KeyguardControllerState.from(
                         isAodShowing = false,
                         isKeyguardShowing = false,
-                        keyguardOccludedStates = mapOf()
-                    )
+                        keyguardOccludedStates = mapOf(),
+                    ),
             )
 
         val mockComponent = ComponentNameMatcher("", "Mock")
@@ -406,7 +406,7 @@ class WindowManagerStateSubjectTest {
         val componentMatcher =
             ComponentNameMatcher(
                 "com.android.server.wm.flicker.testapp",
-                "com.android.server.wm.flicker.testapp.NotificationActivity"
+                "com.android.server.wm.flicker.testapp.NotificationActivity",
             )
         WindowManagerTraceSubject(trace, reader)
             .isAppWindowInvisible(componentMatcher)
diff --git a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
index 74fc7a93c..71b109fcf 100644
--- a/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
+++ b/libraries/flicker/test/src/android/tools/flicker/subject/wm/WindowManagerTraceSubjectTest.kt
@@ -23,6 +23,9 @@ import android.tools.testutils.assertThatErrorContainsDebugInfo
 import android.tools.testutils.assertThrows
 import android.tools.testutils.getWmTraceReaderFromAsset
 import android.tools.traces.component.ComponentNameMatcher
+import android.tools.traces.component.SurfaceViewBackgroundMatcher
+import android.tools.traces.surfaceflinger.Layer
+import android.tools.traces.surfaceflinger.LayerProperties
 import com.google.common.truth.Truth
 import org.junit.Before
 import org.junit.ClassRule
@@ -159,7 +162,7 @@ class WindowManagerTraceSubjectTest {
             .doNotOverlap(
                 ComponentNameMatcher.IME,
                 ComponentNameMatcher.NAV_BAR,
-                TestComponents.IME_ACTIVITY
+                TestComponents.IME_ACTIVITY,
             )
             .forAllEntries()
     }
@@ -214,6 +217,43 @@ class WindowManagerTraceSubjectTest {
             .isEqualTo(1)
     }
 
+    @Test
+    fun testSurfaceViewBackgroundMatcher() {
+        val cameraActivity =
+            "com.google.android.GoogleCamera/" +
+                "com.google.android.apps.camera.legacy.app.activity.main.CameraActivity"
+        val bg =
+            Layer(
+                name = "Background for e46b52e SurfaceView[$cameraActivity]#2064",
+                id = 1,
+                parentId = 3,
+                z = 4,
+                currFrame = 1,
+                properties = LayerProperties.EMPTY,
+            )
+        val sv =
+            Layer(
+                name = "e46b52e SurfaceView[$cameraActivity]#2063",
+                id = 2,
+                parentId = 3,
+                z = 6,
+                currFrame = 1,
+                properties = LayerProperties.EMPTY,
+            )
+
+        Truth.assertWithMessage("SurfaceView background layer match")
+            .that(SurfaceViewBackgroundMatcher().layerMatchesAnyOf(bg))
+            .isTrue()
+
+        Truth.assertWithMessage("SurfaceView layer should not match")
+            .that(SurfaceViewBackgroundMatcher().layerMatchesAnyOf(sv))
+            .isFalse()
+
+        Truth.assertWithMessage("SurfaceView and its background layer match as a set")
+            .that(SurfaceViewBackgroundMatcher().layerMatchesAnyOf(setOf(bg, sv)))
+            .isTrue()
+    }
+
     @Test
     fun exceptionContainsDebugInfo() {
         val error =
@@ -228,18 +268,18 @@ class WindowManagerTraceSubjectTest {
         val reader =
             getWmTraceReaderFromAsset(
                 "quick_switch_to_app_killed_in_background_trace",
-                legacyTrace = true
+                legacyTrace = true,
             )
         val trace = reader.readWmTrace() ?: error("Unable to read WM trace")
         val app1 =
             ComponentNameMatcher(
                 "com.android.server.wm.flicker.testapp",
-                "com.android.server.wm.flicker.testapp.ImeActivity"
+                "com.android.server.wm.flicker.testapp.ImeActivity",
             )
         val app2 =
             ComponentNameMatcher(
                 "com.android.server.wm.flicker.testapp",
-                "com.android.server.wm.flicker.testapp.SimpleActivity"
+                "com.android.server.wm.flicker.testapp.SimpleActivity",
             )
         WindowManagerTraceSubject(trace, reader)
             .isAppWindowVisible(app1)
@@ -259,7 +299,7 @@ class WindowManagerTraceSubjectTest {
         val reader =
             getWmTraceReaderFromAsset(
                 "quick_switch_to_app_killed_in_background_trace",
-                legacyTrace = true
+                legacyTrace = true,
             )
         val trace = reader.readWmTrace() ?: error("Unable to read WM trace")
         val subject =
@@ -267,7 +307,7 @@ class WindowManagerTraceSubjectTest {
         val app =
             ComponentNameMatcher(
                 "com.android.server.wm.flicker.testapp",
-                "com.android.server.wm.flicker.testapp.SimpleActivity"
+                "com.android.server.wm.flicker.testapp.SimpleActivity",
             )
         subject.isAppWindowInvisible(app)
         subject.isAppWindowVisible(ComponentNameMatcher.SNAPSHOT)
diff --git a/libraries/flicker/test/src/android/tools/integration/AssertionErrorTest.kt b/libraries/flicker/test/src/android/tools/integration/AssertionErrorTest.kt
index 3324b9f40..4ed4a2266 100644
--- a/libraries/flicker/test/src/android/tools/integration/AssertionErrorTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/AssertionErrorTest.kt
@@ -33,7 +33,7 @@ import org.junit.Test
 /**
  * Integration tests to ensure assertions fail correctly
  *
- * To run this test: `atest FlickerLibTest:AssertionErrorTest`
+ * To run this test: `atest FlickerLibTestE2e:AssertionErrorTest`
  */
 @FlakyTest(bugId = 362942901)
 class AssertionErrorTest {
@@ -69,7 +69,7 @@ class AssertionErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         Truth.assertWithMessage("Run status")
             .that(reader.runStatus)
@@ -81,7 +81,7 @@ class AssertionErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         val file = File(reader.artifactPath)
         Truth.assertWithMessage("Files exist").that(file.exists()).isTrue()
diff --git a/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt b/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
index a14682cc9..561831cce 100644
--- a/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/FlickerServiceTracesCollectorTest.kt
@@ -41,7 +41,7 @@ import org.junit.runners.MethodSorters
 
 /**
  * Contains [FlickerServiceTracesCollector] tests. To run this test: `atest
- * FlickerLibTest:FlickerServiceTracesCollectorTest`
+ * FlickerLibTestE2e:FlickerServiceTracesCollectorTest`
  */
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 class FlickerServiceTracesCollectorTest {
@@ -115,10 +115,7 @@ class FlickerServiceTracesCollectorTest {
 
     companion object {
         val EXPECTED_TRACES_LAUNCHER_ONLY =
-            mutableListOf(
-                    TraceType.EVENT_LOG.fileName,
-                    TraceType.PERFETTO.fileName,
-                )
+            mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName)
                 .also {
                     if (!android.tracing.Flags.perfettoProtologTracing()) {
                         it.add(TraceType.PROTOLOG.fileName)
@@ -140,13 +137,12 @@ class FlickerServiceTracesCollectorTest {
                 .toList()
 
         val EXPECTED_TRACES_LAUNCHER_FIRST =
-            mutableListOf(
-                    TraceType.WM.fileName,
-                    TraceType.PROTOLOG.fileName,
-                    TraceType.EVENT_LOG.fileName,
-                    TraceType.PERFETTO.fileName,
-                )
+            mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName)
                 .also {
+                    if (!android.tracing.Flags.perfettoProtologTracing()) {
+                        it.add(TraceType.PROTOLOG.fileName)
+                    }
+
                     if (!android.tracing.Flags.perfettoTransitionTracing()) {
                         it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
                         it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
@@ -156,26 +152,32 @@ class FlickerServiceTracesCollectorTest {
                         it.add("${getLauncherPackageName()}_0.vc__view_capture_trace.winscope")
                         it.add("${getSystemUiUidName()}_1.vc__view_capture_trace.winscope")
                     }
+
+                    if (!android.tracing.Flags.perfettoWmTracing()) {
+                        it.add(TraceType.WM.fileName)
+                    }
                 }
                 .toList()
 
         val EXPECTED_TRACES_SYSUI_FIRST =
-            mutableListOf(
-                    TraceType.WM.fileName,
-                    TraceType.PROTOLOG.fileName,
-                    TraceType.EVENT_LOG.fileName,
-                    TraceType.PERFETTO.fileName,
-                )
-                .also {
-                    if (!android.tracing.Flags.perfettoTransitionTracing()) {
-                        it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
-                        it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
-                    }
+            mutableListOf(TraceType.EVENT_LOG.fileName, TraceType.PERFETTO.fileName).also {
+                if (!android.tracing.Flags.perfettoProtologTracing()) {
+                    it.add(TraceType.PROTOLOG.fileName)
+                }
 
-                    if (!android.tracing.Flags.perfettoViewCaptureTracing()) {
-                        it.add("${getSystemUiUidName()}_0.vc__view_capture_trace.winscope")
-                        it.add("${getLauncherPackageName()}_1.vc__view_capture_trace.winscope")
-                    }
+                if (!android.tracing.Flags.perfettoTransitionTracing()) {
+                    it.add(TraceType.LEGACY_WM_TRANSITION.fileName)
+                    it.add(TraceType.LEGACY_SHELL_TRANSITION.fileName)
+                }
+
+                if (!android.tracing.Flags.perfettoViewCaptureTracing()) {
+                    it.add("${getSystemUiUidName()}_0.vc__view_capture_trace.winscope")
+                    it.add("${getLauncherPackageName()}_1.vc__view_capture_trace.winscope")
+                }
+
+                if (!android.tracing.Flags.perfettoWmTracing()) {
+                    it.add(TraceType.WM.fileName)
                 }
+            }
     }
 }
diff --git a/libraries/flicker/test/src/android/tools/integration/FullLegacyRunTest.kt b/libraries/flicker/test/src/android/tools/integration/FullLegacyRunTest.kt
index 6cc2419c1..cb999b84e 100644
--- a/libraries/flicker/test/src/android/tools/integration/FullLegacyRunTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/FullLegacyRunTest.kt
@@ -40,6 +40,12 @@ import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
 
+/**
+ * Contains an integration test running the legacy flicker test using
+ * [FlickerParametersRunnerFactory] with flicker service compatibility enabled.
+ *
+ * To run this test: `atest FlickerLibTestE2e:FullLegacyRunTest`
+ */
 @FlickerServiceCompatible(expectedCujs = ["ENTIRE_TRACE"])
 @RunWith(Parameterized::class)
 @Parameterized.UseParametersRunnerFactory(FlickerParametersRunnerFactory::class)
@@ -155,10 +161,7 @@ class FullLegacyRunTest(private val flicker: LegacyFlickerTest) {
         Truth.assertWithMessage("Expected state").that(expected).isNotNull()
     }
 
-    private fun validateVisibleRegion(
-        actual: RegionSubject?,
-        expected: RegionSubject?,
-    ) {
+    private fun validateVisibleRegion(actual: RegionSubject?, expected: RegionSubject?) {
         Truth.assertWithMessage("Actual visible region").that(actual).isNotNull()
         Truth.assertWithMessage("Expected visible region").that(expected).isNotNull()
         actual?.coversExactly(expected?.region ?: Region())
diff --git a/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt b/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
index 4429d63f5..ff1e82eac 100644
--- a/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/FullServiceRunTest.kt
@@ -47,6 +47,12 @@ import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
 
+/**
+ * Contains an integration test running a flicker service test using
+ * [FlickerServiceJUnit4ClassRunner].
+ *
+ * To run this test: `atest FlickerLibTestE2e:FullServiceRunTest`
+ */
 @RunWith(FlickerServiceJUnit4ClassRunner::class)
 class FullServiceRunTest {
     private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
@@ -89,7 +95,7 @@ class FullServiceRunTest {
                         object : AssertionTemplate("internalWmCheck") {
                             override fun doEvaluate(
                                 scenarioInstance: ScenarioInstance,
-                                flicker: FlickerTest
+                                flicker: FlickerTest,
                             ) {
                                 var trace: WindowManagerTraceSubject? = null
                                 var executionCount = 0
@@ -118,7 +124,7 @@ class FullServiceRunTest {
                                     validateState(this, trace?.first())
                                     validateVisibleRegion(
                                         this.visibleRegion(),
-                                        trace?.first()?.visibleRegion()
+                                        trace?.first()?.visibleRegion(),
                                     )
 
                                     Truth.assertWithMessage("Execution count")
@@ -130,7 +136,7 @@ class FullServiceRunTest {
                                     validateState(this, trace?.last())
                                     validateVisibleRegion(
                                         this.visibleRegion(),
-                                        trace?.last()?.visibleRegion()
+                                        trace?.last()?.visibleRegion(),
                                     )
 
                                     Truth.assertWithMessage("Execution count")
@@ -142,7 +148,7 @@ class FullServiceRunTest {
                         object : AssertionTemplate("internalLayersCheck") {
                             override fun doEvaluate(
                                 scenarioInstance: ScenarioInstance,
-                                flicker: FlickerTest
+                                flicker: FlickerTest,
                             ) {
                                 var trace: LayersTraceSubject? = null
                                 var executionCount = 0
@@ -171,7 +177,7 @@ class FullServiceRunTest {
                                     validateState(this, trace?.first())
                                     validateVisibleRegion(
                                         this.visibleRegion(),
-                                        trace?.first()?.visibleRegion()
+                                        trace?.first()?.visibleRegion(),
                                     )
 
                                     Truth.assertWithMessage("Execution count")
@@ -183,7 +189,7 @@ class FullServiceRunTest {
                                     validateState(this, trace?.last())
                                     validateVisibleRegion(
                                         this.visibleRegion(),
-                                        trace?.last()?.visibleRegion()
+                                        trace?.last()?.visibleRegion(),
                                     )
 
                                     Truth.assertWithMessage("Execution count")
@@ -191,9 +197,9 @@ class FullServiceRunTest {
                                         .isEqualTo(4)
                                 }
                             }
-                        } to AssertionInvocationGroup.BLOCKING
+                        } to AssertionInvocationGroup.BLOCKING,
                     ),
-                enabled = true
+                enabled = true,
             )
 
         private fun validateState(actual: FlickerSubject?, expected: FlickerSubject?) {
@@ -201,10 +207,7 @@ class FullServiceRunTest {
             Truth.assertWithMessage("Expected state").that(expected).isNotNull()
         }
 
-        private fun validateVisibleRegion(
-            actual: RegionSubject?,
-            expected: RegionSubject?,
-        ) {
+        private fun validateVisibleRegion(actual: RegionSubject?, expected: RegionSubject?) {
             Truth.assertWithMessage("Actual visible region").that(actual).isNotNull()
             Truth.assertWithMessage("Expected visible region").that(expected).isNotNull()
             actual?.coversExactly(expected?.region ?: Region())
diff --git a/libraries/flicker/test/src/android/tools/integration/NoErrorTest.kt b/libraries/flicker/test/src/android/tools/integration/NoErrorTest.kt
index 4f50e6b22..0ba0e86db 100644
--- a/libraries/flicker/test/src/android/tools/integration/NoErrorTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/NoErrorTest.kt
@@ -34,9 +34,9 @@ import org.junit.runners.MethodSorters
 import org.mockito.junit.MockitoJUnitRunner
 
 /**
- * Contains an integration test
+ * Contains an integration test that should not trigger an error.
  *
- * To run this test: `atest FlickerLibTest:IntegrationTests`
+ * To run this test: `atest FlickerLibTestE2e:NoErrorTest`
  */
 @RunWith(MockitoJUnitRunner::class)
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
@@ -215,7 +215,7 @@ class NoErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         Truth.assertWithMessage("Run status")
             .that(reader.runStatus)
@@ -227,7 +227,7 @@ class NoErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         val file = File(reader.artifactPath)
         Truth.assertWithMessage("Files exist").that(file.exists()).isTrue()
diff --git a/libraries/flicker/test/src/android/tools/integration/TransitionErrorTest.kt b/libraries/flicker/test/src/android/tools/integration/TransitionErrorTest.kt
index 4a1f94b3b..fe48223a1 100644
--- a/libraries/flicker/test/src/android/tools/integration/TransitionErrorTest.kt
+++ b/libraries/flicker/test/src/android/tools/integration/TransitionErrorTest.kt
@@ -28,6 +28,11 @@ import org.junit.BeforeClass
 import org.junit.ClassRule
 import org.junit.Test
 
+/**
+ * Contains an integration test that triggers a transition error.
+ *
+ * To run this test: `atest FlickerLibTestE2e:TransitionErrorTest`
+ */
 class TransitionErrorTest {
     private var assertionExecuted = false
     private val testParam = LegacyFlickerTest().also { it.initialize(TEST_SCENARIO.testClass) }
@@ -42,7 +47,7 @@ class TransitionErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         Truth.assertWithMessage("Run status").that(reader.runStatus).isEqualTo(RunStatus.RUN_FAILED)
         assertArtifactExists()
@@ -71,7 +76,7 @@ class TransitionErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         Truth.assertWithMessage("Run status").that(reader.runStatus).isEqualTo(RunStatus.RUN_FAILED)
         assertArtifactExists()
@@ -81,7 +86,7 @@ class TransitionErrorTest {
         val reader =
             android.tools.flicker.datastore.CachedResultReader(
                 TEST_SCENARIO,
-                TRACE_CONFIG_REQUIRE_CHANGES
+                TRACE_CONFIG_REQUIRE_CHANGES,
             )
         val file = File(reader.artifactPath)
         Truth.assertWithMessage("Files exist").that(file.exists()).isTrue()
diff --git a/libraries/flicker/utils/Android.bp b/libraries/flicker/utils/Android.bp
index ecd3a65ac..dae7aa40a 100644
--- a/libraries/flicker/utils/Android.bp
+++ b/libraries/flicker/utils/Android.bp
@@ -20,7 +20,10 @@ package {
 
 filegroup {
     name: "flickerlib-helpers-src",
-    srcs: ["src/android/tools/**/helpers/*.kt"],
+    srcs: [
+        "src/android/tools/**/helpers/*.kt",
+        "src/android/tools/**/helpers/*.java",
+    ],
 }
 
 java_library {
diff --git a/libraries/flicker/utils/src/android/tools/Extensions.kt b/libraries/flicker/utils/src/android/tools/Extensions.kt
index f919445d7..88578eb11 100644
--- a/libraries/flicker/utils/src/android/tools/Extensions.kt
+++ b/libraries/flicker/utils/src/android/tools/Extensions.kt
@@ -17,14 +17,15 @@
 package android.tools
 
 import android.os.Trace
+import android.tools.function.Predicate
 
-inline fun <reified T : Any> withCache(newInstancePredicate: () -> T): T =
-    Cache.get(newInstancePredicate())
+inline fun <reified T : Any> withCache(newInstancePredicate: Predicate<T>): T =
+    Cache.get(newInstancePredicate.invoke())
 
-inline fun <T> withTracing(name: String, predicate: () -> T): T =
+fun <T> withTracing(name: String, predicate: Predicate<T>): T =
     try {
         Trace.beginSection(name)
-        predicate()
+        predicate.invoke()
     } finally {
         Trace.endSection()
     }
diff --git a/libraries/flicker/utils/src/android/tools/ICache.kt b/libraries/flicker/utils/src/android/tools/ICache.kt
index 9e8167f52..b6cb815dc 100644
--- a/libraries/flicker/utils/src/android/tools/ICache.kt
+++ b/libraries/flicker/utils/src/android/tools/ICache.kt
@@ -18,8 +18,12 @@ package android.tools
 
 interface ICache {
     data class Backup(val cache: MutableMap<Any, Any>)
+
     fun <T : Any> get(element: T): T
+
     fun clear()
+
     fun backup(): Backup
+
     fun restore(backup: Backup)
 }
diff --git a/libraries/flicker/utils/src/android/tools/NavBar.kt b/libraries/flicker/utils/src/android/tools/NavBar.kt
index 3ecd527b2..4fb1fb762 100644
--- a/libraries/flicker/utils/src/android/tools/NavBar.kt
+++ b/libraries/flicker/utils/src/android/tools/NavBar.kt
@@ -21,6 +21,7 @@ enum class NavBar(val description: String, val value: String) {
     MODE_GESTURAL("GESTURAL_NAV", PlatformConsts.MODE_GESTURAL);
 
     companion object {
+        @JvmStatic
         fun getByValue(value: String) {
             when (value) {
                 PlatformConsts.MODE_3BUTTON -> MODE_3BUTTON
diff --git a/libraries/flicker/utils/src/android/tools/Position.kt b/libraries/flicker/utils/src/android/tools/Position.kt
index 7d4db3e7b..98db08b58 100644
--- a/libraries/flicker/utils/src/android/tools/Position.kt
+++ b/libraries/flicker/utils/src/android/tools/Position.kt
@@ -21,5 +21,5 @@ enum class Position {
     BOTTOM,
     LEFT,
     RIGHT,
-    INVALID
+    INVALID,
 }
diff --git a/libraries/flicker/utils/src/android/tools/Rotation.kt b/libraries/flicker/utils/src/android/tools/Rotation.kt
index af705a3dc..bcfa5f4c2 100644
--- a/libraries/flicker/utils/src/android/tools/Rotation.kt
+++ b/libraries/flicker/utils/src/android/tools/Rotation.kt
@@ -31,8 +31,9 @@ enum class Rotation(val description: String, val value: Int) {
     companion object {
         private val VALUES = values()
 
-        fun getByValue(value: Int) = if (value == -1) ROTATION_0 else VALUES[value]
+        @JvmStatic fun getByValue(value: Int) = if (value == -1) ROTATION_0 else VALUES[value]
 
+        @JvmStatic
         fun getByName(name: String?): Rotation? = Rotation.values().find { it.name == name }
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/ScenarioBuilder.kt b/libraries/flicker/utils/src/android/tools/ScenarioBuilder.kt
index 95b829566..e6a697ac6 100644
--- a/libraries/flicker/utils/src/android/tools/ScenarioBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/ScenarioBuilder.kt
@@ -57,7 +57,7 @@ class ScenarioBuilder {
             endRotation,
             navBarMode,
             extraConfig,
-            description
+            description,
         )
     }
 
@@ -69,7 +69,7 @@ class ScenarioBuilder {
             navBarMode = DEFAULT_NAVBAR_MODE,
             config = emptyMap(),
             description =
-                defaultDescription(DEFAULT_ROTATION, DEFAULT_ROTATION, DEFAULT_NAVBAR_MODE)
+                defaultDescription(DEFAULT_ROTATION, DEFAULT_ROTATION, DEFAULT_NAVBAR_MODE),
         )
 
     companion object {
@@ -79,7 +79,7 @@ class ScenarioBuilder {
         private fun defaultDescription(
             startOrientation: Rotation,
             endOrientation: Rotation,
-            navBarMode: NavBar
+            navBarMode: NavBar,
         ): String = buildString {
             append(startOrientation.description)
             if (endOrientation != startOrientation) {
diff --git a/libraries/flicker/utils/src/android/tools/ScenarioImpl.kt b/libraries/flicker/utils/src/android/tools/ScenarioImpl.kt
index 905b8854e..8a867ce2a 100644
--- a/libraries/flicker/utils/src/android/tools/ScenarioImpl.kt
+++ b/libraries/flicker/utils/src/android/tools/ScenarioImpl.kt
@@ -36,7 +36,7 @@ internal constructor(
     override val endRotation: Rotation,
     override val navBarMode: NavBar,
     config: Map<String, Any?>,
-    override val description: String
+    override val description: String,
 ) : Scenario {
     private val _extraConfig = config.toMutableMap()
 
@@ -58,7 +58,7 @@ internal constructor(
             if (!extraConfig.containsKey(IS_TABLET)) {
                 Log.e(
                     FLICKER_TAG,
-                    "$IS_TABLET property not initialized. Use [setIsTablet] to initialize"
+                    "$IS_TABLET property not initialized. Use [setIsTablet] to initialize",
                 )
             }
             return extraConfig[IS_TABLET] as Boolean? ?: false
diff --git a/libraries/flicker/utils/src/android/tools/Timestamp.kt b/libraries/flicker/utils/src/android/tools/Timestamp.kt
index c47d03c35..bda8d8010 100644
--- a/libraries/flicker/utils/src/android/tools/Timestamp.kt
+++ b/libraries/flicker/utils/src/android/tools/Timestamp.kt
@@ -30,7 +30,7 @@ internal constructor(
     val elapsedNanos: Long = 0L,
     val systemUptimeNanos: Long = 0L,
     val unixNanos: Long = 0L,
-    private val realTimestampFormatter: (Long) -> String
+    private val realTimestampFormatter: (Long) -> String,
 ) : Comparable<Timestamp> {
     val hasElapsedTimestamp = elapsedNanos != 0L
     val hasSystemUptimeTimestamp = systemUptimeNanos != 0L
@@ -127,7 +127,7 @@ internal constructor(
         ELAPSED,
         SYSTEM_UPTIME,
         UNIX,
-        ANY
+        ANY,
     }
 
     // The preferred and most accurate time type to use when running Timestamp operations or
@@ -188,6 +188,7 @@ internal constructor(
     }
 
     companion object {
+        @JvmStatic
         fun formatElapsedTimestamp(timestampNs: Long): String {
             var remainingNs = timestampNs
             val prettyTimestamp = StringBuilder()
diff --git a/libraries/flicker/utils/src/android/tools/TimestampFactory.kt b/libraries/flicker/utils/src/android/tools/TimestampFactory.kt
index cbb1d7f84..04f77c628 100644
--- a/libraries/flicker/utils/src/android/tools/TimestampFactory.kt
+++ b/libraries/flicker/utils/src/android/tools/TimestampFactory.kt
@@ -24,7 +24,9 @@ class TimestampFactory(private val realTimestampFormatter: (Long) -> String = {
     }
 
     fun min(): Timestamp = min
+
     fun max(): Timestamp = max
+
     fun empty(): Timestamp = empty
 
     fun from(
@@ -36,7 +38,7 @@ class TimestampFactory(private val realTimestampFormatter: (Long) -> String = {
             elapsedNanos ?: 0L,
             systemUptimeNanos ?: 0L,
             unixNanos ?: 0L,
-            realTimestampFormatter
+            realTimestampFormatter,
         )
     }
 
@@ -48,7 +50,7 @@ class TimestampFactory(private val realTimestampFormatter: (Long) -> String = {
         return from(
             (elapsedNanos ?: "0").toLong(),
             (systemUptimeNanos ?: "0").toLong(),
-            (unixNanos ?: "0").toLong()
+            (unixNanos ?: "0").toLong(),
         )
     }
 
@@ -56,7 +58,7 @@ class TimestampFactory(private val realTimestampFormatter: (Long) -> String = {
         return Timestamp(
             elapsedNanos = elapsedNanos,
             unixNanos = elapsedNanos + elapsedOffsetNanos,
-            realTimestampFormatter = realTimestampFormatter
+            realTimestampFormatter = realTimestampFormatter,
         )
     }
 
@@ -64,7 +66,7 @@ class TimestampFactory(private val realTimestampFormatter: (Long) -> String = {
         val elapsedNanosLong = elapsedNanos.toLong()
         return from(
             elapsedNanos = elapsedNanosLong,
-            unixNanos = elapsedNanosLong + elapsedOffsetNanos.toLong()
+            unixNanos = elapsedNanosLong + elapsedOffsetNanos.toLong(),
         )
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/datatypes/ActiveBuffer.kt b/libraries/flicker/utils/src/android/tools/datatypes/ActiveBuffer.kt
index 590db5fc0..61aef3629 100644
--- a/libraries/flicker/utils/src/android/tools/datatypes/ActiveBuffer.kt
+++ b/libraries/flicker/utils/src/android/tools/datatypes/ActiveBuffer.kt
@@ -30,6 +30,8 @@ class ActiveBuffer private constructor(width: Int, height: Int, val stride: Int,
     companion object {
         val EMPTY: ActiveBuffer
             get() = withCache { ActiveBuffer(width = 0, height = 0, stride = 0, format = 0) }
+
+        @JvmStatic
         fun from(width: Int, height: Int, stride: Int, format: Int): ActiveBuffer = withCache {
             ActiveBuffer(width, height, stride, format)
         }
diff --git a/libraries/flicker/utils/src/android/tools/datatypes/Matrix33.kt b/libraries/flicker/utils/src/android/tools/datatypes/Matrix33.kt
index 50a388371..211e304d0 100644
--- a/libraries/flicker/utils/src/android/tools/datatypes/Matrix33.kt
+++ b/libraries/flicker/utils/src/android/tools/datatypes/Matrix33.kt
@@ -35,7 +35,7 @@ private constructor(
     val tx: Float = 0F,
     val dsdy: Float,
     val dtdy: Float,
-    val ty: Float = 0F
+    val ty: Float = 0F,
 ) : DataType() {
     override val isEmpty =
         dsdx == 0f && dtdx == 0f && tx == 0f && dsdy == 0f && dtdy == 0f && ty == 0f
@@ -53,29 +53,34 @@ private constructor(
         val EMPTY: Matrix33
             get() = withCache { from(dsdx = 0f, dtdx = 0f, tx = 0f, dsdy = 0f, dtdy = 0f, ty = 0f) }
 
+        @JvmStatic
         fun identity(x: Float, y: Float): Matrix33 = withCache {
             from(dsdx = 1f, dtdx = 0f, x, dsdy = 0f, dtdy = 1f, y)
         }
 
+        @JvmStatic
         fun rot270(x: Float, y: Float): Matrix33 = withCache {
             from(dsdx = 0f, dtdx = -1f, x, dsdy = 1f, dtdy = 0f, y)
         }
 
+        @JvmStatic
         fun rot180(x: Float, y: Float): Matrix33 = withCache {
             from(dsdx = -1f, dtdx = 0f, x, dsdy = 0f, dtdy = -1f, y)
         }
 
+        @JvmStatic
         fun rot90(x: Float, y: Float): Matrix33 = withCache {
             from(dsdx = 0f, dtdx = 1f, x, dsdy = -1f, dtdy = 0f, y)
         }
 
+        @JvmStatic
         fun from(
             dsdx: Float,
             dtdx: Float,
             tx: Float,
             dsdy: Float,
             dtdy: Float,
-            ty: Float
+            ty: Float,
         ): Matrix33 = withCache { Matrix33(dsdx, dtdx, tx, dsdy, dtdy, ty) }
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/datatypes/Size.kt b/libraries/flicker/utils/src/android/tools/datatypes/Size.kt
index ca55c47d5..836ce261e 100644
--- a/libraries/flicker/utils/src/android/tools/datatypes/Size.kt
+++ b/libraries/flicker/utils/src/android/tools/datatypes/Size.kt
@@ -31,6 +31,7 @@ open class Size protected constructor(val width: Int, val height: Int) : DataTyp
     companion object {
         val EMPTY: Size
             get() = withCache { Size(width = 0, height = 0) }
-        fun from(width: Int, height: Int): Size = withCache { Size(width, height) }
+
+        @JvmStatic fun from(width: Int, height: Int): Size = withCache { Size(width, height) }
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/datatypes/Utils.kt b/libraries/flicker/utils/src/android/tools/datatypes/Utils.kt
index f6d3f6806..70a514fb7 100644
--- a/libraries/flicker/utils/src/android/tools/datatypes/Utils.kt
+++ b/libraries/flicker/utils/src/android/tools/datatypes/Utils.kt
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+@file:JvmName("DataTypeUtils")
+
 package android.tools.datatypes
 
 import android.graphics.Color
diff --git a/libraries/flicker/utils/src/android/tools/device/traces/parsers/WindowManagerStateHelper.kt b/libraries/flicker/utils/src/android/tools/device/traces/parsers/WindowManagerStateHelper.kt
index cc94ad906..36164b2cc 100644
--- a/libraries/flicker/utils/src/android/tools/device/traces/parsers/WindowManagerStateHelper.kt
+++ b/libraries/flicker/utils/src/android/tools/device/traces/parsers/WindowManagerStateHelper.kt
@@ -21,7 +21,7 @@ import androidx.test.platform.app.InstrumentationRegistry
 
 @Deprecated(
     "Please use the version in the android.tools.traces.parsers package instead",
-    replaceWith = ReplaceWith("android.tools.traces.parsers.WindowManagerStateHelper")
+    replaceWith = ReplaceWith("android.tools.traces.parsers.WindowManagerStateHelper"),
 )
 class WindowManagerStateHelper
 @JvmOverloads
diff --git a/libraries/flicker/utils/src/android/tools/function/Predicate.kt b/libraries/flicker/utils/src/android/tools/function/Predicate.kt
new file mode 100644
index 000000000..f7267eb2c
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/function/Predicate.kt
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.function
+
+fun interface Predicate<T> {
+    fun invoke(): T
+}
diff --git a/libraries/flicker/utils/src/android/tools/function/Supplier.kt b/libraries/flicker/utils/src/android/tools/function/Supplier.kt
new file mode 100644
index 000000000..b9da6ea57
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/function/Supplier.kt
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.function
+
+fun interface Supplier<Arg, Return> {
+    fun get(element: Arg): Return
+}
diff --git a/libraries/flicker/utils/src/android/tools/helpers/AutomationUtils.kt b/libraries/flicker/utils/src/android/tools/helpers/AutomationUtils.kt
index 5ca13cff0..a3abb3b06 100644
--- a/libraries/flicker/utils/src/android/tools/helpers/AutomationUtils.kt
+++ b/libraries/flicker/utils/src/android/tools/helpers/AutomationUtils.kt
@@ -158,7 +158,7 @@ fun UiDevice.waitForIME(): Boolean {
 
 private fun openQuickStepAndLongPressOverviewIcon(
     device: UiDevice,
-    wmHelper: WindowManagerStateHelper
+    wmHelper: WindowManagerStateHelper,
 ) {
     if (device.isQuickstepEnabled()) {
         device.openQuickstep(wmHelper)
@@ -191,7 +191,7 @@ fun UiDevice.openQuickStepAndClearRecentAppsFromOverview(wmHelper: WindowManager
             this.displayHeight / 2,
             this.displayWidth,
             this.displayHeight / 2,
-            5
+            5,
         )
         // If "Clear all"  button appears, use it
         val clearAllSelector = By.res(this.launcherPackageName, "clear_all")
@@ -313,7 +313,7 @@ fun UiDevice.resizeSplitScreen(windowHeightRatio: Rational) {
         divider.visibleBounds.centerY(),
         this.displayWidth / 2,
         destHeight,
-        10
+        10,
     )
     this.wait(Until.findObject(dividerSelector), FIND_TIMEOUT)
     // Wait for animation to complete.
diff --git a/libraries/flicker/utils/src/android/tools/helpers/GestureHelper.java b/libraries/flicker/utils/src/android/tools/helpers/GestureHelper.java
new file mode 100644
index 000000000..4b04060cb
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/helpers/GestureHelper.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.helpers;
+
+import android.annotation.NonNull;
+import android.app.Instrumentation;
+import android.app.UiAutomation;
+import android.os.SystemClock;
+import android.view.InputDevice;
+import android.view.InputEvent;
+import android.view.MotionEvent;
+import android.view.MotionEvent.PointerCoords;
+import android.view.MotionEvent.PointerProperties;
+
+import androidx.annotation.Nullable;
+
+/** Injects gestures given an {@link Instrumentation} object. */
+public class GestureHelper {
+    // Inserted after each motion event injection.
+    private static final int MOTION_EVENT_INJECTION_DELAY_MILLIS = 5;
+
+    private final UiAutomation mUiAutomation;
+
+    /** Primary pointer should be cached here for separate release */
+    @Nullable private PointerProperties mPrimaryPtrProp;
+
+    @Nullable private PointerCoords mPrimaryPtrCoord;
+    private long mPrimaryPtrDownTime;
+
+    /** A pair of floating point values. */
+    public static class Tuple {
+        public float x;
+        public float y;
+
+        public Tuple(float x, float y) {
+            this.x = x;
+            this.y = y;
+        }
+    }
+
+    public GestureHelper(Instrumentation instrumentation) {
+        mUiAutomation = instrumentation.getUiAutomation();
+    }
+
+    /**
+     * Injects a series of {@link MotionEvent}s to simulate tapping.
+     *
+     * @param point coordinates of pointer to tap
+     * @param times the number of times to tap
+     */
+    public boolean tap(@NonNull Tuple point, int times) throws InterruptedException {
+        PointerProperties ptrProp = getPointerProp(0, MotionEvent.TOOL_TYPE_FINGER);
+        PointerCoords ptrCoord = getPointerCoord(point.x, point.y, 1, 1);
+
+        for (int i = 0; i <= times; i++) {
+            // If already tapped, inject delay in between movements
+            if (times > 0) {
+                SystemClock.sleep(50L);
+            }
+            if (!primaryPointerDown(ptrProp, ptrCoord, SystemClock.uptimeMillis())) {
+                return false;
+            }
+            // Delay before releasing tap
+            SystemClock.sleep(100L);
+            if (!primaryPointerUp(ptrProp, ptrCoord, SystemClock.uptimeMillis())) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Injects a series of {@link MotionEvent}s to simulate a drag gesture without pointer release.
+     *
+     * <p>Simulates a drag gesture without releasing the primary pointer. The primary pointer info
+     * will be cached for potential release later on by {@code releasePrimaryPointer()}
+     *
+     * @param startPoint initial coordinates of the primary pointer
+     * @param endPoint final coordinates of the primary pointer
+     * @param steps number of steps to take to animate dragging
+     * @return true if gesture is injected successfully
+     */
+    public boolean dragWithoutRelease(
+            @NonNull Tuple startPoint, @NonNull Tuple endPoint, int steps) {
+        PointerProperties ptrProp = getPointerProp(0, MotionEvent.TOOL_TYPE_FINGER);
+        PointerCoords ptrCoord = getPointerCoord(startPoint.x, startPoint.y, 1, 1);
+
+        PointerProperties[] ptrProps = new PointerProperties[] {ptrProp};
+        PointerCoords[] ptrCoords = new PointerCoords[] {ptrCoord};
+
+        long downTime = SystemClock.uptimeMillis();
+
+        if (!primaryPointerDown(ptrProp, ptrCoord, downTime)) {
+            return false;
+        }
+
+        // cache the primary pointer info for later potential release
+        mPrimaryPtrProp = ptrProp;
+        mPrimaryPtrCoord = ptrCoord;
+        mPrimaryPtrDownTime = downTime;
+
+        return movePointers(ptrProps, ptrCoords, new Tuple[] {endPoint}, downTime, steps);
+    }
+
+    /**
+     * Release primary pointer if previous gesture has cached the primary pointer info.
+     *
+     * @return true if the release was injected successfully
+     */
+    public boolean releasePrimaryPointer() {
+        if (mPrimaryPtrProp != null && mPrimaryPtrCoord != null) {
+            return primaryPointerUp(mPrimaryPtrProp, mPrimaryPtrCoord, mPrimaryPtrDownTime);
+        }
+
+        return false;
+    }
+
+    /**
+     * Injects a series of {@link MotionEvent} objects to simulate a pinch gesture.
+     *
+     * @param startPoint1 initial coordinates of the first pointer
+     * @param startPoint2 initial coordinates of the second pointer
+     * @param endPoint1 final coordinates of the first pointer
+     * @param endPoint2 final coordinates of the second pointer
+     * @param steps number of steps to take to animate pinching
+     * @return true if gesture is injected successfully
+     */
+    public boolean pinch(
+            @NonNull Tuple startPoint1,
+            @NonNull Tuple startPoint2,
+            @NonNull Tuple endPoint1,
+            @NonNull Tuple endPoint2,
+            int steps) {
+        PointerProperties ptrProp1 = getPointerProp(0, MotionEvent.TOOL_TYPE_FINGER);
+        PointerProperties ptrProp2 = getPointerProp(1, MotionEvent.TOOL_TYPE_FINGER);
+
+        PointerCoords ptrCoord1 = getPointerCoord(startPoint1.x, startPoint1.y, 1, 1);
+        PointerCoords ptrCoord2 = getPointerCoord(startPoint2.x, startPoint2.y, 1, 1);
+
+        PointerProperties[] ptrProps = new PointerProperties[] {ptrProp1, ptrProp2};
+
+        PointerCoords[] ptrCoords = new PointerCoords[] {ptrCoord1, ptrCoord2};
+
+        long downTime = SystemClock.uptimeMillis();
+
+        if (!primaryPointerDown(ptrProp1, ptrCoord1, downTime)) {
+            return false;
+        }
+
+        if (!nonPrimaryPointerDown(ptrProps, ptrCoords, downTime, 1)) {
+            return false;
+        }
+
+        if (!movePointers(
+                ptrProps, ptrCoords, new Tuple[] {endPoint1, endPoint2}, downTime, steps)) {
+            return false;
+        }
+
+        if (!nonPrimaryPointerUp(ptrProps, ptrCoords, downTime, 1)) {
+            return false;
+        }
+
+        return primaryPointerUp(ptrProp1, ptrCoord1, downTime);
+    }
+
+    private boolean primaryPointerDown(
+            @NonNull PointerProperties prop, @NonNull PointerCoords coord, long downTime) {
+        MotionEvent event =
+                getMotionEvent(
+                        downTime,
+                        downTime,
+                        MotionEvent.ACTION_DOWN,
+                        1,
+                        new PointerProperties[] {prop},
+                        new PointerCoords[] {coord});
+
+        return injectEventSync(event);
+    }
+
+    private boolean nonPrimaryPointerDown(
+            @NonNull PointerProperties[] props,
+            @NonNull PointerCoords[] coords,
+            long downTime,
+            int index) {
+        // at least 2 pointers are needed
+        if (props.length != coords.length || coords.length < 2) {
+            return false;
+        }
+
+        long eventTime = SystemClock.uptimeMillis();
+
+        MotionEvent event =
+                getMotionEvent(
+                        downTime,
+                        eventTime,
+                        MotionEvent.ACTION_POINTER_DOWN
+                                + (index << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
+                        coords.length,
+                        props,
+                        coords);
+
+        return injectEventSync(event);
+    }
+
+    private boolean movePointers(
+            @NonNull PointerProperties[] props,
+            @NonNull PointerCoords[] coords,
+            @NonNull Tuple[] endPoints,
+            long downTime,
+            int steps) {
+        // the number of endpoints should be the same as the number of pointers
+        if (props.length != coords.length || coords.length != endPoints.length) {
+            return false;
+        }
+
+        // prevent division by 0 and negative number of steps
+        if (steps < 1) {
+            steps = 1;
+        }
+
+        // save the starting points before updating any pointers
+        Tuple[] startPoints = new Tuple[coords.length];
+
+        for (int i = 0; i < coords.length; i++) {
+            startPoints[i] = new Tuple(coords[i].x, coords[i].y);
+        }
+
+        MotionEvent event;
+        long eventTime;
+
+        for (int i = 0; i < steps; i++) {
+            // inject a delay between movements
+            SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
+
+            // update the coordinates
+            for (int j = 0; j < coords.length; j++) {
+                coords[j].x += (endPoints[j].x - startPoints[j].x) / steps;
+                coords[j].y += (endPoints[j].y - startPoints[j].y) / steps;
+            }
+
+            eventTime = SystemClock.uptimeMillis();
+
+            event =
+                    getMotionEvent(
+                            downTime,
+                            eventTime,
+                            MotionEvent.ACTION_MOVE,
+                            coords.length,
+                            props,
+                            coords);
+
+            boolean didInject = injectEventSync(event);
+
+            if (!didInject) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean primaryPointerUp(
+            @NonNull PointerProperties prop, @NonNull PointerCoords coord, long downTime) {
+        long eventTime = SystemClock.uptimeMillis();
+
+        MotionEvent event =
+                getMotionEvent(
+                        downTime,
+                        eventTime,
+                        MotionEvent.ACTION_UP,
+                        1,
+                        new PointerProperties[] {prop},
+                        new PointerCoords[] {coord});
+
+        return injectEventSync(event);
+    }
+
+    private boolean nonPrimaryPointerUp(
+            @NonNull PointerProperties[] props,
+            @NonNull PointerCoords[] coords,
+            long downTime,
+            int index) {
+        // at least 2 pointers are needed
+        if (props.length != coords.length || coords.length < 2) {
+            return false;
+        }
+
+        long eventTime = SystemClock.uptimeMillis();
+
+        MotionEvent event =
+                getMotionEvent(
+                        downTime,
+                        eventTime,
+                        MotionEvent.ACTION_POINTER_UP
+                                + (index << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
+                        coords.length,
+                        props,
+                        coords);
+
+        return injectEventSync(event);
+    }
+
+    private PointerCoords getPointerCoord(float x, float y, float pressure, float size) {
+        PointerCoords ptrCoord = new PointerCoords();
+        ptrCoord.x = x;
+        ptrCoord.y = y;
+        ptrCoord.pressure = pressure;
+        ptrCoord.size = size;
+        return ptrCoord;
+    }
+
+    private PointerProperties getPointerProp(int id, int toolType) {
+        PointerProperties ptrProp = new PointerProperties();
+        ptrProp.id = id;
+        ptrProp.toolType = toolType;
+        return ptrProp;
+    }
+
+    private static MotionEvent getMotionEvent(
+            long downTime,
+            long eventTime,
+            int action,
+            int pointerCount,
+            PointerProperties[] ptrProps,
+            PointerCoords[] ptrCoords) {
+        return MotionEvent.obtain(
+                downTime,
+                eventTime,
+                action,
+                pointerCount,
+                ptrProps,
+                ptrCoords,
+                0,
+                0,
+                1.0f,
+                1.0f,
+                0,
+                0,
+                InputDevice.SOURCE_TOUCHSCREEN,
+                0);
+    }
+
+    private boolean injectEventSync(InputEvent event) {
+        return mUiAutomation.injectInputEvent(event, true);
+    }
+}
diff --git a/libraries/flicker/utils/src/android/tools/helpers/RotationUtils.kt b/libraries/flicker/utils/src/android/tools/helpers/RotationUtils.kt
index 51f40e3c3..752f573b9 100644
--- a/libraries/flicker/utils/src/android/tools/helpers/RotationUtils.kt
+++ b/libraries/flicker/utils/src/android/tools/helpers/RotationUtils.kt
@@ -27,6 +27,7 @@ import android.tools.Rotation
  */
 object RotationUtils {
     /** Rotates an Insets according to the given rotation. */
+    @JvmStatic
     fun rotateInsets(insets: Insets?, rotation: Rotation): Insets {
         if (insets == null || insets === Insets.NONE) {
             return Insets.NONE
@@ -49,11 +50,12 @@ object RotationUtils {
      * oldRotation to newRotation. This assumes that parentBounds is at 0,0 and remains at 0,0 after
      * rotation. The bounds will be at the same physical position in parentBounds.
      */
+    @JvmStatic
     fun rotateBounds(
         inBounds: Rect,
         parentBounds: Rect,
         oldRotation: Rotation,
-        newRotation: Rotation
+        newRotation: Rotation,
     ): Rect = rotateBounds(inBounds, parentBounds, deltaRotation(oldRotation, newRotation))
 
     /**
@@ -61,11 +63,12 @@ object RotationUtils {
      * the parent starts at 0,0 and remains at 0,0 after the rotation. The inOutBounds will remain
      * at the same physical position within the parent.
      */
+    @JvmStatic
     fun rotateBounds(
         inBounds: Rect,
         parentWidth: Int,
         parentHeight: Int,
-        rotation: Rotation
+        rotation: Rotation,
     ): Rect {
         val origLeft = inBounds.left
         val origTop = inBounds.top
@@ -76,21 +79,21 @@ object RotationUtils {
                     /* left */ inBounds.top,
                     /* top */ parentWidth - inBounds.right,
                     /* right */ inBounds.bottom,
-                    /* bottom */ parentWidth - origLeft
+                    /* bottom */ parentWidth - origLeft,
                 )
             Rotation.ROTATION_180 ->
                 Rect(
                     /* left */ parentWidth - inBounds.right,
                     /* right */ parentWidth - origLeft,
                     /* top */ parentHeight - inBounds.bottom,
-                    /* bottom */ parentHeight - origTop
+                    /* bottom */ parentHeight - origTop,
                 )
             Rotation.ROTATION_270 ->
                 Rect(
                     /* left */ parentHeight - inBounds.bottom,
                     /* bottom */ inBounds.right,
                     /* right */ parentHeight - inBounds.top,
-                    /* top */ origLeft
+                    /* top */ origLeft,
                 )
         }
     }
@@ -100,10 +103,12 @@ object RotationUtils {
      * 90-degree counter-clockwise increments. This assumes that parentBounds is at 0,0 and remains
      * at 0,0 after rotation. The bounds will be at the same physical position in parentBounds.
      */
+    @JvmStatic
     fun rotateBounds(inBounds: Rect, parentBounds: Rect, rotation: Rotation): Rect =
         rotateBounds(inBounds, parentBounds.right, parentBounds.bottom, rotation)
 
     /** @return the rotation needed to rotate from oldRotation to newRotation. */
+    @JvmStatic
     fun deltaRotation(oldRotation: Rotation, newRotation: Rotation): Rotation {
         var delta = newRotation.value - oldRotation.value
         if (delta < 0) delta += 4
diff --git a/libraries/flicker/utils/src/android/tools/helpers/WindowUtils.kt b/libraries/flicker/utils/src/android/tools/helpers/WindowUtils.kt
index 1be9d0236..3a0eac518 100644
--- a/libraries/flicker/utils/src/android/tools/helpers/WindowUtils.kt
+++ b/libraries/flicker/utils/src/android/tools/helpers/WindowUtils.kt
@@ -27,8 +27,6 @@ import android.tools.traces.wm.InsetsSource
 import android.util.LruCache
 import android.view.WindowInsets
 import androidx.test.platform.app.InstrumentationRegistry
-import kotlin.math.max
-import kotlin.math.min
 
 object WindowUtils {
 
@@ -66,6 +64,7 @@ object WindowUtils {
      *
      * @param requestedRotation Device rotation
      */
+    @JvmStatic
     fun getDisplayBounds(requestedRotation: Rotation): Rect {
         return displayBoundsCache[requestedRotation]
             ?: let {
@@ -86,22 +85,38 @@ object WindowUtils {
             }
     }
 
-    fun getInsetDisplayBounds(): Rect {
+    @JvmStatic
+    fun getInsetDisplayBounds(requestedRotation: Rotation): Rect {
         val currState = getCurrentStateDump(clearCacheAfterParsing = false)
         val display = currState.wmState.getDefaultDisplay() ?: error("Missing physical display")
 
-        val insetDisplayBounds = Rect(display.displayRect)
+        // check device is rotated, and if so, rotate the returned inset bounds
+        val insetDisplayBounds =
+            with(display.displayRect) {
+                if (displayRotation.isRotated() == requestedRotation.isRotated()) {
+                    Rect(left, top, right, bottom)
+                } else {
+                    Rect(left, top, bottom, right)
+                }
+            }
+
+        // Find visible insets from status bar and navigation bar (equivalent to taskbar)
         display.insetsSourceProviders.forEach {
             val insetsSource: InsetsSource = it.source ?: return@forEach
             val insets: Rect = it.frame ?: return@forEach
             if (!insetsSource.visible) return@forEach
 
             when (insetsSource.type) {
+                // Returned insets are based on the display bounds in its natural orientation,
+                // so we calculate the delta between the insets and display bounds when not rotated,
+                // then apply it to the properly rotated (if necessary) display bounds
                 WindowInsets.Type.statusBars() -> {
-                    insetDisplayBounds.top = max(insetDisplayBounds.top, insets.bottom)
+                    val topDelta = insets.bottom - display.displayRect.top
+                    insetDisplayBounds.top += topDelta
                 }
                 WindowInsets.Type.navigationBars() -> {
-                    insetDisplayBounds.bottom = min(insetDisplayBounds.bottom, insets.top)
+                    val botDelta = display.displayRect.bottom - insets.top
+                    insetDisplayBounds.bottom -= botDelta
                 }
             }
         }
@@ -125,6 +140,7 @@ object WindowUtils {
      *
      * @param display the main display
      */
+    @JvmStatic
     fun getExpectedStatusBarPosition(display: DisplayContent): Region {
         val height = getExpectedStatusBarHeight(display)
         return Region(0, 0, display.displayRect.width(), height)
@@ -135,6 +151,7 @@ object WindowUtils {
      *
      * @param display the main display
      */
+    @JvmStatic
     fun getNavigationBarPosition(display: Display): Region {
         return getNavigationBarPosition(display, isGesturalNavigationEnabled)
     }
@@ -145,6 +162,7 @@ object WindowUtils {
      * @param display the main display
      * @param isGesturalNavigation whether gestural navigation is enabled
      */
+    @JvmStatic
     fun getNavigationBarPosition(display: Display, isGesturalNavigation: Boolean): Region {
         val navBarWidth = getDimensionPixelSize("navigation_bar_width")
         val displayHeight = display.layerStackSpace.height()
@@ -170,6 +188,7 @@ object WindowUtils {
      *
      * @param requestedRotation Device rotation
      */
+    @JvmStatic
     fun estimateNavigationBarPosition(requestedRotation: Rotation): Region {
         val displayBounds = displayBounds
         val displayWidth: Int
@@ -207,12 +226,14 @@ object WindowUtils {
             return resources.getInteger(resourceId) == 2
         }
 
+    @JvmStatic
     fun getDimensionPixelSize(resourceName: String): Int {
         val resourceId = resources.getIdentifier(resourceName, "dimen", "android")
         return resources.getDimensionPixelSize(resourceId)
     }
 
     /** Gets the navigation bar frame height */
+    @JvmStatic
     fun getNavigationBarFrameHeight(rotation: Rotation, isGesturalNavigation: Boolean): Int {
         return if (rotation.isRotated()) {
             if (isGesturalNavigation) {
diff --git a/libraries/flicker/utils/src/android/tools/io/Artifact.kt b/libraries/flicker/utils/src/android/tools/io/Artifact.kt
index e27dea78b..8a94491cc 100644
--- a/libraries/flicker/utils/src/android/tools/io/Artifact.kt
+++ b/libraries/flicker/utils/src/android/tools/io/Artifact.kt
@@ -25,6 +25,10 @@ interface Artifact {
     val stableId: String
 
     fun updateStatus(newStatus: RunStatus)
+
+    /* reads the entire artifact */
+    fun readBytes(): ByteArray
+
     fun readBytes(descriptor: ResultArtifactDescriptor): ByteArray?
 
     /** @return if a file matching [descriptor exists in the artifact */
@@ -32,5 +36,6 @@ interface Artifact {
 
     /** @return the number of files in the artifact */
     fun traceCount(): Int
+
     fun deleteIfExists()
 }
diff --git a/libraries/flicker/utils/src/android/tools/io/Consts.kt b/libraries/flicker/utils/src/android/tools/io/Consts.kt
index 67cf8d524..418b9378a 100644
--- a/libraries/flicker/utils/src/android/tools/io/Consts.kt
+++ b/libraries/flicker/utils/src/android/tools/io/Consts.kt
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+@file:JvmName("IOConsts")
+
 package android.tools.io
 
 import android.tools.FLICKER_TAG
diff --git a/libraries/flicker/utils/src/android/tools/io/ResultArtifactDescriptor.kt b/libraries/flicker/utils/src/android/tools/io/ResultArtifactDescriptor.kt
index 0c73b2726..a630e7d6d 100644
--- a/libraries/flicker/utils/src/android/tools/io/ResultArtifactDescriptor.kt
+++ b/libraries/flicker/utils/src/android/tools/io/ResultArtifactDescriptor.kt
@@ -23,7 +23,7 @@ class ResultArtifactDescriptor(
     /** Trace or dump type */
     val traceType: TraceType,
     /** If the trace/dump is associated with a tag */
-    val tag: String = Tag.ALL
+    val tag: String = Tag.ALL,
 ) {
     private val isTagTrace: Boolean
         get() = tag != Tag.ALL
diff --git a/libraries/flicker/utils/src/android/tools/io/RunStatus.kt b/libraries/flicker/utils/src/android/tools/io/RunStatus.kt
index 161ea4de2..7c5fdb961 100644
--- a/libraries/flicker/utils/src/android/tools/io/RunStatus.kt
+++ b/libraries/flicker/utils/src/android/tools/io/RunStatus.kt
@@ -39,6 +39,7 @@ enum class RunStatus(val prefix: String, val isFailure: Boolean) {
     }
 
     companion object {
+        @JvmStatic
         fun fromFileName(fileName: String): RunStatus? {
             if (!fileName.contains("__")) {
                 return UNDEFINED
diff --git a/libraries/flicker/utils/src/android/tools/parsers/AbstractParser.kt b/libraries/flicker/utils/src/android/tools/parsers/AbstractParser.kt
index 07d92c397..7c4380351 100644
--- a/libraries/flicker/utils/src/android/tools/parsers/AbstractParser.kt
+++ b/libraries/flicker/utils/src/android/tools/parsers/AbstractParser.kt
@@ -22,7 +22,9 @@ import android.tools.Timestamp
 /** Base parser class */
 abstract class AbstractParser<InputTypeTrace, OutputTypeTrace> {
     protected abstract val traceName: String
+
     protected abstract fun doDecodeByteArray(bytes: ByteArray): InputTypeTrace
+
     protected abstract fun doParse(input: InputTypeTrace): OutputTypeTrace
 
     /**
@@ -60,7 +62,7 @@ abstract class AbstractParser<InputTypeTrace, OutputTypeTrace> {
         entries: List<Timestamp>,
         from: Timestamp,
         to: Timestamp,
-        addInitialEntry: Boolean
+        addInitialEntry: Boolean,
     ): Set<Timestamp> {
         require(from <= to) { "`from` must be smaller or equal to `to` but was $from and $to" }
 
diff --git a/libraries/flicker/utils/src/android/tools/parsers/AbstractTraceParser.kt b/libraries/flicker/utils/src/android/tools/parsers/AbstractTraceParser.kt
index fab797f46..2c4da4dc1 100644
--- a/libraries/flicker/utils/src/android/tools/parsers/AbstractTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/parsers/AbstractTraceParser.kt
@@ -23,12 +23,19 @@ import android.tools.withTracing
 
 /** Base trace parser class */
 abstract class AbstractTraceParser<
-    InputTypeTrace, InputTypeEntry, OutputTypeEntry, OutputTypeTrace> :
-    AbstractParser<InputTypeTrace, OutputTypeTrace>() {
+    InputTypeTrace,
+    InputTypeEntry,
+    OutputTypeEntry,
+    OutputTypeTrace,
+> : AbstractParser<InputTypeTrace, OutputTypeTrace>() {
     protected open fun onBeforeParse(input: InputTypeTrace) {}
+
     protected abstract fun getEntries(input: InputTypeTrace): Collection<InputTypeEntry>
+
     protected abstract fun getTimestamp(entry: InputTypeEntry): Timestamp
+
     protected abstract fun doParseEntry(entry: InputTypeEntry): OutputTypeEntry
+
     protected abstract fun createTrace(entries: Collection<OutputTypeEntry>): OutputTypeTrace
 
     open fun shouldParseEntry(entry: InputTypeEntry) = true
@@ -39,7 +46,7 @@ abstract class AbstractTraceParser<
             from = Timestamps.min(),
             to = Timestamps.max(),
             addInitialEntry = true,
-            clearCache = clearCache
+            clearCache = clearCache,
         )
     }
 
@@ -49,7 +56,7 @@ abstract class AbstractTraceParser<
             from = Timestamps.min(),
             to = Timestamps.max(),
             addInitialEntry = true,
-            clearCache = clearCache
+            clearCache = clearCache,
         )
     }
 
@@ -58,7 +65,7 @@ abstract class AbstractTraceParser<
             input,
             from = Timestamps.min(),
             to = Timestamps.max(),
-            addInitialEntry = true
+            addInitialEntry = true,
         )
     }
 
@@ -74,7 +81,7 @@ abstract class AbstractTraceParser<
         input: InputTypeTrace,
         from: Timestamp,
         to: Timestamp,
-        addInitialEntry: Boolean
+        addInitialEntry: Boolean,
     ): OutputTypeTrace {
         onBeforeParse(input)
         val parsedEntries = mutableListOf<OutputTypeEntry>()
@@ -107,7 +114,7 @@ abstract class AbstractTraceParser<
         from: Timestamp,
         to: Timestamp,
         addInitialEntry: Boolean = true,
-        clearCache: Boolean = true
+        clearCache: Boolean = true,
     ): OutputTypeTrace {
         return withTracing("${this::class.simpleName}#parse") {
             try {
@@ -134,7 +141,7 @@ abstract class AbstractTraceParser<
         from: Timestamp,
         to: Timestamp,
         addInitialEntry: Boolean = true,
-        clearCache: Boolean = true
+        clearCache: Boolean = true,
     ): OutputTypeTrace {
         val input = decodeByteArray(bytes)
         return parse(input, from, to, addInitialEntry, clearCache)
diff --git a/libraries/flicker/utils/src/android/tools/parsers/events/EventLogParser.kt b/libraries/flicker/utils/src/android/tools/parsers/events/EventLogParser.kt
index d29fff2a9..7d9615132 100644
--- a/libraries/flicker/utils/src/android/tools/parsers/events/EventLogParser.kt
+++ b/libraries/flicker/utils/src/android/tools/parsers/events/EventLogParser.kt
@@ -63,7 +63,7 @@ class EventLogParser : AbstractParser<Collection<String>, EventLog>() {
         uid: String,
         tid: Int,
         tag: String,
-        eventData: String
+        eventData: String,
     ): Event {
         return when (tag) {
             INPUT_FOCUS_TAG -> {
diff --git a/libraries/flicker/utils/src/android/tools/traces/Condition.kt b/libraries/flicker/utils/src/android/tools/traces/Condition.kt
index dcaa1b6cf..20a27c4a9 100644
--- a/libraries/flicker/utils/src/android/tools/traces/Condition.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/Condition.kt
@@ -16,6 +16,8 @@
 
 package android.tools.traces
 
+import java.util.function.Predicate
+
 /**
  * The utility class to wait a condition with customized options. The default retry policy is 5
  * times with interval 1 second.
@@ -44,17 +46,16 @@ package android.tools.traces
  * @param message The message to show what is waiting for.
  * @param condition If it returns true, that means the condition is satisfied.
  */
-open class Condition<T>(
-    protected open val message: String = "",
-    protected open val condition: (T) -> Boolean
-) {
+open class Condition<T>
+@JvmOverloads
+constructor(protected open val message: String = "", protected open val condition: Predicate<T>) {
     /** @return if [value] satisfies the condition */
     fun isSatisfied(value: T): Boolean {
-        return condition.invoke(value)
+        return condition.test(value)
     }
 
     /** @return the negation of the current assertion */
-    fun negate(): Condition<T> = Condition(message = "!$message") { !this.condition.invoke(it) }
+    fun negate(): Condition<T> = Condition(message = "!$message") { !this.condition.test(it) }
 
     /** @return a formatted message for the passing or failing condition on a state */
     open fun getMessage(value: T): String = "$message(passed=${isSatisfied(value)})"
diff --git a/libraries/flicker/utils/src/android/tools/traces/ConditionList.kt b/libraries/flicker/utils/src/android/tools/traces/ConditionList.kt
index 8bd0c3a93..d5f929b37 100644
--- a/libraries/flicker/utils/src/android/tools/traces/ConditionList.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/ConditionList.kt
@@ -16,6 +16,8 @@
 
 package android.tools.traces
 
+import java.util.function.Predicate
+
 /**
  * The utility class to validate a set of conditions
  *
@@ -37,8 +39,8 @@ class ConditionList<T>(val conditions: List<Condition<T>>) : Condition<T>("", {
             }\n)"
         }
 
-    override val condition: (T) -> Boolean
-        get() = { value -> conditions.all { condition -> condition.isSatisfied(value) } }
+    override val condition: Predicate<T>
+        get() = Predicate { value -> conditions.all { condition -> condition.isSatisfied(value) } }
 
     override fun getMessage(value: T): String {
         return "(\n${
diff --git a/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt b/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
index 3ea36e039..0463d5859 100644
--- a/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/ConditionsFactory.kt
@@ -16,7 +16,11 @@
 
 package android.tools.traces
 
+import android.content.Context
 import android.content.res.Resources
+import android.hardware.devicestate.DeviceState.PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY
+import android.hardware.devicestate.DeviceStateManager
+import android.hardware.devicestate.feature.flags.Flags as DeviceStateManagerFlags
 import android.tools.PlatformConsts
 import android.tools.Rotation
 import android.tools.traces.component.ComponentNameMatcher
@@ -26,7 +30,7 @@ import android.tools.traces.surfaceflinger.Transform
 import android.tools.traces.surfaceflinger.Transform.Companion.isFlagSet
 import android.tools.traces.wm.WindowManagerState
 import android.tools.traces.wm.WindowState
-
+import androidx.test.platform.app.InstrumentationRegistry
 import com.android.wm.shell.Flags
 
 object ConditionsFactory {
@@ -34,14 +38,24 @@ object ConditionsFactory {
     /** Check if this is a phone device instead of a folded foldable. */
     fun isPhoneNavBar(): Boolean {
         val isPhone: Boolean
-        val foldedDeviceStatesId: Int =
-            Resources.getSystem().getIdentifier("config_foldedDeviceStates", "array", "android")
-        isPhone =
-            if (foldedDeviceStatesId != 0) {
-                Resources.getSystem().getIntArray(foldedDeviceStatesId).isEmpty()
-            } else {
-                true
-            }
+        if (DeviceStateManagerFlags.deviceStatePropertyMigration()) {
+            val context = InstrumentationRegistry.getInstrumentation().context
+            val deviceStateManager =
+                context.getSystemService(Context.DEVICE_STATE_SERVICE) as DeviceStateManager?
+            isPhone =
+                deviceStateManager?.supportedDeviceStates?.any {
+                    it.hasProperty(PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY)
+                } ?: true
+        } else {
+            val foldedDeviceStatesId: Int =
+                Resources.getSystem().getIdentifier("config_foldedDeviceStates", "array", "android")
+            isPhone =
+                if (foldedDeviceStatesId != 0) {
+                    Resources.getSystem().getIntArray(foldedDeviceStatesId).isEmpty()
+                } else {
+                    true
+                }
+        }
         return isPhone
     }
 
@@ -62,7 +76,7 @@ object ConditionsFactory {
             listOf(
                 isNavOrTaskBarWindowVisible(),
                 isNavOrTaskBarLayerVisible(),
-                isNavOrTaskBarLayerOpaque()
+                isNavOrTaskBarLayerOpaque(),
             )
         )
 
@@ -222,21 +236,21 @@ object ConditionsFactory {
                 hasRotationCondition,
                 isLayerVisible(ComponentNameMatcher.ROTATION).negate(),
                 isLayerVisible(ComponentNameMatcher.BACK_SURFACE).negate(),
-                hasLayersAnimating().negate()
+                hasLayersAnimating().negate(),
             )
         )
     }
 
     fun isWindowVisible(
         componentMatcher: IComponentMatcher,
-        displayId: Int = 0
+        displayId: Int = 0,
     ): Condition<DeviceStateDump> =
         ConditionList(
             containsActivity(componentMatcher),
             containsWindow(componentMatcher),
             isActivityVisible(componentMatcher),
             isWindowSurfaceShown(componentMatcher),
-            isAppTransitionIdle(displayId)
+            isAppTransitionIdle(displayId),
         )
 
     fun isLayerVisible(componentMatcher: IComponentMatcher): Condition<DeviceStateDump> =
@@ -270,7 +284,7 @@ object ConditionsFactory {
 
     fun isLayerTransformFlagSet(
         componentMatcher: IComponentMatcher,
-        transform: Int
+        transform: Int,
     ): Condition<DeviceStateDump> =
         Condition(
             "isLayerTransformFlagSet[" +
@@ -293,7 +307,7 @@ object ConditionsFactory {
             listOf(
                 isLayerTransformFlagSet(layerId, Transform.SCALE_VAL).negate(),
                 isLayerTransformFlagSet(layerId, Transform.TRANSLATE_VAL).negate(),
-                isLayerTransformFlagSet(layerId, Transform.ROTATE_VAL).negate()
+                isLayerTransformFlagSet(layerId, Transform.ROTATE_VAL).negate(),
             )
         )
 
@@ -309,7 +323,7 @@ object ConditionsFactory {
                 result
             },
             isLayerVisible(ComponentNameMatcher.SNAPSHOT).negate(),
-            isLayerVisible(ComponentNameMatcher.SPLASH_SCREEN).negate()
+            isLayerVisible(ComponentNameMatcher.SPLASH_SCREEN).negate(),
         )
     }
 
@@ -318,8 +332,7 @@ object ConditionsFactory {
             val pipWindow =
                 it.wmState.pinnedWindows.firstOrNull { pinnedWindow ->
                     pinnedWindow.layerId == layerId
-                }
-                    ?: error("Unable to find window with layerId $layerId")
+                } ?: error("Unable to find window with layerId $layerId")
             val windowHeight = pipWindow.frame.height().toFloat()
             val windowWidth = pipWindow.frame.width().toFloat()
 
@@ -341,7 +354,7 @@ object ConditionsFactory {
                 isLayerVisible(ComponentNameMatcher.IME),
                 isLayerOpaque(ComponentNameMatcher.IME),
                 isImeSurfaceShown(),
-                isWindowSurfaceShown(ComponentNameMatcher.IME)
+                isWindowSurfaceShown(ComponentNameMatcher.IME),
             )
         )
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/Consts.kt b/libraries/flicker/utils/src/android/tools/traces/Consts.kt
index 325fe7c50..4cd79d7bf 100644
--- a/libraries/flicker/utils/src/android/tools/traces/Consts.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/Consts.kt
@@ -28,7 +28,7 @@ val TRACE_CONFIG_REQUIRE_CHANGES =
         transitionsTrace =
             TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false),
         transactionsTrace =
-            TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false)
+            TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false),
     )
 
 val SERVICE_TRACE_CONFIG =
@@ -39,5 +39,5 @@ val SERVICE_TRACE_CONFIG =
         transitionsTrace =
             TraceConfig(required = true, allowNoChange = true, usingExistingTraces = false),
         transactionsTrace =
-            TraceConfig(required = true, allowNoChange = true, usingExistingTraces = false)
+            TraceConfig(required = true, allowNoChange = true, usingExistingTraces = false),
     )
diff --git a/libraries/flicker/utils/src/android/tools/traces/DeviceStateDump.kt b/libraries/flicker/utils/src/android/tools/traces/DeviceStateDump.kt
index a3956a2b5..470c6f892 100644
--- a/libraries/flicker/utils/src/android/tools/traces/DeviceStateDump.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/DeviceStateDump.kt
@@ -25,5 +25,5 @@ import android.tools.traces.wm.WindowManagerState
  */
 class DeviceStateDump(
     override val wmState: WindowManagerState,
-    override val layerState: LayerTraceEntry
+    override val layerState: LayerTraceEntry,
 ) : NullableDeviceStateDump(wmState, layerState)
diff --git a/libraries/flicker/utils/src/android/tools/traces/Extensions.kt b/libraries/flicker/utils/src/android/tools/traces/Extensions.kt
index 42bb242dc..69df6d644 100644
--- a/libraries/flicker/utils/src/android/tools/traces/Extensions.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/Extensions.kt
@@ -39,7 +39,7 @@ fun now(): Timestamp {
     return Timestamps.from(
         elapsedNanos = SystemClock.elapsedRealtimeNanos(),
         systemUptimeNanos = SystemClock.uptimeNanos(),
-        unixNanos = now.epochSecond * SECOND_AS_NANOSECONDS + now.nano
+        unixNanos = now.epochSecond * SECOND_AS_NANOSECONDS + now.nano,
     )
 }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/NullableDeviceStateDump.kt b/libraries/flicker/utils/src/android/tools/traces/NullableDeviceStateDump.kt
index 265c0dbd7..837e4475b 100644
--- a/libraries/flicker/utils/src/android/tools/traces/NullableDeviceStateDump.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/NullableDeviceStateDump.kt
@@ -28,5 +28,5 @@ open class NullableDeviceStateDump(
     open val wmState: WindowManagerState?,
 
     /** Parsed [LayerTraceEntry] */
-    open val layerState: LayerTraceEntry?
+    open val layerState: LayerTraceEntry?,
 )
diff --git a/libraries/flicker/utils/src/android/tools/traces/TraceConfig.kt b/libraries/flicker/utils/src/android/tools/traces/TraceConfig.kt
index 25b654b43..72efe575e 100644
--- a/libraries/flicker/utils/src/android/tools/traces/TraceConfig.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/TraceConfig.kt
@@ -19,5 +19,5 @@ package android.tools.traces
 data class TraceConfig(
     var required: Boolean,
     var allowNoChange: Boolean,
-    var usingExistingTraces: Boolean
+    var usingExistingTraces: Boolean,
 )
diff --git a/libraries/flicker/utils/src/android/tools/traces/TraceConfigs.kt b/libraries/flicker/utils/src/android/tools/traces/TraceConfigs.kt
index 2150a2b92..e7dca1711 100644
--- a/libraries/flicker/utils/src/android/tools/traces/TraceConfigs.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/TraceConfigs.kt
@@ -16,16 +16,18 @@
 
 package android.tools.traces
 
+import java.util.function.Consumer
+
 data class TraceConfigs(
     val wmTrace: TraceConfig,
     val layersTrace: TraceConfig,
     val transitionsTrace: TraceConfig,
-    val transactionsTrace: TraceConfig
+    val transactionsTrace: TraceConfig,
 ) {
-    fun applyToAll(function: (TraceConfig) -> Unit) {
-        function(wmTrace)
-        function(layersTrace)
-        function(transitionsTrace)
-        function(transactionsTrace)
+    fun applyToAll(function: Consumer<TraceConfig>) {
+        function.accept(wmTrace)
+        function.accept(layersTrace)
+        function.accept(transitionsTrace)
+        function.accept(transactionsTrace)
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/Utils.kt b/libraries/flicker/utils/src/android/tools/traces/Utils.kt
index deb9e10b3..8e80bad3b 100644
--- a/libraries/flicker/utils/src/android/tools/traces/Utils.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/Utils.kt
@@ -25,6 +25,7 @@ import android.os.Process
 import android.os.SystemClock
 import android.tools.MILLISECOND_AS_NANOSECONDS
 import android.tools.io.TraceType
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.PerfettoTraceMonitor
 import android.tools.traces.parsers.DeviceDumpParser
 import android.tools.traces.surfaceflinger.LayerTraceEntry
@@ -74,7 +75,7 @@ fun executeShellCommand(cmd: String, stdin: ByteArray): ByteArray {
 }
 
 private fun doBinderDump(name: String): ByteArray {
-    // create an fd for the binder transaction
+    // create a fd for the binder transaction
     val pipe = ParcelFileDescriptor.createPipe()
     val source = pipe[0]
     val sink = pipe[1]
@@ -117,25 +118,41 @@ fun getCurrentState(
         throw IllegalArgumentException("Only dump types are supported. Invalid types: $traceTypes")
     }
 
+    val requestedWmDump = dumpTypes.contains(TraceType.WM_DUMP)
+    val requestedSfDump = dumpTypes.contains(TraceType.SF_DUMP)
+
     Log.d(LOG_TAG, "Requesting new device state dump")
-    val wmTraceData =
-        if (dumpTypes.contains(TraceType.WM_DUMP)) {
-            if (android.tracing.Flags.perfettoWmDump()) {
-                PerfettoTraceMonitor.newBuilder().enableWindowManagerDump().build().withTracing {}
-            } else {
-                getCurrentWindowManagerState()
+
+    val perfettoTrace =
+        PerfettoTraceMonitor.newBuilder()
+            .also {
+                if (requestedWmDump && android.tracing.Flags.perfettoWmDump()) {
+                    it.enableWindowManagerDump()
+                }
+
+                if (requestedSfDump) {
+                    it.enableLayersDump()
+                }
             }
+            .build()
+            .withTracing(resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }) {}
+            .readBytes(TraceType.PERFETTO) ?: ByteArray(0)
+
+    val wmDump =
+        if (android.tracing.Flags.perfettoWmDump()) {
+            if (requestedWmDump) perfettoTrace else ByteArray(0)
         } else {
-            ByteArray(0)
-        }
-    val layersTraceData =
-        if (dumpTypes.contains(TraceType.SF_DUMP)) {
-            PerfettoTraceMonitor.newBuilder().enableLayersDump().build().withTracing {}
-        } else {
-            ByteArray(0)
+            if (requestedWmDump) {
+                Log.d(LOG_TAG, "Requesting new legacy WM state dump")
+                getCurrentWindowManagerState()
+            } else {
+                ByteArray(0)
+            }
         }
 
-    return Pair(wmTraceData, layersTraceData)
+    val sfDump = if (requestedSfDump) perfettoTrace else ByteArray(0)
+
+    return Pair(wmDump, sfDump)
 }
 
 /**
diff --git a/libraries/flicker/utils/src/android/tools/traces/WaitCondition.kt b/libraries/flicker/utils/src/android/tools/traces/WaitCondition.kt
index 41f68c960..1b6196380 100644
--- a/libraries/flicker/utils/src/android/tools/traces/WaitCondition.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/WaitCondition.kt
@@ -16,6 +16,11 @@
 
 package android.tools.traces
 
+import java.util.function.BiConsumer
+import java.util.function.Consumer
+import java.util.function.Predicate
+import java.util.function.Supplier
+
 /**
  * The utility class to wait a condition with customized options. The default retry policy is 5
  * times with interval 1 second.
@@ -46,28 +51,28 @@ package android.tools.traces
  */
 class WaitCondition<T>
 private constructor(
-    private val supplier: () -> T,
+    private val supplier: Supplier<T>,
     private val condition: Condition<T>,
     private val retryLimit: Int,
-    private val onLog: ((String, Boolean) -> Unit)?,
-    private val onFailure: ((T) -> Any)?,
-    private val onRetry: ((T) -> Any)?,
-    private val onSuccess: ((T) -> Any)?,
-    private val onStart: ((String) -> Any)?,
-    private val onEnd: (() -> Any)?
+    private val onLog: BiConsumer<String, Boolean>?,
+    private val onFailure: Consumer<T>?,
+    private val onRetry: Consumer<T>?,
+    private val onSuccess: Consumer<T>?,
+    private val onStart: Consumer<String>?,
+    private val onEnd: Consumer<String>?,
 ) {
     /** @return `false` if the condition does not satisfy within the time limit. */
     fun waitFor(): Boolean {
-        onStart?.invoke("waitFor")
+        onStart?.accept("waitFor")
         try {
             return doWaitFor()
         } finally {
-            onEnd?.invoke()
+            onEnd?.accept("done waitFor")
         }
     }
 
     private fun doWaitFor(): Boolean {
-        onLog?.invoke("***Waiting for $condition", false)
+        onLog?.accept("***Waiting for $condition", false)
         var currState: T? = null
         var success = false
         for (i in 0..retryLimit) {
@@ -77,7 +82,7 @@ private constructor(
             if (success) {
                 break
             } else if (i < retryLimit) {
-                onRetry?.invoke(currState)
+                onRetry?.accept(currState)
             }
         }
 
@@ -90,20 +95,20 @@ private constructor(
     }
 
     private fun doWaitForRetry(retryNr: Int): Pair<Boolean, T> {
-        onStart?.invoke("doWaitForRetry")
+        onStart?.accept("doWaitForRetry")
         try {
-            val currState = supplier.invoke()
+            val currState = supplier.get()
             return if (condition.isSatisfied(currState)) {
-                onLog?.invoke("***Waiting for $condition ... Success!", false)
-                onSuccess?.invoke(currState)
+                onLog?.accept("***Waiting for $condition ... Success!", false)
+                onSuccess?.accept(currState)
                 Pair(true, currState)
             } else {
                 val detailedMessage = condition.getMessage(currState)
-                onLog?.invoke("***Waiting for $detailedMessage... retry=${retryNr + 1}", true)
+                onLog?.accept("***Waiting for $detailedMessage... retry=${retryNr + 1}", true)
                 Pair(false, currState)
             }
         } finally {
-            onEnd?.invoke()
+            onEnd?.accept("done doWaitForRetry")
         }
     }
 
@@ -114,25 +119,25 @@ private constructor(
             } else {
                 condition.toString()
             }
-        onLog?.invoke("***Waiting for $detailedMessage ... Failed!", true)
+        onLog?.accept("***Waiting for $detailedMessage ... Failed!", true)
         if (onFailure != null) {
             require(currState != null) { "Missing last result for failure notification" }
-            onFailure.invoke(currState)
+            onFailure.accept(currState)
         }
     }
 
-    class Builder<T>(private val supplier: () -> T, private var retryLimit: Int) {
+    class Builder<T>(private var retryLimit: Int, private val supplier: Supplier<T>) {
         private val conditions = mutableListOf<Condition<T>>()
-        private var onStart: ((String) -> Any)? = null
-        private var onEnd: (() -> Any)? = null
-        private var onFailure: ((T) -> Any)? = null
-        private var onRetry: ((T) -> Any)? = null
-        private var onSuccess: ((T) -> Any)? = null
-        private var onLog: ((String, Boolean) -> Unit)? = null
+        private var onStart: Consumer<String>? = null
+        private var onEnd: Consumer<String>? = null
+        private var onFailure: Consumer<T>? = null
+        private var onRetry: Consumer<T>? = null
+        private var onSuccess: Consumer<T>? = null
+        private var onLog: BiConsumer<String, Boolean>? = null
 
         fun withCondition(condition: Condition<T>) = apply { conditions.add(condition) }
 
-        fun withCondition(message: String, condition: (T) -> Boolean) = apply {
+        fun withCondition(message: String, condition: Predicate<T>) = apply {
             withCondition(Condition(message, condition))
         }
 
@@ -149,21 +154,19 @@ private constructor(
          * Executes the action when the condition does not satisfy within the time limit. The passed
          * object to the consumer will be the last result from the supplier.
          */
-        fun onFailure(onFailure: (T) -> Any): Builder<T> = apply { this.onFailure = onFailure }
+        fun onFailure(onFailure: Consumer<T>): Builder<T> = apply { this.onFailure = onFailure }
 
-        fun onLog(onLog: (String, Boolean) -> Unit): Builder<T> = apply { this.onLog = onLog }
+        fun onLog(onLog: BiConsumer<String, Boolean>): Builder<T> = apply { this.onLog = onLog }
 
-        fun onRetry(onRetry: ((T) -> Any)? = null): Builder<T> = apply { this.onRetry = onRetry }
+        fun onRetry(onRetry: Consumer<T>? = null): Builder<T> = apply { this.onRetry = onRetry }
 
-        fun onStart(onStart: ((String) -> Any)? = null): Builder<T> = apply {
+        fun onStart(onStart: Consumer<String>? = null): Builder<T> = apply {
             this.onStart = onStart
         }
 
-        fun onEnd(onEnd: (() -> Any)? = null): Builder<T> = apply { this.onEnd = onEnd }
+        fun onEnd(onEnd: Consumer<String>? = null): Builder<T> = apply { this.onEnd = onEnd }
 
-        fun onSuccess(onRetry: ((T) -> Any)? = null): Builder<T> = apply {
-            this.onSuccess = onRetry
-        }
+        fun onSuccess(onRetry: Consumer<T>? = null): Builder<T> = apply { this.onSuccess = onRetry }
 
         fun build(): WaitCondition<T> =
             WaitCondition(
@@ -175,7 +178,7 @@ private constructor(
                 onRetry,
                 onSuccess,
                 onStart,
-                onEnd
+                onEnd,
             )
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
index a7016ac3b..d9c7a9a28 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/ComponentNameMatcher.kt
@@ -19,20 +19,25 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 /** ComponentMatcher based on name */
 class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher {
     override val packageName: String
         get() = component.packageName
+
     override val className: String
         get() = component.className
+
     override fun toActivityName(): String = component.toActivityName()
+
     override fun toWindowName(): String = component.toWindowName()
+
     override fun toLayerName(): String = component.toLayerName()
 
     constructor(
         packageName: String,
-        className: String
+        className: String,
     ) : this(ComponentName(packageName, className))
 
     constructor(className: String) : this("", className)
@@ -59,8 +64,8 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
-    ): Boolean = condition(layers.filter { layerMatchesAnyOf(it) })
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { layerMatchesAnyOf(it) })
 
     /** {@inheritDoc} */
     override fun toActivityIdentifier(): String = component.toActivityName()
@@ -94,61 +99,65 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
         get() = { it.contains(component.toLayerName()) }
 
     companion object {
-        val NAV_BAR = ComponentNameMatcher("", "NavigationBar0")
-        val TASK_BAR = ComponentNameMatcher("", "Taskbar")
-        val STATUS_BAR = ComponentNameMatcher("", "StatusBar")
-        val ROTATION = ComponentNameMatcher("", "RotationLayer")
-        val BACK_SURFACE = ComponentNameMatcher("", "BackColorSurface")
-        val IME = ComponentNameMatcher("", "InputMethod")
-        val IME_SNAPSHOT = ComponentNameMatcher("", "IME-snapshot-surface")
-        val SPLASH_SCREEN = ComponentNameMatcher("", "Splash Screen")
-        val SNAPSHOT = ComponentNameMatcher("", "SnapshotStartingWindow")
-        val SECONDARY_HOME_HANDLE = ComponentNameMatcher("", "SecondaryHomeHandle")
+        @JvmField val NAV_BAR = ComponentNameMatcher("", "NavigationBar0")
+        @JvmField val TASK_BAR = ComponentNameMatcher("", "Taskbar")
+        @JvmField val STATUS_BAR = ComponentNameMatcher("", "StatusBar")
+        @JvmField val ROTATION = ComponentNameMatcher("", "RotationLayer")
+        @JvmField val BACK_SURFACE = ComponentNameMatcher("", "BackColorSurface")
+        @JvmField val IME = ComponentNameMatcher("", "InputMethod")
+        @JvmField val IME_SNAPSHOT = ComponentNameMatcher("", "IME-snapshot-surface")
+        @JvmField val SPLASH_SCREEN = ComponentNameMatcher("", "Splash Screen")
+        @JvmField val SNAPSHOT = ComponentNameMatcher("", "SnapshotStartingWindow")
+        @JvmField val SECONDARY_HOME_HANDLE = ComponentNameMatcher("", "SecondaryHomeHandle")
 
-        val TRANSITION_SNAPSHOT = ComponentNameMatcher("", "transition snapshot")
-        val LETTERBOX = ComponentNameMatcher("", "Letterbox")
+        @JvmField val TRANSITION_SNAPSHOT = ComponentNameMatcher("", "transition snapshot")
+        @JvmField val LETTERBOX = ComponentNameMatcher("", "Letterbox")
 
-        val WALLPAPER_BBQ_WRAPPER = ComponentNameMatcher("", "Wallpaper BBQ wrapper")
+        @JvmField val WALLPAPER_BBQ_WRAPPER = ComponentNameMatcher("", "Wallpaper BBQ wrapper")
 
-        val PIP_CONTENT_OVERLAY = ComponentNameMatcher("", "PipContentOverlay")
+        @JvmField val PIP_CONTENT_OVERLAY = ComponentNameMatcher("", "PipContentOverlay")
 
-        val PIP_MENU_OVERLAY = ComponentNameMatcher("", "PipMenuView")
+        @JvmField val PIP_MENU_OVERLAY = ComponentNameMatcher("", "PipMenuView")
 
+        @JvmField
         val EDGE_BACK_GESTURE_HANDLER = ComponentNameMatcher("", "EdgeBackGestureHandler0")
 
-        val COLOR_FADE = ComponentNameMatcher("", "ColorFade")
+        @JvmField val COLOR_FADE = ComponentNameMatcher("", "ColorFade")
 
-        val WALLPAPER_WINDOW_TOKEN = ComponentNameMatcher("", "WallpaperWindowToken")
+        @JvmField val WALLPAPER_WINDOW_TOKEN = ComponentNameMatcher("", "WallpaperWindowToken")
 
-        val NOTIFICATION_SHADE = ComponentNameMatcher("", "NotificationShade")
+        @JvmField val NOTIFICATION_SHADE = ComponentNameMatcher("", "NotificationShade")
 
-        val VOLUME_DIALOG = ComponentNameMatcher("", "VolumeDialog")
+        @JvmField val VOLUME_DIALOG = ComponentNameMatcher("", "VolumeDialog")
 
-        val FLOATING_ROTATION_BUTTON = ComponentNameMatcher("", "FloatingRotationButton")
+        @JvmField val FLOATING_ROTATION_BUTTON = ComponentNameMatcher("", "FloatingRotationButton")
 
-        val SCREEN_DECOR_OVERLAY = ComponentNameMatcher("", "ScreenDecorHwcOverlay#")
+        @JvmField val SCREEN_DECOR_OVERLAY = ComponentNameMatcher("", "ScreenDecorHwcOverlay#")
 
-        val POINTER_LOCATION = ComponentNameMatcher("", "PointerLocation")
+        @JvmField val POINTER_LOCATION = ComponentNameMatcher("", "PointerLocation")
 
+        @JvmField
         val WIRED_CHARGING_ANIMATION = ComponentNameMatcher("", "Wired Charging Animation#")
 
-        val SCREEN_RECORDING_OVERLAYS = SCREEN_DECOR_OVERLAY.or(POINTER_LOCATION)
+        @JvmField val SCREEN_RECORDING_OVERLAYS = SCREEN_DECOR_OVERLAY.or(POINTER_LOCATION)
 
+        @JvmField
         val LAUNCHER =
             ComponentNameMatcher(
                 "com.google.android.apps.nexuslauncher",
-                "com.google.android.apps.nexuslauncher.NexusLauncherActivity"
+                "com.google.android.apps.nexuslauncher.NexusLauncherActivity",
             )
 
+        @JvmField
         val AOSP_LAUNCHER =
             ComponentNameMatcher(
                 "com.android.launcher3",
-                "com.android.launcher3.uioverrides.QuickstepLauncher"
+                "com.android.launcher3.uioverrides.QuickstepLauncher",
             )
 
-        val SPLIT_DIVIDER = ComponentNameMatcher("", "StageCoordinatorSplitDivider")
+        @JvmField val SPLIT_DIVIDER = ComponentNameMatcher("", "StageCoordinatorSplitDivider")
 
-        val DEFAULT_TASK_DISPLAY_AREA = ComponentNameMatcher("", "DefaultTaskDisplayArea")
+        @JvmField val DEFAULT_TASK_DISPLAY_AREA = ComponentNameMatcher("", "DefaultTaskDisplayArea")
 
         /**
          * Creates a component matcher from a window or layer name.
@@ -157,6 +166,7 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
          *
          * @param str Value to parse
          */
+        @JvmStatic
         fun unflattenFromString(str: String): ComponentNameMatcher {
             val sep = str.indexOf('/')
             if (sep < 0 || sep + 1 >= str.length) {
@@ -179,6 +189,7 @@ class ComponentNameMatcher(var component: ComponentName) : IComponentNameMatcher
          *
          * @param str Value to parse
          */
+        @JvmStatic
         fun unflattenFromStringWithJunk(str: String): ComponentNameMatcher {
             val sep = str.indexOf('/')
             if (sep < 0 || sep + 1 >= str.length) {
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/ComponentRegexMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/ComponentRegexMatcher.kt
index fdce49743..4da5c07cf 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/ComponentRegexMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/ComponentRegexMatcher.kt
@@ -19,14 +19,12 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 /** ComponentMatcher based on a regular expression for a name */
-data class ComponentRegexMatcher(
-    private val regex: Regex
-) : IComponentMatcher {
+data class ComponentRegexMatcher(private val regex: Regex) : IComponentMatcher {
 
-    private val identifierDescription: String =
-        "Regular expression: $regex"
+    private val identifierDescription: String = "Regular expression: $regex"
 
     /** {@inheritDoc} */
     override fun windowMatchesAnyOf(windows: Collection<WindowContainer>): Boolean =
@@ -43,8 +41,8 @@ data class ComponentRegexMatcher(
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
-    ): Boolean = condition(layers.filter { layerMatchesAnyOf(it) })
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { layerMatchesAnyOf(it) })
 
     /** {@inheritDoc} */
     override fun toActivityIdentifier(): String = identifierDescription
@@ -56,9 +54,8 @@ data class ComponentRegexMatcher(
     override fun toLayerIdentifier(): String = identifierDescription
 
     companion object {
+        @JvmField
         val FOLD_OVERLAY_MATCHER =
-            ComponentRegexMatcher(
-                regex = "^fold-animation-overlay.*".toRegex()
-            )
+            ComponentRegexMatcher(regex = "^fold-animation-overlay.*".toRegex())
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/ComponentSplashScreenMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/ComponentSplashScreenMatcher.kt
index 1501cd4f9..abb1adcd9 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/ComponentSplashScreenMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/ComponentSplashScreenMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 class ComponentSplashScreenMatcher(val componentNameMatcher: IComponentNameMatcher) :
     IComponentMatcher {
@@ -68,12 +69,12 @@ class ComponentSplashScreenMatcher(val componentNameMatcher: IComponentNameMatch
 
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
+        condition: Predicate<Collection<Layer>>,
     ): Boolean {
         val splashScreenLayer = layers.filter { layerMatchesAnyOf(it) }
         require(splashScreenLayer.size <= 1) {
             "More than on SplashScreen layer found. Only up to 1 match was expected."
         }
-        return condition(splashScreenLayer)
+        return condition.test(splashScreenLayer)
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/EdgeExtensionComponentMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/EdgeExtensionComponentMatcher.kt
index 02eaaca51..82b2c26e8 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/EdgeExtensionComponentMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/EdgeExtensionComponentMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 class EdgeExtensionComponentMatcher : IComponentMatcher {
     /** {@inheritDoc} */
@@ -49,8 +50,8 @@ class EdgeExtensionComponentMatcher : IComponentMatcher {
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
-    ): Boolean = condition(layers.filter { layerMatchesAnyOf(it) })
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { layerMatchesAnyOf(it) })
 
     /** {@inheritDoc} */
     override fun toActivityIdentifier(): String {
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/ExactComponentIdMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/ExactComponentIdMatcher.kt
index 0d993ca53..0e2fa7d22 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/ExactComponentIdMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/ExactComponentIdMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 /**
  * A component matcher that matches the targeted window and layer with ids windowId and layerId
@@ -52,8 +53,8 @@ class ExactComponentIdMatcher(private val windowId: Int, private val layerId: In
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
-    ): Boolean = condition(layers.filter { it.id == layerId })
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { it.id == layerId })
 
     /** {@inheritDoc} */
     override fun toActivityIdentifier() = toWindowIdentifier()
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
index eb38ae6c0..eed2f9a44 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/FullComponentIdMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 /**
  * A component matcher that matches the targeted window and layer with ids windowId and layerId
@@ -66,8 +67,8 @@ class FullComponentIdMatcher(val windowId: Int, val layerId: Int) : IComponentMa
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
-    ): Boolean = condition(layers.filter { layerMatchesAnyOf(it) })
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { layerMatchesAnyOf(it) })
 
     /** {@inheritDoc} */
     override fun toActivityIdentifier() = toWindowIdentifier()
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/IComponentMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/IComponentMatcher.kt
index 2794bcf43..27ff73916 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/IComponentMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/IComponentMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 interface IComponentMatcher {
     fun or(other: IComponentMatcher): IComponentMatcher {
@@ -103,7 +104,7 @@ interface IComponentMatcher {
      *         defined execution of it.
      * ```
      */
-    fun check(layers: Collection<Layer>, condition: (Collection<Layer>) -> Boolean): Boolean
+    fun check(layers: Collection<Layer>, condition: Predicate<Collection<Layer>>): Boolean
 
     fun filterLayers(layers: Collection<Layer>): Collection<Layer> =
         layers.filter { layerMatchesAnyOf(it) }
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/IComponentName.kt b/libraries/flicker/utils/src/android/tools/traces/component/IComponentName.kt
index 704930a69..0ead95ca8 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/IComponentName.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/IComponentName.kt
@@ -18,7 +18,13 @@ package android.tools.traces.component
 interface IComponentName {
     val packageName: String
     val className: String
+
     fun toActivityName(): String
+
     fun toWindowName(): String
+
     fun toLayerName(): String
+
+    val packageNameMatcher: ComponentNameMatcher
+        get() = ComponentNameMatcher(packageName, "")
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/OrComponentMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/OrComponentMatcher.kt
index b2b469b6f..33cfd6886 100644
--- a/libraries/flicker/utils/src/android/tools/traces/component/OrComponentMatcher.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/component/OrComponentMatcher.kt
@@ -19,6 +19,7 @@ package android.tools.traces.component
 import android.tools.traces.surfaceflinger.Layer
 import android.tools.traces.wm.Activity
 import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
 
 class OrComponentMatcher(private val componentMatchers: Collection<IComponentMatcher>) :
     IComponentMatcher {
@@ -56,10 +57,10 @@ class OrComponentMatcher(private val componentMatchers: Collection<IComponentMat
     /** {@inheritDoc} */
     override fun check(
         layers: Collection<Layer>,
-        condition: (Collection<Layer>) -> Boolean
+        condition: Predicate<Collection<Layer>>,
     ): Boolean {
         return componentMatchers.any { oredComponent ->
-            oredComponent.check(layers) { condition(it) }
+            oredComponent.check(layers) { condition.test(it) }
         }
     }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/component/SurfaceViewBackgroundMatcher.kt b/libraries/flicker/utils/src/android/tools/traces/component/SurfaceViewBackgroundMatcher.kt
new file mode 100644
index 000000000..80e273d0b
--- /dev/null
+++ b/libraries/flicker/utils/src/android/tools/traces/component/SurfaceViewBackgroundMatcher.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tools.traces.component
+
+import android.tools.traces.surfaceflinger.Layer
+import android.tools.traces.wm.Activity
+import android.tools.traces.wm.WindowContainer
+import java.util.function.Predicate
+
+class SurfaceViewBackgroundMatcher : IComponentMatcher {
+    /** {@inheritDoc} */
+    override fun windowMatchesAnyOf(windows: Collection<WindowContainer>): Boolean {
+        // Doesn't have a window component only layers
+        return false
+    }
+
+    /** {@inheritDoc} */
+    override fun activityMatchesAnyOf(activities: Collection<Activity>): Boolean {
+        // Doesn't have a window component only layers
+        return false
+    }
+
+    /** {@inheritDoc} */
+    override fun layerMatchesAnyOf(layers: Collection<Layer>): Boolean {
+        return layers.any { it.name.matches(Regex("^Background for \\w+ SurfaceView.*$")) }
+    }
+
+    /** {@inheritDoc} */
+    override fun check(
+        layers: Collection<Layer>,
+        condition: Predicate<Collection<Layer>>,
+    ): Boolean = condition.test(layers.filter { layerMatchesAnyOf(it) })
+
+    /** {@inheritDoc} */
+    override fun toActivityIdentifier(): String {
+        throw NotImplementedError(
+            "toActivityIdentifier() is not implemented on SurfaceViewBackgroundMatcher"
+        )
+    }
+
+    /** {@inheritDoc} */
+    override fun toWindowIdentifier(): String {
+        throw NotImplementedError(
+            "toWindowName() is not implemented on SurfaceViewBackgroundMatcher"
+        )
+    }
+
+    /** {@inheritDoc} */
+    override fun toLayerIdentifier(): String {
+        return "SurfaceViewBackground"
+    }
+}
diff --git a/libraries/flicker/utils/src/android/tools/traces/events/CujEvent.kt b/libraries/flicker/utils/src/android/tools/traces/events/CujEvent.kt
index b637b27f0..fad6e3e54 100644
--- a/libraries/flicker/utils/src/android/tools/traces/events/CujEvent.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/events/CujEvent.kt
@@ -53,20 +53,20 @@ class CujEvent(
             uid: String,
             threadId: Int,
             eventTag: String,
-            data: String
+            data: String,
         ): CujEvent {
             return CujEvent(
                 Timestamps.from(
                     elapsedNanos = getElapsedTimestampFromData(data, eventTag.asCujType()),
                     systemUptimeNanos = getSystemUptimeNanosFromData(data, eventTag.asCujType()),
-                    unixNanos = getUnixTimestampFromData(data, eventTag.asCujType())
+                    unixNanos = getUnixTimestampFromData(data, eventTag.asCujType()),
                 ),
                 getCujMarkerFromData(data, eventTag.asCujType()),
                 processId,
                 uid,
                 threadId,
                 eventTag,
-                getCujTagFromData(data, eventTag.asCujType())
+                getCujTagFromData(data, eventTag.asCujType()),
             )
         }
 
@@ -144,7 +144,7 @@ class CujEvent(
         enum class Type {
             START,
             END,
-            CANCEL
+            CANCEL,
         }
 
         const val JANK_CUJ_BEGIN_TAG = "jank_cuj_events_begin_request"
diff --git a/libraries/flicker/utils/src/android/tools/traces/events/Event.kt b/libraries/flicker/utils/src/android/tools/traces/events/Event.kt
index 8175dfb4d..397377b3f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/events/Event.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/events/Event.kt
@@ -34,5 +34,5 @@ open class Event(
     val processId: Int,
     val uid: String,
     val threadId: Int,
-    val eventTag: String
+    val eventTag: String,
 ) : TraceEntry
diff --git a/libraries/flicker/utils/src/android/tools/traces/events/FocusEvent.kt b/libraries/flicker/utils/src/android/tools/traces/events/FocusEvent.kt
index f10803ca0..3bc7ce05e 100644
--- a/libraries/flicker/utils/src/android/tools/traces/events/FocusEvent.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/events/FocusEvent.kt
@@ -38,12 +38,12 @@ class FocusEvent(
     val reason: String,
     processId: Int,
     uid: String,
-    threadId: Int
+    threadId: Int,
 ) : Event(timestamp, processId, uid, threadId, INPUT_FOCUS_TAG) {
     enum class Type {
         GAINED,
         LOST,
-        REQUESTED
+        REQUESTED,
     }
 
     override fun toString(): String {
@@ -60,7 +60,7 @@ class FocusEvent(
             processId: Int,
             uid: String,
             threadId: Int,
-            data: Collection<String>
+            data: Collection<String>,
         ) =
             FocusEvent(
                 timestamp,
@@ -69,7 +69,7 @@ class FocusEvent(
                 data.drop(1).first().removePrefix("reason="),
                 processId,
                 uid,
-                threadId
+                threadId,
             )
 
         private fun getWindowFromData(data: String): String {
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/ImeClientEntry.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/ImeClientEntry.kt
index d8d4f4a80..eff0aea90 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/ImeClientEntry.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/ImeClientEntry.kt
@@ -36,18 +36,21 @@ open class ImeClientEntry(
     // val imeFocusController: ImeFocusController,
     // val inputConnection: InputConnection,
     // val inputConnectionCall: InputConnectionCall,
-    val elapsedTimestamp: Long
+    val elapsedTimestamp: Long,
 ) : TraceEntry {
     override val timestamp = Timestamps.from(systemUptimeNanos = elapsedTimestamp)
     val stableId: String
         get() = this::class.simpleName ?: error("Unable to determine class")
+
     val name: String
         get() = timestamp.toString()
+
     override fun toString(): String = name
 
     override fun equals(other: Any?): Boolean {
         return other is ImeClientEntry && other.timestamp == this.timestamp
     }
+
     override fun hashCode(): Int {
         var result = timestamp.hashCode()
         result = 31 * result + where.hashCode()
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceEntry.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceEntry.kt
index 75387fc87..a7aa54eb8 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceEntry.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceEntry.kt
@@ -51,11 +51,12 @@ open class InputMethodManagerServiceEntry(
     val imeWindowVisibility: Int,
     val isShowImeWithHardKeyboard: Boolean,
     val isAccessibilityRequestingNoSoftKeyboard: Boolean,
-    val elapsedTimestamp: Long
+    val elapsedTimestamp: Long,
 ) : TraceEntry {
     override val timestamp = Timestamps.from(systemUptimeNanos = elapsedTimestamp)
     val stableId: String
         get() = this::class.simpleName ?: error("Unable to determine class")
+
     val name: String
         get() = timestamp.toString()
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceTrace.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceTrace.kt
index 8e703044d..13b5c0f2c 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceTrace.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodManagerServiceTrace.kt
@@ -45,7 +45,7 @@ data class InputMethodManagerServiceTrace(
      */
     override fun slice(
         startTimestamp: Timestamp,
-        endTimestamp: Timestamp
+        endTimestamp: Timestamp,
     ): InputMethodManagerServiceTrace {
         return InputMethodManagerServiceTrace(
             this.entries
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceEntry.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceEntry.kt
index 8ef9c48a2..c438a2b5c 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceEntry.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceEntry.kt
@@ -53,11 +53,12 @@ open class InputMethodServiceEntry(
     val lastComputedInsets: Insets,
     val settingsObserver: String,
     //    val inputConnectionCall: InputConnectionCallState,
-    val elapsedTimestamp: Long
+    val elapsedTimestamp: Long,
 ) : TraceEntry {
     override val timestamp = Timestamps.from(systemUptimeNanos = elapsedTimestamp)
     val stableId: String
         get() = this::class.simpleName ?: error("Unable to determine class")
+
     val name: String
         get() = timestamp.toString()
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceTrace.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceTrace.kt
index 533e52018..aafa99390 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceTrace.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/InputMethodServiceTrace.kt
@@ -44,7 +44,7 @@ data class InputMethodServiceTrace(override val entries: Collection<InputMethodS
      */
     override fun slice(
         startTimestamp: Timestamp,
-        endTimestamp: Timestamp
+        endTimestamp: Timestamp,
     ): InputMethodServiceTrace {
         return InputMethodServiceTrace(
             this.entries
diff --git a/libraries/flicker/utils/src/android/tools/traces/inputmethod/SoftInputWindow.kt b/libraries/flicker/utils/src/android/tools/traces/inputmethod/SoftInputWindow.kt
index b337e0517..e92f7b69f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/inputmethod/SoftInputWindow.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/inputmethod/SoftInputWindow.kt
@@ -24,10 +24,7 @@ import android.graphics.Rect
  * This is a generic object that is reused by both Flicker and Winscope and cannot access internal
  * Java/Android functionality
  */
-open class SoftInputWindow(
-    val bounds: Rect,
-    val windowState: Int,
-) {
+open class SoftInputWindow(val bounds: Rect, val windowState: Int) {
     override fun toString(): String {
         return "${this::class.simpleName}: {windowState: $windowState, bounds: $bounds"
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ArtifactBuilder.kt b/libraries/flicker/utils/src/android/tools/traces/io/ArtifactBuilder.kt
index 34c9844f0..8f3e43780 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ArtifactBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ArtifactBuilder.kt
@@ -133,13 +133,13 @@ class ArtifactBuilder {
                     addFile(
                         zipOutputStream,
                         artifact,
-                        nameInArchive = descriptor.fileNameInArtifact
+                        nameInArchive = descriptor.fileNameInArtifact,
                     )
                     writtenFileNames.add(descriptor.fileNameInArtifact)
                 } else {
                     Log.d(
                         FLICKER_IO_TAG,
-                        "Not adding duplicated ${descriptor.fileNameInArtifact} to zip"
+                        "Not adding duplicated ${descriptor.fileNameInArtifact} to zip",
                     )
                 }
             }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/FileArtifact.kt b/libraries/flicker/utils/src/android/tools/traces/io/FileArtifact.kt
index 5ee6cb929..347300369 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/FileArtifact.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/FileArtifact.kt
@@ -69,6 +69,8 @@ internal constructor(private val scenario: Scenario, artifactFile: File, private
         }
     }
 
+    override fun readBytes(): ByteArray = file.readBytes()
+
     override fun deleteIfExists() {
         file.deleteIfExists()
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ResultData.kt b/libraries/flicker/utils/src/android/tools/traces/io/ResultData.kt
index 4c8892e33..2403f7843 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ResultData.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ResultData.kt
@@ -31,7 +31,7 @@ import android.tools.io.TransitionTimeRange
 open class ResultData(
     _artifact: Artifact,
     _transitionTimeRange: TransitionTimeRange,
-    _executionError: Throwable?
+    _executionError: Throwable?,
 ) : IResultData {
     final override val artifact: Artifact = _artifact
     final override val transitionTimeRange: TransitionTimeRange = _transitionTimeRange
@@ -50,7 +50,7 @@ open class ResultData(
         return ResultData(
             artifact,
             TransitionTimeRange(startTimestamp, endTimestamp),
-            executionError
+            executionError,
         )
     }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt b/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
index 539ea3f1b..6bca2049a 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ResultReader.kt
@@ -145,7 +145,7 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
                                 transitionTimeRange.start,
                                 transitionTimeRange.end,
                                 addInitialEntry = true,
-                                clearCache = true
+                                clearCache = true,
                             )
                     }
                 val minimumEntries = minimumTraceEntriesForConfig(traceConfig.layersTrace)
@@ -246,7 +246,7 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
                         .parse(
                             session,
                             from = transitionTimeRange.start,
-                            to = transitionTimeRange.end
+                            to = transitionTimeRange.end,
                         )
                 }
             }
@@ -274,7 +274,7 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
                     from = transitionTimeRange.start,
                     to = transitionTimeRange.end,
                     addInitialEntry = true,
-                    clearCache = true
+                    clearCache = true,
                 )
         }
     }
@@ -304,7 +304,7 @@ open class ResultReader(_result: IResultData, internal val traceConfig: TraceCon
                     wmSideTraceData,
                     shellSideTraceData,
                     from = transitionTimeRange.start,
-                    to = transitionTimeRange.end
+                    to = transitionTimeRange.end,
                 )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ResultReaderWithLru.kt b/libraries/flicker/utils/src/android/tools/traces/io/ResultReaderWithLru.kt
index a8da9b969..c088a39f5 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ResultReaderWithLru.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ResultReaderWithLru.kt
@@ -40,7 +40,7 @@ import java.io.IOException
 open class ResultReaderWithLru(
     result: IResultData,
     traceConfig: TraceConfigs,
-    private val reader: ResultReader = ResultReader(result, traceConfig)
+    private val reader: ResultReader = ResultReader(result, traceConfig),
 ) : Reader by reader {
     /** {@inheritDoc} */
     @Throws(IOException::class)
@@ -74,7 +74,7 @@ open class ResultReaderWithLru(
 
     private fun <TraceType> LruCache<CacheKey, TraceType>.logAndReadTrace(
         key: CacheKey,
-        predicate: () -> TraceType?
+        predicate: () -> TraceType?,
     ): TraceType? {
         return withTracing("logAndReadTrace") {
             var value = this[key]
@@ -98,7 +98,7 @@ open class ResultReaderWithLru(
         data class CacheKey(
             private val artifact: String,
             internal val descriptor: ResultArtifactDescriptor,
-            private val transitionTimeRange: TransitionTimeRange
+            private val transitionTimeRange: TransitionTimeRange,
         )
 
         private val wmTraceCache = LruCache<CacheKey, WindowManagerTrace>(5)
diff --git a/libraries/flicker/utils/src/android/tools/traces/io/ResultWriter.kt b/libraries/flicker/utils/src/android/tools/traces/io/ResultWriter.kt
index 209021b13..4e54cc829 100644
--- a/libraries/flicker/utils/src/android/tools/traces/io/ResultWriter.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/io/ResultWriter.kt
@@ -74,7 +74,7 @@ open class ResultWriter {
     fun addTraceResult(traceType: TraceType, artifact: File, tag: String = Tag.ALL) = apply {
         Log.d(
             FLICKER_IO_TAG,
-            "Add trace result file=$artifact type=$traceType tag=$tag scenario=$scenario"
+            "Add trace result file=$artifact type=$traceType tag=$tag scenario=$scenario",
         )
         val fileDescriptor = ResultArtifactDescriptor(traceType, tag)
         files[fileDescriptor] = artifact
@@ -101,7 +101,7 @@ open class ResultWriter {
             ResultData(
                 artifact,
                 TransitionTimeRange(transitionStartTime, transitionEndTime),
-                executionError
+                executionError,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/MonitorUtils.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/MonitorUtils.kt
index 570833d22..1d33a31c5 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/MonitorUtils.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/MonitorUtils.kt
@@ -17,7 +17,7 @@
 @file:JvmName("MonitorUtils")
 @file:OptIn(
     androidx.benchmark.perfetto.ExperimentalPerfettoCaptureApi::class,
-    androidx.benchmark.perfetto.ExperimentalPerfettoTraceProcessorApi::class
+    androidx.benchmark.perfetto.ExperimentalPerfettoTraceProcessorApi::class,
 )
 
 package android.tools.traces.monitors
@@ -25,19 +25,45 @@ package android.tools.traces.monitors
 import android.tools.ScenarioBuilder
 import android.tools.Tag
 import android.tools.io.Reader
+import android.tools.io.TraceType
 import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.TRACE_CONFIG_REQUIRE_CHANGES
+import android.tools.traces.io.IResultData
+import android.tools.traces.io.ResultReader
 import android.tools.traces.io.ResultReaderWithLru
 import android.tools.traces.io.ResultWriter
 import android.tools.traces.monitors.wm.WindowManagerTraceMonitor
 import android.tools.traces.parsers.perfetto.LayersTraceParser
 import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.TransactionsTraceParser
-import android.tools.traces.parsers.wm.LegacyWindowManagerTraceParser
+import android.tools.traces.parsers.perfetto.WindowManagerTraceParser
 import android.tools.traces.surfaceflinger.LayersTrace
 import android.tools.traces.surfaceflinger.TransactionsTrace
 import android.tools.traces.wm.WindowManagerTrace
 import java.io.File
 import perfetto.protos.PerfettoConfig.SurfaceFlingerLayersConfig
+import perfetto.protos.PerfettoConfig.WindowManagerConfig
+
+private fun buildResultReader(resultData: IResultData): ResultReader =
+    ResultReader(resultData, TRACE_CONFIG_REQUIRE_CHANGES)
+
+/**
+ * Reads the Perfetto file form the result reader and keep (or not) a copy
+ *
+ * @param debugFile File to keep a copy of the parsed trace, leave null to not keep any copies
+ * @throws UnsupportedOperationException If tracing is already activated
+ */
+private fun readBytes(
+    reader: ResultReader,
+    debugFile: File?,
+    traceType: TraceType = TraceType.PERFETTO,
+    tag: String = Tag.ALL,
+): ByteArray {
+    val bytes = reader.readBytes(traceType, tag) ?: error("Missing trace $traceType")
+    reader.artifact.deleteIfExists()
+    debugFile?.writeBytes(bytes)
+    return bytes
+}
 
 /**
  * Acquire the [WindowManagerTrace] with the device state changes that happen when executing the
@@ -46,9 +72,22 @@ import perfetto.protos.PerfettoConfig.SurfaceFlingerLayersConfig
  * @param predicate Commands to execute
  * @throws UnsupportedOperationException If tracing is already activated
  */
-fun withWMTracing(predicate: () -> Unit): WindowManagerTrace {
-    return LegacyWindowManagerTraceParser()
-        .parse(WindowManagerTraceMonitor().withTracing(Tag.ALL, predicate))
+fun withWMTracing(
+    logFrequency: WindowManagerConfig.LogFrequency =
+        WindowManagerConfig.LogFrequency.LOG_FREQUENCY_FRAME,
+    debugFile: File? = null,
+    predicate: Runnable,
+): WindowManagerTrace {
+    val reader =
+        PerfettoTraceMonitor.newBuilder()
+            .enableWindowManagerTrace(logFrequency)
+            .build()
+            .withTracing(resultReaderProvider = { buildResultReader(it) }, predicate)
+
+    val bytes = readBytes(reader, debugFile)
+    return TraceProcessorSession.loadPerfettoTrace(bytes) { session ->
+        WindowManagerTraceParser().parse(session)
+    }
 }
 
 /**
@@ -57,19 +96,23 @@ fun withWMTracing(predicate: () -> Unit): WindowManagerTrace {
  *
  * @param flags Flags to indicate tracing level
  * @param predicate Commands to execute
+ * @param debugFile File to keep a copy of the parsed trace, leave null to not keep any copies
  * @throws UnsupportedOperationException If tracing is already activated
  */
 @JvmOverloads
 fun withSFTracing(
     flags: List<SurfaceFlingerLayersConfig.TraceFlag>? = null,
-    predicate: () -> Unit
+    debugFile: File? = null,
+    predicate: Runnable,
 ): LayersTrace {
-    val trace =
+    val reader =
         PerfettoTraceMonitor.newBuilder()
             .enableLayersTrace(flags)
             .build()
-            .withTracing(Tag.ALL, predicate)
-    return TraceProcessorSession.loadPerfettoTrace(trace) { session ->
+            .withTracing(resultReaderProvider = { buildResultReader(it) }, predicate)
+
+    val bytes = readBytes(reader, debugFile)
+    return TraceProcessorSession.loadPerfettoTrace(bytes) { session ->
         LayersTraceParser().parse(session)
     }
 }
@@ -78,17 +121,18 @@ fun withSFTracing(
  * Acquire the [TransactionsTrace] with the device state changes that happen when executing the
  * commands defined in the [predicate].
  *
+ * @param debugFile File to keep a copy of the parsed trace, leave null to not keep any copies
  * @param predicate Commands to execute
  * @throws UnsupportedOperationException If tracing is already activated
  */
-@JvmOverloads
-fun withTransactionsTracing(predicate: () -> Unit): TransactionsTrace {
-    val trace =
+fun withTransactionsTracing(debugFile: File? = null, predicate: Runnable): TransactionsTrace {
+    val reader =
         PerfettoTraceMonitor.newBuilder()
             .enableTransactionsTrace()
             .build()
-            .withTracing(Tag.ALL, predicate)
-    return TraceProcessorSession.loadPerfettoTrace(trace) { session ->
+            .withTracing(resultReaderProvider = { buildResultReader(it) }, predicate)
+    val bytes = readBytes(reader, debugFile)
+    return TraceProcessorSession.loadPerfettoTrace(bytes) { session ->
         TransactionsTraceParser().parse(session)
     }
 }
@@ -97,6 +141,8 @@ fun withTransactionsTracing(predicate: () -> Unit): TransactionsTrace {
  * Acquire the [WindowManagerTrace] and [LayersTrace] with the device state changes that happen when
  * executing the commands defined in the [predicate].
  *
+ * @param traceMonitors List of monitors to start
+ * @param debugFile File to keep a copy of the parsed trace, leave null to not keep any copies
  * @param predicate Commands to execute
  * @throws UnsupportedOperationException If tracing is already activated
  */
@@ -119,7 +165,8 @@ fun withTracing(
                 this.add(monitorBuilder.build())
             }
             .toList(),
-    predicate: () -> Unit
+    debugFile: File? = null,
+    predicate: Runnable,
 ): Reader {
     val tmpFile = File.createTempFile("recordTraces", "")
     val writer =
@@ -129,11 +176,13 @@ fun withTracing(
 
     try {
         traceMonitors.forEach { it.start() }
-        predicate()
+        predicate.run()
     } finally {
         traceMonitors.forEach { it.stop(writer) }
     }
-    return ResultReaderWithLru(writer.write(), SERVICE_TRACE_CONFIG)
+    val reader = ResultReaderWithLru(writer.write(), SERVICE_TRACE_CONFIG)
+    debugFile?.writeBytes(reader.artifact.readBytes())
+    return reader
 }
 
 /**
@@ -144,12 +193,10 @@ fun withTracing(
  * @return a pair containing the WM and SF traces
  * @throws UnsupportedOperationException If tracing is already activated
  */
-fun recordTraces(predicate: () -> Unit): Pair<ByteArray, ByteArray> {
-    var wmTraceData = ByteArray(0)
-    val layersTraceData =
-        PerfettoTraceMonitor.newBuilder().enableLayersTrace().build().withTracing {
-            wmTraceData = WindowManagerTraceMonitor().withTracing(Tag.ALL, predicate)
-        }
-
-    return Pair(wmTraceData, layersTraceData)
+fun recordTraces(predicate: Runnable): ResultReader {
+    return PerfettoTraceMonitor.newBuilder()
+        .enableLayersTrace()
+        .enableWindowManagerTrace()
+        .build()
+        .withTracing(resultReaderProvider = { buildResultReader(it) }, predicate)
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/NoTraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/NoTraceMonitor.kt
index faf090fa2..2e9625d9d 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/NoTraceMonitor.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/NoTraceMonitor.kt
@@ -18,12 +18,13 @@ package android.tools.traces.monitors
 
 import android.tools.Timestamps
 import android.tools.traces.io.ResultWriter
+import java.util.function.Consumer
 
 /**
  * A monitor that doesn't actually collect any traces and instead get the resultSetter sets the
  * trace file directly when called.
  */
-class NoTraceMonitor(private val resultSetter: (ResultWriter) -> Unit) : ITransitionMonitor {
+class NoTraceMonitor(private val resultSetter: Consumer<ResultWriter>) : ITransitionMonitor {
     override fun start() {
         // Does nothing
     }
@@ -31,6 +32,6 @@ class NoTraceMonitor(private val resultSetter: (ResultWriter) -> Unit) : ITransi
     override fun stop(writer: ResultWriter) {
         writer.setTransitionStartTime(Timestamps.min())
         writer.setTransitionEndTime(Timestamps.max())
-        this.resultSetter.invoke(writer)
+        this.resultSetter.accept(writer)
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
index 97243376f..4b597a0f4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/PerfettoTraceMonitor.kt
@@ -74,7 +74,7 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
             listOf(
                 SurfaceFlingerLayersConfig.TraceFlag.TRACE_FLAG_INPUT,
                 SurfaceFlingerLayersConfig.TraceFlag.TRACE_FLAG_COMPOSITION,
-                SurfaceFlingerLayersConfig.TraceFlag.TRACE_FLAG_VIRTUAL_DISPLAYS
+                SurfaceFlingerLayersConfig.TraceFlag.TRACE_FLAG_VIRTUAL_DISPLAYS,
             )
 
         private val dataSourceConfigs = mutableSetOf<DataSourceConfig>()
@@ -134,7 +134,7 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
                     false,
                     defaultLogFrom,
                     groupOverrides,
-                    dataSourceName
+                    dataSourceName,
                 )
             )
         }
@@ -148,7 +148,7 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
         fun enableWindowManagerTrace(
             logFrequency: WindowManagerConfig.LogFrequency =
                 WindowManagerConfig.LogFrequency.LOG_FREQUENCY_FRAME,
-            dataSourceName: String = WINDOWMANAGER_DATA_SOURCE
+            dataSourceName: String = WINDOWMANAGER_DATA_SOURCE,
         ): Builder = apply {
             val config =
                 DataSourceConfig.newBuilder()
@@ -324,16 +324,19 @@ open class PerfettoTraceMonitor(val config: TraceConfig) : TraceMonitor() {
             return Builder()
         }
 
+        @JvmStatic
         fun stopAllSessions() {
             allPerfettoPidsLock.lock()
             try {
                 allPerfettoPids.forEach { killPerfettoProcess(it) }
                 allPerfettoPids.forEach { waitPerfettoProcessExits(it) }
+                allPerfettoPids.clear()
             } finally {
                 allPerfettoPidsLock.unlock()
             }
         }
 
+        @JvmStatic
         fun killPerfettoProcess(pid: Int) {
             if (isPerfettoProcessUp(pid)) {
                 executeShellCommand("kill $pid")
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecorder.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecorder.kt
index 71af9f2b7..8d2d4d061 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecorder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecorder.kt
@@ -30,7 +30,7 @@ constructor(
     private val context: Context,
     private val outputFile: File = File.createTempFile("transition", "screen_recording"),
     private val width: Int = 720,
-    private val height: Int = 1280
+    private val height: Int = 1280,
 ) : TraceMonitor() {
     override val traceType = TraceType.SCREEN_RECORDING
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecordingRunnable.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecordingRunnable.kt
index dccd3acba..23622f0f9 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecordingRunnable.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/ScreenRecordingRunnable.kt
@@ -38,7 +38,7 @@ class ScreenRecordingRunnable(
     private val outputFile: File,
     context: Context,
     private val width: Int = 720,
-    private val height: Int = 1280
+    private val height: Int = 1280,
 ) : Runnable {
     private val displayManager = context.getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
     private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
@@ -63,7 +63,7 @@ class ScreenRecordingRunnable(
             inputSurface,
             DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
             null,
-            null
+            null,
         )
     private val muxer = createMuxer()
     private var metadataTrackIndex = -1
@@ -165,7 +165,7 @@ class ScreenRecordingRunnable(
             LOG_TAG,
             "Writing winscope metadata (size=${timestampsMonotonicUs.size} " +
                 ", monotonic timestamps range [us] = " +
-                "${timestampsMonotonicUs.first()}-${timestampsMonotonicUs.last()})"
+                "${timestampsMonotonicUs.first()}-${timestampsMonotonicUs.last()})",
         )
 
         val monotonicTimeNs = TimeUnit.MILLISECONDS.toNanos(SystemClock.uptimeMillis())
@@ -211,7 +211,7 @@ class ScreenRecordingRunnable(
         val displayMode = windowManager.defaultDisplay.mode
         format.setInteger(
             MediaFormat.KEY_COLOR_FORMAT,
-            MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface
+            MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface,
         )
         format.setInteger(MediaFormat.KEY_BIT_RATE, BIT_RATE)
         format.setFloat(MediaFormat.KEY_FRAME_RATE, displayMode.refreshRate)
diff --git a/libraries/flicker/utils/src/android/tools/traces/monitors/TraceMonitor.kt b/libraries/flicker/utils/src/android/tools/traces/monitors/TraceMonitor.kt
index 981272a02..38560ef61 100644
--- a/libraries/flicker/utils/src/android/tools/traces/monitors/TraceMonitor.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/monitors/TraceMonitor.kt
@@ -17,9 +17,9 @@
 package android.tools.traces.monitors
 
 import android.tools.ScenarioBuilder
-import android.tools.Tag
+import android.tools.function.Supplier
 import android.tools.io.TraceType
-import android.tools.traces.TRACE_CONFIG_REQUIRE_CHANGES
+import android.tools.traces.io.IResultData
 import android.tools.traces.io.IoUtils
 import android.tools.traces.io.ResultReader
 import android.tools.traces.io.ResultWriter
@@ -33,7 +33,9 @@ import kotlin.io.path.createTempDirectory
 abstract class TraceMonitor : ITransitionMonitor {
     abstract val isEnabled: Boolean
     abstract val traceType: TraceType
+
     protected abstract fun doStart()
+
     protected abstract fun doStop(): File
 
     protected open fun doStopTraces(): Map<TraceType, File> = mapOf(traceType to doStop())
@@ -66,7 +68,7 @@ abstract class TraceMonitor : ITransitionMonitor {
             } catch (e: Throwable) {
                 throw RuntimeException(
                     "Could not stop ${traceType.name} trace and save it to ${traceType.fileName}",
-                    e
+                    e,
                 )
             }
         artifacts.forEach { (key, value) -> writer.addTraceResult(key, value) }
@@ -86,11 +88,11 @@ abstract class TraceMonitor : ITransitionMonitor {
      * @param predicate Commands to execute
      * @throws UnsupportedOperationException If tracing is already activated
      */
-    fun withTracing(writer: ResultWriter, predicate: () -> Unit) {
+    fun withTracing(writer: ResultWriter, predicate: Runnable) {
         android.tools.withTracing("${this::class.simpleName}#withTracing") {
             try {
                 this.start()
-                predicate()
+                predicate.run()
             } finally {
                 this.stop(writer)
             }
@@ -101,16 +103,18 @@ abstract class TraceMonitor : ITransitionMonitor {
      * Acquires the trace generated when executing the commands defined in the [predicate].
      *
      * @param predicate Commands to execute
+     * @param resultReaderProvider Predicate to generate new result readers
+     * @param
      * @throws UnsupportedOperationException If tracing is already activated
      */
-    fun withTracing(tag: String = Tag.ALL, predicate: () -> Unit): ByteArray {
+    fun withTracing(
+        resultReaderProvider: Supplier<IResultData, ResultReader>,
+        predicate: Runnable,
+    ): ResultReader {
         val writer = createWriter()
         withTracing(writer, predicate)
         val result = writer.write()
-        val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
-        val bytes = reader.readBytes(traceType, tag) ?: error("Missing trace $traceType")
-        result.artifact.deleteIfExists()
-        return bytes
+        return resultReaderProvider.get(result)
     }
 
     private fun createWriter(): ResultWriter {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/DeviceDumpParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/DeviceDumpParser.kt
index 719bd16e9..508b003a4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/DeviceDumpParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/DeviceDumpParser.kt
@@ -54,41 +54,53 @@ class DeviceDumpParser {
         fun fromNullableDump(
             wmTraceData: ByteArray,
             layersTraceData: ByteArray,
-            clearCacheAfterParsing: Boolean
+            clearCacheAfterParsing: Boolean,
         ): NullableDeviceStateDump {
             return withTracing("fromNullableDump") {
-                    val wmState =
-                        wmTraceData
-                            .takeIf { it.isNotEmpty() }
-                            ?.let {
-                                if (android.tracing.Flags.perfettoWmDump()) {
-                                    TraceProcessorSession.loadPerfettoTrace(wmTraceData) { session
-                                        ->
-                                        WindowManagerTraceParser()
-                                            .parse(session, clearCache = clearCacheAfterParsing)
-                                            .entries
-                                            .first()
-                                    }
-                                } else {
-                                    WindowManagerDumpParser()
-                                        .parse(wmTraceData, clearCache = clearCacheAfterParsing)
+                    val hasSfDump = layersTraceData.isNotEmpty()
+                    val hasWmDump = wmTraceData.isNotEmpty()
+
+                    // If android.tracing.Flags.perfettoWmDump() is enabled, layersTraceData and
+                    // wmTraceData correspond to the same perfetto trace file
+                    val perfettoTrace =
+                        if (hasSfDump) {
+                            layersTraceData
+                        } else if (android.tracing.Flags.perfettoWmDump() && hasWmDump) {
+                            wmTraceData
+                        } else {
+                            null
+                        }
+
+                    var wmState: WindowManagerState? = null
+                    var layerState: LayerTraceEntry? = null
+
+                    perfettoTrace?.let {
+                        TraceProcessorSession.loadPerfettoTrace(it) { session ->
+                            if (hasSfDump) {
+                                layerState =
+                                    LayersTraceParser()
+                                        .parse(session, clearCache = clearCacheAfterParsing)
                                         .entries
                                         .first()
-                                }
                             }
 
-                    val layerState =
-                        layersTraceData
-                            .takeIf { it.isNotEmpty() }
-                            ?.let {
-                                TraceProcessorSession.loadPerfettoTrace(layersTraceData) { session
-                                    ->
-                                    LayersTraceParser()
+                            if (android.tracing.Flags.perfettoWmDump() && hasWmDump) {
+                                wmState =
+                                    WindowManagerTraceParser()
                                         .parse(session, clearCache = clearCacheAfterParsing)
                                         .entries
                                         .first()
-                                }
                             }
+                        }
+                    }
+
+                    if (!android.tracing.Flags.perfettoWmDump() && hasWmDump) {
+                        wmState =
+                            WindowManagerDumpParser()
+                                .parse(wmTraceData, clearCache = clearCacheAfterParsing)
+                                .entries
+                                .first()
+                    }
 
                     NullableDeviceStateDump(wmState = wmState, layerState = layerState)
                 }
@@ -103,14 +115,14 @@ class DeviceDumpParser {
         fun fromDump(
             wmTraceData: ByteArray,
             layersTraceData: ByteArray,
-            clearCacheAfterParsing: Boolean
+            clearCacheAfterParsing: Boolean,
         ): DeviceStateDump {
             return withTracing("fromDump") {
                     val nullableDump =
                         fromNullableDump(wmTraceData, layersTraceData, clearCacheAfterParsing)
                     DeviceStateDump(
                         nullableDump.wmState ?: error("WMState dump missing"),
-                        nullableDump.layerState ?: error("Layer State dump missing")
+                        nullableDump.layerState ?: error("Layer State dump missing"),
                     )
                 }
                 .also {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/WaitForValidActivityState.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/WaitForValidActivityState.kt
index 49204a13b..2072ea712 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/WaitForValidActivityState.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/WaitForValidActivityState.kt
@@ -25,7 +25,7 @@ data class WaitForValidActivityState(
     @JvmField val windowIdentifier: String?,
     @JvmField val stackId: Int,
     @JvmField val windowingMode: Int,
-    @JvmField val activityType: Int
+    @JvmField val activityType: Int,
 ) {
     constructor(
         activityName: IComponentMatcher
@@ -34,7 +34,7 @@ data class WaitForValidActivityState(
         windowIdentifier = activityName.toWindowIdentifier(),
         stackId = ActivityTaskManager.INVALID_STACK_ID,
         windowingMode = WindowConfiguration.WINDOWING_MODE_UNDEFINED,
-        activityType = WindowConfiguration.ACTIVITY_TYPE_UNDEFINED
+        activityType = WindowConfiguration.ACTIVITY_TYPE_UNDEFINED,
     )
 
     private constructor(
@@ -44,7 +44,7 @@ data class WaitForValidActivityState(
         windowIdentifier = builder.windowIdentifier,
         stackId = builder.stackId,
         windowingMode = builder.windowingMode,
-        activityType = builder.activityType
+        activityType = builder.activityType,
     )
 
     override fun toString(): String {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
index a36d0a4f2..deb616266 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/WindowManagerStateHelper.kt
@@ -19,6 +19,7 @@ package android.tools.traces.parsers
 import android.app.ActivityTaskManager
 import android.app.Instrumentation
 import android.app.WindowConfiguration
+import android.graphics.Rect
 import android.graphics.Region
 import android.os.SystemClock
 import android.os.Trace
@@ -46,6 +47,8 @@ import android.tools.traces.wm.WindowState
 import android.util.Log
 import android.view.Display
 import androidx.test.platform.app.InstrumentationRegistry
+import java.util.function.Predicate
+import java.util.function.Supplier
 
 /** Helper class to wait on [WindowManagerState] or [LayerTraceEntry] conditions */
 open class WindowManagerStateHelper
@@ -55,13 +58,13 @@ constructor(
     private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
     private val clearCacheAfterParsing: Boolean = true,
     /** Predicate to supply a new UI information */
-    private val deviceDumpSupplier: () -> DeviceStateDump = {
+    private val deviceDumpSupplier: Supplier<DeviceStateDump> = Supplier {
         getCurrentStateDump(clearCacheAfterParsing = clearCacheAfterParsing)
     },
     /** Number of attempts to satisfy a wait condition */
     private val numRetries: Int = DEFAULT_RETRY_LIMIT,
     /** Interval between wait for state dumps during wait conditions */
-    private val retryIntervalMs: Long = DEFAULT_RETRY_INTERVAL_MS
+    private val retryIntervalMs: Long = DEFAULT_RETRY_INTERVAL_MS,
 ) {
     private var internalState: DeviceStateDump? = null
 
@@ -69,7 +72,7 @@ constructor(
     val currentState: DeviceStateDump
         get() {
             if (internalState == null) {
-                internalState = deviceDumpSupplier.invoke()
+                internalState = deviceDumpSupplier.get()
             } else {
                 StateSyncBuilder().withValidState().waitFor()
             }
@@ -98,16 +101,19 @@ constructor(
     fun getWindowRegion(componentMatcher: IComponentMatcher): Region =
         getWindow(componentMatcher)?.frameRegion ?: Region()
 
+    /** Factory function to create a new [StateSyncBuilder] object from a state helper */
+    fun StateSyncBuilder(): StateSyncBuilder = StateSyncBuilder(deviceDumpSupplier)
+
     /**
      * Class to build conditions for waiting on specific [WindowManagerTrace] and [LayersTrace]
      * conditions
      */
-    inner class StateSyncBuilder {
+    inner class StateSyncBuilder(private val deviceDumpSupplier: Supplier<DeviceStateDump>) {
         private val conditionBuilder = createConditionBuilder()
         private var lastMessage = ""
 
         private fun createConditionBuilder(): WaitCondition.Builder<DeviceStateDump> =
-            WaitCondition.Builder(deviceDumpSupplier, numRetries)
+            WaitCondition.Builder(numRetries) { deviceDumpSupplier.get() }
                 .onStart { Trace.beginSection(it) }
                 .onEnd { Trace.endSection() }
                 .onSuccess { updateCurrState(it) }
@@ -138,7 +144,7 @@ constructor(
          * @param condition to wait for
          */
         @JvmOverloads
-        fun add(message: String = "", condition: (DeviceStateDump) -> Boolean): StateSyncBuilder =
+        fun add(message: String = "", condition: Predicate<DeviceStateDump>): StateSyncBuilder =
             add(Condition(message, condition))
 
         /**
@@ -189,7 +195,7 @@ constructor(
         @JvmOverloads
         fun withFullScreenApp(
             componentMatcher: IComponentMatcher,
-            displayId: Int = Display.DEFAULT_DISPLAY
+            displayId: Int = Display.DEFAULT_DISPLAY,
         ) =
             withFullScreenAppCondition(componentMatcher)
                 .withAppTransitionIdle(displayId)
@@ -205,7 +211,7 @@ constructor(
         @JvmOverloads
         fun withFreeformApp(
             componentMatcher: IComponentMatcher,
-            displayId: Int = Display.DEFAULT_DISPLAY
+            displayId: Int = Display.DEFAULT_DISPLAY,
         ) =
             withFreeformAppCondition(componentMatcher)
                 .withAppTransitionIdle(displayId)
@@ -291,7 +297,7 @@ constructor(
         @JvmOverloads
         fun withActivityRemoved(
             componentMatcher: IComponentMatcher,
-            displayId: Int = Display.DEFAULT_DISPLAY
+            displayId: Int = Display.DEFAULT_DISPLAY,
         ) =
             withAppTransitionIdle(displayId)
                 .add(ConditionsFactory.containsActivity(componentMatcher).negate())
@@ -320,7 +326,7 @@ constructor(
         @JvmOverloads
         fun withWindowSurfaceDisappeared(
             componentMatcher: IComponentMatcher,
-            displayId: Int = Display.DEFAULT_DISPLAY
+            displayId: Int = Display.DEFAULT_DISPLAY,
         ) =
             withAppTransitionIdle(displayId)
                 .add(ConditionsFactory.isWindowSurfaceShown(componentMatcher).negate())
@@ -337,7 +343,7 @@ constructor(
         @JvmOverloads
         fun withWindowSurfaceAppeared(
             componentMatcher: IComponentMatcher,
-            displayId: Int = Display.DEFAULT_DISPLAY
+            displayId: Int = Display.DEFAULT_DISPLAY,
         ) =
             withAppTransitionIdle(displayId)
                 .add(ConditionsFactory.isWindowSurfaceShown(componentMatcher))
@@ -348,27 +354,32 @@ constructor(
          *
          * @param componentMatcher Components to search
          */
-        fun withLayerVisible(
-            componentMatcher: IComponentMatcher
-        ) = add(ConditionsFactory.isLayerVisible(componentMatcher))
+        fun withLayerVisible(componentMatcher: IComponentMatcher) =
+            add(ConditionsFactory.isLayerVisible(componentMatcher))
 
         /**
          * Wait until least one layer matching [componentMatcher] has [expectedRegion]
          *
          * @param componentMatcher Components to search
          * @param expectedRegion of the target surface
+         * @param compareFn custom comparator to compare `visibleRegion` vs `expectedRegion`
          */
-        fun withSurfaceVisibleRegion(componentMatcher: IComponentMatcher, expectedRegion: Region) =
-            add(
-                Condition("surfaceRegion") {
-                    val layer =
-                        it.layerState.visibleLayers.firstOrNull { layer ->
-                            componentMatcher.layerMatchesAnyOf(layer)
-                        }
-
-                    layer?.visibleRegion == expectedRegion
-                }
-            )
+        fun withSurfaceMatchingVisibleRegion(
+            componentMatcher: IComponentMatcher,
+            expectedRegion: Region,
+            compareFn: (Region, Region) -> Boolean = { surfaceRegion, expected ->
+                surfaceRegion == expected
+            },
+        ) = add(Condition("surfaceRegion") {
+            val layer = it.layerState.visibleLayers.firstOrNull { layer ->
+                componentMatcher.layerMatchesAnyOf(layer)
+            }
+            layer?.let {
+                // TODO(pablogamito): Remove non-null assertion once visibleRegion in
+                // LayerProperties is no longer nullable.
+                compareFn(layer.visibleRegion!!, expectedRegion)
+            } ?: false
+        })
 
         /**
          * Waits until the IME window and layer are visible
@@ -434,6 +445,14 @@ constructor(
         /** Waits until the keyguard is showing */
         fun withKeyguardShowing() = add("withKeyguardShowing") { it.wmState.isKeyguardShowing }
 
+        /** Waits until the given app is the top visible app window. */
+        fun withTopVisibleApp(componentMatcher: IComponentMatcher): StateSyncBuilder {
+            return add("withTopVisibleApp") {
+                val topVisible = it.wmState.topVisibleAppWindow
+                return@add topVisible != null && componentMatcher.windowMatchesAnyOf(topVisible)
+            }
+        }
+
         /**
          * Wait for the activities to appear in proper stacks and for valid state in AM and WM.
          *
@@ -463,6 +482,7 @@ constructor(
                     .setActivityType(WindowConfiguration.ACTIVITY_TYPE_STANDARD)
                     .build()
             )
+
         fun withFreeformAppCondition(componentMatcher: IComponentMatcher) =
             waitForValidStateCondition(
                 WaitForValidActivityState.Builder(componentMatcher)
@@ -482,7 +502,7 @@ constructor(
         /** @return true if it should wait for some activities to become visible. */
         private fun shouldWaitForActivities(
             state: DeviceStateDump,
-            vararg waitForActivitiesVisible: WaitForValidActivityState
+            vararg waitForActivitiesVisible: WaitForValidActivityState,
         ): Boolean {
             if (waitForActivitiesVisible.isEmpty()) {
                 return false
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/Args.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/Args.kt
index a20ae70d1..0703e0816 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/Args.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/Args.kt
@@ -85,7 +85,7 @@ class Args {
         keyAndIndex: Pair<String, Int>,
         keyTokens: List<String>,
         currentToken: Int,
-        value: Any
+        value: Any,
     ) {
         val (key, index) = keyAndIndex
         if (children == null) {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/LayersTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/LayersTraceParser.kt
index 97a6c40ff..00c3e0fef 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/LayersTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/LayersTraceParser.kt
@@ -93,7 +93,7 @@ class LayersTraceParser(
     private fun buildTraceEntry(
         snapshotRows: List<Row>,
         layersRows: List<Row>,
-        realToMonotonicTimeOffsetNs: Long
+        realToMonotonicTimeOffsetNs: Long,
     ): LayerTraceEntry {
         val snapshotArgs = Args.build(snapshotRows)
         val displays = snapshotArgs.getChildren("displays")?.map { newDisplay(it) } ?: emptyList()
@@ -186,7 +186,7 @@ class LayersTraceParser(
                 layer.getChild("is_relative_of")?.getBoolean() ?: false,
                 layer.getChild("z_order_relative_of")?.getInt() ?: 0,
                 layer.getChild("layer_stack")?.getInt() ?: 0,
-                excludesCompositionState
+                excludesCompositionState,
             )
         }
 
@@ -212,7 +212,7 @@ class LayersTraceParser(
                 /* left */ rectf.getChild("left")?.getFloat() ?: 0f,
                 /* top */ rectf.getChild("top")?.getFloat() ?: 0f,
                 /* right */ rectf.getChild("right")?.getFloat() ?: 0f,
-                /* bottom */ rectf.getChild("bottom")?.getFloat() ?: 0f
+                /* bottom */ rectf.getChild("bottom")?.getFloat() ?: 0f,
             )
         }
 
@@ -222,7 +222,7 @@ class LayersTraceParser(
             }
             return Size.from(
                 sizeArgs.getChild("w")?.getInt() ?: 0,
-                sizeArgs.getChild("h")?.getInt() ?: 0
+                sizeArgs.getChild("h")?.getInt() ?: 0,
             )
         }
 
@@ -235,7 +235,7 @@ class LayersTraceParser(
                     color.getChild("r")?.getFloat() ?: 0f,
                     color.getChild("g")?.getFloat() ?: 0f,
                     color.getChild("b")?.getFloat() ?: 0f,
-                    color.getChild("a")?.getFloat() ?: 0f
+                    color.getChild("a")?.getFloat() ?: 0f,
                 )
             }
         }
@@ -248,7 +248,7 @@ class LayersTraceParser(
                 buffer.getChild("width")?.getInt() ?: 0,
                 buffer.getChild("height")?.getInt() ?: 0,
                 buffer.getChild("stride")?.getInt() ?: 0,
-                buffer.getChild("format")?.getInt() ?: 0
+                buffer.getChild("format")?.getInt() ?: 0,
             )
         }
 
@@ -292,7 +292,7 @@ class LayersTraceParser(
                 rect?.getChild("left")?.getInt() ?: 0,
                 rect?.getChild("top")?.getInt() ?: 0,
                 rect?.getChild("right")?.getInt() ?: 0,
-                rect?.getChild("bottom")?.getInt() ?: 0
+                rect?.getChild("bottom")?.getInt() ?: 0,
             )
 
         private fun newTransform(transform: Args?, position: Args?) =
@@ -315,7 +315,7 @@ class LayersTraceParser(
                 x,
                 transform.getChild("dsdy")?.getFloat() ?: 0f,
                 transform.getChild("dtdy")?.getFloat() ?: 0f,
-                y
+                y,
             )
         }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
index 4680cbe46..c6520eb5c 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TraceProcessorSession.kt
@@ -16,7 +16,7 @@
 
 @file:OptIn(
     androidx.benchmark.perfetto.ExperimentalPerfettoCaptureApi::class,
-    androidx.benchmark.perfetto.ExperimentalPerfettoTraceProcessorApi::class
+    androidx.benchmark.perfetto.ExperimentalPerfettoTraceProcessorApi::class,
 )
 
 package android.tools.traces.parsers.perfetto
@@ -40,6 +40,7 @@ class TraceProcessorSession(val session: PerfettoTraceProcessor.Session) {
     }
 
     companion object {
+        @JvmStatic
         fun <T> loadPerfettoTrace(trace: ByteArray, predicate: (TraceProcessorSession) -> T): T {
             return withTracing("TraceProcessorSession#loadPerfettoTrace") {
                 val traceFile = File.createTempFile(TraceType.SF.fileName, "")
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransactionsTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransactionsTraceParser.kt
index 073acde1c..ff3251b52 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransactionsTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransactionsTraceParser.kt
@@ -27,7 +27,10 @@ import kotlin.math.min
 /** Parser for [TransactionsTrace] */
 class TransactionsTraceParser :
     AbstractTraceParser<
-        TraceProcessorSession, TransactionsTraceEntry, TransactionsTraceEntry, TransactionsTrace
+        TraceProcessorSession,
+        TransactionsTraceEntry,
+        TransactionsTraceEntry,
+        TransactionsTrace,
     >() {
 
     override val traceName = "Layers trace (SF)"
@@ -98,7 +101,7 @@ class TransactionsTraceParser :
 
         private fun buildTraceEntry(
             rows: List<Row>,
-            realToMonotonicTimeOffsetNs: Long
+            realToMonotonicTimeOffsetNs: Long,
         ): TransactionsTraceEntry {
             val args = Args.build(rows)
             val transactions: Collection<Transaction> =
@@ -110,19 +113,18 @@ class TransactionsTraceParser :
                         transaction.getChild("post_time")?.getLong() ?: -1,
                         transaction.getChild("transaction_id")?.getLong() ?: -1,
                         transaction.getChildren("merged_transaction_ids")?.map { it.getLong() }
-                            ?: emptyList()
+                            ?: emptyList(),
                     )
-                }
-                    ?: emptyList()
+                } ?: emptyList()
 
             val traceEntry =
                 TransactionsTraceEntry(
                     CrossPlatform.timestamp.from(
                         elapsedNanos = args.getChild("elapsed_realtime_nanos")?.getLong() ?: 0,
-                        elapsedOffsetNanos = realToMonotonicTimeOffsetNs
+                        elapsedOffsetNanos = realToMonotonicTimeOffsetNs,
                     ),
                     args.getChild("vsync_id")?.getLong() ?: -1,
-                    transactions
+                    transactions,
                 )
 
             transactions.forEach { it.appliedInEntry = traceEntry }
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
index 820ebb602..132785b0f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/TransitionsTraceParser.kt
@@ -87,7 +87,7 @@ class TransitionsTraceParser :
 
         private fun buildTransition(
             transitionRows: List<Row>,
-            handlerMapping: Map<Int, String>
+            handlerMapping: Map<Int, String>,
         ): Transition {
             val args = Args.build(transitionRows)
             return Transition(
@@ -118,7 +118,7 @@ class TransitionsTraceParser :
                                         it.getChild("window_id")?.getInt()
                                             ?: error(
                                                 "Missing window id ${it.getChild("window_id")}"
-                                            )
+                                            ),
                                     )
                                 }
                                 ?.ifEmpty { null },
@@ -132,7 +132,7 @@ class TransitionsTraceParser :
                         abortTime = args.getChild("shell_abort_time_ns")?.getLong()?.toTimestamp(),
                         handler = args.getChild("handler")?.getInt()?.let { handlerMapping[it] },
                         mergeTarget = args.getChild("merge_target")?.getInt(),
-                    )
+                    ),
             )
         }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerStateBuilder.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerStateBuilder.kt
index b59819383..107b504ad 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerStateBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerStateBuilder.kt
@@ -90,7 +90,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             keyguardControllerState =
                 buildKeyguardControllerState(
                     service.getChild("root_window_container")?.getChild("keyguard_controller")
-                )
+                ),
         )
     }
 
@@ -132,7 +132,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                 windowManagerPolicyProto.getChild("screen_on_fully")?.getBoolean() ?: false,
             windowManagerDrawComplete =
                 windowManagerPolicyProto.getChild("window_manager_draw_complete")?.getBoolean()
-                    ?: false
+                    ?: false,
         )
     }
 
@@ -142,7 +142,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                 windowContainerProto = rootWindowContainerProto.getChild("window_container"),
                 windowContainerChildProtos =
                     rootWindowContainerProto.getChild("window_container")?.getChildren("children"),
-                isActivityInTree = false
+                isActivityInTree = false,
             ) ?: error("Window container should not be null")
 
         return RootWindowContainer(windowContainer)
@@ -153,7 +153,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
         windowContainerChildProtos: List<Args>?,
         isActivityInTree: Boolean,
         nameOverride: String? = null,
-        visibleOverride: Boolean? = null
+        visibleOverride: Boolean? = null,
     ): WindowContainer? {
         if (windowContainerProto == null) {
             return null
@@ -183,7 +183,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             layerId =
                 windowContainerProto.getChild("surfaceControl")?.getChild("layerId")?.getInt() ?: 0,
             _children = children,
-            computedZ = computedZCounter++
+            computedZ = computedZCounter++,
         )
     }
 
@@ -198,7 +198,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             mergedOverrideConfiguration =
                 buildConfiguration(
                     configurationContainerProto?.getChild("merged_override_configuration")
-                )
+                ),
         )
     }
 
@@ -217,7 +217,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             smallestScreenWidthDp =
                 configurationProto.getChild("smallest_screen_width_dp")?.getInt() ?: 0,
             screenLayout = configurationProto.getChild("screen_layout")?.getInt() ?: 0,
-            uiMode = configurationProto.getChild("ui_mode")?.getInt() ?: 0
+            uiMode = configurationProto.getChild("ui_mode")?.getInt() ?: 0,
         )
     }
 
@@ -231,7 +231,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             bounds = buildRect(windowConfigurationProto.getChild("bounds")),
             maxBounds = buildRect(windowConfigurationProto.getChild("max_bounds")),
             windowingMode = windowConfigurationProto.getChild("windowing_mode")?.getInt() ?: 0,
-            activityType = windowConfigurationProto.getChild("activity_type")?.getInt() ?: 0
+            activityType = windowConfigurationProto.getChild("activity_type")?.getInt() ?: 0,
         )
     }
 
@@ -247,43 +247,43 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     val displayId = it.getChild("display_id")?.getInt() ?: 0
                     val keyguardOccuded = it.getChild("keyguard_occluded")?.getBoolean() ?: false
                     displayId to keyguardOccuded
-                } ?: emptyMap()
+                } ?: emptyMap(),
         )
     }
 
     private fun buildWindowContainerChild(
         windowContainerChildProto: Args,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): WindowContainer? {
         return buildDisplayContent(
             windowContainerChildProto.getChild("display_content"),
-            isActivityInTree
+            isActivityInTree,
         )
             ?: buildDisplayArea(
                 windowContainerChildProto.getChild("display_area"),
-                isActivityInTree
+                isActivityInTree,
             )
             ?: buildTask(windowContainerChildProto.getChild("task"), isActivityInTree)
             ?: buildTaskFragment(
                 windowContainerChildProto.getChild("task_fragment"),
-                isActivityInTree
+                isActivityInTree,
             )
             ?: buildActivity(windowContainerChildProto.getChild("activity"))
             ?: buildWindowToken(
                 windowContainerChildProto.getChild("window_token"),
-                isActivityInTree
+                isActivityInTree,
             )
             ?: buildWindowState(windowContainerChildProto.getChild("window"), isActivityInTree)
             ?: buildWindowContainer(
                 windowContainerChildProto.getChild("window_container"),
                 windowContainerChildProtos = null,
-                isActivityInTree = isActivityInTree
+                isActivityInTree = isActivityInTree,
             )
     }
 
     private fun buildDisplayContent(
         displayContentProto: Args?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): DisplayContent? {
         if (displayContentProto == null) {
             return null
@@ -320,7 +320,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     displayContentProto
                         .getChild("display_info")
                         ?.getChild("logical_height")
-                        ?.getInt() ?: 0
+                        ?.getInt() ?: 0,
                 ),
             appRect =
                 Rect(
@@ -329,7 +329,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     displayContentProto.getChild("display_info")?.getChild("app_width")?.getInt()
                         ?: 0,
                     displayContentProto.getChild("display_info")?.getChild("app_height")?.getInt()
-                        ?: 0
+                        ?: 0,
                 ),
             dpi = displayContentProto.getChild("dpi")?.getInt() ?: 0,
             flags = displayContentProto.getChild("display_info")?.getChild("flags")?.getInt() ?: 0,
@@ -365,7 +365,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                 ),
             insetsSourceProviders =
                 buildInsetsSourceProviders(
-                    displayContentProto.getChildren("insets_source_providers"),
+                    displayContentProto.getChildren("insets_source_providers")
                 ),
             windowContainer =
                 buildWindowContainer(
@@ -381,8 +381,8 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     isActivityInTree = isActivityInTree,
                     nameOverride =
                         displayContentProto.getChild("display_info")?.getChild("name")?.getString()
-                            ?: ""
-                ) ?: error("Window container should not be null")
+                            ?: "",
+                ) ?: error("Window container should not be null"),
         )
     }
 
@@ -400,7 +400,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     windowContainerChildProtos =
                         displayAreaProto.getChild("window_container")?.getChildren("children"),
                     isActivityInTree = isActivityInTree,
-                ) ?: error("Window container should not be null")
+                ) ?: error("Window container should not be null"),
         )
     }
 
@@ -454,14 +454,14 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                         } else {
                             taskProto.getChild("window_container")?.getChildren("children")
                         },
-                    isActivityInTree = isActivityInTree
-                ) ?: error("Window container should not be null")
+                    isActivityInTree = isActivityInTree,
+                ) ?: error("Window container should not be null"),
         )
     }
 
     private fun buildTaskFragment(
         taskFragmentProto: Args?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): TaskFragment? {
         if (taskFragmentProto == null) {
             return null
@@ -477,8 +477,8 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                     windowContainerProto = taskFragmentProto.getChild("window_container"),
                     windowContainerChildProtos =
                         taskFragmentProto.getChild("window_container")?.getChildren("children"),
-                    isActivityInTree = isActivityInTree
-                ) ?: error("Window container should not be null")
+                    isActivityInTree = isActivityInTree,
+                ) ?: error("Window container should not be null"),
         )
     }
 
@@ -502,8 +502,8 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                             ?.getChild("window_container")
                             ?.getChildren("children"),
                     isActivityInTree = true,
-                    nameOverride = activityRecordProto.getChild("name")?.getString() ?: ""
-                ) ?: error("Window container should not be null")
+                    nameOverride = activityRecordProto.getChild("name")?.getString() ?: "",
+                ) ?: error("Window container should not be null"),
         )
     }
 
@@ -517,7 +517,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                 windowContainerProto = windowTokenProto.getChild("window_container"),
                 windowContainerChildProtos =
                     windowTokenProto.getChild("window_container")?.getChildren("children"),
-                isActivityInTree = isActivityInTree
+                isActivityInTree = isActivityInTree,
             ) ?: error("Window container should not be null")
         )
     }
@@ -562,7 +562,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             requestedSize =
                 Size.from(
                     windowStateProto.getChild("requested_width")?.getInt() ?: 0,
-                    windowStateProto.getChild("requested_height")?.getInt() ?: 0
+                    windowStateProto.getChild("requested_height")?.getInt() ?: 0,
                 ),
             surfacePosition = buildRect(windowStateProto.getChild("surface_position")),
             frame = buildRect(windowStateProto.getChild("window_frames")?.getChild("frame")),
@@ -597,9 +597,9 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
                                     )
                                 else -> identifierName
                             }
-                        )
+                        ),
                 ) ?: error("Window container should not be null"),
-            isAppWindow = isActivityInTree
+            isAppWindow = isActivityInTree,
         )
     }
 
@@ -614,7 +614,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             buildRect(displayCutoutProto.getChild("bound_top")),
             buildRect(displayCutoutProto.getChild("bound_right")),
             buildRect(displayCutoutProto.getChild("bound_bottom")),
-            buildInsets(displayCutoutProto.getChild("waterfall_insets"))
+            buildInsets(displayCutoutProto.getChild("waterfall_insets")),
         )
     }
 
@@ -637,7 +637,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             ?.map {
                 InsetsSourceProvider(
                     buildRect(it.getChild("frame")),
-                    buildInsetsSource(it.getChild("source"))
+                    buildInsetsSource(it.getChild("source")),
                 )
             }
             ?.toTypedArray() ?: emptyArray<InsetsSourceProvider>()
@@ -695,7 +695,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             fitInsetsTypes = windowLayoutParamsProto?.getChild("fit_insets_types")?.getInt() ?: 0,
             fitInsetsSides = windowLayoutParamsProto?.getChild("fit_insets_sides")?.getInt() ?: 0,
             fitIgnoreVisibility =
-                windowLayoutParamsProto?.getChild("fit_ignore_visibility")?.getBoolean() ?: false
+                windowLayoutParamsProto?.getChild("fit_ignore_visibility")?.getBoolean() ?: false,
         )
     }
 
@@ -708,7 +708,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             rectProto?.getChild("left")?.getInt() ?: 0,
             rectProto?.getChild("top")?.getInt() ?: 0,
             rectProto?.getChild("right")?.getInt() ?: 0,
-            rectProto?.getChild("bottom")?.getInt() ?: 0
+            rectProto?.getChild("bottom")?.getInt() ?: 0,
         )
     }
 
@@ -717,7 +717,7 @@ class WindowManagerStateBuilder(val entry: Args, val realToElapsedTimeOffsetNs:
             rectProto?.getChild("left")?.getInt() ?: 0,
             rectProto?.getChild("top")?.getInt() ?: 0,
             rectProto?.getChild("right")?.getInt() ?: 0,
-            rectProto?.getChild("bottom")?.getInt() ?: 0
+            rectProto?.getChild("bottom")?.getInt() ?: 0,
         )
 
     private fun getWindowTitle(title: String): String {
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerTraceParser.kt
index e325989d8..00560c0c8 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/perfetto/WindowManagerTraceParser.kt
@@ -26,7 +26,7 @@ class WindowManagerTraceParser :
         TraceProcessorSession,
         WindowManagerState,
         WindowManagerState,
-        WindowManagerTrace
+        WindowManagerTrace,
     >() {
     override val traceName: String = "WM Trace"
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/view/ViewFrameBuilder.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/view/ViewFrameBuilder.kt
index 7eef97385..e0b7015bd 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/view/ViewFrameBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/view/ViewFrameBuilder.kt
@@ -43,7 +43,7 @@ class ViewFrameBuilder {
                     node.left,
                     node.top,
                     /* right */ node.left + node.width,
-                    /* bottom */ node.top + node.height
+                    /* bottom */ node.top + node.height,
                 ),
             scroll = Point(node.scrollX, node.scrollY),
             translation = PointF(node.translationX, node.translationY),
@@ -53,7 +53,7 @@ class ViewFrameBuilder {
             clipChildren = node.clipChildren,
             visibility = node.visibility,
             elevation = node.elevation.toDouble(),
-            children = node.childrenList.map { parseViewNode(it) }
+            children = node.childrenList.map { parseViewNode(it) },
         )
 
     fun build(): ViewFrame {
@@ -64,7 +64,7 @@ class ViewFrameBuilder {
 
         return ViewFrame(
             timestamp = Timestamps.from(systemUptimeNanos = systemUptimeNanos),
-            root = parseViewNode(root)
+            root = parseViewNode(root),
         )
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyWindowManagerTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyWindowManagerTraceParser.kt
index 9ccf18834..7c9c1f993 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyWindowManagerTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/LegacyWindowManagerTraceParser.kt
@@ -30,7 +30,7 @@ open class LegacyWindowManagerTraceParser(private val legacyTrace: Boolean = fal
         WindowManagerTraceFileProto,
         WindowManagerTraceProto,
         WindowManagerState,
-        WindowManagerTrace
+        WindowManagerTrace,
     >() {
     private var realToElapsedTimeOffsetNanos = 0L
 
@@ -48,7 +48,7 @@ open class LegacyWindowManagerTraceParser(private val legacyTrace: Boolean = fal
         require(legacyTrace || realToElapsedTimeOffsetNanos != 0L)
         return Timestamps.from(
             elapsedNanos = entry.elapsedRealtimeNanos,
-            unixNanos = entry.elapsedRealtimeNanos + realToElapsedTimeOffsetNanos
+            unixNanos = entry.elapsedRealtimeNanos + realToElapsedTimeOffsetNanos,
         )
     }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/ShellTransitionTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/ShellTransitionTraceParser.kt
index ee615d050..f289d2f96 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/ShellTransitionTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/ShellTransitionTraceParser.kt
@@ -30,7 +30,7 @@ class ShellTransitionTraceParser :
         WmShellTransitionTraceProto,
         Transition,
         android.tools.traces.wm.Transition,
-        TransitionsTrace
+        TransitionsTrace,
     >() {
     override val traceName: String = "Transition trace (shell)"
 
@@ -83,7 +83,7 @@ class ShellTransitionTraceParser :
         input: WmShellTransitionTraceProto,
         from: Timestamp,
         to: Timestamp,
-        addInitialEntry: Boolean
+        addInitialEntry: Boolean,
     ): TransitionsTrace {
         val uncompressedTransitionsTrace = super.doParse(input, from, to, addInitialEntry)
         return uncompressedTransitionsTrace.asCompressed()
@@ -124,8 +124,8 @@ class ShellTransitionTraceParser :
                             Timestamps.from(elapsedNanos = entry.abortTimeNs)
                         },
                     handler = handlerMapping[entry.handler],
-                    mergeTarget = if (entry.mergeTarget == 0) null else entry.mergeTarget
-                )
+                    mergeTarget = if (entry.mergeTarget == 0) null else entry.mergeTarget,
+                ),
         )
     }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WindowManagerStateBuilder.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WindowManagerStateBuilder.kt
index 8783bd04c..c6d4ac662 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WindowManagerStateBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WindowManagerStateBuilder.kt
@@ -128,7 +128,7 @@ class WindowManagerStateBuilder {
             rotation = Rotation.getByValue(proto.rotation),
             rotationMode = proto.rotationMode,
             screenOnFully = proto.screenOnFully,
-            windowManagerDrawComplete = proto.windowManagerDrawComplete
+            windowManagerDrawComplete = proto.windowManagerDrawComplete,
         )
     }
 
@@ -138,7 +138,7 @@ class WindowManagerStateBuilder {
                 proto.windowContainer,
                 proto.windowContainer.children.mapNotNull { p ->
                     createWindowContainerChild(p, isActivityInTree = false)
-                }
+                },
             ) ?: error("Window container should not be null")
         )
     }
@@ -151,13 +151,13 @@ class WindowManagerStateBuilder {
             isKeyguardShowing = proto?.keyguardShowing ?: false,
             keyguardOccludedStates =
                 proto?.keyguardOccludedStates?.associate { it.displayId to it.keyguardOccluded }
-                    ?: emptyMap()
+                    ?: emptyMap(),
         )
     }
 
     private fun createWindowContainerChild(
         proto: WindowContainerChildProto,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): WindowContainer? {
         return createDisplayContent(proto.displayContent, isActivityInTree)
             ?: createDisplayArea(proto.displayArea, isActivityInTree)
@@ -171,7 +171,7 @@ class WindowManagerStateBuilder {
 
     private fun createDisplayContent(
         proto: DisplayContentProto?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): DisplayContent? {
         return if (proto == null) {
             null
@@ -190,7 +190,7 @@ class WindowManagerStateBuilder {
                         0,
                         0,
                         proto.displayInfo?.logicalWidth ?: 0,
-                        proto.displayInfo?.logicalHeight ?: 0
+                        proto.displayInfo?.logicalHeight ?: 0,
                     ),
                 appRect =
                     Rect(0, 0, proto.displayInfo?.appWidth ?: 0, proto.displayInfo?.appHeight ?: 0),
@@ -213,15 +213,15 @@ class WindowManagerStateBuilder {
                         proto.rootDisplayArea.windowContainer.children.mapNotNull { p ->
                             createWindowContainerChild(p, isActivityInTree)
                         },
-                        nameOverride = proto.displayInfo?.name ?: ""
-                    ) ?: error("Window container should not be null")
+                        nameOverride = proto.displayInfo?.name ?: "",
+                    ) ?: error("Window container should not be null"),
             )
         }
     }
 
     private fun createDisplayArea(
         proto: DisplayAreaProto?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): DisplayArea? {
         return if (proto == null) {
             null
@@ -233,8 +233,8 @@ class WindowManagerStateBuilder {
                         proto.windowContainer,
                         proto.windowContainer.children.mapNotNull { p ->
                             createWindowContainerChild(p, isActivityInTree)
-                        }
-                    ) ?: error("Window container should not be null")
+                        },
+                    ) ?: error("Window container should not be null"),
             )
         }
     }
@@ -272,15 +272,15 @@ class WindowManagerStateBuilder {
                             proto.windowContainer.children.mapNotNull { p ->
                                 createWindowContainerChild(p, isActivityInTree)
                             }
-                        }
-                    ) ?: error("Window container should not be null")
+                        },
+                    ) ?: error("Window container should not be null"),
             )
         }
     }
 
     private fun createTaskFragment(
         proto: TaskFragmentProto?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): TaskFragment? {
         return if (proto == null) {
             null
@@ -295,8 +295,8 @@ class WindowManagerStateBuilder {
                         proto.windowContainer,
                         proto.windowContainer.children.mapNotNull { p ->
                             createWindowContainerChild(p, isActivityInTree)
-                        }
-                    ) ?: error("Window container should not be null")
+                        },
+                    ) ?: error("Window container should not be null"),
             )
         }
     }
@@ -316,15 +316,15 @@ class WindowManagerStateBuilder {
                         proto.windowToken.windowContainer.children.mapNotNull { p ->
                             createWindowContainerChild(p, isActivityInTree = true)
                         },
-                        nameOverride = proto.name
-                    ) ?: error("Window container should not be null")
+                        nameOverride = proto.name,
+                    ) ?: error("Window container should not be null"),
             )
         }
     }
 
     private fun createWindowToken(
         proto: WindowTokenProto?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): WindowToken? {
         return if (proto == null) {
             null
@@ -334,7 +334,7 @@ class WindowManagerStateBuilder {
                     proto.windowContainer,
                     proto.windowContainer.children.mapNotNull { p ->
                         createWindowContainerChild(p, isActivityInTree)
-                    }
+                    },
                 ) ?: error("Window container should not be null")
             )
         }
@@ -342,7 +342,7 @@ class WindowManagerStateBuilder {
 
     private fun createWindowState(
         proto: WindowStateProto?,
-        isActivityInTree: Boolean
+        isActivityInTree: Boolean,
     ): WindowState? {
         return if (proto == null) {
             null
@@ -397,9 +397,9 @@ class WindowManagerStateBuilder {
                                         )
                                     else -> identifierName
                                 }
-                            )
+                            ),
                     ) ?: error("Window container should not be null"),
-                isAppWindow = isActivityInTree
+                isAppWindow = isActivityInTree,
             )
         }
     }
@@ -435,7 +435,7 @@ class WindowManagerStateBuilder {
             behavior = proto?.behavior ?: 0,
             fitInsetsTypes = proto?.fitInsetsTypes ?: 0,
             fitInsetsSides = proto?.fitInsetsSides ?: 0,
-            fitIgnoreVisibility = proto?.fitIgnoreVisibility ?: false
+            fitIgnoreVisibility = proto?.fitIgnoreVisibility ?: false,
         )
     }
 
@@ -445,7 +445,7 @@ class WindowManagerStateBuilder {
         return ConfigurationContainerImpl.from(
             overrideConfiguration = createConfiguration(proto?.overrideConfiguration),
             fullConfiguration = createConfiguration(proto?.fullConfiguration),
-            mergedOverrideConfiguration = createConfiguration(proto?.mergedOverrideConfiguration)
+            mergedOverrideConfiguration = createConfiguration(proto?.mergedOverrideConfiguration),
         )
     }
 
@@ -466,7 +466,7 @@ class WindowManagerStateBuilder {
                 screenWidthDp = proto.screenWidthDp,
                 smallestScreenWidthDp = proto.smallestScreenWidthDp,
                 screenLayout = proto.screenLayout,
-                uiMode = proto.uiMode
+                uiMode = proto.uiMode,
             )
         }
     }
@@ -477,7 +477,7 @@ class WindowManagerStateBuilder {
             bounds = proto.bounds?.toRect(),
             maxBounds = proto.maxBounds?.toRect(),
             windowingMode = proto.windowingMode,
-            activityType = proto.activityType
+            activityType = proto.activityType,
         )
     }
 
@@ -485,7 +485,7 @@ class WindowManagerStateBuilder {
         proto: WindowContainerProto?,
         children: List<WindowContainer>,
         nameOverride: String? = null,
-        visibleOverride: Boolean? = null
+        visibleOverride: Boolean? = null,
     ): WindowContainer? {
         return if (proto == null) {
             null
@@ -498,7 +498,7 @@ class WindowManagerStateBuilder {
                 configurationContainer = createConfigurationContainer(proto.configurationContainer),
                 layerId = proto.surfaceControl?.layerId ?: 0,
                 _children = children,
-                computedZ = computedZCounter++
+                computedZ = computedZCounter++,
             )
         }
     }
@@ -513,7 +513,7 @@ class WindowManagerStateBuilder {
                 proto.boundTop?.toRect() ?: Rect(),
                 proto.boundRight?.toRect() ?: Rect(),
                 proto.boundBottom?.toRect() ?: Rect(),
-                proto.waterfallInsets?.toInsets() ?: Insets.NONE
+                proto.waterfallInsets?.toInsets() ?: Insets.NONE,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WmTransitionTraceParser.kt b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WmTransitionTraceParser.kt
index dece2f177..5605027ce 100644
--- a/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WmTransitionTraceParser.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/parsers/wm/WmTransitionTraceParser.kt
@@ -29,7 +29,10 @@ import com.android.server.wm.shell.nano.TransitionTraceProto
 /** Parser for [TransitionsTrace] objects */
 class WmTransitionTraceParser :
     AbstractTraceParser<
-        TransitionTraceProto, Transition, android.tools.traces.wm.Transition, TransitionsTrace
+        TransitionTraceProto,
+        Transition,
+        android.tools.traces.wm.Transition,
+        TransitionsTrace,
     >() {
     override val traceName: String = "Transition trace (WM)"
 
@@ -78,7 +81,7 @@ class WmTransitionTraceParser :
         input: TransitionTraceProto,
         from: Timestamp,
         to: Timestamp,
-        addInitialEntry: Boolean
+        addInitialEntry: Boolean,
     ): TransitionsTrace {
         val uncompressedTransitionsTrace = super.doParse(input, from, to, addInitialEntry)
         return uncompressedTransitionsTrace.asCompressed()
@@ -95,11 +98,7 @@ class WmTransitionTraceParser :
                 null
             } else {
                 entry.targets.map {
-                    TransitionChange(
-                        TransitionType.fromInt(it.mode),
-                        it.layerId,
-                        it.windowId,
-                    )
+                    TransitionChange(TransitionType.fromInt(it.mode), it.layerId, it.windowId)
                 }
             }
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/region/RegionTrace.kt b/libraries/flicker/utils/src/android/tools/traces/region/RegionTrace.kt
index f1b28b092..a6356ae20 100644
--- a/libraries/flicker/utils/src/android/tools/traces/region/RegionTrace.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/region/RegionTrace.kt
@@ -30,7 +30,7 @@ import android.tools.traces.component.IComponentMatcher
  */
 data class RegionTrace(
     val components: IComponentMatcher?,
-    override val entries: Collection<RegionEntry>
+    override val entries: Collection<RegionEntry>,
 ) : Trace<RegionEntry> {
 
     override fun slice(startTimestamp: Timestamp, endTimestamp: Timestamp): Trace<RegionEntry> {
@@ -38,7 +38,7 @@ data class RegionTrace(
             components,
             entries
                 .dropWhile { it.timestamp < startTimestamp }
-                .dropLastWhile { it.timestamp > endTimestamp }
+                .dropLastWhile { it.timestamp > endTimestamp },
         )
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Display.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Display.kt
index 306a840fe..6edb5fb76 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Display.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Display.kt
@@ -111,6 +111,7 @@ private constructor(
                 )
             }
 
+        @JvmStatic
         fun from(
             id: Long,
             name: String,
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
index c4b6c13e9..68dcebd97 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Flag.kt
@@ -24,5 +24,5 @@ enum class Flag(val value: Int) {
     SECURE(0x80),
     ENABLE_BACKPRESSURE(0x100),
     DISPLAY_DECORATION(0x200),
-    IGNORE_DESTINATION_FRAME(0x400)
+    IGNORE_DESTINATION_FRAME(0x400),
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/HwcCompositionType.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/HwcCompositionType.kt
index d0f75c645..3878a423f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/HwcCompositionType.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/HwcCompositionType.kt
@@ -24,5 +24,5 @@ enum class HwcCompositionType(val value: Int) {
     HWC_TYPE_CURSOR(4),
     HWC_TYPE_SIDEBAND(5),
     HWC_TYPE_DISPLAY_DECORATION(6),
-    HWC_TYPE_UNRECOGNIZED(-1)
+    HWC_TYPE_UNRECOGNIZED(-1),
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/ILayerProperties.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/ILayerProperties.kt
index e7ab9682c..f60acdeb3 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/ILayerProperties.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/ILayerProperties.kt
@@ -29,7 +29,7 @@ import android.tools.datatypes.isNotEmpty
  * than the full layers
  */
 interface ILayerProperties {
-    val visibleRegion: Region?
+    val visibleRegion: Region
     val activeBuffer: ActiveBuffer
     val flags: Int
     val bounds: RectF
@@ -51,8 +51,10 @@ interface ILayerProperties {
 
     val isScaling: Boolean
         get() = transform.isScaling
+
     val isTranslating: Boolean
         get() = transform.isTranslating
+
     val isRotating: Boolean
         get() = transform.isRotating
 
@@ -125,6 +127,7 @@ interface ILayerProperties {
         get() {
             return fillsColor || drawsShadows
         }
+
     /**
      * Checks if the [Layer] has zero requested or inherited alpha
      *
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Layer.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Layer.kt
index 0de2cf7a2..616ea004b 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Layer.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Layer.kt
@@ -24,6 +24,7 @@ import android.tools.datatypes.containsWithThreshold
 import android.tools.datatypes.crop
 import android.tools.traces.component.ComponentName
 import androidx.core.graphics.toRect
+import com.android.internal.annotations.VisibleForTesting
 
 /**
  * Represents a single layer with links to its parent and child layers.
@@ -32,7 +33,8 @@ import androidx.core.graphics.toRect
  * Java/Android functionality
  */
 class Layer
-private constructor(
+@VisibleForTesting
+public constructor(
     val name: String,
     val id: Int,
     val parentId: Int,
@@ -60,12 +62,16 @@ private constructor(
     private val _coveredBy = mutableListOf<Layer>()
     val children: Collection<Layer>
         get() = _children
+
     val occludedBy: Collection<Layer>
         get() = _occludedBy
+
     val partiallyOccludedBy: Collection<Layer>
         get() = _partiallyOccludedBy
+
     val coveredBy: Collection<Layer>
         get() = _coveredBy
+
     var isMissing: Boolean = false
         internal set
 
@@ -313,6 +319,7 @@ private constructor(
     }
 
     companion object {
+        @JvmStatic
         fun from(
             name: String,
             id: Int,
@@ -337,7 +344,7 @@ private constructor(
             isRelativeOf: Boolean,
             zOrderRelativeOfId: Int,
             stackId: Int,
-            excludesCompositionState: Boolean
+            excludesCompositionState: Boolean,
         ): Layer {
             val properties =
                 LayerProperties.from(
@@ -359,7 +366,7 @@ private constructor(
                     isRelativeOf,
                     zOrderRelativeOfId,
                     stackId,
-                    excludesCompositionState
+                    excludesCompositionState,
                 )
             return Layer(name, id, parentId, z, currFrame, properties)
         }
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerProperties.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerProperties.kt
index 72515b034..83a06cb4a 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerProperties.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerProperties.kt
@@ -44,7 +44,7 @@ private constructor(
     override val isRelativeOf: Boolean = false,
     override val zOrderRelativeOfId: Int = 0,
     override val stackId: Int = 0,
-    override val excludesCompositionState: Boolean = false
+    override val excludesCompositionState: Boolean = false,
 ) : ILayerProperties {
     override val isOpaque: Boolean = if (color.alpha() != 1.0f) false else _isOpaque
 
@@ -138,7 +138,7 @@ private constructor(
             isRelativeOf: Boolean,
             zOrderRelativeOfId: Int,
             stackId: Int,
-            excludesCompositionState: Boolean
+            excludesCompositionState: Boolean,
         ): ILayerProperties {
             return withCache {
                 LayerProperties(
@@ -160,7 +160,7 @@ private constructor(
                     isRelativeOf,
                     zOrderRelativeOfId,
                     stackId,
-                    excludesCompositionState
+                    excludesCompositionState,
                 )
             }
         }
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerTraceEntry.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerTraceEntry.kt
index 68335f7b5..59728ef12 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerTraceEntry.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayerTraceEntry.kt
@@ -37,7 +37,7 @@ class LayerTraceEntry(
     val where: String,
     val displays: Collection<Display>,
     val vSyncId: Long,
-    _rootLayers: Collection<Layer>
+    _rootLayers: Collection<Layer>,
 ) : TraceEntry {
     override val timestamp =
         Timestamps.from(systemUptimeNanos = elapsedTimestamp, unixNanos = clockTimestamp)
@@ -85,7 +85,7 @@ class LayerTraceEntry(
      */
     fun isAnimating(
         prevState: LayerTraceEntry?,
-        componentMatcher: IComponentMatcher? = null
+        componentMatcher: IComponentMatcher? = null,
     ): Boolean {
         val curLayers =
             visibleLayers.filter {
@@ -167,8 +167,7 @@ class LayerTraceEntry(
                 displays
                     .firstOrNull { it.layerStackId == layer.stackId }
                     ?.layerStackSpace
-                    ?.toRectF()
-                    ?: RectF()
+                    ?.toRectF() ?: RectF()
 
             if (visible) {
                 val occludedBy =
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayersTrace.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayersTrace.kt
index c1841929c..d799708e7 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayersTrace.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/LayersTrace.kt
@@ -59,15 +59,13 @@ data class LayersTrace(override val entries: Collection<LayerTraceEntry>) : Trac
     fun getFirstEntryWithOnDisplayAfter(timestamp: Timestamp): LayerTraceEntry {
         return this.entries.firstOrNull {
             it.timestamp >= timestamp && it.displays.any { display -> display.isOn }
-        }
-            ?: error("No entry after $timestamp in layer trace with on display.")
+        } ?: error("No entry after $timestamp in layer trace with on display.")
     }
 
     fun getLastEntryWithOnDisplayBefore(timestamp: Timestamp): LayerTraceEntry {
         return this.entries.lastOrNull {
             it.timestamp <= timestamp && it.displays.any { display -> display.isOn }
-        }
-            ?: error("No entry before $timestamp in layer trace with on display.")
+        } ?: error("No entry before $timestamp in layer trace with on display.")
     }
 
     fun getLayerDescriptorById(layerId: Int): LayerDescriptor? {
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/TransactionsTraceEntry.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/TransactionsTraceEntry.kt
index c3353aaf7..4ef6b650f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/TransactionsTraceEntry.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/TransactionsTraceEntry.kt
@@ -22,5 +22,5 @@ import android.tools.TraceEntry
 class TransactionsTraceEntry(
     override val timestamp: Timestamp,
     val vSyncId: Long,
-    val transactions: Collection<Transaction>
+    val transactions: Collection<Transaction>,
 ) : TraceEntry
diff --git a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Transform.kt b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Transform.kt
index 27e4b4004..5b39428ac 100644
--- a/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Transform.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/surfaceflinger/Transform.kt
@@ -58,8 +58,10 @@ class Transform private constructor(val type: Int?, val matrix: Matrix33) {
 
     val isScaling: Boolean
         get() = type?.isFlagSet(SCALE_VAL) ?: false
+
     val isTranslating: Boolean
         get() = type?.isFlagSet(TRANSLATE_VAL) ?: false
+
     val isRotating: Boolean
         get() = type?.isFlagSet(ROTATE_VAL) ?: false
 
@@ -154,7 +156,7 @@ class Transform private constructor(val type: Int?, val matrix: Matrix33) {
             /* right */ arrayOf(leftTop.x, rightTop.x, leftBottom.x, rightBottom.x).minOrNull()
                 ?: 0f,
             /* bottom */ arrayOf(leftTop.y, rightTop.y, leftBottom.y, rightBottom.y).minOrNull()
-                ?: 0f
+                ?: 0f,
         )
     }
 
@@ -164,7 +166,7 @@ class Transform private constructor(val type: Int?, val matrix: Matrix33) {
         // |0    0     1 |     | 1 |
         return Vec2(
             matrix.dsdx * x + matrix.dsdy * y + matrix.tx,
-            matrix.dtdx * x + matrix.dtdy * y + matrix.ty
+            matrix.dtdx * x + matrix.dtdy * y + matrix.ty,
         )
     }
 
@@ -201,6 +203,7 @@ class Transform private constructor(val type: Int?, val matrix: Matrix33) {
         const val ROT_90_VAL = 0x0400 // (1 << 2 << 8)
         const val ROT_INVALID_VAL = 0x8000 // (0x80 << 8)
 
+        @JvmStatic
         fun isSimpleTransform(type: Int?): Boolean {
             return type?.isFlagClear(ROT_INVALID_VAL or SCALE_VAL) ?: false
         }
@@ -213,6 +216,7 @@ class Transform private constructor(val type: Int?, val matrix: Matrix33) {
             return this and bits == bits
         }
 
+        @JvmStatic
         fun from(type: Int?, matrix: Matrix33): Transform = withCache { Transform(type, matrix) }
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/view/ViewNode.kt b/libraries/flicker/utils/src/android/tools/traces/view/ViewNode.kt
index e750c6a1c..f4311d2a4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/view/ViewNode.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/view/ViewNode.kt
@@ -41,7 +41,7 @@ private constructor(
     val clipChildren: Boolean,
     val visibility: Int,
     val elevation: Double,
-    val children: Collection<ViewNode>
+    val children: Collection<ViewNode>,
 ) {
     override fun equals(other: Any?): Boolean {
         if (this === other) return true
@@ -85,6 +85,7 @@ private constructor(
         "ViewNode(classNameIndex=$classNameIndex, hashCode=$hashcode, id='$id', bounds=$bounds)"
 
     companion object {
+        @JvmStatic
         fun from(
             classNameIndex: Int,
             hashCode: Int,
@@ -98,7 +99,7 @@ private constructor(
             clipChildren: Boolean,
             visibility: Int,
             elevation: Double,
-            children: Collection<ViewNode>
+            children: Collection<ViewNode>,
         ): ViewNode = withCache {
             ViewNode(
                 classNameIndex,
@@ -113,7 +114,7 @@ private constructor(
                 clipChildren,
                 visibility,
                 elevation,
-                children
+                children,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/view/ViewTrace.kt b/libraries/flicker/utils/src/android/tools/traces/view/ViewTrace.kt
index f66546bbe..4f2ed091a 100644
--- a/libraries/flicker/utils/src/android/tools/traces/view/ViewTrace.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/view/ViewTrace.kt
@@ -34,7 +34,7 @@ data class ViewTrace(val windowTitle: String, override val entries: Collection<V
             windowTitle,
             entries
                 .dropWhile { it.timestamp < startTimestamp }
-                .dropLastWhile { it.timestamp > endTimestamp }
+                .dropLastWhile { it.timestamp > endTimestamp },
         )
 
     override fun toString(): String {
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/Activity.kt b/libraries/flicker/utils/src/android/tools/traces/wm/Activity.kt
index 4d7b7ab11..1917063ed 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/Activity.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/Activity.kt
@@ -30,7 +30,7 @@ class Activity(
     val frontOfTask: Boolean,
     val procId: Int,
     val isTranslucent: Boolean,
-    private val windowContainer: WindowContainer
+    private val windowContainer: WindowContainer,
 ) : WindowContainer by windowContainer {
     /**
      * Checks if the activity contains a [WindowState] matching [componentMatcher]
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/Configuration.kt b/libraries/flicker/utils/src/android/tools/traces/wm/Configuration.kt
index e185b703e..ac3fbec77 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/Configuration.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/Configuration.kt
@@ -33,7 +33,7 @@ private constructor(
     val screenWidthDp: Int = 0,
     val smallestScreenWidthDp: Int = 0,
     val screenLayout: Int = 0,
-    val uiMode: Int = 0
+    val uiMode: Int = 0,
 ) {
     val isEmpty: Boolean
         get() =
@@ -86,7 +86,7 @@ private constructor(
             screenWidthDp: Int,
             smallestScreenWidthDp: Int,
             screenLayout: Int,
-            uiMode: Int
+            uiMode: Int,
         ): Configuration = withCache {
             Configuration(
                 windowConfiguration,
@@ -96,7 +96,7 @@ private constructor(
                 screenWidthDp,
                 smallestScreenWidthDp,
                 screenLayout,
-                uiMode
+                uiMode,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/ConfigurationContainerImpl.kt b/libraries/flicker/utils/src/android/tools/traces/wm/ConfigurationContainerImpl.kt
index 96503dd46..d2ab4acf5 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/ConfigurationContainerImpl.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/ConfigurationContainerImpl.kt
@@ -23,7 +23,7 @@ class ConfigurationContainerImpl
 private constructor(
     override val overrideConfiguration: Configuration?,
     override val fullConfiguration: Configuration?,
-    override val mergedOverrideConfiguration: Configuration?
+    override val mergedOverrideConfiguration: Configuration?,
 ) : ConfigurationContainer {
     override val windowingMode: Int
         get() = fullConfiguration?.windowConfiguration?.windowingMode ?: 0
@@ -33,8 +33,7 @@ private constructor(
 
     override val isEmpty: Boolean
         get() =
-            (overrideConfiguration?.isEmpty
-                ?: true) &&
+            (overrideConfiguration?.isEmpty ?: true) &&
                 (fullConfiguration?.isEmpty ?: true) &&
                 (mergedOverrideConfiguration?.isEmpty ?: true)
 
@@ -70,12 +69,12 @@ private constructor(
         fun from(
             overrideConfiguration: Configuration?,
             fullConfiguration: Configuration?,
-            mergedOverrideConfiguration: Configuration?
+            mergedOverrideConfiguration: Configuration?,
         ): ConfigurationContainerImpl = withCache {
             ConfigurationContainerImpl(
                 overrideConfiguration,
                 fullConfiguration,
-                mergedOverrideConfiguration
+                mergedOverrideConfiguration,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/DisplayContent.kt b/libraries/flicker/utils/src/android/tools/traces/wm/DisplayContent.kt
index 73a1d771e..e8bde2ba4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/DisplayContent.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/DisplayContent.kt
@@ -52,7 +52,7 @@ class DisplayContent(
     val lastOrientation: Int,
     val cutout: DisplayCutout?,
     val insetsSourceProviders: Array<InsetsSourceProvider>,
-    private val windowContainer: WindowContainer
+    private val windowContainer: WindowContainer,
 ) : WindowContainer by windowContainer {
     override val name: String = displayId.toString()
     override val isVisible: Boolean = false
@@ -178,6 +178,7 @@ class DisplayContent(
         /** From [com.android.systemui.shared.recents.utilities.Utilities] */
         const val TABLET_MIN_DPS = 600f
 
+        @JvmStatic
         fun dpiFromPx(size: Float, densityDpi: Int): Float {
             val densityRatio: Float = densityDpi.toFloat() / DENSITY_DEFAULT
             return size / densityRatio
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/DisplayCutout.kt b/libraries/flicker/utils/src/android/tools/traces/wm/DisplayCutout.kt
index cb555adfa..aa1f4452b 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/DisplayCutout.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/DisplayCutout.kt
@@ -28,7 +28,7 @@ private constructor(
     val boundTop: Rect,
     val boundRight: Rect,
     val boundBottom: Rect,
-    val waterfallInsets: Insets
+    val waterfallInsets: Insets,
 ) {
     override fun equals(other: Any?): Boolean {
         if (this === other) return true
@@ -72,7 +72,7 @@ private constructor(
             boundTop: Rect,
             boundRight: Rect,
             boundBottom: Rect,
-            waterfallInsets: Insets
+            waterfallInsets: Insets,
         ): DisplayCutout = withCache {
             DisplayCutout(insets, boundLeft, boundTop, boundRight, boundBottom, waterfallInsets)
         }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/InsetsSource.kt b/libraries/flicker/utils/src/android/tools/traces/wm/InsetsSource.kt
index ad4d25a7f..7e4f44bce 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/InsetsSource.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/InsetsSource.kt
@@ -39,7 +39,7 @@ class InsetsSource private constructor(val type: Int, val frame: Rect, val visib
     }
 
     override fun toString(): String {
-        return "InsetsSource(" + "type=$type, " + "frame=$frame, " + "visible=$visible" + ")"
+        return "InsetsSource(type=$type, frame=$frame, visible=$visible)"
     }
 
     companion object {
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/KeyguardControllerState.kt b/libraries/flicker/utils/src/android/tools/traces/wm/KeyguardControllerState.kt
index 69e74deb1..1027bcfc9 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/KeyguardControllerState.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/KeyguardControllerState.kt
@@ -28,7 +28,7 @@ class KeyguardControllerState
 private constructor(
     val isAodShowing: Boolean,
     val isKeyguardShowing: Boolean,
-    val keyguardOccludedStates: Map<Int, Boolean>
+    val keyguardOccludedStates: Map<Int, Boolean>,
 ) {
     fun isKeyguardOccluded(displayId: Int): Boolean = keyguardOccludedStates[displayId] ?: false
 
@@ -55,10 +55,11 @@ private constructor(
     }
 
     companion object {
+        @JvmStatic
         fun from(
             isAodShowing: Boolean,
             isKeyguardShowing: Boolean,
-            keyguardOccludedStates: Map<Int, Boolean>
+            keyguardOccludedStates: Map<Int, Boolean>,
         ): KeyguardControllerState = withCache {
             KeyguardControllerState(isAodShowing, isKeyguardShowing, keyguardOccludedStates)
         }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/RotationAnimation.kt b/libraries/flicker/utils/src/android/tools/traces/wm/RotationAnimation.kt
index 35663d706..75e898b06 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/RotationAnimation.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/RotationAnimation.kt
@@ -23,6 +23,7 @@ enum class RotationAnimation(val value: Int) {
     ROTATION_ANIMATION_SEAMLESS(3);
 
     companion object {
+        @JvmStatic
         fun fromName(name: String?): RotationAnimation? {
             return name?.let { RotationAnimation.values().find { it.name == name } }
         }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/Task.kt b/libraries/flicker/utils/src/android/tools/traces/wm/Task.kt
index 643690bbb..1aaaf3d49 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/Task.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/Task.kt
@@ -43,21 +43,25 @@ class Task(
     val createdByOrganizer: Boolean,
     val minWidth: Int,
     val minHeight: Int,
-    private val windowContainer: WindowContainer
+    private val windowContainer: WindowContainer,
 ) : WindowContainer by windowContainer {
     override val isVisible: Boolean = false
     override val name: String = taskId.toString()
     override val isEmpty: Boolean
         get() = tasks.isEmpty() && activities.isEmpty()
+
     override val stableId: String
         get() = "${this::class.simpleName} $token $title $taskId"
 
     val isRootTask: Boolean
         get() = taskId == rootTaskId
+
     val tasks: Collection<Task>
         get() = this.children.reversed().filterIsInstance<Task>()
+
     val taskFragments: Collection<TaskFragment>
         get() = this.children.reversed().filterIsInstance<TaskFragment>()
+
     val activities: Collection<Activity>
         get() = this.children.reversed().filterIsInstance<Activity>()
 
@@ -66,6 +70,7 @@ class Task(
     //       so the indices are inverted
     val topTask: Task?
         get() = tasks.firstOrNull()
+
     val resumedActivities: Collection<String>
         get() {
             val result = mutableListOf<String>()
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/TaskFragment.kt b/libraries/flicker/utils/src/android/tools/traces/wm/TaskFragment.kt
index 13b60d556..f119ba1f4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/TaskFragment.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/TaskFragment.kt
@@ -27,7 +27,7 @@ class TaskFragment(
     val displayId: Int,
     val minWidth: Int,
     val minHeight: Int,
-    private val windowContainer: WindowContainer
+    private val windowContainer: WindowContainer,
 ) : WindowContainer by windowContainer {
     val tasks: Collection<Task>
         get() = this.children.reversed().filterIsInstance<Task>()
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/TransitMode.kt b/libraries/flicker/utils/src/android/tools/traces/wm/TransitMode.kt
index 78b9a3d4e..df3911062 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/TransitMode.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/TransitMode.kt
@@ -25,6 +25,6 @@ enum class TransitMode {
     TRANSIT_CHANGE;
 
     companion object {
-        fun fromInt(value: Int) = values().first { it.ordinal == value }
+        @JvmStatic fun fromInt(value: Int) = values().first { it.ordinal == value }
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt b/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
index 16f0f857f..c473218ec 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/Transition.kt
@@ -46,10 +46,15 @@ class Transition(
 
     override val timestamp =
         wmData.createTime
-            ?: wmData.sendTime ?: shellData.dispatchTime ?: shellData.mergeRequestTime
-                ?: shellData.mergeTime ?: shellData.abortTime ?: wmData.finishTime
-                ?: wmData.abortTime ?: wmData.startingWindowRemoveTime
-                ?: error("Missing non-null timestamp")
+            ?: wmData.sendTime
+            ?: shellData.dispatchTime
+            ?: shellData.mergeRequestTime
+            ?: shellData.mergeTime
+            ?: shellData.abortTime
+            ?: wmData.finishTime
+            ?: wmData.abortTime
+            ?: wmData.startingWindowRemoveTime
+            ?: error("Missing non-null timestamp")
 
     val createTime: Timestamp = wmData.createTime ?: Timestamps.min()
 
@@ -143,9 +148,9 @@ class Transition(
                         changes =
                             (wmData.changes?.toMutableList() ?: mutableListOf())
                                 .apply { addAll(transition.wmData.changes ?: emptyList()) }
-                                .toSet()
+                                .toSet(),
                     ),
-                shellData = shellData
+                shellData = shellData,
             )
 
         return mergedTransition
@@ -193,7 +198,7 @@ class Transition(
             return Transition(
                 id = transition1.id,
                 transition1.wmData.merge(transition2.wmData),
-                transition1.shellData.merge(transition2.shellData)
+                transition1.shellData.merge(transition2.shellData),
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionChange.kt b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionChange.kt
index 25b5981b1..82bad1d79 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionChange.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionChange.kt
@@ -18,11 +18,7 @@ package android.tools.traces.wm
 
 import android.tools.traces.surfaceflinger.LayersTrace
 
-class TransitionChange(
-    val transitMode: TransitionType,
-    val layerId: Int,
-    val windowId: Int,
-) {
+class TransitionChange(val transitMode: TransitionType, val layerId: Int, val windowId: Int) {
 
     override fun toString(): String = Formatter(null, null).format(this)
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionInfo.kt b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionInfo.kt
index a8d0e40c2..b1404719b 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionInfo.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionInfo.kt
@@ -17,8 +17,5 @@
 package android.tools.traces.wm
 
 data class TransitionInfo(val transitionId: Int, val changes: List<Change>) {
-    data class Change(
-        val layerId: Int,
-        val transitMode: TransitMode,
-    )
+    data class Change(val layerId: Int, val transitMode: TransitMode)
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionType.kt b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionType.kt
index c88606e41..3c24b21e3 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/TransitionType.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/TransitionType.kt
@@ -49,7 +49,13 @@ enum class TransitionType(val value: Int) {
     DESKTOP_MODE_CANCEL_DRAG_TO_DESKTOP(FIRST_CUSTOM.value + 13),
     DESKTOP_MODE_TOGGLE_RESIZE(FIRST_CUSTOM.value + 14),
     MOVE_TO_DESKTOP(FIRST_CUSTOM.value + 15),
-    RESIZE_PIP(FIRST_CUSTOM.value + 16);
+    RESIZE_PIP(FIRST_CUSTOM.value + 16),
+    TASK_FRAGMENT_DRAG_RESIZE(FIRST_CUSTOM.value + 17),
+    SPLIT_PASSTHROUGH(FIRST_CUSTOM.value + 18),
+    CLEANUP_PIP_EXIT(FIRST_CUSTOM.value + 19),
+    MINIMIZE(FIRST_CUSTOM.value + 20),
+    START_RECENTS_TRANSITION(FIRST_CUSTOM.value + 21),
+    END_RECENTS_TRANSITION(FIRST_CUSTOM.value + 22);
 
     companion object {
         fun fromInt(value: Int) = entries.first { it.value == value }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowConfiguration.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowConfiguration.kt
index 31c8668f0..9c47005f4 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowConfiguration.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowConfiguration.kt
@@ -30,7 +30,7 @@ open class WindowConfiguration(
     val bounds: Rect = Rect(),
     val maxBounds: Rect = Rect(),
     val windowingMode: Int = 0,
-    val activityType: Int = 0
+    val activityType: Int = 0,
 ) {
     val isEmpty: Boolean
         get() =
@@ -66,19 +66,20 @@ open class WindowConfiguration(
         val EMPTY: WindowConfiguration
             get() = withCache { WindowConfiguration() }
 
+        @JvmStatic
         fun from(
             appBounds: Rect?,
             bounds: Rect?,
             maxBounds: Rect?,
             windowingMode: Int,
-            activityType: Int
+            activityType: Int,
         ): WindowConfiguration = withCache {
             WindowConfiguration(
                 appBounds ?: Rect(),
                 bounds ?: Rect(),
                 maxBounds ?: Rect(),
                 windowingMode,
-                activityType
+                activityType,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowContainerImpl.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowContainerImpl.kt
index 9c5942daf..63fc8aeac 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowContainerImpl.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowContainerImpl.kt
@@ -34,7 +34,7 @@ class WindowContainerImpl(
     _isVisible: Boolean,
     private val configurationContainer: ConfigurationContainer,
     _children: Collection<WindowContainer>,
-    override val computedZ: Int
+    override val computedZ: Int,
 ) : ConfigurationContainer by configurationContainer, WindowContainer {
     override val id: Int = if (token.isEmpty()) -1 else token.toInt(16)
 
@@ -49,8 +49,10 @@ class WindowContainerImpl(
     override val isVisible: Boolean = _isVisible
     override val name: String
         get() = title
+
     override val stableId: String
         get() = "${this::class.simpleName} $token $title"
+
     override val isFullscreen: Boolean = false
     override val bounds: Rect = Rect()
 
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowLayoutParams.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowLayoutParams.kt
index cbff2c417..da4bb6748 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowLayoutParams.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowLayoutParams.kt
@@ -55,7 +55,7 @@ private constructor(
     val behavior: Int = 0,
     val fitInsetsTypes: Int = 0,
     val fitInsetsSides: Int = 0,
-    val fitIgnoreVisibility: Boolean = false
+    val fitIgnoreVisibility: Boolean = false,
 ) {
     val isValidNavBarType: Boolean = this.type == TYPE_NAVIGATION_BAR
 
@@ -187,7 +187,7 @@ private constructor(
             behavior: Int,
             fitInsetsTypes: Int,
             fitInsetsSides: Int,
-            fitIgnoreVisibility: Boolean
+            fitIgnoreVisibility: Boolean,
         ): WindowLayoutParams = withCache {
             WindowLayoutParams(
                 type,
@@ -219,7 +219,7 @@ private constructor(
                 behavior,
                 fitInsetsTypes,
                 fitInsetsSides,
-                fitIgnoreVisibility
+                fitIgnoreVisibility,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerPolicy.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerPolicy.kt
index 150930980..343e96745 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerPolicy.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerPolicy.kt
@@ -39,7 +39,7 @@ private constructor(
     val rotation: Rotation = Rotation.ROTATION_0,
     val rotationMode: Int = 0,
     val screenOnFully: Boolean = false,
-    val windowManagerDrawComplete: Boolean = false
+    val windowManagerDrawComplete: Boolean = false,
 ) {
     val isOrientationNoSensor: Boolean
         get() = orientation == SCREEN_ORIENTATION_NOSENSOR
@@ -144,7 +144,7 @@ private constructor(
             rotation: Rotation = Rotation.ROTATION_0,
             rotationMode: Int = 0,
             screenOnFully: Boolean = false,
-            windowManagerDrawComplete: Boolean = false
+            windowManagerDrawComplete: Boolean = false,
         ): WindowManagerPolicy = withCache {
             WindowManagerPolicy(
                 focusedAppToken,
@@ -159,7 +159,7 @@ private constructor(
                 rotation,
                 rotationMode,
                 screenOnFully,
-                windowManagerDrawComplete
+                windowManagerDrawComplete,
             )
         }
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
index 217740d84..cf8f94727 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerState.kt
@@ -44,7 +44,7 @@ class WindowManagerState(
     val isDisplayFrozen: Boolean,
     private val _pendingActivities: Collection<String>,
     val root: RootWindowContainer,
-    val keyguardControllerState: KeyguardControllerState
+    val keyguardControllerState: KeyguardControllerState,
 ) : TraceEntry {
     override val timestamp =
         Timestamps.from(elapsedNanos = elapsedTimestamp, unixNanos = clockTimestamp)
@@ -53,6 +53,7 @@ class WindowManagerState(
 
     val stableId: String
         get() = this::class.simpleName ?: error("Unable to determine class")
+
     val isTablet: Boolean
         get() = displays.any { it.isTablet }
 
@@ -87,10 +88,13 @@ class WindowManagerState(
 
     val appWindows: Collection<WindowState>
         get() = windowStates.filter { it.isAppWindow }
+
     val nonAppWindows: Collection<WindowState>
         get() = windowStates.filterNot { it.isAppWindow }
+
     val aboveAppWindows: Collection<WindowState>
         get() = windowStates.takeWhile { !appWindows.contains(it) }
+
     val belowAppWindows: Collection<WindowState>
         get() = windowStates.dropWhile { !appWindows.contains(it) }.drop(appWindows.size)
 
@@ -104,12 +108,16 @@ class WindowManagerState(
                 // for invisible checks it suffices if activity or window is invisible
                 windowIsVisible && (activityIsVisible || activities.isEmpty())
             }
+
     val visibleAppWindows: Collection<WindowState>
         get() = visibleWindows.filter { it.isAppWindow }
+
     val topVisibleAppWindow: WindowState?
         get() = visibleAppWindows.firstOrNull()
+
     val pinnedWindows: Collection<WindowState>
         get() = visibleWindows.filter { it.windowingMode == PlatformConsts.WINDOWING_MODE_PINNED }
+
     val pendingActivities: Collection<Activity>
         get() = _pendingActivities.mapNotNull { getActivityByName(it) }
 
@@ -118,6 +126,7 @@ class WindowManagerState(
 
     val isKeyguardShowing: Boolean
         get() = keyguardControllerState.isKeyguardShowing
+
     val isAodShowing: Boolean
         get() = keyguardControllerState.isAodShowing
 
@@ -127,8 +136,10 @@ class WindowManagerState(
      */
     val canRotate: Boolean
         get() = policy?.isFixedOrientation != true && policy?.isOrientationNoSensor != true
+
     val focusedDisplay: DisplayContent?
         get() = getDisplay(focusedDisplayId)
+
     val focusedStackId: Int
         get() = focusedDisplay?.focusedRootTaskId ?: -1
 
@@ -144,25 +155,34 @@ class WindowManagerState(
                 else -> null
             }
         }
+
     val resumedActivities: Collection<Activity>
         get() = rootTasks.flatMap { it.resumedActivities }.mapNotNull { getActivityByName(it) }
+
     val resumedActivitiesCount: Int
         get() = resumedActivities.size
+
     val stackCount: Int
         get() = rootTasks.size
+
     val homeTask: Task?
         get() = getStackByActivityType(PlatformConsts.ACTIVITY_TYPE_HOME)?.topTask
+
     val recentsTask: Task?
         get() = getStackByActivityType(PlatformConsts.ACTIVITY_TYPE_RECENTS)?.topTask
+
     val homeActivity: Activity?
         get() = homeTask?.activities?.lastOrNull()
+
     val isHomeActivityVisible: Boolean
         get() {
             val activity = homeActivity
             return activity != null && activity.isVisible
         }
+
     val recentsActivity: Activity?
         get() = recentsTask?.activities?.lastOrNull()
+
     val isRecentsActivityVisible: Boolean
         get() {
             return if (isHomeRecentsComponent) {
@@ -172,8 +192,10 @@ class WindowManagerState(
                 activity != null && activity.isVisible
             }
         }
+
     val frontWindow: WindowState?
         get() = windowStates.firstOrNull()
+
     val inputMethodWindowState: WindowState?
         get() = getWindowStateForAppToken(inputMethodWindowAppToken)
 
@@ -222,15 +244,14 @@ class WindowManagerState(
 
     fun getActivitiesForWindowState(
         windowState: WindowState,
-        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY,
     ): Collection<Activity> {
         return displays
             .firstOrNull { it.displayId == displayId }
             ?.rootTasks
             ?.mapNotNull { stack ->
                 stack.getActivity { activity -> activity.hasWindowState(windowState) }
-            }
-            ?: emptyList()
+            } ?: emptyList()
     }
 
     /**
@@ -242,15 +263,14 @@ class WindowManagerState(
      */
     fun getActivitiesForWindow(
         componentMatcher: IComponentMatcher,
-        displayId: Int = PlatformConsts.DEFAULT_DISPLAY
+        displayId: Int = PlatformConsts.DEFAULT_DISPLAY,
     ): Collection<Activity> {
         return displays
             .firstOrNull { it.displayId == displayId }
             ?.rootTasks
             ?.mapNotNull { stack ->
                 stack.getActivity { activity -> activity.hasWindow(componentMatcher) }
-            }
-            ?: emptyList()
+            } ?: emptyList()
     }
 
     /**
@@ -354,7 +374,7 @@ class WindowManagerState(
     fun defaultMinimalDisplaySizeForSplitScreen(displayId: Int): Int {
         return dpToPx(
             PlatformConsts.DEFAULT_MINIMAL_SPLIT_SCREEN_DISPLAY_SIZE_DP.toFloat(),
-            getDisplay(displayId)!!.dpi
+            getDisplay(displayId)!!.dpi,
         )
     }
 
@@ -469,6 +489,7 @@ class WindowManagerState(
             return (dp * densityDpi / PlatformConsts.DENSITY_DEFAULT + 0.5f).toInt()
         }
     }
+
     override fun equals(other: Any?): Boolean {
         return other is WindowManagerState && other.timestamp == this.timestamp
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerTraceEntryBuilder.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerTraceEntryBuilder.kt
index 978e4e531..13bbcf5db 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerTraceEntryBuilder.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowManagerTraceEntryBuilder.kt
@@ -104,7 +104,7 @@ class WindowManagerTraceEntryBuilder {
             isDisplayFrozen,
             pendingActivities,
             root,
-            keyguardControllerState
+            keyguardControllerState,
         )
     }
 }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowState.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowState.kt
index 6e09432a2..22eaa213f 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowState.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowState.kt
@@ -45,12 +45,13 @@ class WindowState(
     val givenContentInsets: Rect,
     val crop: Rect,
     private val windowContainer: WindowContainer,
-    val isAppWindow: Boolean
+    val isAppWindow: Boolean,
 ) : WindowContainer by windowContainer {
     override val isVisible: Boolean = windowContainer.isVisible && attributes.alpha > 0
 
     override val isFullscreen: Boolean
         get() = this.attributes.flags.and(PlatformConsts.FLAG_FULLSCREEN) > 0
+
     val isStartingWindow: Boolean = windowType == PlatformConsts.WINDOW_TYPE_STARTING
     val isExitingWindow: Boolean = windowType == PlatformConsts.WINDOW_TYPE_EXITING
     val isDebuggerWindow: Boolean = windowType == PlatformConsts.WINDOW_TYPE_DEBUGGER
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WindowToken.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WindowToken.kt
index 6399769f7..cb22f0526 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WindowToken.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WindowToken.kt
@@ -26,6 +26,7 @@ class WindowToken(private val windowContainer: WindowContainer) :
     WindowContainer by windowContainer {
     override val isVisible: Boolean
         get() = false
+
     override fun toString(): String {
         return "${this::class.simpleName}: {$token $title}"
     }
diff --git a/libraries/flicker/utils/src/android/tools/traces/wm/WmTransitionData.kt b/libraries/flicker/utils/src/android/tools/traces/wm/WmTransitionData.kt
index 19fe21dd1..7ae5697a8 100644
--- a/libraries/flicker/utils/src/android/tools/traces/wm/WmTransitionData.kt
+++ b/libraries/flicker/utils/src/android/tools/traces/wm/WmTransitionData.kt
@@ -47,6 +47,6 @@ data class WmTransitionData(
             wmData.startTransactionId ?: startTransactionId,
             wmData.finishTransactionId ?: finishTransactionId,
             wmData.type ?: type,
-            wmData.changes ?: changes
+            wmData.changes ?: changes,
         )
 }
diff --git a/libraries/flicker/utils/test/AndroidTest.xml b/libraries/flicker/utils/test/AndroidTest.xml
index fba26b662..dcee16540 100644
--- a/libraries/flicker/utils/test/AndroidTest.xml
+++ b/libraries/flicker/utils/test/AndroidTest.xml
@@ -46,6 +46,7 @@
     <!-- Needed for pulling the collected trace config on to the host -->
     <metrics_collector class="com.android.tradefed.device.metric.FilePullerLogCollector">
         <option name="pull-pattern-keys" value="perfetto_file_path"/>
+        <option name="directory-keys" value="/data/user/0/android.tools/files" />
         <option name="collect-on-run-ended-only" value="true"/>
         <option name="clean-up" value="true"/>
     </metrics_collector>
diff --git a/libraries/flicker/utils/test/src/android/tools/datatypes/Matrix33Test.kt b/libraries/flicker/utils/test/src/android/tools/datatypes/Matrix33Test.kt
index aa2ff772e..e4383ae8e 100644
--- a/libraries/flicker/utils/test/src/android/tools/datatypes/Matrix33Test.kt
+++ b/libraries/flicker/utils/test/src/android/tools/datatypes/Matrix33Test.kt
@@ -33,7 +33,7 @@ class Matrix33Test : DatatypeTest<Matrix33>() {
             createManualMatrix = { tx, ty ->
                 Matrix33.from(dsdx = 1f, dtdx = 0f, tx, dsdy = 0f, dtdy = 1f, ty)
             },
-            createMatrix = { tx, ty -> Matrix33.identity(tx, ty) }
+            createMatrix = { tx, ty -> Matrix33.identity(tx, ty) },
         )
     }
 
@@ -43,7 +43,7 @@ class Matrix33Test : DatatypeTest<Matrix33>() {
             createManualMatrix = { tx, ty ->
                 Matrix33.from(dsdx = 0f, dtdx = 1f, tx, dsdy = -1f, dtdy = 0f, ty)
             },
-            createMatrix = { tx, ty -> Matrix33.rot90(tx, ty) }
+            createMatrix = { tx, ty -> Matrix33.rot90(tx, ty) },
         )
     }
 
@@ -53,7 +53,7 @@ class Matrix33Test : DatatypeTest<Matrix33>() {
             createManualMatrix = { tx, ty ->
                 Matrix33.from(dsdx = -1f, dtdx = 0f, tx, dsdy = 0f, dtdy = -1f, ty)
             },
-            createMatrix = { tx, ty -> Matrix33.rot180(tx, ty) }
+            createMatrix = { tx, ty -> Matrix33.rot180(tx, ty) },
         )
     }
 
@@ -63,13 +63,13 @@ class Matrix33Test : DatatypeTest<Matrix33>() {
             createManualMatrix = { tx, ty ->
                 Matrix33.from(dsdx = 0f, dtdx = -1f, tx, dsdy = 1f, dtdy = 0f, ty)
             },
-            createMatrix = { tx, ty -> Matrix33.rot270(tx, ty) }
+            createMatrix = { tx, ty -> Matrix33.rot270(tx, ty) },
         )
     }
 
     private fun validateCreation(
         createManualMatrix: (tx: Float, ty: Float) -> Matrix33,
-        createMatrix: (tx: Float, ty: Float) -> Matrix33
+        createMatrix: (tx: Float, ty: Float) -> Matrix33,
     ) {
         val tx = 1f
         val ty = 2f
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt
index c44ae9a6b..1a6b0037c 100644
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseLegacyTransitionsTest.kt
@@ -29,7 +29,7 @@ class ResultReaderParseLegacyTransitionsTest : BaseResultReaderTestParseTrace()
     override val assetFiles =
         mapOf(
             TraceType.LEGACY_WM_TRANSITION to TestTraces.LegacyTransitionTrace.WM_FILE,
-            TraceType.LEGACY_SHELL_TRANSITION to TestTraces.LegacyTransitionTrace.SHELL_FILE
+            TraceType.LEGACY_SHELL_TRANSITION to TestTraces.LegacyTransitionTrace.SHELL_FILE,
         )
     override val traceName = "Transitions trace"
     override val startTimeTrace = TestTraces.LegacyTransitionTrace.START_TIME
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseWMTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseWMTest.kt
index bac5fcb92..98f9efb29 100644
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseWMTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/io/ResultReaderParseWMTest.kt
@@ -25,7 +25,7 @@ class ResultReaderParseWMTest : BaseResultReaderTestParseTrace() {
     override val assetFiles =
         mapOf(
             TraceType.PERFETTO to TestTraces.WMTrace.FILE,
-            TraceType.WM to TestTraces.LegacyWMTrace.FILE
+            TraceType.WM to TestTraces.LegacyWMTrace.FILE,
         )
     override val traceName = "WM trace"
     override val startTimeTrace = TestTraces.WMTrace.START_TIME
diff --git a/libraries/flicker/utils/test/src/android/tools/io/ResultWriterTest.kt b/libraries/flicker/utils/test/src/android/tools/io/ResultWriterTest.kt
index 6772db336..f9c28850d 100644
--- a/libraries/flicker/utils/test/src/android/tools/io/ResultWriterTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/io/ResultWriterTest.kt
@@ -161,11 +161,11 @@ class ResultWriterTest {
             newTestResultWriter()
                 .addTraceResult(
                     TraceType.LEGACY_WM_TRANSITION,
-                    TestTraces.LegacyTransitionTrace.WM_FILE
+                    TestTraces.LegacyTransitionTrace.WM_FILE,
                 )
                 .addTraceResult(
                     TraceType.LEGACY_SHELL_TRANSITION,
-                    TestTraces.LegacyTransitionTrace.SHELL_FILE
+                    TestTraces.LegacyTransitionTrace.SHELL_FILE,
                 )
         val result = writer.write()
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
@@ -187,11 +187,11 @@ class ResultWriterTest {
                 .addTraceResult(TraceType.TRANSACTION, TestTraces.TransactionTrace.FILE)
                 .addTraceResult(
                     TraceType.LEGACY_WM_TRANSITION,
-                    TestTraces.LegacyTransitionTrace.WM_FILE
+                    TestTraces.LegacyTransitionTrace.WM_FILE,
                 )
                 .addTraceResult(
                     TraceType.LEGACY_SHELL_TRANSITION,
-                    TestTraces.LegacyTransitionTrace.SHELL_FILE
+                    TestTraces.LegacyTransitionTrace.SHELL_FILE,
                 )
         val result = writer.write()
         val reader = ResultReader(result, TRACE_CONFIG_REQUIRE_CHANGES)
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/MonitorUtilsTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/MonitorUtilsTest.kt
index ce447881c..f54bee5bc 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/MonitorUtilsTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/MonitorUtilsTest.kt
@@ -29,10 +29,17 @@ import org.junit.runners.MethodSorters
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 class MonitorUtilsTest {
     private val device = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())
+
     @Test
     fun withTracing() {
+        val debugFile =
+            InstrumentationRegistry.getInstrumentation()
+                .targetContext
+                .filesDir
+                .resolve("uiTrace-MonitorUtilsTest-withTracing.winscope")
+
         val trace =
-            android.tools.traces.monitors.withTracing {
+            android.tools.traces.monitors.withTracing(debugFile = debugFile) {
                 device.pressHome()
                 device.pressRecentApps()
             }
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
index 7edb01176..2928e00a5 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/PerfettoTraceMonitorTest.kt
@@ -19,6 +19,9 @@ package android.tools.monitors
 import android.tools.device.apphelpers.BrowserAppHelper
 import android.tools.io.TraceType
 import android.tools.testutils.CleanFlickerEnvironmentRule
+import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.io.IResultData
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.PerfettoTraceMonitor
 import android.tools.traces.monitors.withSFTracing
 import android.tools.traces.monitors.withTransactionsTracing
@@ -26,8 +29,10 @@ import android.tools.traces.parsers.WindowManagerStateHelper
 import android.tools.traces.parsers.perfetto.LayersTraceParser
 import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.TransitionsTraceParser
+import androidx.test.platform.app.InstrumentationRegistry
 import com.android.server.wm.flicker.helpers.ImeAppHelper
 import com.google.common.truth.Truth
+import java.io.File
 import org.junit.Assume.assumeTrue
 import org.junit.ClassRule
 import org.junit.FixMethodOrder
@@ -51,20 +56,24 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
 
     @Test
     fun withSFTracingTest() {
-        val trace = withSFTracing {
-            device.pressHome()
-            device.pressRecentApps()
-        }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-withSFTracingTest")
+        val trace =
+            withSFTracing(debugFile = debugFile) {
+                device.pressHome()
+                device.pressRecentApps()
+            }
 
         Truth.assertWithMessage("Could not obtain layers trace").that(trace.entries).isNotEmpty()
     }
 
     @Test
     fun withTransactionsTracingTest() {
-        val trace = withTransactionsTracing {
-            device.pressHome()
-            device.pressRecentApps()
-        }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-withTransactionsTracingTest")
+        val trace =
+            withTransactionsTracing(debugFile) {
+                device.pressHome()
+                device.pressRecentApps()
+            }
 
         Truth.assertWithMessage("Could not obtain transactions trace")
             .that(trace.entries)
@@ -73,7 +82,13 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
 
     @Test
     fun layersDump() {
-        val traceData = PerfettoTraceMonitor.newBuilder().enableLayersDump().build().withTracing {}
+        val reader =
+            PerfettoTraceMonitor.newBuilder().enableLayersDump().build().withTracing(
+                resultReaderProvider = { buildResultReader(it) }
+            ) {}
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-layersDump")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val trace =
@@ -89,16 +104,19 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
     fun withTransitionTracingTest() {
         assumeTrue(
             "PerfettoTransitionTracing flag should be enabled",
-            android.tracing.Flags.perfettoTransitionTracing()
+            android.tracing.Flags.perfettoTransitionTracing(),
         )
 
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableTransitionsTrace().build()
-        val traceData =
-            traceMonitor.withTracing {
+        val reader =
+            traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
                 BrowserAppHelper().launchViaIntent()
                 device.pressHome()
                 device.pressRecentApps()
             }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-withTransitionTracingTest")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val trace =
@@ -115,26 +133,26 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
         assumeTrue("PerfettoIme flag should be enabled", android.tracing.Flags.perfettoIme())
 
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableImeTrace().build()
-        val traceData =
-            traceMonitor.withTracing {
+        val reader =
+            traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
                 val wmHelper = WindowManagerStateHelper()
                 val imeApp = ImeAppHelper(instrumentation)
                 imeApp.launchViaIntent(wmHelper)
                 imeApp.openIME(wmHelper)
             }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-imeTracingTest")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val queryRowsCount = { session: TraceProcessorSession, tableName: String ->
             val sql =
                 "INCLUDE PERFETTO MODULE android.winscope.inputmethod;" +
                     "SELECT COUNT(*) FROM $tableName;"
-            session.query(
-                sql,
-                { rows ->
-                    require(rows.size == 1)
-                    rows.get(0).get("COUNT(*)") as Long
-                }
-            )
+            session.query(sql) { rows ->
+                require(rows.size == 1)
+                rows[0]["COUNT(*)"] as Long
+            }
         }
 
         val (countRowsClients, countRowsManagerService, countRowsService) =
@@ -142,7 +160,7 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
                 Triple(
                     queryRowsCount(session, "android_inputmethod_clients"),
                     queryRowsCount(session, "android_inputmethod_manager_service"),
-                    queryRowsCount(session, "android_inputmethod_service")
+                    queryRowsCount(session, "android_inputmethod_service"),
                 )
             }
 
@@ -161,16 +179,19 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
     fun viewCaptureTracingTest() {
         assumeTrue(
             "PerfettoViewCaptureTracing flag should be enabled",
-            android.tracing.Flags.perfettoViewCaptureTracing()
+            android.tracing.Flags.perfettoViewCaptureTracing(),
         )
 
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableViewCaptureTrace().build()
-        val traceData =
-            traceMonitor.withTracing {
+        val reader =
+            traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
                 BrowserAppHelper().launchViaIntent()
                 device.pressHome()
                 device.pressRecentApps()
             }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-viewCaptureTracingTest")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val countRows =
@@ -178,13 +199,10 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
                 val sql =
                     "INCLUDE PERFETTO MODULE android.winscope.viewcapture;" +
                         "SELECT COUNT(*) FROM android_viewcapture;"
-                session.query(
-                    sql,
-                    { rows ->
-                        require(rows.size == 1)
-                        rows.get(0).get("COUNT(*)") as Long
-                    }
-                )
+                session.query(sql) { rows ->
+                    require(rows.size == 1)
+                    rows[0]["COUNT(*)"] as Long
+                }
             }
 
         Truth.assertWithMessage("TP doesn't contain ViewCapture rows")
@@ -196,16 +214,19 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
     fun windowManagerTracingTest() {
         assumeTrue(
             "PerfettoWmTracing flag should be enabled",
-            android.tracing.Flags.perfettoWmTracing()
+            android.tracing.Flags.perfettoWmTracing(),
         )
 
         val traceMonitor = PerfettoTraceMonitor.newBuilder().enableWindowManagerTrace().build()
-        val traceData =
-            traceMonitor.withTracing {
+        val reader =
+            traceMonitor.withTracing(resultReaderProvider = { buildResultReader(it) }) {
                 BrowserAppHelper().launchViaIntent()
                 device.pressHome()
                 device.pressRecentApps()
             }
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-windowManagerTracingTest")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val countRows =
@@ -213,13 +234,10 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
                 val sql =
                     "INCLUDE PERFETTO MODULE android.winscope.windowmanager;" +
                         "SELECT COUNT(*) FROM android_windowmanager;"
-                session.query(
-                    sql,
-                    { rows ->
-                        require(rows.size == 1)
-                        rows.get(0).get("COUNT(*)") as Long
-                    }
-                )
+                session.query(sql) { rows ->
+                    require(rows.size == 1)
+                    rows[0]["COUNT(*)"] as Long
+                }
             }
 
         Truth.assertWithMessage("TP doesn't contain WindowManager rows")
@@ -231,11 +249,16 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
     fun windowManagerDumpTest() {
         assumeTrue(
             "PerfettoWmTracing flag should be enabled",
-            android.tracing.Flags.perfettoWmTracing()
+            android.tracing.Flags.perfettoWmTracing(),
         )
 
-        val traceData =
-            PerfettoTraceMonitor.newBuilder().enableWindowManagerDump().build().withTracing {}
+        val reader =
+            PerfettoTraceMonitor.newBuilder().enableWindowManagerDump().build().withTracing(
+                resultReaderProvider = { buildResultReader(it) }
+            ) {}
+        val debugFile = getDebugFile("uiTrace-PerfettoTraceMonitorTest-windowManagerDumpTest")
+        debugFile.writeBytes(reader.artifact.readBytes())
+        val traceData = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         assertTrace(traceData)
 
         val countRows =
@@ -243,13 +266,10 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
                 val sql =
                     "INCLUDE PERFETTO MODULE android.winscope.windowmanager;" +
                         "SELECT COUNT(*) FROM android_windowmanager;"
-                session.query(
-                    sql,
-                    { rows ->
-                        require(rows.size == 1)
-                        rows.get(0).get("COUNT(*)") as Long
-                    }
-                )
+                session.query(sql) { rows ->
+                    require(rows.size == 1)
+                    rows[0]["COUNT(*)"] as Long
+                }
             }
 
         Truth.assertWithMessage("TP doesn't contain WindowManager dump rows")
@@ -257,6 +277,15 @@ class PerfettoTraceMonitorTest : TraceMonitorTest<PerfettoTraceMonitor>() {
             .isEqualTo(1L)
     }
 
+    private fun getDebugFile(testName: String): File =
+        InstrumentationRegistry.getInstrumentation()
+            .targetContext
+            .filesDir
+            .resolve("$testName.winscope")
+
+    private fun buildResultReader(resultData: IResultData): ResultReader =
+        ResultReader(resultData, SERVICE_TRACE_CONFIG)
+
     companion object {
         @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
     }
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/ScreenRecorderTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/ScreenRecorderTest.kt
index 99f197c12..462b3ece2 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/ScreenRecorderTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/ScreenRecorderTest.kt
@@ -114,7 +114,7 @@ class ScreenRecorderTest {
                 0x4d,
                 0x45,
                 0x32,
-                0x23
+                0x23,
             ) // "#VV1NSC0PET1ME2#"
 
         @ClassRule @JvmField val ENV_CLEANUP = CleanFlickerEnvironmentRule()
@@ -202,14 +202,14 @@ class ScreenRecorderTest {
             flags: Int,
             size: Int,
             offset: Int,
-            cryptoData: MediaCodec.CryptoInfo?
+            cryptoData: MediaCodec.CryptoInfo?,
         ) {
             // do nothing
         }
 
         private fun processSampleData(
             inputReader: MediaParser.InputReader,
-            buffer: ArrayList<Byte>
+            buffer: ArrayList<Byte>,
         ) {
             while (inputReader.length > 0) {
                 val requestLength = kotlin.math.min(inputReader.length, auxBuffer.size.toLong())
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/TraceMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/TraceMonitorTest.kt
index f13e5b543..7ec4fbcf1 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/TraceMonitorTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/TraceMonitorTest.kt
@@ -23,6 +23,7 @@ import android.tools.io.TraceType
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.newTestResultWriter
 import android.tools.testutils.outputFileName
+import android.tools.traces.SERVICE_TRACE_CONFIG
 import android.tools.traces.TRACE_CONFIG_REQUIRE_CHANGES
 import android.tools.traces.deleteIfExists
 import android.tools.traces.io.ResultReader
@@ -105,12 +106,14 @@ abstract class TraceMonitorTest<T : TraceMonitor> {
 
     @Test
     open fun withTracing() {
-        val trace =
-            traceMonitor.withTracing(tag) {
+        val reader =
+            traceMonitor.withTracing(
+                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
+            ) {
                 device.pressHome()
                 device.pressRecentApps()
             }
-
+        val trace = reader.readBytes(traceType, tag) ?: ByteArray(0)
         assertTrace(trace)
     }
 
diff --git a/libraries/flicker/utils/test/src/android/tools/monitors/events/EventLogMonitorTest.kt b/libraries/flicker/utils/test/src/android/tools/monitors/events/EventLogMonitorTest.kt
index c5f88c00a..5eca8c587 100644
--- a/libraries/flicker/utils/test/src/android/tools/monitors/events/EventLogMonitorTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/monitors/events/EventLogMonitorTest.kt
@@ -59,32 +59,32 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus entering 111 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus leaving 222 com.google.android.apps.nexuslauncher/" +
                 "com.google.android.apps.nexuslauncher.NexusLauncherActivity (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 333 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         monitor.start()
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus leaving 4749f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         val writer = newTestResultWriter()
         monitor.stop(writer)
@@ -92,7 +92,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus entering 2aa30cd com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         val result = writer.write()
 
@@ -103,12 +103,12 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
         assertEquals(2, eventLog.focusEvents.size)
         assertEquals(
             "4749f88 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.first().window
+            eventLog.focusEvents.first().window,
         )
         assertEquals(FocusEvent.Type.LOST, eventLog.focusEvents.first().type)
         assertEquals(
             "7c01447 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.drop(1).first().window
+            eventLog.focusEvents.drop(1).first().window,
         )
         assertEquals(FocusEvent.Type.GAINED, eventLog.focusEvents.drop(1).first().type)
         assertTrue(
@@ -125,13 +125,13 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 11111 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 22222 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         monitor.stop(newTestResultWriter())
 
@@ -140,13 +140,13 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 479f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         val writer = newTestResultWriter()
         monitor.stop(writer)
@@ -159,12 +159,12 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
         assertEquals(2, eventLog.focusEvents.size)
         assertEquals(
             "479f88 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.first().window
+            eventLog.focusEvents.first().window,
         )
         assertEquals(FocusEvent.Type.LOST, eventLog.focusEvents.first().type)
         assertEquals(
             "7c01447 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.drop(1).first().window
+            eventLog.focusEvents.drop(1).first().window,
         )
         assertEquals(FocusEvent.Type.GAINED, eventLog.focusEvents.drop(1).first().type)
         assertTrue(
@@ -180,19 +180,19 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 4749f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus request 111 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         val writer = newTestResultWriter()
         monitor.stop(writer)
@@ -205,12 +205,12 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
         assertEquals(2, eventLog.focusEvents.size)
         assertEquals(
             "4749f88 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.first().window
+            eventLog.focusEvents.first().window,
         )
         assertEquals(FocusEvent.Type.LOST, eventLog.focusEvents.first().type)
         assertEquals(
             "7c01447 com.android.phone/com.android.phone.settings.fdn.FdnSetting (server)",
-            eventLog.focusEvents.drop(1).first().window
+            eventLog.focusEvents.drop(1).first().window,
         )
         assertEquals(FocusEvent.Type.GAINED, eventLog.focusEvents.drop(1).first().type)
         assertTrue(
@@ -227,19 +227,19 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 4749f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus request 111 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         EventLog.writeEvent(
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
         val writer = newTestResultWriter()
         monitor.stop(writer)
@@ -259,7 +259,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 4749f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
 
         monitor.start()
@@ -268,7 +268,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
 
         val writer = newTestResultWriter()
@@ -292,7 +292,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus leaving 4749f88 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
 
         writer.setTransitionStartTime(now())
@@ -301,7 +301,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
 
         writer.setTransitionEndTime(now())
@@ -310,7 +310,7 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             INPUT_FOCUS_TAG,
             "Focus entering 7c01447 com.android.phone/" +
                 "com.android.phone.settings.fdn.FdnSetting (server)",
-            "reason=test"
+            "reason=test",
         )
 
         monitor.stop(writer)
@@ -334,14 +334,14 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             now.unixNanos,
             now.elapsedNanos,
             now.systemUptimeNanos,
-            ""
+            "",
         )
         now = now()
         EventLogTags.writeJankCujEventsEndRequest(
             CujType.CUJ_NOTIFICATION_APP_START.ordinal,
             now.unixNanos,
             now.elapsedNanos,
-            now.systemUptimeNanos
+            now.systemUptimeNanos,
         )
         monitor.stop(writer)
         val result = writer.write()
@@ -363,19 +363,19 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             now.unixNanos,
             now.elapsedNanos,
             now.systemUptimeNanos,
-            ""
+            "",
         )
         EventLogTags.writeJankCujEventsEndRequest(
             CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL.id,
             now.unixNanos + 1,
             now.elapsedNanos + 1,
-            now.systemUptimeNanos + 1
+            now.systemUptimeNanos + 1,
         )
         EventLogTags.writeJankCujEventsCancelRequest(
             CujType.CUJ_LOCKSCREEN_LAUNCH_CAMERA.id,
             now.unixNanos + 2,
             now.elapsedNanos + 2,
-            now.systemUptimeNanos + 2
+            now.systemUptimeNanos + 2,
         )
         monitor.stop(writer)
         val result = writer.write()
@@ -416,21 +416,21 @@ class EventLogMonitorTest : TraceMonitorTest<EventLogMonitor>() {
             now.unixNanos,
             now.elapsedNanos,
             now.systemUptimeNanos,
-            ""
+            "",
         )
         now = now()
         EventLogTags.writeJankCujEventsEndRequest(
             unknownCujId,
             now.unixNanos,
             now.elapsedNanos,
-            now.systemUptimeNanos
+            now.systemUptimeNanos,
         )
         now = now()
         EventLogTags.writeJankCujEventsCancelRequest(
             unknownCujId,
             now.unixNanos,
             now.elapsedNanos,
-            now.systemUptimeNanos
+            now.systemUptimeNanos,
         )
         monitor.stop(writer)
         val result = writer.write()
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/MockTraceParser.kt b/libraries/flicker/utils/test/src/android/tools/parsers/MockTraceParser.kt
index ae7c43a7d..7dd658fc4 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/MockTraceParser.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/MockTraceParser.kt
@@ -23,7 +23,10 @@ import android.tools.traces.wm.WindowManagerTrace
 
 class MockTraceParser(private val data: WindowManagerTrace) :
     AbstractTraceParser<
-        WindowManagerTrace, WindowManagerState, WindowManagerState, WindowManagerTrace
+        WindowManagerTrace,
+        WindowManagerState,
+        WindowManagerState,
+        WindowManagerTrace,
     >() {
     override val traceName: String = "In memory trace"
 
@@ -31,10 +34,14 @@ class MockTraceParser(private val data: WindowManagerTrace) :
         WindowManagerTrace(entries)
 
     override fun doDecodeByteArray(bytes: ByteArray): WindowManagerTrace = data
+
     override fun doParseEntry(entry: WindowManagerState): WindowManagerState = entry
+
     override fun getEntries(input: WindowManagerTrace): Collection<WindowManagerState> =
         input.entries
+
     override fun getTimestamp(entry: WindowManagerState): Timestamp =
         Timestamps.from(elapsedNanos = entry.elapsedTimestamp)
+
     override fun onBeforeParse(input: WindowManagerTrace) {}
 }
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/TraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/TraceParserTest.kt
index dba7c04a1..a53eb5ff9 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/TraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/TraceParserTest.kt
@@ -32,7 +32,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             Timestamps.min().elapsedNanos,
             mockTraceForSliceTests.entries.first().timestamp.elapsedNanos - 1,
-            listOf<Long>()
+            listOf<Long>(),
         )
     }
 
@@ -46,7 +46,7 @@ class TraceParserTest {
                     mockTraceForSliceTests,
                     Timestamps.from(elapsedNanos = from),
                     Timestamps.from(elapsedNanos = to),
-                    addInitialEntry = false
+                    addInitialEntry = false,
                 )
         Truth.assertThat(splitLayersTraceWithoutInitialEntry.entries).isEmpty()
 
@@ -56,7 +56,7 @@ class TraceParserTest {
                     mockTraceForSliceTests,
                     Timestamps.from(elapsedNanos = from),
                     Timestamps.from(elapsedNanos = to),
-                    addInitialEntry = true
+                    addInitialEntry = true,
                 )
         Truth.assertThat(splitLayersTraceWithInitialEntry.entries).hasSize(1)
         Truth.assertThat(splitLayersTraceWithInitialEntry.entries.first().timestamp)
@@ -73,7 +73,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp.elapsedNanos - 1,
             27L,
-            listOf(5L, 8L, 15L, 18L, 25L, 27L)
+            listOf(5L, 8L, 15L, 18L, 25L, 27L),
         )
     }
 
@@ -82,7 +82,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             18L,
             mockTraceForSliceTests.entries.last().timestamp.elapsedNanos + 5,
-            listOf(18L, 25L, 27L, 30L)
+            listOf(18L, 25L, 27L, 30L),
         )
     }
 
@@ -91,7 +91,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp.elapsedNanos - 1,
             mockTraceForSliceTests.entries.last().timestamp.elapsedNanos + 1,
-            mockTraceForSliceTests.entries.map { it.timestamp }
+            mockTraceForSliceTests.entries.map { it.timestamp },
         )
     }
 
@@ -100,7 +100,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp,
             mockTraceForSliceTests.entries.last().timestamp.elapsedNanos + 1,
-            mockTraceForSliceTests.entries.map { it.timestamp }
+            mockTraceForSliceTests.entries.map { it.timestamp },
         )
     }
 
@@ -109,7 +109,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp,
             mockTraceForSliceTests.entries.last().timestamp,
-            mockTraceForSliceTests.entries.map { it.timestamp }
+            mockTraceForSliceTests.entries.map { it.timestamp },
         )
     }
 
@@ -118,7 +118,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp,
             18L,
-            listOf(5L, 8L, 15L, 18L)
+            listOf(5L, 8L, 15L, 18L),
         )
     }
 
@@ -127,7 +127,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             18L,
             mockTraceForSliceTests.entries.last().timestamp,
-            listOf(18L, 25L, 27L, 30L)
+            listOf(18L, 25L, 27L, 30L),
         )
     }
 
@@ -136,7 +136,7 @@ class TraceParserTest {
         testSliceUsingElapsedTimestamp(
             mockTraceForSliceTests.entries.first().timestamp.elapsedNanos - 1,
             mockTraceForSliceTests.entries.last().timestamp,
-            mockTraceForSliceTests.entries.map { it.timestamp }
+            mockTraceForSliceTests.entries.map { it.timestamp },
         )
     }
 
@@ -154,7 +154,7 @@ class TraceParserTest {
     private fun testSliceUsingElapsedTimestamp(
         from: Timestamp?,
         to: Long,
-        expected: List<Timestamp>
+        expected: List<Timestamp>,
     ) {
         return testSliceUsingElapsedTimestamp(from, to, expected.map { it.elapsedNanos })
     }
@@ -162,7 +162,7 @@ class TraceParserTest {
     private fun testSliceUsingElapsedTimestamp(
         from: Long,
         to: Timestamp?,
-        expected: List<Timestamp>
+        expected: List<Timestamp>,
     ) {
         return testSliceUsingElapsedTimestamp(from, to, expected.map { it.elapsedNanos })
     }
@@ -172,7 +172,7 @@ class TraceParserTest {
         return testSliceUsingElapsedTimestamp(
             from,
             to?.elapsedNanos ?: error("missing elapsed timestamp"),
-            expected
+            expected,
         )
     }
 
@@ -180,12 +180,12 @@ class TraceParserTest {
     private fun testSliceUsingElapsedTimestamp(
         from: Timestamp?,
         to: Timestamp?,
-        expected: List<Timestamp>
+        expected: List<Timestamp>,
     ) {
         return testSliceUsingElapsedTimestamp(
             from?.elapsedNanos ?: error("missing elapsed timestamp"),
             to?.elapsedNanos ?: error("missing elapsed timestamp"),
-            expected.map { it.elapsedNanos }
+            expected.map { it.elapsedNanos },
         )
     }
 
@@ -193,7 +193,7 @@ class TraceParserTest {
         return testSliceUsingElapsedTimestamp(
             from?.elapsedNanos ?: error("missing elapsed timestamp"),
             to,
-            expected
+            expected,
         )
     }
 
@@ -248,7 +248,7 @@ class TraceParserTest {
                     mockTraceForSliceTests,
                     Timestamps.from(elapsedNanos = from),
                     Timestamps.from(elapsedNanos = to),
-                    addInitialEntry = false
+                    addInitialEntry = false,
                 )
         Truth.assertThat(splitLayersTrace.entries.map { it.timestamp.elapsedNanos })
             .isEqualTo(expected)
@@ -261,7 +261,7 @@ class TraceParserTest {
                     mockTraceForSliceTests,
                     Timestamps.from(elapsedNanos = from),
                     Timestamps.from(elapsedNanos = to),
-                    addInitialEntry = true
+                    addInitialEntry = true,
                 )
         Truth.assertThat(splitLayersTraceWithStartEntry.entries.map { it.timestamp.elapsedNanos })
             .isEqualTo(expected)
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
index 871a5ad18..09999eec0 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/WindowManagerStateHelperTest.kt
@@ -61,14 +61,14 @@ class WindowManagerStateHelperTest {
         /** Predicate to supply a new UI information */
         deviceDumpSupplier: () -> DeviceStateDump,
         numRetries: Int = 5,
-        retryIntervalMs: Long = 500L
+        retryIntervalMs: Long = 500L,
     ) :
         WindowManagerStateHelper(
             InstrumentationRegistry.getInstrumentation(),
             clearCacheAfterParsing = false,
             deviceDumpSupplier,
             numRetries,
-            retryIntervalMs
+            retryIntervalMs,
         ) {
         var wmState: WindowManagerState = _wmState
             private set
@@ -99,7 +99,7 @@ class WindowManagerStateHelperTest {
                 /* left */ index.toFloat(),
                 /* top */ index.toFloat(),
                 /* right */ index.toFloat() + 1,
-                /* bottom */ index.toFloat() + 1
+                /* bottom */ index.toFloat() + 1,
             )
         return Layer.from(
             name,
@@ -125,7 +125,7 @@ class WindowManagerStateHelperTest {
             isRelativeOf = false,
             zOrderRelativeOfId = -1,
             stackId = 0,
-            excludesCompositionState = false
+            excludesCompositionState = false,
         )
     }
 
@@ -138,7 +138,7 @@ class WindowManagerStateHelperTest {
                     name.toLayerName(),
                     index,
                     id = name.hashCode(),
-                    parentId = root.id
+                    parentId = root.id,
                 )
             )
         }
@@ -201,7 +201,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("IME window is visible")
             .that(helper.wmState.isVisible(ComponentNameMatcher.IME))
@@ -222,7 +222,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("IME window is visible")
             .that(helper.wmState.isVisible(ComponentNameMatcher.IME))
@@ -243,7 +243,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("$simpleAppComponentName is visible")
             .that(helper.wmState.isVisible(simpleAppComponentName))
@@ -267,7 +267,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = 3,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("$simpleAppComponentName is visible")
             .that(helper.wmState.isVisible(simpleAppComponentName))
@@ -288,7 +288,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("Home activity is visible")
             .that(helper.wmState.isHomeActivityVisible)
@@ -313,7 +313,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
 
         Truth.assertWithMessage("$chromeComponent is visible")
@@ -341,7 +341,7 @@ class WindowManagerStateHelperTest {
                 initialEntry,
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
 
         Truth.assertWithMessage("State is valid").that(helper.wmState.isComplete()).isFalse()
@@ -359,7 +359,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("Display rotation")
             .that(helper.wmState.getRotation(displayId = 0))
@@ -395,7 +395,7 @@ class WindowManagerStateHelperTest {
                 trace.entries.first(),
                 supplier,
                 numRetries = trace.entries.size,
-                retryIntervalMs = 1
+                retryIntervalMs = 1,
             )
         Truth.assertWithMessage("Recents activity is visible")
             .that(helper.wmState.isRecentsActivityVisible)
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/ArgsTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/ArgsTest.kt
index e2ff49284..3e1ec1ef6 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/ArgsTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/ArgsTest.kt
@@ -32,7 +32,7 @@ class ArgsTest {
                     Pair("int", 10),
                     Pair("long", 100L),
                     Pair("float", 10.1f),
-                    Pair("string", "text")
+                    Pair("string", "text"),
                 )
             )
 
@@ -61,11 +61,7 @@ class ArgsTest {
     fun getChildren() {
         val args =
             makeArgs(
-                listOf(
-                    Pair("children[0]", 10),
-                    Pair("children[1]", 11),
-                    Pair("children[2]", 12),
-                )
+                listOf(Pair("children[0]", 10), Pair("children[1]", 11), Pair("children[2]", 12))
             )
 
         Truth.assertThat(args.getChildren("invalidChildren")).isNull()
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/WindowManagerTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/WindowManagerTraceParserTest.kt
index 49bd041a1..675f0a04f 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/WindowManagerTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/perfetto/WindowManagerTraceParserTest.kt
@@ -17,8 +17,11 @@
 package android.tools.parsers.perfetto
 
 import android.tools.Cache
+import android.tools.io.TraceType
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.readAsset
+import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.PerfettoTraceMonitor
 import android.tools.traces.parsers.perfetto.TraceProcessorSession
 import android.tools.traces.parsers.perfetto.WindowManagerTraceParser
@@ -58,11 +61,12 @@ class WindowManagerTraceParserTest {
 
         val device = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())
         val monitor = PerfettoTraceMonitor.Builder().enableWindowManagerTrace().build()
-        val data =
-            monitor.withTracing {
+        val reader =
+            monitor.withTracing(resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }) {
                 device.pressHome()
                 device.pressRecentApps()
             }
+        val data = reader.readBytes(TraceType.PERFETTO) ?: ByteArray(0)
         val trace =
             TraceProcessorSession.loadPerfettoTrace(data) { session ->
                 WindowManagerTraceParser().parse(session)
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt
index 3343e24c1..0ca8bf192 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyShellLegacyTransitionTraceParserTest.kt
@@ -21,6 +21,8 @@ import android.tools.Cache
 import android.tools.device.apphelpers.MessagingAppHelper
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.readAsset
+import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.wm.LegacyShellTransitionTraceMonitor
 import android.tools.traces.parsers.wm.ShellTransitionTraceParser
 import android.tracing.Flags
@@ -57,14 +59,16 @@ class LegacyShellLegacyTransitionTraceParserTest {
     fun canParseAllEntriesFromNewTrace() {
         val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
         val tapl = LauncherInstrumentation()
-        val data =
-            LegacyShellTransitionTraceMonitor().withTracing {
+        val reader =
+            LegacyShellTransitionTraceMonitor().withTracing(
+                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
+            ) {
                 MessagingAppHelper(instrumentation).open()
                 tapl.goHome().switchToAllApps()
                 tapl.goHome()
             }
-        val trace = ShellTransitionTraceParser().parse(data, clearCache = false)
-        Truth.assertThat(trace.entries).isNotEmpty()
+        val trace = reader.readTransitionsTrace()
+        Truth.assertThat(trace?.entries).isNotEmpty()
     }
 
     companion object {
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt
index 703c6c121..92ad56e62 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyTransitionTraceParserTest.kt
@@ -39,7 +39,7 @@ class LegacyTransitionTraceParserTest {
             LegacyTransitionTraceParser()
                 .parse(
                     wmSideTraceData = readAsset("wm_transition_trace.winscope"),
-                    shellSideTraceData = readAsset("shell_transition_trace.winscope")
+                    shellSideTraceData = readAsset("shell_transition_trace.winscope"),
                 )
         val firstEntry = trace.entries.first()
         Truth.assertThat(firstEntry.timestamp.elapsedNanos).isEqualTo(760760231809L)
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWindowManagerTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWindowManagerTraceParserTest.kt
index 6832539d2..92a9dceea 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWindowManagerTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWindowManagerTraceParserTest.kt
@@ -19,6 +19,8 @@ package android.tools.parsers.wm
 import android.tools.Cache
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.readAsset
+import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.wm.WindowManagerTraceMonitor
 import android.tools.traces.parsers.wm.LegacyWindowManagerTraceParser
 import androidx.test.platform.app.InstrumentationRegistry
@@ -53,13 +55,15 @@ class LegacyWindowManagerTraceParserTest {
         Assume.assumeFalse(android.tracing.Flags.perfettoWmTracing())
 
         val device = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())
-        val data =
-            WindowManagerTraceMonitor().withTracing {
+        val reader =
+            WindowManagerTraceMonitor().withTracing(
+                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
+            ) {
                 device.pressHome()
                 device.pressRecentApps()
             }
-        val trace = LegacyWindowManagerTraceParser().parse(data, clearCache = false)
-        Truth.assertThat(trace.entries).isNotEmpty()
+        val trace = reader.readWmTrace()
+        Truth.assertThat(trace?.entries).isNotEmpty()
     }
 
     companion object {
diff --git a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt
index 9c5b6cc5b..3d6d0e30d 100644
--- a/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/parsers/wm/LegacyWmLegacyTransitionTraceParserTest.kt
@@ -21,6 +21,8 @@ import android.tools.Cache
 import android.tools.device.apphelpers.BrowserAppHelper
 import android.tools.testutils.CleanFlickerEnvironmentRule
 import android.tools.testutils.readAsset
+import android.tools.traces.SERVICE_TRACE_CONFIG
+import android.tools.traces.io.ResultReader
 import android.tools.traces.monitors.wm.LegacyWmTransitionTraceMonitor
 import android.tools.traces.parsers.wm.WmTransitionTraceParser
 import android.tracing.Flags
@@ -55,14 +57,16 @@ class LegacyWmLegacyTransitionTraceParserTest {
     fun canParseAllEntriesFromNewTrace() {
         val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
         val tapl = LauncherInstrumentation()
-        val data =
-            LegacyWmTransitionTraceMonitor().withTracing {
+        val reader =
+            LegacyWmTransitionTraceMonitor().withTracing(
+                resultReaderProvider = { ResultReader(it, SERVICE_TRACE_CONFIG) }
+            ) {
                 BrowserAppHelper(instrumentation).open()
                 tapl.goHome().switchToAllApps()
                 tapl.goHome()
             }
-        val trace = WmTransitionTraceParser().parse(data, clearCache = false)
-        Truth.assertThat(trace.entries).isNotEmpty()
+        val trace = reader.readTransitionsTrace()
+        Truth.assertThat(trace?.entries).isNotEmpty()
     }
 
     companion object {
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerBuilder.kt b/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerBuilder.kt
index 2af6d084b..3a94ace55 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerBuilder.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerBuilder.kt
@@ -92,7 +92,7 @@ class MockLayerBuilder(private val name: String) {
                 isRelativeOf = false,
                 zOrderRelativeOfId = -1,
                 stackId = 0,
-                excludesCompositionState = false
+                excludesCompositionState = false,
             )
 
         val layers = mutableListOf<Layer>()
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerTraceEntryBuilder.kt b/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerTraceEntryBuilder.kt
index db2c2c81d..65076fd92 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerTraceEntryBuilder.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/MockLayerTraceEntryBuilder.kt
@@ -55,7 +55,7 @@ class MockLayerTraceEntryBuilder() {
                 transform = Transform.EMPTY,
                 isVirtual = false,
                 dpiX = 416.0,
-                dpiY = 416.0
+                dpiY = 416.0,
             )
         )
         this.layers.add(displayLayer)
@@ -75,7 +75,7 @@ class MockLayerTraceEntryBuilder() {
             where = "",
             displays = displays,
             vSyncId = 100,
-            _rootLayers = layers
+            _rootLayers = layers,
         )
     }
 
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/MockWindowStateBuilder.kt b/libraries/flicker/utils/test/src/android/tools/testutils/MockWindowStateBuilder.kt
index 2fe270814..623dc10b0 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/MockWindowStateBuilder.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/MockWindowStateBuilder.kt
@@ -57,8 +57,8 @@ class MockWindowStateBuilder() {
                 KeyguardControllerState.from(
                     isAodShowing = false,
                     isKeyguardShowing = false,
-                    keyguardOccludedStates = emptyMap()
-                )
+                    keyguardOccludedStates = emptyMap(),
+                ),
         )
     }
 
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/ParsedTracesReader.kt b/libraries/flicker/utils/test/src/android/tools/testutils/ParsedTracesReader.kt
index 42410a77e..9116de444 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/ParsedTracesReader.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/ParsedTracesReader.kt
@@ -71,7 +71,7 @@ class ParsedTracesReader(
             eventLog?.slice(startTimestamp, endTimestamp),
             protoLogTrace?.slice(startTimestamp, endTimestamp),
             layerDumps,
-            wmDumps
+            wmDumps,
         )
     }
 
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/TestArtifact.kt b/libraries/flicker/utils/test/src/android/tools/testutils/TestArtifact.kt
index d43c7c6e0..2da6371c7 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/TestArtifact.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/TestArtifact.kt
@@ -35,6 +35,8 @@ class TestArtifact(artifactIdentifier: String) : Artifact {
 
     override fun hasTrace(descriptor: ResultArtifactDescriptor): Boolean = false
 
+    override fun readBytes(): ByteArray = ByteArray(0)
+
     override fun readBytes(descriptor: ResultArtifactDescriptor): ByteArray? = null
 
     override fun updateStatus(newStatus: RunStatus) {
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/TestComponents.kt b/libraries/flicker/utils/test/src/android/tools/testutils/TestComponents.kt
index 74c981746..3cf772007 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/TestComponents.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/TestComponents.kt
@@ -21,73 +21,63 @@ package android.tools.testutils
 import android.tools.traces.component.ComponentNameMatcher
 
 object TestComponents {
-    @JvmStatic
     val CHROME = ComponentNameMatcher("com.android.chrome", "com.google.android.apps.chrome.Main")
 
-    @JvmStatic
     val CHROME_FIRST_RUN =
         ComponentNameMatcher(
             "com.android.chrome",
-            "org.chromium.chrome.browser.firstrun.FirstRunActivity"
+            "org.chromium.chrome.browser.firstrun.FirstRunActivity",
         )
 
-    @JvmStatic
     val CHROME_SPLASH_SCREEN = ComponentNameMatcher("", "Splash Screen com.android.chrome")
 
-    @JvmStatic val DOCKER_STACK_DIVIDER = ComponentNameMatcher("", "DockedStackDivider")
+    val DOCKER_STACK_DIVIDER = ComponentNameMatcher("", "DockedStackDivider")
 
-    @JvmStatic val IMAGINARY = ComponentNameMatcher("", "ImaginaryWindow")
+    val IMAGINARY = ComponentNameMatcher("", "ImaginaryWindow")
 
-    @JvmStatic
     val IME_ACTIVITY =
         ComponentNameMatcher(
             "com.android.server.wm.flicker.testapp",
-            "com.android.server.wm.flicker.testapp.ImeActivity"
+            "com.android.server.wm.flicker.testapp.ImeActivity",
         )
 
-    @JvmStatic
     val LAUNCHER =
         ComponentNameMatcher(
             "com.google.android.apps.nexuslauncher",
-            "com.google.android.apps.nexuslauncher.NexusLauncherActivity"
+            "com.google.android.apps.nexuslauncher.NexusLauncherActivity",
         )
 
-    @JvmStatic val PIP_OVERLAY = ComponentNameMatcher("", "pip-dismiss-overlay")
+    val PIP_OVERLAY = ComponentNameMatcher("", "pip-dismiss-overlay")
 
-    @JvmStatic
     val SIMPLE_APP =
         ComponentNameMatcher(
             "com.android.server.wm.flicker.testapp",
-            "com.android.server.wm.flicker.testapp.SimpleActivity"
+            "com.android.server.wm.flicker.testapp.SimpleActivity",
         )
 
-    @JvmStatic
     val NON_RESIZEABLE_APP =
         ComponentNameMatcher(
             "com.android.server.wm.flicker.testapp",
-            "com.android.server.wm.flicker.testapp.NonResizeableActivity"
+            "com.android.server.wm.flicker.testapp.NonResizeableActivity",
         )
 
     private const val SHELL_PKG_NAME = "com.android.wm.shell.flicker.testapp"
 
-    @JvmStatic
     val SHELL_SPLIT_SCREEN_PRIMARY =
         ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.SplitScreenActivity")
 
-    @JvmStatic
     val SHELL_SPLIT_SCREEN_SECONDARY =
         ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.SplitScreenSecondaryActivity")
 
-    @JvmStatic val FIXED_APP = ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.FixedActivity")
+    val FIXED_APP = ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.FixedActivity")
 
-    @JvmStatic val PIP_APP = ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.PipActivity")
+    val PIP_APP = ComponentNameMatcher(SHELL_PKG_NAME, "$SHELL_PKG_NAME.PipActivity")
 
-    @JvmStatic val SCREEN_DECOR_OVERLAY = ComponentNameMatcher("", "ScreenDecorOverlay")
+    val SCREEN_DECOR_OVERLAY = ComponentNameMatcher("", "ScreenDecorOverlay")
 
-    @JvmStatic
     val WALLPAPER =
         ComponentNameMatcher(
             "",
-            "com.breel.wallpapers18.soundviz.wallpaper.variations.SoundVizWallpaperV2"
+            "com.breel.wallpapers18.soundviz.wallpaper.variations.SoundVizWallpaperV2",
         )
 }
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt b/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
index caaccc6b2..2e57e5027 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/TestTraces.kt
@@ -81,14 +81,10 @@ object TestTraces {
             Timestamps.from(
                 elapsedNanos = 2770105426934 - 1000,
                 systemUptimeNanos = 0,
-                unixNanos = 0
-            )
-        val INVALID_SLICE_TIME =
-            Timestamps.from(
-                elapsedNanos = 2770105426934 + 1,
-                systemUptimeNanos = 0,
                 unixNanos = 0,
             )
+        val INVALID_SLICE_TIME =
+            Timestamps.from(elapsedNanos = 2770105426934 + 1, systemUptimeNanos = 0, unixNanos = 0)
         val END_TIME =
             Timestamps.from(elapsedNanos = 2770105426934, systemUptimeNanos = 0, unixNanos = 0)
 
@@ -108,14 +104,10 @@ object TestTraces {
             Timestamps.from(
                 elapsedNanos = 479583450794 + 5000,
                 systemUptimeNanos = 0,
-                unixNanos = 0
-            )
-        val INVALID_SLICE_TIME =
-            Timestamps.from(
-                elapsedNanos = 487330863192 + 1,
-                systemUptimeNanos = 0,
                 unixNanos = 0,
             )
+        val INVALID_SLICE_TIME =
+            Timestamps.from(elapsedNanos = 487330863192 + 1, systemUptimeNanos = 0, unixNanos = 0)
         val END_TIME =
             Timestamps.from(elapsedNanos = 487330863192, systemUptimeNanos = 0, unixNanos = 0)
 
@@ -132,14 +124,10 @@ object TestTraces {
             Timestamps.from(
                 elapsedNanos = 3663230963946 + 5000,
                 systemUptimeNanos = 0,
-                unixNanos = 0
-            )
-        val INVALID_SLICE_TIME =
-            Timestamps.from(
-                elapsedNanos = 3672045108074 + 1,
-                systemUptimeNanos = 0,
                 unixNanos = 0,
             )
+        val INVALID_SLICE_TIME =
+            Timestamps.from(elapsedNanos = 3672045108074 + 1, systemUptimeNanos = 0, unixNanos = 0)
         val END_TIME =
             Timestamps.from(elapsedNanos = 3672045108074, systemUptimeNanos = 0, unixNanos = 0)
 
@@ -159,6 +147,6 @@ object TestTraces {
             transitionsTrace =
                 TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false),
             transactionsTrace =
-                TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false)
+                TraceConfig(required = false, allowNoChange = false, usingExistingTraces = false),
         )
 }
diff --git a/libraries/flicker/utils/test/src/android/tools/testutils/Utils.kt b/libraries/flicker/utils/test/src/android/tools/testutils/Utils.kt
index ca9cb37e3..181d65d61 100644
--- a/libraries/flicker/utils/test/src/android/tools/testutils/Utils.kt
+++ b/libraries/flicker/utils/test/src/android/tools/testutils/Utils.kt
@@ -77,7 +77,7 @@ inline fun <reified ExceptionType> assertThrows(r: () -> Unit): ExceptionType {
             t is Exception ->
                 throw AssertionError(
                     "Expected ${ExceptionType::class.java}, but got '${t.javaClass}'",
-                    t
+                    t,
                 )
             // Re-throw Errors and other non-Exception throwables.
             else -> throw t
@@ -148,7 +148,7 @@ fun getWmTraceReaderFromAsset(
                 .parse(
                     session,
                     Timestamps.from(elapsedNanos = from),
-                    Timestamps.from(elapsedNanos = to)
+                    Timestamps.from(elapsedNanos = to),
                 )
         }
     }
@@ -165,7 +165,7 @@ fun getWmTraceReaderFromAsset(
                 Timestamps.from(elapsedNanos = from),
                 Timestamps.from(elapsedNanos = to),
                 addInitialEntry,
-                clearCache = false
+                clearCache = false,
             )
     }
 
@@ -178,7 +178,7 @@ fun getWmTraceReaderFromAsset(
 
     return ParsedTracesReader(
         artifact = TestArtifact(relativePathWithoutExtension),
-        wmTrace = trace
+        wmTrace = trace,
     )
 }
 
@@ -206,7 +206,7 @@ fun getWmDumpReaderFromAsset(relativePathWithoutExtension: String): Reader {
         }
     return ParsedTracesReader(
         artifact = TestArtifact(relativePathWithoutExtension),
-        wmTrace = wmTrace
+        wmTrace = wmTrace,
     )
 }
 
@@ -214,7 +214,7 @@ fun getLayerTraceReaderFromAsset(
     relativePath: String,
     ignoreOrphanLayers: Boolean = true,
     from: Timestamp = Timestamps.min(),
-    to: Timestamp = Timestamps.max()
+    to: Timestamp = Timestamps.max(),
 ): Reader {
     val layersTrace =
         TraceProcessorSession.loadPerfettoTrace(readAsset(relativePath)) { session ->
@@ -271,7 +271,7 @@ fun outputFileName(status: RunStatus) =
 fun createDefaultArtifactBuilder(
     status: RunStatus,
     outputDir: File = createTempDirectory().toFile(),
-    files: Map<ResultArtifactDescriptor, File> = emptyMap()
+    files: Map<ResultArtifactDescriptor, File> = emptyMap(),
 ) =
     ArtifactBuilder()
         .withScenario(TEST_SCENARIO)
@@ -298,6 +298,6 @@ fun newEmptyRootContainer(orientation: Int = 0, layerId: Int = 0) =
             _isVisible = true,
             _children = emptyList(),
             configurationContainer = ConfigurationContainerImpl.EMPTY,
-            computedZ = 0
+            computedZ = 0,
         )
     )
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/events/CujTraceTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/events/CujTraceTest.kt
index d7505af61..4275dbe4e 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/events/CujTraceTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/events/CujTraceTest.kt
@@ -32,12 +32,12 @@ class CujTraceTest {
                     createCujEvent(
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_BEGIN_TAG
+                        CujEvent.JANK_CUJ_BEGIN_TAG,
                     ),
                     createCujEvent(
                         2,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_END_TAG
+                        CujEvent.JANK_CUJ_END_TAG,
                     ),
                 )
             )
@@ -58,12 +58,12 @@ class CujTraceTest {
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
                         CujEvent.JANK_CUJ_BEGIN_TAG,
-                        tag = "MySubType"
+                        tag = "MySubType",
                     ),
                     createCujEvent(
                         2,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_END_TAG
+                        CujEvent.JANK_CUJ_END_TAG,
                     ),
                 )
             )
@@ -84,12 +84,12 @@ class CujTraceTest {
                     createCujEvent(
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_BEGIN_TAG
+                        CujEvent.JANK_CUJ_BEGIN_TAG,
                     ),
                     createCujEvent(
                         2,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_CANCEL_TAG
+                        CujEvent.JANK_CUJ_CANCEL_TAG,
                     ),
                 )
             )
@@ -109,17 +109,17 @@ class CujTraceTest {
                     createCujEvent(
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_CANCEL_TAG
+                        CujEvent.JANK_CUJ_CANCEL_TAG,
                     ),
                     createCujEvent(
                         2,
                         CujType.CUJ_BIOMETRIC_PROMPT_TRANSITION,
-                        CujEvent.JANK_CUJ_END_TAG
+                        CujEvent.JANK_CUJ_END_TAG,
                     ),
                     createCujEvent(
                         3,
                         CujType.CUJ_LAUNCHER_APP_CLOSE_TO_HOME,
-                        CujEvent.JANK_CUJ_BEGIN_TAG
+                        CujEvent.JANK_CUJ_BEGIN_TAG,
                     ),
                 )
             )
@@ -135,12 +135,12 @@ class CujTraceTest {
                     createCujEvent(
                         2,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_END_TAG
+                        CujEvent.JANK_CUJ_END_TAG,
                     ),
                     createCujEvent(
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_BEGIN_TAG
+                        CujEvent.JANK_CUJ_BEGIN_TAG,
                     ),
                 )
             )
@@ -160,12 +160,12 @@ class CujTraceTest {
                     createCujEvent(
                         1,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_END_TAG
+                        CujEvent.JANK_CUJ_END_TAG,
                     ),
                     createCujEvent(
                         2,
                         CujType.CUJ_LAUNCHER_ALL_APPS_SCROLL,
-                        CujEvent.JANK_CUJ_BEGIN_TAG
+                        CujEvent.JANK_CUJ_BEGIN_TAG,
                     ),
                 )
             )
@@ -193,17 +193,9 @@ class CujTraceTest {
         timestamp: Long,
         cuj: ICujType,
         type: String,
-        tag: String? = null
+        tag: String? = null,
     ): CujEvent {
-        return CujEvent(
-            Timestamps.from(unixNanos = timestamp),
-            cuj,
-            0,
-            "root",
-            0,
-            type,
-            tag,
-        )
+        return CujEvent(Timestamps.from(unixNanos = timestamp), cuj, 0, "root", 0, type, tag)
     }
 
     companion object {
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTest.kt
index 65556aeb2..1ef6134fb 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTest.kt
@@ -66,7 +66,7 @@ class LayerTest {
                 makeLayerWithDefaults(
                         excludeCompositionState = false,
                         visibleRegion = Region(),
-                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0)
+                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0),
                     )
                     .isVisible
             )
@@ -75,7 +75,7 @@ class LayerTest {
                 makeLayerWithDefaults(
                         excludeCompositionState = false,
                         visibleRegion = Region(0, 0, 100, 100),
-                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0)
+                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0),
                     )
                     .isVisible
             )
@@ -88,7 +88,7 @@ class LayerTest {
                 makeLayerWithDefaults(
                         excludeCompositionState = true,
                         bounds = RectF(),
-                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0)
+                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0),
                     )
                     .isVisible
             )
@@ -97,7 +97,7 @@ class LayerTest {
                 makeLayerWithDefaults(
                         excludeCompositionState = true,
                         bounds = RectF(0f, 0f, 100f, 100f),
-                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0)
+                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0),
                     )
                     .isVisible
             )
@@ -107,7 +107,7 @@ class LayerTest {
                         excludeCompositionState = true,
                         visibleRegion = Region(0, 0, 100, 100),
                         bounds = RectF(),
-                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0)
+                        activeBuffer = ActiveBuffer.from(100, 100, 1, 0),
                     )
                     .isVisible
             )
@@ -119,7 +119,7 @@ class LayerTest {
         excludeCompositionState: Boolean = false,
         visibleRegion: Region = Region(),
         bounds: RectF = RectF(),
-        activeBuffer: ActiveBuffer = ActiveBuffer.EMPTY
+        activeBuffer: ActiveBuffer = ActiveBuffer.EMPTY,
     ): Layer {
         return Layer.from(
             "",
@@ -145,7 +145,7 @@ class LayerTest {
             false,
             -1,
             -1,
-            excludeCompositionState
+            excludeCompositionState,
         )
     }
 }
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTraceEntryBuilderTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTraceEntryBuilderTest.kt
index 56de2feaa..8fb280b97 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTraceEntryBuilderTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayerTraceEntryBuilderTest.kt
@@ -103,7 +103,7 @@ class LayerTraceEntryBuilderTest {
                     isRelativeOf = false,
                     zOrderRelativeOfId = 0,
                     stackId = offDisplayStackId,
-                    excludesCompositionState = true
+                    excludesCompositionState = true,
                 )
             )
 
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayersTraceEntryTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayersTraceEntryTest.kt
index 9053cce4c..1828380f6 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayersTraceEntryTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/surfaceflinger/LayersTraceEntryTest.kt
@@ -27,7 +27,9 @@ import org.junit.FixMethodOrder
 import org.junit.Test
 import org.junit.runners.MethodSorters
 
-/** Contains [LayerTraceEntry] tests. To run this test: `atest FlickerLibTest:LayersTraceTest` */
+/**
+ * Contains [LayerTraceEntry] tests. To run this test: `atest FlickerLibTest:LayersTraceEntryTest`
+ */
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 class LayersTraceEntryTest {
     @Before
@@ -125,7 +127,7 @@ class LayersTraceEntryTest {
             val reader =
                 getLayerTraceReaderFromAsset(
                     "layers_trace_orphanlayers.perfetto-trace",
-                    ignoreOrphanLayers = false
+                    ignoreOrphanLayers = false,
                 )
             reader.readLayersTrace()?.entries?.first()?.flattenedLayers
             error("Failed to detect orphaned layers.")
@@ -178,7 +180,7 @@ class LayersTraceEntryTest {
                 where = "",
                 displays = emptyList(),
                 vSyncId = 123,
-                _rootLayers = emptyList()
+                _rootLayers = emptyList(),
             )
         Truth.assertThat(entry.timestamp.elapsedNanos).isEqualTo(Timestamps.empty().elapsedNanos)
         Truth.assertThat(entry.timestamp.systemUptimeNanos).isEqualTo(100)
@@ -192,7 +194,7 @@ class LayersTraceEntryTest {
                 where = "",
                 displays = emptyList(),
                 vSyncId = 123,
-                _rootLayers = emptyList()
+                _rootLayers = emptyList(),
             )
         Truth.assertThat(entry.timestamp.elapsedNanos).isEqualTo(Timestamps.empty().elapsedNanos)
         Truth.assertThat(entry.timestamp.systemUptimeNanos).isEqualTo(100)
@@ -228,7 +230,7 @@ class LayersTraceEntryTest {
             trace.getEntryAt(
                 Timestamps.from(
                     elapsedNanos = 90485742427178,
-                    elapsedOffsetNanos = 1682359234732002451
+                    elapsedOffsetNanos = 1682359234732002451,
                 )
             )
         var coveredLayer = state.getLayerById(693) ?: error("Activity layer not found")
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionTest.kt
index 2009b048b..fb924acb7 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionTest.kt
@@ -46,23 +46,17 @@ class TransitionTest {
                 shellData =
                     ShellTransitionData(
                         dispatchTime = Timestamps.from(22),
-                        handler = "DefaultHandler"
+                        handler = "DefaultHandler",
                     ),
             )
 
         val transition3 =
-            Transition(
-                id = 1,
-                wmData =
-                    WmTransitionData(
-                        finishTime = Timestamps.from(40),
-                    ),
-            )
+            Transition(id = 1, wmData = WmTransitionData(finishTime = Timestamps.from(40)))
 
         val mergedTransition =
             Transition.mergePartialTransitions(
                 Transition.mergePartialTransitions(transition1, transition2),
-                transition3
+                transition3,
             )
 
         Truth.assertThat(mergedTransition.createTime.elapsedNanos).isEqualTo(10)
@@ -95,7 +89,7 @@ class TransitionTest {
                         abortTime = Timestamps.from(24),
                         handler = "Handler1",
                         mergeTarget = 1,
-                    )
+                    ),
             )
 
         val transition2 =
@@ -120,7 +114,7 @@ class TransitionTest {
                         abortTime = Timestamps.from(240),
                         handler = "Handler2",
                         mergeTarget = 10,
-                    )
+                    ),
             )
 
         val mergedTransition = Transition.mergePartialTransitions(transition1, transition2)
@@ -149,8 +143,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        startTransactionId = transactionId
-                    )
+                        startTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -161,7 +155,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = emptyList()
+                    mergedTransactionIds = emptyList(),
                 )
             )
         val transactionsTraceEntry =
@@ -169,7 +163,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
@@ -188,8 +182,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        startTransactionId = transactionId
-                    )
+                        startTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -200,7 +194,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = emptyList()
+                    mergedTransactionIds = emptyList(),
                 )
             )
         val transactionsTraceEntry =
@@ -208,7 +202,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
@@ -227,8 +221,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        startTransactionId = transactionId
-                    )
+                        startTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -239,7 +233,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = listOf(transactionId)
+                    mergedTransactionIds = listOf(transactionId),
                 )
             )
         val transactionsTraceEntry =
@@ -247,7 +241,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
@@ -266,8 +260,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        finishTransactionId = transactionId
-                    )
+                        finishTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -278,7 +272,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = emptyList()
+                    mergedTransactionIds = emptyList(),
                 )
             )
         val transactionsTraceEntry =
@@ -286,7 +280,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
@@ -305,8 +299,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        finishTransactionId = transactionId
-                    )
+                        finishTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -317,7 +311,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = emptyList()
+                    mergedTransactionIds = emptyList(),
                 )
             )
         val transactionsTraceEntry =
@@ -325,7 +319,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
@@ -344,8 +338,8 @@ class TransitionTest {
                 wmData =
                     WmTransitionData(
                         sendTime = Timestamps.from(1),
-                        finishTransactionId = transactionId
-                    )
+                        finishTransactionId = transactionId,
+                    ),
             )
 
         val transactions =
@@ -356,7 +350,7 @@ class TransitionTest {
                     uid = 0,
                     requestedVSyncId = 0,
                     postTime = 0,
-                    mergedTransactionIds = listOf(transactionId)
+                    mergedTransactionIds = listOf(transactionId),
                 )
             )
         val transactionsTraceEntry =
@@ -364,7 +358,7 @@ class TransitionTest {
                 TransactionsTraceEntry(
                     timestamp = Timestamps.from(1),
                     vSyncId = 1,
-                    transactions = transactions
+                    transactions = transactions,
                 )
             )
         val transactionTrace = TransactionsTrace(transactionsTraceEntry)
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionsTraceTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionsTraceTest.kt
index 9b4723ddb..eae9261db 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionsTraceTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/wm/TransitionsTraceTest.kt
@@ -46,16 +46,13 @@ class TransitionsTraceTest {
                             shellData =
                                 ShellTransitionData(
                                     dispatchTime = Timestamps.from(22),
-                                    handler = "DefaultHandler"
+                                    handler = "DefaultHandler",
                                 ),
                         ),
                         Transition(
                             id = 1,
-                            wmData =
-                                WmTransitionData(
-                                    finishTime = Timestamps.from(40),
-                                ),
-                        )
+                            wmData = WmTransitionData(finishTime = Timestamps.from(40)),
+                        ),
                     )
                 )
                 .asCompressed()
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerStateTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerStateTest.kt
index fe9e9466e..b3d187835 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerStateTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerStateTest.kt
@@ -54,8 +54,8 @@ class WindowManagerStateTest {
                     KeyguardControllerState.from(
                         isAodShowing = false,
                         isKeyguardShowing = false,
-                        keyguardOccludedStates = mapOf()
-                    )
+                        keyguardOccludedStates = mapOf(),
+                    ),
             )
         Truth.assertThat(entry.timestamp.elapsedNanos).isEqualTo(100)
         Truth.assertThat(entry.timestamp.unixNanos).isEqualTo(600)
@@ -78,8 +78,8 @@ class WindowManagerStateTest {
                     KeyguardControllerState.from(
                         isAodShowing = false,
                         isKeyguardShowing = false,
-                        keyguardOccludedStates = mapOf()
-                    )
+                        keyguardOccludedStates = mapOf(),
+                    ),
             )
         Truth.assertThat(entry.timestamp.elapsedNanos).isEqualTo(100)
         Truth.assertThat(entry.timestamp.unixNanos).isEqualTo(Timestamps.empty().unixNanos)
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceEntryBuilderTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceEntryBuilderTest.kt
index 8a921afd7..8bc3435c2 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceEntryBuilderTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceEntryBuilderTest.kt
@@ -44,7 +44,7 @@ class WindowManagerTraceEntryBuilderTest {
                     KeyguardControllerState.from(
                         isAodShowing = false,
                         isKeyguardShowing = false,
-                        keyguardOccludedStates = mapOf()
+                        keyguardOccludedStates = mapOf(),
                     )
                 )
                 .setRealToElapsedTimeOffsetNs(500)
@@ -68,7 +68,7 @@ class WindowManagerTraceEntryBuilderTest {
                     KeyguardControllerState.from(
                         isAodShowing = false,
                         isKeyguardShowing = false,
-                        keyguardOccludedStates = mapOf()
+                        keyguardOccludedStates = mapOf(),
                     )
                 )
                 .build()
diff --git a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceTest.kt b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceTest.kt
index 6260dcaf2..c1b92d82d 100644
--- a/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceTest.kt
+++ b/libraries/flicker/utils/test/src/android/tools/traces/wm/WindowManagerTraceTest.kt
@@ -133,7 +133,7 @@ class WindowManagerTraceTest {
                 "wm_trace_openchrome2",
                 from = 174686204723645,
                 to = 174686640998584,
-                legacyTrace = true
+                legacyTrace = true,
             )
         val trace = reader.readWmTrace() ?: error("Unable to read WM trace")
 
@@ -149,7 +149,7 @@ class WindowManagerTraceTest {
                 "wm_trace_openchrome2",
                 from = 9213763541297,
                 to = 9215895891561,
-                legacyTrace = true
+                legacyTrace = true,
             )
         val trace = reader.readWmTrace() ?: error("Unable to read WM trace")
         assertThat(trace.entries).isEmpty()
diff --git a/libraries/health/rules/Android.bp b/libraries/health/rules/Android.bp
index e6ff19209..1bfa4cbe3 100644
--- a/libraries/health/rules/Android.bp
+++ b/libraries/health/rules/Android.bp
@@ -55,10 +55,12 @@ java_library {
     static_libs: [
         "junit",
         "androidx.test.runner",
+        "kotlin-reflect",
     ],
     srcs: [
-        "src/android/platform/test/rule/LimitDevicesRule.kt",
         "src/android/platform/test/rule/AnnotationUtils.kt",
+        "src/android/platform/test/rule/LimitDevicesRule.kt",
+        "src/android/platform/test/rule/TestAnnotationScanner.kt",
     ],
 }
 
diff --git a/libraries/health/rules/TEST_MAPPING b/libraries/health/rules/TEST_MAPPING
index be870e3aa..899ce6173 100644
--- a/libraries/health/rules/TEST_MAPPING
+++ b/libraries/health/rules/TEST_MAPPING
@@ -2,6 +2,32 @@
   "imports": [
     {
       "path": "vendor/google_testing/integration/tests/scenarios/src/android/platform/test/scenario/sysui"
+    },
+    {
+      "path": "frameworks/base"
+    }
+  ],
+
+  // To make sure health/rules do not break sysui tests.
+  // Copied from the internal "sysui-e2e-postsumit" test mapping group.
+  // Once stable, this will be promoted to presubmit.
+  "postsubmit": [
+    {
+      "name": "PlatformScenarioTests",
+      "options": [
+        {
+            "include-filter": "android.platform.test.scenario.sysui"
+        },
+        {
+            "include-annotation": "android.platform.test.scenario.annotation.Scenario"
+        },
+        {
+            "exclude-annotation": "org.junit.Ignore"
+        },
+        {
+            "exclude-annotation": "androidx.test.filters.FlakyTest"
+        }
+      ]
     }
   ]
-}
+}
\ No newline at end of file
diff --git a/libraries/health/rules/multivalentTests/src/android/platform/test/rule/LimitDevicesRuleTest.kt b/libraries/health/rules/multivalentTests/src/android/platform/test/rule/LimitDevicesRuleTest.kt
index 7c09be4af..d75eb0aa3 100644
--- a/libraries/health/rules/multivalentTests/src/android/platform/test/rule/LimitDevicesRuleTest.kt
+++ b/libraries/health/rules/multivalentTests/src/android/platform/test/rule/LimitDevicesRuleTest.kt
@@ -93,7 +93,7 @@ class LimitDevicesRuleTest {
         FlakyOnPhone.isFlakyConfig = false
         checkResults(
             "runAndPass: SKIPPED: Skipping test as cf_x86_64_phone is flaky " +
-                "and this config excludes fakes"
+                "and this config excludes flakes"
         )
 
         FlakyOnPhone.device = CF_PHONE
@@ -108,8 +108,27 @@ class LimitDevicesRuleTest {
         FlakyOnPhone.isFlakyConfig = true
         checkResults("runAndPass: PASSED")
     }
+
+    @FlakyOnTablet
+    class ThisIsFlakyOnTablet {
+        fun aTest() {}
+    }
+
+    @Test
+    fun metaAnnotation() {
+        val skipReason =
+            LimitDevicesRule(thisDevice = CF_TABLET.product, runningFlakyTests = false)
+                .skipReasonIfAny("aTest".description<ThisIsFlakyOnTablet>())
+        val expected = "Skipping test as cf_x86_64_tablet is flaky and this config excludes flakes"
+        assertThat(skipReason).isEqualTo(expected)
+    }
 }
 
+@MetaAnnotation
+@Retention(AnnotationRetention.RUNTIME)
+@FlakyDevices(CF_TABLET)
+annotation class FlakyOnTablet
+
 @AllowedDevices(CF_PHONE) private class AllowedOnPhonesOnly
 
 @DeniedDevices(CF_PHONE) private class DeniedOnPhonesOnly
diff --git a/libraries/health/rules/multivalentTests/src/android/platform/test/rule/TestAnnotationScannerTest.kt b/libraries/health/rules/multivalentTests/src/android/platform/test/rule/TestAnnotationScannerTest.kt
new file mode 100644
index 000000000..dccdcb767
--- /dev/null
+++ b/libraries/health/rules/multivalentTests/src/android/platform/test/rule/TestAnnotationScannerTest.kt
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.rule
+
+import com.google.common.truth.Truth.assertThat
+import com.google.common.truth.Truth.assertWithMessage
+import java.lang.annotation.Inherited
+import kotlin.reflect.full.memberFunctions
+import org.junit.Test
+import org.junit.runner.Description
+import org.junit.runner.JUnitCore
+import org.junit.runner.Request
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+@Inherited @Retention(AnnotationRetention.RUNTIME) annotation class Flavor(val value: String = "")
+
+@Retention(AnnotationRetention.RUNTIME) annotation class NotInherited(val value: String = "")
+
+@Inherited
+@Retention(AnnotationRetention.RUNTIME)
+@MetaAnnotation
+@Flavor("umami")
+annotation class Umami()
+
+inline fun <reified T> String.description() =
+    Description.createTestDescription(
+        T::class.java,
+        this,
+        *(T::class.memberFunctions.single { it.name == this }.annotations.toTypedArray()),
+    )
+
+class TestAnnotationScannerTest {
+    class NoAnnotation {
+        fun aTest() {}
+    }
+
+    @Test
+    fun noAnnotation() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<NoAnnotation>()
+        assertThat(scanner.find<Flavor>(method)).isNull()
+    }
+
+    class AnnotationOnMethod {
+        @Flavor("spicy") fun aTest() {}
+    }
+
+    @Test
+    fun annotationOnMethod() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<AnnotationOnMethod>()
+        assertThat(scanner.find<Flavor>(method)?.value).isEqualTo("spicy")
+    }
+
+    @Flavor("sour")
+    class AnnotationOnClass {
+        fun aTest() {}
+    }
+
+    @Test
+    fun annotationOnClass() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<AnnotationOnClass>()
+        assertThat(scanner.find<Flavor>(method)?.value).isEqualTo("sour")
+    }
+
+    @Flavor("bitter")
+    class AnnotationOnBoth {
+        @Flavor("sweet") fun aTest() {}
+    }
+
+    @Test
+    fun methodWinsOnBoth() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<AnnotationOnBoth>()
+        assertThat(scanner.find<Flavor>(method)?.value).isEqualTo("sweet")
+    }
+
+    @NotInherited("only for this class")
+    @Flavor("tangy")
+    @AllowedDevices(DeviceProduct.CF_PHONE)
+    open class Superclass
+
+    class Subclass : Superclass() {
+        fun aTest() {}
+    }
+
+    @Test
+    fun findSuperclassIfInherited() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<Subclass>()
+        assertThat(scanner.find<Flavor>(method)?.value).isEqualTo("tangy")
+    }
+
+    @Test
+    fun findAllowedDevicesFromSuperclass() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<Subclass>()
+        assertThat(scanner.find<AllowedDevices>(method)?.allowed)
+            .isEqualTo(arrayOf(DeviceProduct.CF_PHONE))
+    }
+
+    @Test
+    fun dontFindSuperclassIfNotInherited() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<Subclass>()
+        assertThat(scanner.find<NotInherited>(method)).isNull()
+    }
+
+    @Umami
+    open class UmamiTest {
+        fun aTest() {}
+    }
+
+    @Test
+    fun metaAnnotation() {
+        val scanner = TestAnnotationScanner()
+        val method = "aTest".description<UmamiTest>()
+        assertThat(scanner.find<Flavor>(method)!!.value).isEqualTo("umami")
+    }
+
+    @RunWith(Parameterized::class)
+    class ParameterizedUmamiSubclassTest : UmamiTest() {
+        companion object {
+            @Parameterized.Parameters(name = "{0}")
+            @JvmStatic
+            fun getParams() = listOf("1", "2", "3")
+        }
+
+        @Parameterized.Parameter lateinit var param: String
+
+        @Test fun bTest() {}
+    }
+
+    @Test
+    fun parameterizedSubclass() {
+        val scanner = TestAnnotationScanner()
+        val request = Request.classes(ParameterizedUmamiSubclassTest::class.java)
+        assertThat(JUnitCore().run(request).failures).isEmpty()
+        val rootDescription = request.runner.description
+        val leaves = rootDescription.leafDescriptions()
+        assertThat(leaves.map { it.methodName }).contains("bTest[1]")
+        val bTestDescription = leaves.first { it.methodName == "bTest[1]" }
+        assertWithMessage(rootDescription.familyTree())
+            .that(scanner.find<Flavor>(bTestDescription)?.value)
+            .isEqualTo("umami")
+    }
+}
+
+private fun Description.familyTree(): String {
+    return toString() +
+        if (isTest) {
+            ""
+        } else {
+            children.map { it.familyTree() }.toString()
+        }
+}
+
+private fun Description.leafDescriptions(): List<Description> {
+    return if (isTest) {
+        listOf(this)
+    } else {
+        children.flatMap { it.leafDescriptions() }
+    }
+}
diff --git a/libraries/health/rules/src/android/platform/test/rule/ArtifactSaver.java b/libraries/health/rules/src/android/platform/test/rule/ArtifactSaver.java
index ecfd39fc2..58c29e5f0 100644
--- a/libraries/health/rules/src/android/platform/test/rule/ArtifactSaver.java
+++ b/libraries/health/rules/src/android/platform/test/rule/ArtifactSaver.java
@@ -119,10 +119,6 @@ public class ArtifactSaver {
                 "dumpsys meminfo",
                 artifactFile("MemInfo-OnFailure-" + getClassAndMethodName(description) + ".txt"));
 
-        dumpCommandOutput(
-                "cmd statusbar flag | tail +11", // Flags info starts at line 11
-                artifactFile("Flags-OnFailure-" + getClassAndMethodName(description) + ".txt"));
-
         dumpCommandOutput(
                 "dumpsys activity service SystemUI",
                 artifactFile("SystemUI-OnFailure-" + getClassAndMethodName(description) + ".txt"));
diff --git a/libraries/health/rules/src/android/platform/test/rule/DeviceTypeRule.kt b/libraries/health/rules/src/android/platform/test/rule/DeviceTypeRule.kt
index a5b4f5380..fc9a83932 100644
--- a/libraries/health/rules/src/android/platform/test/rule/DeviceTypeRule.kt
+++ b/libraries/health/rules/src/android/platform/test/rule/DeviceTypeRule.kt
@@ -16,11 +16,13 @@
 package android.platform.test.rule
 
 import android.app.Instrumentation
+import android.hardware.devicestate.DeviceState.PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY
+import android.hardware.devicestate.DeviceStateManager
+import android.hardware.devicestate.feature.flags.Flags as DeviceStateManagerFlags
 import android.os.Build
 import androidx.test.InstrumentationRegistry
 import androidx.test.uiautomator.UiDevice
 import com.android.internal.R
-import java.lang.RuntimeException
 import kotlin.annotation.AnnotationRetention.RUNTIME
 import kotlin.annotation.AnnotationTarget.ANNOTATION_CLASS
 import kotlin.annotation.AnnotationTarget.CLASS
@@ -107,11 +109,19 @@ class DeviceTypeRule : TestRule {
 }
 
 internal fun isFoldable(): Boolean {
-    return getInstrumentation()
-        .targetContext
-        .resources
-        .getIntArray(R.array.config_foldedDeviceStates)
-        .isNotEmpty()
+    if (DeviceStateManagerFlags.deviceStatePropertyMigration()) {
+        val dm: DeviceStateManager =
+            getInstrumentation().targetContext.getSystemService(DeviceStateManager::class.java)
+        return dm.supportedDeviceStates.any { state ->
+            state.hasProperty(PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY)
+        }
+    } else {
+        return getInstrumentation()
+            .targetContext
+            .resources
+            .getIntArray(R.array.config_foldedDeviceStates)
+            .isNotEmpty()
+    }
 }
 
 private val isCuttlefish get() = Build.BOARD == "cutf"
diff --git a/libraries/health/rules/src/android/platform/test/rule/DoubleLineClockRule.kt b/libraries/health/rules/src/android/platform/test/rule/DoubleLineClockRule.kt
index df4434303..1c2b7aab8 100644
--- a/libraries/health/rules/src/android/platform/test/rule/DoubleLineClockRule.kt
+++ b/libraries/health/rules/src/android/platform/test/rule/DoubleLineClockRule.kt
@@ -6,7 +6,8 @@ import android.provider.Settings
  * Rule that allows to set the double line clock on the lockscreen to be enabled/disabled. Also
  * resets the setting to its original value at the end of the test.
  */
-class DoubleLineClockRule :
+class DoubleLineClockRule(initialValue: Boolean? = null) :
     SecureSettingRule<Boolean>(
         settingName = Settings.Secure.LOCKSCREEN_USE_DOUBLE_LINE_CLOCK,
+        initialValue = initialValue,
     )
diff --git a/libraries/health/rules/src/android/platform/test/rule/LimitDevicesRule.kt b/libraries/health/rules/src/android/platform/test/rule/LimitDevicesRule.kt
index 705467793..4bf61b43a 100644
--- a/libraries/health/rules/src/android/platform/test/rule/LimitDevicesRule.kt
+++ b/libraries/health/rules/src/android/platform/test/rule/LimitDevicesRule.kt
@@ -20,6 +20,7 @@ import android.platform.test.rule.DeviceProduct.CF_PHONE
 import android.platform.test.rule.DeviceProduct.CF_TABLET
 import android.util.Log
 import androidx.test.platform.app.InstrumentationRegistry
+import java.lang.annotation.Inherited
 import kotlin.annotation.AnnotationRetention.RUNTIME
 import kotlin.annotation.AnnotationTarget.CLASS
 import kotlin.annotation.AnnotationTarget.FUNCTION
@@ -28,19 +29,22 @@ import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
 
-/** Limits the test to run on devices specified by [allowed], */
+/** Limits the test to run on devices specified by [allowed] */
 @Retention(RUNTIME)
 @Target(FUNCTION, CLASS)
+@Inherited
 annotation class AllowedDevices(vararg val allowed: DeviceProduct)
 
 /** Does not run the test on device specified by [denied], */
 @Retention(RUNTIME)
 @Target(FUNCTION, CLASS)
+@Inherited
 annotation class DeniedDevices(vararg val denied: DeviceProduct)
 
 /** Limits the test on default screenshot devices, or [allowed] devices if specified. */
 @Retention(RUNTIME)
 @Target(FUNCTION, CLASS)
+@Inherited
 annotation class ScreenshotTestDevices(vararg val allowed: DeviceProduct = [CF_PHONE, CF_TABLET])
 
 /**
@@ -50,13 +54,17 @@ annotation class ScreenshotTestDevices(vararg val allowed: DeviceProduct = [CF_P
  */
 @Retention(RUNTIME)
 @Target(FUNCTION, CLASS)
+@Inherited
 annotation class FlakyDevices(vararg val flaky: DeviceProduct)
 
 /**
  * Ignore LimitDevicesRule constraints when [ignoreLimit] is true. Main use case is to allow local
  * builds to bypass [LimitDevicesRule] and be able to run on any devices.
  */
-@Retention(RUNTIME) @Target(FUNCTION, CLASS) annotation class IgnoreLimit(val ignoreLimit: Boolean)
+@Retention(RUNTIME)
+@Target(FUNCTION, CLASS)
+@Inherited
+annotation class IgnoreLimit(val ignoreLimit: Boolean)
 
 /**
  * Limits a test to run specified devices.
@@ -77,40 +85,43 @@ class LimitDevicesRule(
     private val thisDevice: String = Build.PRODUCT,
     private val runningFlakyTests: Boolean = false,
 ) : TestRule {
+    val scanner = TestAnnotationScanner()
+
     override fun apply(base: Statement, description: Description): Statement {
-        if (description.ignoreLimit()) {
+        val skipReason = skipReasonIfAny(description)
+        if (skipReason == null) {
             return base
+        } else {
+            return makeAssumptionViolatedStatement(skipReason)
+        }
+    }
+
+    fun skipReasonIfAny(description: Description): String? {
+        if (description.ignoreLimit()) {
+            return null
         }
 
         val limitDevicesAnnotations = description.limitDevicesAnnotation()
         if (limitDevicesAnnotations.count() > 1) {
-            return makeAssumptionViolatedStatement(
-                "Only one LimitDeviceRule annotation is supported. Found $limitDevicesAnnotations"
-            )
+            return "Only one LimitDeviceRule annotation is supported. Found $limitDevicesAnnotations"
         }
         val deniedDevices = description.deniedDevices()
         if (thisDevice in deniedDevices) {
-            return makeAssumptionViolatedStatement(
-                "Skipping test as $thisDevice is in $deniedDevices"
-            )
+            return "Skipping test as $thisDevice is in $deniedDevices"
         }
 
         val flakyDevices = description.flakyDevices()
         if (thisDevice in flakyDevices) {
             if (!runningFlakyTests) {
-                return makeAssumptionViolatedStatement(
-                    "Skipping test as $thisDevice is flaky and this config excludes fakes"
-                )
+                return "Skipping test as $thisDevice is flaky and this config excludes flakes"
             }
         }
 
         val allowedDevices = description.allowedDevices()
         if (allowedDevices.isEmpty() || thisDevice in allowedDevices) {
-            return base
+            return null
         }
-        return makeAssumptionViolatedStatement(
-            "Skipping test as $thisDevice in not in $allowedDevices"
-        )
+        return "Skipping test as $thisDevice in not in $allowedDevices"
     }
 
     private fun Description.allowedDevices(): List<String> =
@@ -136,18 +147,10 @@ class LimitDevicesRule(
             .toSet()
 
     private fun Description.ignoreLimit(): Boolean =
-        getAnnotation(IgnoreLimit::class.java)?.ignoreLimit == true ||
-            testClass?.getClassAnnotation<IgnoreLimit>()?.ignoreLimit == true
-
-    private inline fun <reified T : Annotation> Description.getMostSpecificAnnotation(): T? {
-        getAnnotation(T::class.java)?.let {
-            return it
-        }
-        return testClass?.getClassAnnotation<T>()
-    }
+        getMostSpecificAnnotation<IgnoreLimit>()?.ignoreLimit == true
 
-    private inline fun <reified T : Annotation> Class<*>.getClassAnnotation() =
-        getLowestAncestorClassAnnotation(this, T::class.java)
+    private inline fun <reified T : Annotation> Description.getMostSpecificAnnotation() =
+        scanner.find<T>(this)
 
     private fun List<Array<out DeviceProduct>?>.collectProducts() =
         filterNotNull().flatMap { it.toList() }.map { it.product }
@@ -176,7 +179,9 @@ enum class DeviceProduct(val product: String) {
     CF_PHONE("cf_x86_64_phone"),
     CF_TABLET("cf_x86_64_tablet"),
     CF_FOLDABLE("cf_x86_64_foldable"),
+    CF_COMET("cf_x86_64_comet"),
     CF_AUTO("cf_x86_64_auto"),
+    CF_ARM_PHONE("cf_arm64_only_phone"),
     TANGORPRO("tangorpro"),
     FELIX("felix"),
     ROBOLECTRIC("robolectric"),
diff --git a/libraries/health/rules/src/android/platform/test/rule/SetWattsonMarkersRule.java b/libraries/health/rules/src/android/platform/test/rule/SetWattsonMarkersRule.java
new file mode 100644
index 000000000..a037ccfed
--- /dev/null
+++ b/libraries/health/rules/src/android/platform/test/rule/SetWattsonMarkersRule.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.test.rule;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+import org.junit.runner.Description;
+import org.junit.runners.model.InitializationError;
+
+/**
+ * Rule to insert Wattson start and stop markers around a test
+ */
+public class SetWattsonMarkersRule extends TestWatcher {
+    public SetWattsonMarkersRule() {}
+
+    @Override
+    protected void starting(Description description) {
+        writeTraceMarker("I|0|wattson_start");
+    }
+
+    @Override
+    protected void finished(Description description) {
+        writeTraceMarker("I|0|wattson_stop");
+    }
+
+    private void writeTraceMarker(String marker) {
+        // Create a temporary file which contains the markers command.
+        // Do this because we cannot write to sysfs directly, as executeShellCommand parses the '>'
+        // character as a literal.
+        File tempDir = InstrumentationRegistry.getInstrumentation().getContext().getCacheDir();
+        File tempFile = null;
+        try {
+            tempFile = File.createTempFile("echo_marker_script", ".sh", tempDir);
+            tempFile.setWritable(true);
+            tempFile.setExecutable(true, /*ownersOnly*/false);
+            try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile.toString()))) {
+                writer.write(String.format("echo '%s' > /sys/kernel/tracing/trace_marker", marker));
+            }
+            executeShellCommand(tempFile.toString());
+        } catch (IOException e) {
+            throw new AssertionError (e);
+        } finally {
+            if (tempFile != null && tempFile.exists()) {
+                tempFile.delete();
+            }
+        }
+    }
+}
diff --git a/libraries/health/rules/src/android/platform/test/rule/TestAnnotationScanner.kt b/libraries/health/rules/src/android/platform/test/rule/TestAnnotationScanner.kt
new file mode 100644
index 000000000..64d65a774
--- /dev/null
+++ b/libraries/health/rules/src/android/platform/test/rule/TestAnnotationScanner.kt
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.rule
+
+import kotlin.reflect.KClass
+import kotlin.reflect.cast
+import kotlin.reflect.full.hasAnnotation
+import org.junit.runner.Description
+
+/**
+ * Marks an annotation class as a "meta-annotation", which for our purposes means that it bundles
+ * together one or more test-behavior-affecting annotation values for reuse in multiple places in
+ * the test suite, if the runner or rule in question uses [TestAnnotationScanner]. For example:
+ * ```
+ * @Retention(AnnotationRetention.RUNTIME)
+ * annotation class Flavor(val value: String = "")
+ *
+ * @Retention(AnnotationRetention.RUNTIME)
+ * @MetaAnnotation
+ * @Flavor("umami")
+ * annotation class Umami()
+ *
+ * // This test should be treated as if annotation with `@Flavor("umami")`
+ * @Umami
+ * class SushiTest {
+ * }
+ * ```
+ */
+@Retention(AnnotationRetention.RUNTIME) annotation class MetaAnnotation
+
+/**
+ * Scans for annotations on test methods and classes that may affect test runners or rules.
+ *
+ * (Encapsulated as an object to allow potentially caching results in the future, based on
+ * experience on annotation reflection performance in JUnit 4.)
+ *
+ * @see [find] for primary usage
+ */
+class TestAnnotationScanner {
+    /** inline reified version of [find] for more concise usage in Kotlin */
+    inline fun <reified T : Annotation> find(description: Description) = find(T::class, description)
+
+    /**
+     * Find the most-relevant instance of [annotationClass] for the leaf-level test method described
+     * by [description], or null if none exists. The rules include:
+     * - if there is no such annotation on the test method, looks for an annotation on the class
+     * - if [annotationClass] is marked with [java.lang.annotation.Inherited], then the superclass
+     *   hierarchy will be searched for a relevant annotation
+     * - if there are any annotations on the method or class, (or superclasses if [Inherited]) that
+     *   are marked with [MetaAnnotation], then the annotations on the meta-annotation will be
+     *   recursively searched (see [MetaAnnotation])
+     */
+    fun <T : Annotation> find(annotationClass: KClass<T>, description: Description): T? {
+        findAnnotation(annotationClass, description.annotations)?.let {
+            return it
+        }
+        val testClass =
+            description.testClass
+                ?: throw IllegalArgumentException(
+                    "Could not find class for test: ${description.displayName}"
+                )
+        findAnnotation(annotationClass, testClass.annotations.toList())?.let {
+            return it
+        }
+        return null
+    }
+
+    private fun <T : Annotation> findAnnotation(
+        annotationClass: KClass<T>,
+        annotations: Collection<Annotation>,
+    ): T? {
+        annotations.forEach { annotation ->
+            if (annotationClass.isInstance(annotation)) {
+                return annotationClass.cast(annotation)
+            }
+            val maybeMeta = annotation.annotationClass
+            if (maybeMeta.hasAnnotation<MetaAnnotation>()) {
+                findAnnotation(annotationClass, maybeMeta.annotations)?.let {
+                    return it
+                }
+            }
+        }
+        return null
+    }
+}
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/ComposeToolkit.kt b/libraries/motion/compose/src/platform/test/motion/compose/ComposeToolkit.kt
index 6bd7ff8d9..cae93756c 100644
--- a/libraries/motion/compose/src/platform/test/motion/compose/ComposeToolkit.kt
+++ b/libraries/motion/compose/src/platform/test/motion/compose/ComposeToolkit.kt
@@ -24,12 +24,13 @@ import androidx.compose.runtime.setValue
 import androidx.compose.ui.geometry.Offset
 import androidx.compose.ui.graphics.ImageBitmap
 import androidx.compose.ui.graphics.asAndroidBitmap
+import androidx.compose.ui.graphics.asImageBitmap
 import androidx.compose.ui.platform.ViewConfiguration
+import androidx.compose.ui.platform.ViewRootForTest
 import androidx.compose.ui.test.ExperimentalTestApi
 import androidx.compose.ui.test.SemanticsNodeInteraction
 import androidx.compose.ui.test.SemanticsNodeInteractionsProvider
 import androidx.compose.ui.test.TouchInjectionScope
-import androidx.compose.ui.test.captureToImage
 import androidx.compose.ui.test.junit4.ComposeContentTestRule
 import androidx.compose.ui.test.junit4.ComposeTestRule
 import androidx.compose.ui.test.junit4.createComposeRule
@@ -37,6 +38,7 @@ import androidx.compose.ui.test.onRoot
 import androidx.compose.ui.test.performTouchInput
 import androidx.compose.ui.unit.Density
 import androidx.compose.ui.unit.IntSize
+import java.util.concurrent.TimeUnit
 import kotlin.math.roundToInt
 import kotlin.time.Duration
 import kotlin.time.Duration.Companion.milliseconds
@@ -68,12 +70,10 @@ import platform.test.screenshot.DeviceEmulationRule
 import platform.test.screenshot.DeviceEmulationSpec
 import platform.test.screenshot.Displays
 import platform.test.screenshot.GoldenPathManager
+import platform.test.screenshot.captureToBitmapAsync
 
 /** Toolkit to support Compose-based [MotionTestRule] tests. */
-class ComposeToolkit(
-    val composeContentTestRule: ComposeContentTestRule,
-    val testScope: TestScope,
-) {
+class ComposeToolkit(val composeContentTestRule: ComposeContentTestRule, val testScope: TestScope) {
     internal companion object {
         const val TAG = "ComposeToolkit"
     }
@@ -82,7 +82,7 @@ class ComposeToolkit(
 /** Runs a motion test in the [ComposeToolkit.testScope] */
 fun MotionTestRule<ComposeToolkit>.runTest(
     timeout: Duration = 20.seconds,
-    testBody: suspend MotionTestRule<ComposeToolkit>.() -> Unit
+    testBody: suspend MotionTestRule<ComposeToolkit>.() -> Unit,
 ) {
     val motionTestRule = this
     toolkit.testScope.runTest(timeout) { testBody.invoke(motionTestRule) }
@@ -98,7 +98,7 @@ fun MotionTestRule<ComposeToolkit>.runTest(
 fun createComposeMotionTestRule(
     goldenPathManager: GoldenPathManager,
     testScope: TestScope = TestScope(),
-    deviceEmulationSpec: DeviceEmulationSpec = DeviceEmulationSpec(Displays.Phone)
+    deviceEmulationSpec: DeviceEmulationSpec = DeviceEmulationSpec(Displays.Phone),
 ): MotionTestRule<ComposeToolkit> {
     val deviceEmulationRule = DeviceEmulationRule(deviceEmulationSpec)
     val composeRule = createComposeRule(testScope.coroutineContext)
@@ -106,7 +106,7 @@ fun createComposeMotionTestRule(
     return MotionTestRule(
         ComposeToolkit(composeRule, testScope),
         goldenPathManager,
-        extraRules = RuleChain.outerRule(deviceEmulationRule).around(composeRule)
+        extraRules = RuleChain.outerRule(deviceEmulationRule).around(composeRule),
     )
 }
 
@@ -122,7 +122,7 @@ fun createComposeMotionTestRule(
 class MotionControl(
     val delayReadyToPlay: MotionControlFn = {},
     val delayRecording: MotionControlFn = {},
-    val recording: MotionControlFn
+    val recording: MotionControlFn,
 )
 
 typealias MotionControlFn = suspend MotionControlScope.() -> Unit
@@ -146,7 +146,7 @@ interface MotionControlScope : SemanticsNodeInteractionsProvider {
      */
     suspend fun performTouchInputAsync(
         onNode: SemanticsNodeInteraction,
-        gestureControl: TouchInjectionScope.() -> Unit
+        gestureControl: TouchInjectionScope.() -> Unit,
     )
 }
 
@@ -185,7 +185,7 @@ data class ComposeRecordingSpec(
                 motionControl = MotionControl { awaitCondition { checkDone() } },
                 recordBefore,
                 recordAfter,
-                timeSeriesCapture
+                timeSeriesCapture,
             )
         }
     }
@@ -210,7 +210,10 @@ fun MotionTestRule<ComposeToolkit>.recordMotion(
             Log.i(TAG, "recordFrame($frameId)")
             frameIdCollector.add(frameId)
             recordingSpec.timeSeriesCapture.invoke(TimeSeriesCaptureScope(this, propertyCollector))
-            screenshotCollector.add(onRoot().captureToImage())
+
+            val view = (onRoot().fetchSemanticsNode().root as ViewRootForTest).view
+            val bitmap = view.captureToBitmapAsync().get(10, TimeUnit.SECONDS)
+            screenshotCollector.add(bitmap.asImageBitmap())
         }
 
         var playbackStarted by mutableStateOf(false)
@@ -226,7 +229,7 @@ fun MotionTestRule<ComposeToolkit>.recordMotion(
             MotionControlImpl(
                 toolkit.composeContentTestRule,
                 toolkit.testScope,
-                recordingSpec.motionControl
+                recordingSpec.motionControl,
             )
 
         Log.i(TAG, "recordMotion() awaiting readyToPlay")
@@ -266,7 +269,7 @@ fun MotionTestRule<ComposeToolkit>.recordMotion(
         val timeSeries =
             TimeSeries(
                 frameIdCollector.toList(),
-                propertyCollector.entries.map { entry -> Feature(entry.key, entry.value) }
+                propertyCollector.entries.map { entry -> Feature(entry.key, entry.value) },
             )
 
         return create(timeSeries, screenshotCollector.map { it.asAndroidBitmap() })
@@ -285,7 +288,7 @@ enum class MotionControlState {
 private class MotionControlImpl(
     val composeTestRule: ComposeTestRule,
     val testScope: TestScope,
-    val motionControl: MotionControl
+    val motionControl: MotionControl,
 ) : MotionControlScope, SemanticsNodeInteractionsProvider by composeTestRule {
 
     private var state = MotionControlState.Start
@@ -375,7 +378,7 @@ private class MotionControlImpl(
 
     override suspend fun performTouchInputAsync(
         onNode: SemanticsNodeInteraction,
-        gestureControl: TouchInjectionScope.() -> Unit
+        gestureControl: TouchInjectionScope.() -> Unit,
     ) {
         val node = onNode.fetchSemanticsNode()
         val density = node.layoutInfo.density
@@ -429,7 +432,7 @@ private sealed interface TouchEventRecorderEntry {
 private class TouchEventRecorder(
     density: Density,
     override val viewConfiguration: ViewConfiguration,
-    override val visibleSize: IntSize
+    override val visibleSize: IntSize,
 ) : TouchInjectionScope, Density by density {
 
     val lastPositions = mutableMapOf<Int, Offset>()
@@ -464,7 +467,7 @@ private class TouchEventRecorder(
     override fun moveWithHistoryMultiPointer(
         relativeHistoricalTimes: List<Long>,
         historicalCoordinates: List<List<Offset>>,
-        delayMillis: Long
+        delayMillis: Long,
     ) {
         TODO("Not yet supported")
     }
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt b/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
index 398153e01..dbca5ad3f 100644
--- a/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
+++ b/libraries/motion/compose/src/platform/test/motion/compose/DataPointTypes.kt
@@ -22,6 +22,7 @@ import androidx.compose.ui.geometry.isUnspecified
 import androidx.compose.ui.unit.Dp
 import androidx.compose.ui.unit.DpOffset
 import androidx.compose.ui.unit.DpSize
+import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.IntSize
 import androidx.compose.ui.unit.dp
 import java.lang.reflect.Array.getDouble
@@ -52,7 +53,7 @@ object DataPointTypes {
                     else -> throw UnknownTypeException()
                 }
             },
-            valueToJson = { it.value }
+            valueToJson = { it.value },
         )
 
     val intSize: DataPointType<IntSize> =
@@ -68,7 +69,23 @@ object DataPointTypes {
                     put("width", it.width)
                     put("height", it.height)
                 }
-            }
+            },
+        )
+
+    val intOffset: DataPointType<IntOffset> =
+        DataPointType(
+            "intOffset",
+            jsonToValue = {
+                with(it as? JSONObject ?: throw UnknownTypeException()) {
+                    IntOffset(getInt("x"), getInt("y"))
+                }
+            },
+            valueToJson = {
+                JSONObject().apply {
+                    put("x", it.x)
+                    put("y", it.y)
+                }
+            },
         )
 
     val dpSize: DataPointType<DpSize> =
@@ -84,7 +101,7 @@ object DataPointTypes {
                     put("width", it.width.value)
                     put("height", it.height.value)
                 }
-            }
+            },
         )
 
     val dpOffset: DataPointType<DpOffset> =
@@ -100,7 +117,7 @@ object DataPointTypes {
                     put("x", it.x.value)
                     put("y", it.y.value)
                 }
-            }
+            },
         )
 
     val offset: DataPointType<Offset> =
@@ -125,6 +142,6 @@ object DataPointTypes {
                             put("y", it.y)
                         }
                 }
-            }
+            },
         )
 }
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/MotionTestValues.kt b/libraries/motion/compose/src/platform/test/motion/compose/MotionTestValues.kt
index 860e3beeb..156772391 100644
--- a/libraries/motion/compose/src/platform/test/motion/compose/MotionTestValues.kt
+++ b/libraries/motion/compose/src/platform/test/motion/compose/MotionTestValues.kt
@@ -37,7 +37,7 @@ fun <T> hasMotionTestValue(motionTestValueKey: MotionTestValueKey<T>): Semantics
 fun <T> SemanticsNodeInteractionsProvider.motionTestValueOfNode(
     motionTestValueKey: MotionTestValueKey<T>,
     matcher: SemanticsMatcher = hasMotionTestValue(motionTestValueKey),
-    useUnmergedTree: Boolean = false
+    useUnmergedTree: Boolean = false,
 ): T = onNode(matcher, useUnmergedTree).fetchSemanticsNode().get(motionTestValueKey)
 
 /**
@@ -51,7 +51,7 @@ fun <T : Any> TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.feature(
     motionTestValueKey: MotionTestValueKey<T>,
     dataPointType: DataPointType<T>,
     matcher: SemanticsMatcher = hasMotionTestValue(motionTestValueKey),
-    name: String = motionTestValueKey.semanticsPropertyKey.name
+    name: String = motionTestValueKey.semanticsPropertyKey.name,
 ) {
     feature(
         matcher,
@@ -70,12 +70,9 @@ fun <T> TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.feature(
     motionTestValueKey: MotionTestValueKey<T>,
     capture: FeatureCapture<T, *>,
     matcher: SemanticsMatcher = hasMotionTestValue(motionTestValueKey),
-    name: String = "${motionTestValueKey.semanticsPropertyKey.name}_${capture.name}"
+    name: String = "${motionTestValueKey.semanticsPropertyKey.name}_${capture.name}",
 ) {
-    feature(
-        matcher,
-        FeatureCapture(name) { capture.capture(it.get(motionTestValueKey)) },
-    )
+    feature(matcher, FeatureCapture(name) { capture.capture(it.get(motionTestValueKey)) })
 }
 
 private fun <T> SemanticsNode.get(motionTestValueKey: MotionTestValueKey<T>) =
diff --git a/libraries/motion/compose/src/platform/test/motion/compose/TransitionFeatureCapture.kt b/libraries/motion/compose/src/platform/test/motion/compose/TransitionFeatureCapture.kt
new file mode 100644
index 000000000..3b33d07fa
--- /dev/null
+++ b/libraries/motion/compose/src/platform/test/motion/compose/TransitionFeatureCapture.kt
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion.compose
+
+import androidx.compose.animation.EnterExitState
+import androidx.compose.animation.core.Transition
+import androidx.compose.ui.test.SemanticsMatcher
+import androidx.compose.ui.test.SemanticsNodeInteractionsProvider
+import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.IntSize
+import org.json.JSONObject
+import platform.test.motion.compose.DataPointTypes.intOffset
+import platform.test.motion.compose.DataPointTypes.intSize
+import platform.test.motion.compose.TransitionFeatureCapture.animatedVisibility
+import platform.test.motion.compose.TransitionFeatureCapture.animatedVisibilityTransitions
+import platform.test.motion.compose.values.MotionTestValueKey
+import platform.test.motion.golden.DataPoint
+import platform.test.motion.golden.DataPointType
+import platform.test.motion.golden.DataPointTypes.float
+import platform.test.motion.golden.FeatureCapture
+import platform.test.motion.golden.NotFoundDataPoint
+import platform.test.motion.golden.TimeSeriesCaptureScope
+import platform.test.motion.golden.UnknownTypeException
+
+/**
+ * Captures animations started by the built-in `Transition.AnimatedContent(...)` transitions.
+ *
+ * Note: `Transition.AnimatedContent(...)` does not support providing a transition label currently.
+ * The `getTransitionLabel` is intended as a stop-gap for providing this label after the fact, and
+ * will be removed once the compose API is updated.
+ *
+ * @param getTransitionLabel Returns a label for the n-th AnimatedVisibility transition. The index
+ *   represents the compose Order
+ */
+fun <T> TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.animatedVisibilityFeatures(
+    transitionValueKey: MotionTestValueKey<Transition<T>>,
+    matcher: SemanticsMatcher = hasMotionTestValue(transitionValueKey),
+    name: String = transitionValueKey.semanticsPropertyKey.name,
+    getTransitionLabel: (index: Int) -> String = { "AnimatedVisibility[$it]" },
+) {
+    on({
+        try {
+            it.onNode(matcher).fetchSemanticsNode().config[transitionValueKey.semanticsPropertyKey]
+        } catch (e: AssertionError) {
+            null
+        }
+    }) {
+        feature(
+            FeatureCapture(name) { rootTransition ->
+                DataPoint.of(
+                    buildMap {
+                        val enterExitTransitions =
+                            rootTransition.transitions.filterEnterExitTransitions()
+
+                        enterExitTransitions
+                            .filterByDirection(
+                                source = EnterExitState.PreEnter,
+                                target = EnterExitState.Visible,
+                            )
+                            .forEachIndexed { index, transition ->
+                                val transitionLabel = "${getTransitionLabel(index)}::Enter"
+
+                                put(transitionLabel, animatedVisibility.capture(transition))
+                            }
+                        enterExitTransitions
+                            .filterByDirection(
+                                source = EnterExitState.Visible,
+                                target = EnterExitState.PostExit,
+                            )
+                            .forEachIndexed { index, transition ->
+                                val transitionLabel = "${getTransitionLabel(index)}::Exit"
+
+                                put(transitionLabel, animatedVisibility.capture(transition))
+                            }
+                    },
+                    animatedVisibilityTransitions,
+                )
+            }
+        )
+    }
+}
+
+fun <T> ComposeRecordingSpec.Companion.duringTransition(
+    transitionValueKey: MotionTestValueKey<Transition<T>>,
+    recordBefore: Boolean = true,
+    recordAfter: Boolean = true,
+    timeSeriesCapture: TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.() -> Unit,
+): ComposeRecordingSpec {
+    return ComposeRecordingSpec(
+        motionControl =
+            MotionControl {
+                awaitCondition { motionTestValueOfNode(transitionValueKey).isRunning }
+                awaitCondition { !motionTestValueOfNode(transitionValueKey).isRunning }
+            },
+        recordBefore,
+        recordAfter,
+        timeSeriesCapture,
+    )
+}
+
+@SuppressWarnings("unchecked_cast")
+private fun List<Transition<*>>.filterEnterExitTransitions(): List<Transition<EnterExitState>> =
+    filter {
+            // http://go/cs-compose/symbol/AnimatedEnterExitImpl
+            it.label?.endsWith("> EnterExitTransition") == true && it.currentState is EnterExitState
+        }
+        .map { it as Transition<EnterExitState> }
+
+private fun List<Transition<EnterExitState>>.filterByDirection(
+    source: EnterExitState,
+    target: EnterExitState,
+) = filter { it.currentState == source && it.targetState == target }
+
+internal typealias AnimatedVisibilityTransitions = Map<String, DataPoint<AnimatedVisibilityValues>>
+
+internal data class AnimatedVisibilityValues(
+    val alpha: DataPoint<Float>,
+    val slide: DataPoint<IntOffset>,
+    val scale: DataPoint<Float>,
+    val size: DataPoint<IntSize>,
+)
+
+internal object TransitionFeatureCapture {
+    val animatedVisibilityTransitions: DataPointType<AnimatedVisibilityTransitions> =
+        DataPointType(
+            "animatedVisibilityTransitions",
+            jsonToValue = {
+                with(it as? JSONObject ?: throw UnknownTypeException()) {
+                    buildMap {
+                        for (key in keys()) {
+                            put(key, animatedVisibilityValues.fromJson(it.get(key)))
+                        }
+                    }
+                }
+            },
+            valueToJson = {
+                JSONObject().apply { it.forEach { (key, value) -> put(key, value.asJson()) } }
+            },
+        )
+
+    val animatedVisibilityValues: DataPointType<AnimatedVisibilityValues> =
+        DataPointType(
+            "animatedVisibilityValues",
+            jsonToValue = { json ->
+                with(json as? JSONObject ?: throw UnknownTypeException()) {
+                    val alpha =
+                        if (json.has(alphaProperty)) float.fromJson(json.get(alphaProperty))
+                        else DataPoint.notFound()
+                    val slide =
+                        if (json.has(slideProperty)) intOffset.fromJson(json.get(slideProperty))
+                        else DataPoint.notFound()
+                    val scale =
+                        if (json.has(scaleProperty)) float.fromJson(json.get(scaleProperty))
+                        else DataPoint.notFound()
+                    val size =
+                        if (json.has(sizeProperty)) intSize.fromJson(json.get(sizeProperty))
+                        else DataPoint.notFound()
+
+                    AnimatedVisibilityValues(alpha, slide, scale, size)
+                }
+            },
+            valueToJson = { value ->
+                JSONObject().apply {
+                    value.alpha
+                        .takeIf { it !is NotFoundDataPoint }
+                        ?.also { put(alphaProperty, it.asJson()) }
+                    value.slide
+                        .takeIf { it !is NotFoundDataPoint }
+                        ?.also { put(slideProperty, it.asJson()) }
+                    value.scale
+                        .takeIf { it !is NotFoundDataPoint }
+                        ?.also { put(scaleProperty, it.asJson()) }
+                    value.size
+                        .takeIf { it !is NotFoundDataPoint }
+                        ?.also { put(sizeProperty, it.asJson()) }
+                }
+            },
+        )
+
+    val animatedVisibility =
+        FeatureCapture<Transition<EnterExitState>, AnimatedVisibilityValues>(
+            "Animated Visibility"
+        ) { transition ->
+            var alpha = DataPoint.notFound<Float>()
+            var slide = DataPoint.notFound<IntOffset>()
+            var scale = DataPoint.notFound<Float>()
+            var size = DataPoint.notFound<IntSize>()
+
+            // Built-in animations are created in these functions:
+            // http://go/cs-compose/symbol/createModifier/file:EnterExitTransition
+            // http://go/cs-compose/symbol/createGraphicsLayerBlock/file:EnterExitTransition
+
+            transition.animations.forEach {
+                when (it.label) {
+                    "Built-in alpha" -> alpha = DataPoint.of(it.value as Float?, float)
+                    "Built-in slide" -> slide = DataPoint.of(it.value as IntOffset?, intOffset)
+                    "Built-in scale" -> scale = DataPoint.of(it.value as Float?, float)
+                    "Built-in shrink/expand" -> size = DataPoint.of(it.value as IntSize?, intSize)
+                }
+            }
+
+            DataPoint.of(
+                AnimatedVisibilityValues(alpha, slide, scale, size),
+                animatedVisibilityValues,
+            )
+        }
+
+    private const val alphaProperty = "alpha"
+    private const val slideProperty = "slide"
+    private const val scaleProperty = "scale"
+    private const val sizeProperty = "size"
+}
diff --git a/libraries/motion/compose/tests/AndroidManifest.xml b/libraries/motion/compose/tests/AndroidManifest.xml
index 32127dee9..0dc72c93a 100644
--- a/libraries/motion/compose/tests/AndroidManifest.xml
+++ b/libraries/motion/compose/tests/AndroidManifest.xml
@@ -19,7 +19,8 @@
 
     <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
 
-    <application>
+    <application
+        android:theme="@style/Theme.AppCompat.Light.NoActionBar">
         <uses-library android:name="android.test.runner" />
     </application>
 
diff --git a/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesDefaultTransition.json b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesDefaultTransition.json
new file mode 100644
index 000000000..0231be59d
--- /dev/null
+++ b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesDefaultTransition.json
@@ -0,0 +1,184 @@
+{
+  "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    48,
+    64,
+    80,
+    96,
+    112,
+    128,
+    144,
+    160,
+    176,
+    192,
+    208,
+    224,
+    240,
+    256,
+    272,
+    288,
+    304,
+    320,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "test_transition",
+      "type": "animatedVisibilityTransitions",
+      "data_points": [
+        {},
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.90025705
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.48624206
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.18556798
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.05656153
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0,
+            "scale": 0.92
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.007037282
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.0016364644,
+            "scale": 0.9201309
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.025862994,
+            "scale": 0.9220691
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.09289477,
+            "scale": 0.9274316
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.22583008,
+            "scale": 0.9380664
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.41684115,
+            "scale": 0.9533473
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.59469557,
+            "scale": 0.96757567
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.725448,
+            "scale": 0.9780358
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.8176699,
+            "scale": 0.9854136
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.882954,
+            "scale": 0.99063635
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.92908186,
+            "scale": 0.99432653
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9610159,
+            "scale": 0.99688125
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9820254,
+            "scale": 0.99856204
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.99435395,
+            "scale": 0.9995483
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9996045,
+            "scale": 0.99996835
+          }
+        },
+        {}
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesFade.json b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesFade.json
new file mode 100644
index 000000000..2cfe4765e
--- /dev/null
+++ b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesFade.json
@@ -0,0 +1,214 @@
+{
+  "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    48,
+    64,
+    80,
+    96,
+    112,
+    128,
+    144,
+    160,
+    176,
+    192,
+    208,
+    224,
+    240,
+    256,
+    272,
+    288,
+    304,
+    320,
+    336,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "test_transition",
+      "type": "animatedVisibilityTransitions",
+      "data_points": [
+        {},
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.041483272
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.9585167
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.13524042
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.86475956
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.24952994
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.75047004
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.36607495
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.633925
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.47506905
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.52493095
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.5719077
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.42809233
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.6550744
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.34492555
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.7247951
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.27520487
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.7821971
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.21780288
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.8287988
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.17120126
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.8662106
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.13378945
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.89597094
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.10402903
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.919465
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.080535
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9378929
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.062107105
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.95226747
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.047732532
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.96342677
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.03657326
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9720537
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.027946273
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9786985
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.021301514
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.9837997
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.016200291
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "alpha": 0.98770446
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "alpha": 0.012295524
+          }
+        },
+        {}
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesSlide.json b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesSlide.json
new file mode 100644
index 000000000..5620116a5
--- /dev/null
+++ b/libraries/motion/compose/tests/goldens/recordMotion_AnimatedContent_capturesSlide.json
@@ -0,0 +1,211 @@
+{
+  "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    48,
+    64,
+    80,
+    96,
+    112,
+    128,
+    144,
+    160,
+    176,
+    192,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "test_transition",
+      "type": "animatedVisibilityTransitions",
+      "data_points": [
+        {},
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 175
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": 0
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 175
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": 0
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 153
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -22
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 113
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -62
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 78
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -97
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 51
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -124
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 32
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -143
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 20
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -155
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 12
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -163
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 7
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -168
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 4
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -171
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 3
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -172
+            }
+          }
+        },
+        {
+          "AnimatedVisibility[0]::Enter": {
+            "slide": {
+              "x": 0,
+              "y": 1
+            }
+          },
+          "AnimatedVisibility[0]::Exit": {
+            "slide": {
+              "x": 0,
+              "y": -174
+            }
+          }
+        },
+        {}
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/motion/compose/tests/goldens/recordMotion_twoAnimatedContents_allowsNamingTransitions.json b/libraries/motion/compose/tests/goldens/recordMotion_twoAnimatedContents_allowsNamingTransitions.json
new file mode 100644
index 000000000..36b4bbcb0
--- /dev/null
+++ b/libraries/motion/compose/tests/goldens/recordMotion_twoAnimatedContents_allowsNamingTransitions.json
@@ -0,0 +1,340 @@
+{
+  "frame_ids": [
+    "before",
+    0,
+    16,
+    32,
+    48,
+    64,
+    80,
+    96,
+    112,
+    128,
+    144,
+    160,
+    176,
+    192,
+    208,
+    224,
+    240,
+    256,
+    272,
+    288,
+    304,
+    320,
+    336,
+    352,
+    368,
+    384,
+    400,
+    416,
+    432,
+    448,
+    464,
+    480,
+    496,
+    512,
+    "after"
+  ],
+  "features": [
+    {
+      "name": "test_transition",
+      "type": "animatedVisibilityTransitions",
+      "data_points": [
+        {},
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 1
+          },
+          "two::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 1
+          },
+          "two::Exit": {
+            "alpha": 1
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.9229404
+          },
+          "two::Exit": {
+            "alpha": 0.9229404
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.5782508
+          },
+          "two::Exit": {
+            "alpha": 0.5782508
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.25091302
+          },
+          "two::Exit": {
+            "alpha": 0.25091302
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.09543866
+          },
+          "two::Exit": {
+            "alpha": 0.09543866
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.024732292
+          },
+          "two::Exit": {
+            "alpha": 0.024732292
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          },
+          "one::Exit": {
+            "alpha": 0.0008595586
+          },
+          "two::Exit": {
+            "alpha": 0.0008595586
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.003614861
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.039107826
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.13394694
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.31306237
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.5245707
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.68782955
+          },
+          "two::Enter": {
+            "alpha": 0
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.7996198
+          },
+          "two::Enter": {
+            "alpha": 0.00086708216
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.8759679
+          },
+          "two::Enter": {
+            "alpha": 0.025862994
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.9281181
+          },
+          "two::Enter": {
+            "alpha": 0.1028615
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.9629379
+          },
+          "two::Enter": {
+            "alpha": 0.26111406
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.98475736
+          },
+          "two::Enter": {
+            "alpha": 0.47459888
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.9964471
+          },
+          "two::Enter": {
+            "alpha": 0.65247446
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.7755618
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.8594967
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.9169188
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.95558983
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.9803462
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.99435395
+          }
+        },
+        {
+          "one::Enter": {
+            "alpha": 0.99978864
+          }
+        },
+        {}
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
index e4449a598..f89a1cabb 100644
--- a/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/ComposeToolkitTest.kt
@@ -93,7 +93,7 @@ class ComposeToolkitTest {
                     },
                     ComposeRecordingSpec.until({ completed }) {
                         feature(hasTestTag("foo"), ComposeFeatureCaptures.positionInRoot)
-                    }
+                    },
                 )
 
             assertThat(motion).timeSeriesMatchesGolden()
@@ -118,7 +118,7 @@ class ComposeToolkitTest {
                     },
                     ComposeRecordingSpec.until({ completed }) {
                         feature(hasTestTag("foo"), ComposeFeatureCaptures.dpSize)
-                    }
+                    },
                 )
 
             assertThat(motion).timeSeriesMatchesGolden()
@@ -146,7 +146,7 @@ class ComposeToolkitTest {
                     },
                     ComposeRecordingSpec.until({ completed }) {
                         feature(hasTestTag("BoxOfInterest"), ComposeFeatureCaptures.alpha)
-                    }
+                    },
                 )
 
             assertThat(motion).timeSeriesMatchesGolden()
@@ -187,7 +187,7 @@ class ComposeToolkitTest {
                     ComposeRecordingSpec.until({ completed }) {
                         feature(hasTestTag("bar"), ComposeFeatureCaptures.alpha, name = "bar_alpha")
                         feature(hasTestTag("foo"), ComposeFeatureCaptures.alpha, name = "foo_alpha")
-                    }
+                    },
                 )
 
             assertThat(motion).timeSeriesMatchesGolden()
@@ -227,7 +227,7 @@ class ComposeToolkitTest {
                         }
                     ) {
                         feature(hasTestTag("foo"), ComposeFeatureCaptures.dpSize)
-                    }
+                    },
                 )
             motionRule.assertThat(motion).timeSeriesMatchesGolden()
         }
@@ -241,7 +241,7 @@ class ComposeToolkitTest {
                 Modifier.pointerInput(Unit) {
                         detectDragGestures(
                             onDragStart = { pointerPosition = it },
-                            onDragEnd = { pointerPosition = Offset.Unspecified }
+                            onDragEnd = { pointerPosition = Offset.Unspecified },
                         ) { _, dragAmount ->
                             pointerPosition =
                                 if (pointerPosition.isSpecified) pointerPosition + dragAmount
@@ -284,7 +284,7 @@ class ComposeToolkitTest {
                         }
                     ) {
                         feature(pointerOffsetKey, offset)
-                    }
+                    },
                 )
 
             // The golden is expected to be missing the first 100ms, while the `swipeDown` executes.
@@ -307,7 +307,7 @@ class ComposeToolkitTest {
                         }
                     ) {
                         feature(pointerOffsetKey, offset)
-                    }
+                    },
                 )
 
             motionRule.assertThat(motion).timeSeriesMatchesGolden()
@@ -339,7 +339,7 @@ class ComposeToolkitTest {
                         }
                     ) {
                         feature(pointerOffsetKey, offset)
-                    }
+                    },
                 )
 
             motionRule.assertThat(motion).timeSeriesMatchesGolden()
@@ -390,7 +390,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = true,
                     recordAfter = false,
-                    MotionControl { awaitFrames(5) }
+                    MotionControl { awaitFrames(5) },
                 )
                 // Minimum delays, play flag flipped after 2
                 .containsExactly(/* before */ 2, 103, 104, 105, 106, 107)
@@ -403,7 +403,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = false,
                     recordAfter = false,
-                    MotionControl { awaitFrames(5) }
+                    MotionControl { awaitFrames(5) },
                 )
                 // Same as above, just not recording before. Must not make a difference
                 .containsExactly(103, 104, 105, 106, 107)
@@ -416,7 +416,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = true,
                     recordAfter = true,
-                    MotionControl { awaitFrames(1) }
+                    MotionControl { awaitFrames(1) },
                 )
                 // after represents the state when the composable is idle, no matter how long the
                 // recording took
@@ -430,7 +430,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = true,
                     recordAfter = false,
-                    MotionControl(delayRecording = { awaitFrames(2) }) { awaitFrames(5) }
+                    MotionControl(delayRecording = { awaitFrames(2) }) { awaitFrames(5) },
                 )
                 // Start recording is delayed, readyToPlay is still after frame 2 (before is
                 // captured
@@ -445,7 +445,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = true,
                     recordAfter = false,
-                    MotionControl(delayReadyToPlay = { awaitFrames(2) }) { awaitFrames(5) }
+                    MotionControl(delayReadyToPlay = { awaitFrames(2) }) { awaitFrames(5) },
                 )
                 // delaying readyToPlay pushes back the before recording
                 .containsExactly(/* before */ 4, 105, 106, 107, 108, 109)
@@ -460,10 +460,10 @@ class ComposeToolkitTest {
                     recordAfter = false,
                     MotionControl(
                         delayReadyToPlay = { awaitFrames(2) },
-                        delayRecording = { awaitFrames(3) }
+                        delayRecording = { awaitFrames(3) },
                     ) {
                         awaitFrames(5)
-                    }
+                    },
                 )
                 .containsExactly(/* before */ 4, 108, 109, 110, 111, 112)
                 .inOrder()
@@ -475,7 +475,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = false,
                     recordAfter = false,
-                    MotionControl { awaitDelay(10.milliseconds) }
+                    MotionControl { awaitDelay(10.milliseconds) },
                 )
                 .hasSize(1)
         }
@@ -486,7 +486,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = false,
                     recordAfter = false,
-                    MotionControl { awaitDelay(16.milliseconds) }
+                    MotionControl { awaitDelay(16.milliseconds) },
                 )
                 .hasSize(1)
         }
@@ -497,7 +497,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = false,
                     recordAfter = false,
-                    MotionControl { awaitDelay(17.milliseconds) }
+                    MotionControl { awaitDelay(17.milliseconds) },
                 )
                 .hasSize(2)
         }
@@ -512,7 +512,7 @@ class ComposeToolkitTest {
                         // 20ms
                         awaitDelay(10.milliseconds)
                         awaitDelay(10.milliseconds)
-                    }
+                    },
                 )
                 .hasSize(2)
         }
@@ -523,7 +523,7 @@ class ComposeToolkitTest {
             assertThatFrameCountValues(
                     recordBefore = false,
                     recordAfter = false,
-                    MotionControl { awaitDelay(10.milliseconds) }
+                    MotionControl { awaitDelay(10.milliseconds) },
                 )
                 .hasSize(1)
         }
@@ -542,7 +542,7 @@ class ComposeToolkitTest {
                             checkConditionInvocationFrames.add(currentFrameCount)
                             currentFrameCount == 105
                         }
-                    }
+                    },
                 )
                 // Must not record the frame where the condition returned true
                 .containsExactly(/* before */ 2, 103, 104)
@@ -573,13 +573,13 @@ class ComposeToolkitTest {
                                 motionTestValueOfNode(frameCountKey)
                                     .also(awaitStartRecordingInvocationFrames::add) == 107
                             }
-                        }
+                        },
                     ) {
                         awaitCondition {
                             motionTestValueOfNode(frameCountKey)
                                 .also(awaitAnimationEndInvocationFrames::add) == 110
                         }
-                    }
+                    },
                 )
                 .containsExactly(/* before */ 6, 108, 109)
                 .inOrder()
@@ -622,12 +622,12 @@ class ComposeToolkitTest {
                     Text(
                         text = "$exportedFrameCount",
                         modifier =
-                            Modifier.motionTestValues { exportedFrameCount exportAs frameCountKey }
+                            Modifier.motionTestValues { exportedFrameCount exportAs frameCountKey },
                     )
                 },
                 ComposeRecordingSpec(motionControl, recordBefore, recordAfter) {
                     feature(frameCountKey, DataPointTypes.int)
-                }
+                },
             )
 
         val frameCountValues =
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/DataPointTypesTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/DataPointTypesTest.kt
index d9c10263e..d69647d30 100644
--- a/libraries/motion/compose/tests/src/platform/test/motion/compose/DataPointTypesTest.kt
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/DataPointTypesTest.kt
@@ -19,6 +19,7 @@ package platform.test.motion.compose
 import androidx.compose.ui.geometry.Offset
 import androidx.compose.ui.unit.DpOffset
 import androidx.compose.ui.unit.DpSize
+import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.IntSize
 import androidx.compose.ui.unit.dp
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -29,6 +30,7 @@ import org.junit.runner.RunWith
 import platform.test.motion.compose.DataPointTypes.dp
 import platform.test.motion.compose.DataPointTypes.dpOffset
 import platform.test.motion.compose.DataPointTypes.dpSize
+import platform.test.motion.compose.DataPointTypes.intOffset
 import platform.test.motion.compose.DataPointTypes.intSize
 import platform.test.motion.compose.DataPointTypes.offset
 import platform.test.motion.testing.DataPointTypeSubject.Companion.assertThat
@@ -50,6 +52,14 @@ class DataPointTypesTest {
 
         assertThat(intSize).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
     }
+
+    @Test
+    fun intOffset_jsonConversion() {
+        assertThat(intOffset).convertsJsonObject(IntOffset(x = 1, y = 2), """{"x":1, "y": 2}""")
+
+        assertThat(intOffset).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
+    }
+
     @Test
     fun dpSize_jsonConversion() {
         assertThat(dpSize)
@@ -57,6 +67,7 @@ class DataPointTypesTest {
 
         assertThat(intSize).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
     }
+
     @Test
     fun dpOffset_jsonConversion() {
         assertThat(dpOffset).convertsJsonObject(DpOffset(x = 1.dp, y = 2.dp), """{"x":1, "y": 2}""")
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/MotionTestValuesTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/MotionTestValuesTest.kt
index 589d652ea..8be2d1c25 100644
--- a/libraries/motion/compose/tests/src/platform/test/motion/compose/MotionTestValuesTest.kt
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/MotionTestValuesTest.kt
@@ -98,7 +98,7 @@ class MotionTestValuesTest {
             val motion =
                 recordMotion(
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
-                    singleFrame { feature(foo, DataPointTypes.float) }
+                    singleFrame { feature(foo, DataPointTypes.float) },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo", .5f.asDataPoint())
@@ -116,7 +116,7 @@ class MotionTestValuesTest {
                             }
                         )
                     },
-                    singleFrame { feature(foo, DataPointTypes.float, matcher = hasTestTag("foo")) }
+                    singleFrame { feature(foo, DataPointTypes.float, matcher = hasTestTag("foo")) },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo", .5f.asDataPoint())
@@ -130,7 +130,7 @@ class MotionTestValuesTest {
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
                     singleFrame {
                         feature(foo, DataPointTypes.float, matcher = hasTestTag("unknown"))
-                    }
+                    },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo", DataPoint.notFound())
@@ -142,7 +142,7 @@ class MotionTestValuesTest {
             val motion =
                 recordMotion(
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
-                    singleFrame { feature(foo, DataPointTypes.float, name = "bar") }
+                    singleFrame { feature(foo, DataPointTypes.float, name = "bar") },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("bar", .5f.asDataPoint())
@@ -154,7 +154,7 @@ class MotionTestValuesTest {
             val motion =
                 recordMotion(
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
-                    singleFrame { feature(foo, times3) }
+                    singleFrame { feature(foo, times3) },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo_times3", 1.5f.asDataPoint())
@@ -172,7 +172,7 @@ class MotionTestValuesTest {
                             }
                         )
                     },
-                    singleFrame { feature(foo, times3, matcher = hasTestTag("foo")) }
+                    singleFrame { feature(foo, times3, matcher = hasTestTag("foo")) },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo_times3", 1.5f.asDataPoint())
@@ -184,7 +184,7 @@ class MotionTestValuesTest {
             val motion =
                 recordMotion(
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
-                    singleFrame { feature(foo, times3, matcher = hasTestTag("unknown")) }
+                    singleFrame { feature(foo, times3, matcher = hasTestTag("unknown")) },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("foo_times3", DataPoint.notFound())
@@ -196,7 +196,7 @@ class MotionTestValuesTest {
             val motion =
                 recordMotion(
                     content = { Box(Modifier.size(10.dp).motionTestValues { .5f exportAs foo }) },
-                    singleFrame { feature(foo, times3, name = "bar") }
+                    singleFrame { feature(foo, times3, name = "bar") },
                 )
 
             motion.timeSeries.assertSingleFeatureMatches("bar", 1.5f.asDataPoint())
@@ -208,7 +208,7 @@ class MotionTestValuesTest {
      */
     private fun TimeSeries.assertSingleFeatureMatches(
         featureName: String,
-        vararg expectedDataPoints: DataPoint<Float>
+        vararg expectedDataPoints: DataPoint<Float>,
     ) {
         assertThat(features.keys).containsExactly(featureName)
         val feature = checkNotNull(features[featureName])
@@ -216,13 +216,13 @@ class MotionTestValuesTest {
     }
 
     private fun singleFrame(
-        timeSeriesCapture: TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.() -> Unit,
+        timeSeriesCapture: TimeSeriesCaptureScope<SemanticsNodeInteractionsProvider>.() -> Unit
     ): ComposeRecordingSpec {
         return ComposeRecordingSpec(
             recording = { awaitFrames(1) },
             recordBefore = false,
             recordAfter = false,
-            timeSeriesCapture
+            timeSeriesCapture,
         )
     }
 
diff --git a/libraries/motion/compose/tests/src/platform/test/motion/compose/TransitionFeatureCaptureTest.kt b/libraries/motion/compose/tests/src/platform/test/motion/compose/TransitionFeatureCaptureTest.kt
new file mode 100644
index 000000000..dfd7f458e
--- /dev/null
+++ b/libraries/motion/compose/tests/src/platform/test/motion/compose/TransitionFeatureCaptureTest.kt
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.motion.compose
+
+import androidx.compose.animation.AnimatedContent
+import androidx.compose.animation.AnimatedContentTransitionScope.SlideDirection.Companion.Up
+import androidx.compose.animation.core.Transition
+import androidx.compose.animation.core.tween
+import androidx.compose.animation.core.updateTransition
+import androidx.compose.animation.fadeIn
+import androidx.compose.animation.fadeOut
+import androidx.compose.animation.togetherWith
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.size
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.unit.dp
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import org.json.JSONArray
+import org.json.JSONObject
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import platform.test.motion.compose.DataPointTypes.intSize
+import platform.test.motion.compose.TransitionFeatureCapture.animatedVisibilityValues
+import platform.test.motion.compose.values.MotionTestValueKey
+import platform.test.motion.compose.values.motionTestValues
+import platform.test.motion.golden.DataPoint
+import platform.test.motion.testing.DataPointTypeSubject.Companion.assertThat
+import platform.test.motion.testing.createGoldenPathManager
+
+@RunWith(AndroidJUnit4::class)
+class TransitionFeatureCaptureTest {
+
+    private val pathManager =
+        createGoldenPathManager("platform_testing/libraries/motion/compose/tests/goldens")
+    @get:Rule val motionRule = createComposeMotionTestRule(pathManager)
+
+    @Test
+    fun recordMotion_AnimatedContent_capturesDefaultTransition() =
+        transitionGoldenTest(
+            content = { transition ->
+                transition.AnimatedContent(modifier = Modifier.subject(transition)) { targetState ->
+                    Text(text = targetState)
+                }
+            },
+            ComposeRecordingSpec.duringTransition(transitionKey) {
+                animatedVisibilityFeatures(transitionKey)
+            },
+        )
+
+    @Test
+    fun recordMotion_AnimatedContent_capturesFade() =
+        transitionGoldenTest(
+            content = { transition ->
+                transition.AnimatedContent(
+                    modifier = Modifier.subject(transition),
+                    transitionSpec = { fadeIn() togetherWith fadeOut() },
+                ) { targetState ->
+                    Text(text = targetState)
+                }
+            },
+            ComposeRecordingSpec.duringTransition(transitionKey) {
+                animatedVisibilityFeatures(transitionKey)
+            },
+        )
+
+    @Test
+    fun recordMotion_AnimatedContent_capturesSlide() =
+        transitionGoldenTest(
+            content = { transition ->
+                transition.AnimatedContent(
+                    modifier = Modifier.subject(transition),
+                    transitionSpec = { slideIntoContainer(Up) togetherWith slideOutOfContainer(Up) },
+                ) { targetState ->
+                    Text(text = targetState)
+                }
+            },
+            ComposeRecordingSpec.duringTransition(transitionKey) {
+                animatedVisibilityFeatures(transitionKey)
+            },
+        )
+
+    @Test
+    fun recordMotion_twoAnimatedContents_allowsNamingTransitions() =
+        transitionGoldenTest(
+            content = { transition ->
+                Column(modifier = Modifier.motionTestValues { transition exportAs transitionKey }) {
+                    transition.AnimatedContent(
+                        modifier = Modifier.size(50.dp),
+                        transitionSpec = {
+                            fadeIn(tween(durationMillis = 200, delayMillis = 200)) togetherWith
+                                fadeOut(tween(durationMillis = 100))
+                        },
+                    ) { targetState ->
+                        Text(text = targetState)
+                    }
+
+                    transition.AnimatedContent(
+                        modifier = Modifier.size(50.dp),
+                        transitionSpec = {
+                            fadeIn(tween(durationMillis = 200, delayMillis = 300)) togetherWith
+                                fadeOut(tween(durationMillis = 100))
+                        },
+                    ) { targetState ->
+                        Text(text = targetState)
+                    }
+                }
+            },
+            ComposeRecordingSpec.duringTransition(transitionKey) {
+                animatedVisibilityFeatures(transitionKey) {
+                    when (it) {
+                        0 -> "one"
+                        1 -> "two"
+                        else -> throw IllegalArgumentException()
+                    }
+                }
+            },
+        )
+
+    @Test
+    fun animatedVisibilityValues_jsonConversion_notFoundDoesNotWriteJson() {
+        assertThat(animatedVisibilityValues)
+            .convertsJsonObject(
+                AnimatedVisibilityValues(
+                    DataPoint.notFound(),
+                    DataPoint.notFound(),
+                    DataPoint.notFound(),
+                    DataPoint.notFound(),
+                ),
+                """{}""",
+            )
+
+        assertThat(intSize).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
+    }
+
+    @Test
+    fun animatedVisibilityValues_jsonConversion_nullDataPointWritesNull() {
+        assertThat(animatedVisibilityValues)
+            .convertsJsonObject(
+                AnimatedVisibilityValues(
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                ),
+                """{"alpha":null,"slide":null,"scale":null,"size":null}""",
+            )
+
+        assertThat(intSize).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
+    }
+
+    @Test
+    fun animatedVisibilityValues_jsonConversion_actial() {
+        assertThat(animatedVisibilityValues)
+            .convertsJsonObject(
+                AnimatedVisibilityValues(
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                    DataPoint.nullValue(),
+                ),
+                """{"alpha":null,"slide":null,"scale":null,"size":null}""",
+            )
+
+        assertThat(intSize).invalidJsonReturnsUnknownDataPoint(JSONObject(), 1)
+    }
+
+    @Test
+    fun animatedVisibilityValues_invalid_returnsUnknown() {
+        assertThat(animatedVisibilityValues).invalidJsonReturnsUnknownDataPoint(JSONArray(), 1)
+    }
+
+    private fun Modifier.subject(transition: Transition<String>) =
+        this then Modifier.size(50.dp).motionTestValues { transition exportAs transitionKey }
+
+    private fun transitionGoldenTest(
+        content: @Composable (transition: Transition<String>) -> Unit,
+        recordingSpec: ComposeRecordingSpec,
+    ) {
+
+        motionRule.runTest {
+            val motion =
+                recordMotion(
+                    content = { play ->
+                        val transition =
+                            updateTransition(
+                                targetState = if (play) "B" else "A",
+                                label = "subject",
+                            )
+                        content(transition)
+                    },
+                    recordingSpec = recordingSpec,
+                )
+
+            assertThat(motion).timeSeriesMatchesGolden()
+        }
+    }
+
+    companion object {
+        val transitionKey = MotionTestValueKey<Transition<String>>("test_transition")
+    }
+}
diff --git a/libraries/motion/compose/values/Android.bp b/libraries/motion/compose/values/Android.bp
index a42f09d05..73daefa63 100644
--- a/libraries/motion/compose/values/Android.bp
+++ b/libraries/motion/compose/values/Android.bp
@@ -27,5 +27,7 @@ android_library {
     static_libs: [
         "androidx.compose.runtime_runtime",
         "androidx.compose.ui_ui",
+        "androidx.compose.animation_animation-core",
+        "androidx.compose.animation_animation-graphics",
     ],
 }
diff --git a/libraries/motion/compose/values/src/platform/test/motion/compose/values/LocalEnableMotionTesting.kt b/libraries/motion/compose/values/src/platform/test/motion/compose/values/LocalEnableMotionTesting.kt
index 6b23c9e4a..3cbd79d8a 100644
--- a/libraries/motion/compose/values/src/platform/test/motion/compose/values/LocalEnableMotionTesting.kt
+++ b/libraries/motion/compose/values/src/platform/test/motion/compose/values/LocalEnableMotionTesting.kt
@@ -25,9 +25,5 @@ internal val LocalEnableMotionTestValueCollection = staticCompositionLocalOf { f
 /** Enables capturing of test data provided to [motionTestValues]. */
 @Composable
 fun EnableMotionTestValueCollection(content: @Composable () -> Unit) {
-    CompositionLocalProvider(
-        LocalEnableMotionTestValueCollection provides true,
-    ) {
-        content()
-    }
+    CompositionLocalProvider(LocalEnableMotionTestValueCollection provides true) { content() }
 }
diff --git a/libraries/motion/src/platform/test/motion/MotionTestRule.kt b/libraries/motion/src/platform/test/motion/MotionTestRule.kt
index 3ba63e37e..9e3c25d3a 100644
--- a/libraries/motion/src/platform/test/motion/MotionTestRule.kt
+++ b/libraries/motion/src/platform/test/motion/MotionTestRule.kt
@@ -57,7 +57,7 @@ class MotionTestRule<Toolkit>(
     val toolkit: Toolkit,
     private val goldenPathManager: GoldenPathManager,
     internal val bitmapDiffer: BitmapDiffer? = null,
-    extraRules: RuleChain = RuleChain.emptyRuleChain()
+    extraRules: RuleChain = RuleChain.emptyRuleChain(),
 ) : TestRule {
 
     @Volatile internal var testClassName: String? = null
@@ -106,7 +106,7 @@ class MotionTestRule<Toolkit>(
      */
     internal fun readGoldenTimeSeries(
         goldenIdentifier: String,
-        typeRegistry: Map<String, DataPointType<*>>
+        typeRegistry: Map<String, DataPointType<*>>,
     ): TimeSeries {
         val path = goldenPathManager.goldenIdentifierResolver(goldenIdentifier, JSON_EXTENSION)
         try {
@@ -142,7 +142,7 @@ class MotionTestRule<Toolkit>(
         metadata.put(
             "goldenRepoPath",
             "${goldenPathManager.assetsPathRelativeToBuildRoot}/${relativeGoldenPath.replace(
-                JSON_ACTUAL_EXTENSION, JSON_EXTENSION)}"
+                JSON_ACTUAL_EXTENSION, JSON_EXTENSION,)}",
         )
         metadata.put("goldenIdentifier", goldenIdentifier)
         metadata.put("testClassName", recordedMotion.testClassName)
@@ -198,7 +198,7 @@ class MotionTestRule<Toolkit>(
 internal enum class TimeSeriesVerificationResult {
     PASSED,
     FAILED,
-    MISSING_REFERENCE
+    MISSING_REFERENCE,
 }
 
 class GoldenNotFoundException(val missingGoldenFile: String) : Exception()
diff --git a/libraries/motion/src/platform/test/motion/filmstrip/Filmstrip.kt b/libraries/motion/src/platform/test/motion/filmstrip/Filmstrip.kt
index fbab254c9..386f1d9a3 100644
--- a/libraries/motion/src/platform/test/motion/filmstrip/Filmstrip.kt
+++ b/libraries/motion/src/platform/test/motion/filmstrip/Filmstrip.kt
@@ -91,7 +91,7 @@ enum class FilmstripOrientation {
     /** Horizontal for screenshots taller than wide, and vice versa */
     AUTOMATIC,
     HORIZONTAL,
-    VERTICAL
+    VERTICAL,
 }
 
 /** An animation screenshot annotated with the frame its originating from. */
@@ -101,7 +101,7 @@ private sealed class FilmstripRenderer(
     val screenshots: List<MotionScreenshot>,
     val screenshotWidth: Int,
     val screenshotHeight: Int,
-    val scale: Float
+    val scale: Float,
 ) {
     val bitmapConfig = checkNotNull(screenshots.first().bitmap.config)
 
@@ -131,7 +131,7 @@ private class HorizontalFilmstripRenderer(
     screenshots: List<MotionScreenshot>,
     screenshotWidth: Int,
     screenshotHeight: Int,
-    scale: Float
+    scale: Float,
 ) : FilmstripRenderer(screenshots, screenshotWidth, screenshotHeight, scale) {
 
     init {
@@ -168,7 +168,7 @@ private class HorizontalFilmstripRenderer(
             canvas.drawBitmap(
                 /* bitmap = */ screenshot.bitmap,
                 /* matrix = */ transform,
-                /* paint = */ backgroundPaint
+                /* paint = */ backgroundPaint,
             )
 
             canvas.drawText(
@@ -188,7 +188,7 @@ private class VerticalFilmstripRenderer(
     screenshots: List<MotionScreenshot>,
     screenshotWidth: Int,
     screenshotHeight: Int,
-    scale: Float
+    scale: Float,
 ) : FilmstripRenderer(screenshots, screenshotWidth, screenshotHeight, scale) {
     override fun render(): Bitmap {
         val tileHeight = max(screenshotHeight, labelHeight + 2 * labelMargin)
@@ -218,7 +218,7 @@ private class VerticalFilmstripRenderer(
             canvas.drawBitmap(
                 /* bitmap = */ screenshot.bitmap,
                 /* matrix = */ transform,
-                /* paint = */ backgroundPaint
+                /* paint = */ backgroundPaint,
             )
 
             val textBounds = Rect()
diff --git a/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt b/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt
index a74202d4f..1308f2e5f 100644
--- a/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt
+++ b/libraries/motion/src/platform/test/motion/filmstrip/VideoRenderer.kt
@@ -63,11 +63,7 @@ class VideoRenderer(private val screenshots: List<MotionScreenshot>) {
         muxer.release()
     }
 
-    private fun encodeScreenshotsInVideo(
-        encoder: MediaCodec,
-        muxer: MediaMuxer,
-        surface: Surface,
-    ) {
+    private fun encodeScreenshotsInVideo(encoder: MediaCodec, muxer: MediaMuxer, surface: Surface) {
         val bufferInfo = MediaCodec.BufferInfo()
         val screenshotIterator = screenshots.iterator()
         var isEndOfStream = false
diff --git a/libraries/motion/src/platform/test/motion/golden/DataPoint.kt b/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
index cc85f89f4..2600b96ce 100644
--- a/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
+++ b/libraries/motion/src/platform/test/motion/golden/DataPoint.kt
@@ -41,14 +41,18 @@ sealed interface DataPoint<out T> {
         }
 
         fun <T> notFound(): DataPoint<T> {
-            @Suppress("UNCHECKED_CAST") return NotFoundDataPoint.instance as NotFoundDataPoint<T>
+            @Suppress("UNCHECKED_CAST")
+            return NotFoundDataPoint.instance as NotFoundDataPoint<T>
         }
+
         fun <T> nullValue(): DataPoint<T> {
-            @Suppress("UNCHECKED_CAST") return NullDataPoint.instance as NullDataPoint<T>
+            @Suppress("UNCHECKED_CAST")
+            return NullDataPoint.instance as NullDataPoint<T>
         }
 
         fun <T> unknownType(): DataPoint<T> {
-            @Suppress("UNCHECKED_CAST") return UnknownType.instance as UnknownType<T>
+            @Suppress("UNCHECKED_CAST")
+            return UnknownType.instance as UnknownType<T>
         }
     }
 }
diff --git a/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt b/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
index 97ae22d13..f4961c664 100644
--- a/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
+++ b/libraries/motion/src/platform/test/motion/golden/DataPointTypes.kt
@@ -40,7 +40,7 @@ object DataPointTypes {
                     else -> throw UnknownTypeException()
                 }
             },
-            valueToJson = { it }
+            valueToJson = { it },
         )
 
     val float: DataPointType<Float> =
@@ -54,7 +54,7 @@ object DataPointTypes {
                     else -> throw UnknownTypeException()
                 }
             },
-            valueToJson = { it }
+            valueToJson = { it },
         )
 
     val int: DataPointType<Int> =
@@ -68,7 +68,7 @@ object DataPointTypes {
                     else -> throw UnknownTypeException()
                 }
             },
-            valueToJson = { it }
+            valueToJson = { it },
         )
 
     val string: DataPointType<String> =
@@ -95,7 +95,7 @@ object DataPointTypes {
             },
             valueToJson = {
                 JSONArray().apply { it.forEach { value -> put(dataPointType.toJson(value)) } }
-            }
+            },
         )
     }
 }
diff --git a/libraries/motion/src/platform/test/motion/golden/JsonGoldenSerializer.kt b/libraries/motion/src/platform/test/motion/golden/JsonGoldenSerializer.kt
index 7f87822f5..b76d6c270 100644
--- a/libraries/motion/src/platform/test/motion/golden/JsonGoldenSerializer.kt
+++ b/libraries/motion/src/platform/test/motion/golden/JsonGoldenSerializer.kt
@@ -56,11 +56,11 @@ object JsonGoldenSerializer {
         JSONObject().apply {
             put(
                 KEY_FRAME_IDS,
-                JSONArray().apply { golden.frameIds.map(::frameIdToJson).forEach(this::put) }
+                JSONArray().apply { golden.frameIds.map(::frameIdToJson).forEach(this::put) },
             )
             put(
                 KEY_FEATURES,
-                JSONArray().apply { golden.features.values.map(::featureToJson).forEach(this::put) }
+                JSONArray().apply { golden.features.values.map(::featureToJson).forEach(this::put) },
             )
         }
 
@@ -80,7 +80,7 @@ object JsonGoldenSerializer {
 
     private fun featureFromJson(
         jsonObject: JSONObject,
-        typeRegistry: Map<String, DataPointType<*>>
+        typeRegistry: Map<String, DataPointType<*>>,
     ): Feature<*> {
         val name = jsonObject.getString(KEY_FEATURE_NAME)
         val type = typeRegistry[jsonObject.optString(KEY_FEATURE_TYPE)] ?: unknownType
@@ -110,9 +110,10 @@ object JsonGoldenSerializer {
 
             put(
                 KEY_FEATURE_DATAPOINTS,
-                JSONArray().apply { feature.dataPoints.map { it.asJson() }.forEach(this::put) }
+                JSONArray().apply { feature.dataPoints.map { it.asJson() }.forEach(this::put) },
             )
         }
+
     private const val KEY_FRAME_IDS = "frame_ids"
     private const val KEY_FEATURES = "features"
     private const val KEY_FEATURE_NAME = "name"
@@ -123,7 +124,7 @@ object JsonGoldenSerializer {
         DataPointType(
             "unknown",
             jsonToValue = { throw UnknownTypeException() },
-            valueToJson = { throw AssertionError() }
+            valueToJson = { throw AssertionError() },
         )
 }
 
@@ -146,7 +147,7 @@ fun TimeSeries.createTypeRegistry(): Map<String, DataPointType<*>> = buildMap {
 
 private fun <I, O> JSONArray.convert(
     elementAccessor: JSONArray.(index: Int) -> I,
-    convertFn: (I) -> O
+    convertFn: (I) -> O,
 ) = buildList {
     for (i in 0 until length()) {
         add(convertFn(elementAccessor(i)))
diff --git a/libraries/motion/src/platform/test/motion/golden/TimeSeries.kt b/libraries/motion/src/platform/test/motion/golden/TimeSeries.kt
index cfa232fdc..473d07349 100644
--- a/libraries/motion/src/platform/test/motion/golden/TimeSeries.kt
+++ b/libraries/motion/src/platform/test/motion/golden/TimeSeries.kt
@@ -26,7 +26,7 @@ data class TimeSeries(val frameIds: List<FrameId>, val features: Map<String, Fea
 
     constructor(
         frameIds: List<FrameId>,
-        features: List<Feature<*>>
+        features: List<Feature<*>>,
     ) : this(frameIds, features.associateBy { it.name }) {
         require(features.size == this.features.size) { "duplicate feature names" }
     }
@@ -68,5 +68,5 @@ data class Feature<out T>(
     /** Test-specific, human readable name identifying the feature. */
     val name: String,
     /** Recorded data points of the feature. */
-    val dataPoints: List<DataPoint<T>>
+    val dataPoints: List<DataPoint<T>>,
 )
diff --git a/libraries/motion/src/platform/test/motion/golden/TimeSeriesCapture.kt b/libraries/motion/src/platform/test/motion/golden/TimeSeriesCapture.kt
index 6680e0f6d..95f1b4dda 100644
--- a/libraries/motion/src/platform/test/motion/golden/TimeSeriesCapture.kt
+++ b/libraries/motion/src/platform/test/motion/golden/TimeSeriesCapture.kt
@@ -21,10 +21,7 @@ package platform.test.motion.golden
  *
  * A [DataPoint] of type [V] is recorded at each frame.
  */
-class FeatureCapture<T, V : Any>(
-    val name: String,
-    private val captureFn: (T) -> DataPoint<V>,
-) {
+class FeatureCapture<T, V : Any>(val name: String, private val captureFn: (T) -> DataPoint<V>) {
     fun capture(observed: T) = captureFn(observed)
 }
 
@@ -58,7 +55,7 @@ class TimeSeriesCaptureScope<T>(
      */
     fun <U> on(
         resolveRelated: (T) -> U?,
-        nestedTimeSeriesCapture: TimeSeriesCaptureScope<U>.() -> Unit
+        nestedTimeSeriesCapture: TimeSeriesCaptureScope<U>.() -> Unit,
     ) {
         with(TimeSeriesCaptureScope(observing?.let(resolveRelated), valueCollector)) {
             nestedTimeSeriesCapture()
diff --git a/libraries/motion/src/platform/test/motion/testing/DataPointTypeSubject.kt b/libraries/motion/src/platform/test/motion/testing/DataPointTypeSubject.kt
index ba27ddcff..7eeb4b99d 100644
--- a/libraries/motion/src/platform/test/motion/testing/DataPointTypeSubject.kt
+++ b/libraries/motion/src/platform/test/motion/testing/DataPointTypeSubject.kt
@@ -54,7 +54,7 @@ private constructor(failureMetadata: FailureMetadata, private val actual: DataPo
     private fun convertsJson(
         nativeObject: T,
         jsonRepresentation: String,
-        parseJsonRepresentation: (String) -> Any
+        parseJsonRepresentation: (String) -> Any,
     ) {
         isNotNull()
         val dataPointType = checkNotNull(actual)
@@ -73,8 +73,7 @@ private constructor(failureMetadata: FailureMetadata, private val actual: DataPo
         val dataPointType = checkNotNull(actual)
 
         samples.forEach {
-            Truth.assertThat(dataPointType.fromJson(JSONObject()))
-                .isEqualTo(DataPoint.unknownType<T>())
+            Truth.assertThat(dataPointType.fromJson(it)).isEqualTo(DataPoint.unknownType<T>())
         }
     }
 
diff --git a/libraries/motion/src/platform/test/motion/testing/GoldenPathManagerFactory.kt b/libraries/motion/src/platform/test/motion/testing/GoldenPathManagerFactory.kt
index be1d4d895..a13e14212 100644
--- a/libraries/motion/src/platform/test/motion/testing/GoldenPathManagerFactory.kt
+++ b/libraries/motion/src/platform/test/motion/testing/GoldenPathManagerFactory.kt
@@ -28,7 +28,7 @@ import platform.test.screenshot.PathConfig
  */
 fun createGoldenPathManager(
     sourceTreeGoldenLocation: String,
-    pathConfig: PathConfig = PathConfig()
+    pathConfig: PathConfig = PathConfig(),
 ): GoldenPathManager {
     val appContext = InstrumentationRegistry.getInstrumentation().context
     val deviceOutputDirectory = File(appContext.filesDir, "goldens").toString()
@@ -36,6 +36,6 @@ fun createGoldenPathManager(
         appContext,
         sourceTreeGoldenLocation,
         deviceOutputDirectory,
-        pathConfig
+        pathConfig,
     )
 }
diff --git a/libraries/motion/src/platform/test/motion/truth/RecordedMotionSubject.kt b/libraries/motion/src/platform/test/motion/truth/RecordedMotionSubject.kt
index dbe37cfcd..cd524ca58 100644
--- a/libraries/motion/src/platform/test/motion/truth/RecordedMotionSubject.kt
+++ b/libraries/motion/src/platform/test/motion/truth/RecordedMotionSubject.kt
@@ -92,7 +92,7 @@ internal constructor(
      */
     fun filmstripMatchesGolden(
         goldenName: String? = null,
-        bitmapMatcher: BitmapMatcher = PixelPerfectMatcher()
+        bitmapMatcher: BitmapMatcher = PixelPerfectMatcher(),
     ) {
         isNotNull()
         val recordedMotion = checkNotNull(actual)
diff --git a/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt b/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
index 215764d1f..9df2c1cbb 100644
--- a/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
+++ b/libraries/motion/src/platform/test/motion/truth/TimeSeriesSubject.kt
@@ -34,6 +34,7 @@ private constructor(failureMetadata: FailureMetadata, private val actual: TimeSe
         if (actual is TimeSeries && expected is TimeSeries) {
             val facts = compareTimeSeries(expected, actual)
             if (facts.isNotEmpty()) {
+                facts.add(simpleFact(MANAGE_GOLDEN_DOCUMENTATION))
                 failWithoutActual(facts[0], *(facts.drop(1)).toTypedArray())
             }
         } else {
@@ -42,7 +43,7 @@ private constructor(failureMetadata: FailureMetadata, private val actual: TimeSe
     }
 
     private fun compareTimeSeries(expected: TimeSeries, actual: TimeSeries) =
-        buildList<Fact> {
+        mutableListOf<Fact>().apply {
             val actualToExpectedDataPointIndices: List<Pair<Int, Int>>
             if (actual.frameIds != expected.frameIds) {
                 add(simpleFact("TimeSeries.frames does not match"))
@@ -121,5 +122,8 @@ private constructor(failureMetadata: FailureMetadata, private val actual: TimeSe
         /** Shortcut for `Truth.assertAbout(timeSeries()).that(timeSeries)`. */
         fun assertThat(timeSeries: TimeSeries): TimeSeriesSubject =
             Truth.assertAbout(timeSeries()).that(timeSeries)
+
+        const val MANAGE_GOLDEN_DOCUMENTATION =
+            "Documentation on how to verify the change visually and how to update the golden files can be found at http://go/motion-testing#managing-goldens"
     }
 }
diff --git a/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt b/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
index c5deaed91..0e2f66b69 100644
--- a/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
+++ b/libraries/motion/src/platform/test/motion/view/DataPointTypes.kt
@@ -42,7 +42,7 @@ object DataPointTypes {
                     put("y", it.y)
                 }
             },
-            ensureImmutable = { Point(it) }
+            ensureImmutable = { Point(it) },
         )
 
     val rect: DataPointType<Rect> =
@@ -61,7 +61,7 @@ object DataPointTypes {
                     put("bottom", it.bottom)
                 }
             },
-            ensureImmutable = { Rect(it) }
+            ensureImmutable = { Rect(it) },
         )
 
     /** [GradientDrawable] corner radii */
@@ -83,7 +83,7 @@ object DataPointTypes {
                         put(cornerRadiiPropertyNames[i], it.rawValues[i])
                     }
                 }
-            }
+            },
         )
     // property names match order of val
     private val cornerRadiiPropertyNames =
diff --git a/libraries/motion/src/platform/test/motion/view/DrawableFeatureCaptures.kt b/libraries/motion/src/platform/test/motion/view/DrawableFeatureCaptures.kt
index 2f065b305..b3adb577c 100644
--- a/libraries/motion/src/platform/test/motion/view/DrawableFeatureCaptures.kt
+++ b/libraries/motion/src/platform/test/motion/view/DrawableFeatureCaptures.kt
@@ -31,7 +31,7 @@ object DrawableFeatureCaptures {
         FeatureCapture<GradientDrawable, CornerRadii>("cornerRadii") {
             DataPoint.of(
                 it.cornerRadii?.let { rawValues -> CornerRadii(rawValues) },
-                DataPointTypes.cornerRadii
+                DataPointTypes.cornerRadii,
             )
         }
 }
@@ -44,6 +44,7 @@ object DrawableFeatureCaptures {
  */
 class CornerRadii(rawValues: FloatArray) {
     val rawValues = rawValues.clone()
+
     override fun equals(other: Any?): Boolean {
         if (this === other) return true
 
diff --git a/libraries/motion/src/platform/test/motion/view/ViewFeatureCaptures.kt b/libraries/motion/src/platform/test/motion/view/ViewFeatureCaptures.kt
index c1735aa2c..86bd24cba 100644
--- a/libraries/motion/src/platform/test/motion/view/ViewFeatureCaptures.kt
+++ b/libraries/motion/src/platform/test/motion/view/ViewFeatureCaptures.kt
@@ -25,7 +25,7 @@ import platform.test.motion.golden.asDataPoint
 /** Returns a [TimeSeriesCaptureScope] for the child view with the specified ID. */
 fun <U : View> TimeSeriesCaptureScope<out View>.onViewWithId(
     viewId: Int,
-    nestedTimeSeriesCapture: TimeSeriesCaptureScope<U>.() -> Unit
+    nestedTimeSeriesCapture: TimeSeriesCaptureScope<U>.() -> Unit,
 ) = on({ it.findViewById(viewId) }, nestedTimeSeriesCapture)
 
 /** Common, generic [FeatureCapture] implementations for Views. */
diff --git a/libraries/motion/src/platform/test/motion/view/ViewToolkit.kt b/libraries/motion/src/platform/test/motion/view/ViewToolkit.kt
index ce09ad52a..46ab05584 100644
--- a/libraries/motion/src/platform/test/motion/view/ViewToolkit.kt
+++ b/libraries/motion/src/platform/test/motion/view/ViewToolkit.kt
@@ -20,7 +20,6 @@ import android.animation.Animator
 import android.animation.AnimatorSet
 import android.graphics.Bitmap
 import android.view.View
-import androidx.annotation.OptIn
 import androidx.test.core.app.ActivityScenario
 import com.google.errorprone.annotations.CheckReturnValue
 import java.util.concurrent.TimeUnit
@@ -38,9 +37,7 @@ import platform.test.screenshot.BitmapSupplier
 import platform.test.screenshot.captureToBitmapAsync
 
 /** Toolkit class to use for View-based [MotionTestRule] tests. */
-class ViewToolkit(
-    internal val currentActivityScenario: () -> ActivityScenario<*>,
-)
+class ViewToolkit(internal val currentActivityScenario: () -> ActivityScenario<*>)
 
 /**
  * Defines the sampling of features during a test run.
@@ -75,7 +72,7 @@ data class ViewRecordingSpec<T>(
                 captureRoot = this,
                 sampling = sampling,
                 visualCapture = { screenshotView.captureToBitmapAsync().get(10, TimeUnit.SECONDS) },
-                timeSeriesCapture
+                timeSeriesCapture,
             )
 
         /**
@@ -86,12 +83,12 @@ data class ViewRecordingSpec<T>(
          */
         fun <T : View> T.capture(
             sampling: AnimationSampling,
-            timeSeriesCapture: TimeSeriesCaptureScope<T>.() -> Unit
+            timeSeriesCapture: TimeSeriesCaptureScope<T>.() -> Unit,
         ) =
             capture(
                 screenshotView = this,
                 sampling = sampling,
-                timeSeriesCapture = timeSeriesCapture
+                timeSeriesCapture = timeSeriesCapture,
             )
 
         /**
@@ -102,13 +99,13 @@ data class ViewRecordingSpec<T>(
          */
         fun <T> T.captureWithoutScreenshot(
             sampling: AnimationSampling,
-            timeSeriesCapture: TimeSeriesCaptureScope<T>.() -> Unit
+            timeSeriesCapture: TimeSeriesCaptureScope<T>.() -> Unit,
         ) =
             ViewRecordingSpec(
                 captureRoot = this,
                 sampling = sampling,
                 visualCapture = null,
-                timeSeriesCapture = timeSeriesCapture
+                timeSeriesCapture = timeSeriesCapture,
             )
     }
 }
@@ -117,7 +114,7 @@ data class ViewRecordingSpec<T>(
 @CheckReturnValue
 fun <T> MotionTestRule<ViewToolkit>.record(
     animator: AnimatorSet,
-    recordingSpec: ViewRecordingSpec<T>
+    recordingSpec: ViewRecordingSpec<T>,
 ): RecordedMotion {
     require(!animator.isStarted) { "AnimatorSet must not have been started." }
     return recordSeekableAnimation(animator.makeTestable(), recordingSpec)
@@ -164,7 +161,7 @@ internal fun <T> MotionTestRule<ViewToolkit>.recordSeekableAnimation(
     val timeSeries =
         TimeSeries(
             frameIdCollector.toList(),
-            propertyCollector.entries.map { entry -> Feature(entry.key, entry.value) }
+            propertyCollector.entries.map { entry -> Feature(entry.key, entry.value) },
         )
 
     return create(timeSeries, screenshotCollector)
diff --git a/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt b/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
index 7227a1c86..fa194b700 100644
--- a/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/MotionTestRuleTest.kt
@@ -46,7 +46,7 @@ class MotionTestRuleTest {
             "FooClass",
             "bar_test",
             TimeSeries(listOf(), emptyList()),
-            screenshots = null
+            screenshots = null,
         )
 
     @Test
@@ -76,7 +76,7 @@ class MotionTestRuleTest {
         subject.writeGeneratedTimeSeries(
             "updated_golden",
             emptyRecordedMotion,
-            TimeSeriesVerificationResult.PASSED
+            TimeSeriesVerificationResult.PASSED,
         )
         val expectedFile =
             File(goldenPathManager.deviceLocalPath).resolve("FooClass/updated_golden.actual.json")
@@ -89,7 +89,7 @@ class MotionTestRuleTest {
         subject.writeGeneratedTimeSeries(
             "updated_golden",
             emptyRecordedMotion,
-            TimeSeriesVerificationResult.PASSED
+            TimeSeriesVerificationResult.PASSED,
         )
         val expectedFile =
             File(goldenPathManager.deviceLocalPath).resolve("FooClass/updated_golden.actual.json")
@@ -111,7 +111,7 @@ class MotionTestRuleTest {
         subject.writeGeneratedTimeSeries(
             "updated_golden",
             emptyRecordedMotion,
-            TimeSeriesVerificationResult.MISSING_REFERENCE
+            TimeSeriesVerificationResult.MISSING_REFERENCE,
         )
         val expectedFile =
             File(goldenPathManager.deviceLocalPath).resolve("FooClass/updated_golden.actual.json")
@@ -152,15 +152,15 @@ class MotionTestRuleTest {
                 "bar_test",
                 TimeSeries(
                     listOf(TimestampFrameId(0), TimestampFrameId(16), SupplementalFrameId("after")),
-                    listOf()
+                    listOf(),
                 ),
                 listOf(
                     mockScreenshot(Color.RED, w, h),
                     mockScreenshot(Color.GREEN, w, h),
-                    mockScreenshot(Color.BLUE, w, h)
-                )
+                    mockScreenshot(Color.BLUE, w, h),
+                ),
             ),
-            TimeSeriesVerificationResult.MISSING_REFERENCE
+            TimeSeriesVerificationResult.MISSING_REFERENCE,
         )
 
         val expectedVideo =
@@ -200,7 +200,7 @@ class MotionTestRuleTest {
             subject.writeGeneratedTimeSeries(
                 "invalid identifier!",
                 emptyRecordedMotion,
-                TimeSeriesVerificationResult.PASSED
+                TimeSeriesVerificationResult.PASSED,
             )
         }
     }
@@ -209,6 +209,6 @@ class MotionTestRuleTest {
         color: Int,
         width: Int = 400,
         height: Int = 200,
-        bitmapConfig: Bitmap.Config = Bitmap.Config.ARGB_8888
+        bitmapConfig: Bitmap.Config = Bitmap.Config.ARGB_8888,
     ) = Bitmap.createBitmap(width, height, bitmapConfig).also { Canvas(it).drawColor(color) }
 }
diff --git a/libraries/motion/tests/src/platform/test/motion/filmstrip/FilmstripTest.kt b/libraries/motion/tests/src/platform/test/motion/filmstrip/FilmstripTest.kt
index a4b7a8025..860f32ca9 100644
--- a/libraries/motion/tests/src/platform/test/motion/filmstrip/FilmstripTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/filmstrip/FilmstripTest.kt
@@ -90,11 +90,11 @@ class FilmstripTest {
             listOf(
                 MotionScreenshot(
                     SupplementalFrameId("wide_before"),
-                    mockScreenshot(Color.RED, w, h)
+                    mockScreenshot(Color.RED, w, h),
                 ),
                 MotionScreenshot(
                     SupplementalFrameId("wide_after"),
-                    mockScreenshot(Color.BLUE, w, h)
+                    mockScreenshot(Color.BLUE, w, h),
                 ),
             )
 
@@ -261,6 +261,6 @@ class FilmstripTest {
         color: Int,
         width: Int = 400,
         height: Int = 200,
-        bitmapConfig: Bitmap.Config = Bitmap.Config.ARGB_8888
+        bitmapConfig: Bitmap.Config = Bitmap.Config.ARGB_8888,
     ) = Bitmap.createBitmap(width, height, bitmapConfig).also { Canvas(it).drawColor(color) }
 }
diff --git a/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypeTest.kt b/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypeTest.kt
index 0a2675edd..2f7913f3f 100644
--- a/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypeTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypeTest.kt
@@ -38,7 +38,7 @@ class DataPointTypeTest {
             valueToJson = {
                 valueToJsonInvocations++
                 it.id
-            }
+            },
         )
     private var jsonToValueInvocations = 0
     private var valueToJsonInvocations = 0
diff --git a/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypesTest.kt b/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypesTest.kt
index d2ba78246..e13a16687 100644
--- a/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypesTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/golden/DataPointTypesTest.kt
@@ -126,7 +126,7 @@ class DataPointTypesTest {
         assertThat(DataPointTypes.listOf(something))
             .convertsJsonArray(
                 listOf(Something("foo"), Something("bar")),
-                """[{"string":"foo"}, {"string":"bar"}]"""
+                """[{"string":"foo"}, {"string":"bar"}]""",
             )
     }
 
@@ -157,6 +157,6 @@ class DataPointTypesTest {
                     Something(getString("string"))
                 }
             },
-            valueToJson = { JSONObject().apply { put("string", it.string) } }
+            valueToJson = { JSONObject().apply { put("string", it.string) } },
         )
 }
diff --git a/libraries/motion/tests/src/platform/test/motion/golden/JsonGoldenSerializerTest.kt b/libraries/motion/tests/src/platform/test/motion/golden/JsonGoldenSerializerTest.kt
index 848f24bc4..e975a52fe 100644
--- a/libraries/motion/tests/src/platform/test/motion/golden/JsonGoldenSerializerTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/golden/JsonGoldenSerializerTest.kt
@@ -34,6 +34,7 @@ import platform.test.motion.testing.JsonSubject.Companion.json
 class JsonGoldenSerializerTest {
 
     @get:Rule val expect: Expect = Expect.create()
+
     private fun assertConversions(timeSeries: TimeSeries, json: String) {
         expect
             .withMessage("serialize to JSON")
@@ -56,7 +57,7 @@ class JsonGoldenSerializerTest {
     fun timestampFrameId_asNumber() {
         assertConversions(
             TimeSeries(listOf(TimestampFrameId(33)), listOf()),
-            """{"frame_ids":[33],"features":[]}"""
+            """{"frame_ids":[33],"features":[]}""",
         )
     }
 
@@ -64,7 +65,7 @@ class JsonGoldenSerializerTest {
     fun supplementalFrameId_asString() {
         assertConversions(
             TimeSeries(listOf(SupplementalFrameId("foo")), listOf()),
-            """{"frame_ids":["foo"],"features":[]}"""
+            """{"frame_ids":["foo"],"features":[]}""",
         )
     }
 
@@ -72,7 +73,7 @@ class JsonGoldenSerializerTest {
     fun feature_withoutDataPoint_noType() {
         assertConversions(
             TimeSeries(listOf(), listOf(Feature<Int>("foo", emptyList()))),
-            """{"frame_ids":[],"features":[{"name":"foo","data_points":[]}]}"""
+            """{"frame_ids":[],"features":[{"name":"foo","data_points":[]}]}""",
         )
     }
 
@@ -81,9 +82,9 @@ class JsonGoldenSerializerTest {
         assertConversions(
             TimeSeries(
                 listOf(TimestampFrameId(1)),
-                listOf(Feature("foo", listOf(42.asDataPoint())))
+                listOf(Feature("foo", listOf(42.asDataPoint()))),
             ),
-            """{"frame_ids":[1],"features":[{"name":"foo","type":"int","data_points":[42]}]}"""
+            """{"frame_ids":[1],"features":[{"name":"foo","type":"int","data_points":[42]}]}""",
         )
     }
 
@@ -92,10 +93,10 @@ class JsonGoldenSerializerTest {
         assertConversions(
             TimeSeries(
                 listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                listOf(Feature("foo", listOf(42.asDataPoint(), 43.asDataPoint())))
+                listOf(Feature("foo", listOf(42.asDataPoint(), 43.asDataPoint()))),
             ),
             """{"frame_ids":[1,2],
-                "features":[{"name":"foo","type":"int","data_points":[42,43]}]}}"""
+                "features":[{"name":"foo","type":"int","data_points":[42,43]}]}}""",
         )
     }
 
@@ -104,10 +105,10 @@ class JsonGoldenSerializerTest {
         assertConversions(
             TimeSeries(
                 listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                listOf(Feature("foo", listOf(nullValue(), 43.asDataPoint())))
+                listOf(Feature("foo", listOf(nullValue(), 43.asDataPoint()))),
             ),
             """{"frame_ids":[1,2],
-                "features":[{"name":"foo","type":"int","data_points":[null,43]}]}}"""
+                "features":[{"name":"foo","type":"int","data_points":[null,43]}]}}""",
         )
     }
 
@@ -116,10 +117,10 @@ class JsonGoldenSerializerTest {
         assertConversions(
             TimeSeries(
                 listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                listOf(Feature("foo", listOf(notFound(), 43.asDataPoint())))
+                listOf(Feature("foo", listOf(notFound(), 43.asDataPoint()))),
             ),
             """{"frame_ids":[1,2],
-                "features":[{"name":"foo","type":"int","data_points":[{"type":"not_found"},43]}]}}"""
+                "features":[{"name":"foo","type":"int","data_points":[{"type":"not_found"},43]}]}}""",
         )
     }
 
@@ -128,9 +129,9 @@ class JsonGoldenSerializerTest {
         assertConversions(
             TimeSeries(
                 listOf(TimestampFrameId(1)),
-                listOf(Feature<Int>("foo", listOf(nullValue())))
+                listOf(Feature<Int>("foo", listOf(nullValue()))),
             ),
-            """{"frame_ids":[1],"features":[{"name":"foo","data_points":[null]}]}"""
+            """{"frame_ids":[1],"features":[{"name":"foo","data_points":[null]}]}""",
         )
     }
 
@@ -140,7 +141,7 @@ class JsonGoldenSerializerTest {
             JsonGoldenSerializer.toJson(
                 TimeSeries(
                     listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                    listOf(Feature("foo", listOf(42.asDataPoint(), 42f.asDataPoint())))
+                    listOf(Feature("foo", listOf(42.asDataPoint(), 42f.asDataPoint()))),
                 )
             )
         }
@@ -152,7 +153,7 @@ class JsonGoldenSerializerTest {
             JsonGoldenSerializer.toJson(
                 TimeSeries(
                     listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                    listOf(Feature("foo", listOf(42.asDataPoint(), unknownType())))
+                    listOf(Feature("foo", listOf(42.asDataPoint(), unknownType()))),
                 )
             )
         }
@@ -168,14 +169,14 @@ class JsonGoldenSerializerTest {
                     "features":[{"name":"foo","type":"bar","data_points":[null,43]}]
                 }"""
                 ),
-                emptyMap()
+                emptyMap(),
             )
 
         assertThat(timeSeries)
             .isEqualTo(
                 TimeSeries(
                     listOf(TimestampFrameId(1), TimestampFrameId(2)),
-                    listOf(Feature<Any>("foo", listOf(nullValue(), unknownType())))
+                    listOf(Feature<Any>("foo", listOf(nullValue(), unknownType()))),
                 )
             )
     }
diff --git a/libraries/motion/tests/src/platform/test/motion/truth/RecordedMotionSubjectTest.kt b/libraries/motion/tests/src/platform/test/motion/truth/RecordedMotionSubjectTest.kt
index 986f41b8d..e5dcb36ab 100644
--- a/libraries/motion/tests/src/platform/test/motion/truth/RecordedMotionSubjectTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/truth/RecordedMotionSubjectTest.kt
@@ -52,7 +52,7 @@ class RecordedMotionSubjectTest {
     private val goldenPathManager =
         GoldenPathManager(
             InstrumentationRegistry.getInstrumentation().context,
-            pathConfig = PathConfig()
+            pathConfig = PathConfig(),
         )
     private val bitmapDiffer: BitmapDiffer = mock()
     private val motionRule =
@@ -78,7 +78,7 @@ class RecordedMotionSubjectTest {
             .writeGeneratedTimeSeries(
                 "foo",
                 recordedMotion,
-                TimeSeriesVerificationResult.MISSING_REFERENCE
+                TimeSeriesVerificationResult.MISSING_REFERENCE,
             )
     }
 
@@ -164,7 +164,7 @@ class RecordedMotionSubjectTest {
             testClassName = "MotionTest",
             testMethodName = "foo_test",
             actual,
-            screenshots
+            screenshots,
         )
     }
 }
diff --git a/libraries/motion/tests/src/platform/test/motion/truth/TimeSeriesSubjectTest.kt b/libraries/motion/tests/src/platform/test/motion/truth/TimeSeriesSubjectTest.kt
index 0bc69e216..76bf88ddc 100644
--- a/libraries/motion/tests/src/platform/test/motion/truth/TimeSeriesSubjectTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/truth/TimeSeriesSubjectTest.kt
@@ -139,12 +139,12 @@ class TimeSeriesSubjectTest {
         val expected =
             TimeSeries(
                 createFrames(2),
-                listOf(Feature("foo", listOf(1.asDataPoint(), 2.asDataPoint())))
+                listOf(Feature("foo", listOf(1.asDataPoint(), 2.asDataPoint()))),
             )
         val actual =
             TimeSeries(
                 createFrames(2),
-                listOf(Feature("foo", listOf(1.asDataPoint(), 3.asDataPoint())))
+                listOf(Feature("foo", listOf(1.asDataPoint(), 3.asDataPoint()))),
             )
 
         with(assertThrows { assertThat(actual).isEqualTo(expected) }) {
@@ -153,7 +153,8 @@ class TimeSeriesSubjectTest {
                     "TimeSeries.features[foo].dataPoints do not match",
                     "|  @1ms",
                     "|    expected",
-                    "|    but was"
+                    "|    but was",
+                    TimeSeriesSubject.MANAGE_GOLDEN_DOCUMENTATION,
                 )
                 .inOrder()
 
@@ -162,15 +163,35 @@ class TimeSeriesSubjectTest {
         }
     }
 
+    @Test
+    fun isEqualTo_manageGoldenMessageAddedOnError() {
+        val expected =
+            TimeSeries(
+                createFrames(2),
+                listOf(Feature("foo", listOf(1.asDataPoint(), 2.asDataPoint()))),
+            )
+        val actual =
+            TimeSeries(
+                createFrames(2),
+                listOf(Feature("foo", listOf(1.asDataPoint(), 3.asDataPoint()))),
+            )
+
+        with(assertThrows { assertThat(actual).isEqualTo(expected) }) {
+            factKeys().contains(TimeSeriesSubject.MANAGE_GOLDEN_DOCUMENTATION)
+        }
+    }
+
     private fun createTimeSeries(frameCount: Int) =
         TimeSeries(
             createFrames(frameCount),
-            listOf(createIntFeature("foo", frameCount), createStringFeature("bar", frameCount))
+            listOf(createIntFeature("foo", frameCount), createStringFeature("bar", frameCount)),
         )
 
     private fun createFrames(frameCount: Int) = List(frameCount) { TimestampFrameId(it.toLong()) }
+
     private fun createIntFeature(name: String, dataPoints: Int) =
         Feature(name, List(dataPoints) { it.asDataPoint() })
+
     private fun createStringFeature(name: String, dataPoints: Int) =
         Feature(name, List(dataPoints) { it.toString().asDataPoint() })
 
@@ -185,11 +206,12 @@ class TimeSeriesSubjectTest {
         }
         throw AssertionError("Body completed successfully. Expected AssertionError")
     }
+
     companion object {
         val startsWith: Correspondence<String, String> =
             Correspondence.from(
                 { actual, expected -> checkNotNull(actual).startsWith(checkNotNull(expected)) },
-                "starts with"
+                "starts with",
             )
     }
 }
diff --git a/libraries/motion/tests/src/platform/test/motion/view/DataPointTypesTest.kt b/libraries/motion/tests/src/platform/test/motion/view/DataPointTypesTest.kt
index 6de191283..e7e68bcfb 100644
--- a/libraries/motion/tests/src/platform/test/motion/view/DataPointTypesTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/view/DataPointTypesTest.kt
@@ -35,12 +35,12 @@ class DataPointTypesTest {
 
     @Test
     fun point_fromToJson() {
-        assertThat(point).convertsJsonObject(Point(/* x = */ 1, /* y = */ 2), """{"x":1, "y": 2}""")
+        assertThat(point).convertsJsonObject(Point(/* x= */ 1, /* y= */ 2), """{"x":1, "y": 2}""")
     }
 
     @Test
     fun point_dataPoint_isImmutable() {
-        val native = Point(/* x = */ 1, /* y = */ 2)
+        val native = Point(/* x= */ 1, /* y= */ 2)
         val dataPoint = DataPoint.of(native, point)
         native.x = 3
         assertThat((dataPoint as ValueDataPoint).value.x).isEqualTo(1)
@@ -55,8 +55,8 @@ class DataPointTypesTest {
     fun rect_fromToJson() {
         assertThat(rect)
             .convertsJsonObject(
-                Rect(/* left = */ 1, /* top = */ 2, /* right = */ 3, /* bottom = */ 4),
-                """{"left":1, "top": 2,"right":3, "bottom": 4}"""
+                Rect(/* left= */ 1, /* top= */ 2, /* right= */ 3, /* bottom= */ 4),
+                """{"left":1, "top": 2,"right":3, "bottom": 4}""",
             )
     }
 
@@ -67,7 +67,7 @@ class DataPointTypesTest {
 
     @Test
     fun rect_dataPoint_isImmutable() {
-        val native = Rect(/* left = */ 1, /* top = */ 2, /* right = */ 3, /* bottom = */ 4)
+        val native = Rect(/* left= */ 1, /* top= */ 2, /* right= */ 3, /* bottom= */ 4)
         val dataPoint = DataPoint.of(native, rect)
         native.top = 5
         assertThat((dataPoint as ValueDataPoint).value.left).isEqualTo(1)
@@ -87,7 +87,7 @@ class DataPointTypesTest {
                 "bottom_right_y": 6,
                 "bottom_left_x": 7,
                 "bottom_left_y": 8
-                }"""
+                }""",
             )
     }
 
diff --git a/libraries/motion/tests/src/platform/test/motion/view/ViewToolkitTest.kt b/libraries/motion/tests/src/platform/test/motion/view/ViewToolkitTest.kt
index 88052838b..5f875b517 100644
--- a/libraries/motion/tests/src/platform/test/motion/view/ViewToolkitTest.kt
+++ b/libraries/motion/tests/src/platform/test/motion/view/ViewToolkitTest.kt
@@ -66,7 +66,7 @@ class ViewToolkitTest {
                 animator,
                 sceneRoot.capture(evenlySampled(10)) {
                     onViewWithId(R.id.test_box) { feature(ViewFeatureCaptures.x, "box_x") }
-                }
+                },
             )
 
         motionRule.assertThat(recordedMotion).timeSeriesMatchesGolden("timeseries_simple_scene_box")
@@ -82,7 +82,7 @@ class ViewToolkitTest {
                 animator,
                 sceneRoot.captureWithoutScreenshot(evenlySampled(10)) {
                     onViewWithId(R.id.test_box) { feature(ViewFeatureCaptures.x, "box_x") }
-                }
+                },
             )
 
         motionRule.assertThat(recordedMotion).timeSeriesMatchesGolden("timeseries_simple_scene_box")
@@ -113,13 +113,6 @@ class ViewToolkitTest {
     companion object {
 
         private val emulationSpec =
-            DeviceEmulationSpec(
-                DisplaySpec(
-                    "phone",
-                    width = 320,
-                    height = 690,
-                    densityDpi = 160,
-                )
-            )
+            DeviceEmulationSpec(DisplaySpec("phone", width = 320, height = 690, densityDpi = 160))
     }
 }
diff --git a/libraries/rdroidtest/src/lib.rs b/libraries/rdroidtest/src/lib.rs
index 9ea742e02..3b5f35569 100644
--- a/libraries/rdroidtest/src/lib.rs
+++ b/libraries/rdroidtest/src/lib.rs
@@ -42,7 +42,7 @@ macro_rules! test {
             #[$crate::_linkme::distributed_slice($crate::runner::RDROIDTEST_TESTS)]
             fn [< __test_ $test_name >]() -> $crate::_libtest_mimic::Trial {
                 $crate::_libtest_mimic::Trial::test(
-                    ::std::stringify!($test_name),
+                    $crate::_prepend_module_path!(::std::stringify!($test_name)),
                     move || $crate::runner::run($test_name),
                 )
             }
@@ -53,7 +53,7 @@ macro_rules! test {
             #[$crate::_linkme::distributed_slice($crate::runner::RDROIDTEST_TESTS)]
             fn [< __test_ $test_name >]() -> $crate::_libtest_mimic::Trial {
                 $crate::_libtest_mimic::Trial::test(
-                    ::std::stringify!($test_name),
+                    $crate::_prepend_module_path!(::std::stringify!($test_name)),
                     move || $crate::runner::run($test_name),
                 ).with_ignored_flag($ignore_expr)
             }
@@ -92,7 +92,11 @@ macro_rules! ptest {
             fn [< __ptest_ $test_name >]() -> Vec<$crate::_libtest_mimic::Trial> {
                 $param_gen.into_iter().map(|(name, val)| {
                     $crate::_libtest_mimic::Trial::test(
-                        format!("{}/{}", ::std::stringify!($test_name), name),
+                        format!(
+                            "{}/{}",
+                            $crate::_prepend_module_path!(::std::stringify!($test_name)),
+                            name
+                        ),
                         move || $crate::runner::run(|| $test_name(val)),
                     )
                 }).collect()
@@ -106,7 +110,11 @@ macro_rules! ptest {
                 $param_gen.into_iter().map(|(name, val)| {
                     let ignored = $ignore_expr(&val);
                     $crate::_libtest_mimic::Trial::test(
-                        format!("{}/{}", ::std::stringify!($test_name), name),
+                        format!(
+                            "{}/{}",
+                            $crate::_prepend_module_path!(::std::stringify!($test_name)),
+                            name
+                        ),
                         move || $crate::runner::run(|| $test_name(val)),
                     ).with_ignored_flag(ignored)
                 }).collect()
@@ -114,3 +122,16 @@ macro_rules! ptest {
         );
     };
 }
+
+/// Prepends module path (without the crate name) to the test name and returns
+/// the new string.
+#[doc(hidden)]
+#[macro_export]
+macro_rules! _prepend_module_path {
+    ($test_name:expr) => {{
+        match module_path!().split_once("::") {
+            Some((_, path)) => format!("{}::{}", path, $test_name),
+            None => format!("{}", $test_name),
+        }
+    }};
+}
diff --git a/libraries/runner/Android.bp b/libraries/runner/Android.bp
index 93027190f..280ad0862 100644
--- a/libraries/runner/Android.bp
+++ b/libraries/runner/Android.bp
@@ -22,15 +22,33 @@ android_library {
     manifest: "AndroidManifest.xml",
     platform_apis: true,
     min_sdk_version: "Tiramisu",
-    lint: { test: true },
+    lint: {
+        test: true,
+    },
     optimize: {
-        enabled: false
+        enabled: false,
     },
     srcs: [
         "src/main/java/**/*.java",
     ],
     libs: [
-      "Robolectric_all-target_upstream",
+        "Robolectric_all-target_upstream",
+    ],
+    static_libs: [],
+}
+
+android_test {
+    name: "platform-parametric-runner-lib-test",
+    team: "trendy_team_test_infrastructure",
+    srcs: [
+        "src/test/java/**/*.java",
+        "src/test/java/**/*.kt",
+    ],
+    static_libs: [
+        "platform-parametric-runner-lib",
     ],
-    static_libs: [ ],
+
+    sdk_version: "current",
+
+    test_suites: ["general-tests"],
 }
diff --git a/libraries/runner/TEST_MAPPING b/libraries/runner/TEST_MAPPING
new file mode 100644
index 000000000..da11d1a8a
--- /dev/null
+++ b/libraries/runner/TEST_MAPPING
@@ -0,0 +1,7 @@
+{
+  "postsubmit": [
+    {
+      "name": "platform-parametric-runner-lib-test"
+    }
+  ]
+}
\ No newline at end of file
diff --git a/libraries/runner/src/androidTest/java/platform/test/runner/parameterized/ClassRuleCountTest.kt b/libraries/runner/src/androidTest/java/platform/test/runner/parameterized/ClassRuleCountTest.kt
new file mode 100644
index 000000000..ed05668c8
--- /dev/null
+++ b/libraries/runner/src/androidTest/java/platform/test/runner/parameterized/ClassRuleCountTest.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package platform.test.runner.parameterized
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.ClassRule
+import org.junit.Test
+import org.junit.rules.TestRule
+import org.junit.runner.RunWith
+
+@RunWith(ParameterizedAndroidJunit4::class)
+class ClassRuleCountTest(private val i: Int) {
+    companion object {
+        var howManyApplications = 0
+
+        @JvmStatic
+        @get:ClassRule
+        val countApplicationsRule = TestRule { base, _ ->
+            howManyApplications++
+            base
+        }
+
+        @JvmStatic
+        @Parameters(name = "N = {0}")
+        fun data(): List<Array<Any>> {
+            return listOf(arrayOf(0), arrayOf(1))
+        }
+    }
+
+    @Test
+    fun equalityWorks() {
+        assertThat(i).isEqualTo(i)
+        assertThat(howManyApplications).isEqualTo(1)
+    }
+}
diff --git a/libraries/runner/src/main/java/platform/test/runner/parameterized/AndroidParameterizedRunner.java b/libraries/runner/src/main/java/platform/test/runner/parameterized/AndroidParameterizedRunner.java
index f5d53cd0c..526124fdd 100644
--- a/libraries/runner/src/main/java/platform/test/runner/parameterized/AndroidParameterizedRunner.java
+++ b/libraries/runner/src/main/java/platform/test/runner/parameterized/AndroidParameterizedRunner.java
@@ -18,9 +18,11 @@ package platform.test.runner.parameterized;
 
 import androidx.test.internal.runner.junit4.AndroidJUnit4ClassRunner;
 
+import org.junit.rules.TestRule;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 
+import java.util.Collections;
 import java.util.List;
 
 /** Parameterized runner for Android instrumentation. */
@@ -67,4 +69,11 @@ public class AndroidParameterizedRunner extends AndroidJUnit4ClassRunner {
     protected Object createTest() throws Exception {
         return mDelegate.createTestInstance(getTestClass());
     }
+
+    @Override
+    protected List<TestRule> classRules() {
+        // We are already running ClassRules at the top class level, don't run them again
+        // on each parameter (b/377890695)
+        return Collections.emptyList();
+    }
 }
diff --git a/libraries/screenshot/deviceless/layoutlib/tests/run_tests.sh b/libraries/screenshot/deviceless/layoutlib/tests/run_tests.sh
index 68bb8c992..8b4570cca 100755
--- a/libraries/screenshot/deviceless/layoutlib/tests/run_tests.sh
+++ b/libraries/screenshot/deviceless/layoutlib/tests/run_tests.sh
@@ -18,6 +18,7 @@ JAVA_LIBRARIES=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/soong/.intermediates/platform
 SDK=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/linux-x86/sdk/sdk*/android-sdk*"
 SDK_REPO=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/linux-x86/sdk-repo"
 FONT_DIR=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/common/obj/PACKAGING/fonts_intermediates"
+HYPHEN_DATA_DIR=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/common/obj/PACKAGING/hyphen_intermediates"
 KEYBOARD_DIR=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/common/obj/PACKAGING/keyboards_intermediates"
 ICU_DATA_PATH=${SCRIPT_DIR}"/${SCRIPT_TO_TOP}/out/host/linux-x86/com.android.i18n/etc/icu/icudt71l.dat"
 TMP_DIR=$(mktemp -d)
@@ -48,6 +49,7 @@ ${STUDIO_JDK}/bin/java -ea \
     -Dnative.lib.path=${NATIVE_LIBRARIES} \
     -Dfont.dir=${FONT_DIR} \
     -Dicu.data.path=${ICU_DATA_PATH} \
+    -Dhyphen.data.dir=${HYPHEN_DATA_DIR} \
     -Dkeyboard.dir=${KEYBOARD_DIR} \
     -Dplatform.dir=${PLATFORM} \
     -Dtest_res.dir=${SCRIPT_DIR}/res \
diff --git a/libraries/screenshot/deviceless/layoutlib/tests/src/com/android/layoutlib/bridge/intensive/RenderTestBase.java b/libraries/screenshot/deviceless/layoutlib/tests/src/com/android/layoutlib/bridge/intensive/RenderTestBase.java
index 4a4242baa..80c22fb60 100644
--- a/libraries/screenshot/deviceless/layoutlib/tests/src/com/android/layoutlib/bridge/intensive/RenderTestBase.java
+++ b/libraries/screenshot/deviceless/layoutlib/tests/src/com/android/layoutlib/bridge/intensive/RenderTestBase.java
@@ -16,6 +16,13 @@
 
 package com.android.layoutlib.bridge.intensive;
 
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.view.Choreographer;
+
 import com.android.ide.common.rendering.api.ILayoutLog;
 import com.android.ide.common.rendering.api.RenderSession;
 import com.android.ide.common.rendering.api.Result;
@@ -37,6 +44,8 @@ import com.android.layoutlib.bridge.intensive.util.SessionParamsBuilder;
 import com.android.layoutlib.bridge.intensive.util.TestAssetRepository;
 import com.android.utils.ILogger;
 
+import com.google.android.collect.Lists;
+
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -44,10 +53,6 @@ import org.junit.Rule;
 import org.junit.rules.TestWatcher;
 import org.junit.runner.Description;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.view.Choreographer;
-
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -55,14 +60,8 @@ import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 
-import com.google.android.collect.Lists;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-
 /**
  * Base class for render tests. The render tests load all the framework resources and a project
  * checked in this test's resources. The main dependencies
@@ -102,6 +101,7 @@ public class RenderTestBase {
     private static final String NATIVE_LIB_PATH_PROPERTY = "native.lib.path";
     private static final String FONT_DIR_PROPERTY = "font.dir";
     private static final String ICU_DATA_PATH_PROPERTY = "icu.data.path";
+    private static final String HYPHEN_DATA_DIR_PROPERTY = "hyphen.data.dir";
     private static final String KEYBOARD_DIR_PROPERTY = "keyboard.dir";
     private static final String PLATFORM_DIR_PROPERTY = "platform.dir";
     private static final String RESOURCE_DIR_PROPERTY = "test_res.dir";
@@ -109,6 +109,7 @@ public class RenderTestBase {
     private static final String NATIVE_LIB_DIR_PATH;
     private static final String FONT_DIR;
     private static final String ICU_DATA_PATH;
+    private static final String HYPHEN_DATA_DIR;
     private static final String KEYBOARD_DIR;
     protected static final String PLATFORM_DIR;
     private static final String TEST_RES_DIR;
@@ -139,6 +140,7 @@ public class RenderTestBase {
         NATIVE_LIB_DIR_PATH = getNativeLibDirPath();
         FONT_DIR = getFontDir();
         ICU_DATA_PATH = getIcuDataPath();
+        HYPHEN_DATA_DIR = getHyphenDataDir();
         KEYBOARD_DIR = getKeyboardDir();
 
         TEST_RES_DIR = getTestResDir();
@@ -210,6 +212,15 @@ public class RenderTestBase {
         return icuDataPath;
     }
 
+    private static String getHyphenDataDir() {
+        String hyphenDataDir = System.getProperty(HYPHEN_DATA_DIR_PROPERTY);
+        if (hyphenDataDir == null) {
+            hyphenDataDir =
+                    PLATFORM_DIR + "/../../../../../../common/obj/PACKAGING/hyphen_intermediates";
+        }
+        return hyphenDataDir;
+    }
+
     private static String getKeyboardDir() {
         String keyboardDir = System.getProperty(KEYBOARD_DIR_PROPERTY);
         if (keyboardDir == null) {
@@ -398,8 +409,15 @@ public class RenderTestBase {
         
         String[] keyboardPaths = new String[] { KEYBOARD_DIR + "/Generic.kcm" };
         sBridge = new Bridge();
-        sBridge.init(ConfigGenerator.loadProperties(buildProp), fontLocation, NATIVE_LIB_DIR_PATH,
-                ICU_DATA_PATH, keyboardPaths, ConfigGenerator.getEnumMap(attrs), getLayoutLog());
+        sBridge.init(
+                ConfigGenerator.loadProperties(buildProp),
+                fontLocation,
+                NATIVE_LIB_DIR_PATH,
+                ICU_DATA_PATH,
+                HYPHEN_DATA_DIR,
+                keyboardPaths,
+                ConfigGenerator.getEnumMap(attrs),
+                getLayoutLog());
         Bridge.getLock().lock();
         try {
             Bridge.setLog(getLayoutLog());
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
index 11ff11282..d63fd17f5 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/Bitmap.kt
@@ -16,7 +16,6 @@
 
 package platform.test.screenshot
 
-import android.os.Build
 import platform.test.screenshot.matchers.MSSIMMatcher
 import platform.test.screenshot.matchers.PixelPerfectMatcher
 
@@ -25,7 +24,7 @@ import platform.test.screenshot.matchers.PixelPerfectMatcher
  * screenshot *unit* tests.
  */
 val UnitTestBitmapMatcher =
-    if (Build.CPU_ABI == "x86_64" || Build.FINGERPRINT.contains("robolectric")) {
+    if (System.getProperty("java.vm.name")?.equals("Dalvik") == false) { // isRobolectric
         // Different CPU architectures can sometimes end up rendering differently, so we can't do
         // pixel-perfect matching on different architectures using the same golden. Given that our
         // presubmits are run on cf_x86_64_phone, our goldens should be perfectly matched on the
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/DialogScreenshotTest.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/DialogScreenshotTest.kt
index 9180ec79c..de141c474 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/DialogScreenshotTest.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/DialogScreenshotTest.kt
@@ -30,6 +30,7 @@ fun <A : Activity> dialogScreenshotTest(
     goldenIdentifier: String,
     waitForIdle: () -> Unit = {},
     dialogProvider: (A) -> Dialog,
+    checkDialog: (Dialog) -> Boolean = { _ -> false },
 ) {
     var dialog: Dialog? = null
     activityRule.scenario.onActivity { activity ->
@@ -54,16 +55,22 @@ fun <A : Activity> dialogScreenshotTest(
             }
     }
 
+    checkNotNull(dialog)
+
+    // We call onActivity again because it will make sure that our Activity is done measuring,
+    // laying out and drawing its content.
+    var waitForActivity = true
+    var iterCount = 0
+    while (waitForActivity && iterCount < 10) {
+        activityRule.scenario.onActivity { waitForActivity = checkDialog(dialog!!) }
+        iterCount++
+    }
+
     waitForIdle()
 
     try {
         val bitmap = dialog?.toBitmap() ?: error("dialog is null")
-
-        bitmapDiffer.assertBitmapAgainstGolden(
-            bitmap,
-            goldenIdentifier,
-            matcher,
-        )
+        bitmapDiffer.assertBitmapAgainstGolden(bitmap, goldenIdentifier, matcher)
     } finally {
         dialog?.dismiss()
     }
diff --git a/libraries/screenshot/src/main/java/platform/test/screenshot/ViewScreenshotTestRule.kt b/libraries/screenshot/src/main/java/platform/test/screenshot/ViewScreenshotTestRule.kt
index 3f91d09da..e6127b711 100644
--- a/libraries/screenshot/src/main/java/platform/test/screenshot/ViewScreenshotTestRule.kt
+++ b/libraries/screenshot/src/main/java/platform/test/screenshot/ViewScreenshotTestRule.kt
@@ -41,7 +41,7 @@ open class ViewScreenshotTestRule(
     pathManager: GoldenPathManager,
     private val matcher: BitmapMatcher = UnitTestBitmapMatcher,
     private val decorFitsSystemWindows: Boolean = false,
-    protected val screenshotRule: ScreenshotTestRule = ScreenshotTestRule(pathManager)
+    protected val screenshotRule: ScreenshotTestRule = ScreenshotTestRule(pathManager),
 ) : TestRule, BitmapDiffer by screenshotRule, ScreenshotAsserterFactory by screenshotRule {
     private val colorsRule = MaterialYouColorsRule()
     private val fontsRule = FontsRule()
@@ -144,7 +144,7 @@ open class ViewScreenshotTestRule(
                 false
             },
             subviewId,
-            viewProvider
+            viewProvider,
         )
 
     /**
@@ -169,6 +169,7 @@ open class ViewScreenshotTestRule(
     fun dialogScreenshotTest(
         goldenIdentifier: String,
         waitForIdle: () -> Unit = {},
+        waitingForDialog: (Dialog) -> Boolean = { _ -> false },
         dialogProvider: (Activity) -> Dialog,
     ) {
         dialogScreenshotTest(
@@ -178,6 +179,7 @@ open class ViewScreenshotTestRule(
             goldenIdentifier,
             waitForIdle,
             dialogProvider,
+            waitingForDialog,
         )
     }
 
diff --git a/libraries/screenshot/utils/compose/res/values-night/themes.xml b/libraries/screenshot/utils/compose/res/values-night/themes.xml
deleted file mode 100644
index fc03012a2..000000000
--- a/libraries/screenshot/utils/compose/res/values-night/themes.xml
+++ /dev/null
@@ -1,117 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-     Copyright (C) 2022 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<resources>
-    <style name="Theme.PlatformUi.DayAndNightScreenshot" parent="Theme.SystemUI">
-        <!-- Hardcode the material colors so that screenshot tests don't depend on colors that will
-             change with the device wallpaper. These colors were frozen when using the same color
-             configuration as the MaterialYouColorsRule. -->
-        <item name="*android:materialColorOnSecondaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnTertiaryFixedVariant">#004E5F</item>
-        <item name="*android:materialColorSurfaceContainerLowest">#051013</item>
-        <item name="*android:materialColorOnPrimaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnSecondaryContainer">#A5F2D3</item>
-        <item name="*android:materialColorOnTertiaryContainer">#B2EBFF</item>
-        <item name="*android:materialColorSurfaceContainerLow">#121D21</item>
-        <item name="*android:materialColorOnPrimaryContainer">#83F8CD</item>
-        <item name="*android:materialColorSecondaryFixedDim">#8AD6B7</item>
-        <item name="*android:materialColorOnErrorContainer">#FFDAD6</item>
-        <item name="*android:materialColorOnSecondaryFixed">#002116</item>
-        <item name="*android:materialColorOnSurfaceInverse">#121D21</item>
-        <item name="*android:materialColorTertiaryFixedDim">#86D1E9</item>
-        <item name="*android:materialColorOnTertiaryFixed">#001F27</item>
-        <item name="*android:materialColorPrimaryFixedDim">#66DBB2</item>
-        <item name="*android:materialColorSecondaryContainer">#00513C</item>
-        <item name="*android:materialColorErrorContainer">#93000A</item>
-        <item name="*android:materialColorOnPrimaryFixed">#002116</item>
-        <item name="*android:materialColorPrimaryInverse">#006C51</item>
-        <item name="*android:materialColorSecondaryFixed">#A5F2D3</item>
-        <item name="*android:materialColorTertiaryContainer">#004E5F</item>
-        <item name="*android:materialColorTertiaryFixed">#B2EBFF</item>
-        <item name="*android:materialColorPrimaryContainer">#00513C</item>
-        <item name="*android:materialColorOnBackground">#D8E4EA</item>
-        <item name="*android:materialColorPrimaryFixed">#83F8CD</item>
-        <item name="*android:materialColorOnSecondary">#003829</item>
-        <item name="*android:materialColorOnTertiary">#003642</item>
-        <item name="*android:materialColorOnError">#690005</item>
-        <item name="*android:materialColorOnSurfaceVariant">#B3CAD3</item>
-        <item name="*android:materialColorOutline">#7D949D</item>
-        <item name="*android:materialColorOutlineVariant">#344A52</item>
-        <item name="*android:materialColorOnPrimary">#003829</item>
-        <item name="*android:materialColorOnSurface">#D8E4EA</item>
-        <item name="*android:materialColorPrimary">#66DBB2</item>
-        <item name="*android:materialColorSecondary">#8AD6B7</item>
-        <item name="*android:materialColorTertiary">#86D1E9</item>
-        <item name="*android:materialColorSurfaceInverse">#F2FBFF</item>
-        <item name="*android:materialColorSurfaceVariant">#344A52</item>
-        <item name="*android:materialColorSurfaceDim">#0A1519</item>
-        <item name="*android:materialColorSurfaceBright">#303B3F</item>
-        <item name="*android:materialColorSurface">#0A1519</item>
-        <item name="*android:materialColorSurfaceContainerHigh">#202C30</item>
-        <item name="*android:materialColorSurfaceContainerHighest">#2B373B</item>
-        <item name="*android:materialColorSurfaceContainer">#162125</item>
-    </style>
-
-    <style name="Theme.PlatformUi.Dialog.DayAndNightScreenshot" parent="Theme.SystemUI.Dialog">
-        <!-- Hardcode the material colors so that screenshot tests don't depend on colors that will
-             change with the device wallpaper. These colors were frozen when using the same color
-             configuration as the MaterialYouColorsRule. -->
-        <item name="*android:materialColorOnSecondaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnTertiaryFixedVariant">#004E5F</item>
-        <item name="*android:materialColorSurfaceContainerLowest">#051013</item>
-        <item name="*android:materialColorOnPrimaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnSecondaryContainer">#A5F2D3</item>
-        <item name="*android:materialColorOnTertiaryContainer">#B2EBFF</item>
-        <item name="*android:materialColorSurfaceContainerLow">#121D21</item>
-        <item name="*android:materialColorOnPrimaryContainer">#83F8CD</item>
-        <item name="*android:materialColorSecondaryFixedDim">#8AD6B7</item>
-        <item name="*android:materialColorOnErrorContainer">#FFDAD6</item>
-        <item name="*android:materialColorOnSecondaryFixed">#002116</item>
-        <item name="*android:materialColorOnSurfaceInverse">#121D21</item>
-        <item name="*android:materialColorTertiaryFixedDim">#86D1E9</item>
-        <item name="*android:materialColorOnTertiaryFixed">#001F27</item>
-        <item name="*android:materialColorPrimaryFixedDim">#66DBB2</item>
-        <item name="*android:materialColorSecondaryContainer">#00513C</item>
-        <item name="*android:materialColorErrorContainer">#93000A</item>
-        <item name="*android:materialColorOnPrimaryFixed">#002116</item>
-        <item name="*android:materialColorPrimaryInverse">#006C51</item>
-        <item name="*android:materialColorSecondaryFixed">#A5F2D3</item>
-        <item name="*android:materialColorTertiaryContainer">#004E5F</item>
-        <item name="*android:materialColorTertiaryFixed">#B2EBFF</item>
-        <item name="*android:materialColorPrimaryContainer">#00513C</item>
-        <item name="*android:materialColorOnBackground">#D8E4EA</item>
-        <item name="*android:materialColorPrimaryFixed">#83F8CD</item>
-        <item name="*android:materialColorOnSecondary">#003829</item>
-        <item name="*android:materialColorOnTertiary">#003642</item>
-        <item name="*android:materialColorOnError">#690005</item>
-        <item name="*android:materialColorOnSurfaceVariant">#B3CAD3</item>
-        <item name="*android:materialColorOutline">#7D949D</item>
-        <item name="*android:materialColorOutlineVariant">#344A52</item>
-        <item name="*android:materialColorOnPrimary">#003829</item>
-        <item name="*android:materialColorOnSurface">#D8E4EA</item>
-        <item name="*android:materialColorPrimary">#66DBB2</item>
-        <item name="*android:materialColorSecondary">#8AD6B7</item>
-        <item name="*android:materialColorTertiary">#86D1E9</item>
-        <item name="*android:materialColorSurfaceInverse">#F2FBFF</item>
-        <item name="*android:materialColorSurfaceVariant">#344A52</item>
-        <item name="*android:materialColorSurfaceDim">#0A1519</item>
-        <item name="*android:materialColorSurfaceBright">#303B3F</item>
-        <item name="*android:materialColorSurface">#0A1519</item>
-        <item name="*android:materialColorSurfaceContainerHigh">#202C30</item>
-        <item name="*android:materialColorSurfaceContainerHighest">#2B373B</item>
-        <item name="*android:materialColorSurfaceContainer">#162125</item>
-    </style>
-</resources>
\ No newline at end of file
diff --git a/libraries/screenshot/utils/compose/res/values/themes.xml b/libraries/screenshot/utils/compose/res/values/themes.xml
index bfef4eb56..c0802c791 100644
--- a/libraries/screenshot/utils/compose/res/values/themes.xml
+++ b/libraries/screenshot/utils/compose/res/values/themes.xml
@@ -15,7 +15,7 @@
      limitations under the License.
 -->
 <resources>
-    <style name="Theme.PlatformUi.Screenshot" parent="Theme.PlatformUi.DayAndNightScreenshot">
+    <style name="Theme.PlatformUi.Screenshot" parent="Theme.SystemUI">
         <item name="android:windowActionBar">false</item>
         <item name="android:windowNoTitle">true</item>
 
@@ -34,110 +34,10 @@
         <item name="android:windowOptOutEdgeToEdgeEnforcement">true</item>
     </style>
 
-    <style name="Theme.PlatformUi.Dialog.Screenshot" parent="Theme.PlatformUi.Dialog.DayAndNightScreenshot" />
+    <style name="Theme.PlatformUi.Dialog.Screenshot" parent="Theme.SystemUI.Dialog" />
 
     <style name="Theme.PlatformUi.Dialog.Screenshot.MinWidth" parent="Theme.PlatformUi.Dialog.Screenshot">
         <item name="android:windowMinWidthMajor">@android:dimen/dialog_min_width_major</item>
         <item name="android:windowMinWidthMinor">@android:dimen/dialog_min_width_minor</item>
     </style>
-
-    <style name="Theme.PlatformUi.DayAndNightScreenshot" parent="Theme.SystemUI">
-        <!-- Hardcode the material colors so that screenshot tests don't depend on colors that will
-             change with the device wallpaper. These colors were frozen when using the same color
-             configuration as the MaterialYouColorsRule. -->
-        <item name="*android:materialColorOnSecondaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnTertiaryFixedVariant">#004E5F</item>
-        <item name="*android:materialColorSurfaceContainerLowest">#FFFFFF</item>
-        <item name="*android:materialColorOnPrimaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnSecondaryContainer">#002116</item>
-        <item name="*android:materialColorOnTertiaryContainer">#001F27</item>
-        <item name="*android:materialColorSurfaceContainerLow">#E9F6FB</item>
-        <item name="*android:materialColorOnPrimaryContainer">#002116</item>
-        <item name="*android:materialColorSecondaryFixedDim">#8AD6B7</item>
-        <item name="*android:materialColorOnErrorContainer">#410002</item>
-        <item name="*android:materialColorOnSecondaryFixed">#002116</item>
-        <item name="*android:materialColorOnSurfaceInverse">#D8E4EA</item>
-        <item name="*android:materialColorTertiaryFixedDim">#86D1E9</item>
-        <item name="*android:materialColorOnTertiaryFixed">#001F27</item>
-        <item name="*android:materialColorPrimaryFixedDim">#66DBB2</item>
-        <item name="*android:materialColorSecondaryContainer">#A5F2D3</item>
-        <item name="*android:materialColorErrorContainer">#FFDAD6</item>
-        <item name="*android:materialColorOnPrimaryFixed">#002116</item>
-        <item name="*android:materialColorPrimaryInverse">#66DBB2</item>
-        <item name="*android:materialColorSecondaryFixed">#A5F2D3</item>
-        <item name="*android:materialColorTertiaryContainer">#B2EBFF</item>
-        <item name="*android:materialColorTertiaryFixed">#B2EBFF</item>
-        <item name="*android:materialColorPrimaryContainer">#83F8CD</item>
-        <item name="*android:materialColorOnBackground">#121D21</item>
-        <item name="*android:materialColorPrimaryFixed">#83F8CD</item>
-        <item name="*android:materialColorOnSecondary">#FFFFFF</item>
-        <item name="*android:materialColorOnTertiary">#FFFFFF</item>
-        <item name="*android:materialColorOnError">#FFFFFF</item>
-        <item name="*android:materialColorOnSurfaceVariant">#344A52</item>
-        <item name="*android:materialColorOutline">#647B83</item>
-        <item name="*android:materialColorOutlineVariant">#B3CAD3</item>
-        <item name="*android:materialColorOnPrimary">#FFFFFF</item>
-        <item name="*android:materialColorOnSurface">#121D21</item>
-        <item name="*android:materialColorPrimary">#006C51</item>
-        <item name="*android:materialColorSecondary">#196B52</item>
-        <item name="*android:materialColorTertiary">#00677D</item>
-        <item name="*android:materialColorSurfaceInverse">#0A1519</item>
-        <item name="*android:materialColorSurfaceVariant">#CEE6F0</item>
-        <item name="*android:materialColorSurfaceDim">#D0DCE1</item>
-        <item name="*android:materialColorSurfaceBright">#F2FBFF</item>
-        <item name="*android:materialColorSurface">#F2FBFF</item>
-        <item name="*android:materialColorSurfaceContainerHigh">#DEEAEF</item>
-        <item name="*android:materialColorSurfaceContainerHighest">#D8E4EA</item>
-        <item name="*android:materialColorSurfaceContainer">#E4F0F5</item>
-    </style>
-
-    <style name="Theme.PlatformUi.Dialog.DayAndNightScreenshot" parent="Theme.SystemUI.Dialog">
-        <!-- Hardcode the material colors so that screenshot tests don't depend on colors that will
-             change with the device wallpaper. These colors were frozen when using the same color
-             configuration as the MaterialYouColorsRule. -->
-        <item name="*android:materialColorOnSecondaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnTertiaryFixedVariant">#004E5F</item>
-        <item name="*android:materialColorSurfaceContainerLowest">#FFFFFF</item>
-        <item name="*android:materialColorOnPrimaryFixedVariant">#00513C</item>
-        <item name="*android:materialColorOnSecondaryContainer">#002116</item>
-        <item name="*android:materialColorOnTertiaryContainer">#001F27</item>
-        <item name="*android:materialColorSurfaceContainerLow">#E9F6FB</item>
-        <item name="*android:materialColorOnPrimaryContainer">#002116</item>
-        <item name="*android:materialColorSecondaryFixedDim">#8AD6B7</item>
-        <item name="*android:materialColorOnErrorContainer">#410002</item>
-        <item name="*android:materialColorOnSecondaryFixed">#002116</item>
-        <item name="*android:materialColorOnSurfaceInverse">#D8E4EA</item>
-        <item name="*android:materialColorTertiaryFixedDim">#86D1E9</item>
-        <item name="*android:materialColorOnTertiaryFixed">#001F27</item>
-        <item name="*android:materialColorPrimaryFixedDim">#66DBB2</item>
-        <item name="*android:materialColorSecondaryContainer">#A5F2D3</item>
-        <item name="*android:materialColorErrorContainer">#FFDAD6</item>
-        <item name="*android:materialColorOnPrimaryFixed">#002116</item>
-        <item name="*android:materialColorPrimaryInverse">#66DBB2</item>
-        <item name="*android:materialColorSecondaryFixed">#A5F2D3</item>
-        <item name="*android:materialColorTertiaryContainer">#B2EBFF</item>
-        <item name="*android:materialColorTertiaryFixed">#B2EBFF</item>
-        <item name="*android:materialColorPrimaryContainer">#83F8CD</item>
-        <item name="*android:materialColorOnBackground">#121D21</item>
-        <item name="*android:materialColorPrimaryFixed">#83F8CD</item>
-        <item name="*android:materialColorOnSecondary">#FFFFFF</item>
-        <item name="*android:materialColorOnTertiary">#FFFFFF</item>
-        <item name="*android:materialColorOnError">#FFFFFF</item>
-        <item name="*android:materialColorOnSurfaceVariant">#344A52</item>
-        <item name="*android:materialColorOutline">#647B83</item>
-        <item name="*android:materialColorOutlineVariant">#B3CAD3</item>
-        <item name="*android:materialColorOnPrimary">#FFFFFF</item>
-        <item name="*android:materialColorOnSurface">#121D21</item>
-        <item name="*android:materialColorPrimary">#006C51</item>
-        <item name="*android:materialColorSecondary">#196B52</item>
-        <item name="*android:materialColorTertiary">#00677D</item>
-        <item name="*android:materialColorSurfaceInverse">#0A1519</item>
-        <item name="*android:materialColorSurfaceVariant">#CEE6F0</item>
-        <item name="*android:materialColorSurfaceDim">#D0DCE1</item>
-        <item name="*android:materialColorSurfaceBright">#F2FBFF</item>
-        <item name="*android:materialColorSurface">#F2FBFF</item>
-        <item name="*android:materialColorSurfaceContainerHigh">#DEEAEF</item>
-        <item name="*android:materialColorSurfaceContainerHighest">#D8E4EA</item>
-        <item name="*android:materialColorSurfaceContainer">#E4F0F5</item>
-    </style>
 </resources>
diff --git a/libraries/sts-common-util/sts-sdk/example/.gitignore b/libraries/sts-common-util/autorepro/example/.gitignore
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/.gitignore
rename to libraries/sts-common-util/autorepro/example/.gitignore
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/assembleSubmissionSources.run.xml b/libraries/sts-common-util/autorepro/example/.run/assembleSubmissionSources.run.xml
similarity index 92%
rename from libraries/sts-common-util/sts-sdk/example/.run/assembleSubmissionSources.run.xml
rename to libraries/sts-common-util/autorepro/example/.run/assembleSubmissionSources.run.xml
index 471d1af37..b6f979e86 100644
--- a/libraries/sts-common-util/sts-sdk/example/.run/assembleSubmissionSources.run.xml
+++ b/libraries/sts-common-util/autorepro/example/.run/assembleSubmissionSources.run.xml
@@ -10,7 +10,7 @@
       </option>
       <option name="taskNames">
         <list>
-          <option value="assembStsSdkSubmissionSources" />
+          <option value="assembleSubmissionSources" />
         </list>
       </option>
       <option name="vmOptions" />
@@ -21,4 +21,4 @@
     <RunAsTest>false</RunAsTest>
     <method v="2" />
   </configuration>
-</component>
\ No newline at end of file
+</component>
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/assembleStsSdkSubmissionZip.run.xml b/libraries/sts-common-util/autorepro/example/.run/assembleSubmissionZip.run.xml
similarity index 82%
rename from libraries/sts-common-util/sts-sdk/example/.run/assembleStsSdkSubmissionZip.run.xml
rename to libraries/sts-common-util/autorepro/example/.run/assembleSubmissionZip.run.xml
index 7885f4a9e..f3edeeb05 100644
--- a/libraries/sts-common-util/sts-sdk/example/.run/assembleStsSdkSubmissionZip.run.xml
+++ b/libraries/sts-common-util/autorepro/example/.run/assembleSubmissionZip.run.xml
@@ -1,5 +1,5 @@
 <component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="assembleStsSdkSubmissionZip" type="GradleRunConfiguration" factoryName="Gradle">
+  <configuration default="false" name="assembleSubmissionZip" type="GradleRunConfiguration" factoryName="Gradle">
     <ExternalSystemSettings>
       <option name="executionName" />
       <option name="externalProjectPath" value="$PROJECT_DIR$/submission" />
@@ -10,7 +10,7 @@
       </option>
       <option name="taskNames">
         <list>
-          <option value="assembleStsSdkSubmissionZip" />
+          <option value="assembleSubmissionZip" />
         </list>
       </option>
       <option name="vmOptions" />
diff --git a/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_arm64.run.xml b/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_arm64.run.xml
new file mode 100644
index 000000000..b60514370
--- /dev/null
+++ b/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_arm64.run.xml
@@ -0,0 +1,11 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="autorepro_nonroot_arm64" type="JarApplication">
+    <option name="JAR_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed.jar" />
+    <option name="PROGRAM_PARAMETERS" value="run commandAndExit autorepro-nonroot --log-level debug --log-level-display debug" />
+    <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+    <option name="ALTERNATIVE_JRE_PATH" />
+    <method v="2">
+      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleAutoReproTradefed-test_suites_arm64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
+    </method>
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_x86_64.run.xml b/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_x86_64.run.xml
new file mode 100644
index 000000000..257c1cc6c
--- /dev/null
+++ b/libraries/sts-common-util/autorepro/example/.run/autorepro_nonroot_x86_64.run.xml
@@ -0,0 +1,11 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="autorepro_nonroot_x86_64" type="JarApplication">
+    <option name="JAR_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed.jar" />
+    <option name="PROGRAM_PARAMETERS" value="run commandAndExit autorepro-nonroot --log-level debug --log-level-display debug" />
+    <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+    <option name="ALTERNATIVE_JRE_PATH" />
+    <method v="2">
+      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleAutoReproTradefed-test_suites_x86_64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
+    </method>
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/autorepro/example/.run/autorepro_root_arm64.run.xml b/libraries/sts-common-util/autorepro/example/.run/autorepro_root_arm64.run.xml
new file mode 100644
index 000000000..6a43191ca
--- /dev/null
+++ b/libraries/sts-common-util/autorepro/example/.run/autorepro_root_arm64.run.xml
@@ -0,0 +1,11 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="autorepro_root_arm64" type="JarApplication">
+    <option name="JAR_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed.jar" />
+    <option name="PROGRAM_PARAMETERS" value="run commandAndExit autorepro-root --log-level debug --log-level-display debug" />
+    <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+    <option name="ALTERNATIVE_JRE_PATH" />
+    <method v="2">
+      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleAutoReproTradefed-test_suites_arm64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
+    </method>
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/autorepro/example/.run/autorepro_root_x86_64.run.xml b/libraries/sts-common-util/autorepro/example/.run/autorepro_root_x86_64.run.xml
new file mode 100644
index 000000000..2f628fa2d
--- /dev/null
+++ b/libraries/sts-common-util/autorepro/example/.run/autorepro_root_x86_64.run.xml
@@ -0,0 +1,11 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="autorepro_root_x86_64" type="JarApplication">
+    <option name="JAR_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed.jar" />
+    <option name="PROGRAM_PARAMETERS" value="run commandAndExit autorepro-root --log-level debug --log-level-display debug" />
+    <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+    <option name="ALTERNATIVE_JRE_PATH" />
+    <method v="2">
+      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleAutoReproTradefed-test_suites_x86_64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
+    </method>
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/copyInvocationResultsToSubmission.run.xml b/libraries/sts-common-util/autorepro/example/.run/copyInvocationResultsToSubmission.run.xml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/.run/copyInvocationResultsToSubmission.run.xml
rename to libraries/sts-common-util/autorepro/example/.run/copyInvocationResultsToSubmission.run.xml
diff --git a/libraries/sts-common-util/sts-sdk/example/gradle.properties b/libraries/sts-common-util/autorepro/example/gradle.properties
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/gradle.properties
rename to libraries/sts-common-util/autorepro/example/gradle.properties
diff --git a/libraries/sts-common-util/sts-sdk/example/gradle/wrapper/gradle-wrapper.jar b/libraries/sts-common-util/autorepro/example/gradle/wrapper/gradle-wrapper.jar
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/gradle/wrapper/gradle-wrapper.jar
rename to libraries/sts-common-util/autorepro/example/gradle/wrapper/gradle-wrapper.jar
diff --git a/libraries/sts-common-util/sts-sdk/example/gradle/wrapper/gradle-wrapper.properties b/libraries/sts-common-util/autorepro/example/gradle/wrapper/gradle-wrapper.properties
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/gradle/wrapper/gradle-wrapper.properties
rename to libraries/sts-common-util/autorepro/example/gradle/wrapper/gradle-wrapper.properties
diff --git a/libraries/sts-common-util/sts-sdk/example/gradlew b/libraries/sts-common-util/autorepro/example/gradlew
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/gradlew
rename to libraries/sts-common-util/autorepro/example/gradlew
diff --git a/libraries/sts-common-util/sts-sdk/example/gradlew.bat b/libraries/sts-common-util/autorepro/example/gradlew.bat
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/gradlew.bat
rename to libraries/sts-common-util/autorepro/example/gradlew.bat
diff --git a/libraries/sts-common-util/sts-sdk/example/settings.gradle.kts b/libraries/sts-common-util/autorepro/example/settings.gradle.kts
similarity index 87%
rename from libraries/sts-common-util/sts-sdk/example/settings.gradle.kts
rename to libraries/sts-common-util/autorepro/example/settings.gradle.kts
index 4afcbcdc4..77e1cd38d 100644
--- a/libraries/sts-common-util/sts-sdk/example/settings.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/settings.gradle.kts
@@ -36,12 +36,10 @@ dependencyResolutionManagement {
 plugins {
     // Apply the foojay-resolver plugin to allow automatic download of JDKs
     id("org.gradle.toolchains.foojay-resolver-convention") version "0.4.0"
-    id("com.android.sts.sdksubmission") version "1.0.0" apply false
-    id("com.android.sts.apptest") version "1.0.0" apply false
-    id("com.android.sts.javahosttest") version "1.0.0" apply false
+    id("com.android.security.autorepro.submission") version "1.0.0-alpha1" apply false
 }
 
-rootProject.name = "sts-sdk-example"
+rootProject.name = "autorepro-example"
 
 // glob and include gradle projects
 fileTree(rootDir) {
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest/build.gradle.kts b/libraries/sts-common-util/autorepro/example/submission/appTest/build.gradle.kts
similarity index 81%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest/build.gradle.kts
rename to libraries/sts-common-util/autorepro/example/submission/appTest/build.gradle.kts
index 042f0e9ad..ee315d0ae 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/appTest/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/submission/appTest/build.gradle.kts
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-plugins { id("com.android.sts.apptest") }
+plugins { id("com.android.security.autorepro.apptest") }
 
-// Note: the Gradle package name is appended to the namespace "android.security.sts"
+// Note: the Gradle package name is appended to the namespace "com.android.security"
 appTest {}
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/AndroidManifest.xml b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/AndroidManifest.xml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/AndroidManifest.xml
rename to libraries/sts-common-util/autorepro/example/submission/appTest/src/main/AndroidManifest.xml
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/DeviceTest.java b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/DeviceTest.java
similarity index 99%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/DeviceTest.java
rename to libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/DeviceTest.java
index 6993204da..f825625e9 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/DeviceTest.java
+++ b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/DeviceTest.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package android.security.sts;
+package com.android.security;
 
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/PocActivity.java b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/PocActivity.java
similarity index 98%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/PocActivity.java
rename to libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/PocActivity.java
index 9adb2b5cf..9f2e26de6 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/java/android/security/sts/PocActivity.java
+++ b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/java/com/android/security/PocActivity.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package android.security.sts;
+package com.android.security;
 
 import android.app.Activity;
 import android.content.Intent;
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/res/layout/activity_main.xml b/libraries/sts-common-util/autorepro/example/submission/appTest/src/main/res/layout/activity_main.xml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest/src/main/res/layout/activity_main.xml
rename to libraries/sts-common-util/autorepro/example/submission/appTest/src/main/res/layout/activity_main.xml
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/build.gradle.kts b/libraries/sts-common-util/autorepro/example/submission/appTest2/build.gradle.kts
similarity index 91%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest2/build.gradle.kts
rename to libraries/sts-common-util/autorepro/example/submission/appTest2/build.gradle.kts
index d4e34cd14..cf91cdfcd 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/submission/appTest2/build.gradle.kts
@@ -13,6 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-plugins { id("com.android.sts.apptest") }
+plugins { id("com.android.security.autorepro.apptest") }
 
 appTest {}
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/AndroidManifest.xml b/libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/AndroidManifest.xml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/AndroidManifest.xml
rename to libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/AndroidManifest.xml
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/java/android/security/sts/PocActivity.java b/libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/java/com/android/security/PocActivity.java
similarity index 97%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/java/android/security/sts/PocActivity.java
rename to libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/java/com/android/security/PocActivity.java
index effa60619..d2e9d4d14 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/java/android/security/sts/PocActivity.java
+++ b/libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/java/com/android/security/PocActivity.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package android.security.sts;
+package com.android.security;
 
 import android.app.Activity;
 import android.os.Bundle;
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/res/layout/activity_main.xml b/libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/res/layout/activity_main.xml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/appTest2/src/main/res/layout/activity_main.xml
rename to libraries/sts-common-util/autorepro/example/submission/appTest2/src/main/res/layout/activity_main.xml
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/build.gradle.kts b/libraries/sts-common-util/autorepro/example/submission/build.gradle.kts
similarity index 68%
rename from libraries/sts-common-util/sts-sdk/example/submission/build.gradle.kts
rename to libraries/sts-common-util/autorepro/example/submission/build.gradle.kts
index f8fba7264..9f6200675 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/submission/build.gradle.kts
@@ -1,4 +1,4 @@
-plugins { id("com.android.sts.sdksubmission") }
+plugins { id("com.android.security.autorepro.submission") }
 
 fun getSubprojects(): List<Project> {
     // glob for gradle direct subprojects
@@ -15,12 +15,12 @@ fun getSubprojects(): List<Project> {
         .map { project(it) }
 }
 
-// NOTE! all STS SDK dependencies must be subprojects
+// NOTE! all AutoRepro dependencies must be subprojects
 dependencies {
-    // Automatically add each subproject as an STS SDK Test Resource
-    getSubprojects().forEach { stsSdkTestResource(it) }
+    // Automatically add each subproject as an AutoRepro Test Resource
+    getSubprojects().forEach { testResource(it) }
 }
 
-stsSdkSubmission {
+submission {
     // Please configure your submission attributes here
 }
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/hostTest/build.gradle.kts b/libraries/sts-common-util/autorepro/example/submission/hostTest/build.gradle.kts
similarity index 90%
rename from libraries/sts-common-util/sts-sdk/example/submission/hostTest/build.gradle.kts
rename to libraries/sts-common-util/autorepro/example/submission/hostTest/build.gradle.kts
index 4a6ca1a34..7222155dd 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/hostTest/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/submission/hostTest/build.gradle.kts
@@ -13,4 +13,4 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-plugins { id("com.android.sts.javahosttest") }
+plugins { id("com.android.security.autorepro.javahosttest") }
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/hostTest/src/main/java/android/security/sts/sts_sdk_placeholder/HostsideTest.java b/libraries/sts-common-util/autorepro/example/submission/hostTest/src/main/java/com/android/security/autorepro_placeholder/HostsideTest.java
similarity index 91%
rename from libraries/sts-common-util/sts-sdk/example/submission/hostTest/src/main/java/android/security/sts/sts_sdk_placeholder/HostsideTest.java
rename to libraries/sts-common-util/autorepro/example/submission/hostTest/src/main/java/com/android/security/autorepro_placeholder/HostsideTest.java
index 697202d34..3d936ae4e 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/hostTest/src/main/java/android/security/sts/sts_sdk_placeholder/HostsideTest.java
+++ b/libraries/sts-common-util/autorepro/example/submission/hostTest/src/main/java/com/android/security/autorepro_placeholder/HostsideTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package android.security.sts.sts_sdk_placeholder;
+package com.android.security.autorepro_placeholder;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
@@ -43,11 +43,11 @@ import java.util.regex.Pattern;
 public class HostsideTest extends NonRootSecurityTestCase {
 
     // Set from the Gradle project for the AppTest plugins.
-    static final String TEST_APP = "appTest_StsSdkPlaceholder.apk";
-    // The Gradle project name is appended to the namespace "android.security.sts".
-    static final String TEST_PKG = "android.security.sts.appTest_StsSdkPlaceholder";
+    static final String TEST_APP = "appTest_AutoReproPlaceholder.apk";
+    // The Gradle project name is appended to the namespace "com.android.security".
+    static final String TEST_PKG = "com.android.security.appTest_AutoReproPlaceholder";
     // The class name will be different from the application ID but will match the source code.
-    static final String TEST_CLASS = "android.security.sts.DeviceTest";
+    static final String TEST_CLASS = "com.android.security.DeviceTest";
 
     /** An app test, which uses this host Java test to launch an Android instrumented test */
     @Test
@@ -70,9 +70,9 @@ public class HostsideTest extends NonRootSecurityTestCase {
     public void testWithNativePoc() throws Exception {
         NativePoc.builder()
                 // the name of the PoC
-                .pocName("ndkTest_StsSdkPlaceholder")
+                .pocName("ndkTest_AutoReproPlaceholder")
                 // extra files pushed to the device
-                .resources("StsSdkPlaceholder/res.txt")
+                .resources("AutoReproPlaceholder/res.txt")
                 // command-line arguments for the PoC
                 .args("res.txt", "vulnerable")
                 // other options allow different linker paths for library shims
@@ -99,13 +99,13 @@ public class HostsideTest extends NonRootSecurityTestCase {
                 MallocDebug.withLibcMallocDebugOnNewProcess(
                         getDevice(),
                         "backtrace guard", // malloc debug options
-                        "ndkTest_StsSdkPlaceholder" // process name
+                        "ndkTest_AutoReproPlaceholder" // process name
                         )) {
             assumeTrue("could not disable root", getDevice().disableAdbRoot());
 
             // run a native PoC
             NativePoc.builder()
-                    .pocName("ndkTest_StsSdkPlaceholder")
+                    .pocName("ndkTest_AutoReproPlaceholder")
                     .args("memory_corrupt")
                     .build() // add more as needed
                     .run(this);
@@ -139,7 +139,7 @@ public class HostsideTest extends NonRootSecurityTestCase {
 
         // attack the service
         NativePoc.builder()
-                .pocName("ndkTest_StsSdkPlaceholder")
+                .pocName("ndkTest_AutoReproPlaceholder")
                 // pass the library path to the PoC
                 .args(libFileEntry.get().getFullPath())
                 .assumePocExitSuccess(false) // example returns EXIT_FAILURE if not enough args
@@ -149,7 +149,7 @@ public class HostsideTest extends NonRootSecurityTestCase {
                                         // Because the vulnerability is in the shared library, the
                                         // process crash is the PoC.
                                         .setProcessPatterns(
-                                                Pattern.compile("ndkTest_StsSdkPlaceholder"))))
+                                                Pattern.compile("ndkTest_AutoReproPlaceholder"))))
                 .build()
                 .run(this);
     }
@@ -161,7 +161,7 @@ public class HostsideTest extends NonRootSecurityTestCase {
 
         // attack the device, which can be native poc, echo to socket, send intent, app, etc
         NativePoc.builder()
-                .pocName("ndkTest_StsSdkPlaceholder")
+                .pocName("ndkTest_AutoReproPlaceholder")
                 .assumePocExitSuccess(false) // example returns EXIT_FAILURE if no args
                 .build() // add more as needed
                 .run(this);
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/hostTest/src/main/resources/StsSdkPlaceholder/res.txt b/libraries/sts-common-util/autorepro/example/submission/hostTest/src/main/resources/AutoReproPlaceholder/res.txt
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/hostTest/src/main/resources/StsSdkPlaceholder/res.txt
rename to libraries/sts-common-util/autorepro/example/submission/hostTest/src/main/resources/AutoReproPlaceholder/res.txt
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/ndkTest/CMakeLists.txt b/libraries/sts-common-util/autorepro/example/submission/ndkTest/CMakeLists.txt
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/ndkTest/CMakeLists.txt
rename to libraries/sts-common-util/autorepro/example/submission/ndkTest/CMakeLists.txt
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/ndkTest/build.gradle.kts b/libraries/sts-common-util/autorepro/example/submission/ndkTest/build.gradle.kts
similarity index 58%
rename from libraries/sts-common-util/sts-sdk/example/submission/ndkTest/build.gradle.kts
rename to libraries/sts-common-util/autorepro/example/submission/ndkTest/build.gradle.kts
index c4cc6fb0b..60ddb7a5f 100644
--- a/libraries/sts-common-util/sts-sdk/example/submission/ndkTest/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/example/submission/ndkTest/build.gradle.kts
@@ -1,6 +1,5 @@
 plugins {
-    // my sts sdk plugin
-    id("com.android.sts.ndktest")
+    id("com.android.security.autorepro.ndktest")
 }
 
 nativeTest {
diff --git a/libraries/sts-common-util/sts-sdk/example/submission/ndkTest/src/native-sample.cpp b/libraries/sts-common-util/autorepro/example/submission/ndkTest/src/native-sample.cpp
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/example/submission/ndkTest/src/native-sample.cpp
rename to libraries/sts-common-util/autorepro/example/submission/ndkTest/src/native-sample.cpp
diff --git a/libraries/sts-common-util/sts-sdk/plugin/.gitignore b/libraries/sts-common-util/autorepro/plugin/.gitignore
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/plugin/.gitignore
rename to libraries/sts-common-util/autorepro/plugin/.gitignore
diff --git a/libraries/sts-common-util/sts-sdk/plugin/Android.bp b/libraries/sts-common-util/autorepro/plugin/Android.bp
similarity index 74%
rename from libraries/sts-common-util/sts-sdk/plugin/Android.bp
rename to libraries/sts-common-util/autorepro/plugin/Android.bp
index 2d1d3c734..7d64ac5ba 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/Android.bp
+++ b/libraries/sts-common-util/autorepro/plugin/Android.bp
@@ -17,7 +17,7 @@ package {
 }
 
 filegroup {
-    name: "sts-sdk-skel-srcs",
+    name: "autorepro-skel-srcs",
     srcs: [
         "**/*",
     ],
@@ -28,11 +28,11 @@ filegroup {
 }
 
 genrule {
-    name: "sts-sdk-plugin-skel.zip-gen",
+    name: "autorepro-plugin-skel.zip-gen",
     srcs: [
-        ":sts-sdk-skel-srcs",
+        ":autorepro-skel-srcs",
     ],
-    out: ["sts-sdk-plugin-skel.zip"],
+    out: ["autorepro-plugin-skel.zip"],
     tools: [
         "soong_zip",
     ],
@@ -40,13 +40,13 @@ genrule {
         platform_sdk_version: {
             cmd: "files=($(in)) " +
                 "&& mkdir -p $(genDir)/tmp/ " +
-                "&& echo $(in) > $(genDir)/tmp/sts-sdk-plugin-skel.zip.list " +
-                "&& $(location soong_zip) -o $(out) -C $$(dirname $${files[0]}) -l $(genDir)/tmp/sts-sdk-plugin-skel.zip.list",
+                "&& echo $(in) > $(genDir)/tmp/autorepro-plugin-skel.zip.list " +
+                "&& $(location soong_zip) -o $(out) -C $$(dirname $${files[0]}) -l $(genDir)/tmp/autorepro-plugin-skel.zip.list",
         },
     },
 }
 
 prebuilt_etc {
-    name: "sts-sdk-plugin-skel.zip",
-    src: ":sts-sdk-plugin-skel.zip-gen",
+    name: "autorepro-plugin-skel.zip",
+    src: ":autorepro-plugin-skel.zip-gen",
 }
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/build.gradle.kts b/libraries/sts-common-util/autorepro/plugin/autorepro/build.gradle.kts
similarity index 50%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/build.gradle.kts
rename to libraries/sts-common-util/autorepro/plugin/autorepro/build.gradle.kts
index 9ff831956..c78a169b6 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/build.gradle.kts
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/build.gradle.kts
@@ -47,32 +47,61 @@ java {
 }
 
 // Define the overall plugin
-group = "com.android.sts"
+group = "com.android.security.autorepro"
 
-version = "1.0.0"
+version = "1.0.0-alpha1"
 
 // Define the individual sub-plugins
 gradlePlugin {
     plugins {
-        create("stsSdkBasePlugin") {
-            id = "com.android.sts.base"
-            implementationClass = "com.android.sts.StsSdkBasePlugin"
+        create("submissionPlugin") {
+            id = "com.android.security.autorepro.submission"
+            implementationClass = "com.android.security.autorepro.SubmissionPlugin"
         }
-        create("stsSdkSubmissionPlugin") {
-            id = "com.android.sts.sdksubmission"
-            implementationClass = "com.android.sts.StsSdkSubmissionPlugin"
+        create("javaHostTestPlugin") {
+            id = "com.android.security.autorepro.javahosttest"
+            implementationClass = "com.android.security.autorepro.JavaHostTestPlugin"
         }
-        create("StsSdkJavaHostTestPlugin") {
-            id = "com.android.sts.javahosttest"
-            implementationClass = "com.android.sts.StsSdkJavaHostTestPlugin"
+        create("appTestPlugin") {
+            id = "com.android.security.autorepro.apptest"
+            implementationClass = "com.android.security.autorepro.AppTestPlugin"
         }
-        create("StsSdkAppTestPlugin") {
-            id = "com.android.sts.apptest"
-            implementationClass = "com.android.sts.StsSdkAppTestPlugin"
+        create("ndkTestPlugin") {
+            id = "com.android.security.autorepro.ndktest"
+            implementationClass = "com.android.security.autorepro.NdkTestPlugin"
         }
-        create("StsSdkNdkTestPlugin") {
-            id = "com.android.sts.ndktest"
-            implementationClass = "com.android.sts.StsSdkNdkTestPlugin"
+    }
+}
+
+publishing.publications.withType<MavenPublication>().configureEach {
+    pom {
+        licenses {
+            license {
+                name = "The Apache Software License, Version 2.0"
+                url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
+                distribution = "repo"
+            }
+        }
+        developers {
+            developer {
+                name = "The Android Open Source Project"
+            }
+        }
+    }
+}
+
+publishing {
+    publications {
+        create<MavenPublication>("pluginMaven") {
+            pom {
+                name = "AutoRepro"
+                description = "Gradle plugin to develop Android VRP reports as Tradefed tests."
+            }
+        }
+    }
+    repositories {
+        maven {
+            url = uri(layout.buildDirectory.dir("maven-repo"))
         }
     }
 }
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkAppTestPlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
similarity index 87%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkAppTestPlugin.kt
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
index 9cfc5f22b..8d67dd3ac 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkAppTestPlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/AppTestPlugin.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.sts
+package com.android.security.autorepro
 
 import com.android.build.api.artifact.SingleArtifact
 import com.android.build.api.variant.ApplicationAndroidComponentsExtension
@@ -38,27 +38,20 @@ open class AppTestExtension {
     var compileSdk: Int = 34 // compile = target
 }
 
-class StsSdkAppTestPlugin : Plugin<Project> {
+class AppTestPlugin : Plugin<Project> {
     override fun apply(project: Project) {
-        val namespace = "android.security.sts"
+        val namespace = "com.android.security"
         val appTest = project.extensions.create("appTest", AppTestExtension::class.java)
 
-        // The APK artifact will be published to the "stsSdkTestResource" configuration
-        project.plugins.apply("com.android.sts.base")
-
         val writeManifestTask =
             project.tasks.register("writeManifestTask") { task ->
                 task.outputs.file(
-                    project.layout.buildDirectory.file("sts-sdk/sts-sdk-manifest.json")
+                    project.layout.buildDirectory.file("autorepro/autorepro-manifest.json")
                 )
                 task.doLast {
                     val writer = BufferedWriter(task.outputs.files.singleFile.writer())
                     val moduleManifest =
-                        StsSdkBasePlugin.ModuleManifest<AppTestExtension>(
-                            project,
-                            "AppTest",
-                            appTest
-                        )
+                        PluginBase.ModuleManifest<AppTestExtension>(project, "AppTest", appTest)
                     writer.use { out -> out.write(Gson().toJson(moduleManifest)) }
                 }
             }
@@ -78,7 +71,7 @@ class StsSdkAppTestPlugin : Plugin<Project> {
             // Because every module must be unique, append a placeholder to find/replace on import.
             // https://source.android.com/docs/setup/reference/androidbp
             // "every module must have a name property, and the value must be unique"
-            val rename = project.name + "_StsSdkPlaceholder"
+            val rename = project.name + "_AutoReproPlaceholder"
 
             // Copy our restricted-scope AppTestExtension into the normal Android extension
             // BaseAppModuleExtension is internal to the AGP, but is widely used by similar
@@ -105,7 +98,7 @@ class StsSdkAppTestPlugin : Plugin<Project> {
                     "androidx.test.ext:junit:1.1.5",
                     "androidx.test.espresso:espresso-core:3.5.1",
                     "androidx.test.uiautomator:uiautomator:2.3.0",
-                    "org.jetbrains.kotlin:kotlin-stdlib:1.8.22"
+                    "org.jetbrains.kotlin:kotlin-stdlib:1.8.22",
                 )
                 .forEach { dependencyString ->
                     implementationConfiguration.dependencies.add(
@@ -114,7 +107,7 @@ class StsSdkAppTestPlugin : Plugin<Project> {
                 }
 
             // Register callbacks for "onVariants" so that we can attach the APK to the
-            // stsSdkTestResource configuration.
+            // testResource configuration.
             // This is the technique used by the "gradle-play-publisher" plugin
             // https://developer.android.com/reference/tools/gradle-api/8.3/com/android/build/api/variant/AndroidComponentsExtension
             // The order of this task is sensitive because the callbacks must be registered before
@@ -136,7 +129,7 @@ class StsSdkAppTestPlugin : Plugin<Project> {
                     val copyAppTestcaseResourceTask =
                         project.tasks.register<Copy>(
                             "copyAppTestcaseResource-$variantName",
-                            Copy::class.java
+                            Copy::class.java,
                         ) { task ->
                             task.from(apkDir) {
                                 // Rename to expected Soong module name
@@ -144,18 +137,18 @@ class StsSdkAppTestPlugin : Plugin<Project> {
                                 // Only include apks (glob, not regex)
                                 it.include("*.apk")
                             }
-                            task.into(project.layout.buildDirectory.dir("sts-sdk/testcases/"))
+                            task.into(project.layout.buildDirectory.dir("autorepro/testcases/"))
                         }
 
                     val copyAppTestcaseResourceTasks =
-                        StsSdkBasePlugin.Abi.entries.map { abi ->
-                            Pair(abi, copyAppTestcaseResourceTask)
-                        }
-                    StsSdkBasePlugin.applyConfiguration(
+                        PluginBase.Abi.entries.map { abi -> Pair(abi, copyAppTestcaseResourceTask) }
+
+                    // The APK artifact will be published to the "testResource" configuration.
+                    PluginBase.applyConfiguration(
                         project = project,
                         sourceDirectoryArtifact = project.layout.projectDirectory.dir("src/main"),
                         manifestArtifact = writeManifestTask,
-                        resourceArtifacts = copyAppTestcaseResourceTasks
+                        resourceArtifacts = copyAppTestcaseResourceTasks,
                     )
                 }
             }
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkJavaHostTestPlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/JavaHostTestPlugin.kt
similarity index 89%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkJavaHostTestPlugin.kt
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/JavaHostTestPlugin.kt
index 40c3f52f4..c04b750f1 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkJavaHostTestPlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/JavaHostTestPlugin.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.sts
+package com.android.security.autorepro
 
 import com.google.gson.Gson
 import java.io.BufferedWriter
@@ -24,7 +24,7 @@ import org.gradle.api.Project
 import org.gradle.api.tasks.Copy
 import org.gradle.api.tasks.SourceSetContainer
 
-class StsSdkJavaHostTestPlugin : Plugin<Project> {
+class JavaHostTestPlugin : Plugin<Project> {
     override fun apply(project: Project) {
         val pluginJarUrl = this.javaClass.getProtectionDomain().getCodeSource().getLocation()
 
@@ -49,13 +49,13 @@ class StsSdkJavaHostTestPlugin : Plugin<Project> {
         val writeManifestTask =
             project.tasks.register("writeManifestTask") { task ->
                 task.outputs.file(
-                    project.layout.buildDirectory.file("sts-sdk/sts-sdk-manifest.json")
+                    project.layout.buildDirectory.file("autorepro/autorepro-manifest.json")
                 )
                 task.doLast {
                     val writer = BufferedWriter(task.outputs.files.singleFile.writer())
                     // Note: this module has no extension so using Kotlin Unit as void/null
                     val moduleManifest =
-                        StsSdkBasePlugin.ModuleManifest<Unit>(project, "JavaHostTest", Unit)
+                        PluginBase.ModuleManifest<Unit>(project, "JavaHostTest", Unit)
                     writer.use { out -> out.write(Gson().toJson(moduleManifest)) }
                 }
             }
@@ -72,14 +72,14 @@ class StsSdkJavaHostTestPlugin : Plugin<Project> {
                 task.into(project.layout.buildDirectory.dir("android-sts/testcases"))
             }
         val copyTestcasesResourcesTasks =
-            StsSdkBasePlugin.Abi.entries.map { abi -> Pair(abi, copyTestcasesResourcesTask) }
+            PluginBase.Abi.entries.map { abi -> Pair(abi, copyTestcasesResourcesTask) }
 
-        project.plugins.apply("com.android.sts.base")
-        StsSdkBasePlugin.applyConfiguration(
+        // The artifact will be published to the "testResource" configuration.
+        PluginBase.applyConfiguration(
             project = project,
             sourceDirectoryArtifact = project.layout.projectDirectory.dir("src/main"),
             manifestArtifact = writeManifestTask,
-            resourceArtifacts = copyTestcasesResourcesTasks
+            resourceArtifacts = copyTestcasesResourcesTasks,
         )
 
         val verifyPackageNamesTask =
@@ -87,7 +87,7 @@ class StsSdkJavaHostTestPlugin : Plugin<Project> {
                 task.doLast {
                     val sourceSets = project.extensions.getByType(SourceSetContainer::class.java)
                     sourceSets.getByName("main").java.forEach { file ->
-                        val expectedPackagePrefix = "android.security.sts.sts_sdk_placeholder"
+                        val expectedPackagePrefix = "com.android.security.autorepro_placeholder"
                         val fileText = file.readText()
                         // Extract the package from the Java file
                         val packageRegex = """^package\s+(?<package>[\w.]+);?$"""
@@ -115,7 +115,7 @@ class StsSdkJavaHostTestPlugin : Plugin<Project> {
                 task.doLast {
                     val sourceSets = project.extensions.getByType(SourceSetContainer::class.java)
                     val resourcesSourceSet = sourceSets.getByName("main").resources
-                    val expectedResourceDirectory = "StsSdkPlaceholder"
+                    val expectedResourceDirectory = "AutoReproPlaceholder"
 
                     val invalidPrefixResourceIterator =
                         resourcesSourceSet.asFileTree
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkNdkTestPlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/NdkTestPlugin.kt
similarity index 86%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkNdkTestPlugin.kt
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/NdkTestPlugin.kt
index e17185b13..9e0b4759c 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkNdkTestPlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/NdkTestPlugin.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.sts
+package com.android.security.autorepro
 
 import com.android.build.api.artifact.SingleArtifact
 import com.android.build.api.variant.LibraryAndroidComponentsExtension
@@ -32,36 +32,31 @@ open class NdkTestExtension {
     var compileSdk: Int = 34 // compile = target
 }
 
-class StsSdkNdkTestPlugin : Plugin<Project> {
+class NdkTestPlugin : Plugin<Project> {
     override fun apply(project: Project) {
         val nativeTest = project.extensions.create("nativeTest", NdkTestExtension::class.java)
 
-        project.plugins.apply("com.android.sts.base")
         val ndkTest = project.extensions.create("appTest", NdkTestExtension::class.java)
 
         val writeManifestTask =
             project.tasks.register("writeManifestTask") { task ->
                 task.outputs.file(
-                    project.layout.buildDirectory.file("sts-sdk/sts-sdk-manifest.json")
+                    project.layout.buildDirectory.file("autorepro/autorepro-manifest.json")
                 )
                 task.doLast {
                     val writer = BufferedWriter(task.outputs.files.singleFile.writer())
                     val moduleManifest =
-                        StsSdkBasePlugin.ModuleManifest<NdkTestExtension>(
-                            project,
-                            "NdkTest",
-                            ndkTest
-                        )
+                        PluginBase.ModuleManifest<NdkTestExtension>(project, "NdkTest", ndkTest)
                     writer.use { out -> out.write(Gson().toJson(moduleManifest)) }
                 }
             }
 
         project.afterEvaluate {
-            val rename = project.name + "_StsSdkPlaceholder"
+            val rename = project.name + "_AutoReproPlaceholder"
 
             project.plugins.apply("com.android.library")
             project.extensions.configure<LibraryExtension>("android") {
-                it.namespace = "com.android.sts"
+                it.namespace = "com.android.security.autorepro"
                 it.compileSdk = nativeTest.compileSdk
                 it.externalNativeBuild.cmake.path = File("CMakeLists.txt")
                 // externalNativeBuild.cmake.version will be automatically set
@@ -83,14 +78,14 @@ class StsSdkNdkTestPlugin : Plugin<Project> {
                 if (variantName == "debug") {
                     val aarDir = variant.artifacts.get(SingleArtifact.AAR)
                     val copyNdkTestcaseResourceTasks =
-                        StsSdkBasePlugin.Abi.entries.map { abi ->
+                        PluginBase.Abi.entries.map { abi ->
                             val abiName = abi.attr.name
                             val aarPrefabPath =
                                 "prefab/modules/$projectName/libs/android.$abiName/$projectName"
                             val copyNdkTestcaseResourceTask =
                                 project.tasks.register<Copy>(
                                     "copyNdkTestcaseResource-$variantName-$abiName",
-                                    Copy::class.java
+                                    Copy::class.java,
                                 ) { task ->
                                     task.from(project.zipTree(aarDir)) { copySpec ->
                                         copySpec.include(aarPrefabPath)
@@ -100,24 +95,26 @@ class StsSdkNdkTestPlugin : Plugin<Project> {
                                             fileCopyDetails.relativePath =
                                                 RelativePath(
                                                     true /* endsWithFile */,
-                                                    fileCopyDetails.relativePath.lastName
+                                                    fileCopyDetails.relativePath.lastName,
                                                 )
                                         }
                                         copySpec.includeEmptyDirs = false
                                     }
                                     task.into(
                                         project.layout.buildDirectory.dir(
-                                            "sts-sdk/resources/$abiName"
+                                            "autorepro/resources/$abiName"
                                         )
                                     )
                                 }
                             Pair(abi, copyNdkTestcaseResourceTask)
                         }
-                    StsSdkBasePlugin.applyConfiguration(
+
+                    // The artifact will be published to the "testResource" configuration.
+                    PluginBase.applyConfiguration(
                         project = project,
                         sourceDirectoryArtifact = project.layout.projectDirectory.dir("src"),
                         manifestArtifact = writeManifestTask,
-                        resourceArtifacts = copyNdkTestcaseResourceTasks
+                        resourceArtifacts = copyNdkTestcaseResourceTasks,
                     )
                 }
             }
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkBasePlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/PluginBase.kt
similarity index 71%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkBasePlugin.kt
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/PluginBase.kt
index 7d5935e10..00cbaf982 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkBasePlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/PluginBase.kt
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.sts
+package com.android.security.autorepro
 
-import org.gradle.api.Plugin
 import org.gradle.api.Project
 import org.gradle.api.attributes.Attribute
 
-class StsSdkBasePlugin : Plugin<Project> {
+class PluginBase {
     class AbiAttributes(name: String, bitness: Int) {
         val name = name
         val bitness = bitness
@@ -34,7 +33,7 @@ class StsSdkBasePlugin : Plugin<Project> {
     }
 
     companion object {
-        val STS_SDK_TESTCASES_RESOURCE_CONFIGURATION_NAME = "stsSdkTestResource"
+        val AUTOREPRO_TESTCASES_RESOURCE_CONFIGURATION_NAME = "testResource"
 
         fun applyConfiguration(
             project: Project,
@@ -42,10 +41,20 @@ class StsSdkBasePlugin : Plugin<Project> {
             manifestArtifact: Any,
             resourceArtifacts: List<Pair<Abi, Any>>,
         ) {
-            val stsSdkTestResourceConfiguration =
-                project.configurations.getByName(STS_SDK_TESTCASES_RESOURCE_CONFIGURATION_NAME)
-            val abiAttribute = Attribute.of("com.android.sts.abi", Abi::class.java)
-            stsSdkTestResourceConfiguration.outgoing { configurationPublications ->
+            // Export a configuration for users to add dependencies.
+            // "testResource" represents Soong modules for the Tradefed testcases/ directory.
+            // See "android_test_helper_app" and "cc_test" Soong modules.
+            // Dependencies should map 1:1 to tradefed Android.bp files for easy reconstruction.
+            project.configurations.create(AUTOREPRO_TESTCASES_RESOURCE_CONFIGURATION_NAME) {
+                configuration ->
+                configuration.isCanBeConsumed = true
+                configuration.isCanBeResolved = false
+            }
+
+            val testResourceConfiguration =
+                project.configurations.getByName(AUTOREPRO_TESTCASES_RESOURCE_CONFIGURATION_NAME)
+            val abiAttribute = Attribute.of("com.android.security.autorepro.abi", Abi::class.java)
+            testResourceConfiguration.outgoing { configurationPublications ->
                 configurationPublications.artifact(sourceDirectoryArtifact) {
                     configurePublishArtifact ->
                     configurePublishArtifact.setType("source")
@@ -71,18 +80,6 @@ class StsSdkBasePlugin : Plugin<Project> {
         }
     }
 
-    override fun apply(project: Project) {
-        // Export a configuration for users to add dependencies.
-        // "stsSdkTestResource" represents Soong modules for the Tradefed testcases/ directory.
-        // See "android_test_helper_app" and "cc_test" Soong modules.
-        // Dependencies should map 1:1 to tradefed Android.bp files for easy reconstruction.
-        project.configurations.create(STS_SDK_TESTCASES_RESOURCE_CONFIGURATION_NAME) { configuration
-            ->
-            configuration.isCanBeConsumed = true
-            configuration.isCanBeResolved = false
-        }
-    }
-
     class ModuleManifest<T>(project: Project, type: String, resource: T) {
         val name: String = project.name
         val type: String = type
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkSubmissionPlugin.kt b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/SubmissionPlugin.kt
similarity index 80%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkSubmissionPlugin.kt
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/SubmissionPlugin.kt
index dbcabfab2..5faffd1fe 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/kotlin/com/android/sts/StsSdkSubmissionPlugin.kt
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/kotlin/com/android/security/autorepro/SubmissionPlugin.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.sts
+package com.android.security.autorepro
 
 import com.google.gson.Gson
 import com.google.gson.GsonBuilder
@@ -31,23 +31,24 @@ import org.gradle.api.file.RelativePath
 import org.gradle.api.tasks.Copy
 import org.gradle.api.tasks.bundling.Zip
 
-open class StsSdkSubmissionExtension {
+open class SubmissionExtension {
     var deviceType: String? = null // phone, tv, wear, etc. enum?
     var isRootRequired: Boolean = false
     var isExternalHardwareRequired: Boolean = false // string?
     var isPersistentExploit: Boolean = false
 }
 
-class StsSdkSubmissionPlugin : Plugin<Project> {
-    val taskGroup = "STS SDK"
-    val stsSdkSubmissionSourcesDir = "sts-sdk-submission"
-    val stsSdkTradefedDir = "android-sts"
+class SubmissionPlugin : Plugin<Project> {
+    val taskGroup = "AutoRepro"
+    val submissionSourcesDir = "autorepro-submission"
+    val stsTradefedDir = "android-sts"
 
     // get plugin jar path from current class; plugin jar has resources
     val pluginJarUrl = this.javaClass.getProtectionDomain().getCodeSource().getLocation()
 
-    val abiAttribute = Attribute.of("com.android.sts.abi", StsSdkBasePlugin.Abi::class.java)
-    var stsSdkTestResourceConfiguration: Configuration? = null
+    val abiAttribute =
+        Attribute.of("com.android.security.autorepro.abi", PluginBase.Abi::class.java)
+    var testResourceConfiguration: Configuration? = null
 
     fun dependencyProjectConfiguration(
         project: Project,
@@ -76,14 +77,14 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
         }
     }
 
-    fun registerAssembleStsSdkTradefedTask(
+    fun registerAssembleAutoReproTradefedTask(
         project: Project,
         target: String,
-        abis: Set<StsSdkBasePlugin.Abi>,
+        abis: Set<PluginBase.Abi>,
     ) {
-        val copyStsSdkTradefedToolsTask =
-            project.tasks.register<Copy>("copyStsSdkTradefedTools-$target", Copy::class.java) { task
-                ->
+        val copyAutoReproTradefedToolsTask =
+            project.tasks.register<Copy>("copyAutoReproTradefedTools-$target", Copy::class.java) {
+                task ->
                 // use ziptree to copy the zip contents instead of the jar itself
                 task.from(project.zipTree(pluginJarUrl)) { copySpec ->
                     // only include the "sts-tradefed-tools" path instead of all jar contents
@@ -93,34 +94,31 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                         fileCopyDetails.relativePath =
                             RelativePath(
                                 true /* endsWithFile */,
-                                *fileCopyDetails.relativePath.segments.drop(1).toTypedArray()
+                                *fileCopyDetails.relativePath.segments.drop(1).toTypedArray(),
                             )
                     }
                     // don't include the "sts-tradefed-tools" dir itself
                     copySpec.includeEmptyDirs = false
                 }
-                task.into(project.layout.buildDirectory.dir("$target/$stsSdkTradefedDir/tools"))
+                task.into(project.layout.buildDirectory.dir("$target/$stsTradefedDir/tools"))
             }
 
         val copyTradefedJdkTask =
             project.tasks.register<Copy>("copyTradefedJdk-$target", Copy::class.java) { task ->
                 task.from(project.zipTree(pluginJarUrl)) { copySpec -> copySpec.include("jdk/**") }
-                task.into(project.layout.buildDirectory.dir("$target/$stsSdkTradefedDir"))
+                task.into(project.layout.buildDirectory.dir("$target/$stsTradefedDir"))
             }
 
-        val assembleStsSdkTradefedTask =
-            project.tasks.register("assembleStsSdkTradefed-$target") { task ->
+        val assembleAutoReproTradefedTask =
+            project.tasks.register("assembleAutoReproTradefed-$target") { task ->
                 task.description =
-                    "Assemble the STS SDK Tradefed executable test suite for $target."
+                    "Assemble the AutoRepro Tradefed executable test suite for $target."
                 task.group = taskGroup
-                task.dependsOn(
-                    copyStsSdkTradefedToolsTask,
-                    copyTradefedJdkTask,
-                )
+                task.dependsOn(copyAutoReproTradefedToolsTask, copyTradefedJdkTask)
             }
 
         abis.forEach { abi ->
-            dependencyProjectConfiguration(project, stsSdkTestResourceConfiguration!!) {
+            dependencyProjectConfiguration(project, testResourceConfiguration!!) {
                 dependencyProjectConfigurationPair ->
                 val (dependencyProject, dependencyConfiguration) =
                     dependencyProjectConfigurationPair
@@ -143,7 +141,7 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                                         val copyTestcaseResourceTask =
                                             project.tasks.register<Copy>(
                                                 copyTestcaseResourceTaskName,
-                                                Copy::class.java
+                                                Copy::class.java,
                                             ) { task ->
                                                 // Don't copy until entire task done
                                                 task.dependsOn(publishArtifact)
@@ -153,11 +151,11 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                                                 task.from(publishArtifact.file)
                                                 task.into(
                                                     project.layout.buildDirectory.dir(
-                                                        "$target/$stsSdkTradefedDir/testcases"
+                                                        "$target/$stsTradefedDir/testcases"
                                                     )
                                                 )
                                             }
-                                        assembleStsSdkTradefedTask.configure { task ->
+                                        assembleAutoReproTradefedTask.configure { task ->
                                             task.dependsOn(copyTestcaseResourceTask)
                                         }
                                     }
@@ -167,18 +165,18 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
             }
         }
 
-        // Build STS SDK Tradefed tasks on assemble
+        // Build AutoRepro Tradefed tasks on assemble
         project.tasks.named("assemble").configure { task ->
-            task.dependsOn(assembleStsSdkTradefedTask)
+            task.dependsOn(assembleAutoReproTradefedTask)
         }
     }
 
     override fun apply(project: Project) {
-        val stsSdkSubmissionExtension =
-            project.extensions.create("stsSdkSubmission", StsSdkSubmissionExtension::class.java)
+        val submissionExtension =
+            project.extensions.create("submission", SubmissionExtension::class.java)
 
-        stsSdkTestResourceConfiguration =
-            project.configurations.create("stsSdkTestResource") { configuration ->
+        testResourceConfiguration =
+            project.configurations.create("testResource") { configuration ->
                 configuration.isCanBeConsumed = false
                 configuration.isCanBeResolved = true
             }
@@ -191,8 +189,7 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
         val mergeManifestsTask =
             project.tasks.register("mergeManifests") { task ->
                 task.outputs.file(
-                    // project.layout.buildDirectory.file("sts-sdk-submission/manifest.json")
-                    project.layout.buildDirectory.dir("$stsSdkSubmissionSourcesDir/manifest.json")
+                    project.layout.buildDirectory.dir("$submissionSourcesDir/manifest.json")
                 )
                 task.doLast {
                     val submissionJson = JsonObject()
@@ -202,7 +199,7 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                         resources.add(JsonParser.parseString(resourcesJsonString))
                     }
                     submissionJson.add("resources", resources)
-                    submissionJson.add("submission", Gson().toJsonTree(stsSdkSubmissionExtension))
+                    submissionJson.add("submission", Gson().toJsonTree(submissionExtension))
                     val gson = GsonBuilder().setPrettyPrinting().create()
                     val jsonOutput = gson.toJson(submissionJson)
                     task.outputs.files.singleFile.writeText(jsonOutput)
@@ -239,24 +236,24 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                     // Ignore native build directories
                     copySpec.exclude("**/.cxx")
                 }
-                task.into(project.layout.buildDirectory.dir("$stsSdkSubmissionSourcesDir/project"))
+                task.into(project.layout.buildDirectory.dir("$submissionSourcesDir/project"))
             }
 
-        val assembleStsSdkSubmissionSourcesTask =
-            project.tasks.register("assembleStsSdkSubmissionSources") { task ->
+        val assembleSubmissionSourcesTask =
+            project.tasks.register("assembleSubmissionSources") { task ->
                 task.description = "Assemble the source files for the submission zip."
                 task.group = taskGroup
                 task.dependsOn(mergeManifestsTask)
                 task.dependsOn(copyRootProjectTask)
-                task.outputs.file(project.layout.buildDirectory.dir(stsSdkSubmissionSourcesDir))
+                task.outputs.file(project.layout.buildDirectory.dir(submissionSourcesDir))
             }
 
-        val assembleStsSdkSubmissionZipTask =
-            project.tasks.register<Zip>("assembleStsSdkSubmissionZip", Zip::class.java) { task ->
+        val assembleSubmissionZipTask =
+            project.tasks.register<Zip>("assembleSubmissionZip", Zip::class.java) { task ->
                 task.description = "Assemble the submission zip for upload."
                 task.group = taskGroup
-                task.from(assembleStsSdkSubmissionSourcesTask)
-                task.archiveFileName.set("sts-sdk-submission.zip")
+                task.from(assembleSubmissionSourcesTask)
+                task.archiveFileName.set("autorepro-submission.zip")
                 task.destinationDirectory.set(project.layout.buildDirectory)
             }
 
@@ -264,13 +261,12 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
         val targetToMultiAbiSets =
             mapOf(
                 "test_suites_arm64" to
-                    setOf(StsSdkBasePlugin.Abi.ABI_ARMEABI_V7A, StsSdkBasePlugin.Abi.ABI_ARM64_V8A),
-                "test_suites_x86_64" to
-                    setOf(StsSdkBasePlugin.Abi.ABI_X86, StsSdkBasePlugin.Abi.ABI_X86_64),
+                    setOf(PluginBase.Abi.ABI_ARMEABI_V7A, PluginBase.Abi.ABI_ARM64_V8A),
+                "test_suites_x86_64" to setOf(PluginBase.Abi.ABI_X86, PluginBase.Abi.ABI_X86_64),
             )
         targetToMultiAbiSets.entries.forEach { mapEntry ->
             val (target, abis) = mapEntry
-            registerAssembleStsSdkTradefedTask(project, target, abis)
+            registerAssembleAutoReproTradefedTask(project, target, abis)
         }
 
         // By default, Gradle considers "evaluation" of the "configure" lifecycle to be done before
@@ -284,13 +280,11 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
         // Need to perform this work in the "afterEvaluate" callback because the extensions,
         // dependencies, and dependency artifacts are not initialized yet.
         project.afterEvaluate {
-            stsSdkTestResourceConfiguration!!.dependencies.forEach { dependency ->
+            testResourceConfiguration!!.dependencies.forEach { dependency ->
                 if (dependency is ProjectDependency) {
                     val dependencyProject = dependency.dependencyProject
                     val configuration =
-                        dependencyProject.configurations.getByName(
-                            stsSdkTestResourceConfiguration!!.name
-                        )
+                        dependencyProject.configurations.getByName(testResourceConfiguration!!.name)
                     val projectName = dependencyProject.name
 
                     configuration.artifacts.forEach { publishArtifact ->
@@ -302,22 +296,22 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
                                 }
                             }
                             "source" -> {
-                                val copyStsSdkTestcaseResourceSourceTask =
+                                val copyAutoReproTestcaseResourceSourceTask =
                                     project.tasks.register<Copy>(
-                                        "copyStsSdkTestcaseResourceSource-$projectName",
-                                        Copy::class.java
+                                        "copyAutoReproTestcaseResourceSource-$projectName",
+                                        Copy::class.java,
                                     ) { task ->
                                         // TODO: https://github.com/gradle/gradle/issues/25587 - use
                                         // publishArtifact directly
                                         task.from(publishArtifact.file)
                                         task.into(
                                             project.layout.buildDirectory.dir(
-                                                "$stsSdkSubmissionSourcesDir/source/$projectName/"
+                                                "$submissionSourcesDir/source/$projectName/"
                                             )
                                         )
                                     }
-                                assembleStsSdkSubmissionSourcesTask.configure { task ->
-                                    task.dependsOn(copyStsSdkTestcaseResourceSourceTask)
+                                assembleSubmissionSourcesTask.configure { task ->
+                                    task.dependsOn(copyAutoReproTestcaseResourceSourceTask)
                                 }
                             }
                             else -> {
@@ -336,7 +330,7 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
         val copyInvocationResultsResultsToSubmissionTask =
             project.tasks.register("copyInvocationResultsToSubmission") { task ->
                 task.description =
-                    "Copy the results from previous Tradefed invocations into the STS SDK " +
+                    "Copy the results from previous Tradefed invocations into the AutoRepro " +
                         "submission sources directory to assist with the review process. Note " +
                         "that this contains logs from both the host and device; please review " +
                         "the contents before or after running this."
@@ -347,15 +341,15 @@ class StsSdkSubmissionPlugin : Plugin<Project> {
             val targetTask =
                 project.tasks.register<Copy>(
                     "copyInvocationResultsToSubmission-$target",
-                    Copy::class.java
+                    Copy::class.java,
                 ) { task ->
-                    task.dependsOn(assembleStsSdkSubmissionZipTask)
-                    task.from(project.layout.buildDirectory.dir("$target/$stsSdkTradefedDir")) {
+                    task.dependsOn(assembleSubmissionZipTask)
+                    task.from(project.layout.buildDirectory.dir("$target/$stsTradefedDir")) {
                         copySpec ->
                         copySpec.include("logs/**")
                         copySpec.include("results/**")
                     }
-                    task.into(project.layout.buildDirectory.dir(stsSdkSubmissionSourcesDir))
+                    task.into(project.layout.buildDirectory.dir(submissionSourcesDir))
                 }
             copyInvocationResultsResultsToSubmissionTask.configure { task ->
                 task.dependsOn(targetTask)
diff --git a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/resources/HostsideTest.config b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/resources/HostsideTest.config
similarity index 76%
rename from libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/resources/HostsideTest.config
rename to libraries/sts-common-util/autorepro/plugin/autorepro/src/main/resources/HostsideTest.config
index ed95e86b9..17c34ad75 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/sts-sdk/src/main/resources/HostsideTest.config
+++ b/libraries/sts-common-util/autorepro/plugin/autorepro/src/main/resources/HostsideTest.config
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 
-<configuration description="Runs host-side STS tests">
+<configuration description="Runs host-side tests">
     <test class="com.android.tradefed.testtype.HostTest" >
         <option name="jar" value="HostsideTest.jar" />
     </test>
diff --git a/libraries/sts-common-util/sts-sdk/plugin/extract-and-gradle.sh b/libraries/sts-common-util/autorepro/plugin/extract-and-gradle.sh
similarity index 56%
rename from libraries/sts-common-util/sts-sdk/plugin/extract-and-gradle.sh
rename to libraries/sts-common-util/autorepro/plugin/extract-and-gradle.sh
index 6e2743b34..618625a21 100755
--- a/libraries/sts-common-util/sts-sdk/plugin/extract-and-gradle.sh
+++ b/libraries/sts-common-util/autorepro/plugin/extract-and-gradle.sh
@@ -1,18 +1,18 @@
 #!/bin/bash
 
-# Because the build environment is not passed to this script, please `m sts-sdk`.
+# Because the build environment is not passed to this script, please `m autorepro`.
 
 # usage:
-# $ m sts-sdk && ./extract-and-gradle.sh *commands*
+# $ m autorepro && ./extract-and-gradle.sh *commands*
 
 # publish to local; useful for testing examples:
-# $ m sts-sdk && ./extract-and-gradle.sh publishToMavenLocal
+# $ m autorepro && ./extract-and-gradle.sh publishToMavenLocal
 
 # build only:
-# $ m sts-sdk && ./extract-and-gradle.sh assemble
+# $ m autorepro && ./extract-and-gradle.sh assemble
 
 # build and test:
-# $ m sts-sdk && ./extract-and-gradle.sh build
+# $ m autorepro && ./extract-and-gradle.sh build
 
 # Exit on error
 set -e
@@ -22,16 +22,16 @@ if [ -z "${ANDROID_HOST_OUT}" ]; then
   exit 1
 fi
 
-STS_SDK_OUT=/tmp/sts-sdk
+AUTOREPRO_OUT=/tmp/autorepro
 
 # Remove output directory.
 # This breaks incremental compile but in practice the difference is negligible.
-rm -rf $STS_SDK_OUT
+rm -rf $AUTOREPRO_OUT
 
 # -q quiet
 # -o overwrite without prompting
 # -d output directory
-unzip -q -o $ANDROID_HOST_OUT/sts-sdk/sts-sdk.zip -d $STS_SDK_OUT
+unzip -q -o $ANDROID_HOST_OUT/autorepro/autorepro.zip -d $AUTOREPRO_OUT
 
-cd $STS_SDK_OUT
+cd $AUTOREPRO_OUT
 ./gradlew $@
diff --git a/libraries/sts-common-util/sts-sdk/plugin/gradle/libs.versions.toml b/libraries/sts-common-util/autorepro/plugin/gradle/libs.versions.toml
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/plugin/gradle/libs.versions.toml
rename to libraries/sts-common-util/autorepro/plugin/gradle/libs.versions.toml
diff --git a/libraries/sts-common-util/sts-sdk/plugin/gradle/wrapper/gradle-wrapper.jar b/libraries/sts-common-util/autorepro/plugin/gradle/wrapper/gradle-wrapper.jar
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/plugin/gradle/wrapper/gradle-wrapper.jar
rename to libraries/sts-common-util/autorepro/plugin/gradle/wrapper/gradle-wrapper.jar
diff --git a/libraries/sts-common-util/sts-sdk/plugin/gradle/wrapper/gradle-wrapper.properties b/libraries/sts-common-util/autorepro/plugin/gradle/wrapper/gradle-wrapper.properties
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/plugin/gradle/wrapper/gradle-wrapper.properties
rename to libraries/sts-common-util/autorepro/plugin/gradle/wrapper/gradle-wrapper.properties
diff --git a/libraries/sts-common-util/sts-sdk/plugin/gradlew b/libraries/sts-common-util/autorepro/plugin/gradlew
similarity index 100%
rename from libraries/sts-common-util/sts-sdk/plugin/gradlew
rename to libraries/sts-common-util/autorepro/plugin/gradlew
diff --git a/libraries/sts-common-util/sts-sdk/plugin/settings.gradle.kts b/libraries/sts-common-util/autorepro/plugin/settings.gradle.kts
similarity index 94%
rename from libraries/sts-common-util/sts-sdk/plugin/settings.gradle.kts
rename to libraries/sts-common-util/autorepro/plugin/settings.gradle.kts
index 372ae04dd..d195f073b 100644
--- a/libraries/sts-common-util/sts-sdk/plugin/settings.gradle.kts
+++ b/libraries/sts-common-util/autorepro/plugin/settings.gradle.kts
@@ -30,6 +30,6 @@ dependencyResolutionManagement {
     }
 }
 
-rootProject.name = "sts-sdk"
+rootProject.name = "autorepro"
 
-include("sts-sdk")
+include("autorepro")
diff --git a/libraries/sts-common-util/host-side/src/com/android/sts/common/UserUtils.java b/libraries/sts-common-util/host-side/src/com/android/sts/common/UserUtils.java
index fc799d4df..cf35fc0e6 100644
--- a/libraries/sts-common-util/host-side/src/com/android/sts/common/UserUtils.java
+++ b/libraries/sts-common-util/host-side/src/com/android/sts/common/UserUtils.java
@@ -237,7 +237,7 @@ public class UserUtils {
             }
             final String outputStdout = output.getStdout();
             mTestUserId =
-                    Optional.ofNullable(
+                    Optional.of(
                             Integer.parseInt(
                                     outputStdout.substring(outputStdout.lastIndexOf(" ")).trim()));
             AutoCloseable asSecondaryUser =
diff --git a/libraries/sts-common-util/host-side/tests/Android.bp b/libraries/sts-common-util/host-side/tests/Android.bp
index 7d2c3b1cd..890c8d948 100644
--- a/libraries/sts-common-util/host-side/tests/Android.bp
+++ b/libraries/sts-common-util/host-side/tests/Android.bp
@@ -29,6 +29,10 @@ java_test_host {
         "mockito-host",
     ],
 
+    device_common_data: [
+        ":StsCommonUtilDeviceTests",
+    ],
+
     // tag this module as a test artifact
     test_suites: ["general-tests"],
 
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_arm64.run.xml b/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_arm64.run.xml
deleted file mode 100644
index 201d016c7..000000000
--- a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_arm64.run.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="sts-tradefed_linux_nonroot_arm64" type="ShConfigurationType">
-    <option name="SCRIPT_TEXT" value="" />
-    <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
-    <option name="SCRIPT_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed" />
-    <option name="SCRIPT_OPTIONS" value="run commandAndExit sts-sdk-nonroot --log-level debug --log-level-display debug" />
-    <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
-    <option name="SCRIPT_WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-    <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
-    <option name="INTERPRETER_PATH" value="/bin/bash" />
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="EXECUTE_IN_TERMINAL" value="true" />
-    <option name="EXECUTE_SCRIPT_FILE" value="true" />
-    <envs />
-    <method v="2">
-      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleStsSdkTradefed-test_suites_arm64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
-    </method>
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_x86_64.run.xml b/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_x86_64.run.xml
deleted file mode 100644
index ba3116654..000000000
--- a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_nonroot_x86_64.run.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="sts-tradefed_linux_nonroot_x86_64" type="ShConfigurationType">
-    <option name="SCRIPT_TEXT" value="" />
-    <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
-    <option name="SCRIPT_PATH" value="$PROJECT_DIR$/submission/build/test_suites_x86_64/android-sts/tools/sts-tradefed" />
-    <option name="SCRIPT_OPTIONS" value="run commandAndExit sts-sdk-nonroot --log-level debug --log-level-display debug" />
-    <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
-    <option name="SCRIPT_WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-    <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
-    <option name="INTERPRETER_PATH" value="/bin/bash" />
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="EXECUTE_IN_TERMINAL" value="true" />
-    <option name="EXECUTE_SCRIPT_FILE" value="true" />
-    <envs />
-    <method v="2">
-      <option name="Gradle.BeforeRunTask" enabled="false" tasks="assembleStsSdkTradefed-test_suites_x86_64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
-    </method>
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_arm64.run.xml b/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_arm64.run.xml
deleted file mode 100644
index 3b7e6422c..000000000
--- a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_arm64.run.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="sts-tradefed_linux_root_arm64" type="ShConfigurationType">
-    <option name="SCRIPT_TEXT" value="" />
-    <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
-    <option name="SCRIPT_PATH" value="$PROJECT_DIR$/submission/build/test_suites_arm64/android-sts/tools/sts-tradefed" />
-    <option name="SCRIPT_OPTIONS" value="run commandAndExit sts-sdk-root --log-level debug --log-level-display debug" />
-    <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
-    <option name="SCRIPT_WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-    <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
-    <option name="INTERPRETER_PATH" value="/bin/bash" />
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="EXECUTE_IN_TERMINAL" value="true" />
-    <option name="EXECUTE_SCRIPT_FILE" value="true" />
-    <envs />
-    <method v="2">
-      <option name="Gradle.BeforeRunTask" enabled="true" tasks="assembleStsSdkTradefed-test_suites_arm64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
-    </method>
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_x86_64.run.xml b/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_x86_64.run.xml
deleted file mode 100644
index 9c2a0cdc6..000000000
--- a/libraries/sts-common-util/sts-sdk/example/.run/sts-tradefed_linux_root_x86_64.run.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="sts-tradefed_linux_root_x86_64" type="ShConfigurationType">
-    <option name="SCRIPT_TEXT" value="" />
-    <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
-    <option name="SCRIPT_PATH" value="$PROJECT_DIR$/submission/build/test_suites_x86_64/android-sts/tools/sts-tradefed" />
-    <option name="SCRIPT_OPTIONS" value="run commandAndExit sts-sdk-root --log-level debug --log-level-display debug" />
-    <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
-    <option name="SCRIPT_WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-    <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
-    <option name="INTERPRETER_PATH" value="/bin/bash" />
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="EXECUTE_IN_TERMINAL" value="true" />
-    <option name="EXECUTE_SCRIPT_FILE" value="true" />
-    <envs />
-    <method v="2">
-      <option name="Gradle.BeforeRunTask" enabled="true" tasks="assembleStsSdkTradefed-test_suites_x86_64" externalProjectPath="$PROJECT_DIR$/submission" vmOptions="" scriptParameters="" />
-    </method>
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/libraries/sts-common-util/util/src/com/android/sts/common/util/KernelVersion.java b/libraries/sts-common-util/util/src/com/android/sts/common/util/KernelVersion.java
index c9329b969..a9d8b5b8a 100644
--- a/libraries/sts-common-util/util/src/com/android/sts/common/util/KernelVersion.java
+++ b/libraries/sts-common-util/util/src/com/android/sts/common/util/KernelVersion.java
@@ -16,6 +16,8 @@
 
 package com.android.sts.common.util;
 
+import java.lang.Integer;
+import java.util.Optional;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -24,28 +26,39 @@ public final class KernelVersion implements Comparable<KernelVersion> {
     public final int version;
     public final int patchLevel;
     public final int subLevel;
+    public Optional<Integer> osRelease;
 
     public KernelVersion(int version, int patchLevel, int subLevel) {
         this.version = version;
         this.patchLevel = patchLevel;
         this.subLevel = subLevel;
+        this.osRelease = Optional.empty();
+    }
+
+    public KernelVersion(int version, int patchLevel, int subLevel, Optional<Integer> osRelease) {
+        this.version = version;
+        this.patchLevel = patchLevel;
+        this.subLevel = subLevel;
+        this.osRelease = osRelease;
     }
 
     /**
-     * Parse a kernel version string in the format "version.patchlevel.sublevel" - "5.4.123".
-     * Trailing values are ignored so `uname -r` can be parsed properly.
+     * Parse a kernel version string in the format "version.patchlevel.sublevel-androidosRelease" -
+     * "5.4.123-android12". Trailing values are ignored so `uname -r` can be parsed properly.
      *
      * @param versionString The version string to parse
      */
     public static KernelVersion parse(String versionString) {
         Pattern kernelReleasePattern =
-                Pattern.compile("(?<version>\\d+)\\.(?<patchLevel>\\d+)\\.(?<subLevel>\\d+)(.*)");
+                Pattern.compile(
+                        "^(?<version>\\d+)[.](?<patchLevel>\\d+)[.](?<subLevel>\\d+)(-android(?<osRelease>\\d+))?(.*)$");
         Matcher matcher = kernelReleasePattern.matcher(versionString);
         if (matcher.find()) {
             return new KernelVersion(
                     Integer.parseInt(matcher.group("version")),
                     Integer.parseInt(matcher.group("patchLevel")),
-                    Integer.parseInt(matcher.group("subLevel")));
+                    Integer.parseInt(matcher.group("subLevel")),
+                    Optional.ofNullable(matcher.group("osRelease")).map(Integer::parseInt));
         }
         throw new IllegalArgumentException(
                 String.format("Could not parse kernel version string (%s)", versionString));
@@ -54,9 +67,7 @@ public final class KernelVersion implements Comparable<KernelVersion> {
     /** {@inheritDoc} */
     @Override
     public int hashCode() {
-        // 2147483647 (INT_MAX)
-        // vvppppssss
-        return version * 10000000 + patchLevel * 10000 + subLevel;
+        return toStringWithRelease().hashCode();
     }
 
     /** Compare by version, patchlevel, and sublevel in that order. */
@@ -67,7 +78,11 @@ public final class KernelVersion implements Comparable<KernelVersion> {
         if (patchLevel != o.patchLevel) {
             return Integer.compare(patchLevel, o.patchLevel);
         }
-        return Integer.compare(subLevel, o.subLevel);
+        if (subLevel != o.subLevel) {
+            return Integer.compare(subLevel, o.subLevel);
+        }
+        return Integer.compare(
+                osRelease.orElse(Integer.valueOf(0)), o.osRelease.orElse(Integer.valueOf(0)));
     }
 
     /** {@inheritDoc} */
@@ -89,4 +104,12 @@ public final class KernelVersion implements Comparable<KernelVersion> {
     public String toStringShort() {
         return String.format("%d.%d", version, patchLevel);
     }
+
+    public String toStringWithRelease() {
+        if (!osRelease.isPresent()) {
+            return toString();
+        }
+        return String.format(
+                "%d.%d.%d-android%d", version, patchLevel, subLevel, osRelease.get().intValue());
+    }
 }
diff --git a/libraries/systemui-helper/src/android/platform/helpers/CommonUtils.java b/libraries/systemui-helper/src/android/platform/helpers/CommonUtils.java
index 6344ad274..1c720155f 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/CommonUtils.java
+++ b/libraries/systemui-helper/src/android/platform/helpers/CommonUtils.java
@@ -19,7 +19,7 @@ package android.platform.helpers;
 import static android.platform.helpers.ui.UiAutomatorUtils.getInstrumentation;
 import static android.platform.helpers.ui.UiAutomatorUtils.getUiDevice;
 import static android.platform.helpers.ui.UiSearch.search;
-import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+import static android.platform.uiautomatorhelpers.DeviceHelpers.getContext;
 
 import static com.google.common.truth.Truth.assertWithMessage;
 
diff --git a/libraries/systemui-helper/src/android/platform/helpers/LaunchAppUtils.kt b/libraries/systemui-helper/src/android/platform/helpers/LaunchAppUtils.kt
index 91a39d4e8..9de231015 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/LaunchAppUtils.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/LaunchAppUtils.kt
@@ -19,15 +19,15 @@ package android.platform.helpers
 import android.content.Context
 import android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK
 import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
-import android.platform.uiautomator_helpers.DeviceHelpers
 import android.platform.helpers.LaunchAppUtils.launchApp
+import android.platform.uiautomatorhelpers.DeviceHelpers
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.uiautomator.By
 import androidx.test.uiautomator.UiDevice
 import androidx.test.uiautomator.Until
+import java.time.Duration
 import org.junit.rules.TestWatcher
 import org.junit.runner.Description
-import java.time.Duration
 
 /** Utilities to launch an [App]. */
 object LaunchAppUtils {
@@ -38,8 +38,7 @@ object LaunchAppUtils {
         val appIntent =
             packageManager.getLaunchIntentForPackage(app.packageName)?.apply {
                 flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_CLEAR_TASK
-            }
-                ?: error("Package ${app.packageName} not available")
+            } ?: error("Package ${app.packageName} not available")
 
         startActivity(appIntent)
         assertAppInForeground(app)
@@ -63,15 +62,11 @@ object LaunchAppUtils {
         get() = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())
 }
 
-/**
- * Rule that launches specified app and closes it after the test execution
- */
+/** Rule that launches specified app and closes it after the test execution */
 class LaunchAppRule(private val app: App) : TestWatcher() {
 
     override fun starting(description: Description?) {
-        InstrumentationRegistry.getInstrumentation()
-            .targetContext
-            .launchApp(app)
+        InstrumentationRegistry.getInstrumentation().targetContext.launchApp(app)
     }
 
     override fun finished(description: Description?) {
@@ -84,7 +79,7 @@ enum class App(internal val packageName: String) {
     CALCULATOR("com.google.android.calculator"),
     MAPS("com.google.android.apps.maps"),
     CAMERA("com.google.android.GoogleCamera"),
-    SETTINGS("com.android.settings")
+    SETTINGS("com.android.settings"),
 }
 
 private val MAX_TIMEOUT = Duration.ofSeconds(10)
diff --git a/libraries/systemui-helper/src/android/platform/helpers/LockscreenUtils.java b/libraries/systemui-helper/src/android/platform/helpers/LockscreenUtils.java
index 95eab2f50..48285149e 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/LockscreenUtils.java
+++ b/libraries/systemui-helper/src/android/platform/helpers/LockscreenUtils.java
@@ -21,8 +21,8 @@ import static android.os.SystemClock.sleep;
 import static android.platform.helpers.CommonUtils.executeShellCommand;
 import static android.platform.helpers.Constants.SHORT_WAIT_TIME_IN_SECONDS;
 import static android.platform.helpers.ui.UiAutomatorUtils.getUiDevice;
-import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
-import static android.platform.uiautomator_helpers.WaitUtils.ensureThat;
+import static android.platform.uiautomatorhelpers.DeviceHelpers.getContext;
+import static android.platform.uiautomatorhelpers.WaitUtils.ensureThat;
 import static android.view.KeyEvent.KEYCODE_ENTER;
 
 import static com.google.common.truth.Truth.assertThat;
diff --git a/libraries/systemui-helper/src/android/platform/helpers/ProcessUtil.kt b/libraries/systemui-helper/src/android/platform/helpers/ProcessUtil.kt
index 618b51f45..a5e772d21 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/ProcessUtil.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/ProcessUtil.kt
@@ -1,7 +1,7 @@
 package android.platform.helpers
 
-import android.platform.uiautomator_helpers.DeviceHelpers.shell
-import android.platform.uiautomator_helpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.DeviceHelpers.shell
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import android.util.Log
 import java.time.Duration
 
@@ -18,11 +18,11 @@ class ProcessUtil(private val packageName: String) {
                 Log.d(TAG, "Result of \"$killCmd\": \"$result\"")
             }
         ensureThat("All sysui process stopped", Duration.ofSeconds(30L)) {
-           allProcessesStopped(initialPids)
+            allProcessesStopped(initialPids)
         }
         ensureThat("All sysui process restarted", Duration.ofSeconds(30L)) {
-           hasProcessRestarted(initialPids)
-       }
+            hasProcessRestarted(initialPids)
+        }
     }
 
     private fun getPids(logTag: String): List<String> {
diff --git a/libraries/systemui-helper/src/android/platform/helpers/SysuiRestarter.kt b/libraries/systemui-helper/src/android/platform/helpers/SysuiRestarter.kt
index 409f37ab7..f674c28cd 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/SysuiRestarter.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/SysuiRestarter.kt
@@ -19,9 +19,9 @@ import android.platform.helpers.CommonUtils.assertScreenOn
 import android.platform.helpers.Constants.UI_PACKAGE_NAME_SYSUI
 import android.platform.helpers.LockscreenUtils.LockscreenType
 import android.platform.helpers.features.common.HomeLockscreenPage
-import android.platform.uiautomator_helpers.DeviceHelpers.assertVisibility
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.DurationUtils.platformAdjust
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DurationUtils.platformAdjust
 import androidx.test.uiautomator.By
 import com.android.app.tracing.traceSection
 import com.android.systemui.Flags
@@ -42,7 +42,7 @@ object SysuiRestarter {
                     "keyguard_indication_area"
                 } else {
                     "keyguard_clock_container"
-                }
+                },
             )
         }
 
@@ -64,7 +64,7 @@ object SysuiRestarter {
             LockscreenUtils.setLockscreen(
                 LockscreenType.SWIPE,
                 /* lockscreenCode= */ null,
-                /* expectedResult= */ false
+                /* expectedResult= */ false,
             )
             sysuiProcessUtils.restart()
             assertLockscreenVisibility(true) { "Lockscreen not visible after restart" }
@@ -80,7 +80,7 @@ object SysuiRestarter {
             LOCKSCREEN_SELECTOR,
             visible,
             timeout = Duration.ofSeconds(10).platformAdjust(),
-            errorProvider = errorMessageProvider
+            errorProvider = errorMessageProvider,
         )
     }
 }
diff --git a/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableDeviceController.kt b/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableDeviceController.kt
index 815fb2fbe..46e3ee6b6 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableDeviceController.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableDeviceController.kt
@@ -16,15 +16,21 @@
 package android.platform.helpers.foldable
 
 import android.hardware.Sensor
+import android.hardware.devicestate.DeviceState.PROPERTY_FEATURE_REAR_DISPLAY
+import android.hardware.devicestate.DeviceState.PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_INNER_PRIMARY
+import android.hardware.devicestate.DeviceState.PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY
+import android.hardware.devicestate.DeviceState.PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_HALF_OPEN
 import android.hardware.devicestate.DeviceStateManager
 import android.hardware.devicestate.DeviceStateManager.DeviceStateCallback
+import android.hardware.devicestate.DeviceStateManager.INVALID_DEVICE_STATE_IDENTIFIER
 import android.hardware.devicestate.DeviceStateRequest
+import android.hardware.devicestate.feature.flags.Flags as DeviceStateManagerFlags
 import android.platform.test.rule.isLargeScreen
-import android.platform.uiautomator_helpers.DeviceHelpers.isScreenOnSettled
-import android.platform.uiautomator_helpers.DeviceHelpers.printInstrumentationStatus
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.platform.uiautomator_helpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.DeviceHelpers.isScreenOnSettled
+import android.platform.uiautomatorhelpers.DeviceHelpers.printInstrumentationStatus
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import android.util.Log
 import androidx.annotation.FloatRange
 import androidx.test.platform.app.InstrumentationRegistry
@@ -128,6 +134,14 @@ internal class FoldableDeviceController {
     }
 
     private fun findStates() {
+        if (DeviceStateManagerFlags.deviceStatePropertyMigration()) {
+            findStates_deviceStateManager()
+        } else {
+            findStates_configValues()
+        }
+    }
+
+    private fun findStates_configValues() {
         val foldedStates = resources.getIntArray(R.array.config_foldedDeviceStates)
         assumeTrue("Skipping on non-foldable devices", foldedStates.isNotEmpty())
         foldedState = foldedStates.first()
@@ -136,6 +150,52 @@ internal class FoldableDeviceController {
         rearDisplayState = resources.getIntArray(R.array.config_rearDisplayDeviceStates).first()
     }
 
+    private fun findStates_deviceStateManager() {
+        val deviceStates = deviceStateManager.supportedDeviceStates
+        foldedState =
+            deviceStates
+                .firstOrNull { deviceState ->
+                    deviceState.hasProperty(
+                        PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_OUTER_PRIMARY
+                    ) && !deviceState.hasProperty(PROPERTY_FEATURE_REAR_DISPLAY)
+                }
+                ?.identifier ?: INVALID_DEVICE_STATE_IDENTIFIER
+
+        assumeTrue(
+            "Skipping on non-foldable devices",
+            foldedState != INVALID_DEVICE_STATE_IDENTIFIER,
+        )
+
+        halfFoldedState =
+            deviceStates
+                .firstOrNull { deviceState ->
+                    deviceState.hasProperties(
+                        PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_INNER_PRIMARY,
+                        PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_HALF_OPEN,
+                    )
+                }
+                ?.identifier ?: INVALID_DEVICE_STATE_IDENTIFIER
+
+        unfoldedState =
+            deviceStates
+                .firstOrNull { deviceState ->
+                    deviceState.hasProperty(
+                        PROPERTY_FOLDABLE_DISPLAY_CONFIGURATION_INNER_PRIMARY
+                    ) &&
+                        !deviceState.hasProperty(
+                            PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_HALF_OPEN
+                        )
+                }
+                ?.identifier ?: INVALID_DEVICE_STATE_IDENTIFIER
+
+        rearDisplayState =
+            deviceStates
+                .firstOrNull { deviceState ->
+                    deviceState.hasProperty(PROPERTY_FEATURE_REAR_DISPLAY)
+                }
+                ?.identifier ?: INVALID_DEVICE_STATE_IDENTIFIER
+    }
+
     private fun setDeviceState(state: Int) {
         if (currentState == state) {
             Log.e(TAG, "setting device state to the same state already set.")
@@ -148,7 +208,7 @@ internal class FoldableDeviceController {
             deviceStateManager.requestBaseStateOverride(
                 request,
                 context.mainExecutor,
-                deviceStateRequestCallback
+                deviceStateRequestCallback,
             )
             deviceStateLatch.await { "Device state didn't change within the timeout" }
             ensureStateSet(state)
diff --git a/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableRule.kt b/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableRule.kt
index 2a4fe4f4b..15bc2775a 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableRule.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/foldable/FoldableRule.kt
@@ -22,8 +22,8 @@ import android.platform.helpers.foldable.FoldableState.HALF_FOLDED
 import android.platform.helpers.foldable.FoldableState.REAR_DISPLAY
 import android.platform.helpers.foldable.FoldableState.UNFOLDED
 import android.platform.test.rule.TestWatcher
-import android.platform.uiautomator_helpers.TracingUtils.trace
-import android.platform.uiautomator_helpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
 import androidx.annotation.FloatRange
 import java.util.concurrent.TimeUnit
 import org.junit.rules.TestRule
@@ -63,9 +63,10 @@ class FoldableRule(private val ensureScreenOn: Boolean = false) : TestWatcher()
 
     /**
      * Folds a foldable device
+     *
      * @param turnOffDisplayAfterFold if true, then triggers the device to go to sleep
-     * @param ensureFinished if true, waits for the display switch to happen
-     *                       and for the fold animation to play
+     * @param ensureFinished if true, waits for the display switch to happen and for the fold
+     *   animation to play
      */
     @JvmOverloads
     fun fold(turnOffDisplayAfterFold: Boolean = true, ensureFinished: Boolean = true) {
@@ -130,7 +131,8 @@ class FoldableRule(private val ensureScreenOn: Boolean = false) : TestWatcher()
         }
     }
 
-    fun unfold() {
+    @JvmOverloads
+    fun unfold(ensureFinished: Boolean = true) {
         trace("FoldableRule#unfold") {
             check(!controller.isUnfolded) { "Trying to unfold when already unfolded" }
             if (ensureScreenOn) {
@@ -140,6 +142,11 @@ class FoldableRule(private val ensureScreenOn: Boolean = false) : TestWatcher()
             val initialState = currentState
 
             controller.unfold()
+
+            if (!ensureFinished) {
+                return
+            }
+
             SystemClock.sleep(ANIMATION_TIMEOUT) // Let's wait for the unfold animation to finish.
 
             ensureThat("screen is on after unfolding") { screenOn }
diff --git a/libraries/systemui-helper/src/android/platform/helpers/foldable/UnfoldAnimationTestingUtils.kt b/libraries/systemui-helper/src/android/platform/helpers/foldable/UnfoldAnimationTestingUtils.kt
index 9bf6d530e..4a14e39d5 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/foldable/UnfoldAnimationTestingUtils.kt
+++ b/libraries/systemui-helper/src/android/platform/helpers/foldable/UnfoldAnimationTestingUtils.kt
@@ -1,8 +1,8 @@
 package android.platform.helpers.foldable
 
 import android.graphics.Point
-import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
-import android.platform.uiautomator_helpers.WaitUtils.waitFor
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.WaitUtils.waitFor
 import com.google.common.truth.Expect
 import com.google.common.truth.Truth.assertWithMessage
 import java.time.Duration
@@ -21,7 +21,7 @@ object UnfoldAnimationTestingUtils {
      */
     fun getIconPositionsAfterAnyIconMove(
         initialIcons: Set<Icon>,
-        currentProvider: () -> Set<Icon>
+        currentProvider: () -> Set<Icon>,
     ): Set<Icon> {
         return waitFor("Icons moving", Duration.ofSeconds(20)) {
             val newIcons = currentProvider()
@@ -92,7 +92,7 @@ object UnfoldAnimationTestingUtils {
     /** Describes axis (x or y) of a View */
     enum class Axis {
         X,
-        Y
+        Y,
     }
 
     /**
diff --git a/libraries/systemui-helper/src/android/platform/helpers/media/MediaInstrumentation.java b/libraries/systemui-helper/src/android/platform/helpers/media/MediaInstrumentation.java
index 4becab469..ddb469afe 100644
--- a/libraries/systemui-helper/src/android/platform/helpers/media/MediaInstrumentation.java
+++ b/libraries/systemui-helper/src/android/platform/helpers/media/MediaInstrumentation.java
@@ -16,7 +16,7 @@
 
 package android.platform.helpers.media;
 
-import static android.platform.uiautomator_helpers.DeviceHelpers.assertVisibility;
+import static android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility;
 
 import static org.junit.Assert.assertNotNull;
 
diff --git a/libraries/systemui-tapl/Android.bp b/libraries/systemui-tapl/Android.bp
new file mode 100644
index 000000000..71f0f3173
--- /dev/null
+++ b/libraries/systemui-tapl/Android.bp
@@ -0,0 +1,45 @@
+//
+// Copyright (C) 2021 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    //   legacy_proprietary
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+java_library {
+    name: "systemui-tapl",
+    libs: [
+        "androidx.test.uiautomator_uiautomator",
+        "systemui-helper",
+        "launcher-aosp-tapl",
+        "sysui-helper",
+        "user-helper",
+        "uiautomator-helpers",
+        "health-testing-utils",
+    ],
+    static_libs: [
+        "tapl-common",
+        "//frameworks/base/packages/SystemUI/aconfig:com_android_systemui_flags_lib",
+        "SettingsLib",
+    ],
+    srcs: [
+        "src/**/*.java",
+        "src/**/*.kt",
+    ],
+    lint: {
+        test: true,
+    },
+}
diff --git a/libraries/systemui-tapl/OWNERS b/libraries/systemui-tapl/OWNERS
new file mode 100644
index 000000000..50d9e8e4b
--- /dev/null
+++ b/libraries/systemui-tapl/OWNERS
@@ -0,0 +1,5 @@
+nicomazz@google.com
+saff@google.com
+yuzhechen@google.com
+
+per-file *Notification* = juliacr@google.com, jeffdq@google.com
diff --git a/libraries/systemui-tapl/TEST_MAPPING b/libraries/systemui-tapl/TEST_MAPPING
new file mode 100644
index 000000000..94b253388
--- /dev/null
+++ b/libraries/systemui-tapl/TEST_MAPPING
@@ -0,0 +1,8 @@
+{
+  "imports": [
+    {
+      "path": "vendor/google_testing/integration/tests/scenarios/src/android/platform/test/scenario/sysui"
+    }
+  ]
+}
+
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BigTextNotificationController.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BigTextNotificationController.kt
new file mode 100644
index 000000000..1d959c277
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BigTextNotificationController.kt
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+import android.R
+import android.app.Notification
+import android.app.PendingIntent
+import android.content.Intent
+import android.platform.systemui_tapl.ui.Notification.Companion.NOTIFICATION_BIG_TEXT
+import android.platform.uiautomator_helpers.DeviceHelpers
+
+object BigTextNotificationController {
+    /** Id of the high importance channel created by the controller. */
+    private const val NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_ID = "test_channel_id_high_importance"
+    private const val NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_ID =
+        "test_channel_id_default_importance"
+    private const val NOTIFICATION_CONTENT_TEXT = "Test notification content"
+    private const val NOTIFICATION_TITLE_TEXT = "TEST NOTIFICATION"
+
+    /**
+     * Posts a notification using [Notification.BigTextStyle].
+     *
+     * @param pkg Default contentIntent launches this App to when clicking on notification.
+     * @param highImportance Whether to post the notification with high importance.
+     * @param collapsedText Text content when the notification is collapsed.
+     * @param expandedText Text content when the notification is expanded.
+     * @param title Title of the notification.
+     * @param contentIntent The contentIntent when the notification is clicked.
+     * @param addActionButton When true, add a default action button to the notification.
+     * @param actions The list of actions attached to the notification.
+     * @return The [NotificationIdentity] that represents the posted notification.
+     */
+    @JvmOverloads
+    @JvmStatic
+    fun postBigTextNotification(
+        pkg: String?,
+        highImportance: Boolean = false,
+        collapsedText: String = NOTIFICATION_CONTENT_TEXT,
+        expandedText: String = NOTIFICATION_BIG_TEXT,
+        title: String = NOTIFICATION_TITLE_TEXT,
+        contentIntent: PendingIntent? = null,
+        publicVersion: Notification? = null,
+        addActionButton: Boolean = false,
+        allowAutoGroup: Boolean = false,
+        vararg actions: Notification.Action,
+    ): NotificationIdentity {
+        val context = DeviceHelpers.context
+        val channelId =
+            if (highImportance) NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_ID
+            else NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_ID
+        val notificationController = NotificationController.get()
+
+        val builder =
+            Notification.Builder(context, channelId)
+                .setStyle(Notification.BigTextStyle().bigText(expandedText))
+                .setSmallIcon(R.drawable.stat_notify_chat)
+                .setContentText(collapsedText)
+                .setContentTitle(title)
+                .setCategory(Notification.CATEGORY_SYSTEM)
+                .setGroupSummary(false)
+                .setActions(*actions)
+
+        if (addActionButton) {
+            builder.addAction(notificationController.defaultActionBuilder.build())
+        }
+
+        publicVersion?.let(builder::setPublicVersion)
+        val pendingIntent =
+            if (pkg != null && contentIntent == null)
+                PendingIntent.getActivity(
+                    /* context= */ context,
+                    /* requestCode= */ 0,
+                    /* intent= */ context.packageManager.getLaunchIntentForPackage(pkg),
+                    /* flags= */ Intent.FLAG_ACTIVITY_NEW_TASK or PendingIntent.FLAG_IMMUTABLE,
+                )
+            else contentIntent
+        pendingIntent?.let { builder.setContentIntent(it) }
+
+        if (allowAutoGroup) {
+            notificationController.postNotificationNoGroup(builder)
+        } else {
+            notificationController.postNotification(builder)
+        }
+
+        return NotificationIdentity(
+            type = NotificationIdentity.Type.BIG_TEXT,
+            title = title,
+            text = collapsedText,
+            summary = null,
+            textWhenExpanded = expandedText,
+            contentIsVisibleInCollapsedState = true,
+            pkg = pkg,
+            hasAction = actions.isNotEmpty() or addActionButton,
+        )
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java
new file mode 100644
index 000000000..89c5c3c46
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/BubbleSettingsController.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.content.Context.STATUS_BAR_SERVICE;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+
+import android.app.INotificationManager;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.platform.systemui_tapl.ui.Root;
+import android.system.Os;
+import android.util.Log;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+/** Controller for manipulating bubble settings. */
+public class BubbleSettingsController {
+    private static final int UID = Os.getuid();
+    private static final String PACKAGE_NAME = getContext().getPackageName();
+    private static final String TAG = "BubbleSettingsController";
+
+    private final INotificationManager mINotificationManager =
+            INotificationManager.Stub.asInterface(
+                    ServiceManager.getService(Context.NOTIFICATION_SERVICE));
+
+    private BubbleSettingsController() {}
+
+    /** Returns an instance of BubbleSettingsController. */
+    public static BubbleSettingsController get() {
+        return new BubbleSettingsController();
+    }
+
+    private void setBubblesAllowed(int bubblePreference) {
+        Log.d(TAG, "setBubblesAllowed(" + bubblePreference + ") for UID " + UID);
+        InstrumentationRegistry.getInstrumentation()
+                .getUiAutomation()
+                .adoptShellPermissionIdentity(STATUS_BAR_SERVICE);
+        try {
+            mINotificationManager.setBubblesAllowed(PACKAGE_NAME, UID, bubblePreference);
+        } catch (RemoteException e) {
+            throw new RuntimeException(e);
+        } finally {
+            InstrumentationRegistry.getInstrumentation()
+                    .getUiAutomation()
+                    .dropShellPermissionIdentity();
+        }
+    }
+
+    /** Allows all bubbles. */
+    public void enableBubbles() {
+        setBubblesAllowed(NotificationManager.BUBBLE_PREFERENCE_ALL);
+    }
+
+    /** Disallows all bubbles. */
+    public void disableBubbles() {
+        setBubblesAllowed(NotificationManager.BUBBLE_PREFERENCE_NONE);
+        // Ensure any existing bubble is removed
+        Root.get().verifyNoBubbleIsVisible();
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/DockController.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/DockController.kt
new file mode 100644
index 000000000..712641682
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/DockController.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.IntentFilter
+import android.platform.uiautomator_helpers.DeviceHelpers.context
+import android.platform.uiautomator_helpers.DeviceHelpers.shell
+import android.platform.uiautomator_helpers.WaitUtils.ensureThat
+import android.util.Log
+import java.time.Duration
+import org.junit.rules.ExternalResource
+
+/** Controller for manipulating dock status of a tablet. */
+class DockController : ExternalResource() {
+    private var lastDockState = UNKNOWN_DOCK_STATE
+
+    private val dockChangedReceiver =
+        object : BroadcastReceiver() {
+            override fun onReceive(context: Context, intent: Intent) {
+                val newDockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, UNKNOWN_DOCK_STATE)
+                Log.i(
+                    TAG,
+                    "ACTION_DOCK_EVENT received, " +
+                        "lastDockState: $lastDockState (${DOCK_STATE_NAMES[lastDockState]}), " +
+                        "newDockState: $newDockState (${DOCK_STATE_NAMES[newDockState]})",
+                )
+                lastDockState = newDockState
+            }
+        }
+
+    override fun before() {
+        registerReceiver()
+    }
+
+    override fun after() {
+        unregisterReceiver()
+    }
+
+    fun enterDockState() {
+        if (DEBUG) Log.i(TAG, "enterDockState")
+        // Fake Korlan Dock. See go/dock-manager-guide#fake-korlan-dock
+        shell("dumpsys DockObserver set state ${Intent.EXTRA_DOCK_STATE_HE_DESK}")
+        context.sendBroadcast(
+            Intent("ACTION_DEBUG_DOCK")
+                .putExtra("EXTRA_DEBUG_DOCK_PRODUCT", "korlan")
+                .putExtra("EXTRA_DEBUG_DOCK_VERSION", "9.99.999999")
+                .putExtra("EXTRA_DEBUG_DOCK_HGS_ID", "fake-hgs-id")
+                .setClassName(context, DOCK_MANAGER_DEBUG_CONTROLLER_BROADCAST_RECEIVER)
+        )
+        waitUntilDocked()
+    }
+
+    fun exitDockState() {
+        if (DEBUG) Log.i(TAG, "exitDockState")
+        shell("dumpsys DockObserver set state ${Intent.EXTRA_DOCK_STATE_UNDOCKED}")
+        context.sendBroadcast(
+            Intent("ACTION_DEBUG_UNDOCK")
+                .setClassName(context, DOCK_MANAGER_DEBUG_CONTROLLER_BROADCAST_RECEIVER)
+        )
+        waitUntilUndocked()
+    }
+
+    fun resetDockState() {
+        if (DEBUG) Log.i(TAG, "resetDockState")
+        shell("dumpsys DockObserver reset")
+        context.sendBroadcast(
+            Intent("ACTION_DEBUG_UNDOCK")
+                .setClassName(context, DOCK_MANAGER_DEBUG_CONTROLLER_BROADCAST_RECEIVER)
+        )
+        waitUntilUndocked()
+    }
+
+    private fun isDocked(): Boolean {
+        val docked = lastDockState in DOCKED_STATES
+        if (DEBUG) Log.i(TAG, "isDocked: $docked")
+        return docked
+    }
+
+    fun waitUntilDocked() {
+        if (DEBUG) Log.i(TAG, "waitUntilDocked")
+        ensureThat("device is docked", DEFAULT_DEADLINE) { isDocked() }
+    }
+
+    fun waitUntilUndocked() {
+        if (DEBUG) Log.i(TAG, "waitUntilUndocked")
+        ensureThat("device is undocked", DEFAULT_DEADLINE) { !isDocked() }
+    }
+
+    private fun registerReceiver() {
+        val intentFilter = IntentFilter(Intent.ACTION_DOCK_EVENT)
+        if (DEBUG) Log.i(TAG, "Registered event receiver")
+        context.registerReceiver(dockChangedReceiver, intentFilter)
+    }
+
+    private fun unregisterReceiver() {
+        if (DEBUG) Log.i(TAG, "Unregistered event receiver")
+        context.unregisterReceiver(dockChangedReceiver)
+    }
+
+    companion object {
+        private val TAG = DockController::class.java.simpleName
+        private const val DOCK_MANAGER_DEBUG_CONTROLLER_BROADCAST_RECEIVER =
+            "com.google.android.apps.nest.dockmanager.app/.service.DebugControllerBroadcastReceiver"
+        private const val UNKNOWN_DOCK_STATE = -1
+        private const val DEBUG = false
+        private val DOCK_STATE_NAMES =
+            mapOf(
+                UNKNOWN_DOCK_STATE to "UNKNOWN_DOCK_STATE",
+                Intent.EXTRA_DOCK_STATE_CAR to "EXTRA_DOCK_STATE_CAR",
+                Intent.EXTRA_DOCK_STATE_DESK to "EXTRA_DOCK_STATE_DESK",
+                Intent.EXTRA_DOCK_STATE_HE_DESK to "EXTRA_DOCK_STATE_HE_DESK",
+                Intent.EXTRA_DOCK_STATE_LE_DESK to "EXTRA_DOCK_STATE_LE_DESK",
+                Intent.EXTRA_DOCK_STATE_UNDOCKED to "EXTRA_DOCK_STATE_UNDOCKED",
+            )
+        private val DOCKED_STATES =
+            arrayOf(
+                Intent.EXTRA_DOCK_STATE_HE_DESK,
+                Intent.EXTRA_DOCK_STATE_LE_DESK,
+                Intent.EXTRA_DOCK_STATE_DESK,
+            )
+        private val DEFAULT_DEADLINE = Duration.ofSeconds(20)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/LockscreenController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/LockscreenController.java
new file mode 100644
index 000000000..ba650aaa8
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/LockscreenController.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.content.Context.KEYGUARD_SERVICE;
+import static android.platform.helpers.LockscreenUtils.LockscreenType.NONE;
+import static android.platform.helpers.LockscreenUtils.LockscreenType.PASSWORD;
+import static android.platform.helpers.LockscreenUtils.LockscreenType.PATTERN;
+import static android.platform.helpers.LockscreenUtils.LockscreenType.PIN;
+import static android.platform.helpers.LockscreenUtils.LockscreenType.SWIPE;
+import static android.platform.test.util.HealthTestingUtils.waitForCondition;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getUiDevice;
+import static android.platform.uiautomator_helpers.DeviceHelpers.isScreenOnSettled;
+import static android.platform.uiautomator_helpers.WaitUtils.ensureThat;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.KeyguardManager;
+import android.content.ContentResolver;
+import android.hardware.display.AmbientDisplayConfiguration;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.os.Trace;
+import android.platform.helpers.LockscreenUtils;
+import android.provider.Settings;
+
+import org.junit.Assume;
+
+import java.io.IOException;
+
+/** Controller for manipulating lockscreen states. */
+public class LockscreenController {
+    private static final int SLEEP_INTERVAL_MS = 500;
+
+    private static final String FACE_WAKE_FAKE_COMMAND =
+            "am broadcast -a "
+                    + "com.android.systemui.latency.ACTION_FACE_WAKE"
+                    + " --user 0"; // Making sure broadcast receiver will receive the action
+    // if current user is different than System.
+    private static final String FINGERPRINT_WAKE_FAKE_COMMAND =
+            "am broadcast -a "
+                    + "com.android.systemui.latency.ACTION_FINGERPRINT_WAKE"
+                    + " --user 0"; // Making sure broadcast receiver will receive the action
+
+    // if current user is different than System.
+
+    /** Returns an instance of LockscreenController. */
+    public static LockscreenController get() {
+        return new LockscreenController();
+    }
+
+    private LockscreenController() {}
+
+    /** Enables unlocking via swipe */
+    public void setUnlockSwipe() {
+        LockscreenUtils.setLockscreen(
+                /* lockscreenType= */ SWIPE, /* lockscreenCode= */ "", /* expectedResult= */ false);
+    }
+
+    /** Enables no-lockscreen mode */
+    public void setNoLockScreenMode() {
+        LockscreenUtils.setLockscreen(
+                /* lockscreenType= */ NONE, /* lockscreenCode= */ "", /* expectedResult= */ false);
+    }
+
+    /** Enables pin unlock */
+    public void setLockscreenPin(String pin) {
+        LockscreenUtils.setLockscreen(
+                /* lockscreenType= */ PIN, /* lockscreenCode= */ pin, /* expectedResult= */ true);
+    }
+
+    /** Enables password unlock */
+    public void setLockscreenPassword(String password) {
+        LockscreenUtils.setLockscreen(
+                /* lockscreenType= */ PASSWORD,
+                /* lockscreenCode= */ password,
+                /* expectedResult= */ true);
+    }
+
+    /** Enables pattern unlock */
+    public void setLockscreenPattern(String pattern) {
+        LockscreenUtils.setLockscreen(
+                /* lockscreenType= */ PATTERN,
+                /* lockscreenCode= */ pattern,
+                /* expectedResult= */ true);
+    }
+
+    /**
+     * Enables or disables always-on display.
+     *
+     * @param enableAod Enable AOD?
+     * @return whether AOD was enabled.
+     */
+    public boolean setAodEnabled(boolean enableAod) {
+        final ContentResolver contentResolver = getContext().getContentResolver();
+        final boolean aodWasEnabled =
+                Settings.Secure.getInt(contentResolver, Settings.Secure.DOZE_ALWAYS_ON, 0) == 1;
+
+        if (enableAod != aodWasEnabled) {
+            assertThat(
+                            Settings.Secure.putInt(
+                                    contentResolver,
+                                    Settings.Secure.DOZE_ALWAYS_ON,
+                                    enableAod ? 1 : 0))
+                    .isTrue();
+        }
+
+        return aodWasEnabled;
+    }
+
+    /** Turns screen off by going to sleep. */
+    public void turnScreenOff() {
+        try {
+            getUiDevice().sleep();
+        } catch (RemoteException e) {
+            throw new RuntimeException(e);
+        }
+        SystemClock.sleep(SLEEP_INTERVAL_MS * 4);
+        waitForCondition(() -> "Screen didn't turn off", () -> !getUiDevice().isScreenOn());
+    }
+
+    /** Turns screen on by waking up from sleep. */
+    public void turnScreenOn() {
+        Trace.beginSection("LockscreenController#turnScreenOn");
+        try {
+            try {
+                getUiDevice().wakeUp();
+            } catch (RemoteException e) {
+                throw new RuntimeException(e);
+            }
+            SystemClock.sleep(SLEEP_INTERVAL_MS * 4);
+            ensureThat("Screen is on", () -> isScreenOnSettled(getUiDevice()));
+        } finally {
+            Trace.endSection();
+        }
+    }
+
+    /** Goes to the Locked screen page */
+    public void lockScreen() {
+        LockscreenUtils.goToLockScreen();
+    }
+
+    /**
+     * Clears the lock credentials.
+     *
+     * @param currentLockscreenCode old code which is currently set.
+     */
+    public void clearLockCredentials(String currentLockscreenCode) {
+        LockscreenUtils.resetLockscreen(currentLockscreenCode);
+    }
+
+    /** Fake face unlock. */
+    public void fakeFaceUnlock() {
+        try {
+            getUiDevice().executeShellCommand(FACE_WAKE_FAKE_COMMAND);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /** Fake fingerprint unlock. */
+    public void fakeFingerprintUnlock() {
+        try {
+            getUiDevice().executeShellCommand(FINGERPRINT_WAKE_FAKE_COMMAND);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static KeyguardManager getKeyguardManager() {
+        return (KeyguardManager) getContext().getSystemService(KEYGUARD_SERVICE);
+    }
+
+    /** Checks whether the device supports AlwaysOnDisplay feature. */
+    public static void skipIfDeviceDoesNotSupportAod() {
+        AmbientDisplayConfiguration config = new AmbientDisplayConfiguration(getContext());
+        Assume.assumeTrue(
+                "Device dose not support AOD, skipped test.",
+                config.alwaysOnAvailable() || getUiDevice().getProductName().startsWith("cf_x86"));
+    }
+
+    /**
+     * Returns whether the device is currently locked and requires a PIN, pattern or password to
+     * unlock. see [KeyguardManager.isDeviceLocked].
+     */
+    public boolean isDeviceLocked() {
+        return getKeyguardManager().isDeviceLocked();
+    }
+
+    /**
+     * Returns whether the device is currently secured by a PIN, pattern or password. see
+     * [KeyguardManager.isDeviceSecure].
+     */
+    public boolean isDeviceSecure() {
+        return getKeyguardManager().isDeviceSecure();
+    }
+
+    /**
+     * Returns whether the keyguard is currently locked. See [KeyguardManager.isKeyguardLocked].
+     * Experimental.
+     */
+    public boolean isKeyguardLocked() {
+        return getKeyguardManager().isKeyguardLocked();
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java
new file mode 100644
index 000000000..6e405953f
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationController.java
@@ -0,0 +1,1372 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.app.Notification.CATEGORY_SYSTEM;
+import static android.app.NotificationManager.IMPORTANCE_DEFAULT;
+import static android.app.NotificationManager.IMPORTANCE_HIGH;
+import static android.app.NotificationManager.IMPORTANCE_LOW;
+import static android.app.NotificationManager.IMPORTANCE_MIN;
+import static android.app.PendingIntent.FLAG_IMMUTABLE;
+import static android.platform.systemui_tapl.ui.Notification.NOTIFICATION_BIG_TEXT;
+import static android.platform.test.util.HealthTestingUtils.waitForCondition;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getUiDevice;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+
+import android.R;
+import android.app.Notification;
+import android.app.Notification.Builder;
+import android.app.Notification.MessagingStyle;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Person;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ShortcutInfo;
+import android.content.pm.ShortcutManager;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.Icon;
+import android.os.SystemClock;
+import android.service.notification.StatusBarNotification;
+import android.util.Log;
+import android.widget.RemoteViews;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/** Controller for manipulating notifications. */
+public class NotificationController {
+    private static final String LOG_TAG = "NotificationController";
+
+    private static final String NOTIFICATION_TITLE_TEXT = "TEST NOTIFICATION";
+
+    private static final String INCOMING_CALL_TEXT = "Incoming call";
+
+    private static final String NOTIFICATION_GROUP = "Test group";
+    private static final String CUSTOM_TEXT = "Example text";
+    private static final String NOTIFICATION_CONTENT_TEXT_FORMAT = "Test notification %d";
+
+    /** Id of the high importance channel created by the controller. */
+    public static final String NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_ID =
+            "test_channel_id_high_importance";
+
+    public static final String NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_ID =
+            "test_channel_id_default_importance";
+
+    public static final String NOTIFICATION_CHANNEL_LOW_IMPORTANCE_ID =
+            "test_channel_id_low_importance";
+
+    public static final String NOTIFICATION_CHANNEL_MIN_IMPORTANCE_ID =
+            "test_channel_id_min_importance";
+
+    private static final String NOTIFICATION_CONTENT_TEXT = "Test notification content";
+    private static final String NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_NAME =
+            "Test Channel HIGH_IMPORTANCE";
+    private static final String NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_NAME =
+            "Test Channel DEFAULT_IMPORTANCE";
+
+    private static final String NOTIFICATION_CHANNEL_LOW_IMPORTANCE_NAME =
+            "Test Channel LOW_IMPORTANCE";
+    private static final String NOTIFICATION_CHANNEL_MIN_IMPORTANCE_NAME =
+            "Test Channel MIN_IMPORTANCE";
+    private static final String NOTIFICATION_GROUP_KEY_FORMAT = "Test group %d";
+    private static final String PACKAGE_NAME =
+            getInstrumentation().getTargetContext().getPackageName();
+    private static final String EXTRA_NAME_MESSAGE = "message";
+    private static final String DEFAULT_TEST_SHORTCUT_ID = "test_shortcut_id";
+
+    private static final android.app.NotificationManager NOTIFICATION_MANAGER =
+            getInstrumentation().getTargetContext().getSystemService(NotificationManager.class);
+
+    private static int nextNotificationId = 0;
+
+    private static final String DEFAULT_ACTION_TEXT = "action";
+
+    static {
+        NOTIFICATION_MANAGER.createNotificationChannel(
+                new NotificationChannel(
+                        NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_ID,
+                        NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_NAME,
+                        IMPORTANCE_HIGH));
+
+        NOTIFICATION_MANAGER.createNotificationChannel(
+                new NotificationChannel(
+                        NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_ID,
+                        NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_NAME,
+                        IMPORTANCE_DEFAULT));
+
+        NOTIFICATION_MANAGER.createNotificationChannel(
+                new NotificationChannel(
+                        NOTIFICATION_CHANNEL_LOW_IMPORTANCE_ID,
+                        NOTIFICATION_CHANNEL_LOW_IMPORTANCE_NAME,
+                        IMPORTANCE_LOW));
+
+        NOTIFICATION_MANAGER.createNotificationChannel(
+                new NotificationChannel(
+                        NOTIFICATION_CHANNEL_MIN_IMPORTANCE_ID,
+                        NOTIFICATION_CHANNEL_MIN_IMPORTANCE_NAME,
+                        IMPORTANCE_MIN));
+    }
+
+    /** Returns an instance of NotificationController. */
+    public static NotificationController get() {
+        return new NotificationController();
+    }
+
+    private NotificationController() {}
+
+    private static int getNextNotificationId() {
+        return nextNotificationId++;
+    }
+
+    /**
+     * Posts notification.
+     *
+     * @param builder Builder for notification to post.
+     */
+    public void postNotification(Builder builder) {
+        postNotificationSync(getNextNotificationId(), builder);
+    }
+
+    /**
+     * Posts notification without setting group ID.
+     *
+     * @param builder Builder for notification to post.
+     */
+    public void postNotificationNoGroup(Builder builder) {
+        postNotificationSync(/* id= */ getNextNotificationId(), builder, /* groupKey= */ null);
+    }
+
+    /**
+     * Posts notification.
+     *
+     * @param id notification id.
+     * @param builder Builder for notification to post.
+     */
+    public void postNotification(int id, Builder builder) {
+        Notification notification = builder.setGroup(getGroupKey(id)).build();
+        NOTIFICATION_MANAGER.notify(id, notification);
+        waitUntilNotificationPosted(id);
+    }
+
+    /**
+     * Cancels a notification.
+     *
+     * @param id notification id.
+     */
+    public void cancelNotification(int id) {
+        NOTIFICATION_MANAGER.cancel(id);
+        waitUntilNotificationCancelled(id);
+    }
+
+    /**
+     * Checks the notification has the LIFETIME_EXTENDED_BY_DIRECT_REPLY flag, then sends a
+     * cancellation for given notification, and checks that the cancellation is refused because of
+     * the flag, which prevents non-user originated cancellations from occurring.
+     *
+     * @param id notification id.
+     */
+    public void cancelNotificationLifetimeExtended(int id) {
+        // Checks the notification has the lifetime extended flag.
+        waitUntilNotificationUpdatedWithFlag(
+                id, Notification.FLAG_LIFETIME_EXTENDED_BY_DIRECT_REPLY);
+        // Sends the cancelation signal.
+        NOTIFICATION_MANAGER.cancel(id);
+        // The cancelation should be refused.
+        waitForCondition(
+                () -> "Notification is gone when cancelation should have been prevented",
+                () -> hasNotification(id));
+    }
+
+    /**
+     * Checks that a notification has been cancelled.
+     *
+     * @param id notification id.
+     */
+    public void notificationCancelled(int id) {
+        waitUntilNotificationCancelled(id);
+    }
+
+    /**
+     * Sends a cancellation signal; does not confirm the notification is canceled.
+     *
+     * @param id notification id
+     */
+    public void sendCancellation(int id) {
+        NOTIFICATION_MANAGER.cancel(id);
+    }
+
+    /**
+     * Posts a number of notifications to the device with a package to launch. Successive calls to
+     * this should post new notifications in addition to those previously posted. Note that this may
+     * fail if the helper has surpassed the system-defined limit for per-package notifications.
+     *
+     * @param count The number of notifications to post.
+     * @param isMessaging If notification should be a messagingstyle notification
+     */
+    public void postNotifications(int count, boolean isMessaging) {
+        postNotifications(count, null, isMessaging);
+    }
+
+    /**
+     * Posts a number of notifications to the device. Successive calls to this should post new
+     * notifications to those previously posted. Note that this may fail if the helper has surpassed
+     * the system-defined limit for per-package notifications.
+     *
+     * @param count The number of notifications to post.
+     */
+    public NotificationIdentity postNotifications(int count) {
+        return postNotifications(count, /* pkg */ null);
+    }
+
+    /**
+     * Setup Expectations: None
+     *
+     * <p>Posts a number of notifications to the device with a package to launch. Successive calls
+     * to this should post new notifications in addition to those previously posted. Note that this
+     * may fail if the helper has surpassed the system-defined limit for per-package notifications.
+     *
+     * @param count The number of notifications to post.
+     * @param pkg The application that will be launched by notifications.
+     */
+    public NotificationIdentity postNotifications(int count, String pkg) {
+        postNotifications(count, pkg, /* isMessaging= */ false);
+        return new NotificationIdentity(
+                NotificationIdentity.Type.BY_TITLE,
+                NOTIFICATION_TITLE_TEXT,
+                null,
+                null,
+                null,
+                false,
+                pkg);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.CallStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    @NonNull
+    public NotificationIdentity postCallStyleNotification(@Nullable String pkg) {
+        Person namedPerson = new Person.Builder().setName("Named Person").build();
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setStyle(
+                                Notification.CallStyle.forOngoingCall(
+                                        namedPerson, getLaunchIntent(pkg)))
+                        .setFullScreenIntent(getLaunchIntent(pkg), true)
+                        .setContentText(INCOMING_CALL_TEXT));
+        return new NotificationIdentity(
+                NotificationIdentity.Type.CALL, null, INCOMING_CALL_TEXT, null, null, true, null);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.InboxStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    @NonNull
+    public NotificationIdentity postInboxStyleNotification(
+            @Nullable String pkg, @Nullable String rowText) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setStyle(new Notification.InboxStyle().addLine(rowText))
+                        .setContentText(NOTIFICATION_CONTENT_TEXT));
+        return new NotificationIdentity(
+                NotificationIdentity.Type.INBOX,
+                null,
+                NOTIFICATION_TITLE_TEXT,
+                null,
+                null,
+                true,
+                null);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.MediaStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    @NonNull
+    public NotificationIdentity postMediaStyleNotification(
+            @Nullable String pkg, boolean decorated) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setStyle(
+                                decorated
+                                        ? new Notification.DecoratedMediaCustomViewStyle()
+                                        : new Notification.MediaStyle())
+                        .setContentText(NOTIFICATION_CONTENT_TEXT));
+        return new NotificationIdentity(
+                NotificationIdentity.Type.MEDIA,
+                null,
+                NOTIFICATION_CONTENT_TEXT,
+                null,
+                null,
+                true,
+                null);
+    }
+
+    /**
+     * Posts a notification with a custom layout.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param decorated whether the custom notification should have the standard view wrapper
+     */
+    @NonNull
+    public NotificationIdentity postCustomNotification(@Nullable String pkg, boolean decorated) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setCustomContentView(makeCustomContent())
+                        .setStyle(decorated ? new Notification.DecoratedCustomViewStyle() : null)
+                        .setContentText(CUSTOM_TEXT));
+        return new NotificationIdentity(
+                NotificationIdentity.Type.CUSTOM, null, CUSTOM_TEXT, null, null, true, null);
+    }
+
+    protected RemoteViews makeCustomContent() {
+        RemoteViews customContent =
+                new RemoteViews(PACKAGE_NAME, android.R.layout.simple_list_item_1);
+        int textId = android.R.id.text1;
+        customContent.setTextViewText(textId, "Example Text");
+        return customContent;
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.BigPictureStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    @NonNull
+    public NotificationIdentity postBigPictureNotification(@Nullable String pkg) {
+        Bitmap bitmap = Bitmap.createBitmap(400, 400, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setStyle(new android.app.Notification.BigPictureStyle().bigPicture(bitmap))
+                        .setContentText(NOTIFICATION_CONTENT_TEXT));
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.BIG_PICTURE,
+                /* title= */ null,
+                /* text= */ NOTIFICATION_TITLE_TEXT,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ null);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.BigPictureStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param picture The picture to include as the content of the BigPicture Notification.
+     */
+    @NonNull
+    public NotificationIdentity postBigPictureNotification(
+            @Nullable String pkg, String title, @NonNull Icon picture, boolean lowImportance) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg, lowImportance ? Importance.LOW : Importance.DEFAULT)
+                        .setContentTitle(title)
+                        .setStyle(
+                                new android.app.Notification.BigPictureStyle().bigPicture(picture))
+                        .setContentText(NOTIFICATION_CONTENT_TEXT));
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.BIG_PICTURE,
+                /* title= */ null,
+                /* text= */ title,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                "Scenario");
+    }
+
+    /**
+     * Posts a number of notifications while the shade is closed. Successive calls to this should
+     * post new notifications in addition to those previously posted. Note that this may fail if the
+     * helper has surpassed the system-defined limit for per-package notifications.
+     *
+     * @param count The number of notifications to post.
+     * @param pkg The application that will be launched by notifications.
+     * @param summary Summary text for this group notification
+     */
+    @NonNull
+    public GroupNotificationIdentities postGroupNotifications(
+            int count, @Nullable String pkg, @NonNull String summary) {
+        return postGroupNotifications(count, pkg, summary, /* highImportance= */ false);
+    }
+
+    /**
+     * Posts a number of notifications while the shade is closed. Successive calls to this should
+     * post new notifications in addition to those previously posted. Note that this may fail if the
+     * helper has surpassed the system-defined limit for per-package notifications.
+     *
+     * @param count The number of notifications to post.
+     * @param pkg The application that will be launched by notifications.
+     * @param summary Summary text for this group notification
+     * @param highImportance Whether to post the notification with high importance
+     */
+    @NonNull
+    public GroupNotificationIdentities postGroupNotifications(
+            int count, @Nullable String pkg, @NonNull String summary, boolean highImportance) {
+        return postGroupNotificationsImpl(count, pkg, summary, highImportance);
+    }
+
+    /**
+     * Posts a number of notifications while the shade is closed with custom prioruty. Successive
+     * calls to this should post new notifications in addition to those previously posted. Note that
+     * this may fail if the helper has surpassed the system-defined limit for per-package
+     * notifications.
+     *
+     * @param count The number of notifications to post.
+     * @param pkg The application that will be launched by notifications.
+     * @param summary Summary text for this group notification
+     * @param priority The priority of the group notification
+     */
+    @NonNull
+    public GroupNotificationIdentities postGroupNotifications(
+            int count, @Nullable String pkg, @NonNull String summary, Importance priority) {
+        return postGroupNotificationsImpl(count, pkg, summary, priority);
+    }
+
+    /***
+     * Posts a number of MessagingStyle Notifications and group them. Note that this may fail if the
+     * helper has surpassed the system-defined limit for per-package notifications.
+     * @param pkg The application that will be launched by notifications.
+     * @param count The number of notifications to post.
+     * @param summary Summary text for this group notification
+     * @param personName Name of the person
+     * @param messages Message Content to be posted for each MessingStyle Notification
+     */
+    public NotificationIdentity postGroupNotificationWithMessagingStyle(
+            String pkg,
+            String summary,
+            int count,
+            String groupName,
+            String personName,
+            List<MessagingStyle.Message> messages) {
+        Builder builder =
+                getBuilder(pkg)
+                        .setGroupAlertBehavior(android.app.Notification.GROUP_ALERT_SUMMARY)
+                        .setGroup(groupName);
+
+        for (int i = 0; i < count; i++) {
+            final Person person = new Person.Builder().setName(personName + "_" + i).build();
+            final MessagingStyle messagingStyle =
+                    new MessagingStyle(person).setConversationTitle(NOTIFICATION_TITLE_TEXT);
+            for (MessagingStyle.Message message : messages) {
+                messagingStyle.addMessage(message);
+            }
+            builder.setStyle(messagingStyle);
+            postNotificationSync(getNextNotificationId(), builder, groupName);
+        }
+        builder.setStyle(new android.app.Notification.InboxStyle().setSummaryText(summary))
+                .setGroupSummary(true);
+        postNotificationSync(getNextNotificationId(), builder, groupName);
+        return new NotificationIdentity(
+                NotificationIdentity.Type.GROUP,
+                null,
+                NOTIFICATION_TITLE_TEXT,
+                summary,
+                null,
+                true,
+                null);
+    }
+
+    /***
+     * Posts a number of ConversationStyle Notifications and group them.
+     * Note that this may fail if the helper has surpassed the system-defined limit
+     * for per-package notifications.
+     *
+     * @param pkg The application that will be launched by notifications.
+     * @param count The number of notifications to post.
+     * @param summary Summary text for this group notification
+     * @param personName Name of the person
+     * @param messages Message Content to be posted for each MessingStyle Notification
+     */
+    public NotificationIdentity postGroupNotificationWithConversationStyle(
+            String pkg,
+            String summary,
+            int count,
+            String groupName,
+            String personName,
+            List<MessagingStyle.Message> messages) {
+        Context context = getInstrumentation().getTargetContext();
+        Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        Intent intent = new android.content.Intent(Intent.ACTION_VIEW);
+
+        Builder builder =
+                getBuilder(pkg)
+                        .setGroupAlertBehavior(android.app.Notification.GROUP_ALERT_SUMMARY)
+                        .setGroup(groupName);
+        final ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
+
+        for (int i = 0; i < count; i++) {
+            final Person person = new Person.Builder().setName(personName + "_" + i).build();
+
+            String shortCutId = "short_cut" + i;
+            ShortcutInfo shortcutInfo =
+                    new ShortcutInfo.Builder(context, shortCutId)
+                            .setShortLabel(personName)
+                            .setLongLabel(personName)
+                            .setIntent(intent)
+                            .setIcon(Icon.createWithAdaptiveBitmap(bitmap))
+                            .setPerson(person)
+                            .setLongLived(true)
+                            .build();
+            shortcutManager.pushDynamicShortcut(shortcutInfo);
+            final MessagingStyle messagingStyle =
+                    new MessagingStyle(person).setConversationTitle(NOTIFICATION_TITLE_TEXT);
+            for (MessagingStyle.Message message : messages) {
+                messagingStyle.addMessage(message);
+            }
+            builder.setStyle(messagingStyle).setShortcutId(shortCutId);
+            postNotificationSync(getNextNotificationId(), builder, groupName);
+        }
+        builder.setStyle(new android.app.Notification.InboxStyle().setSummaryText(summary))
+                .setGroupSummary(true);
+        postNotificationSync(getNextNotificationId(), builder, groupName);
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.GROUP,
+                /* title= */ null,
+                /* text= */ NOTIFICATION_TITLE_TEXT,
+                /* summary= */ summary,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ null);
+    }
+
+    /***
+     * Posts a number of BigTextStyle Notifications and group them. Note that this may fail if the
+     * helper has surpassed the system-defined limit for per-package notifications.
+     * @param pkg The application that will be launched by notifications.
+     * @param summary Summary text for this group notification
+     * @param groupName Name of the group
+     * @param bigTextContents List of Text to be mapped BigTextStyle Notifications
+     */
+    public NotificationIdentity postGroupNotificationWithBigTextStyle(
+            String pkg, String summary, String groupName, List<String> bigTextContents) {
+        Builder builder =
+                getBuilder(pkg).setGroupAlertBehavior(android.app.Notification.GROUP_ALERT_SUMMARY);
+
+        final Notification.BigTextStyle bigTextStyle = new Notification.BigTextStyle();
+        for (String bigText : bigTextContents) {
+            bigTextStyle.setBigContentTitle(bigText);
+            builder.setStyle(bigTextStyle).setGroup(groupName);
+            postNotificationSync(getNextNotificationId(), builder, groupName);
+        }
+        builder.setStyle(new android.app.Notification.InboxStyle().setSummaryText(summary))
+                .setGroupSummary(true);
+        postNotificationSync(getNextNotificationId(), builder, groupName);
+        return new NotificationIdentity(
+                NotificationIdentity.Type.GROUP,
+                null,
+                NOTIFICATION_TITLE_TEXT,
+                summary,
+                null,
+                true,
+                null);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.BigTextStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    @NonNull
+    public NotificationIdentity postBigTextNotification(@Nullable String pkg) {
+        return postBigTextNotification(pkg, false);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.BigTextStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param highImportance Whether to post the notification with high importance.
+     */
+    @NonNull
+    public NotificationIdentity postBigTextNotification(
+            @Nullable String pkg, boolean highImportance) {
+        return BigTextNotificationController.postBigTextNotification(
+                /* pkg= */ pkg, /* highImportance= */ highImportance);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.BigTextStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param title title of a notification
+     * @param collapsedText collapsed text of a notification
+     * @param expandedText expanded text of a notification
+     */
+    @NonNull
+    public NotificationIdentity postBigTextNotification(
+            @Nullable String pkg,
+            boolean highImportance,
+            String title,
+            String collapsedText,
+            String expandedText) {
+        return BigTextNotificationController.postBigTextNotification(
+                /* pkg= */ pkg,
+                /* highImportance= */ highImportance,
+                /* collapsedText= */ collapsedText,
+                /* expandedText= */ expandedText,
+                /* title= */ title);
+    }
+
+    /**
+     * Posts a heads-up notification using {@link android.app.Notification.BigTextStyle} with a
+     * default action button. The action button is useful to distinguish if the notification is in
+     * the HUN form (We can tell a notification is in the HUN form if its expand button is at the
+     * "expand" state, and an action button is showing).
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postBigTextHeadsUpNotification(@Nullable String pkg) {
+        return BigTextNotificationController.postBigTextNotification(
+                /* pkg= */ pkg,
+                /* highImportance= */ true,
+                /* actions= */ getDefaultActionBuilder().build());
+    }
+
+    public Notification.Action.Builder getDefaultActionBuilder() {
+        return new Notification.Action.Builder(
+                Icon.createWithResource("", R.drawable.btn_star),
+                DEFAULT_ACTION_TEXT,
+                PendingIntent.getActivity(
+                        getContext(),
+                        0,
+                        new android.content.Intent(Intent.ACTION_VIEW),
+                        PendingIntent.FLAG_IMMUTABLE));
+    }
+
+    /**
+     * Posts a Full Screen Intent Notification.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param fsiPendingIntent Full Screen Intent
+     * @param actions actions Action to be shown in the Notification
+     */
+    public NotificationIdentity postFullScreenIntentNotification(
+            @Nullable final String pkg,
+            final PendingIntent fsiPendingIntent,
+            final Notification.Action... actions) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg, Importance.HIGH)
+                        .setSmallIcon(android.R.drawable.stat_notify_chat)
+                        .setContentText(NOTIFICATION_CONTENT_TEXT)
+                        .setFullScreenIntent(fsiPendingIntent, true)
+                        .setActions(actions));
+        return new NotificationIdentity(
+                /* title= */ NotificationIdentity.Type.BY_TITLE,
+                /* type= */ NOTIFICATION_TITLE_TEXT,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ pkg);
+    }
+
+    /**
+     * Posts an ongoing Notification.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postOngoingNotification(@Nullable final String pkg) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg, Importance.HIGH)
+                        .setContentText(NOTIFICATION_CONTENT_TEXT)
+                        .setOngoing(true));
+        return new NotificationIdentity(
+                /* title= */ NotificationIdentity.Type.BY_TITLE,
+                /* type= */ NOTIFICATION_TITLE_TEXT,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ pkg);
+    }
+
+    private static GroupNotificationIdentities postGroupNotificationsImpl(
+            int count, @Nullable String pkg, @NonNull String summary, boolean highImportance) {
+        return postGroupNotificationsImpl(
+                count, pkg, summary, highImportance ? Importance.HIGH : Importance.DEFAULT);
+    }
+
+    private static GroupNotificationIdentities postGroupNotificationsImpl(
+            int count, @Nullable String pkg, @NonNull String summary, Importance priority) {
+        GroupNotificationIdentities identities = new GroupNotificationIdentities();
+        Builder builder =
+                getBuilder(pkg, priority)
+                        .setGroupAlertBehavior(android.app.Notification.GROUP_ALERT_SUMMARY);
+
+        for (int i = 0; i < count; i++) {
+            final String childText = String.format(Locale.US, NOTIFICATION_CONTENT_TEXT_FORMAT, i);
+            builder.setContentText(childText);
+            postNotificationSync(getNextNotificationId(), builder, NOTIFICATION_GROUP);
+            identities.children.add(
+                    new NotificationIdentity(
+                            /* type= */ NotificationIdentity.Type.BY_TEXT,
+                            /* title= */ null,
+                            /* text= */ childText,
+                            /* summary= */ null,
+                            /* textWhenExpanded= */ null,
+                            /* contentIsVisibleInCollapsedState= */ true,
+                            /* pkg= */ pkg));
+        }
+
+        builder.setStyle(new android.app.Notification.InboxStyle().setSummaryText(summary))
+                .setGroupSummary(true);
+        postNotificationSync(getNextNotificationId(), builder, NOTIFICATION_GROUP);
+        identities.summary =
+                new NotificationIdentity(
+                        /* type= */ priority == Importance.MIN
+                                ? NotificationIdentity.Type.GROUP_MINIMIZED
+                                : NotificationIdentity.Type.GROUP,
+                        /* title= */ NOTIFICATION_TITLE_TEXT,
+                        /* text= */ NOTIFICATION_TITLE_TEXT,
+                        /* summary= */ summary,
+                        /* textWhenExpanded= */ null,
+                        /* contentIsVisibleInCollapsedState= */ true,
+                        /* pkg= */ pkg);
+
+        return identities;
+    }
+
+    /**
+     * Posts Standard Silent Notification
+     *
+     * @param pkg
+     */
+    public NotificationIdentity postStandardSilentNotification(String pkg) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg, Importance.LOW).setContentText(NOTIFICATION_CONTENT_TEXT));
+        return new NotificationIdentity(
+                /* title= */ NotificationIdentity.Type.BY_TITLE,
+                /* type= */ NOTIFICATION_TITLE_TEXT,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ true,
+                /* pkg= */ pkg);
+    }
+
+    /**
+     * Posts a Standard Notification.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postStandardStyleNotification(String pkg) {
+        postNotificationSync(getNextNotificationId(), getBuilder(pkg));
+
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.BY_TITLE,
+                /* title= */ NOTIFICATION_TITLE_TEXT,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ false,
+                /* pkg= */ pkg);
+    }
+
+    /**
+     * Posts a Standard Notification.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param title title of the notification
+     * @param content content of the notification
+     */
+    public NotificationIdentity postStandardStyleNotification(
+            String pkg, String title, String content) {
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg).setContentTitle(title).setContentText(content));
+
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.BY_TITLE,
+                /* title= */ title,
+                /* text= */ null,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ false,
+                /* pkg= */ pkg);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.MessagingStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postMessagingStyleNotification(String pkg) {
+        String personName = "Person Name";
+        android.app.Person person = new android.app.Person.Builder().setName(personName).build();
+        postNotificationSync(
+                getNextNotificationId(),
+                getBuilder(pkg)
+                        .setStyle(
+                                new android.app.Notification.MessagingStyle(person)
+                                        .setConversationTitle(NOTIFICATION_TITLE_TEXT)
+                                        .addMessage(
+                                                new android.app.Notification.MessagingStyle.Message(
+                                                        "Message 4",
+                                                        SystemClock.currentThreadTimeMillis(),
+                                                        person))
+                                        .addMessage(
+                                                new android.app.Notification.MessagingStyle.Message(
+                                                        "Message 3",
+                                                        SystemClock.currentThreadTimeMillis(),
+                                                        person))
+                                        .addMessage(
+                                                new android.app.Notification.MessagingStyle.Message(
+                                                        "Message 2",
+                                                        SystemClock.currentThreadTimeMillis(),
+                                                        person))
+                                        .addMessage(
+                                                new android.app.Notification.MessagingStyle.Message(
+                                                        "Message 1",
+                                                        SystemClock.currentThreadTimeMillis(),
+                                                        person))));
+        return new NotificationIdentity(
+                NotificationIdentity.Type.MESSAGING_STYLE,
+                null,
+                personName,
+                null,
+                null,
+                false,
+                null);
+    }
+
+    /**
+     * Posts a notification using {@link android.app.Notification.MessagingStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param personName name of the person who sends message
+     * @param messages message list.
+     */
+    public NotificationIdentity postMessagingStyleNotification(
+            String pkg, String personName, List<MessagingStyle.Message> messages) {
+        final Person person = new Person.Builder().setName(personName).build();
+        final MessagingStyle messagingStyle =
+                new MessagingStyle(person).setConversationTitle(NOTIFICATION_TITLE_TEXT);
+        for (MessagingStyle.Message message : messages) {
+            messagingStyle.addMessage(message);
+        }
+        postNotificationSync(getNextNotificationId(), getBuilder(pkg).setStyle(messagingStyle));
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.MESSAGING_STYLE,
+                /* title= */ null,
+                /* text= */ personName,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ false,
+                /* pkg= */ null);
+    }
+
+    /**
+     * Posts a conversation notification. This notification is associated with a conversation
+     * shortcut and in {@link android.app.Notification.MessagingStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postConversationNotification(String pkg) {
+        return postConversationNotification(pkg, "test_shortcut_id", "Person Name");
+    }
+
+    /**
+     * Posts a sensitive big text style notification.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     */
+    public NotificationIdentity postBigTextNotificationWithPublicVersion(String pkg) {
+        return BigTextNotificationController.postBigTextNotification(
+                /* pkg= */ pkg,
+                /* highImportance= */ false,
+                /* collapsedText= */ NOTIFICATION_CONTENT_TEXT,
+                /* expandedText= */ NOTIFICATION_BIG_TEXT,
+                /* title: String = */ NOTIFICATION_TITLE_TEXT,
+                /* contentIntent= */ null,
+                /* publicVersion= */ getBuilder(pkg).build());
+    }
+
+    /**
+     * Posts a conversation notification. This notification is associated with a conversation
+     * shortcut and in {@link android.app.Notification.MessagingStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param shortcutId The shortcut ID of the associated conversation.
+     * @param personName The name of the person of the associated conversation.
+     */
+    public NotificationIdentity postConversationNotification(
+            String pkg, String shortcutId, String personName) {
+        Context context = getInstrumentation().getTargetContext();
+        Person person = new Person.Builder().setName(personName).build();
+        long currentTimeMillis = SystemClock.currentThreadTimeMillis();
+        Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        Intent intent = new android.content.Intent(Intent.ACTION_VIEW);
+
+        ShortcutInfo shortcutInfo =
+                new ShortcutInfo.Builder(context, shortcutId)
+                        .setShortLabel(personName)
+                        .setLongLabel(personName)
+                        .setIntent(intent)
+                        .setIcon(Icon.createWithAdaptiveBitmap(bitmap))
+                        .setPerson(person)
+                        .setLongLived(true)
+                        .build();
+        ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
+        shortcutManager.pushDynamicShortcut(shortcutInfo);
+
+        Builder builder =
+                getBuilder(pkg)
+                        .setStyle(
+                                new MessagingStyle(person)
+                                        .addMessage(
+                                                new MessagingStyle.Message(
+                                                        "Message " + personName,
+                                                        currentTimeMillis,
+                                                        person)))
+                        .setShortcutId(shortcutId);
+
+        postNotificationSync(getNextNotificationId(), builder);
+
+        return new NotificationIdentity(
+                NotificationIdentity.Type.CONVERSATION, null, personName, null, null, false, null);
+    }
+
+    /**
+     * Posts a conversation notification. This notification is associated with a conversation
+     * shortcut and in {@link android.app.Notification.MessagingStyle}.
+     *
+     * @param pkg App to launch, when clicking on notification.
+     * @param shortcutId The shortcut ID of the associated conversation.
+     * @param personName The name of the person of the associated conversation.
+     * @param messages messages of the conversation
+     */
+    public NotificationIdentity postConversationNotification(
+            String pkg,
+            String shortcutId,
+            String personName,
+            List<MessagingStyle.Message> messages) {
+        final Context context = getInstrumentation().getTargetContext();
+        final Person person = new Person.Builder().setName(personName).build();
+        final Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        final Intent intent = new android.content.Intent(Intent.ACTION_VIEW);
+
+        final ShortcutInfo shortcutInfo =
+                new ShortcutInfo.Builder(context, shortcutId)
+                        .setShortLabel(personName)
+                        .setLongLabel(personName)
+                        .setIntent(intent)
+                        .setIcon(Icon.createWithAdaptiveBitmap(bitmap))
+                        .setPerson(person)
+                        .setLongLived(true)
+                        .build();
+        final ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
+        shortcutManager.pushDynamicShortcut(shortcutInfo);
+
+        final MessagingStyle messagingStyle = new MessagingStyle(person);
+        for (MessagingStyle.Message message : messages) {
+            messagingStyle.addMessage(message);
+        }
+
+        final Builder builder = getBuilder(pkg).setStyle(messagingStyle).setShortcutId(shortcutId);
+
+        postNotificationSync(getNextNotificationId(), builder);
+
+        return new NotificationIdentity(
+                /* type= */ NotificationIdentity.Type.CONVERSATION,
+                /* title= */ null,
+                /* text= */ personName,
+                /* summary= */ null,
+                /* textWhenExpanded= */ null,
+                /* contentIsVisibleInCollapsedState= */ false,
+                /* pkg= */ null);
+    }
+
+    private Builder createBubbleNotificationPostBuilder(
+            String senderName, String text, String shortcutId, String messageToActivity) {
+        final String pkg = getInstrumentation().getTargetContext().getPackageName();
+
+        Context context = getInstrumentation().getTargetContext();
+        Person person = new Person.Builder().setName(senderName).build();
+        long currentTimeMillis = SystemClock.currentThreadTimeMillis();
+        Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888);
+        new Canvas(bitmap).drawColor(Color.BLUE);
+        Intent intent = new Intent(Intent.ACTION_SENDTO);
+        if (messageToActivity != null) {
+            intent.putExtra(EXTRA_NAME_MESSAGE, messageToActivity);
+        }
+
+        ShortcutInfo shortcutInfo =
+                new ShortcutInfo.Builder(context, shortcutId)
+                        .setShortLabel(senderName)
+                        .setLongLabel(senderName)
+                        .setIntent(intent)
+                        .setIcon(Icon.createWithAdaptiveBitmap(bitmap))
+                        .setPerson(person)
+                        .setLongLived(true)
+                        .build();
+        ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
+        shortcutManager.pushDynamicShortcut(shortcutInfo);
+
+        Notification.BubbleMetadata bubbleMetadata =
+                new Notification.BubbleMetadata.Builder(shortcutInfo.getId())
+                        .setAutoExpandBubble(false /* autoExpand */)
+                        .setSuppressNotification(false /* suppressNotif */)
+                        .build();
+
+        return getBuilder(pkg)
+                .setStyle(
+                        new MessagingStyle(person)
+                                .addMessage(
+                                        new MessagingStyle.Message(
+                                                text, currentTimeMillis, person)))
+                .setShortcutId(shortcutId)
+                .setBubbleMetadata(bubbleMetadata);
+    }
+
+    /**
+     * Posts multiple bubble notifications.
+     *
+     * @param senderName Name of notification sender.
+     * @param count How many bubble notifications to send.
+     */
+    @NonNull
+    public NotificationIdentity postBubbleNotifications(String senderName, int count) {
+        final Builder builder =
+                createBubbleNotificationPostBuilder(
+                        senderName, "Bubble message", DEFAULT_TEST_SHORTCUT_ID, null);
+
+        for (int i = 0; i < count; i++) {
+            postNotificationSync(getNextNotificationId(), builder);
+        }
+
+        return new NotificationIdentity(
+                NotificationIdentity.Type.CONVERSATION,
+                null,
+                "Bubble message",
+                null,
+                null,
+                false,
+                null);
+    }
+
+    /**
+     * Posts a bubble notification.
+     *
+     * @param id An identifier of the notification to be posted.
+     * @param senderName Name of notification sender.
+     * @param text Notification message content.
+     * @param shortcutId id of the shortcut used in the notification.
+     * @param messageToActivity message to send to bubble test activity.
+     */
+    public void postBubbleNotification(
+            int id, String senderName, String text, String shortcutId, String messageToActivity) {
+        Builder builder =
+                createBubbleNotificationPostBuilder(
+                        senderName, text, shortcutId, messageToActivity);
+
+        postNotificationSync(id, builder);
+    }
+
+    /**
+     * Posts a bubble notification.
+     *
+     * @param id An identifier of the notification to be posted.
+     * @param senderName Name of notification sender.
+     * @param text Notification message content.
+     */
+    public void postBubbleNotification(int id, String senderName, String text) {
+        postBubbleNotification(
+                id, senderName, text, DEFAULT_TEST_SHORTCUT_ID, /* messageToActivity= */ null);
+    }
+
+    /**
+     * Updates an existing bubble notification.
+     *
+     * @param id An identifier of the notification to be updated.
+     * @param senderName Name of notification sender.
+     * @param text Update message content.
+     */
+    public void updateBubbleNotification(int id, String senderName, String text) {
+        Person person = new Person.Builder().setName(senderName).build();
+        long currentTimeMillis = SystemClock.currentThreadTimeMillis();
+
+        Notification.BubbleMetadata bubbleMetadata =
+                new Notification.BubbleMetadata.Builder(DEFAULT_TEST_SHORTCUT_ID)
+                        .setAutoExpandBubble(false /* autoExpand */)
+                        .setSuppressNotification(false /* suppressNotif */)
+                        .build();
+
+        Builder builder =
+                getBuilder(PACKAGE_NAME)
+                        .setStyle(
+                                new Notification.MessagingStyle(person)
+                                        .addMessage(
+                                                new MessagingStyle.Message(
+                                                        text, currentTimeMillis, person)))
+                        .setShortcutId(DEFAULT_TEST_SHORTCUT_ID)
+                        .setBubbleMetadata(bubbleMetadata);
+
+        NOTIFICATION_MANAGER.notify(id, builder.build());
+    }
+
+    private static void postNotificationSync(int id, Builder builder) {
+        // By default, we add a group key with the same id as the notification so that it is not
+        // grouped with other notifications, making sure that the notification count is incremented
+        // only by 1 when we already posted another notifications, and not by 2 which will happen
+        // if a new group is formed (as a group also counts as 1 notification). This avoids race
+        // conditions when adding a lot of consecutive notifications.
+        postNotificationSync(id, builder, getGroupKey(id));
+    }
+
+    private static String getGroupKey(int id) {
+        return String.format(NOTIFICATION_GROUP_KEY_FORMAT, id);
+    }
+
+    private static void postNotificationSync(int id, Builder builder, String groupKey) {
+        final int initialCount = getNotificationCount();
+        final Notification notification = builder.setGroup(groupKey).build();
+        NOTIFICATION_MANAGER.notify(id, notification);
+        waitUntilPostedNotificationsCountMatches(initialCount + 1);
+    }
+
+    /**
+     * Returns the current total number of posted notifications. If you've just posted a
+     * notification via NOTIFICATION_MANAGER.notify, this count isn't guaranteed to be correct
+     * unless you've waited for it to arrive. If the notification is posted by postNotificationSync,
+     * the count will be correct after posting. Use only postNotificationSync to post notifications.
+     */
+    private static int getNotificationCount() {
+        return NOTIFICATION_MANAGER.getActiveNotifications().length;
+    }
+
+    private static boolean hasNotification(int id) {
+        StatusBarNotification[] activeNotifications = NOTIFICATION_MANAGER.getActiveNotifications();
+        for (StatusBarNotification notification : activeNotifications) {
+            if (notification.getId() == id) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean hasNotificationWithFlag(int id, int flag) {
+        StatusBarNotification[] activeNotifications = NOTIFICATION_MANAGER.getActiveNotifications();
+        for (StatusBarNotification notification : activeNotifications) {
+            if (notification.getId() == id && (notification.getNotification().flags & flag) != 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static void waitUntilNotificationPosted(int id) {
+        waitForCondition(() -> "Notification was not posted.", () -> hasNotification(id));
+    }
+
+    private static void waitUntilNotificationCancelled(int id) {
+        waitForCondition(() -> "Notification is still present.", () -> !hasNotification(id));
+    }
+
+    private static void waitUntilNotificationUpdatedWithFlag(int id, int flag) {
+        waitForCondition(
+                () -> "Notification was not posted with flag.",
+                () -> (hasNotificationWithFlag(id, flag)));
+    }
+
+    private static void waitUntilPostedNotificationsCountMatches(int count) {
+        waitForCondition(
+                () ->
+                        "Notification count didn't become "
+                                + count
+                                + ". It is currently equal to "
+                                + getNotificationCount(),
+                () -> getNotificationCount() == count);
+    }
+
+    private static Builder getBuilder(String pkg) {
+        return getBuilder(pkg, Importance.DEFAULT);
+    }
+
+    private static Builder getBuilder(String pkg, Importance importance) {
+        Context context = getInstrumentation().getTargetContext();
+
+        final String channelId =
+                switch (importance) {
+                    case HIGH -> NOTIFICATION_CHANNEL_HIGH_IMPORTANCE_ID;
+                    case DEFAULT -> NOTIFICATION_CHANNEL_DEFAULT_IMPORTANCE_ID;
+                    case LOW -> NOTIFICATION_CHANNEL_LOW_IMPORTANCE_ID;
+                    case MIN -> NOTIFICATION_CHANNEL_MIN_IMPORTANCE_ID;
+                };
+        Builder builder =
+                new Builder(context, channelId)
+                        .setContentTitle(NOTIFICATION_TITLE_TEXT)
+                        .setCategory(CATEGORY_SYSTEM)
+                        .setGroupSummary(false)
+                        .setContentText(NOTIFICATION_CONTENT_TEXT)
+                        .setShowWhen(false)
+                        .setSmallIcon(android.R.drawable.stat_notify_chat);
+        if (pkg != null) {
+            builder.setContentIntent(getLaunchIntent(pkg));
+        }
+        return builder;
+    }
+
+    private static PendingIntent getLaunchIntent(String pkg) {
+        Context context = getInstrumentation().getTargetContext();
+        return PendingIntent.getActivity(
+                context,
+                0,
+                context.getPackageManager().getLaunchIntentForPackage(pkg),
+                Intent.FLAG_ACTIVITY_NEW_TASK | FLAG_IMMUTABLE);
+    }
+
+    private static void postNotifications(int count, String pkg, boolean isMessaging) {
+        Builder builder = getBuilder(pkg);
+        if (isMessaging) {
+            Person person = new Person.Builder().setName("Marvelous user").build();
+            builder.setStyle(
+                    new MessagingStyle(person)
+                            .addMessage(
+                                    new MessagingStyle.Message(
+                                            "Hello",
+                                            SystemClock.currentThreadTimeMillis(),
+                                            person)));
+        }
+
+        for (int i = (count - 1); i >= 0; i--) {
+            builder.setContentText(String.format(NOTIFICATION_CONTENT_TEXT_FORMAT, i));
+            postNotificationSync(getNextNotificationId(), builder);
+        }
+    }
+
+    /** Cancels all notifications posted by this object. */
+    public void cancelNotifications() {
+        NOTIFICATION_MANAGER.cancelAll();
+        waitUntilPostedNotificationsCountMatches(0);
+    }
+
+    /**
+     * Set or reset avalanche suppression.
+     *
+     * @param disabledForTest If true, disable; otherwise reset to default.
+     */
+    public void setCooldownSettingDisabled(boolean disabledForTest) {
+        StringBuilder sb = new StringBuilder();
+        StringBuilder command = new StringBuilder("");
+        if (disabledForTest) {
+            command.append("settings put system notification_cooldown_enabled 0");
+        } else {
+            command.append("settings reset system notification_cooldown_enabled");
+        }
+        runCommandAndCollectResult("set avalanche suppression", command.toString(), sb);
+        Log.d(LOG_TAG, sb.toString());
+    }
+
+    private static String runCommandAndCollectResult(
+            String description, String cmd, StringBuilder sb) {
+        if (cmd == null || sb == null) {
+            return null;
+        }
+        String result = null;
+        try {
+            Log.d(LOG_TAG, "Before command: " + cmd);
+            result = getUiDevice().executeShellCommand(cmd);
+            String msg = String.format("%s command: %s\nResult: %s\n", description, cmd, result);
+            Log.d(LOG_TAG, msg);
+            sb.append(msg);
+        } catch (IOException ioe) {
+            Log.e(LOG_TAG, "Failed to run command: " + cmd, ioe);
+        }
+        return result;
+    }
+
+    /**
+     * Set up or clear the debug filter; restricting notifications to the provided packages, or
+     * resetting if none are provided.
+     *
+     * @param allowedPackages package names allowed to show notifications
+     */
+    private void setDebugNotificationFilter(@Nullable List<String> allowedPackages) {
+        StringBuilder sb = new StringBuilder();
+        StringBuilder command = new StringBuilder("cmd statusbar notif-filter ");
+        if (allowedPackages == null || allowedPackages.isEmpty()) {
+            command.append("reset");
+        } else {
+            command.append("allowed-pkgs");
+            for (String pkg : allowedPackages) {
+                command.append(" ");
+                command.append(pkg);
+            }
+        }
+        runCommandAndCollectResult("set debug filter", command.toString(), sb);
+        Log.d(LOG_TAG, sb.toString());
+    }
+
+    /**
+     * Set up or clear the debug filter; restricting notifications to the test package, or resetting
+     * if false is provided.
+     *
+     * @param enabled whether to enable the debug filter
+     */
+    public void setDebugNotificationFilter(boolean enabled) {
+        setDebugNotificationFilter(enabled ? List.of(PACKAGE_NAME) : null);
+    }
+
+    /**
+     * Holds the identities of a group summary and children as posted by {@link
+     * NotificationController#postGroupNotifications(int, String, String, boolean)}.
+     */
+    public static class GroupNotificationIdentities {
+        public NotificationIdentity summary = null;
+        public List<NotificationIdentity> children = new ArrayList<NotificationIdentity>();
+    }
+
+    /**
+     * The importance of the Notification to be posted.
+     *
+     * @see NotificationChannel#setImportance(int)
+     */
+    public enum Importance {
+        HIGH,
+        DEFAULT,
+        LOW,
+        MIN
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt
new file mode 100644
index 000000000..5753188fc
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/NotificationIdentity.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+/**
+ * A way to uniquely identify a notification. It's produced by posting a notification and can be
+ * passed to methods for finding a notification.
+ */
+data class NotificationIdentity
+@JvmOverloads
+constructor(
+    val type: Type,
+    val title: String? = null,
+    val text: String? = null,
+    val summary: String? = null,
+    val textWhenExpanded: String? = null,
+    val contentIsVisibleInCollapsedState: Boolean = false,
+    val pkg: String? = null,
+    val hasAction: Boolean = false,
+) {
+    enum class Type {
+        GROUP,
+        GROUP_MINIMIZED,
+        GROUP_AUTO_GENERATED,
+        BIG_PICTURE,
+        BIG_TEXT,
+        MESSAGING_STYLE,
+        CONVERSATION,
+        BY_TITLE,
+        BY_TEXT,
+        CALL,
+        INBOX,
+        MEDIA,
+        CUSTOM,
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/PowerController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/PowerController.java
new file mode 100644
index 000000000..9aaea6294
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/PowerController.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.platform.helpers.CommonUtils.executeShellCommand;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+import static android.view.KeyEvent.KEYCODE_POWER;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.provider.Settings;
+import android.util.Log;
+
+/** Controller for manipulating power button behavior and actions. */
+public class PowerController {
+    private static final String TAG = "PowerController";
+    private static final String POWER_COMMAND =
+            String.format("input keyevent --longpress  %s", KEYCODE_POWER);
+    private static final String POWER_BUTTON_LONG_PRESS_BEHAVIOR = "power_button_long_press";
+
+    /** Returns an instance of PowerController. */
+    public static PowerController get() {
+        return new PowerController();
+    }
+
+    private PowerController() {}
+
+    /** Mimics long-pressing the power button. */
+    public void longPressPowerButton() {
+        executeShellCommand(POWER_COMMAND);
+    }
+
+    /**
+     * Sets the behavior of the long press of the power button. See config_longPressOnPowerBehavior.
+     *
+     * @param behavior new behavior
+     * @return old behavior
+     */
+    public int setLongPressOnPowerBehavior(int behavior) {
+        final Context context = getContext();
+        int oldLongPressPowerKeyBehavior;
+        try {
+            oldLongPressPowerKeyBehavior =
+                    Settings.Global.getInt(
+                            context.getContentResolver(), POWER_BUTTON_LONG_PRESS_BEHAVIOR);
+        } catch (Settings.SettingNotFoundException e) {
+            Log.w(TAG, "Global settings POWER_BUTTON_LONG_PRESS do not exist.");
+            oldLongPressPowerKeyBehavior = 0;
+        }
+        assertThat(
+                        Settings.Global.putInt(
+                                context.getContentResolver(),
+                                POWER_BUTTON_LONG_PRESS_BEHAVIOR,
+                                behavior))
+                .isTrue();
+
+        return oldLongPressPowerKeyBehavior;
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/QuickSettingsController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/QuickSettingsController.java
new file mode 100644
index 000000000..be047468e
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/QuickSettingsController.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.platform.uiautomator_helpers.DeviceHelpers.getUiDevice;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+
+import android.system.helpers.QuickSettingsHelper;
+
+import java.util.List;
+
+/** Controller for manipulating quick settings contents. */
+public class QuickSettingsController {
+    private final QuickSettingsHelper mHelper;
+
+    /** Returns an instance of QuickSettingsController. */
+    public static QuickSettingsController get() {
+        return new QuickSettingsController();
+    }
+
+    private QuickSettingsController() {
+        mHelper = new QuickSettingsHelper(getUiDevice(), getInstrumentation());
+    }
+
+    /** Places a tile in quick settings as the first tile. Add the tile if necessary */
+    public void addAsFirstTile(String tileName) {
+        mHelper.setFirstQS(tileName);
+    }
+
+    /** Restore the default tile set. */
+    public void restoreDefaultTiles() {
+        mHelper.setQuickSettingsDefaultTiles();
+    }
+
+    /** Gets the list of default QS tiles. */
+    public List<String> getDefaultTiles() {
+        return mHelper.getQSDefaultTileList();
+    }
+
+    /** Gets the list of current QS tiles. */
+    public List<String> getCurrentTiles() {
+        return mHelper.getCurrentTilesList();
+    }
+
+    /**
+     * Sets the list of tiles to a given list.
+     *
+     * @param tiles list of specs for the tiles.
+     */
+    public void setTiles(List<String> tiles) {
+        mHelper.modifyQSTileList(tiles);
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/ShadeController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/ShadeController.java
new file mode 100644
index 000000000..c4d68b2e1
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/ShadeController.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import android.platform.helpers.CommonUtils;
+
+/** Controller for retrieving shade state and controlling it */
+public class ShadeController {
+
+    private ShadeController() {}
+
+    public static ShadeController get() {
+        return new ShadeController();
+    }
+
+    /**
+     * Checks the state of the split shade
+     *
+     * @return true if the shade is split
+     */
+    public boolean isSplitShade() {
+        return CommonUtils.isSplitShade();
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/StatusBarController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/StatusBarController.java
new file mode 100644
index 000000000..bcaa1da1f
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/StatusBarController.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.platform.uiautomator_helpers.DeviceHelpers.getUiDevice;
+import static android.platform.uiautomator_helpers.DeviceHelpers.shell;
+
+/** Controller for manipulating status bar state. */
+public class StatusBarController {
+    private static final String SHOW_BATTERY_PERCENT_SETTING = "status_bar_show_battery_percent";
+
+    private StatusBarController() {}
+
+    /** Returns an instance of StatusBarController. */
+    public static StatusBarController get() {
+        return new StatusBarController();
+    }
+
+    /** If the user wants to see the batter percentage on the status bar. */
+    private static boolean shouldShowBatteryPercentage() {
+        return "1"
+                .equals(
+                        shell(getUiDevice(), "settings get system " + SHOW_BATTERY_PERCENT_SETTING)
+                                .trim());
+    }
+
+    private static void setBatteryPercentageVisibleInternal(boolean visible) {
+        shell(
+                getUiDevice(),
+                "settings put system " + SHOW_BATTERY_PERCENT_SETTING + " " + (visible ? 1 : 0));
+    }
+
+    /**
+     * Shows or hides the battery percentage indicator.
+     *
+     * @param visible show?
+     * @return previous visibility.
+     */
+    public boolean setBatteryPercentageVisible(boolean visible) {
+        boolean wasPercentageVisible = shouldShowBatteryPercentage();
+        setBatteryPercentageVisibleInternal(visible);
+        return wasPercentageVisible;
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/SysUiFlagController.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/SysUiFlagController.kt
new file mode 100644
index 000000000..fe2b4c1bb
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/SysUiFlagController.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+import android.platform.uiautomator_helpers.DeviceHelpers.shell
+import android.platform.uiautomator_helpers.DeviceHelpers.uiDevice
+
+private const val BASE_FLAG_COMMAND = "cmd statusbar flag"
+
+class SysUiFlagController private constructor() {
+
+    /** Sets the flag value to [newValue]. */
+    fun setValue(flag: SystemUIFlag, newValue: String) {
+        uiDevice.shell("${BASE_FLAG_COMMAND} ${flag.flagName} $newValue")
+    }
+
+    /** `True` when the flag is enabled. */
+    fun isEnabled(flag: SystemUIFlag): Boolean =
+        uiDevice.shell("$BASE_FLAG_COMMAND ${flag.flagName}").trim().endsWith("true")
+
+    /** Resets the flag to the default value. */
+    fun reset(flag: SystemUIFlag) {
+        uiDevice.shell("$BASE_FLAG_COMMAND ${flag.flagName} erase")
+    }
+
+    /** List of SysUI flags used by tests. */
+    enum class SystemUIFlag(val flagName: String) {
+        FULL_SCREEN_USER_SWITCHER("full_screen_user_switcher")
+    }
+
+    companion object {
+        fun get() = SysUiFlagController()
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/UserController.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/UserController.java
new file mode 100644
index 000000000..b8dc5d802
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/UserController.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller;
+
+import static android.platform.helpers.CommonUtils.executeShellCommand;
+import static android.platform.test.util.HealthTestingUtils.waitForCondition;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getContext;
+import static android.platform.uiautomator_helpers.DeviceHelpers.getUiDevice;
+import static android.platform.uiautomator_helpers.DeviceHelpers.shell;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.app.ActivityManager;
+import android.content.pm.UserInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.NewUserRequest;
+import android.os.NewUserResponse;
+import android.os.UserManager;
+import android.platform.helpers.CommonUtils;
+import android.platform.systemui_tapl.utils.UserUtils;
+import android.system.helpers.UserHelper;
+
+import androidx.annotation.Nullable;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.concurrent.CountDownLatch;
+
+/** Controller for manipulating users. */
+public class UserController {
+
+    // TODO(b/264023316): Reduce once fixed.
+    private static final int VERIFICATION_TIME_IN_SECONDS = 90;
+    private static final String USER_SWITCHER_VISIBLE_FLAG_CMD = "cmd statusbar flag 204";
+
+    /** Returns an instance of UserController. */
+    public static UserController get() {
+        return new UserController();
+    }
+
+    private UserController() {}
+
+    /** Switch to given user directly, not via any switcher UI. */
+    public void switchToUser(int userId) {
+        // TODO(b/192001071): Consider just returning getActivityManager().switchUser(user.id);
+        //                    instead. Avoids shell, but then you lose the advantages of "-w".
+        if (getCurrentUserId() == userId) return;
+        // Go to user, waiting until action is completed.
+        UserUtils.runThenWaitUntilSwitchCompleted(
+                () ->
+                        executeShellCommand(
+                                String.format(Locale.US, "am switch-user -w %d", userId)));
+        waitForCondition(
+                () -> "Current user didn't become " + userId,
+                () -> CommonUtils.getCurrentUserId() == userId);
+    }
+
+    /** Returns current user ID. UserID = 0 is for System User. */
+    public int getCurrentUserId() {
+        return CommonUtils.getCurrentUserId();
+    }
+
+    /**
+     * Returns the main user ID. NOTE: For headless system it is NOT 0. Returns 0 by default, if
+     * there is no main user.
+     */
+    public int getMainUserId() {
+        return CommonUtils.getMainUserId();
+    }
+
+    private static UserManager getUserManager() {
+        return UserHelper.getInstance().getUserManager();
+    }
+
+    /** Creates a user with specified name and returns its id. */
+    public int createSecondaryUser(String userName) {
+        Optional<Integer> userId = tryCreatingSecondaryUser(userName);
+        assertWithMessage("Failed user creation").that(userId.isPresent()).isTrue();
+        return userId.get();
+    }
+
+    /**
+     * Create a secondary user with specific icon color.
+     *
+     * @see #createSecondaryUser(String)
+     */
+    public int createSecondaryUser(String userName, int iconColor) {
+        Optional<Integer> userId =
+                tryCreatingSecondaryUserImpl(userName, defaultUserIcon(iconColor));
+        assertWithMessage("Failed to create user with icon color.")
+                .that(userId.isPresent())
+                .isTrue();
+        return userId.get();
+    }
+
+    /**
+     * Try to create a secondary user. This function is mainly for testing corner cases, which
+     * expects the user creation will fail.
+     */
+    public Optional<Integer> tryCreatingSecondaryUser(String userName) {
+        return tryCreatingSecondaryUserImpl(
+                userName,
+                /* userIcon= */
+                null);
+    }
+
+    private Optional<Integer> tryCreatingSecondaryUserImpl(
+            String userName, @Nullable Bitmap userIcon) {
+        NewUserRequest request =
+                new NewUserRequest.Builder().setName(userName).setUserIcon(userIcon).build();
+        final NewUserResponse resp = getUserManager().createUser(request);
+        if (!resp.isSuccessful()) {
+            return Optional.empty();
+        }
+        return Optional.of(resp.getUser().getIdentifier());
+    }
+
+    private Bitmap defaultUserIcon(int color) {
+        Resources resources = getContext().getResources();
+        int iconSize = resources.getDimensionPixelSize(com.android.internal.R.dimen.user_icon_size);
+        Drawable iconDrawable =
+                getContext().getDrawable(com.android.internal.R.drawable.ic_account_circle);
+        iconDrawable.setColorFilter(color, Mode.MULTIPLY);
+        Bitmap iconBitmap = Bitmap.createBitmap(iconSize, iconSize, Config.ARGB_8888);
+        Canvas canvas = new Canvas(iconBitmap);
+        iconDrawable.setBounds(new Rect(0, 0, iconSize, iconSize));
+        iconDrawable.draw(canvas);
+        return iconBitmap;
+    }
+
+    /** Returns all users except for the primary and the system user. */
+    public Collection<Integer> getSecondaryUsers() {
+        final HashSet<Integer> secondaryUsers = new HashSet<>();
+        List<UserInfo> userInfoList = getUserManager().getAliveUsers();
+        for (UserInfo userInfo : userInfoList) {
+            // Remove all users except for the primary / system user
+            if (!userInfo.isPrimary()) {
+                secondaryUsers.add(userInfo.id);
+            }
+        }
+        return secondaryUsers;
+    }
+
+    private static boolean hasGuest() {
+        return getUserManager().findCurrentGuestUser() != null;
+    }
+
+    /** Creates a guest user. */
+    public void createGuest() {
+        try {
+            assertThat(hasGuest()).isFalse();
+            CountDownLatch countDownLatch = new CountDownLatch(1);
+            new Thread(
+                            () -> {
+                                getUserManager().createGuest(getContext());
+                                countDownLatch.countDown();
+                            })
+                    .start();
+            countDownLatch.await();
+        } catch (InterruptedException exception) {
+            throw new RuntimeException("Create guest failed.", exception);
+        }
+    }
+
+    private static ActivityManager getActivityManager() {
+        return getContext().getSystemService(ActivityManager.class);
+    }
+
+    /** Stop the provided user. */
+    public void stopUser(int userId) {
+        executeShellCommand(String.format(Locale.US, "am stop-user -w %d", userId));
+
+        assertWithMessage("Failed to stop userId=" + userId)
+                .that(getActivityManager().isUserRunning(userId))
+                .isFalse();
+    }
+
+    /** Returns whether the given user is actively running. */
+    public boolean isUserRunning(int userId) {
+        return getActivityManager().isUserRunning(userId);
+    }
+
+    /** Returns whether the project supports user switcher chip. */
+    public boolean isUserSwitcherChipSupported() {
+        return shell(getUiDevice(), USER_SWITCHER_VISIBLE_FLAG_CMD).trim().endsWith("true");
+    }
+
+    /** Return the maximum number of users that are allowed in the current device. */
+    public int getMaxUsers() {
+        return getUserManager().getMaxSupportedUsers();
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/VolumeController.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/VolumeController.kt
new file mode 100644
index 000000000..b0c0f9826
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/VolumeController.kt
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+import android.Manifest.permission
+import android.content.ContentResolver
+import android.media.AudioManager
+import android.os.VibratorManager
+import android.platform.uiautomator_helpers.DeviceHelpers.context
+import android.platform.uiautomator_helpers.ShellPrivilege
+import android.platform.uiautomator_helpers.WaitUtils.ensureThat
+import android.provider.Settings
+
+/** Controller for adjusting the device volume. */
+class VolumeController private constructor() {
+
+    private val audioManager: AudioManager =
+        context.getSystemService(AudioManager::class.java)
+            ?: error("Can't get the AudioManager for ${VolumeController::class}}")
+
+    /** Available ringer modes defined in [AudioManager] */
+    enum class RingerMode(internal val mode: Int) {
+        NORMAL(AudioManager.RINGER_MODE_NORMAL),
+        SILENT(AudioManager.RINGER_MODE_SILENT),
+        VIBRATE(AudioManager.RINGER_MODE_VIBRATE);
+
+        /** Whether the ringer mode is available on the device under test. */
+        val isAvailable: Boolean
+            get() {
+                return when (this) {
+                    NORMAL,
+                    SILENT -> true
+                    VIBRATE -> hasVibrator
+                }
+            }
+    }
+
+    /**
+     * Adjusts the volume to ADJUST_SAME.
+     *
+     * This method can be used to show the volume dialog.
+     *
+     * Note: ADJUST_SAME here means [AudioManager.ADJUST_SAME]. It tells AudioManager the direction
+     * to change the volume, which is to keep the slider as is.
+     */
+    fun adjustVolumeSame() = adjustVolume(AudioManager.ADJUST_SAME)
+
+    /** Adjusts the volume to ADJUST_LOWER. Shows the volume dialog. */
+    fun adjustVolumeLower() = adjustVolume(AudioManager.ADJUST_LOWER)
+
+    /** Adjusts the volume to ADJUST_RAISE. Shows the volume dialog. */
+    fun adjustVolumeRaise() = adjustVolume(AudioManager.ADJUST_RAISE)
+
+    private fun adjustVolume(direction: Int) {
+        audioManager.adjustSuggestedStreamVolume(
+            direction,
+            AudioManager.STREAM_MUSIC,
+            AudioManager.FLAG_SHOW_UI,
+        )
+    }
+
+    /**
+     * The current Music stream's volume. This setter won't bring up volume dialog. Use
+     * [adjustVolumeSame] instead if you want to open the dialog.
+     */
+    var volume: Int
+        get() = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
+        set(volumeIndex) {
+            audioManager.setStreamVolume(
+                AudioManager.STREAM_MUSIC,
+                volumeIndex,
+                0, // Do nothing, prevent opening UI.
+            )
+            ensureThat("music volume == ${volumeIndex}") { volume == volumeIndex }
+        }
+
+    /**
+     * Set SysUI's internal ringer mode state.
+     *
+     * Notice that it requires STATUS_BAR_SERVICE permission to complete the setup. If the caller
+     * doesn't have the permission, the function will try to automatically grant the permission for
+     * the caller. However, it may throw [SecurityException] if the caller has called
+     * [android.app.UiAutomation.adoptShellPermissionIdentity] before. Therefore, use this function
+     * carefully.
+     *
+     * @param ringerMode[RingerMode]
+     */
+    fun setRingerModeInternal(ringerMode: RingerMode) {
+        ShellPrivilege(permission.STATUS_BAR_SERVICE).use {
+            audioManager.ringerModeInternal = ringerMode.mode
+        }
+    }
+
+    /**
+     * Sets volume dialog timeout in ms.
+     *
+     * This method is called to set the timeout to a longer value to help the test to recognize its
+     * visibility.
+     *
+     * Use [SetVolumeDialogTimeoutRule] in order to control the timeout value during the test only.
+     *
+     * @param cr content resolver.
+     * @param timeout long press timeout.
+     */
+    fun setVolumeDialogTimeout(cr: ContentResolver, timeout: Int) {
+        Settings.Secure.putInt(cr, Settings.Secure.VOLUME_DIALOG_DISMISS_TIMEOUT, timeout)
+    }
+
+    /** ringerMode is the current available Audio ringer mode. */
+    val ringerMode: RingerMode
+        get() {
+            val ringerMode = audioManager.ringerMode
+            return RingerMode.values().firstOrNull { it.mode == ringerMode }
+                ?: error("Ringer mode $ringerMode isn't defined in ${RingerMode::class}")
+        }
+
+    /** Maximum volume of music stream. The value may be different based on the device's setting. */
+    val maxVolume: Int
+        get() = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)
+
+    /** Minimum volume of music stream. The value may be different based on the device's setting. */
+    val minVolume: Int
+        get() = audioManager.getStreamMinVolume(AudioManager.STREAM_MUSIC)
+
+    companion object {
+        @JvmStatic
+        private val hasVibrator: Boolean
+            get() =
+                context
+                    .getSystemService(VibratorManager::class.java)!!
+                    .defaultVibrator
+                    .hasVibrator()
+
+        /** Returns an instance of VolumeController. */
+        @JvmStatic
+        fun get(): VolumeController {
+            return VolumeController()
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/users.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/users.kt
new file mode 100644
index 000000000..5ca7f2306
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/controller/users.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.controller
+
+import android.system.helpers.UserHelper
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
+
+/** Removes a specified set of secondary users. */
+fun removeSecondaryUsers(usersToRemove: Collection<Int>) {
+    runBlocking(Dispatchers.IO) {
+        for (userId in usersToRemove) {
+            launch { UserHelper.getInstance().removeSecondaryUser(userId) }
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt
new file mode 100644
index 000000000..78daa8104
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/permissions/rule/AdoptShellPermissionsRule.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.permissions.rule
+
+import android.app.UiAutomation
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.rules.TestWatcher
+import org.junit.runner.Description
+
+/**
+ * Adopts shell [permissions] identity for the [uiAutomation].
+ *
+ * @see
+ *   cts/common/device-side/util-axt/src/com/android/compatibility/common/util/AdoptShellPermissionsRule.java
+ * @see UiAutomation.adoptShellPermissionIdentity
+ */
+class AdoptShellPermissionsRule(
+    vararg permissions: String,
+    private val uiAutomation: UiAutomation =
+        InstrumentationRegistry.getInstrumentation().uiAutomation,
+) : TestWatcher() {
+
+    private val permissionSet: Set<String> = permissions.toSet()
+
+    init {
+        require(permissionSet.isNotEmpty())
+    }
+
+    override fun starting(description: Description?) {
+        super.starting(description)
+        for (permission in permissionSet) {
+            uiAutomation.adoptShellPermissionIdentity(permission)
+        }
+        Log.d("AdoptShellPermissionsRule", "Adopted identities=${permissionSet}")
+    }
+
+    override fun finished(description: Description?) {
+        uiAutomation.dropShellPermissionIdentity()
+        Log.d("AdoptShellPermissionsRule", "Dropped adopted identities")
+        super.finished(description)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPanel.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPanel.kt
new file mode 100644
index 000000000..776b3d0ca
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPanel.kt
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.UserUtils.runThenWaitUntilSwitchCompleted
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import java.util.regex.Pattern
+
+/**
+ * System UI test automation object representing the panel for adding the new user.
+ * https://hsv.googleplex.com/6238141703782400
+ */
+class AddUserPanel internal constructor() {
+
+    init {
+        TITLE_SELECTOR.assertVisible { "Add user panel is not visible" }
+    }
+
+    /** Clicks on the OK button. */
+    fun OK() {
+        runThenWaitUntilSwitchCompleted {
+            waitForObj(OK_SELECTOR) { "OK Button not found" }.click()
+        }
+    }
+
+    /** Clicks on the cancel button. */
+    fun cancel() {
+        waitForObj(CANCEL_SELECTOR) { "Cancel button not found" }.click()
+    }
+
+    /** Sets the user name. */
+    fun setUserName(userName: String) {
+        val editNameField = waitForObj(EDIT_NAME_SELECTOR) { "Name edit field not found" }
+        editNameField.click()
+        editNameField.text = userName
+    }
+
+    companion object {
+        // https://hsv.googleplex.com/6238141703782400?node=7
+        private val TITLE_SELECTOR =
+            androidResSelector("alertTitle")
+                .text(Pattern.compile("Add user", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/6238141703782400?node=18
+        private val OK_SELECTOR =
+            androidResSelector("button1").text(Pattern.compile("OK", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/6238141703782400?node=17
+        private val CANCEL_SELECTOR =
+            androidResSelector("button2").text(Pattern.compile("Cancel", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/6238141703782400?node=17
+        private val EDIT_NAME_SELECTOR = sysuiResSelector("user_name")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPrompt.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPrompt.kt
new file mode 100644
index 000000000..83bc17f84
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AddUserPrompt.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import java.util.regex.Pattern
+
+/**
+ * System UI test automation object representing the dialog for adding the new user from quick
+ * settings.
+ *
+ * https://hsv.googleplex.com/5360066535358464
+ */
+class AddUserPrompt internal constructor() {
+    /** Clicks on the OK button. https://hsv.googleplex.com/5360066535358464?node=15 */
+    fun clickOkToOpenAddUserPanel(): AddUserPanel {
+        TITLE_SELECTOR.assertVisible()
+        waitForObj(OK_SELECTOR) { "OK button not found" }.click()
+        return AddUserPanel()
+    }
+
+    /** Clicks on the cancel button. https://hsv.googleplex.com/5360066535358464?node=14 */
+    fun cancel() {
+        TITLE_SELECTOR.assertVisible()
+        waitForObj(CANCEL_SELECTOR) { "Cancel button not found" }.click()
+    }
+
+    companion object {
+        // https://hsv.googleplex.com/5360066535358464?node=11
+        private val TITLE_SELECTOR =
+            By.res("com.android.systemui:id/dialog_with_icon_title")
+                .text(Pattern.compile("Add new user\\?", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/5360066535358464?node=15
+        private val OK_SELECTOR =
+            By.res("com.android.systemui:id/button_ok")
+                .text(Pattern.compile("Next", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/5360066535358464?node=14
+        private val CANCEL_SELECTOR =
+            By.res("com.android.systemui:id/button_cancel")
+                .text(Pattern.compile("Cancel", Pattern.CASE_INSENSITIVE))
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AlertDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AlertDialog.kt
new file mode 100644
index 000000000..d06fb2e3b
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/AlertDialog.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import com.android.launcher3.tapl.LauncherInstrumentation
+
+/** System UI test automation object representing an alert dialog. */
+class AlertDialog internal constructor() {
+
+    init {
+        UI_DIALOG_TITLE.assertVisible()
+    }
+
+    /** Asserts visibility of the 'negative' button in the dialog */
+    fun assertNegativeButtonVisibility(visible: Boolean) {
+        uiDevice.assertVisibility(androidResSelector(UI_ALERT_DIALOG_NEGATIVE_BUTTON_ID), visible)
+    }
+
+    /* Dismisses the dialog by the Back gesture */
+    fun dismiss() {
+        // Press back to dismiss the dialog
+        LauncherInstrumentation().pressBack()
+        UI_DIALOG_TITLE.assertInvisible()
+    }
+
+    companion object {
+        private const val UI_DIALOG_TITLE_ID = "alertTitle"
+        private const val UI_ALERT_DIALOG_NEGATIVE_BUTTON_ID = "button2"
+        private val UI_DIALOG_TITLE = androidResSelector(UI_DIALOG_TITLE_ID)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt
new file mode 100644
index 000000000..4863acf1a
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Aod.kt
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+
+/** System UI test automation object representing the always-on-display. */
+class Aod internal constructor() {
+    init {
+        LockScreen.LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt
new file mode 100644
index 000000000..97d612874
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BluetoothDialog.kt
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitResult
+import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
+import android.platform.uiautomatorhelpers.scrollUntilFound
+import android.util.Log
+
+/** Wrapper representing the BluetoothDialog that opens when the QS Tile is clicked */
+class BluetoothDialog internal constructor() {
+    val scrollView =
+        waitForObj(
+            sysuiResSelector(SCROLL_VIEW_RES_ID)
+                .hasParent(sysuiResSelector(BLUETOOTH_TILE_DIALOG_RES_ID))
+        )
+
+    /** Finds the done button, clicks on it and asserts that the dialog has closed. */
+    fun clickOnDoneAndClose() {
+        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
+        doneButton.click()
+        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
+            Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
+            doneButton.click()
+        }
+        DONE_BTN.assertInvisible(errorProvider = { "Bluetooth tile dialog is dismissed" })
+    }
+
+    private companion object {
+        val DONE_BTN = sysuiResSelector("done_button")
+        const val SCROLL_VIEW_RES_ID = "scroll_view"
+        const val BLUETOOTH_TILE_DIALOG_RES_ID = "root"
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bouncer.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bouncer.kt
new file mode 100644
index 000000000..6d32f2486
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bouncer.kt
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.graphics.Rect
+import android.os.SystemClock.sleep
+import android.platform.helpers.Constants
+import android.platform.helpers.LockscreenUtils
+import android.platform.helpers.LockscreenUtils.LockscreenType
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
+import android.platform.uiautomatorhelpers.BetterSwipe.from
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.doubleTapAt
+import android.platform.uiautomatorhelpers.DeviceHelpers.shell
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.assertOnTheLeftSide
+import android.platform.uiautomatorhelpers.assertOnTheRightSide
+import android.platform.uiautomatorhelpers.stableBounds
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiObject2
+import com.google.common.truth.Truth
+import java.time.Duration
+import java.util.regex.Pattern
+
+/** System UI test automation object representing the lockscreen bouncer. */
+class Bouncer internal constructor(private val notification: Notification?) {
+    private val uiObject: UiObject2 = waitForFirstObj(*BOUNCER_SELECTORS, timeout = LONG_WAIT).first
+
+    private fun enterCodeOnBouncer(lockscreenType: LockscreenType, lockCode: String) {
+        LOCKSCREEN_TEXT_BOX_SELECTOR.assertVisible { "Lockscreen text box is not visible" }
+        LOCKSCREEN_TEXT_BOX_SELECTOR.click()
+        LockscreenUtils.enterCodeOnLockscreen(lockscreenType, lockCode)
+    }
+
+    /**
+     * Enters pattern based on a string which contains digits between 1-9 to represent a 3x3 grid.
+     *
+     * The constraint here is that the pattern must start with 5 (the center) as we use the center
+     * of the lock pattern view as a reference on where to swipe.
+     */
+    fun enterPattern(pattern: String) {
+        Truth.assertWithMessage("#enterPattern argument does not start with 5")
+            .that(pattern.isNotEmpty() && pattern[0] == '5')
+            .isTrue()
+        val lockPatternView = waitForObj(PATTERN_SELECTOR)
+        val visibleCenter = lockPatternView.visibleCenter
+        val visibleBounds = lockPatternView.visibleBounds
+        val points = mutableListOf<Point>()
+        val centerPoint = Point(visibleCenter.x, visibleCenter.y)
+        for (c in pattern.substring(1).toCharArray()) {
+            points.add(centerPoint)
+            points.add(
+                when (c) {
+                    '1' -> visibleBounds.left to visibleBounds.top
+                    '2' -> visibleCenter.x to visibleBounds.top
+                    '3' -> visibleBounds.right to visibleBounds.top
+                    '4' -> visibleBounds.left to visibleCenter.y
+                    '5' -> visibleCenter.x to visibleCenter.y
+                    '6' -> visibleBounds.right to visibleCenter.y
+                    '7' -> visibleBounds.left to visibleBounds.bottom
+                    '8' -> visibleCenter.x to visibleBounds.bottom
+                    '9' -> visibleBounds.right to visibleBounds.bottom
+                    else -> error("Entering invalid digit: $c")
+                }.toPoint()
+            )
+        }
+        val swipe = from(centerPoint)
+        points.forEach { swipe.to(it) }
+        swipe.release()
+    }
+
+    private fun Pair<Int, Int>.toPoint() = Point(first, second)
+
+    /**
+     * Enter the Lockscreen code in the enter lockscreen text box.
+     *
+     * @param lockscreenType type of lockscreen set
+     * @param lockCode code to unlock the lockscreen
+     */
+    fun unlockViaCode(lockscreenType: LockscreenType, lockCode: String) {
+        enterCodeOnBouncer(lockscreenType, lockCode)
+        LockscreenUtils.checkDeviceLock(false)
+        By.res(PAGE_TITLE_SELECTOR_PATTERN).assertInvisible()
+        notification?.verifyStartedApp()
+    }
+
+    /**
+     * Enter invalid Lockscreen code in the enter lockscreen text box and fail to unlock.
+     *
+     * @param lockscreenType type of lockscreen set
+     * @param invalidCode invalid code to unlock the lockscreen
+     */
+    private fun failedUnlockViaCode(lockscreenType: LockscreenType, invalidCode: String) {
+        enterCodeOnBouncer(lockscreenType, invalidCode)
+
+        // Making sure device is still locked. The action happens really fast. Making sure
+        // previous action got completed
+        sleep((Constants.SHORT_WAIT_TIME_IN_SECONDS * 1000).toLong())
+        LockscreenUtils.checkDeviceLock(true)
+    }
+
+    /**
+     * Enter invalid Lockscreen pin in the enter lockscreen text box and fail to unlock.
+     *
+     * @param invalidPin invalid pin to unlock the lockscreen
+     */
+    fun failedUnlockViaPin(invalidPin: String) {
+        failedUnlockViaCode(LockscreenType.PIN, invalidPin)
+    }
+
+    /**
+     * Enter invalid Lockscreen password in the enter lockscreen text box and fail to unlock.
+     *
+     * @param invalidPassword invalid password to unlock the lockscreen
+     */
+    fun failedUnlockViaPassword(invalidPassword: String) {
+        failedUnlockViaCode(LockscreenType.PASSWORD, invalidPassword)
+    }
+
+    /** Check bouncer input UI is on the left side of the screen */
+    fun assertOnTheLeftSide(lockscreenType: LockscreenType) {
+        getInputUI(lockscreenType).assertOnTheLeftSide()
+    }
+
+    /** Check bouncer is on the right side of the screen */
+    fun assertOnTheRightSide(lockscreenType: LockscreenType) {
+        getInputUI(lockscreenType).assertOnTheRightSide()
+    }
+
+    private fun getInputUI(lockscreenType: LockscreenType): UiObject2 {
+        return when (lockscreenType) {
+            LockscreenType.PIN -> waitForObj(KEYPAD_SELECTOR)
+            LockscreenType.PATTERN -> waitForObj(PATTERN_SELECTOR)
+            LockscreenType.PASSWORD,
+            LockscreenType.SWIPE,
+            LockscreenType.NONE -> throw NotImplementedError("Not supported for these auth types")
+        }
+    }
+
+    /** Double-taps on the left side of the screen. */
+    fun doubleTapOnTheLeftSide() {
+        doubleTapAtXPosition(uiDevice.displayWidth / 4)
+    }
+
+    /** Double-taps on the right side of the screen. */
+    fun doubleTapOnTheRightSide() {
+        doubleTapAtXPosition(uiDevice.displayWidth * 3 / 4)
+    }
+
+    private fun doubleTapAtXPosition(touchX: Int) {
+        val touchY = uiDevice.displayHeight / 2
+        uiDevice.doubleTapAt(touchX, touchY)
+    }
+
+    /** https://hsv.googleplex.com/5840630509993984?node=26 */
+    val pinContainerRect: Rect?
+        get() {
+            return waitForFirstObj(*PIN_CONTAINER_SELECTOR).first.visibleBounds
+        }
+
+    /** https://hsv.googleplex.com/5550967647895552?node=25 */
+    val pinBouncerContainerRect: Rect
+        get() {
+            return waitForObj(sysuiResSelector("keyguard_pin_view")).stableBounds
+        }
+
+    /** https://hsv.googleplex.com/6358737448075264?node=25 */
+    val patternBouncerContainerRect: Rect
+        get() {
+            return waitForObj(sysuiResSelector("keyguard_pattern_view")).stableBounds
+        }
+
+    /** https://hsv.googleplex.com/4951362564521984?node=25 */
+    val passwordBouncerContainerRect: Rect
+        get() {
+            return waitForObj(sysuiResSelector("keyguard_password_view")).stableBounds
+        }
+
+    /** Checks whether the delete button exists or not. */
+    fun assertDeleteButtonVisibility(visible: Boolean) {
+        assertVisibility(PIN_BOUNCER_DELETE_BUTTON, visible)
+    }
+
+    /** Checks whether the enter button exists or not. */
+    fun assertEnterButtonVisibility(visible: Boolean) {
+        assertVisibility(PIN_BOUNCER_ENTER_BUTTON, visible)
+    }
+
+    /** Inputs key on the bouncer. */
+    fun inputKey(key: String) {
+        shell("input keyboard text $key")
+    }
+
+    companion object {
+        // Default wait used by waitForObj. waitForFirstObj uses a shorter wait.
+        private val LONG_WAIT = Duration.ofSeconds(10)
+
+        private val IS_COMPOSE_BOUNCER_ENABLED =
+            com.android.systemui.Flags.composeBouncer() ||
+                com.android.systemui.Flags.sceneContainer()
+        /**
+         * Possible selectors for container holding security view like pin, bouncer etc HSV:
+         * https://hsv.googleplex.com/5452172222267392?node=22
+         *
+         * It can be one of these three selectors depending on the flags that are active.
+         */
+        private val BOUNCER_SELECTORS =
+            arrayOf(
+                sysuiResSelector("bouncer_root"),
+                By.res("element:BouncerContent"),
+                sysuiResSelector("view_flipper"),
+            )
+
+        private val LOCKSCREEN_TEXT_BOX_SELECTOR =
+            if (IS_COMPOSE_BOUNCER_ENABLED) {
+                sysuiResSelector("bouncer_text_entry")
+            } else {
+                By.res(Pattern.compile(SYSUI_PACKAGE + ":id/(pinEntry|passwordEntry)"))
+                    .focused(true)
+            }
+
+        /** The compose bouncer_text_entry isn't the same as pin_container, but close enough */
+        private val PIN_CONTAINER_SELECTOR =
+            arrayOf(
+                sysuiResSelector("bouncer_text_entry"),
+                sysuiResSelector("pin_container"),
+            )
+        /** https://hsv.googleplex.com/5225465733185536?node=54 */
+        private val PIN_BOUNCER_DELETE_BUTTON = sysuiResSelector("delete_button")
+        /** https://hsv.googleplex.com/5554629610831872?node=52 */
+        private val PIN_BOUNCER_ENTER_BUTTON = sysuiResSelector("key_enter")
+
+        // https://hsv.googleplex.com/5130837462876160?node=117
+        private val PAGE_TITLE_SELECTOR_PATTERN =
+            Pattern.compile(String.format("%s:id/%s", SYSUI_PACKAGE, "keyguard_clock_container"))
+
+        public val PATTERN_SELECTOR =
+            if (IS_COMPOSE_BOUNCER_ENABLED) {
+                sysuiResSelector("bouncer_pattern_root")
+            } else {
+                sysuiResSelector("lockPatternView")
+            }
+
+        public val PASSWORD_SELECTOR =
+            if (IS_COMPOSE_BOUNCER_ENABLED) {
+                sysuiResSelector("bouncer_text_entry")
+            } else {
+                sysuiResSelector("passwordEntry")
+            }
+
+        public val KEYPAD_SELECTOR =
+            if (IS_COMPOSE_BOUNCER_ENABLED) {
+                sysuiResSelector("pin_pad_grid")
+            } else {
+                sysuiResSelector("flow1")
+            }
+
+        const val VALID_PIN = "1234"
+
+        const val VALID_PASSWORD = "abcd"
+
+        const val DEFAULT_PATTERN = "5624"
+
+        public val USER_ICON_SELECTOR = sysuiResSelector("user_icon")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt
new file mode 100644
index 000000000..71d73e149
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BrightnessSlider.kt
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe.from
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import androidx.test.uiautomator.UiObject2
+import com.android.systemui.Flags
+import com.google.common.truth.Truth.assertThat
+import java.time.Duration
+
+/** System UI test automation object representing the quick settings' brightness slider. */
+class BrightnessSlider internal constructor() {
+    private val slider: UiObject2
+
+    init {
+        val selector = sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID)
+        slider =
+            waitForObj(selector, LONG_WAIT) { "$selector not found" }
+                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID))
+    }
+
+    /** Slides from left to right */
+    fun swipeFromLeftToRight() {
+        val sliderBounds = slider.visibleBounds
+        val pointFrom =
+            PointF(
+                (sliderBounds.centerX() - sliderBounds.width() / 3).toFloat(),
+                sliderBounds.centerY().toFloat(),
+            )
+        val pointTo =
+            PointF(
+                (sliderBounds.centerX() + sliderBounds.width() / 3).toFloat(),
+                sliderBounds.centerY().toFloat(),
+            )
+        val swipe =
+            from(pointFrom).to(pointTo, Duration.ofMillis(500), PRECISE_GESTURE_INTERPOLATOR)
+        if (Flags.qsUiRefactorComposeFragment()) {
+            // In this case, the slider is moved to an overlay, then we verify:
+            // The notification shade is not visible, but
+            assertVisibility(sysuiResSelector(UI_NOTIFICATION_SHADE_ID), visible = false)
+            // The actual slider is visible, and
+            assertVisibility(sysuiResSelector(UI_BRIGHTNESS_SLIDER_ID), visible = true)
+            // The bounds haven't changed.
+            assertThat(slider.visibleBounds).isEqualTo(sliderBounds)
+            swipe.release()
+        } else {
+            val mirrorBounds = brightnessSliderMirror.visibleBounds
+            assertThat(sliderBounds).isEqualTo(mirrorBounds)
+            swipe.release()
+            assertThat(mirrorBounds).isEqualTo(slider.visibleBounds)
+        }
+    }
+
+    // The Mirror slider has the same id as the original one, so we get it from the container
+    private val brightnessSliderMirror: UiObject2
+        get() {
+            // The Mirror slider has the same id as the original one, so we get it from the
+            // container
+            return waitForObj(sysuiResSelector(UI_BRIGHTNESS_MIRROR_CONTAINER_ID))
+                .waitForObj(sysuiResSelector(UI_TOGGLE_SEEKBAR_ID))
+        }
+
+    private companion object {
+        const val UI_TOGGLE_SEEKBAR_ID = "slider"
+        const val UI_BRIGHTNESS_SLIDER_ID = "brightness_slider"
+        const val UI_BRIGHTNESS_MIRROR_CONTAINER_ID = "brightness_mirror_container"
+        const val UI_NOTIFICATION_SHADE_ID = "notification_shade"
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt
new file mode 100644
index 000000000..718d03161
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Bubble.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.os.SystemClock
+import android.platform.helpers.CommonUtils
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.DeviceHelpers.hasObject
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForPossibleEmpty
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import android.view.WindowInsets
+import android.view.WindowManager
+import androidx.test.uiautomator.UiObject2
+import com.google.common.truth.Truth.assertWithMessage
+import java.time.Duration
+import java.time.temporal.ChronoUnit
+
+/**
+ * System UI test automation object representing a notification bubble, specifically the view
+ * representing the bubble, shown when the stack is collapsed or expanded.
+ */
+class Bubble internal constructor(private val bubbleView: UiObject2) {
+    /** Expands the bubble into the stack. */
+    fun expand(): ExpandedBubbleStack {
+        bubbleView.click()
+        // check if bubble stack education is visible
+        // education visibility can be checked only after interacting with the bubble (click)
+        // it might be invoked by user interaction, if it wasn't presented yet
+        if (isEducationVisible) {
+            // click bubble again to expand
+            // if education is visible, the previous interaction didn't expand the bubble stack
+            bubbleView.click()
+        }
+        // let the stack expand animation to finish
+        SystemClock.sleep(STACK_EXPAND_TIMEOUT.toMillis())
+        uiDevice.waitForIdle()
+        return ExpandedBubbleStack().apply {
+            // dismiss manage education if it's visible
+            dismissManageEducation()
+        }
+    }
+
+    /** Clicks on the bubble. */
+    fun click() {
+        bubbleView.click()
+    }
+
+    /** Returns the content description of the bubble. */
+    fun contentDescription(): String = bubbleView.contentDescription
+
+    /** Dismisses the bubble by dragging it to the Dismiss target. */
+    fun dismiss() {
+        dragBubbleToDismiss()
+        // check if bubble stack education is visible and blocked interaction
+        // education visibility can be checked only after interacting with the bubble (swipe)
+        // it might be invoked by user interaction, if it wasn't presented yet
+        if (isEducationVisible) {
+            // retry drag interaction
+            // if education is visible, the previous interaction was blocked and didn't drag bubble
+            dragBubbleToDismiss()
+        }
+    }
+
+    /** Returns the flyout if it's visible, or fails. */
+    val flyout: BubbleFlyout
+        get() = BubbleFlyout()
+
+    /** Is Welcome education visible and stopped bubbles expand */
+    private val isEducationVisible: Boolean
+        get() = hasObject(BUBBLE_STACK_EDUCATION)
+
+    /** Drag bubble to Dismiss target */
+    private fun dragBubbleToDismiss() {
+        val windowMetrics =
+            context.getSystemService(WindowManager::class.java)!!.currentWindowMetrics
+        val insets =
+            windowMetrics.windowInsets.getInsetsIgnoringVisibility(
+                WindowInsets.Type.mandatorySystemGestures() or
+                    WindowInsets.Type.navigationBars() or
+                    WindowInsets.Type.displayCutout()
+            )
+        val destination =
+            PointF(
+                windowMetrics.bounds.width() / 2f,
+                (windowMetrics.bounds.height() - insets.bottom).toFloat(),
+            )
+        BetterSwipe.from(bubbleView.visibleCenter)
+            .to(
+                destination,
+                duration = Duration.of(700, ChronoUnit.MILLIS),
+                interpolator = PRECISE_GESTURE_INTERPOLATOR,
+            )
+            .release()
+    }
+
+    companion object {
+        val FIND_OBJECT_TIMEOUT = Duration.ofSeconds(20)
+        val BUBBLE_VIEW = sysuiResSelector("bubble_view")
+        val BUBBLE_BAR_VIEWS = launcherResSelector("bubble_view")
+        private val STACK_EXPAND_TIMEOUT = Duration.ofSeconds(1)
+        private val BUBBLE_STACK_EDUCATION = sysuiResSelector("stack_education_layout")
+
+        @JvmStatic
+        internal val bubbleViews: List<UiObject2>
+            get() {
+                val bubbleViews =
+                    if (CommonUtils.isLargeScreen()) {
+                        // Check bubble bar first if we're large screen
+                        waitForPossibleEmpty(BUBBLE_BAR_VIEWS, timeout = FIND_OBJECT_TIMEOUT)
+                            .ifEmpty {
+                                // Check floating in case bubble bar wasn't active
+                                waitForPossibleEmpty(BUBBLE_VIEW, timeout = FIND_OBJECT_TIMEOUT)
+                            }
+                    } else {
+                        waitForPossibleEmpty(BUBBLE_VIEW, timeout = FIND_OBJECT_TIMEOUT)
+                    }
+                assertWithMessage("No bubbles visible").that(bubbleViews.size).isAtLeast(1)
+                return bubbleViews
+            }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBar.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBar.kt
new file mode 100644
index 000000000..774cf891e
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBar.kt
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import com.google.common.truth.Truth.assertThat
+import java.time.Duration
+import java.time.temporal.ChronoUnit
+
+/**
+ * Provides an API for interacting with the collapsed bubble bar within launcher in UI automation
+ * tests.
+ *
+ * Note that this class does not represent the state of the bubble bar being stashed.
+ *
+ * @see [ExpandedBubbleBar]
+ */
+class BubbleBar {
+
+    init {
+        BUBBLE_BAR_VIEW.assertVisible { "Failed while waiting for bubble bar to become visible" }
+        assertThat(bubbles).isNotEmpty()
+    }
+
+    /**
+     * Returns the selected bubble in the bubble bar.
+     *
+     * Bubbles in the collapsed bubble bar are reversed. The selected bubble is the last bubble in
+     * the view hierarchy.
+     */
+    val selectedBubble: BubbleBarItem
+        get() = bubbles.last()
+
+    /**
+     * Returns all the bubbles in the bubble bar.
+     *
+     * Note that the overflow bubble is not included in the result because it is never visible when
+     * the bubble bar is collapsed.
+     */
+    val bubbles: List<BubbleBarItem>
+        get() = waitForObj(BUBBLE_BAR_VIEW).children.map { BubbleBarItem(it) }
+
+    /** Expands the bubble bar by clicking on it and returns [ExpandedBubbleBar]. */
+    fun expand(): ExpandedBubbleBar {
+        BUBBLE_BAR_VIEW.click()
+        return ExpandedBubbleBar(selectedBubble)
+    }
+
+    /** Expands the bubble bar by swiping up on it and returns [ExpandedBubbleBar]. */
+    fun swipeUpToExpand(): ExpandedBubbleBar {
+        val bubbleBarCenter = waitForObj(BUBBLE_BAR_VIEW).visibleCenter
+        val windowHeight = uiDevice.displayHeight
+        // we want to swipe to the point that is twice as far from the bottom of the screen as the
+        // bubble bar center Y coordinate
+        val destinationY = 2 * bubbleBarCenter.y - windowHeight
+        BetterSwipe.from(Point(bubbleBarCenter.x, windowHeight))
+            .to(Point(bubbleBarCenter.x, destinationY))
+            .release()
+        return ExpandedBubbleBar(selectedBubble)
+    }
+
+    /**
+     * Drags the bubble bar to the dismiss target. At the end of the gesture the bubble bar will be
+     * gone.
+     */
+    fun dragToDismiss() {
+        BetterSwipe.from(waitForObj(BUBBLE_BAR_VIEW).visibleCenter)
+            .pause()
+            .to(
+                waitForObj(DISMISS_VIEW).visibleCenter,
+                Duration.of(500, ChronoUnit.MILLIS),
+                PRECISE_GESTURE_INTERPOLATOR,
+            )
+            .release()
+
+        BUBBLE_BAR_VIEW.assertInvisible {
+            "Failed while waiting for bubble bar to become invisible"
+        }
+    }
+
+    companion object {
+        internal val BUBBLE_BAR_VIEW = launcherResSelector("taskbar_bubbles")
+        private val DISMISS_VIEW = launcherResSelector("dismiss_view")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarItem.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarItem.kt
new file mode 100644
index 000000000..81015865d
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleBarItem.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import androidx.test.uiautomator.UiObject2
+
+/** A UI test automation type representing bubbles in the bubble bar. */
+data class BubbleBarItem(val item: UiObject2)
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt
new file mode 100644
index 000000000..1db79cbe7
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleFlyout.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import java.time.Duration
+
+/**
+ * System UI test automation object representing a notification bubble flyout popup that appears
+ * after posting or visually updating a bubble notification.
+ */
+class BubbleFlyout internal constructor() {
+    init {
+        BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW.assertVisible(timeout = TIMEOUT)
+    }
+
+    /** Fails if the flyout doesn't auto-close */
+    fun verifyAutoClosing() {
+        BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW.assertInvisible(timeout = TIMEOUT) {
+            "Flyout didn't auto close"
+        }
+    }
+
+    private companion object {
+        val BUBBLE_FLYOUT_TEXT_CONTAIER_VIEW = sysuiResSelector("bubble_flyout_text_container")
+        val TIMEOUT = Duration.ofSeconds(20)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleOverflow.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleOverflow.kt
new file mode 100644
index 000000000..0df9f5535
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/BubbleOverflow.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import com.google.common.truth.Truth.assertThat
+import java.time.Duration
+
+/** System UI test automation object representing a bubble overflow panel. */
+class BubbleOverflow internal constructor() {
+    init {
+        BUBBLE_OVERFLOW_CONTAINER.assertVisible(timeout = FIND_OBJECT_TIMEOUT)
+    }
+
+    /** Asserts that the panel is empty. */
+    fun verifyIsEmpty() {
+        BUBBLE_OVERFLOW_EMPTY_STATE_ID.assertVisible(timeout = FIND_OBJECT_TIMEOUT)
+    }
+
+    /** Asserts that the panel has at least one bubble. */
+    fun verifyHasBubbles() {
+        val recycler = waitForObj(BUBBLE_OVERFLOW_RECYCLER_ID, timeout = FIND_OBJECT_TIMEOUT)
+        val overflowBubbleViews = recycler.findObjects(BUBBLE_OVERFLOW_VIEW)
+        assertThat(overflowBubbleViews.size).isAtLeast(1)
+    }
+
+    private companion object {
+        val FIND_OBJECT_TIMEOUT = Duration.ofSeconds(20)
+        val BUBBLE_OVERFLOW_RECYCLER_ID = sysuiResSelector("bubble_overflow_recycler")
+        val BUBBLE_OVERFLOW_EMPTY_STATE_ID = sysuiResSelector("bubble_overflow_empty_state")
+        val BUBBLE_OVERFLOW_VIEW = sysuiResSelector("bubble_overflow_view")
+        val BUBBLE_OVERFLOW_CONTAINER = sysuiResSelector("bubble_overflow_container")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt
new file mode 100644
index 000000000..ec150dc20
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ChooseScreenLock.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.helpers.LockscreenUtils.LockscreenType
+import android.platform.helpers.LockscreenUtils.LockscreenType.PASSWORD
+import android.platform.helpers.LockscreenUtils.LockscreenType.PIN
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.settingsResSelector
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.shell
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import java.time.Duration
+
+/**
+ * System UI test automation object representing the setup screen of screen lock.
+ *
+ * https://hsv.googleplex.com/6685423272198144
+ */
+class ChooseScreenLock internal constructor() {
+
+    init {
+        CHOOSE_A_SCREEN_LOCK_SELECTOR.assertVisible(timeout = LONG_WAIT_TIME)
+    }
+
+    /**
+     * Choose one screen lock.
+     *
+     * @param screenLockType type of screen lock set.
+     */
+    fun chooseScreenLock(screenLockType: LockscreenType) {
+        waitForObj(androidResSelector("title").text(screenLockType.toString())).click()
+    }
+
+    /**
+     * Entering the given code on the setup page of screen lock.
+     *
+     * If using the setLockscreenPin method to set a 6 digit PIN lock, it will not trigger the auto
+     * unlock feature, so add the functionality to set PIN lock.
+     *
+     * @param screenLockType type of screen lock set.
+     * @param screenLockCode screen lock code.
+     */
+    fun enterCodeOnSetupPageOfScreenLock(screenLockType: LockscreenType, screenLockCode: String) {
+        when (screenLockType) {
+            PIN,
+            PASSWORD -> {
+                waitForObj(PASSWORD_ENTRY, LONG_WAIT_TIME).click()
+                uiDevice.shell("input keyboard text $screenLockCode")
+                Gestures.click(waitForObj(NEXT_BUTTON_SELECTOR, LONG_WAIT_TIME), "Next button")
+                uiDevice.shell("input keyboard text $screenLockCode")
+                Gestures.click(
+                    waitForObj(CONFIRM_BUTTON_SELECTOR, LONG_WAIT_TIME),
+                    "Confirm button",
+                )
+                Gestures.click(waitForObj(DONE_BUTTON_SELECTOR, LONG_WAIT_TIME), "Done button")
+                DONE_BUTTON_SELECTOR.assertInvisible(timeout = LONG_WAIT_TIME)
+            }
+            else -> throw AssertionError("Non-supported Lockscreen Type: $screenLockType")
+        }
+    }
+
+    private companion object {
+        @JvmField val LONG_WAIT_TIME: Duration = Duration.ofSeconds(15)
+
+        const val BUTTON_CLASS = "android.widget.Button"
+
+        // https://hsv.googleplex.com/6685423272198144?node=7
+        val CHOOSE_A_SCREEN_LOCK_SELECTOR: BySelector =
+            settingsResSelector("collapsing_toolbar").desc("Choose a screen lock")
+
+        val PASSWORD_ENTRY: BySelector = settingsResSelector("password_entry")
+
+        val NEXT_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Next")
+
+        val CONFIRM_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Confirm")
+
+        // https://hsv.googleplex.com/5618542457126912?node=26
+        val DONE_BUTTON_SELECTOR: BySelector = By.clazz(BUTTON_CLASS).text("Done")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/CommunalHub.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/CommunalHub.kt
new file mode 100644
index 000000000..433eaf002
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/CommunalHub.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import androidx.test.uiautomator.By
+
+/** System UI test automation object representing the communal hub. */
+class CommunalHub internal constructor() {
+    init {
+        COMMUNAL_SELECTOR.assertVisible { "Communal Hub is not visible" }
+    }
+
+    /** Swipes right on the communal hub to exit the surface. */
+    fun swipeRightToExit() {
+        COMMUNAL_SELECTOR.assertVisible { "Communal Hub is not visible for swiping right" }
+        swipeRight()
+        COMMUNAL_SELECTOR.assertInvisible { "Communal Hub is still visible after swiping right" }
+    }
+
+    private fun swipeRight() {
+        val bounds = waitForObj(COMMUNAL_SELECTOR).visibleBounds
+        val swipeY = bounds.top + bounds.height() / 2f
+        BetterSwipe.from(PointF(bounds.left + 1f, swipeY))
+            .to(
+                PointF(bounds.left + bounds.width() / 2f, swipeY),
+                interpolator = FLING_GESTURE_INTERPOLATOR,
+            )
+            .release()
+    }
+
+    companion object {
+        const val NAMESPACE_COMMUNAL = "communal"
+        const val FLAG_COMMUNAL_HUB = "com.android.systemui.communal_hub"
+
+        private const val COMMUNAL_HUB_RESOURCE_ID = "communal_hub"
+        val COMMUNAL_SELECTOR = By.res(COMMUNAL_HUB_RESOURCE_ID)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt
new file mode 100644
index 000000000..f0fb99861
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTile.kt
@@ -0,0 +1,273 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.test.scenario.tapl_common.Gestures.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.text.TextUtils
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiObject2
+import com.google.common.truth.Truth.assertWithMessage
+import kotlin.reflect.KClass
+
+/**
+ * Object to encapsulate a tile. See https://hsv.googleplex.com/4910828112314368
+ *
+ * In order to interact with the tile, [getBehavior] needs to be called, with the type of behavior
+ * needed. There are also convenience methods for calling [click], [toggleAndAssertToggled], and
+ * [longPress]. These methods will fail the test if the tile doesn't support that interaction.
+ */
+abstract class ComposeQuickSettingsTile private constructor() {
+    /**
+     * Representation of the tile object. This should be made to retrieve the object every time (if
+     * possible) to prevent stale objects.
+     */
+    protected abstract val tile: UiObject2
+
+    /** Whether the tile is small (icon only) or large (icon + text). */
+    val isSmallTile: Boolean
+        get() {
+            val res = tile.resourceName
+            return when {
+                res.endsWith(SMALL_TILE_TAG) -> true
+                res.endsWith(LARGE_TILE_TAG) -> false
+                else -> error("Tile doesn't have a valid resource name: $res")
+            }
+        }
+
+    /** The human readable name of the tile. */
+    val tileName: String
+        get() =
+            if (!TextUtils.isEmpty(tile.contentDescription)) {
+                tile.contentDescription
+            } else {
+                tile.getTextFromSelfOrChild()
+            }
+
+    /**
+     * Get a specific behavior for the tile, by class. Prefer using [getBehavior] as it will return
+     * a casted value. This will be `null` if the tile does not support that behavior.
+     *
+     * The behavior is created new every time it's requested, tied to the backing UiObject2, so
+     * prefer creating it every time it's needed instead of storing it.
+     */
+    fun <T : TileBehavior> getBehavior(behaviorType: KClass<T>): TileBehavior? {
+        return when (behaviorType) {
+            Toggleable::class -> tile.takeIf { it.isCheckable }?.let { ToggleableImpl(it) }
+            LongPressable::class ->
+                tile.takeIf { it.isLongClickable }?.let { LongPressableImpl(it) }
+            Clickable::class -> tile.takeIf { it.isClickable }?.let { ClickableImpl(it) }
+            DualTarget::class -> tile.findObject(INNER_TARGET_SELECTOR)?.let { DualTargetImpl(it) }
+            ToggleableDualTarget::class ->
+                tile.findObject(INNER_TARGET_SELECTOR)?.let {
+                    it.takeIf { it.isCheckable }?.let { DualTargetImpl(it) }
+                }
+            else -> null
+        }
+    }
+
+    /** See [getBehavior]. */
+    inline fun <reified T : TileBehavior> getBehavior(): T? {
+        return getBehavior(T::class) as? T
+    }
+
+    /**
+     * Perform a click on the tile with no validation of the effect. This will fail if the tile does
+     * not support [Clickable].
+     *
+     * See [Clickable.click]
+     */
+    fun click() {
+        getBehavior<Clickable>()!!.click()
+    }
+
+    /**
+     * Toggle the current checked state of the tile, validating that the state has changed. This
+     * will fail if the tile does not support [Toggleable].
+     *
+     * See [Toggleable.toggleAndAssertToggled]
+     */
+    fun toggleAndAssertToggled() {
+        getBehavior<Toggleable>()!!.toggleAndAssertToggled()
+    }
+
+    /**
+     * Perform a long press on the tile, validating that [expectedSettingsPackage] (or
+     * [SETTINGS_PACKAGE] if `null`) is visible afterwards. This will fail if the tile does not
+     * support [LongPressable].
+     *
+     * See [LongPressable.longPress]
+     */
+    fun longPress(expectedSettingsPackage: String? = null) {
+        getBehavior<LongPressable>()!!.longPress(expectedSettingsPackage)
+    }
+
+    companion object {
+        /** Create a [ComposeQuickSettingsTile] wrapper from a fixed [tile] ui object. */
+        fun createFrom(tile: UiObject2): ComposeQuickSettingsTile {
+            return object : ComposeQuickSettingsTile() {
+                override val tile: UiObject2
+                    get() = tile
+            }
+        }
+
+        /**
+         * Create a [ComposeQuickSettingsTile] wrapper based on a [selector]. The wrapper will
+         * re-fetch the ui object every time it's needed, giving more flexibility in case of stale.
+         */
+        fun createFrom(selector: BySelector): ComposeQuickSettingsTile {
+            return object : ComposeQuickSettingsTile() {
+                override val tile: UiObject2
+                    get() = waitForObj(selector)
+            }
+        }
+
+        /** See https://hsv.googleplex.com/4910828112314368?node=37 */
+        fun smallTileSelector(description: String): BySelector {
+            return sysuiResSelector(SMALL_TILE_TAG).descStartsWith(description)
+        }
+
+        /** See https://hsv.googleplex.com/4910828112314368?node=28 */
+        fun largeTileSelector(description: String): BySelector {
+            return sysuiResSelector(LARGE_TILE_TAG).hasChild(By.textStartsWith(description))
+        }
+
+        fun UiObject2.assertIsTile() {
+            assertWithMessage("Tile has id ${resourceName} which is not a tile id")
+                .that(
+                    resourceName?.endsWith(SMALL_TILE_TAG) ?: false ||
+                        resourceName?.endsWith(LARGE_TILE_TAG) ?: false
+                )
+                .isTrue()
+        }
+
+        const val SMALL_TILE_TAG = "qs_tile_small"
+        const val LARGE_TILE_TAG = "qs_tile_large"
+        private const val TOGGLE_TARGET_TAG = "qs_tile_toggle_target"
+
+        private val INNER_TARGET_SELECTOR = sysuiResSelector(TOGGLE_TARGET_TAG)
+    }
+}
+
+/** Behavior for a tile */
+sealed interface TileBehavior
+
+/** Behavior for clickable tiles. */
+interface Clickable : TileBehavior {
+    /** Click on the tile. No verification is performed. */
+    fun click()
+}
+
+private class ClickableImpl(private val tile: UiObject2) : Clickable {
+    init {
+        check(tile.isClickable)
+    }
+
+    override fun click() {
+        click(tile, "Tile")
+    }
+}
+
+/**
+ * Behavior for tiles that are toggleable. This means that clicking on them will toggle them between
+ * and Off state and an On state
+ */
+interface Toggleable : TileBehavior {
+    /** Whether the tile is currently in its On state */
+    val isChecked: Boolean
+
+    /** Toggle the tile between On/Off. Validates that the tile has changed checked state. */
+    fun toggleAndAssertToggled()
+
+    /** Asserts the current checked state with a nice message. */
+    fun assertCheckedStatus(checked: Boolean)
+}
+
+private open class ToggleableImpl(private val tile: UiObject2) : Toggleable {
+    init {
+        check(tile.isCheckable)
+        check(tile.isClickable)
+    }
+
+    override val isChecked: Boolean
+        get() = tile.isChecked
+
+    override fun toggleAndAssertToggled() {
+        val wasChecked = isChecked
+        click(tile, "Tile")
+        assertCheckedStatus(!wasChecked)
+    }
+
+    override fun assertCheckedStatus(checked: Boolean) {
+        val expectedState = if (checked) "checked" else "unchecked"
+        ensureThat("tile is $expectedState") { isChecked == checked }
+    }
+}
+
+/** Behavior for tiles that support long press. */
+interface LongPressable : TileBehavior {
+    /**
+     * Long press on the tile. Validates that a settings activity with the correct package was
+     * launched.
+     */
+    fun longPress(expectedSettingsPackage: String? = null)
+}
+
+private class LongPressableImpl(private val tile: UiObject2) : LongPressable {
+    init {
+        check(tile.isLongClickable)
+    }
+
+    override fun longPress(expectedSettingsPackage: String?) {
+        val longClick = Gestures.longClickDown(tile, "Quick settings tile")
+        try {
+            val packageName = expectedSettingsPackage ?: SETTINGS_PACKAGE
+            By.pkg(packageName).assertVisible { "$packageName didn't appear" }
+        } finally {
+            longClick.up()
+        }
+    }
+}
+
+/**
+ * Behavior for tiles that support a dual target. The dual target is not necessarily a toggle
+ * between On/Off
+ */
+interface DualTarget : Clickable, LongPressable
+
+/** Behavior for tiles that support a dual target that is an On/Off toggle */
+interface ToggleableDualTarget : Toggleable, DualTarget
+
+private class DualTargetImpl(innerTarget: UiObject2) :
+    ToggleableDualTarget,
+    Toggleable by ToggleableImpl(innerTarget),
+    Clickable by ClickableImpl(innerTarget),
+    LongPressable by LongPressableImpl(innerTarget)
+
+private fun UiObject2.getTextFromSelfOrChild(): String {
+    return if (!TextUtils.isEmpty(text)) {
+        text
+    } else {
+        children.firstOrNull { !TextUtils.isEmpty(it.text) }?.text ?: ""
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt
new file mode 100644
index 000000000..e0e7a8daf
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ComposeQuickSettingsTileExt.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+fun ComposeQuickSettingsTile.clickInternetTileToOpenDialog(): InternetDialog {
+    click()
+    return InternetDialog()
+}
+
+fun ComposeQuickSettingsTile.clickBluetoothTileToOpenDialog(): BluetoothDialog {
+    click()
+    return BluetoothDialog()
+}
+
+fun ComposeQuickSettingsTile.clickModesTileToOpenDialog(): ModesDialog {
+    click()
+    return ModesDialog()
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExitGuestPrompt.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExitGuestPrompt.kt
new file mode 100644
index 000000000..10479e096
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExitGuestPrompt.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.UserUtils.runThenWaitUntilSwitchCompleted
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import java.util.regex.Pattern
+
+/**
+ * System UI test automation object representing the exit confirmation dialog when either switching
+ * from an ephemeral guest user, or pressing "Exit guest" when device is configured with
+ * config_guestUserAutoCreated.
+ *
+ * https://hsv.googleplex.com/5025959268843520
+ */
+class ExitGuestPrompt internal constructor() {
+    /** Click the exit button. https://hsv.googleplex.com/5025959268843520?node=16 */
+    fun confirmExit() {
+        runThenWaitUntilSwitchCompleted {
+            TITLE_SELECTOR.assertVisible { "Exit guest prompt prompt dialog is not visible" }
+            waitForObj(EXIT_SELECTOR) { "Exit button not found" }.click()
+        }
+    }
+
+    companion object {
+
+        // https://hsv.googleplex.com/6067368607350784?node=10
+        private val TITLE_SELECTOR =
+            androidResSelector("alertTitle")
+                .text(Pattern.compile("Exit guest mode\\?", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/6067368607350784?node=19
+        private val EXIT_SELECTOR =
+            androidResSelector("button1").text(Pattern.compile("Exit", Pattern.CASE_INSENSITIVE))
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt
new file mode 100644
index 000000000..aade1473c
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBar.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherDescSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import com.google.common.truth.Truth.assertThat
+
+/**
+ * Provides an API for interacting with the expanded bubble bar within launcher in UI automation
+ * tests.
+ *
+ * @see [BubbleBar]
+ */
+class ExpandedBubbleBar(val selectedBubble: BubbleBarItem) {
+
+    init {
+        assertThat(bubbles.size).isAtLeast(1)
+    }
+
+    /** @return all the bubbles in the bubble bar. */
+    val bubbles: List<BubbleBarItem>
+        get() = waitForObj(BUBBLE_BAR).children.map { BubbleBarItem(it) }
+
+    /** @return expanded view for the current bubble. */
+    val expandedBubble: ExpandedBubbleBarBubble
+        get() = ExpandedBubbleBarBubble()
+
+    /** Collapses the bubble bar by tapping on the selected bubble and returns [BubbleBar]. */
+    fun collapse(): BubbleBar {
+        selectedBubble.item.click()
+        return BubbleBar()
+    }
+
+    /**
+     * Selects the specified [bubble] by tapping on it and returns a new instance of
+     * [ExpandedBubbleBar].
+     */
+    fun select(bubble: BubbleBarItem): ExpandedBubbleBar {
+        assertThat(bubble).isNotEqualTo(selectedBubble)
+        bubble.item.click()
+        return ExpandedBubbleBar(bubble)
+    }
+
+    companion object {
+        private val BUBBLE_BAR = launcherResSelector("taskbar_bubbles")
+        private val OVERFLOW_BUBBLE = launcherDescSelector("Overflow")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBarBubble.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBarBubble.kt
new file mode 100644
index 000000000..ebd9aba00
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleBarBubble.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import android.view.WindowManager
+
+/**
+ * Provides an API for interacting with the expanded bubble view when bubble bar is used in UI
+ * automation tests.
+ *
+ * @see [ExpandedBubbleBar]
+ */
+class ExpandedBubbleBarBubble internal constructor() {
+
+    init {
+        BUBBLE_EXPANDED_VIEW.assertVisible()
+        HANDLE_VIEW.assertVisible()
+    }
+
+    /** Dismisses expanded view by dragging it into the dismiss area */
+    fun dragToDismiss() {
+        val windowMetrics =
+            DeviceHelpers.context.getSystemService(WindowManager::class.java)!!.currentWindowMetrics
+        val displayCenter = Point(windowMetrics.bounds.centerX(), windowMetrics.bounds.centerY())
+
+        BetterSwipe.from(waitForObj(HANDLE_VIEW).visibleCenter)
+            // First drag to the center of the display, dismiss view only shows up after drag starts
+            .to(displayCenter, interpolator = PRECISE_GESTURE_INTERPOLATOR)
+            .to(waitForObj(DISMISS_VIEW).visibleCenter, interpolator = PRECISE_GESTURE_INTERPOLATOR)
+            .release()
+
+        BUBBLE_EXPANDED_VIEW.assertInvisible {
+            "Failed while waiting for expanded bubble to become invisible"
+        }
+    }
+
+    private companion object {
+        val BUBBLE_EXPANDED_VIEW = sysuiResSelector("bubble_expanded_view")
+        val HANDLE_VIEW = sysuiResSelector("bubble_bar_handle_view")
+        val DISMISS_VIEW = sysuiResSelector("dismiss_view")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleStack.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleStack.kt
new file mode 100644
index 000000000..8186aeeb4
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ExpandedBubbleStack.kt
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.platform.helpers.CommonUtils
+import android.platform.systemui_tapl.ui.Bubble.Companion.bubbleViews
+import android.platform.systemui_tapl.utils.DeviceUtils.launcherResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.DeviceHelpers.hasObject
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.view.WindowInsets
+import android.view.WindowManager
+import android.view.WindowMetrics
+import androidx.test.uiautomator.UiObject2
+import com.android.launcher3.tapl.LauncherInstrumentation
+import com.google.common.truth.Truth.assertWithMessage
+import java.time.Duration
+import java.time.temporal.ChronoUnit.MILLIS
+
+/** System UI test automation object representing the expanded bubble stack. */
+class ExpandedBubbleStack internal constructor() {
+    init {
+        BUBBLE_EXPANDED_VIEW.assertVisible(timeout = FIND_OBJECT_TIMEOUT) {
+            "Bubbles expanded view should be visible"
+        }
+    }
+
+    /** Returns all bubbles. */
+    val bubbles: List<Bubble>
+        get() = bubbleViews.map { bubbleView: UiObject2 -> Bubble(bubbleView) }
+
+    /** Clicks the overflow button and returns the overflow panel that appears. */
+    fun openOverflow(): BubbleOverflow {
+        bubbleOverflow.click()
+        return BubbleOverflow()
+    }
+
+    /** Closes the stack by swiping up. */
+    fun closeBySwiping() {
+        val windowBounds = windowMetrics.bounds
+        val x = windowBounds.width() / 2f
+        // Move up by 1 pixel to ensure tap begins on screen.
+        val startY = windowBounds.bottom - 1f
+        // From bottom middle of screen
+        val from = PointF(x, startY)
+        // To middle of screen
+        val to = PointF(x, startY / 2)
+        // Use a custom duration for bubble swipe to reduce flakiness on slow device.
+        BetterSwipe.from(from)
+            .to(to, duration = Duration.of(700, MILLIS), interpolator = FLING_GESTURE_INTERPOLATOR)
+            .release()
+        Root.get().verifyNoExpandedBubbleStackIsVisible()
+    }
+
+    /** Closes the stack by the "back" gesture. */
+    fun closeByBackGesture() {
+        LauncherInstrumentation().pressBack()
+        Root.get().verifyNoExpandedBubbleStackIsVisible()
+    }
+
+    /** Closes the stack by clicking outside. */
+    fun closeByClickingOutside() {
+        val gestureInsets =
+            windowMetrics.windowInsets.getInsetsIgnoringVisibility(
+                WindowInsets.Type.mandatorySystemGestures() or WindowInsets.Type.displayCutout()
+            )
+        val clickX = gestureInsets.left
+        val clickY = gestureInsets.top
+        uiDevice.click(clickX, clickY)
+        Root.get().verifyNoExpandedBubbleStackIsVisible()
+    }
+
+    /** Dismiss Manage education to proceed with expanded bubbles */
+    fun dismissManageEducation() {
+        if (hasObject(BUBBLE_MANAGE_EDUCATION)) {
+            waitForObj(BUBBLE_GOT_IT_BUTTON).click()
+            uiDevice.waitForIdle()
+        }
+    }
+
+    companion object {
+        val FIND_OBJECT_TIMEOUT = Duration.ofSeconds(20)
+        val BUBBLE_EXPANDED_VIEW = sysuiResSelector("bubble_expanded_view")
+        private val BUBBLE_OVERFLOW_BUTTON = sysuiResSelector("bubble_overflow_button")
+        private val BUBBLE_BAR_OVERFLOW = launcherResSelector("bubble_overflow_button")
+        private val BUBBLE_MANAGE_EDUCATION = sysuiResSelector("manage_education_view")
+        private val BUBBLE_GOT_IT_BUTTON = sysuiResSelector("got_it")
+
+        private val windowMetrics: WindowMetrics
+            get() = context.getSystemService(WindowManager::class.java)!!.currentWindowMetrics
+
+        @JvmStatic
+        internal val bubbleOverflow: UiObject2
+            get() {
+                val bubbleOverflow =
+                    if (CommonUtils.isLargeScreen()) {
+                        // Check bubble bar first if we're large screen
+                        waitForNullableObj(BUBBLE_BAR_OVERFLOW, timeout = FIND_OBJECT_TIMEOUT)
+                            ?:
+                            // Check floating in case bubble bar wasn't active
+                            waitForNullableObj(
+                                BUBBLE_OVERFLOW_BUTTON,
+                                timeout = FIND_OBJECT_TIMEOUT,
+                            )
+                    } else {
+                        waitForNullableObj(BUBBLE_OVERFLOW_BUTTON, timeout = FIND_OBJECT_TIMEOUT)
+                    }
+                assertWithMessage("Bubble overflow not visible").that(bubbleOverflow).isNotNull()
+                return bubbleOverflow!!
+            }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt
new file mode 100644
index 000000000..1f638e546
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/InternetDialog.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitResult
+import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
+import android.platform.uiautomatorhelpers.scrollUntilFound
+import android.util.Log
+import androidx.test.uiautomator.UiObject2
+
+/** Wrapper representing the InternetDialog that opens when the QS Tile is clicked */
+class InternetDialog internal constructor() {
+    private val scrollView: UiObject2 =
+        waitForObj(sysuiResSelector(SCROLL_VIEW_RES_ID).hasParent(sysuiResSelector(DIALOG_RES_ID)))
+
+    /** Finds the done button, clicks on it and asserts that the dialog has closed. */
+    fun clickOnDoneAndClose() {
+        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
+        doneButton.click()
+        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
+            Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
+            doneButton.click()
+        }
+        DONE_BTN.assertInvisible(errorProvider = { "Internet dialog is dismissed" })
+    }
+
+    private companion object {
+        const val DIALOG_RES_ID = "internet_connectivity_dialog"
+        const val SCROLL_VIEW_RES_ID = "scroll_view"
+        val DONE_BTN = sysuiResSelector("done_button")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/KeyboardBacklightIndicatorDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/KeyboardBacklightIndicatorDialog.kt
new file mode 100644
index 000000000..af2b499dd
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/KeyboardBacklightIndicatorDialog.kt
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.settingsResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+
+class KeyboardBacklightIndicatorDialog {
+    init {
+        CONTAINER_SELECTOR.assertVisible()
+    }
+
+    companion object {
+        val CONTAINER_SELECTOR = settingsResSelector("keyboard_backlight_dialog_container")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt
new file mode 100644
index 000000000..f03b824fd
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockScreen.kt
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.platform.systemui_tapl.controller.LockscreenController
+import android.platform.systemui_tapl.ui.CommunalHub.Companion.COMMUNAL_SELECTOR
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import androidx.test.uiautomator.By
+import com.android.launcher3.tapl.Workspace
+import com.android.systemui.Flags.migrateClocksToBlueprint
+import com.android.systemui.Flags.sceneContainer
+import com.google.common.truth.Truth.assertWithMessage
+
+/** System UI test automation object representing the lock screen. */
+class LockScreen internal constructor() {
+    init {
+        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+    }
+
+    /**
+     * Opens expanded quick settings shade via swipe on the portrait lock screen. When you swipe
+     * from the top area of the screen instead of opening normal notification shade we open expanded
+     * quick settings. This helper methods allows to perform this gesture. The difference from
+     * opening normal shade gesture is that the startY position is higher. It is handled in
+     * [NotificationPanelViewController.shouldQuickSettingsIntercept].
+     */
+    fun openQuickSettings(): QuickSettings {
+        val device = uiDevice
+        device.betterSwipe(
+            startX = device.displayWidth / 2,
+            startY = 0,
+            endX = device.displayWidth / 2,
+            endY = device.displayHeight * 2 / 3,
+            interpolator = FLING_GESTURE_INTERPOLATOR,
+        )
+        return QuickSettings()
+    }
+
+    /**
+     * Returns the lockscreen shade (the one visible without the need to pull it down). Fails if not
+     * visible.
+     */
+    val notificationShade: LockscreenNotificationShade
+        get() = LockscreenNotificationShade()
+
+    /** Swipes up to the unlocked state. */
+    fun swipeUpToUnlock(): Workspace {
+        swipeUp()
+        LOCKSCREEN_SELECTOR.assertInvisible { "Lockscreen still visible after swiping up." }
+        assertWithMessage("Device is still locked after swiping up")
+            .that(LockscreenController.get().isDeviceLocked)
+            .isFalse()
+        return Root.get().goHomeViaKeycode()
+    }
+
+    /** Swipes left to access the Communal Hub */
+    fun swipeLeftToCommunal(): CommunalHub {
+        swipeLeft()
+        COMMUNAL_SELECTOR.assertVisible { "Communal Hub is not visible after swiping left" }
+        return CommunalHub()
+    }
+
+    /**
+     * Returns bounds of the lock icon at the bottom of the screen. HSV:
+     * https://hsv.googleplex.com/5632535322165248
+     */
+    val lockIcon: LockscreenLockIcon
+        get() {
+            val lockIcon = waitForObj(LOCK_ICON_SELECTOR) { "Lockscreen lock icon not found" }
+            return LockscreenLockIcon(/* rect= */ lockIcon.visibleBounds)
+        }
+
+    /**
+     * Returns user switcher on the lockscreen. HSV:
+     * https://hsv.googleplex.com/5452172222267392?node=50
+     */
+    val userSwitcher: LockscreenUserSwitcher
+        get() = LockscreenUserSwitcher()
+
+    /** Returns the lockscreen StatusBar. Fails if not visible. */
+    val statusBar: LockscreenStatusBar
+        get() = LockscreenStatusBar()
+
+    /** Swipes up to the bouncer. */
+    fun swipeUpToBouncer(): Bouncer {
+        swipeUp()
+        return Bouncer(null)
+    }
+
+    /** Returns the bouncer. Fails if the bouncer is not visible. */
+    fun getBouncer(): Bouncer {
+        return Bouncer(null)
+    }
+
+    private fun swipeUp() {
+        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+        val swipeableArea = waitForObj(SWIPEABLE_AREA) { "Swipeable area not found" }
+        // shift swipe gesture over to left so we don't begin the gesture on the lock icon
+        //   this can be removed if b/229696938 gets resolved to allow for swiping on the icon
+        val bounds = swipeableArea.visibleBounds
+        val swipeX = bounds.left + bounds.width() / 4f
+        BetterSwipe.from(PointF(swipeX, bounds.bottom - 1f))
+            .to(PointF(swipeX, bounds.top.toFloat()), interpolator = FLING_GESTURE_INTERPOLATOR)
+            .release()
+    }
+
+    private fun swipeLeft() {
+        LOCKSCREEN_SELECTOR.assertVisible { "Lockscreen is not visible" }
+        val swipeableArea = waitForObj(SWIPEABLE_AREA) { "Swipeable area not found" }
+        val bounds = swipeableArea.visibleBounds
+        val swipeY = bounds.top + bounds.height() / 2f
+        BetterSwipe.from(PointF(bounds.right - 1f, swipeY))
+            .to(
+                PointF(bounds.left + bounds.width() / 2f, swipeY),
+                interpolator = FLING_GESTURE_INTERPOLATOR,
+            )
+            .release()
+    }
+
+    companion object {
+        private val LOCK_ICON_SELECTOR = sysuiResSelector("device_entry_icon_view")
+
+        // https://hsv.googleplex.com/5130837462876160?node=117
+        val LOCKSCREEN_SELECTOR =
+            if (sceneContainer()) {
+                By.res("element:lockscreen")
+            } else {
+                sysuiResSelector(
+                    if (migrateClocksToBlueprint()) {
+                        "keyguard_indication_area"
+                    } else {
+                        "keyguard_clock_container"
+                    }
+                )
+            }
+        private val SWIPEABLE_AREA =
+            if (com.android.systemui.Flags.sceneContainer()) {
+                sysuiResSelector("shared_notification_container")
+            } else {
+                sysuiResSelector("notification_panel")
+            }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenNotificationShade.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenNotificationShade.kt
new file mode 100644
index 000000000..a98d3d684
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenNotificationShade.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+/** Shade visible from the lockscreen. Its construction is expected to fail if not visible. */
+class LockscreenNotificationShade internal constructor() :
+    NotificationStack(fromLockscreen = true) {
+    /**
+     * Returns a SystemUI test object representing the Quick Quick Settings element in the
+     * Notification Shade.
+     */
+    val quickQuickSettings: QuickQuickSettings
+        get() = QuickQuickSettings()
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenStatusBar.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenStatusBar.kt
new file mode 100644
index 000000000..433421b9a
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenStatusBar.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import com.android.settingslib.flags.Flags.newStatusBarIcons
+import org.junit.Assume.assumeFalse
+
+/** StatusBar visible from the lockscreen. */
+class LockscreenStatusBar internal constructor() {
+
+    init {
+        KEYGUARD_STATUS_BAR_SELECTOR.assertVisible { "Lockscreen statusbar not found." }
+    }
+
+    /**
+     * Returns the value of the battery level on lockscreen statusbar. Experimental.
+     *
+     * TODO(b/328785514): this method will no longer work with the rollout of NEW_STATUS_BAR_ICONS
+     */
+    fun getBatteryLevel(): String {
+        assumeFalse(newStatusBarIcons())
+        return waitForObj(sysuiResSelector(StatusBar.BATTERY_LEVEL_TEXT_ID)) {
+                "Battery percentage not found on lock screen statusbar."
+            }
+            .text
+    }
+
+    /** Gets user switcher chip. */
+    val userSwitcherChip: UserSwitcherChip
+        get() = UserSwitcherChip()
+
+    /** Asserts that user switcher chip is invisible. */
+    fun assertUserSwitcherChipIsInvisible() {
+        sysuiResSelector(UserSwitcherChip.USER_SWITCHER_CONTAINER_ID).assertInvisible()
+    }
+
+    private companion object {
+        // https://hsv.googleplex.com/6309313707507712?node=45
+        val KEYGUARD_STATUS_BAR_SELECTOR = sysuiResSelector("keyguard_header")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenUserSwitcher.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenUserSwitcher.kt
new file mode 100644
index 000000000..b3a620330
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/LockscreenUserSwitcher.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.doubleTapAt
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.assertOnTheLeftSide
+import android.platform.uiautomatorhelpers.assertOnTheRightSide
+import java.time.Duration
+
+/**
+ * User switcher visible on lockscreen on large screen devices when
+ * [USER_SWITCHER_VISIBLE_FLAG_NAME] is enabled. Constructor fails if the switcher is not visible.
+ */
+class LockscreenUserSwitcher internal constructor() {
+
+    private val uiObject =
+        waitForFirstObj(*USER_SWITCHER_SELECTORS, timeout = LONG_WAIT) {
+                "Lockscreen user switcher not found"
+            }
+            .first
+
+    /** Check that the bouncer is on the right side of the screen. */
+    fun assertOnTheRightSide(): Unit = uiObject.assertOnTheRightSide()
+
+    /** Check that the bouncer is on the left side of the screen. */
+    fun assertOnTheLeftSide(): Unit = uiObject.assertOnTheLeftSide()
+
+    /**
+     * Double tap the bottom of the view. Used for large screen where user switcher is side by side
+     * with bouncer and double tapping means they should switch sides horizontally
+     */
+    fun doubleTapBelowUserSwitcher() {
+        val bounds = uiObject.visibleBounds
+        // Tap 5 pixels below the user switcher UI element.
+        val (touchX, touchY) = Pair(bounds.centerX(), bounds.bottom + 5)
+        uiDevice.doubleTapAt(touchX, touchY)
+    }
+
+    /** Taps the user switcher anchor to expand the list. */
+    fun openUserSelectorExpandedList(): UserSelectionExpandedList {
+        waitForObj(USER_SWITCHER_DROPDOWN_SELECTOR) { "User switcher anchor not found" }.click()
+        return UserSelectionExpandedList()
+    }
+
+    private companion object {
+        // Default wait used by waitForObj. waitForFirstObj uses a shorter wait.
+        private val LONG_WAIT = Duration.ofSeconds(10)
+
+        // https://hsv.googleplex.com/6328527512141824?node=23
+        private val USER_SWITCHER_DROPDOWN_SELECTOR = sysuiResSelector("user_switcher_anchor")
+        private val USER_SWITCHER_SELECTORS =
+            arrayOf(
+                sysuiResSelector("keyguard_bouncer_user_switcher"),
+                sysuiResSelector("UserSwitcher"),
+            )
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionAppSelector.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionAppSelector.kt
new file mode 100644
index 000000000..f44a3895f
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionAppSelector.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.helpers.ui.UiAutomatorUtils.getUiDevice
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.stableBounds
+import com.google.common.truth.Truth.assertThat
+
+/**
+ * System UI test automation object representing a media projection app selector. App selector is
+ * launched when sharing a single app.
+ */
+class MediaProjectionAppSelector internal constructor() {
+
+    init {
+        CHOOSER_HEADER.assertVisible()
+    }
+
+    /** Dismiss app selector by pressing back. Make sure it is no longer visible */
+    fun dismiss() {
+        getUiDevice().pressBack()
+        CHOOSER_HEADER.assertInvisible()
+    }
+
+    /** Make sure app selector is fully expanded */
+    fun verifyIsExpanded() {
+        // Assert full expansion when the top of the drawer touches the bottom of the status bar
+        val headerTop = waitForObj(CHOOSER_HEADER).stableBounds.top
+        val statusBarBottom = waitForObj(STATUS_BAR).stableBounds.bottom
+        assertThat(headerTop).isEqualTo(statusBarBottom)
+    }
+
+    /** Width of the app selector drawer */
+    val width: Int
+        get() = waitForObj(CHOOSER_HEADER).stableBounds.width()
+
+    companion object {
+        private val CHOOSER_HEADER = androidResSelector("chooser_header")
+        private val STATUS_BAR = sysuiResSelector("status_bar_container")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionPermissionDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionPermissionDialog.kt
new file mode 100644
index 000000000..1ae41293b
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MediaProjectionPermissionDialog.kt
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.os.SystemClock
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.scrollUntilFound
+import androidx.test.uiautomator.By
+import com.android.launcher3.tapl.LauncherInstrumentation
+import com.android.systemui.shared.system.ActivityManagerWrapper
+import java.time.Duration
+import java.util.regex.Pattern
+
+/**
+ * System UI test automation object representing a media projection permission dialog for sharing
+ * the user's screen to another app.
+ *
+ * https://screenshot.googleplex.com/9YU3VqEh2uiTQ34 (single app) and
+ * https://screenshot.googleplex.com/AE5gqPJ3DE3jo7g (entire screen).
+ */
+class MediaProjectionPermissionDialog internal constructor() {
+
+    init {
+        assertSpinnerVisibility(visible = true)
+    }
+
+    fun startSingleTaskShare() {
+        waitForObj(SPINNER_SELECTOR).click()
+
+        // Make sure clicking one the pop-up option, not the spinner with the same text
+        waitForObj(POP_UP).waitForObj(SINGLE_APP_SELECTOR) { "Single app option not found" }.click()
+        waitForObj(DIALOG).scrollUntilFound(SINGLE_APP_START_SELECTOR)
+            ?: error("Start button not found")
+
+        // TODO(b/333510487): Sleep is temporarily needed after scroll, and should be remove later
+        SystemClock.sleep(SHORT_TIMEOUT.toMillis())
+        SINGLE_APP_START_SELECTOR.click()
+        ensureThat("App selector is launched") { isAppSelectorRunning() }
+    }
+
+    private fun isAppSelectorRunning(): Boolean {
+        val tasks = ActivityManagerWrapper.getInstance().getRunningTasks(false)
+        return tasks.any { it.topActivity?.className?.contains(APP_SELECTOR_ACTIVITY) ?: false }
+    }
+
+    fun cancel() {
+        waitForObj(CANCEL_SELECTOR) { "Cancel button not found" }.click()
+    }
+
+    /* Dismisses the dialog by the Back gesture */
+    fun dismiss() {
+        LauncherInstrumentation().pressBack()
+        assertSpinnerVisibility(visible = false)
+    }
+
+    fun assertSingleAppOptionIsDefault() {
+        // Single App option should be visible without clicking on the spinner
+        SINGLE_APP_SELECTOR.assertVisible()
+    }
+
+    fun assertEntireScreenOptionIsDefault() {
+        // Entire screen option should be visible without clicking on the spinner
+        ENTIRE_SCREEN_SELECTOR.assertVisible()
+    }
+
+    fun assertSingleAppOptionDisabled() {
+        waitForObj(SPINNER_SELECTOR).click()
+        SINGLE_APP_DISABLED_SELECTOR.assertVisible()
+        ensureThat("Single app is disabled") { !waitForObj(SINGLE_APP_SELECTOR).isEnabled }
+    }
+
+    fun assertSingleAppOptionEnabled() {
+        waitForObj(SPINNER_SELECTOR).click()
+        SINGLE_APP_DISABLED_SELECTOR.assertInvisible()
+        ensureThat("Single app is enabled") { waitForObj(SINGLE_APP_SELECTOR).isEnabled }
+    }
+
+    fun assertSecondaryDisplayVisible() {
+        waitForObj(SPINNER_SELECTOR).click()
+        ENTIRE_SCREEN_RECORD_SECONDARY_SELECTOR.assertVisible()
+    }
+
+    companion object {
+        private val DIALOG = sysuiResSelector("screen_share_permission_dialog")
+
+        // Builds from 24Q3 and earlier will have screen_share_mode_spinner, while builds from
+        // 24Q4 onwards will have screen_share_mode_options, so need to check both options here
+        private val SPINNER_SELECTOR =
+            By.res(Pattern.compile("$SYSUI_PACKAGE:id/screen_share_mode_(options|spinner)"))
+
+        private val POP_UP = By.clazz("android.widget.ListView")
+        private val SINGLE_APP_SELECTOR = By.text("Share one app")
+        private val ENTIRE_SCREEN_SELECTOR = By.text("Share entire screen")
+        private val ENTIRE_SCREEN_RECORD_SECONDARY_SELECTOR =
+            By.text("Record entire screen: Overlay #1")
+        private val SINGLE_APP_START_SELECTOR = By.text("Next")
+        private val CANCEL_SELECTOR = By.text("Cancel")
+        private val SINGLE_APP_DISABLED_SELECTOR = By.textEndsWith("has disabled this option")
+        private const val APP_SELECTOR_ACTIVITY = "MediaProjectionAppSelectorActivity"
+        private val SHORT_TIMEOUT = Duration.ofMillis(500)
+
+        // Public as it is used in Root.java
+        @JvmStatic
+        fun assertSpinnerVisibility(visible: Boolean) {
+            assertVisibility(SPINNER_SELECTOR, visible)
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MinusOne.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MinusOne.java
new file mode 100644
index 000000000..18b4124ea
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MinusOne.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui;
+
+import android.support.test.uiautomator.UiDevice;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+public class MinusOne {
+
+    public void swipeRight() {
+        UiDevice mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
+        mDevice.swipe(
+                0,
+                mDevice.getDisplayHeight() / 2,
+                mDevice.getDisplayWidth() * 4 / 5,
+                mDevice.getDisplayHeight() / 2,
+                15);
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt
new file mode 100644
index 000000000..95c95acf6
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ModesDialog.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiObject2
+import com.android.launcher3.tapl.LauncherInstrumentation
+import java.time.Duration
+
+/** System UI test automation object representing the modes list dialog. */
+class ModesDialog internal constructor() {
+
+    init {
+        UI_DIALOG_TITLE.assertVisible()
+    }
+
+    /* Dismisses the dialog by the Back gesture */
+    fun dismiss() {
+        // Press back to dismiss the dialog
+        LauncherInstrumentation().pressBack()
+        UI_DIALOG_TITLE.assertInvisible()
+    }
+
+    private fun getModeTile(modeName: String): UiObject2 {
+        return waitForObj(By.text(modeName)).parent
+    }
+
+    fun tapMode(modeName: String) {
+        getModeTile(modeName).click()
+    }
+
+    fun verifyModeState(modeName: String, isOn: Boolean) {
+        val modeTile = getModeTile(modeName)
+        modeTile.waitForObj(
+            if (isOn) MODE_STATE_ON_SELECTOR else MODE_STATE_OFF_SELECTOR,
+            errorProvider = { "Tile not in correct state, wanted ${if (isOn) "On" else "Off"}" },
+        )
+    }
+
+    companion object {
+        private const val UI_DIALOG_TITLE_ID = "modes_title"
+        private const val UI_ALERT_DIALOG_NEGATIVE_BUTTON_ID = "button2"
+        private val UI_DIALOG_TITLE = By.res(UI_DIALOG_TITLE_ID)
+        private val MODE_NAME_SELECTOR = By.res("name")
+        private val MODE_STATE_ON_SELECTOR = By.res("stateOn")
+        private val MODE_STATE_OFF_SELECTOR = By.res("stateOff")
+        private val UI_RESPONSE_TIMEOUT = Duration.ofSeconds(3)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MultipleUsersSettings.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MultipleUsersSettings.kt
new file mode 100644
index 000000000..a7f12d8d8
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/MultipleUsersSettings.kt
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.settingsResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import androidx.test.uiautomator.BySelector
+
+/**
+ * Page containing users.
+ *
+ * https://hsv.googleplex.com/6421165189890048
+ */
+class MultipleUsersSettings internal constructor() {
+    init {
+        PAGE_SELECTOR.assertVisible { "Multiple users settings page didn't appear" }
+    }
+
+    companion object {
+        // https://hsv.googleplex.com/6421165189890048?node=7
+        private val PAGE_SELECTOR: BySelector =
+            settingsResSelector("collapsing_toolbar").desc("Users")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt
new file mode 100644
index 000000000..9898058d4
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Notification.kt
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.graphics.Rect
+import android.platform.helpers.ui.UiAutomatorUtils.getUiDevice
+import android.platform.systemui_tapl.controller.NotificationIdentity
+import android.platform.systemui_tapl.ui.NotificationStack.Companion.NOTIFICATION_ROW_SELECTOR
+import android.platform.systemui_tapl.ui.NotificationStack.Companion.getNotificationCountByIdentityText
+import android.platform.systemui_tapl.ui.NotificationStack.Companion.notificationByTextSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.SHORT_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.WaitUtils.retryIfStale
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import com.google.common.truth.Truth.assertThat
+import com.google.common.truth.Truth.assertWithMessage
+import java.time.Duration
+import org.junit.Assert.assertNull
+
+/** System UI test automation object representing a notification in the notification shade. */
+class Notification
+internal constructor(
+    private val notification: UiObject2,
+    private val fromLockscreen: Boolean,
+    private val isHeadsUpNotification: Boolean,
+    private val groupNotificationIdentity: NotificationIdentity? = null,
+    // Selector of a view visible only in the expanded state.
+    private val contentIsVisibleInCollapsedState: Boolean = false,
+    private val isBigText: Boolean? = null,
+    private val pkg: String? = null,
+    selectorWhenExpanded: BySelector? = null,
+) : Sized(notification.visibleBounds) {
+
+    private val selectorWhenExpanded: BySelector = selectorWhenExpanded ?: COLLAPSE_SELECTOR
+
+    /**
+     * Verifies that the notification is in collapsed or expanded state.
+     *
+     * @param expectedExpanded whether the expected state is "expanded".
+     */
+    fun verifyExpanded(expectedExpanded: Boolean) {
+        notification.assertVisibility(selector = selectorWhenExpanded, visible = expectedExpanded)
+    }
+
+    /**
+     * Taps the chevron or swipes the specified notification to expand it from the collapsed state.
+     *
+     * @param dragging By swiping when `true`, by tapping the chevron otherwise.
+     */
+    fun expand(dragging: Boolean) {
+        if (groupNotificationIdentity != null) {
+            expandGroup(dragging)
+        } else {
+            verifyExpanded(false)
+            toggleNonGroup(dragging, wasExpanded = false)
+            verifyExpanded(true)
+        }
+    }
+
+    /**
+     * Taps the chevron or swipes the specified notification to collapse it from the expanded state.
+     *
+     * @param dragging By swiping when `true`, by tapping the chevron otherwise.
+     */
+    fun collapse(dragging: Boolean) {
+        assertNull("Collapsing groups is not supported", groupNotificationIdentity)
+        verifyExpanded(true)
+        toggleNonGroup(dragging, wasExpanded = true)
+        verifyExpanded(false)
+    }
+
+    /** Dismisses the notification via swipe. */
+    fun dismiss() {
+        val rowCountBeforeSwipe = expandableNotificationRows.size
+        swipeRightOnNotification()
+
+        // Since one group notification was swiped away, the new size shall be smaller
+        ensureThat("Number of notifications decreases after swipe") {
+            expandableNotificationRows.size < rowCountBeforeSwipe
+        }
+        // group notification shall not been found again
+        groupNotificationIdentity?.let {
+            notificationByTextSelector(it.summary!!).assertInvisible()
+        }
+    }
+
+    fun waitUntilGone() {
+        notification.assertVisibility(TITLE_SELECTOR, false)
+    }
+
+    /**
+     * Verifies that the notification is in HUN state. HUN State: A notification that has the expand
+     * button (chevron) at the expand status, and has at least an action that is currently
+     * showing. We only allow assertion of HUN state for notifications that have action buttons.
+     * Fails if the notification is not at the HUN state defined above.
+     */
+    fun verifyIsHunState() {
+        notification.assertVisibility(
+            selector = androidResSelector(EXPAND_BUTTON_ID).desc("Expand"),
+            visible = true,
+            errorProvider = {
+                "HUN state assertion error: The notification is found, but not " +
+                    "in the HUN status, because didn't find the expand_button at the Expand status."
+            },
+        )
+        notification.assertVisibility(
+            selector = ACTION_BUTTON_SELECTOR,
+            visible = true,
+            errorProvider = {
+                "HUN state assertion error: The notification is found, but not " +
+                    "in the HUN status, because didn't find an action button."
+            },
+        )
+    }
+
+    /** Swipes on the notification but not able to dismiss the notification. */
+    fun swipeButNotDismiss() {
+        val rowCountBeforeSwipe = expandableNotificationRows.size
+        swipeRightOnNotification()
+
+        // Since one group notification was swiped away, the new size shall be smaller
+        ensureThat("Number of notifications keeping the same after swipe") {
+            expandableNotificationRows.size == rowCountBeforeSwipe
+        }
+    }
+
+    /**
+     * Swipes vertically on the specified notification. When the notification is a HUN (heads up
+     * notification), this expands the shade.
+     */
+    fun expandShadeFromHun(): NotificationShade {
+        assertWithMessage("Not a heads-up notification").that(isHeadsUpNotification).isTrue()
+        // drag straight downward by 1/4 of the screen size
+        val center = notification.visibleCenter
+        uiDevice.betterSwipe(
+            startX = center.x,
+            startY = center.y,
+            endX = center.x,
+            endY = center.y + uiDevice.displayHeight / 2,
+            interpolator = FLING_GESTURE_INTERPOLATOR,
+        )
+
+        val shade = NotificationShade()
+        // swipe to show full list. Throws if we aren't in the shade
+        shade.scrollToBottom()
+        shade.verifyIsShowingFooter()
+        return shade
+    }
+
+    /** Returns this notification object's visible bounds. */
+    fun getBounds(): Rect {
+        return notification.visibleBounds
+    }
+
+    private fun toggleNonGroup(dragging: Boolean, wasExpanded: Boolean) {
+        check(isBigText != null) { "It is needed to know isBigText to use toggle notification" }
+        expandNotification(dragging)
+
+        InstrumentationRegistry.getInstrumentation().uiAutomation.clearCache()
+
+        // Expansion indicator be visible on the expanded state, and hidden on the collapsed one.
+        if (wasExpanded) {
+            assertThat(notification.wait(Until.gone(selectorWhenExpanded), TIMEOUT_MS)).isTrue()
+
+            notification.assertVisibility(By.text(APP_NAME), false)
+            notification.assertVisibility(
+                By.text(NOTIFICATION_CONTENT_TEXT),
+                visible = contentIsVisibleInCollapsedState,
+            )
+            notification.assertVisibility(By.text(NOTIFICATION_BIG_TEXT), false)
+        } else {
+            assertThat(notification.wait(Until.hasObject(selectorWhenExpanded), TIMEOUT_MS))
+                .isTrue()
+
+            // Expanded state must contain app name.
+            notification.assertVisibility(By.text(APP_NAME), true)
+            if (isBigText) {
+                notification.assertVisibility(By.text(NOTIFICATION_BIG_TEXT), true)
+            } else {
+                notification.assertVisibility(By.text(NOTIFICATION_CONTENT_TEXT), true)
+            }
+        }
+        notification.assertVisibility(TITLE_SELECTOR, true)
+        notification.assertVisibility(androidResSelector(APP_ICON_ID), true)
+        notification.assertVisibility(androidResSelector(EXPAND_BUTTON_ID), true)
+    }
+
+    private fun expandNotification(dragging: Boolean) {
+        val height: Int = notification.visibleBounds.height()
+        if (dragging) {
+            val center = notification.visibleCenter
+            uiDevice.betterSwipe(
+                startX = center.x,
+                startY = center.y,
+                endX = center.x,
+                endY = center.y + 300,
+                interpolator = FLING_GESTURE_INTERPOLATOR,
+            )
+        } else {
+            tapExpandButton()
+        }
+
+        // There isn't an explicit contract for notification expansion, so let's assert
+        // that the content height changed, which is likely.
+        ensureThat("Notification height changed") { notification.visibleBounds.height() != height }
+    }
+
+    fun tapExpandButton() {
+        val chevron = notification.waitForObj(androidResSelector(EXPAND_BUTTON_ID))
+        Gestures.click(chevron, "Chevron")
+    }
+
+    private fun expandGroup(dragging: Boolean) {
+        check(dragging) { "Only expanding by dragging is supported for group notifications" }
+        val collapsedNotificationsCount =
+            getNotificationCountByIdentityText(groupNotificationIdentity!!)
+
+        // drag group notification to bottom to expand group
+        val center = notification.visibleCenter
+        uiDevice.betterSwipe(
+            startX = center.x,
+            startY = center.y,
+            endX = uiDevice.displayWidth / 2,
+            endY = uiDevice.displayHeight,
+            interpolator = FLING_GESTURE_INTERPOLATOR,
+        )
+
+        // swipe to show full list
+        NotificationShade().scrollToBottom()
+
+        // make sure the group notification expanded
+        ensureThat("Notification count increases") {
+            val expandNotificationsCount =
+                getNotificationCountByIdentityText(groupNotificationIdentity)
+            collapsedNotificationsCount < expandNotificationsCount
+        }
+    }
+
+    /** Returns number of messages in the notification. */
+    val messageCount: Int
+        get() = notification.waitForObj(MESSAGE_SELECTOR).children.size
+
+    /** Long press on notification to show its hidden menu (a.k.a. guts) */
+    fun showGuts(): NotificationGuts {
+        val longClick = Gestures.longClickDown(notification, "Notification")
+        val guts = notification.waitForObj(GUTS_SELECTOR, UI_RESPONSE_TIMEOUT)
+        guts.assertVisibility(By.text(APP_NAME), true)
+        guts.assertVisibility(By.text(NOTIFICATION_CHANNEL_NAME), true)
+
+        // Confirmation/Settings buttons
+        guts.assertVisibility(GUTS_SETTINGS_SELECTOR, true)
+        guts.assertVisibility(GUTS_CLOSE_SELECTOR, true)
+        longClick.up()
+        return NotificationGuts(notification)
+    }
+
+    /** Clicks the notification and verifies that the expected app opens. */
+    fun clickToApp() {
+        Gestures.click(notification, "Notification")
+        verifyStartedApp()
+    }
+
+    /** Clicks the notification to open the bouncer. */
+    fun clickToBouncer(): Bouncer {
+        assertWithMessage("The notification should be a lockscreen one")
+            .that(fromLockscreen)
+            .isTrue()
+        Gestures.click(notification, "Notification")
+        return Bouncer(/* notification= */ this)
+    }
+
+    fun verifyStartedApp() {
+        check(
+            uiDevice.wait(Until.hasObject(By.pkg(pkg!!).depth(0)), LAUNCH_APP_TIMEOUT.toMillis())
+        ) {
+            "Did not find application, ${pkg}, in foreground"
+        }
+    }
+
+    /** Clicks "show bubble" button to show a bubble. */
+    fun showBubble() {
+        // Create bubble from the notification
+        TaplUiDevice.waitForObject(BUBBLE_BUTTON_SELECTOR, "Show bubble button").click()
+
+        // Verify that a bubble is visible
+        Root.get().bubble
+    }
+
+    /** Taps the snooze button on the notification */
+    fun snooze(): Notification = also {
+        ensureThat { notification.isLongClickable }
+
+        val snoozeButton = notification.waitForObj(SNOOZE_BUTTON_SELECTOR)
+
+        Gestures.click(snoozeButton, "Snooze button")
+
+        notification.assertVisibility(UNDO_BUTTON_SELECTOR, true)
+
+        ensureThat { !notification.isLongClickable }
+    }
+
+    /** Taps undo button on the snoozed notification */
+    fun unsnooze(): Notification = also {
+        ensureThat { !notification.isLongClickable }
+
+        val undoButton = notification.waitForObj(UNDO_BUTTON_SELECTOR)
+
+        Gestures.click(undoButton, "Undo Snooze button")
+
+        notification.assertVisibility(SNOOZE_BUTTON_SELECTOR, true)
+
+        ensureThat { notification.isLongClickable }
+    }
+
+    /** Verifies that the given notification action is enabled/disabled */
+    fun verifyActionIsEnabled(actionSelectorText: String, expectedEnabledState: Boolean) {
+        val actionButton =
+            notification.wait(
+                Until.findObject(By.text(actionSelectorText)),
+                UI_RESPONSE_TIMEOUT.toMillis(),
+            )
+
+        assertThat(actionButton).isNotNull()
+
+        ensureThat { actionButton.isEnabled == expectedEnabledState }
+    }
+
+    fun verifyTitleEquals(expected: String) {
+        waitForObj(
+            By.copy(TITLE_SELECTOR).text(expected),
+            errorProvider = { "Couldn't find title with text \"$expected\"" },
+        )
+    }
+
+    fun verifyBigTextEquals(expected: String) {
+        waitForObj(
+            By.copy(BIG_TEXT_SELECTOR).text(expected),
+            errorProvider = { "Couldn't find big text with text \"$expected\"" },
+        )
+    }
+
+    fun clickButton(label: String) {
+        notification.waitForObj(By.text(label)).click()
+    }
+
+    /**
+     * Press the reply button, enter [text] to reply with and send.
+     *
+     * NOTE: Prefer using shorter strings here, as longer ones tend to have a significant effect on
+     * performance on slower test devices.
+     */
+    fun replyWithText(text: String) {
+        // This sometimes has issues where it can't find the reply button due to a
+        // StaleObjectException, although the button is there. So we attempt each interaciton
+        // three times, separately.
+        retryIfStale(description = "find reply button", times = 3) {
+            notification.waitForObj(REPLY_BUTTON_SELECTOR, SHORT_WAIT).click()
+        }
+
+        var remoteInputSelector: UiObject2? = null
+        retryIfStale(description = "add reply text \"$text\"", times = 3) {
+            remoteInputSelector = notification.waitForObj(REMOTE_INPUT_TEXT_SELECTOR, LONG_WAIT)
+        }
+        if (remoteInputSelector == null) {
+            // If the screen is too small, it might be hidden by IME.
+            // Dismiss the IME and try again.
+            getUiDevice().pressBack()
+            retryIfStale(description = "add reply text \"$text\"", times = 3) {
+                remoteInputSelector = notification.waitForObj(REMOTE_INPUT_TEXT_SELECTOR, LONG_WAIT)
+            }
+        }
+        remoteInputSelector?.text = text
+
+        var sendSelector: UiObject2? = null
+        retryIfStale(description = "find send selector input", times = 3) {
+            sendSelector = notification.waitForObj(REMOTE_INPUT_SEND_SELECTOR, SHORT_WAIT)
+        }
+        if (sendSelector == null) {
+            // If the screen is too small, it might be hidden by IME.
+            // Dismiss the IME and try again.
+            getUiDevice().pressBack()
+            retryIfStale(description = "find send selector input", times = 3) {
+                sendSelector = notification.waitForObj(REMOTE_INPUT_SEND_SELECTOR, SHORT_WAIT)
+            }
+        }
+        sendSelector?.click()
+    }
+
+    fun assertReplyHistoryContains(reply: String) {
+        ensureThat("Reply history should contain \"$reply\"") { replyHistoryContains(reply) }
+    }
+
+    fun getUiObject(): UiObject2 = notification
+
+    private fun replyHistoryContains(reply: String): Boolean {
+        // Fail if we cannot find the container
+        val container = notification.waitForObj(REPLY_HISTORY_CONTAINER, LONG_WAIT)
+        return (1..3).any { i ->
+            val replyObject =
+                container.waitForNullableObj(getReplyHistorySelector(i), SHORT_WAIT)
+                    ?: return false // We don't expect more replies
+            replyObject.text == reply
+        }
+    }
+
+    private fun swipeRightOnNotification() {
+        val bounds = notification.visibleBounds
+        val centerY = (bounds.top + bounds.bottom) / 2f
+        BetterSwipe.from(PointF(bounds.left.toFloat(), centerY))
+            .to(PointF(bounds.right.toFloat(), centerY), interpolator = FLING_GESTURE_INTERPOLATOR)
+            .release()
+    }
+
+    companion object {
+        private const val APP_NAME = "Scenario"
+        private val UI_RESPONSE_TIMEOUT = Duration.ofSeconds(3)
+        private val LAUNCH_APP_TIMEOUT = Duration.ofSeconds(10)
+        private val SHORT_TRANSITION_WAIT = Duration.ofMillis(1500)
+        private val TIMEOUT_MS = LONG_WAIT.toMillis()
+
+        private val TITLE_SELECTOR = androidResSelector("title")
+        private val MESSAGE_SELECTOR = androidResSelector("group_message_container")
+        private val COLLAPSE_SELECTOR = By.descContains("Collapse")
+        private val GUTS_SELECTOR = sysuiResSelector("notification_guts").maxDepth(1)
+        private const val NOTIFICATION_CHANNEL_NAME = "Test Channel DEFAULT_IMPORTANCE"
+        private val GUTS_SETTINGS_SELECTOR = sysuiResSelector("info")
+        private val GUTS_CLOSE_SELECTOR = sysuiResSelector("done")
+        private val BUBBLE_BUTTON_SELECTOR = By.res("android:id/bubble_button")
+        private val SNOOZE_BUTTON_SELECTOR = androidResSelector("snooze_button")
+        private val UNDO_BUTTON_SELECTOR = By.text("Undo")
+        private val ACTION_BUTTON_SELECTOR = androidResSelector("action0")
+        private val BIG_TEXT_SELECTOR = androidResSelector("big_text")
+
+        // RemoteInput selectors
+        private val REPLY_BUTTON_SELECTOR = androidResSelector("action0").descContains("Reply")
+        private val REMOTE_INPUT_TEXT_SELECTOR = sysuiResSelector("remote_input_text")
+        private val REMOTE_INPUT_SEND_SELECTOR = sysuiResSelector("remote_input_send")
+        private val REPLY_HISTORY_CONTAINER =
+            androidResSelector("notification_material_reply_container")
+
+        private fun getReplyHistorySelector(index: Int) =
+            androidResSelector("notification_material_reply_text_$index")
+
+        const val MAX_FIND_BOTTOM_ATTEMPTS = 15
+
+        const val NOTIFICATION_TITLE_TEXT = "TEST NOTIFICATION"
+
+        @JvmField
+        val NOTIFICATION_BIG_TEXT =
+            """
+            lorem ipsum dolor sit amet
+            lorem ipsum dolor sit amet
+            lorem ipsum dolor sit amet
+            lorem ipsum dolor sit amet
+            """
+                .trimIndent()
+        private const val EXPAND_BUTTON_ID = "expand_button"
+        private const val APP_ICON_ID = "icon"
+        private const val NOTIFICATION_CONTENT_TEXT = "Test notification content"
+
+        private val expandableNotificationRows: List<UiObject2>
+            get() {
+                return uiDevice.wait(
+                    Until.findObjects(NOTIFICATION_ROW_SELECTOR),
+                    SHORT_TRANSITION_WAIT.toMillis(),
+                ) ?: emptyList()
+            }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationGuts.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationGuts.kt
new file mode 100644
index 000000000..6fe7d23e4
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationGuts.kt
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import com.google.common.truth.Truth.assertThat
+
+/** System UI test automation object representing a notification hidden's menu (a.k.a. guts). */
+class NotificationGuts internal constructor(private val mNotification: UiObject2) {
+    /** Taps the "Done" button on the notification guts. */
+    fun close() {
+        val gutsSelector = sysuiResSelector(GUTS_ID)
+        mNotification.assertVisibility(gutsSelector, visible = true)
+        Gestures.click(mNotification.waitForObj(By.text("Done")), "Done button")
+        assertThat(mNotification.wait(Until.gone(gutsSelector), UI_RESPONSE_TIMEOUT_MSECS)).isTrue()
+    }
+
+    private companion object {
+        const val GUTS_ID = "notification_guts"
+        const val UI_RESPONSE_TIMEOUT_MSECS: Long = 3000
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt
new file mode 100644
index 000000000..231c34048
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShade.kt
@@ -0,0 +1,346 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.os.SystemClock
+import android.platform.helpers.CommonUtils
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.settingsResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.test.scenario.tapl_common.TaplUiObject
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.view.WindowManager
+import android.view.WindowMetrics
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import com.android.launcher3.tapl.LauncherInstrumentation
+import com.android.systemui.Flags
+import com.google.common.truth.StandardSubjectBuilder
+import com.google.common.truth.Truth.assertThat
+import com.google.common.truth.Truth.assertWithMessage
+import kotlin.math.floor
+
+/** System UI test automation object representing the notification shade. */
+class NotificationShade internal constructor() {
+    init {
+        if (CommonUtils.isSplitShade()) {
+            val qsBounds = quickSettingsContainer.visibleBounds
+            val notificationBounds = notificationShadeScrollContainer.visibleBounds
+            assertWithMessage(
+                    "Quick settings container is not positioned left to notification stack scroller"
+                )
+                .that(qsBounds.right <= notificationBounds.left)
+                .isTrue()
+        }
+    }
+
+    /* fromLockscreen= */
+    /** Returns the shade's notification stack. */
+    val notificationStack: NotificationStack
+        get() = NotificationStack(/* fromLockscreen= */ false)
+
+    /**
+     * Returns a SystemUI test object representing the Quick Quick Settings element in the
+     * Notification Shade.
+     */
+    val quickQuickSettings: QuickQuickSettings
+        get() = QuickQuickSettings()
+
+    /** Check whether QuickSettings are expanded in the NotificationShade. */
+    fun assertQuickSettingsExpanded() {
+        assertWithMessage("QuickQuickSettings is visible")
+            .waitUntilGone(QuickQuickSettings.UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR)
+    }
+
+    /** Check whether QuickSettings are collapsed in the NotificationShade. */
+    fun assertQuickSettingsCollapsed() {
+        assertWithMessage("QuickQuickSettings not visible, shade is not collapsed")
+            .waitUntilVisible(QuickQuickSettings.UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR)
+    }
+
+    fun verifyIsEmpty() {
+        assertWithMessage("Notification shade is not empty")
+            .waitUntilVisible(sysuiResSelector(UI_EMPTY_SHADE_VIEW_ID))
+    }
+
+    fun verifyIsNotEmpty() {
+        assertWithMessage("Notification shade is empty")
+            .waitUntilGone(sysuiResSelector(UI_EMPTY_SHADE_VIEW_ID))
+    }
+
+    fun verifyIsShowingFooter() {
+        assertWithMessage("Notification footer is invisible")
+            .waitUntilVisible(sysuiResSelector(UI_SETTINGS_BUTTON_ID))
+    }
+
+    fun verifyIsNotShowingFooter() {
+        assertWithMessage("Notification footer is visible")
+            .waitUntilGone(sysuiResSelector(UI_SETTINGS_BUTTON_ID))
+    }
+
+    /** Click Manage button to open notification settings page. */
+    fun openNotificationSettingsFromButton() {
+        val manageBtn =
+            if (Flags.notificationsRedesignFooterView())
+                scrollAndFindButton("Notification settings")
+            else scrollAndFindButton("Manage")
+        assertThat(manageBtn).isNotNull()
+        Gestures.click(manageBtn!!, "Settings button")
+
+        settingsResSelector("app_bar").assertVisible()
+    }
+
+    private fun scrollAndFindButton(desc: String): UiObject2? {
+        var btn: UiObject2? = null
+        for (i in 0 until SCROLL_TIMES) {
+            btn = uiDevice.wait(Until.findObject(By.desc(desc)), LONG_WAIT.toMillis())
+            if (btn != null) {
+                break
+            }
+            flingDown()
+        }
+        return btn
+    }
+
+    /** Presses Clear All button. */
+    fun clearAllNotifications() {
+        scrollToBottom()
+        val device = uiDevice
+        sysuiResSelector(UI_EMPTY_SHADE_VIEW_ID).assertInvisible {
+            "Shade is empty; cannot clear all"
+        }
+        TaplUiDevice.waitForObject(
+                sysuiResSelector(UI_CLEAR_ALL_BUTTON_ID),
+                objectName = "Clear All button",
+            )
+            .click()
+        waitForShadeToClose()
+        Root.get().goHomeViaKeycode()
+    }
+
+    /**
+     * Performs a fling gesture from the bottom towards the top of the shade, thereby scrolling it
+     * down (or closing it where appropriate).
+     */
+    fun flingUp() {
+        fling(Direction.UP)
+    }
+
+    /**
+     * Performs a fling gesture from the top towards the bottom of the shade, thereby scrolling it
+     * up (or opening the quick settings where appropriate).
+     */
+    fun flingDown() {
+        fling(Direction.DOWN)
+    }
+
+    private fun fling(direction: Direction) {
+        val notificationObject = notificationsStack ?: error("Notification stack is not visible")
+        val notificationList = TaplUiObject(notificationObject, "Notification stack")
+        val notificationListY: Int = notificationObject.visibleBounds.height()
+        notificationList.setGestureMargin(floor(notificationListY * 0.2).toInt())
+        notificationList.fling(direction, 1.0f)
+        uiDevice.waitForIdle()
+    }
+
+    /** Scrolls the shade to the bottom. */
+    fun scrollToBottom() {
+        for (retries in 0 until Notification.MAX_FIND_BOTTOM_ATTEMPTS) {
+            // Checks the notification list has scrolled to the bottom or not
+            if (isShowingBottomOfShade) {
+                notificationStack.assertShelfVisibility(/* visible= */ false)
+                return
+            }
+            NotificationStack.scrollNotificationListOnce(Direction.DOWN)
+        }
+        throw AssertionError("Failed to find the bottom of the notification shade")
+    }
+
+    /** Closes the shade. */
+    fun close() {
+        val device = uiDevice
+        // Swipe in first quarter to avoid desktop windowing app handle interactions.
+        val swipeXCoordinate = device.displayWidth / 4
+        device.betterSwipe(
+            startX = swipeXCoordinate,
+            startY = screenBottom,
+            endX = swipeXCoordinate,
+            endY = 0,
+            interpolator = FLING_GESTURE_INTERPOLATOR,
+        )
+        waitForShadeToClose()
+    }
+
+    /** Closes the shade with the back button. */
+    fun closeWithBackButton() {
+        LauncherInstrumentation().pressBack()
+        waitForShadeToClose()
+    }
+
+    // UiDevice#getDisplayHeight() excludes insets.
+    private val screenBottom: Int
+        get() {
+            val mWindowMetrics: WindowMetrics =
+                context
+                    .getSystemService<WindowManager>(WindowManager::class.java)!!
+                    .getMaximumWindowMetrics()
+
+            // UiDevice#getDisplayHeight() excludes insets.
+            return mWindowMetrics.getBounds().height() - 1
+        }
+
+    /** Scrolls the shade down. */
+    fun scrollDown() {
+        NotificationStack.scrollNotificationListOnce(Direction.DOWN)
+    }
+
+    /** Scrolls the shade up. */
+    fun scrollUp() {
+        NotificationStack.scrollNotificationListOnce(Direction.UP)
+    }
+
+    /**
+     * Returns the type of the shade.
+     *
+     * This depends by the device characteristics (e.g. currently large screens in landscape has a
+     * split shade, composed by two columns)
+     */
+    val type: NotificationShadeType
+        get() {
+            val stackBounds = notificationsStack!!.visibleBounds
+            val stackWidth = stackBounds.width()
+            val displayWidth = uiDevice.displayWidth
+            return if (stackWidth <= displayWidth / 2) NotificationShadeType.SPLIT
+            else NotificationShadeType.NORMAL
+        }
+
+    /** Opens quick settings via swipe. */
+    fun openQuickSettings(): QuickSettings {
+        val device = uiDevice
+        // Swipe in first quarter to avoid desktop windowing app handle interactions.
+        val swipeXCoordinate = device.displayWidth / 4
+        device.betterSwipe(
+            startX = swipeXCoordinate,
+            startY = 0,
+            endX = swipeXCoordinate,
+            endY = device.displayHeight,
+        )
+        SystemClock.sleep(SHORT_TIMEOUT.toLong())
+        return QuickSettings()
+    }
+
+    /** Returns Quick Settings (aka expanded Quick Settings) or fails if it's not visible. */
+    val quickSettings: QuickSettings
+        get() = QuickSettings()
+
+    /**
+     * Returns the visible UMO, or fails if it's not visible.
+     *
+     * **See:** [HSV](https://hsv.googleplex.com/5715413598994432?node=44)
+     */
+    val universalMediaObject: UniversalMediaObject
+        get() = UniversalMediaObject()
+
+    /**
+     * Returns the QS header. Experimental.
+     *
+     * It provided both from here and from [QuickSettings] because there are slightly different
+     * layouts when QS are expanded and collapsed.
+     */
+    val header: QSHeader
+        get() = QSHeader()
+
+    companion object {
+        private val QS_HEADER_SELECTOR = sysuiResSelector("split_shade_status_bar")
+        private const val WAIT_TIME = 10_000L
+        private const val UI_EMPTY_SHADE_VIEW_ID = "no_notifications"
+        private val UI_SETTINGS_BUTTON_ID =
+            if (Flags.notificationsRedesignFooterView()) "settings_button" else "manage_text"
+        private const val UI_QS_CONTAINER_ID = "quick_settings_container"
+        private const val UI_RESPONSE_TIMEOUT_MSECS: Long = 3000
+        private const val UI_CLEAR_ALL_BUTTON_ID = "dismiss_text"
+        private const val SHORT_TRANSITION_WAIT: Long = 1500
+        private const val UI_NOTIFICATION_LIST_ID = "notification_stack_scroller"
+        private const val SCROLL_TIMES = 3
+        private const val SHORT_TIMEOUT = 500
+        const val NOTIFICATION_MAX_HIERARCHY_DEPTH = 4
+        const val EXPANDABLE_NOTIFICATION_ROW = "expandableNotificationRow"
+        const val SHELF_ID = "notificationShelf"
+        const val UI_SCROLLABLE_ELEMENT_ID = "notification_stack_scroller"
+        const val HEADER_EXPAND_BUTTON = "expand_button"
+        val notificationsStack: UiObject2?
+            get() =
+                uiDevice.wait(
+                    Until.findObject(sysuiResSelector(UI_NOTIFICATION_LIST_ID)),
+                    SHORT_TRANSITION_WAIT,
+                )
+
+        val isShowingBottomOfShade: Boolean
+            get() = isShowingEmptyShade || isShowingFooter
+
+        private val isShowingEmptyShade: Boolean
+            get() = uiDevice.hasObject(sysuiResSelector(UI_EMPTY_SHADE_VIEW_ID))
+
+        private val isShowingFooter: Boolean
+            get() = uiDevice.hasObject(sysuiResSelector(UI_SETTINGS_BUTTON_ID))
+
+        private val quickSettingsContainer: UiObject2
+            get() =
+                uiDevice.wait(
+                    Until.findObject(sysuiResSelector(UI_QS_CONTAINER_ID)),
+                    UI_RESPONSE_TIMEOUT_MSECS,
+                ) ?: error("Can't find qs container.")
+
+        private val notificationShadeScrollContainer: UiObject2
+            get() =
+                uiDevice.wait(
+                    Until.findObject(sysuiResSelector(UI_SCROLLABLE_ELEMENT_ID)),
+                    UI_RESPONSE_TIMEOUT_MSECS,
+                ) ?: error("Can't find notification shade scroll container.")
+
+        @JvmStatic
+        fun waitForShadeToClose() {
+            trace("waitForShadeToClose") {
+                // QS header view used in all configurations of Notification shade.
+                QS_HEADER_SELECTOR.assertInvisible { "Notification shade didn't close" }
+                // Asserts on new QS resId.
+                sysuiResSelector("shade_header_root").assertInvisible {
+                    "Notification shade didn't close"
+                }
+            }
+        }
+    }
+}
+
+private fun StandardSubjectBuilder.waitUntilGone(selector: BySelector) {
+    that(uiDevice.wait(Until.gone(selector), LONG_WAIT.toMillis())).isTrue()
+}
+
+private fun StandardSubjectBuilder.waitUntilVisible(selector: BySelector) {
+    that(uiDevice.wait(Until.hasObject(selector), LONG_WAIT.toMillis())).isTrue()
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShadeType.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShadeType.kt
new file mode 100644
index 000000000..36a82b8cf
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationShadeType.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.ui.NotificationShadeType.SPLIT
+
+/**
+ * Types for [NotificationShade].
+ *
+ * When [SPLIT], it has two columns: one with QS, and the other with notifications.
+ */
+enum class NotificationShadeType {
+    NORMAL,
+    SPLIT,
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt
new file mode 100644
index 000000000..922e0dc6b
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/NotificationStack.kt
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Rect
+import android.platform.systemui_tapl.controller.NotificationIdentity
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.BIG_PICTURE
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.BIG_TEXT
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.BY_TEXT
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.BY_TITLE
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.CALL
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.CONVERSATION
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.CUSTOM
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.GROUP
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.GROUP_AUTO_GENERATED
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.GROUP_MINIMIZED
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.INBOX
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.MEDIA
+import android.platform.systemui_tapl.controller.NotificationIdentity.Type.MESSAGING_STYLE
+import android.platform.systemui_tapl.ui.NotificationShade.Companion.SHELF_ID
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.test.scenario.tapl_common.TaplUiObject
+import android.platform.test.util.HealthTestingUtils.waitForValueToSettle
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForNullableObjects
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.WaitUtils.retryIfStale
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import java.time.Duration
+import java.util.regex.Pattern
+import kotlin.math.floor
+import org.junit.Assert.assertTrue
+
+/**
+ * Represents the stack of notifications, terminating with the optional [NotificationShelf].
+ *
+ * This might be shown on several places:
+ * - Lockscreen ([LockscreenNotificationShade])
+ * - Notification shade ([NotificationShade]), pulled-down from the top of the screen.
+ */
+open class NotificationStack internal constructor(val fromLockscreen: Boolean) {
+
+    init {
+        NOTIFICATION_STACK_SCROLLER.assertVisible { "Notification stack scroller didn't appear" }
+    }
+
+    /** Fails when shelf visibility doesn't match [visible] within a timeout. */
+    fun assertShelfVisibility(visible: Boolean) {
+        uiDevice.assertVisibility(NOTIFICATION_SHELF_SELECTOR, visible) {
+            "Notification shelf is ${if (visible) { "invisible" } else {"visible"}}"
+        }
+    }
+
+    /** Fails when [notifications] size doesn't become [expected] within a timeout. */
+    fun assertVisibleNotificationCount(expected: Int) {
+        val errorMessage = {
+            "Notification count didn't match expectations. " +
+                "Count=${notifications.size}, expected=$expected"
+        }
+        ensureThat("Visible notifications count match", errorProvider = errorMessage) {
+            notifications.size == expected
+        }
+    }
+
+    /** Fails when [notifications] count doesn't become at least [expected] within a timeout. */
+    fun assertVisibleNotificationCountAtLeast(expected: Int) {
+        val errorMessage = {
+            "Notification count didn't match expectations. " +
+                "Count=${notifications.size}, expected>=$expected"
+        }
+        ensureThat("Visible notifications count at least $expected", errorProvider = errorMessage) {
+            notifications.size >= expected
+        }
+    }
+
+    /** Returns visible notifications. */
+    val notifications: List<Notification>
+        get() =
+            waitForValueToSettle(/* errorMessage= */ { "visibleNotifications didn't settle." }) {
+                visibleNotifications.map { uiObject ->
+                    Notification(uiObject, fromLockscreen, isHeadsUpNotification = false)
+                }
+            }
+
+    /** Returns visible notifications if able, otherwise [null]. */
+    fun tryGetNotifications(): List<Notification>? {
+        return retryIfStale(description = "tryGetNotifications", times = 3) {
+            return@retryIfStale notifications
+        }
+    }
+
+    /**
+     * Waits for visible notifications to settle (the same number of notifications for several
+     * seconds)
+     */
+    fun waitForNotificationsToSettle() {
+        // Accessing visible notifications waits for them to settle
+        notifications
+    }
+
+    /** @return the bounds of the notification shade. */
+    fun getShadeBounds(): Rect {
+        val stack = waitForObj(NOTIFICATION_STACK_SCROLLER)
+        return Rect().apply { stack.children.forEach { child -> union(child.visibleBounds) } }
+    }
+
+    fun getShelfBounds(): Rect {
+        return waitForObj(NOTIFICATION_SHELF_SELECTOR).visibleBounds
+    }
+
+    /** Returns the [NotificationShelf] if visible, otherwise [null]. */
+    fun tryGetNotificationShelf(): NotificationShelf? {
+        return retryIfStale(description = "tryGetNotificationShelf", times = 3) {
+            return@retryIfStale waitForValueToSettle(
+                /* errorMessage= */ { "Notification shelf didn't settle." }) {
+                notificationShelfObject?.let { NotificationShelf(rect = it.visibleBounds) }
+            }
+        }
+    }
+
+    /**
+     * Finds a notification by its identity. Fails if the notification can't be found.
+     *
+     * @param identity description of the notification tyoe and properties
+     * @param waitTimeout duration to wait for notification to appear.
+     * @return Notification (throws assertion if not found)
+     */
+    @JvmOverloads
+    fun findNotification(
+        identity: NotificationIdentity,
+        waitTimeout: Duration = LONG_WAIT,
+    ): Notification =
+        findNotificationInternal(
+            identity,
+            fromLockscreen,
+            isHeadsUpNotification = false,
+            scroll = false,
+            waitTimeout = waitTimeout,
+        )
+
+    /**
+     * Scrolls to a notification defined by its identity. Fails if the notification can't be found
+     * in the shade.
+     *
+     * @param identity description of the notification tyoe and properties
+     * @param waitTimeout duration to wait for notification to appear.
+     * @return Notification (throws assertion if not found)
+     */
+    fun scrollToNotification(
+        identity: NotificationIdentity,
+        waitTimeout: Duration = LONG_WAIT,
+    ): Notification =
+        findNotificationInternal(
+            identity,
+            fromLockscreen,
+            isHeadsUpNotification = false,
+            scroll = true,
+            waitTimeout = waitTimeout,
+        )
+
+    companion object {
+
+        /**
+         * Finds a HUN by its identity. Fails if the notification can't be found.
+         *
+         * @param identity The NotificationIdentity used to find the HUN
+         * @param assertIsHunState When it's true, findHeadsUpNotification would fail if the
+         *   notification is not at the HUN state (eg. showing in the Shade), or its HUN state
+         *   cannot be verified. An action button is necessary for the verification. Consider
+         *   posting the HUN with NotificationController#postBigTextHeadsUpNotification if you need
+         *   to assert the HUN state. Expanded HUN state cannot be asserted.
+         * @param waitTimeout duration to wait for the notification to appear.
+         * @return Notification (throws assertion if not found)
+         */
+        @JvmOverloads
+        @JvmStatic
+        internal fun findHeadsUpNotification(
+            identity: NotificationIdentity,
+            assertIsHunState: Boolean = true,
+            waitTimeout: Duration = LONG_WAIT,
+        ): Notification {
+            if (!assertIsHunState) {
+                return findNotificationInternal(
+                    identity = identity,
+                    fromLockscreen = false,
+                    isHeadsUpNotification = true,
+                    scroll = false,
+                    waitTimeout = waitTimeout,
+                )
+            }
+
+            assertTrue(
+                "HUN state Assertion usage error: Notification: ${identity.title} " +
+                    "| You can only assert the HUN State of a notification that has an action " +
+                    "button. Add an action button to the notification or set assertHeadsUpState " +
+                    "to false.",
+                identity.hasAction,
+            )
+
+            val notification =
+                findNotificationInternal(
+                    identity,
+                    fromLockscreen = false,
+                    isHeadsUpNotification = true,
+                    scroll = false,
+                    waitTimeout = waitTimeout,
+                )
+            notification.verifyIsHunState()
+            return notification
+        }
+
+        /**
+         * Finds a notification by its identity. Fails is the notification can't be found.
+         *
+         * @param identity description of the notification tyoe and properties.
+         * @param fromLockscreen flag set in the returned Notification object.
+         * @param isHeadsUpNotification flag set in the returned Notification object.
+         * @param scroll allow scrolling to find the notification in the notification stak.
+         * @param waitTimeout duration to wait for notification to appear.
+         * @return Notification (throws assertion if not found)
+         */
+        @JvmStatic
+        private fun findNotificationInternal(
+            identity: NotificationIdentity,
+            fromLockscreen: Boolean,
+            isHeadsUpNotification: Boolean,
+            scroll: Boolean,
+            waitTimeout: Duration,
+        ): Notification {
+
+            // Generate the selector for the expanded notification.
+            val selectorWhenExpanded: BySelector? =
+                when (identity.type) {
+                    GROUP,
+                    GROUP_AUTO_GENERATED,
+                    GROUP_MINIMIZED -> null
+                    BIG_TEXT -> By.text(identity.textWhenExpanded!!)
+                    BIG_PICTURE -> BIG_PICTURE_SELECTOR
+                    CUSTOM -> CUSTOM_NOTIFICATION_SELECTOR
+                    CALL,
+                    MEDIA,
+                    INBOX,
+                    BY_TEXT -> By.text(identity.text!!)
+                    MESSAGING_STYLE,
+                    CONVERSATION -> MESSAGE_ICON_CONTAINER_SELECTOR
+                    BY_TITLE -> notificationByTitleSelector(identity.title!!)
+                }
+
+            // Generate the selector for the notification
+            val selector =
+                when (identity.type) {
+                    GROUP -> groupBySummarySelector(identity.summary!!)
+                    GROUP_MINIMIZED -> minimizedGroupBySummarySelector(identity.title!!)
+                    GROUP_AUTO_GENERATED -> autoGeneratedGroupByAppNameSelector(identity.summary!!)
+                    CALL,
+                    MEDIA,
+                    INBOX,
+                    MESSAGING_STYLE,
+                    CONVERSATION,
+                    BY_TEXT -> notificationByTextSelector(identity.text!!)
+                    BIG_TEXT -> notificationByTitleSelector(identity.title!!)
+                    CUSTOM -> CUSTOM_NOTIFICATION_SELECTOR
+                    BY_TITLE -> notificationByTitleSelector(identity.title!!)
+                    else -> notificationByTitleSelector(identity.text!!)
+                }
+
+            // If scrolling is enabled, scroll to the notification using the selector,
+            // otherwise, just wait for it.
+            val notification =
+                if (scroll) {
+                    scrollToNotificationBySelector(selector)
+                } else {
+                    waitForObj(selector, waitTimeout)
+                }
+
+            // Notification groups should have at least 2 children
+            if (identity.type == GROUP || identity.type == GROUP_AUTO_GENERATED) {
+                val childCount = notification.findObjects(NOTIFICATION_ROW_SELECTOR).size
+                assertTrue(
+                    "Wanted at least 2 children, but found only $childCount.",
+                    childCount >= 2,
+                )
+            }
+            return if (identity.type == GROUP) {
+                Notification(
+                    notification = notification,
+                    groupNotificationIdentity = identity,
+                    selectorWhenExpanded = selectorWhenExpanded,
+                    contentIsVisibleInCollapsedState = false,
+                    isBigText = true,
+                    pkg = identity.pkg,
+                    fromLockscreen = fromLockscreen,
+                    isHeadsUpNotification = isHeadsUpNotification,
+                )
+            } else {
+                Notification(
+                    notification = notification,
+                    selectorWhenExpanded = selectorWhenExpanded,
+                    contentIsVisibleInCollapsedState = identity.contentIsVisibleInCollapsedState,
+                    isBigText = identity.type == BIG_TEXT,
+                    pkg = identity.pkg,
+                    fromLockscreen = fromLockscreen,
+                    isHeadsUpNotification = isHeadsUpNotification,
+                )
+            }
+        }
+
+        private fun groupBySummarySelector(summary: String): BySelector {
+            return By.copy(NOTIFICATION_ROW_SELECTOR)
+                .hasDescendant(androidResSelector("header_text").text(summary))
+                .hasDescendant(NOTIFICATION_ROW_SELECTOR)
+        }
+
+        private fun minimizedGroupBySummarySelector(summary: String): BySelector {
+            return By.copy(NOTIFICATION_ROW_SELECTOR)
+                .hasDescendant(androidResSelector("header_text").text(summary))
+                .hasDescendant(NOTIFICATION_HEADER_EXPAND_BUTTON_SELECTOR)
+        }
+
+        private fun autoGeneratedGroupByAppNameSelector(appName: String): BySelector {
+            return By.copy(NOTIFICATION_ROW_SELECTOR)
+                .hasDescendant(androidResSelector("app_name_text").text(appName))
+                .hasDescendant(NOTIFICATION_ROW_SELECTOR)
+        }
+
+        private fun notificationByTitleSelector(title: String) =
+            By.copy(NOTIFICATION_ROW_SELECTOR)
+                .hasDescendant(androidResSelector("title").text(title))
+
+        internal fun notificationByTextSelector(text: String) =
+            By.copy(NOTIFICATION_ROW_SELECTOR).hasDescendant(By.text(text))
+
+        internal fun getNotificationCountByIdentityText(identity: NotificationIdentity): Int {
+            val notifications: Collection<UiObject2> =
+                uiDevice.wait(
+                    Until.findObjects(notificationByTextSelector(identity.text!!)),
+                    LONG_WAIT.toMillis(),
+                ) ?: throw AssertionError("Cannot find notifications with text '${identity.text}'")
+            return notifications.size
+        }
+
+        private fun scrollToNotificationBySelector(selector: BySelector): UiObject2 {
+            // fail if the device doesn't become idle
+            uiDevice.waitForIdle(LONG_WAIT.toMillis())
+            // wait for the first element longer, maybe our notifications are not posted yet
+            var found = waitForNullableObj(selector, LONG_WAIT)
+            var scrolledToBottom = NotificationShade.isShowingBottomOfShade
+            var retries = 0
+            while (
+                retries++ < MAX_FIND_NOTIFICATION_ATTEMPTS && !scrolledToBottom && found == null
+            ) {
+                scrollNotificationListOnce(Direction.DOWN)
+                scrolledToBottom = NotificationShade.isShowingBottomOfShade
+
+                found =
+                    waitForNullableObj(selector)?.takeIf {
+                        // only take this object, if it is entirely scrolled above the shelf
+                        scrolledToBottom || isAboveShelf(it)
+                    }
+            }
+
+            return checkNotNull(found) { "Did not find notification matching $selector" }
+        }
+
+        private fun isAboveShelf(notification: UiObject2): Boolean {
+            val stack: UiObject2 =
+                NotificationShade.notificationsStack ?: error("Notification stack is not visible")
+            val shelf = stack.findObject(NOTIFICATION_SHELF_SELECTOR) ?: return true
+            return notification.visibleBounds.bottom < shelf.visibleBounds.top
+        }
+
+        /** Performs one swipe to scroll notification list. */
+        internal fun scrollNotificationListOnce(direction: Direction) {
+            val notificationListObject2: UiObject2 =
+                NotificationShade.notificationsStack ?: error("Notification stack is not visible")
+            val notificationList = TaplUiObject(notificationListObject2, "Notification stack")
+            val notificationListY: Int = notificationListObject2.visibleBounds.height()
+            notificationList.setGestureMargin(floor(notificationListY * 0.2).toInt())
+            notificationList.scroll(direction, 1.0f)
+        }
+
+        private val notificationShelfObject: UiObject2?
+            get() = uiDevice.waitForNullableObj(NOTIFICATION_SHELF_SELECTOR)
+
+        private val visibleNotifications: List<UiObject2>
+            get() = uiDevice.waitForNullableObjects(NOTIFICATION_ROW_SELECTOR) ?: emptyList()
+
+        private const val MAX_FIND_NOTIFICATION_ATTEMPTS = 15
+        private val NOTIFICATION_SHELF_SELECTOR =
+            sysuiResSelector(SHELF_ID).maxDepth(NotificationShade.NOTIFICATION_MAX_HIERARCHY_DEPTH)
+        private val NOTIFICATION_STACK_SCROLLER = sysuiResSelector("notification_stack_scroller")
+        private val BIG_PICTURE_SELECTOR = androidResSelector("big_picture")
+        private val MESSAGE_ICON_CONTAINER_SELECTOR = androidResSelector("message_icon_container")
+        private val CUSTOM_NOTIFICATION_SELECTOR =
+            By.text(Pattern.compile("Example text|Example Text"))
+
+        internal val NOTIFICATION_ROW_SELECTOR =
+            sysuiResSelector(NotificationShade.EXPANDABLE_NOTIFICATION_ROW)
+
+        internal val NOTIFICATION_HEADER_EXPAND_BUTTON_SELECTOR =
+            androidResSelector(NotificationShade.HEADER_EXPAND_BUTTON)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/OneHandModeTutorial.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/OneHandModeTutorial.kt
new file mode 100644
index 000000000..72d9a24ee
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/OneHandModeTutorial.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Rect
+import android.platform.systemui_tapl.ui.NotificationShade.Companion.waitForShadeToClose
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.view.WindowInsets
+import android.view.WindowManager
+import android.view.WindowMetrics
+
+/**
+ * System UI test automation object representing swipe down screen bottom to trigger one-handed mode
+ * triggered, the whole screen translate down and tutorial shown on top area.
+ * HSV:https://hsv.googleplex.com/4846680840077312 Lastly, swipe down gesture to close one-handed
+ * mode, and ensure the display area recovered. Swipe gesture
+ * region:https://screenshot.googleplex.com/q83UXMidE2PUFDq)
+ */
+class OneHandModeTutorial internal constructor() {
+
+    init {
+        waitForShadeToClose()
+        TUTORIAL_SELECTOR.assertVisible()
+    }
+
+    /**
+     * Closes the one-handed mode by swipe up gesture at screen bottom area. Gesture region:
+     * https://screenshot.googleplex.com/q83UXMidE2PUFDq, and make sure the tutorial invisible from
+     * screen at the end.
+     */
+    fun close() {
+        val windowMetrics: WindowMetrics =
+            DeviceHelpers.context.getSystemService(WindowManager::class.java)!!.currentWindowMetrics
+        val insets: WindowInsets = windowMetrics.windowInsets
+        val displayBounds: Rect = windowMetrics.bounds
+        val bottomMandatoryGestureHeight: Int =
+            insets
+                .getInsetsIgnoringVisibility(
+                    WindowInsets.Type.navigationBars() or WindowInsets.Type.displayCutout()
+                )
+                .bottom
+
+        // Swipe up from screen bottom exiting one-handed mode in System Gesture mandatory region.
+        betterSwipe(
+            displayBounds.width() / 2,
+            displayBounds.height(),
+            displayBounds.width() / 2,
+            displayBounds.height() - Math.round(bottomMandatoryGestureHeight * 2.5f),
+        )
+
+        TUTORIAL_SELECTOR.assertInvisible()
+    }
+
+    companion object {
+        private val TUTORIAL_SELECTOR = sysuiResSelector("one_handed_tutorial_layout")
+        private const val TRANSITION_TIMEOUT = 20000
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/PowerPanel.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/PowerPanel.kt
new file mode 100644
index 000000000..6a91cfe9c
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/PowerPanel.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import androidx.test.uiautomator.By
+import com.android.launcher3.tapl.LauncherInstrumentation
+import java.util.regex.Pattern
+
+/** System UI test automation object representing the panel with power controls aka "power menu". */
+class PowerPanel internal constructor() {
+    init {
+        POWER_PANEL_SELECTOR.assertVisible()
+        POWER_OFF_BUTTON_SELECTOR.assertVisible()
+    }
+
+    /** Closes the panel and returns to the previous UI object. */
+    fun close() {
+        LauncherInstrumentation().pressBack()
+        POWER_PANEL_SELECTOR.assertInvisible()
+        POWER_OFF_BUTTON_SELECTOR.assertInvisible { "System power menu is visible" }
+    }
+
+    private companion object {
+        private val POWER_PANEL_SELECTOR = sysuiResSelector("list_flow")
+
+        // https://hsv.googleplex.com/6244730548518912?node=13
+        private val POWER_OFF_BUTTON_SELECTOR =
+            By.text(Pattern.compile("Power off", Pattern.CASE_INSENSITIVE))
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QSHeader.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QSHeader.kt
new file mode 100644
index 000000000..9d123a266
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QSHeader.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.SHORT_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.regex.Pattern
+
+/**
+ * Space above quick settings, similar to the status bar. Visible only when the shade is open. It
+ * what's visible inside might differ when:
+ * - in QQS state
+ * - in QS state
+ * - Large screen device https://hsv.googleplex.com/4864533182021632?node=16
+ */
+class QSHeader internal constructor() {
+    private val uiObject =
+        waitForFirstObj(
+                sysuiResSelector("shade_header_root"),
+                sysuiResSelector("split_shade_status_bar"),
+                timeout = LONG_WAIT,
+            )
+            .first
+
+    /** Returns the value of the battery level on QS header. Experimental. */
+    fun getBatteryLevel(): String {
+        return uiDevice
+            .waitForObj(sysuiResSelector(StatusBar.BATTERY_LEVEL_TEXT_ID)) {
+                "Battery percentage not found on QS header."
+            }
+            .text
+    }
+
+    /** Verifies the clock is visible. Throws otherwise. Experimental. */
+    fun verifyTimeVisible() {
+        // Matches 12h or 24h time format
+        val timePattern = Pattern.compile("^(?:[01]?\\d|2[0-3]):[0-5]\\d")
+        By.pkg("com.android.systemui").text(timePattern).assertVisible(SHORT_WAIT)
+    }
+
+    /** Verifies the date is visible. Throws otherwise. Experimental. */
+    fun verifyDateVisible() {
+        val date = Date(System.currentTimeMillis())
+        val dateText = SimpleDateFormat("EEE, MMM d", Locale.ENGLISH).format(date)
+        By.pkg("com.android.systemui").text(dateText).assertVisible(SHORT_WAIT)
+    }
+
+    /** Verifies status icons are visible. Throws otherwise. Experimental. */
+    fun verifyStatusIconsVisible() {
+        // See {@link EnsureAtLeastOneStatusBarIconVisibleRule}
+        verifySilentIconIsVisible()
+    }
+
+    /** Verifies the battery percentage is visible. Throws otherwise. Experimental. */
+    fun verifyBatteryMeterVisible() {
+        "battery_percentage_view".assertVisible()
+    }
+
+    /** Verifies that dock defend icon is visible. */
+    fun verifyDockDefendIconVisible() {
+        uiObject.hasObject(By.descContains(StatusBar.DOCK_DEFEND_ICON_SUFFIX_STRING))
+    }
+
+    /** Verifies that DND icon is visible. Experimental. */
+    fun verifyDndIconIsVisible() {
+        By.pkg("com.android.systemui")
+            .clazz("android.widget.ImageView")
+            .desc(StatusBar.DND_ICON_DESC)
+            .assertVisible(SHORT_WAIT)
+    }
+
+    /** Verifies that silent icon is visible. */
+    fun verifySilentIconIsVisible() {
+        By.pkg("com.android.systemui")
+            .clazz("android.widget.ImageView")
+            .desc("Ringer silent.")
+            .assertVisible(SHORT_WAIT)
+    }
+
+    private fun String.assertVisible() = sysuiResSelector(this).assertVisible(timeout = SHORT_WAIT)
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt
new file mode 100644
index 000000000..58833c1ac
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickQuickSettings.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.ui.ComposeQuickSettingsTile.Companion.assertIsTile
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisibility
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.UiObject2
+import com.android.systemui.Flags
+
+/**
+ * System UI test automation object representing quick quick settings in the notification shade.
+ *
+ * This is the area that contains a few tiles and doesn't have pages, appearing on top of the
+ * Notification space.
+ *
+ * https://hsv.googleplex.com/4814389392703488?node=15#
+ */
+class QuickQuickSettings internal constructor() {
+
+    private val qqsTilesContainer: UiObject2
+
+    init {
+        UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR.assertVisible(timeout = LONG_WAIT) {
+            "Quick quick settings not visible"
+        }
+        qqsTilesContainer =
+            waitForObj(UI_QQS_TILE_LAYOUT_SELECTOR) {
+                "Quick quick settings does not have a tile layout"
+            }
+    }
+
+    /**
+     * Get a list of [QuickSettingsTile] objects, each representing one of the tiles visible in the
+     * QuickQuickSettings container. Will fail if there's an element that's not a tile (i.e.,
+     * doesn't have the label view as https://hsv.googleplex.com/4814389392703488?node=22#), only
+     * when the [qsUiRefactorComposeFragment] flag is false.
+     */
+    fun getVisibleTiles(): List<QuickQuickSettingsTile> {
+        val uiTiles = qqsTilesContainer.children
+        if (!Flags.qsUiRefactorComposeFragment()) {
+            uiTiles.forEach { tile ->
+                tile.assertVisibility(UI_TILE_LABEL_SELECTOR, visible = true)
+            }
+        }
+        return uiTiles.map { QuickQuickSettingsTile(it) }
+    }
+
+    fun getVisibleComposeTiles(): List<ComposeQuickSettingsTile> {
+        val uiChildren = qqsTilesContainer.children
+        val largeTileSelector = sysuiResSelector(ComposeQuickSettingsTile.LARGE_TILE_TAG)
+        val smallTileSelector = sysuiResSelector(ComposeQuickSettingsTile.SMALL_TILE_TAG)
+        val uiTiles =
+            uiChildren.map { child ->
+                val (tile, _) =
+                    child.waitForFirstObj(smallTileSelector, largeTileSelector) {
+                        "No tile object found in child $child"
+                    }
+                tile.assertIsTile()
+                tile
+            }
+        return uiTiles.map { ComposeQuickSettingsTile.createFrom(it) }
+    }
+
+    companion object {
+        @JvmField
+        val UI_QUICK_QUICK_SETTINGS_CONTAINER_SELECTOR = sysuiResSelector("quick_qs_panel")
+        // https://hsv.googleplex.com/4814389392703488?node=16#
+        private val UI_QQS_TILE_LAYOUT_SELECTOR = sysuiResSelector("qqs_tile_layout")
+        @JvmField
+        // https://hsv.googleplex.com/4814389392703488?node=22#
+        val UI_TILE_LABEL_SELECTOR = sysuiResSelector("tile_label")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt
new file mode 100644
index 000000000..297357376
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettings.kt
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.graphics.PointF
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
+import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.test.scenario.tapl_common.TaplUiObject
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForFirstObj
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.platform.uiautomatorhelpers.scrollUntilFound
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiSelector
+import java.time.Duration
+import java.util.regex.Pattern
+
+/** System UI test automation object representing quick settings in the notification shade. */
+class QuickSettings internal constructor() {
+    // TODO(279061302): Remove TaplUiObject after BetterSwipe has a scroll wrapper.
+    private val pager: TaplUiObject
+
+    private val clazzNamePattern = Pattern.compile("android\\.widget\\.((Switch)|(Button))")
+
+    init {
+        UI_QUICK_SETTINGS_CONTAINER_ID.assertVisible { "Quick settings didn't open" }
+        FOOTER_SELECTOR.assertVisible()
+        pager = TaplUiDevice.waitForObject(PAGER_UI_OBJECT_SELECTOR, "QS pager")
+    }
+
+    /** Presses Power button to open the power panel. */
+    fun openPowerPanel(): PowerPanel {
+        waitForObj(sysuiResSelector(POWER_BTN_RES_ID)).click()
+        return PowerPanel()
+    }
+
+    /** Presses Settings button to open Settings. */
+    fun openSettings() {
+        waitForObj(sysuiResSelector(SETTINGS_BUTTON_RES_ID)).click()
+        By.pkg(SETTINGS_PACKAGE).assertVisible()
+    }
+
+    /** Opens the user selection panel by clicking User Switch button. */
+    fun openUserSelection(): UserSelectionPanel {
+        // Click on the multi user switch icon. http://go/hsv/5465641194618880?node=84
+        waitForObj(sysuiResSelector(MULTI_USER_SWITCH_RES_ID)).click()
+        return UserSelectionPanel()
+    }
+
+    /** Finds a tile by the prefix of its description */
+    fun findTile(tileDesc: String): QuickSettingsTile {
+        // Select by title_label https://hsv.googleplex.com/5476758214148096?node=57
+        val titleLabelSelector = sysuiResSelector("tile_label").textStartsWith(tileDesc)
+        val tileSelector = By.clazz(clazzNamePattern).hasDescendant(titleLabelSelector, 3)
+        waitForObj(tileSelector)
+        return QuickSettingsTile(tileSelector)
+    }
+
+    fun findComposeTile(tileDesc: String): ComposeQuickSettingsTile {
+        val smallTileSelector = ComposeQuickSettingsTile.smallTileSelector(tileDesc)
+        val largeTileSelector = ComposeQuickSettingsTile.largeTileSelector(tileDesc)
+        val (_, selector) = waitForFirstObj(smallTileSelector, largeTileSelector)
+        return ComposeQuickSettingsTile.createFrom(selector)
+    }
+
+    /** Returns the brightness slider. */
+    val brightnessSlider: BrightnessSlider
+        get() = BrightnessSlider()
+
+    /** Returns the QS header. */
+    val header: QSHeader
+        get() = QSHeader()
+
+    /**
+     * Returns the visible UMO, or fails if it's not visible.
+     *
+     * **See:** [HSV](https://hsv.googleplex.com/6702722561605632?node=85)
+     */
+    val universalMediaObject: UniversalMediaObject
+        get() {
+            val footerTop = waitForObj(QUICK_SETTING_FOOTER_SELECTOR).visibleBounds.top
+            waitForObj(QUICK_SETTINGS_SCROLLVIEW_SELECTOR).scrollUntilFound(
+                UniversalMediaObject.MEDIA_CAROUSEL_SCROLLER,
+                direction = Direction.DOWN,
+            ) {
+                val umoBottom = it.visibleBounds.bottom
+                umoBottom - footerTop <= 0
+            }
+            return UniversalMediaObject()
+        }
+
+    /** Swipes up back to QQS or closes shade in case of split shade. */
+    fun close() {
+        swipeUp()
+        UI_QUICK_SETTINGS_CONTAINER_ID.assertInvisible()
+    }
+
+    fun swipeLeft() {
+        pager.fling(Direction.LEFT, 0.5f)
+    }
+
+    private fun swipeUp() {
+        val displayWidth = uiDevice.displayWidth
+        val displayHeight = uiDevice.displayHeight
+        BetterSwipe.from(PointF((displayWidth / 2).toFloat(), displayHeight.toFloat() - 1f))
+            .to(
+                PointF((displayWidth / 2).toFloat(), 0f),
+                Duration.ofMillis(500),
+                FLING_GESTURE_INTERPOLATOR,
+            )
+            .release()
+    }
+
+    private companion object {
+        val UI_QUICK_SETTINGS_CONTAINER_ID = sysuiResSelector("quick_settings_panel")
+        val FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
+
+        // https://hsv.googleplex.com/5291196806070272?node=109
+        const val POWER_BTN_RES_ID = "pm_lite"
+
+        // https://hsv.googleplex.com/5291196806070272?node=108
+        const val SETTINGS_BUTTON_RES_ID = "settings_button_container"
+
+        // http://go/hsv/5465641194618880?node=84
+        const val MULTI_USER_SWITCH_RES_ID = "multi_user_switch"
+        const val PAGER_CLASS_NAME = "androidx.viewpager.widget.ViewPager"
+        const val PAGER_RES_ID = "$SYSUI_PACKAGE:id/qs_pager"
+        val PAGER_SELECTOR = UiSelector().className(PAGER_CLASS_NAME).resourceId(PAGER_RES_ID)
+        const val PAGER_UI_OBJECT_RES_ID = "qs_pager"
+        val PAGER_UI_OBJECT_SELECTOR = sysuiResSelector(PAGER_UI_OBJECT_RES_ID)
+        private val QUICK_SETTINGS_SCROLLVIEW_SELECTOR = sysuiResSelector("expanded_qs_scroll_view")
+        private val QUICK_SETTING_FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt
new file mode 100644
index 000000000..145bbc1fa
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/QuickSettingsTileBase.kt
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SETTINGS_PACKAGE
+import android.platform.test.scenario.tapl_common.Gestures
+import android.platform.test.scenario.tapl_common.Gestures.click
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.test.util.HealthTestingUtils.waitForValueCatchingStaleObjectExceptions
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.WaitResult
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.WaitUtils.waitToBecomeTrue
+import android.platform.uiautomatorhelpers.scrollUntilFound
+import android.util.Log
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiObject2
+import com.android.systemui.Flags
+import com.google.common.truth.Truth.assertWithMessage
+
+/** Base class for tiles in Quick Settings and Quick Quick Settings */
+sealed class QuickSettingsTileBase {
+    protected abstract val tile: UiObject2
+
+    /**
+     * Obtain the label of this tile. Will fail if the label is not found or it doesn't have text.
+     */
+    val tileLabel: String
+        get() {
+            val label =
+                if (Flags.qsUiRefactorComposeFragment()) {
+                    tile.contentDescription
+                } else {
+                    tile.waitForObj(QuickQuickSettings.UI_TILE_LABEL_SELECTOR).text
+                }
+            assertWithMessage("Tile label should not be null").that(label).isNotNull()
+            return label
+        }
+
+    /** Returns whether the tile is checked. */
+    val isChecked: Boolean
+        get() {
+            ensureThat("tile is clickable") {
+                waitForValueCatchingStaleObjectExceptions({
+                    "Failed to get clickable state for tile."
+                }) {
+                    tile.isClickable
+                }
+            }
+            return waitForValueCatchingStaleObjectExceptions({
+                "Failed to get checked state for tile"
+            }) {
+                tile.isChecked
+            }
+        }
+
+    /** Clicks a non-Internet tile and verifies that its checked state changes. */
+    fun click() {
+        val wasChecked = isChecked
+        click(tile, "Tile")
+        assertCheckedStatus(!wasChecked)
+    }
+
+    /**
+     * Clicks a non-Internet tile without any assertions about resulting tile state. Please don't
+     * use unless you have a very good reason to omit assertions.
+     */
+    fun clickWithoutAssertions() {
+        click(tile, "Tile")
+    }
+
+    fun assertCheckedStatus(checked: Boolean) {
+        val expectedState = if (checked) "checked" else "unchecked"
+        ensureThat("tile is $expectedState") { tile.isChecked == checked }
+    }
+
+    /** Clicks the Internet tile and presses Done button. */
+    fun clickInternetTile() {
+        click(tile, "Tile")
+        val scrollView =
+            TaplUiDevice.waitForObject(
+                    sysuiResSelector(DIALOG_RES_ID),
+                    objectName = "Internet connectivity dialog",
+                )
+                .waitForChildObject(
+                    childResourceId = SCROLL_VIEW_RES_ID,
+                    childObjectName = "Scroll view",
+                )
+                .uiObject
+        val doneButton = scrollView.scrollUntilFound(DONE_BTN) ?: error("Done button not found")
+        doneButton.click()
+        if (waitToBecomeTrue { !uiDevice.hasObject(DONE_BTN) }.result !is WaitResult.WaitSuccess) {
+            Log.d("QuickSettingsTileBase", "Retrying click due to b/339676505")
+            doneButton.click()
+        }
+        DONE_BTN.assertInvisible(errorProvider = { "Internet dialog is dismissed" })
+    }
+
+    /** Clicks the Bluetooth tile and presses Done button. */
+    fun clickBluetoothTile() {
+        click(tile, "Tile")
+        val scrollView =
+            TaplUiDevice.waitForObject(
+                    sysuiResSelector(BLUETOOTH_TILE_DIALOG_RES_ID),
+                    objectName = "Bluetooth tile dialog",
+                )
+                .waitForChildObject(
+                    childResourceId = SCROLL_VIEW_RES_ID,
+                    childObjectName = "Scroll view",
+                )
+                .uiObject
+        scrollView.scrollUntilFound(DONE_BTN)?.click() ?: error("Done button not found")
+        DONE_BTN.assertInvisible(errorProvider = { "Bluetooth tile dialog is dismissed" })
+    }
+
+    fun clickDnDIntoDialog(): AlertDialog {
+        click(tile, "Tile")
+        return AlertDialog()
+    }
+
+    fun clickModesTile(): ModesDialog {
+        click(tile, "Tile")
+        return ModesDialog()
+    }
+
+    /** Long-clicks the tile and verifies that Settings app appears, unless otherwise specified */
+    fun longClick(expectedSettingsPackage: String? = null) {
+        val longClick = Gestures.longClickDown(tile, "Quick settings tile")
+        try {
+            val packageName = expectedSettingsPackage ?: SETTINGS_PACKAGE
+            By.pkg(packageName).assertVisible { "$packageName didn't appear" }
+        } finally {
+            longClick.up()
+        }
+    }
+
+    private companion object {
+        val DONE_BTN = sysuiResSelector("done_button")
+        const val DIALOG_RES_ID = "internet_connectivity_dialog"
+        const val SCROLL_VIEW_RES_ID = "scroll_view"
+        const val BLUETOOTH_TILE_DIALOG_RES_ID = "root"
+    }
+}
+
+/**
+ * System UI test automation object representing a Quick Settings tile.
+ *
+ * It keeps track of the tile by its selector, instead of the UiObject2 in case it moves in the
+ * middle of the test.
+ */
+class QuickSettingsTile internal constructor(private val selector: BySelector) :
+    QuickSettingsTileBase() {
+
+    override val tile: UiObject2
+        get() = waitForObj(selector)
+}
+
+/**
+ * System UI test automation object representing a Quick Quick Settings tile.
+ *
+ * As these are retrieved by the position, they are associated with the actual object.
+ */
+class QuickQuickSettingsTile internal constructor(override val tile: UiObject2) :
+    QuickSettingsTileBase()
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/RecentMediaCard.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/RecentMediaCard.kt
new file mode 100644
index 000000000..97988f1fb
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/RecentMediaCard.kt
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForPossibleEmpty
+
+/**
+ * Recommend Media Card on the Universal Media Object.
+ *
+ * **See:** [HSV](https://hsv.googleplex.com/6195547053490176?node=86)
+ */
+class RecentMediaCard internal constructor() {
+
+    init {
+        sysuiResSelector("media_recommendations_updated").assertVisible {
+            "Can't find recent media card."
+        }
+    }
+
+    /**
+     * The titles of recommended recent medias. The layout of the card is defined in
+     * [RecommendationViewHolder].
+     */
+    val mediaTitles: List<String>
+        get() = waitForPossibleEmpty(sysuiResSelector("media_title")).map { it.text }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt
new file mode 100644
index 000000000..8e531437f
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Root.kt
@@ -0,0 +1,496 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.graphics.PointF
+import android.graphics.Rect
+import android.os.RemoteException
+import android.os.SystemClock
+import android.platform.systemui_tapl.controller.LockscreenController
+import android.platform.systemui_tapl.controller.NotificationIdentity
+import android.platform.systemui_tapl.ui.ExpandedBubbleStack.Companion.BUBBLE_EXPANDED_VIEW
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.FLING_GESTURE_INTERPOLATOR
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.view.InputDevice
+import android.view.InputEvent
+import android.view.KeyCharacterMap
+import android.view.KeyEvent
+import android.view.WindowInsets
+import android.view.WindowManager
+import android.view.WindowMetrics
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiSelector
+import androidx.test.uiautomator.Until
+import com.android.launcher3.tapl.LauncherInstrumentation
+import com.android.launcher3.tapl.Workspace
+import com.google.common.truth.Truth.assertThat
+import java.time.Duration
+import org.junit.Assert
+
+/**
+ * The root class for System UI test automation objects. All System UI test automation objects are
+ * produced by this class or other System UI test automation objects.
+ */
+class Root private constructor() {
+
+    /**
+     * Opens the notification shade. Use this if there is no need to assert the way of opening it.
+     *
+     * Uses AccessibilityService.GLOBAL_ACTION_NOTIFICATIONS to open the shade, because it turned
+     * out to be more reliable than swipe gestures. Note that GLOBAL_ACTION_NOTIFICATIONS won't open
+     * notifications shade if the lockscreen screen is shown.
+     */
+    fun openNotificationShade(): NotificationShade {
+        return openNotificationShadeViaGlobalAction()
+    }
+
+    /** Opens the notification shade via AccessibilityService.GLOBAL_ACTION_NOTIFICATIONS. */
+    fun openNotificationShadeViaGlobalAction(): NotificationShade {
+        trace("Opening notification shade via global action") {
+            uiDevice.openNotification()
+            waitForShadeToOpen()
+            return NotificationShade()
+        }
+    }
+
+    /** Opens the notification shade via two fingers wipe. */
+    fun openNotificationShadeViaTwoFingersSwipe(): NotificationShade {
+        return openNotificationShadeViaTwoFingersSwipe(Duration.ofMillis(300))
+    }
+
+    /** Opens the notification shade via slow swipe. */
+    fun openNotificationShadeViaSlowSwipe(): NotificationShade {
+        return openNotificationShadeViaSwipe(Duration.ofMillis(3000))
+    }
+
+    /**
+     * Opens the notification shade via swipe with a default speed of 500ms and default start point
+     * of 10% of the display height. NOTE: with b/277063189, the default start point of a quarter of
+     * the way down the screen can overlap a widget and the shade won't open.
+     *
+     * @param swipeDuration amount of time the swipe will last from start to finish
+     * @param heightFraction fraction of the height of the display to start from.
+     */
+    @JvmOverloads
+    fun openNotificationShadeViaSwipe(
+        swipeDuration: Duration = Duration.ofMillis(500),
+        heightFraction: Float = 0.1F,
+    ): NotificationShade {
+        trace("Opening notification shade via swipe") {
+            val device = uiDevice
+            val width = device.displayWidth.toFloat()
+            val height = device.displayHeight.toFloat()
+            BetterSwipe.from(PointF(width / 2, height * heightFraction))
+                .to(PointF(width / 2, height), swipeDuration, FLING_GESTURE_INTERPOLATOR)
+                .release()
+            waitForShadeToOpen()
+            return NotificationShade()
+        }
+    }
+
+    /**
+     * Opens the notification shade via swipe from top of screen. Needed for opening shade while in
+     * an app.
+     */
+    fun openNotificationShadeViaSwipeFromTop(): NotificationShade {
+        val device = uiDevice
+        // Swipe in first quarter to avoid desktop windowing app handle interactions.
+        val swipeXCoordinate = (device.displayWidth / 4).toFloat()
+        val height = device.displayHeight.toFloat()
+        BetterSwipe.from(PointF(swipeXCoordinate, 0f))
+            .to(
+                PointF(swipeXCoordinate, height),
+                Duration.ofMillis(500),
+                FLING_GESTURE_INTERPOLATOR,
+            )
+            .release()
+        waitForShadeToOpen()
+        return NotificationShade()
+    }
+
+    /** Opens the notification shade via swipe. */
+    private fun openNotificationShadeViaTwoFingersSwipe(
+        swipeDuration: Duration
+    ): NotificationShade {
+        val device = uiDevice
+        val width = device.displayWidth
+        val distance = device.displayHeight / 3 * 2
+        // Steps are injected about 5 milliseconds apart
+        val steps = swipeDuration.toMillisPart() / 5
+        val resId = "com.google.android.apps.nexuslauncher:id/workspace"
+        // Wait is only available for UiObject2
+        DeviceHelpers.waitForObj(By.res(resId))
+        val obj = device.findObject(UiSelector().resourceId(resId))
+        obj.performTwoPointerGesture(
+            Point(width / 3, 0),
+            Point(width / 3 * 2, 0),
+            Point(width / 3, distance),
+            Point(width / 3 * 2, distance),
+            steps,
+        )
+        waitForShadeToOpen()
+        return NotificationShade()
+    }
+
+    /**
+     * Finds a HUN by its identity. Fails if the notification can't be found.
+     *
+     * @param identity The NotificationIdentity used to find the HUN
+     * @param assertIsHunState When it's true, findHeadsUpNotification would fail if the
+     *   notification is not at the HUN state (eg. showing in the Shade), or its HUN state cannot be
+     *   verified. An action button is necessary for the verification. Consider posting the HUN with
+     *   NotificationController#postBigTextHeadsUpNotification if you need to assert the HUN state.
+     *   Expanded HUN state cannot be asserted.
+     */
+    @JvmOverloads
+    fun findHeadsUpNotification(
+        identity: NotificationIdentity,
+        assertIsHunState: Boolean = true,
+    ): Notification {
+        return NotificationStack.findHeadsUpNotification(
+            identity = identity,
+            assertIsHunState = assertIsHunState,
+        )
+    }
+
+    /**
+     * Ensures there is not a HUN with this identity. Fails if the HUN is found, or the identity
+     * doesn't have an action button.
+     *
+     * @param identity The NotificationIdentity used to find the HUN, an action button is necessary
+     */
+    // TODO(b/295209746): More robust (and more performant) assertion for "HUN does not appear"
+    fun ensureNoHeadsUpNotification(identity: NotificationIdentity) {
+        Assert.assertTrue(
+            "HUN state Assertion usage error: Notification: ${identity.title} " +
+                "| You can only assert the HUN State of a notification that has an action " +
+                "button.",
+            identity.hasAction,
+        )
+        Assert.assertThrows(IllegalStateException::class.java) {
+            findHeadsUpNotification(identity, assertIsHunState = false)
+        }
+    }
+
+    /** Opens the quick settings via AccessibilityService.GLOBAL_ACTION_QUICK_SETTINGS. */
+    fun openQuickSettingsViaGlobalAction(): QuickSettings {
+        val device = uiDevice
+        device.openQuickSettings()
+        // Quick Settings isn't always open when this is complete. Explicitly wait for the Quick
+        // Settings footer to make sure that the buttons are accessible when the bar is open and
+        // this call is complete.
+        FOOTER_SELECTOR.assertVisible()
+        // Wait an extra bit for the animation to complete. If we return to early, future callers
+        // that are trying to find the location of the footer will get incorrect coordinates
+        device.waitForIdle(LONG_TIMEOUT.toLong())
+        return QuickSettings()
+    }
+
+    /** Gets status bar. */
+    val statusBar: StatusBar
+        get() = StatusBar()
+
+    /** Gets an alert dialog. */
+    val alertDialog: AlertDialog
+        get() = AlertDialog()
+
+    /** Gets a media projection permission dialog. */
+    val mediaProjectionPermissionDialog: MediaProjectionPermissionDialog
+        get() = MediaProjectionPermissionDialog()
+
+    /** Gets a media projection app selector. */
+    val mediaProjectionAppSelector: MediaProjectionAppSelector
+        get() = MediaProjectionAppSelector()
+
+    /** Asserts that the media projection permission dialog is not visible. */
+    fun assertMediaProjectionPermissionDialogNotVisible() {
+        MediaProjectionPermissionDialog.assertSpinnerVisibility(false)
+    }
+
+    /** Gets lock screen. Fails if lock screen is not visible. */
+    val lockScreen: LockScreen
+        get() = LockScreen()
+
+    /** Gets primary bouncer. Fails if the primary bouncer is not visible. */
+    val primaryBouncer: Bouncer
+        get() = Bouncer(null)
+
+    /** Gets Aod. Fails if Aod is not visible. */
+    val aod: Aod
+        get() = Aod()
+
+    /** Gets ChooseScreenLock. Fails if ChooseScreenLock is not visible. */
+    val chooseScreenLock: ChooseScreenLock
+        get() = ChooseScreenLock()
+
+    /** Gets the bubble. Fails if there is no bubble. */
+    val bubble: Bubble
+        get() {
+            val bubbleViews = Bubble.bubbleViews
+            return Bubble(bubbleViews[0])
+        }
+
+    /**
+     * Returns the selected bubble.
+     *
+     * Bubbles in the collapsed stack are reversed. The selected bubble is the last bubble in the
+     * view hierarchy.
+     */
+    val selectedBubble: Bubble
+        get() {
+            val bubbleViews = Bubble.bubbleViews
+            return Bubble(bubbleViews.last())
+        }
+
+    /** Gets the expanded bubble stack. Fails if no stack or if the stack is not expanded. */
+    val expandedBubbleStack: ExpandedBubbleStack
+        get() = ExpandedBubbleStack()
+
+    /** Gets the collapsed bubble bar in launcher. */
+    val bubbleBar: BubbleBar
+        get() = BubbleBar()
+
+    /** Verifies that the bubble bar is hidden. */
+    fun verifyBubbleBarIsHidden() {
+        BubbleBar.BUBBLE_BAR_VIEW.assertInvisible(LONG_WAIT)
+    }
+
+    /** Verifies that no bubbles or an expanded bubble stack are visible. */
+    fun verifyNoBubbleIsVisible() {
+        Bubble.BUBBLE_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
+        verifyNoExpandedBubbleStackIsVisible()
+    }
+
+    /** Verifies that expanded bubble stack is not visible. */
+    fun verifyNoExpandedBubbleStackIsVisible() {
+        BUBBLE_EXPANDED_VIEW.assertInvisible(timeout = Bubble.FIND_OBJECT_TIMEOUT)
+    }
+
+    /** Verifies that status bar is hidden by checking StatusBar's clock icon whether it exists. */
+    fun verifyStatusBarIsHidden() {
+        assertThat(
+                uiDevice.wait(
+                    Until.gone(sysuiResSelector(StatusBar.CLOCK_ID)),
+                    SHORT_TIMEOUT.toLong(),
+                )
+            )
+            .isTrue()
+    }
+
+    /** Takes a screenshot and returns the actions panel that appears. */
+    fun screenshot(): ScreenshotActions {
+        val device = uiDevice
+        device.pressKeyCode(KeyEvent.KEYCODE_SYSRQ)
+        check(
+            device.wait(Until.hasObject(GLOBAL_SCREENSHOT_SELECTOR), SCREENSHOT_POST_TIMEOUT_MSEC)
+        ) {
+            "Can't find screenshot image"
+        }
+        return ScreenshotActions()
+    }
+
+    /** Gets the power panel. Fails if there is no power panel visible. */
+    val powerPanel: PowerPanel
+        get() = PowerPanel()
+
+    /**
+     * Goes to Launcher workspace by sending KeyEvent.KEYCODE_HOME. This method is not
+     * representative of real user's actions, but it's more stable than
+     * LauncherInstrumentation.goHome because LauncherInstrumentation.goHome expects all prior
+     * animations to settle before it's used, which is true for Launcher tests that use it, but not
+     * necessarily true for SysUI tests.
+     *
+     * @return the Workspace object.
+     */
+    fun goHomeViaKeycode(): Workspace {
+        uiDevice.pressHome()
+        // getWorkspace will check `expectedRotation` and fail if it doesn't match the one from
+        // the device. However, if the test has an Orientation annotation, the orientation won't
+        // be fixed back until after this is run, possibly failing the test.
+        val instrumentation = LauncherInstrumentation()
+        instrumentation.setExpectedRotation(uiDevice.displayRotation)
+        return instrumentation.getWorkspace()
+    }
+
+    private fun wakeUp() {
+        try {
+            uiDevice.wakeUp()
+        } catch (e: RemoteException) {
+            e.printStackTrace()
+        }
+    }
+
+    /** Returns the volume dialog or fails if it's invisible. */
+    val volumeDialog: VolumeDialog
+        get() = VolumeDialog()
+
+    /** Asserts that the volume dialog is not visible. */
+    fun assertVolumeDialogNotVisible() {
+        VolumeDialog.PAGE_TITLE_SELECTOR.assertInvisible()
+    }
+
+    /** Asserts that lock screen is invisible. */
+    fun assertLockScreenNotVisible() {
+        LockScreen.LOCKSCREEN_SELECTOR.assertInvisible()
+    }
+
+    // TODO (b/277105514): Determine whether this is an idiomatic method of determing visibility.
+    /** Asserts that launcher is visible. */
+    fun assertLauncherVisible() {
+        By.pkg("com.google.android.apps.nexuslauncher").assertVisible()
+    }
+
+    val keyboardBacklightIndicatorDialog: KeyboardBacklightIndicatorDialog
+        get() = KeyboardBacklightIndicatorDialog()
+
+    fun assertKeyboardBacklightIndicatorDialogNotVisible() {
+        KeyboardBacklightIndicatorDialog.CONTAINER_SELECTOR.assertInvisible()
+    }
+
+    private fun injectEventSync(event: InputEvent): Boolean {
+        return InstrumentationRegistry.getInstrumentation()
+            .uiAutomation
+            .injectInputEvent(event, true)
+    }
+
+    private fun sendKey(keyCode: Int, metaState: Int, eventTime: Long): Boolean {
+        val downEvent =
+            KeyEvent(
+                eventTime,
+                eventTime,
+                KeyEvent.ACTION_DOWN,
+                keyCode,
+                0,
+                metaState,
+                KeyCharacterMap.VIRTUAL_KEYBOARD,
+                0,
+                0,
+                InputDevice.SOURCE_KEYBOARD,
+            )
+        if (injectEventSync(downEvent)) {
+            val upEvent =
+                KeyEvent(
+                    eventTime,
+                    eventTime,
+                    KeyEvent.ACTION_UP,
+                    keyCode,
+                    0,
+                    metaState,
+                    KeyCharacterMap.VIRTUAL_KEYBOARD,
+                    0,
+                    0,
+                    InputDevice.SOURCE_KEYBOARD,
+                )
+            if (injectEventSync(upEvent)) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun pressKeyCode(keyCode: Int, eventTime: Long) {
+        sendKey(keyCode, /* metaState= */ 0, eventTime)
+    }
+
+    /** Double-taps the power button. Can be used to bring up the camera app. */
+    fun doubleTapPowerButton() {
+        val eventTime = SystemClock.uptimeMillis()
+        pressKeyCode(KeyEvent.KEYCODE_POWER, eventTime)
+        pressKeyCode(KeyEvent.KEYCODE_POWER, eventTime + 1)
+    }
+
+    /** Opens the tutorial by swiping. */
+    fun openTutorialViaSwipe(): OneHandModeTutorial {
+        NotificationShade.waitForShadeToClose()
+        val windowMetrics: WindowMetrics =
+            DeviceHelpers.context
+                .getSystemService(WindowManager::class.java)!!
+                .getCurrentWindowMetrics()
+        val insets: WindowInsets = windowMetrics.getWindowInsets()
+        val displayBounds: Rect = windowMetrics.getBounds()
+        val bottomMandatoryGestureHeight: Int =
+            insets
+                .getInsetsIgnoringVisibility(
+                    WindowInsets.Type.navigationBars() or WindowInsets.Type.displayCutout()
+                )
+                .bottom
+        NotificationShade.waitForShadeToClose()
+        uiDevice.betterSwipe(
+            displayBounds.width() / 2,
+            displayBounds.height() - Math.round(bottomMandatoryGestureHeight * 2.5f),
+            displayBounds.width() / 2,
+            displayBounds.height(),
+        )
+        NotificationShade.waitForShadeToClose()
+        return OneHandModeTutorial()
+    }
+
+    /**
+     * Turn the device off and on, and check for the lockScreen. This should be used instead of
+     * LockscreenUtils.goToLockScreen() because LockscreenController validates that the screen is
+     * off or on, rather than just sleeping and waking up the device. "return lockScreen" calls the
+     * LockScreen constructor, which ensures that the lockscreen clock is visible
+     *
+     * TODO: replace LockscreenUtils.goToLockscreen() with this once it's submitted: b/322870306
+     */
+    fun goToLockscreen(): LockScreen {
+        LockscreenController.get().turnScreenOff()
+        LockscreenController.get().turnScreenOn()
+        return lockScreen
+    }
+
+    companion object {
+        private val QS_HEADER_SELECTOR =
+            if (com.android.systemui.Flags.sceneContainer()) {
+                sysuiResSelector("shade_header_root")
+            } else {
+                sysuiResSelector("split_shade_status_bar")
+            }
+        private val NOTIFICATION_SHADE_OPEN_TIMEOUT = Duration.ofSeconds(20)
+        private const val LONG_TIMEOUT = 2000
+        private const val SHORT_TIMEOUT = 500
+        private val FOOTER_SELECTOR = sysuiResSelector("qs_footer_actions")
+        private const val SCREENSHOT_POST_TIMEOUT_MSEC: Long = 20000
+        private val GLOBAL_SCREENSHOT_SELECTOR = sysuiResSelector("screenshot_actions")
+
+        /** Returns an instance of Root. */
+        @JvmStatic
+        fun get(): Root {
+            return Root()
+        }
+
+        private fun waitForShadeToOpen() {
+            // Note that this duplicates the tracing done by assertVisible, but with a better name.
+            trace("waitForShadeToOpen") {
+                QS_HEADER_SELECTOR.assertVisible(
+                    timeout = NOTIFICATION_SHADE_OPEN_TIMEOUT,
+                    errorProvider = { "Notification shade didn't open" },
+                )
+            }
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ScreenshotActions.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ScreenshotActions.java
new file mode 100644
index 000000000..48d4fc5f8
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ScreenshotActions.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui;
+
+import static android.platform.systemui_tapl.utils.DeviceUtils.sysuiDescSelector;
+
+import android.platform.test.scenario.tapl_common.TaplUiDevice;
+
+import androidx.annotation.NonNull;
+import androidx.test.uiautomator.BySelector;
+
+/**
+ * System UI test automation object representing actions panel that appears after taking a
+ * screenshot.
+ */
+public class ScreenshotActions {
+    private static final BySelector SHARE_BUTTON = sysuiDescSelector("Share screenshot");
+
+    ScreenshotActions() {}
+
+    /** Opens the share sheet by clicking the "Share" button. */
+    @NonNull
+    public ShareSheet openSharesheet() {
+        TaplUiDevice.waitForObject(SHARE_BUTTON, "Share button").click();
+
+        return new ShareSheet();
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ShareSheet.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ShareSheet.kt
new file mode 100644
index 000000000..824987f6a
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/ShareSheet.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Until
+import com.google.common.truth.Truth.assertThat
+
+/** System UI test automation object representing the share sheet. */
+class ShareSheet internal constructor() {
+    init {
+        TaplUiDevice.waitForObject(
+            androidResSelector(RESOLVER_LIST_ID),
+            objectName = "share sheet page",
+        )
+    }
+
+    private fun hasObjectWithWait(selector: BySelector): Boolean {
+        return uiDevice.wait(Until.hasObject(selector), UI_RESPONSE_TIMEOUT_MSECS.toLong())
+    }
+
+    /** Pull the share sheet page to top of the screen. */
+    fun pullUp() {
+        val device = uiDevice
+        assertThat(hasObjectWithWait(HEADER_SELECTOR)).isTrue()
+        val header = uiDevice.waitForObj(HEADER_SELECTOR)
+        header.drag(Point(device.displayWidth / 2, 0), device.displayHeight / 5)
+        device.waitForIdle(UI_RESPONSE_TIMEOUT_MSECS.toLong())
+    }
+
+    private companion object {
+        const val RESOLVER_LIST_ID = "resolver_list"
+        const val HEADER_ID = "chooser_header"
+        val HEADER_SELECTOR = androidResSelector(HEADER_ID)
+        const val UI_RESPONSE_TIMEOUT_MSECS = 3000
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Sized.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Sized.kt
new file mode 100644
index 000000000..3a9ff34cd
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/Sized.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Rect
+
+/**
+ * Represents dimensions and position of a visible view on the screen.
+ *
+ * Allows to compare it with other [sized] objects **without** disclosing the real position.
+ */
+abstract class Sized internal constructor(private val rect: Rect) {
+    /** Returns whether this class intersects with [other]. */
+    infix fun intersect(other: Sized): Boolean = rect.intersect(other.rect)
+
+    override fun equals(other: Any?): Boolean =
+        if (other is Sized) {
+            rect == other.rect
+        } else {
+            super.equals(other)
+        }
+
+    override fun hashCode(): Int = rect.hashCode()
+
+    override fun toString(): String = "${this::class.simpleName}(bounds=$rect)"
+}
+
+/**
+ * System UI test automation object representing the notification shelf.
+ *
+ * This is visible at the end of the [NotificationStack] only when there are notification that don't
+ * fit in the available space.
+ */
+class NotificationShelf internal constructor(rect: Rect) : Sized(rect)
+
+/** System UI test automation object representing the lock icon visible on lockscreen. */
+class LockscreenLockIcon internal constructor(rect: Rect) : Sized(rect)
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java
new file mode 100644
index 000000000..c2e888d71
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/StatusBar.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui;
+
+import static android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT;
+import static android.platform.systemui_tapl.utils.DeviceUtils.SHORT_WAIT;
+import static android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector;
+import static android.platform.test.util.HealthTestingUtils.waitForValueCatchingStaleObjectExceptions;
+import static android.platform.uiautomatorhelpers.DeviceHelpers.getUiDevice;
+import static android.platform.uiautomatorhelpers.WaitUtils.ensureThat;
+
+import static androidx.test.uiautomator.Until.findObject;
+
+import static com.android.settingslib.flags.Flags.newStatusBarIcons;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assume.assumeFalse;
+
+import android.app.Flags;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.platform.helpers.foldable.UnfoldAnimationTestingUtils;
+import android.platform.uiautomatorhelpers.DeviceHelpers;
+
+import androidx.test.uiautomator.By;
+import androidx.test.uiautomator.BySelector;
+import androidx.test.uiautomator.SearchCondition;
+import androidx.test.uiautomator.UiObject2;
+import androidx.test.uiautomator.Until;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+/** System UI test automation object representing status bar. */
+public class StatusBar {
+
+    private static final BySelector PERCENTAGE_SELECTOR = By.text(Pattern.compile("\\d+%"));
+    private static final String BATTERY_ID = "battery";
+    static final String BATTERY_LEVEL_TEXT_ID = "battery_percentage_view";
+    static final String CLOCK_ID = "clock";
+    private static final String NOTIFICATION_ICON_CONTAINER_ID = "notificationIcons";
+    private static final BySelector NOTIFICATION_LIGHTS_OUT_DOT_SELECTOR =
+            sysuiResSelector("notification_lights_out");
+    private static final String UI_SYSTEM_ICONS_ID = "system_icons";
+    private static final String DATE_ID = "date";
+    static final String STATUS_ICON_CONTAINER_ID = "statusIcons";
+    private static final String ALARM_ICON_DESC_PREFIX_STRING = "Alarm";
+    private static final String AIRPLANE_MODE_ICON_DESC = "Airplane mode.";
+    private static final String DATA_SAVER_ICON_DESC = "Data Saver is on";
+    // https://hsv.googleplex.com/6227911158792192?node=18
+    static final String DOCK_DEFEND_ICON_SUFFIX_STRING = "charging paused for battery protection";
+    static final String DND_ICON_DESC = Flags.modesUi() ? "Do Not Disturb is on" : "Do Not Disturb";
+    private static final String WIFI_ICON_ID = "wifi_combo";
+    private static final String ONGOING_ACTIVITY_CHIP_ICON_ID = "ongoing_activity_chip_primary";
+    static final String SCREEN_RECORD_DESC_STRING = "Recording screen";
+    static final String SILENT_ICON_DESC_PREFIX_STRING = "Ringer silent";
+    static final String VIBRATE_ICON_DESC_PREFIX_STRING = "Ringer vibrate";
+    private final List<String> mStatusBarViewIds =
+            List.of(DATE_ID, CLOCK_ID, WIFI_ICON_ID, BATTERY_ID, BATTERY_LEVEL_TEXT_ID);
+
+    StatusBar() {
+        verifyClockIsVisible();
+    }
+
+    private static List<UiObject2> getNotificationIconsObjects() {
+        // As the container for notifications can change between the moment we get it and we get its
+        // children, we retry several times in case of failure. This aims at reducing flakiness.
+        return waitForValueCatchingStaleObjectExceptions(
+                () -> "Failed to get status bar icons.",
+                () -> {
+                    UiObject2 container =
+                            getUiDevice()
+                                    .wait(
+                                            Until.findObject(
+                                                    sysuiResSelector(
+                                                            NOTIFICATION_ICON_CONTAINER_ID)),
+                                            10000);
+                    return container != null ? container.getChildren() : Collections.emptyList();
+                });
+    }
+
+    /** Returns the number of notification icons visible on the status bar. */
+    public int getNotificationIconCount() {
+        List<UiObject2> icons = getNotificationIconsObjects();
+
+        // 2 icons are never ellipsized, let's return them.
+        if (icons.size() <= 2) {
+            return icons.size();
+        }
+
+        // Notification icons don't change visibility when collapsed.
+        // The same icon can represent either the notification and the ellipsis.
+        //
+        // For this reason, UiAutomator thinks the icons are always visible, when we're
+        // actually stacking them up on top of each other and drawing transparent.
+        //
+        // Let's check for overlap instead of view visibility.
+        int iconPadding =
+                icons.get(1).getVisibleBounds().left - icons.get(0).getVisibleBounds().left;
+        int lastIcon = icons.size() - 1;
+        for (int i = 1; i < icons.size(); i++) {
+            lastIcon = i;
+            int padding =
+                    icons.get(i).getVisibleBounds().left - icons.get(i - 1).getVisibleBounds().left;
+            if (padding != iconPadding) {
+                break;
+            }
+        }
+        return lastIcon;
+    }
+
+    /** Verifies visibility of the battery percentage indicator. */
+    public void verifyBatteryPercentageVisibility(boolean expectedVisible) {
+        assumeFalse(newStatusBarIcons());
+        UiObject2 batteryIndication = getBatteryIndication();
+        assertThat(batteryIndication).isNotNull();
+
+        if (expectedVisible) {
+            assertThat(batteryIndication.wait(Until.hasObject(PERCENTAGE_SELECTOR), 10000))
+                    .isTrue();
+        } else {
+            assertThat(batteryIndication.wait(Until.gone(PERCENTAGE_SELECTOR), 10000)).isTrue();
+        }
+    }
+
+    private static UiObject2 getBatteryIndication() {
+        return getUiDevice().wait(findObject(sysuiResSelector(BATTERY_ID)), 1000);
+    }
+
+    /** Assert that clock indicator is visible. */
+    private void verifyClockIsVisible() {
+        // Matches 12h or 24h time format
+        Pattern timePattern = Pattern.compile("^(?:[01]?\\d|2[0-3]):[0-5]\\d");
+        DeviceHelpers.waitForObj(
+                By.pkg("com.android.systemui").text(timePattern),
+                SHORT_WAIT,
+                () -> "Clock should be visible.");
+    }
+
+    /** Assert that clock indicator is NOT visible. */
+    public void verifyClockIsNotVisible() {
+        assertWithMessage("StatusBar clock is visible")
+                .that(
+                        getUiDevice()
+                                .wait(Until.gone(sysuiResSelector(CLOCK_ID)), LONG_WAIT.toMillis()))
+                .isTrue();
+    }
+
+    /** Assert that the lights out notification dot is visible. */
+    public void verifyLightsOutDotIsVisible() {
+        SearchCondition<Boolean> searchCondition =
+                Until.hasObject(NOTIFICATION_LIGHTS_OUT_DOT_SELECTOR);
+        assertThat(getUiDevice().wait(searchCondition, LONG_WAIT.toMillis())).isTrue();
+    }
+
+    /** Assert that the lights out notification dot is NOT visible. */
+    public void verifyLightsOutDotIsNotVisible() {
+        SearchCondition<Boolean> searchCondition = Until.gone(NOTIFICATION_LIGHTS_OUT_DOT_SELECTOR);
+        assertThat(getUiDevice().wait(searchCondition, LONG_WAIT.toMillis())).isTrue();
+    }
+
+    /** Returns the visible user switcher chip, or fails if it's not visible. */
+    public UserSwitcherChip getUserSwitcherChip() {
+        return new UserSwitcherChip();
+    }
+
+    /** Gets the icons object on the right hand side StatusBar. This is for screenshot test. */
+    public Rect getBoundsOfRightHandSideStatusBarIconsForScreenshot() {
+        return DeviceHelpers.INSTANCE
+                .waitForObj(
+                        /* UiDevice= */ getUiDevice(),
+                        /* selector= */ sysuiResSelector(STATUS_ICON_CONTAINER_ID),
+                        /* timeout= */ SHORT_WAIT,
+                        /* errorProvider= */ () ->
+                                "StatusBar icons are not found on the right hand side.")
+                .getVisibleBounds();
+    }
+
+    /** Assert that alarm icon is visible. */
+    public void verifyAlarmIconIsVisible() {
+        DeviceHelpers.waitForObj(
+                By.pkg("com.android.systemui")
+                        .clazz("android.widget.ImageView")
+                        .descContains(ALARM_ICON_DESC_PREFIX_STRING),
+                SHORT_WAIT,
+                () -> "Alarm icon should be visible.");
+    }
+
+    /** Assert that airplane mode icon is visible. */
+    public void verifyAirplaneModeIconIsVisible() {
+        assertThat(
+                        getUiDevice()
+                                .wait(
+                                        Until.hasObject(
+                                                sysuiResSelector(STATUS_ICON_CONTAINER_ID)
+                                                        .hasChild(
+                                                                By.desc(AIRPLANE_MODE_ICON_DESC))),
+                                        SHORT_WAIT.toMillis()))
+                .isTrue();
+    }
+
+    /** Assert that data saver icon is visible. */
+    public void verifyDataSaverIconIsVisible() {
+        assertThat(
+                        getUiDevice()
+                                .wait(
+                                        Until.hasObject(
+                                                sysuiResSelector(STATUS_ICON_CONTAINER_ID)
+                                                        .hasChild(By.desc(DATA_SAVER_ICON_DESC))),
+                                        SHORT_WAIT.toMillis()))
+                .isTrue();
+    }
+
+    /** Assert that dock defend icon is visible. */
+    public void verifyDockDefendIconIsVisible() {
+        assertWithMessage("Dock Defend icon should be visible in status bar.")
+                .that(
+                        getUiDevice()
+                                .wait(
+                                        Until.hasObject(
+                                                sysuiResSelector(UI_SYSTEM_ICONS_ID)
+                                                        .hasChild(
+                                                                By.descContains(
+                                                                        DOCK_DEFEND_ICON_SUFFIX_STRING))),
+                                        SHORT_WAIT.toMillis()))
+                .isTrue();
+    }
+
+    /** Asserts that user switcher chip is invisible. */
+    public void assertUserSwitcherChipIsInvisible() {
+        DeviceHelpers.INSTANCE.assertInvisible(
+                sysuiResSelector(UserSwitcherChip.USER_SWITCHER_CONTAINER_ID),
+                SHORT_WAIT,
+                () -> "User switcher chip should be invisible in status bar.");
+    }
+
+    /** Returns the clock time value on StatusBar. Experimental. */
+    public String getClockTime() {
+        UiObject2 clockTime =
+                DeviceHelpers.INSTANCE.waitForObj(
+                        /* UiDevice= */ getUiDevice(),
+                        /* selector= */ sysuiResSelector(CLOCK_ID),
+                        /* timeout= */ SHORT_WAIT,
+                        /* errorProvider= */ () -> "Clock not found.");
+        return clockTime.getText();
+    }
+
+    /** Returns the position of views in StatusBar. */
+    public Set<UnfoldAnimationTestingUtils.Icon> getStatusBarViewPositions() {
+        Set<UnfoldAnimationTestingUtils.Icon> statusBarViewPositions = new HashSet<>();
+        mStatusBarViewIds.forEach(
+                viewId -> {
+                    UiObject2 viewUiObject =
+                            DeviceHelpers.INSTANCE.waitForNullableObj(
+                                    sysuiResSelector(viewId), SHORT_WAIT);
+                    if (viewUiObject != null) {
+                        Rect iconPosition = viewUiObject.getVisibleBounds();
+                        statusBarViewPositions.add(
+                                new UnfoldAnimationTestingUtils.Icon(
+                                        viewId,
+                                        new Point(iconPosition.centerX(), iconPosition.centerY())));
+                    }
+                });
+        return statusBarViewPositions;
+    }
+
+    /** Assert that DND icon is visible. */
+    public void verifyDndIconIsVisible() {
+        assertWithMessage("DND icon should be visible in status bar.")
+                .that(
+                        getUiDevice()
+                                .wait(
+                                        Until.hasObject(
+                                                sysuiResSelector(STATUS_ICON_CONTAINER_ID)
+                                                        .hasChild(By.descContains(DND_ICON_DESC))),
+                                        SHORT_WAIT.toMillis()))
+                .isTrue();
+    }
+
+    /** Returns the value of the battery level on StatusBar. Experimental. */
+    public String getBatteryLevel() {
+        UiObject2 batteryPercentage =
+                DeviceHelpers.INSTANCE.waitForObj(
+                        /* UiDevice= */ getUiDevice(),
+                        /* selector= */ sysuiResSelector(BATTERY_LEVEL_TEXT_ID),
+                        /* timeout= */ LONG_WAIT,
+                        /* errorProvider= */ () -> "Battery percentage not found.");
+        return batteryPercentage.getText();
+    }
+
+    /** Assert that WiFi icon is visible. Experimental. */
+    public void verifyWifiIconIsVisible() {
+        DeviceHelpers.INSTANCE.assertVisible(
+                sysuiResSelector(UI_SYSTEM_ICONS_ID).hasDescendant(sysuiResSelector(WIFI_ICON_ID)),
+                LONG_WAIT,
+                () -> "WiFi icon should be visible in status bar.");
+    }
+
+    /** Assert that silent icon is visible. */
+    public void verifySilentIconIsVisible() {
+        DeviceHelpers.INSTANCE.assertVisible(
+                sysuiResSelector(STATUS_ICON_CONTAINER_ID)
+                        .hasChild(By.descContains(SILENT_ICON_DESC_PREFIX_STRING)),
+                LONG_WAIT,
+                () -> "Silent icon should be visible in status bar.");
+    }
+
+    /** Assert that the screen record chip is visible. */
+    public void verifyScreenRecordChipIsVisible() {
+        DeviceHelpers.INSTANCE.assertVisible(
+                sysuiResSelector(ONGOING_ACTIVITY_CHIP_ICON_ID)
+                        .hasDescendant(By.descContains(SCREEN_RECORD_DESC_STRING)),
+                LONG_WAIT,
+                () -> "Recording chip should be visible in status bar.");
+    }
+
+    /** Assert there is at least one status icon visible. */
+    public void verifyAtLeastOneStatusIconIsVisible() {
+        UiObject2 statusBar = DeviceHelpers.waitForObj(sysuiResSelector(STATUS_ICON_CONTAINER_ID));
+        assertWithMessage("Status bar should have at least one icon visible")
+                .that(statusBar.getChildCount())
+                .isGreaterThan(0);
+    }
+
+    /** Verifies visibility of the vibrate icon. */
+    public void assertVibrateIconVisibility(boolean visible) {
+        DeviceHelpers.INSTANCE.assertVisibility(
+                /* UiDevice= */ getUiDevice(),
+                /* selector= */ sysuiResSelector(STATUS_ICON_CONTAINER_ID)
+                        .hasChild(By.descContains(VIBRATE_ICON_DESC_PREFIX_STRING)),
+                /* visible= */ visible,
+                /* timeout= */ LONG_WAIT);
+    }
+
+    /**
+     * Fails when {@link #getNotificationIconCount()} doesn't become the expected value within a
+     * timeout.
+     */
+    public void assertNotificationIconCount(int expected) {
+        ensureThat(
+                "Visible StatusBar icon count should be " + expected,
+                () -> getNotificationIconCount() == expected);
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UniversalMediaObject.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UniversalMediaObject.kt
new file mode 100644
index 000000000..a322ffcc7
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UniversalMediaObject.kt
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.ui.NotificationShadeType.NORMAL
+import android.platform.systemui_tapl.ui.NotificationShadeType.SPLIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiObject2
+import com.google.common.collect.Range
+import com.google.common.truth.Truth.assertWithMessage
+
+/**
+ * Represents the universal media object(UMO) displayed in the [NotificationShade]. UMO is not the
+ * same as a media player. It contains a scrollable view called the Carousel, which can contain
+ * multiple media players and recent media cards.
+ */
+class UniversalMediaObject internal constructor() {
+
+    init {
+        MEDIA_CAROUSEL_SCROLLER.assertVisible { "Media carousel not visible" }
+    }
+
+    /** Verifies that the media player is covering the entire space. */
+    fun assertCoversEntireSpace() {
+        val mediaPlayerWidth = mediaCarouselUiObject.visibleBounds.width()
+        val deviceWidth = uiDevice.displayWidth
+
+        when (NotificationShade().type!!) {
+            NORMAL ->
+                assertWithMessage("Media player in normal shade is not covering the entire space")
+                    .that(mediaPlayerWidth)
+                    .isGreaterThan(deviceWidth / 2)
+            SPLIT ->
+                // should fit slightly less than half of the screen (due to margins)
+                assertWithMessage("Media player in split shade is not covering enough space")
+                    .that(mediaPlayerWidth)
+                    .isIn(Range.open(deviceWidth / 4 + 1, deviceWidth / 2))
+        }
+    }
+
+    private val mediaCarouselUiObject: UiObject2
+        get() = uiDevice.waitForObj(MEDIA_CAROUSEL_SCROLLER)
+
+    companion object {
+        val MEDIA_CAROUSEL_SCROLLER: BySelector = sysuiResSelector("media_carousel_scroller")
+    }
+
+    /** Get the recommend media card on the UMO, or fail if it's not visible */
+    val recentMediaCard: RecentMediaCard
+        get() = RecentMediaCard()
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionExpandedList.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionExpandedList.kt
new file mode 100644
index 000000000..def0298f3
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionExpandedList.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
+import android.platform.systemui_tapl.utils.UserUtils.runThenWaitUntilSwitchCompleted
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Until
+
+/**
+ * List that shows up from the bouncer user switcher.
+ *
+ * https://hsv.googleplex.com/6537215275433984?node=3
+ */
+class UserSelectionExpandedList internal constructor() {
+
+    init {
+        USERS_LIST_SELECTOR.assertVisible { "User selection list didn't appear" }
+    }
+
+    /** Opens add user prompt. */
+    fun openAddUserPrompt(): AddUserPrompt {
+        TaplUiDevice.waitForObject(ADD_USER_SELECTOR, "Add user menu item").click()
+        return AddUserPrompt()
+    }
+
+    /** Selects switching to an existing user or a new guest user. */
+    fun switchToUser(userName: String) {
+        runThenWaitUntilSwitchCompleted {
+            // (b/265080418): The clickable attribute of these items are always false.
+            uiDevice.waitForObj(By.pkg(SYSUI_PACKAGE).text(userName)).click()
+        }
+    }
+
+    /**
+     * The number of options on the user selector list.
+     * https://hsv.googleplex.com/6542084124180480?node=3
+     */
+    val numberOfUsers: Int
+        get() {
+            return uiDevice
+                .wait(
+                    Until.findObjects(sysuiResSelector(USER_SWITCHER_ITEM_ID)),
+                    DeviceUtils.SHORT_WAIT.toMillis(),
+                )
+                ?.size ?: error("Can't find any user option.")
+        }
+
+    /** Asserts that user name exists on the expanded list. */
+    fun assertUserNameInExpandedList(userName: String) {
+        waitForObj(sysuiResSelector(USER_SWITCHER_ITEM_ID).hasDescendant(By.text(userName)))
+    }
+
+    private companion object {
+        val IS_COMPOSE_BOUNCER_ENABLED =
+            com.android.systemui.Flags.composeBouncer() ||
+                com.android.systemui.Flags.sceneContainer()
+        const val USER_SWITCHER_ITEM_ID = "user_switcher_item"
+
+        // https://hsv.googleplex.com/6213668812357632?node=8
+        val ADD_USER_SELECTOR: BySelector =
+            sysuiResSelector(USER_SWITCHER_ITEM_ID).hasDescendant(By.text("Add user"))
+
+        // https://hsv.googleplex.com/6542084124180480?node=6
+        val OWNER_SELECTOR: BySelector =
+            sysuiResSelector(USER_SWITCHER_ITEM_ID).hasDescendant(By.text("Owner"))
+
+        // https://hsv.googleplex.com/6542084124180480?node=3
+        val USERS_LIST_SELECTOR: BySelector =
+            if (IS_COMPOSE_BOUNCER_ENABLED) sysuiResSelector("user_list_dropdown")
+            else
+                By.clazz("android.widget.ListView").pkg(SYSUI_PACKAGE).hasDescendant(OWNER_SELECTOR)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionPanel.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionPanel.kt
new file mode 100644
index 000000000..52d4d0481
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSelectionPanel.kt
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Rect
+import android.platform.systemui_tapl.controller.SysUiFlagController
+import android.platform.systemui_tapl.controller.SysUiFlagController.SystemUIFlag
+import android.platform.systemui_tapl.utils.DeviceUtils.SHORT_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.UserUtils.runThenWaitUntilSwitchCompleted
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Until
+import java.util.regex.Pattern.compile
+
+/**
+ * Panel that shows up from the QS multiuser button or user switcher chip.
+ *
+ * Based on the [FULL_SCREEN_USER_SWITCHER] flag, this can be either:
+ * - full screen: http://go/hsv/5243841595572224
+ * - dialog: http://go/hsv/5008296081620992
+ */
+class UserSelectionPanel internal constructor() {
+
+    private val fullscreen: Boolean = SystemUIFlag.FULL_SCREEN_USER_SWITCHER.isEnabled
+
+    init {
+        userSwitcherSelector().assertVisible { "UserSelectionPanel didn't appear" }
+    }
+
+    /** The number of active users on the current panel. Experimental. */
+    val usersCount: Int
+        get() {
+            return uiDevice.wait(Until.findObjects(userSelector()), SHORT_WAIT.toMillis()).size
+        }
+
+    /**
+     * The visible bound of the user container. It's mainly for screenshot testing. Experimental.
+     */
+    val userContainerRect: Rect?
+        get() {
+            if (fullscreen) {
+                return uiDevice
+                    .waitForObj(sysuiResSelector(FULLSCREEN_USER_CONTAINER_ID))
+                    .waitForObj(sysuiResSelector("flow"))
+                    .visibleBounds
+            }
+            throw NotImplementedError("userContainerRect isn't supported on the current device.")
+        }
+
+    /** Closes user selection. */
+    fun close() {
+        TaplUiDevice.waitForObject(closeSelector(), "Close button").click()
+    }
+
+    /** Opens user settings by clicking the User Settings button. */
+    fun openUserSettings(): MultipleUsersSettings {
+        if (fullscreen) {
+            clickButtonFromAddMenu(MANAGE_USERS_BUTTON_LABEL)
+        } else {
+            // http://go/hsv/5905004487507968?node=28
+            val userSettingsButton = androidResSelector("button3").text("Manage users")
+            TaplUiDevice.waitForObject(userSettingsButton, "User settings button").click()
+        }
+        return MultipleUsersSettings()
+    }
+
+    /**
+     * Unless guest user is initialized in some other way, on every UserSelection type we have
+     * creating always means selecting guest user.
+     */
+    fun createAndSwitchToGuestUser() {
+        runThenWaitUntilSwitchCompleted {
+            if (fullscreen) {
+                clickButtonFromAddMenu(ADD_GUEST_BUTTON_LABEL)
+            } else {
+                selectUser(GUEST_NAME)
+            }
+        }
+    }
+
+    /** Opens add user prompt. */
+    fun openAddUserPrompt(): AddUserPrompt {
+        if (fullscreen) {
+            clickButtonFromAddMenu(ADD_USER_BUTTON_LABEL)
+        } else {
+            selectUser(ADD_USER_BUTTON_LABEL)
+        }
+        return AddUserPrompt()
+    }
+
+    /** Selects switching back to an already added guest user. */
+    fun switchBackToGuest(): WelcomeBackGuestDialog {
+        runThenWaitUntilSwitchCompleted { selectUser(GUEST_NAME) }
+        return WelcomeBackGuestDialog()
+    }
+
+    /** Selects switching to an existing user or a new guest user. */
+    fun switchToUser(userName: String) {
+        runThenWaitUntilSwitchCompleted { selectUser(userName) }
+    }
+
+    /**
+     * Selects an entry from the "Add" menu, available only in fullscreen.
+     *
+     * https://hsv.googleplex.com/5243841595572224?node=10
+     */
+    private fun clickButtonFromAddMenu(label: String) {
+        fun clickButtonWithText(label: String) {
+            // TODO(b/260815442): The clickable attribute of these items in the menu list is false.
+            waitForObj(By.text(label)).click()
+        }
+        clickButtonWithText("Add")
+        clickButtonWithText(label)
+    }
+
+    /** Selects the user with [userName]. */
+    private fun selectUser(userName: String) {
+        val userItemSelector: BySelector =
+            if (fullscreen) By.clazz("android.view.ViewGroup") else sysuiResSelector("user_item")
+
+        waitForObj(userItemSelector.hasDescendant(userSelector().text(userName))).click()
+    }
+
+    /** Selects exiting the guest user. */
+    fun exitGuest(): ExitGuestPrompt {
+        selectUser(EXIT_GUEST_ITEM)
+        return ExitGuestPrompt()
+    }
+
+    private fun userSwitcherSelector(): BySelector =
+        if (fullscreen) {
+            sysuiResSelector("user_switcher_root")
+        } else {
+            androidResSelector("alertTitle").text("Select user")
+        }
+
+    private fun closeSelector(): BySelector =
+        if (fullscreen) {
+            // http://go/hsv/5243841595572224?node=9
+            sysuiResSelector(FULLSCREEN_CANCEL_ID)
+        } else {
+            // http://go/hsv/5905004487507968?node=29
+            androidResSelector("button1").text(compile("Close|Done"))
+        }
+
+    // http://go/hsv/5008296081620992?node=10#
+    private fun userSelector(): BySelector =
+        sysuiResSelector(if (fullscreen) "user_switcher_text" else "user_name")
+
+    companion object {
+        private const val GUEST_NAME = "Guest"
+        private const val MANAGE_USERS_BUTTON_LABEL = "Manage users"
+        private const val ADD_GUEST_BUTTON_LABEL = "Add guest"
+        private const val ADD_USER_BUTTON_LABEL = "Add user"
+        private const val FULLSCREEN_CANCEL_ID = "cancel"
+        private const val EXIT_GUEST_ITEM = "Exit guest"
+        private const val FULLSCREEN_USER_CONTAINER_ID = "user_switcher_grid_container"
+    }
+
+    private val SystemUIFlag.isEnabled: Boolean
+        get() = SysUiFlagController.get().isEnabled(this)
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSwitcherChip.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSwitcherChip.kt
new file mode 100644
index 000000000..3368eab17
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/UserSwitcherChip.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.test.scenario.tapl_common.TaplUiDevice
+import android.platform.uiautomatorhelpers.WaitUtils.waitForValueToSettle
+
+/**
+ * A container on the status bar that can launch user selection panel.
+ *
+ * https://hsv.googleplex.com/5504620500615168?node=13
+ */
+class UserSwitcherChip internal constructor() {
+
+    private val container =
+        TaplUiDevice.waitForObject(
+            sysuiResSelector(USER_SWITCHER_CONTAINER_ID),
+            "User switcher chip",
+        )
+
+    /** Gets the current user name. */
+    val username: String
+        get() =
+            container.waitForChildObject("current_user_name", "Current user's name").uiObject.text
+
+    /** Opens the user selection panel by clicking user switcher chip. */
+    fun clickToOpenUserSelector(): UserSelectionPanel {
+        container.click()
+        return UserSelectionPanel().also {
+            waitForValueToSettle("User switch activity transition doesn't finish as expected.") {
+                it.userContainerRect
+            }
+        }
+    }
+
+    companion object {
+        const val USER_SWITCHER_CONTAINER_ID = "user_switcher_container"
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeDialog.kt
new file mode 100644
index 000000000..580fb82d1
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeDialog.kt
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.graphics.Point
+import android.graphics.PointF
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.volume.panel.ui.VolumePanel
+import android.platform.uiautomatorhelpers.BetterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.click
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import com.google.common.truth.Truth
+
+/** System UI test automation object representing the dialog for adjusting the device volume. */
+class VolumeDialog internal constructor() {
+    init {
+        assertVolumeDialogVisible()
+    }
+
+    /**
+     * Changes the volume by dragging the volume slider.
+     *
+     * Note: Volume value cannot be more than 25 and less than 0.
+     *
+     * @param volume new volume value
+     */
+    fun setVolumeByDragging(volume: Int) {
+        assertVolumeDialogVisible()
+        dragAndChangeVolume(volume)
+        assertVolumeDialogVisible()
+    }
+
+    /** Open the ringer drawer by clicking the ringer mode icon on the volume dialog. */
+    fun openRingerDrawer(): VolumeRingerDrawer {
+        val ringerIconSel = sysuiResSelector("volume_new_ringer_active_icon_container")
+        waitForObj(ringerIconSel).click()
+        return VolumeRingerDrawer()
+    }
+
+    /** Open the volume setting panel by clicking the setting icon on the volume dialog. */
+    @Deprecated(
+        "This new volume panel is rolled out. Use openNewVolumePanel instead",
+        replaceWith = ReplaceWith("openNewVolumePanel"),
+    )
+    fun openVolumePanel(): VolumePanelDialog {
+        sysuiResSelector("settings").click()
+        return VolumePanelDialog()
+    }
+
+    /** Open the volume setting panel by clicking the setting icon on the volume dialog. */
+    fun openNewVolumePanel(): VolumePanel {
+        waitForObj(sysuiResSelector("settings")).click()
+        return VolumePanel()
+    }
+
+    /**
+     * Click the live caption button on the volume dialog.
+     *
+     * https://hsv.googleplex.com/4767031439130624
+     *
+     * @return this
+     */
+    fun toggleLiveCaptions(): VolumeDialog {
+        waitForObj(sysuiResSelector("odi_captions_icon")).click()
+        return this
+    }
+
+    companion object {
+        private val SLIDER = sysuiResSelector("volume_row_slider")
+        val PAGE_TITLE_SELECTOR = sysuiResSelector("volume_dialog")
+        private const val MAX_VOLUME = 26
+        private const val MIN_VOLUME = -1
+
+        /**
+         * Method used for dragging and changing the volume. Note: Volume value cannot be more than
+         * 25 and less than 0.
+         *
+         * @param volume value for volume to changed
+         */
+        private fun dragAndChangeVolume(volume: Int) {
+            val coordinates = getDragCoordinates(volume)
+            assertVolumeDialogVisible()
+            BetterSwipe.from(waitForObj(SLIDER).visibleCenter)
+                .to(PointF(coordinates), interpolator = PRECISE_GESTURE_INTERPOLATOR)
+                .release()
+        }
+
+        /** Asserts that the volume dialog is visible. */
+        private fun assertVolumeDialogVisible() {
+            PAGE_TITLE_SELECTOR.assertVisible()
+        }
+
+        /**
+         * This will get the co-ordinate of the for volume slider based on the volume value
+         * provided.
+         *
+         * Note: Volume value cannot be more than 25 and less than 0.
+         *
+         * Formula's used: Suppose volume slider length is 100 and volume provided is 15, therefore
+         * slider should move to:
+         *
+         * FORMULA: (Volume Provided / Max Volume) * Slider Length Hence in current scenario its:
+         * (15/25)*100
+         *
+         * Since the Android device coordinate works from top to down
+         * [https://screenshot.googleplex .com/Zm3s1rqJ2Es], therefore formula used for coordinate
+         * calculation is:
+         *
+         * X-Coordinate: TOP + ((MAX VOLUME - GIVEN VOLUME)/MAX VOLUME ) * (SLIDER BOTTOM Y
+         * COORDINATE - SLIDER TOP Y COORDINATE)
+         *
+         * Y-Coordinate: SLIDER LEFT X COORDINATE + (SLIDER RIGHT X COORDINATE - SLIDER LEFT X
+         * COORDINATE) / 2
+         *
+         * @param volume value for volume to changed
+         * @return an of Point which is the coordinate of the slider to be moved too.
+         */
+        private fun getDragCoordinates(volume: Int): Point {
+            Truth.assertThat(volume).isLessThan(MAX_VOLUME)
+            Truth.assertThat(volume).isGreaterThan(MIN_VOLUME)
+            val dimension = uiDevice.waitForObj(SLIDER).visibleBounds
+            val top = dimension.top
+            val left = dimension.left
+            val right = dimension.right
+            val bottom = dimension.bottom
+            val y = (top + (25 - volume).toFloat() / 25 * (bottom - top)).toInt()
+            val x = left + (right - left) / 2
+            return Point(x, y)
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumePanelDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumePanelDialog.kt
new file mode 100644
index 000000000..5e4c64b0a
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumePanelDialog.kt
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.ui
+
+import android.media.AudioManager
+import android.platform.systemui_tapl.utils.DeviceUtils.SHORT_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.DeviceUtils.settingsResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.betterSwipe
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import android.platform.uiautomatorhelpers.PRECISE_GESTURE_INTERPOLATOR
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.widget.SeekBar
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiObject2
+import com.google.common.collect.Range
+import com.google.common.truth.Truth.assertWithMessage
+import java.util.regex.Pattern
+
+/**
+ * Volume settings panel which is opened after click setting button on the volume dialog.
+ *
+ * https://hsv.googleplex.com/5613609590718464?node=6
+ */
+class VolumePanelDialog internal constructor() {
+    private val container: UiObject2 =
+        waitForObj(settingsResSelector("panel_container")) { "Can't find volume menu dialog" }
+
+    private val audioManager =
+        context.getSystemService(AudioManager::class.java)
+            ?: error("Unable to get the AudioManager for ${VolumePanelDialog::class}")
+
+    /**
+     * Convert volume index to the percentage.
+     *
+     * @param[stream] The volume stream to get the max/min volume.
+     * @param[volumeIndex] The volume index to set.
+     * @return The percentage of the max volume.
+     */
+    private fun volumeToPercentage(stream: Int, volumeIndex: Int): Float {
+        val maxVol: Int = audioManager.getStreamMaxVolume(stream)
+        val minVol: Int = audioManager.getStreamMinVolume(stream)
+        assertWithMessage("input volume is of out range.")
+            .that(volumeIndex)
+            .isIn(Range.closed(minVol, maxVol))
+        return (volumeIndex - minVol).toFloat() / (maxVol - minVol)
+    }
+
+    /**
+     * Adjust ring volume by dragging "Ring & notification volume", or "Ring volume" slider.
+     *
+     * https://hsv.googleplex.com/5613609590718464?node=47
+     *
+     * @param[volume] The target volume index.
+     */
+    fun adjustRingVolume(volume: Int): VolumePanelDialog {
+        val pattern = Pattern.compile("(Ring & notification volume)|(Ring volume)")
+        val ringContainerSel = androidResSelector("content").hasDescendant(By.text(pattern))
+        val ringContainer = container.waitForObj(ringContainerSel, SHORT_WAIT)
+        val seekBar =
+            ringContainer.waitForObj(By.clazz(SeekBar::class.java)) {
+                "Can't find ring volume slider."
+            }
+        val bound = seekBar.visibleBounds
+        val rate = volumeToPercentage(AudioManager.STREAM_RING, volume)
+        val x = ((bound.right - bound.left) * rate + bound.left).toInt()
+        uiDevice.betterSwipe(
+            startX = bound.centerX(),
+            startY = bound.centerY(),
+            endX = x,
+            endY = bound.centerY(),
+            interpolator = PRECISE_GESTURE_INTERPOLATOR,
+        )
+        ensureThat("Volume is set to $volume.") {
+            audioManager.getStreamVolume(AudioManager.STREAM_RING) == volume
+        }
+        return this
+    }
+
+    /**
+     * Click done button.
+     *
+     * https://hsv.googleplex.com/5613609590718464?node=63
+     */
+    fun clickDone() {
+        val btnSel = settingsResSelector("done")
+        waitForObj(btnSel).click()
+        btnSel.assertInvisible {
+            "Volume panel dialog's done button should be invisible after clicking."
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeRingerDrawer.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeRingerDrawer.kt
new file mode 100644
index 000000000..5a6c47474
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/VolumeRingerDrawer.kt
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.controller.VolumeController.RingerMode
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiObject2
+
+/**
+ * Ringer drawer is a container which is opened after clicking ringer mode button.
+ *
+ * Volume dialog(drawer closed): https://hsv.googleplex.com/4762218357850112
+ *
+ * Ringer drawer: https://hsv.googleplex.com/5102770609717248
+ */
+class VolumeRingerDrawer internal constructor() {
+
+    private val container: UiObject2
+
+    init {
+        val containerSel = sysuiResSelector("volume_drawer_container")
+        this.container = waitForObj(containerSel) { "Can't find the ringer drawer." }
+    }
+
+    /**
+     * Detect the current selected mode by checking the highlighted ringer icon. The highlighted
+     * icon is the one with the active icon container on the top.
+     */
+    val selectedMode: RingerMode
+        get() {
+            val activeIconSel = sysuiResSelector("volume_new_ringer_active_icon_container")
+            val activeIcon =
+                waitForObj(activeIconSel) { "Can't find any active icon on the drawer." }
+            val center = activeIcon.visibleCenter
+            return RingerMode.values()
+                .filter { it.isAvailable }
+                .first {
+                    val icon =
+                        container.waitForObj(it.getIconSelector()) {
+                            "Can't find $it icon on the drawer."
+                        }
+                    icon.visibleBounds.contains(center.x, center.y)
+                }
+        }
+
+    /** Click the given ringer icon in the drawer. */
+    fun selectRingerMode(mode: RingerMode): VolumeDialog {
+        waitForObj(mode.getIconSelector()) { "$mode icon not found" }.click()
+        return VolumeDialog()
+    }
+
+    private fun RingerMode.getIconSelector(): BySelector {
+        return when (this) {
+            RingerMode.NORMAL -> "volume_drawer_normal"
+            RingerMode.SILENT -> "volume_drawer_mute"
+            RingerMode.VIBRATE -> "volume_drawer_vibrate"
+        }.let { sysuiResSelector(it) }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/WelcomeBackGuestDialog.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/WelcomeBackGuestDialog.kt
new file mode 100644
index 000000000..7930d6ea6
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/ui/WelcomeBackGuestDialog.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.androidResSelector
+import android.platform.systemui_tapl.utils.UserUtils.runThenWaitUntilSwitchCompleted
+import android.platform.uiautomatorhelpers.DeviceHelpers.assertVisible
+import android.platform.uiautomatorhelpers.DeviceHelpers.waitForObj
+import java.util.regex.Pattern
+
+/**
+ * System UI test automation object representing the confirmation dialog after switching to the
+ * guest user.
+ */
+class WelcomeBackGuestDialog internal constructor() {
+    /** Click the start over button. https://hsv.googleplex.com/6260902091292672?node=15 */
+    fun startOver() {
+        runThenWaitUntilSwitchCompleted {
+            TITLE_SELECTOR.assertVisible { "Welcome back guest dialog is not visible" }
+            waitForObj(START_OVER_BUTTON_SELECTOR).click()
+        }
+    }
+
+    companion object {
+        // https://hsv.googleplex.com/6260902091292672?node=7
+        private val TITLE_SELECTOR =
+            androidResSelector("alertTitle")
+                .text(Pattern.compile("Welcome back, guest!", Pattern.CASE_INSENSITIVE))
+
+        // https://hsv.googleplex.com/6260902091292672?node=15
+        private val START_OVER_BUTTON_SELECTOR =
+            androidResSelector("button2")
+                .text(Pattern.compile("Start over", Pattern.CASE_INSENSITIVE))
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt
new file mode 100644
index 000000000..007e741d4
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/DeviceUtils.kt
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.utils
+
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.BySelector
+import java.time.Duration
+
+const val SYSUI_PACKAGE = "com.android.systemui"
+const val SETTINGS_PACKAGE = "com.android.settings"
+private const val LAUNCHER_PACKAGE = "com.google.android.apps.nexuslauncher"
+private const val ANDROID_PACKAGE = "android"
+
+object DeviceUtils {
+    @JvmField val SHORT_WAIT: Duration = Duration.ofMillis(1_500)
+    @JvmField val LONG_WAIT: Duration = Duration.ofMillis(10_000)
+
+    /** Returns a [BySelector] of a resource in sysui package. */
+    @JvmStatic
+    fun sysuiResSelector(resourceId: String): BySelector =
+        By.pkg(SYSUI_PACKAGE).res(SYSUI_PACKAGE, resourceId)
+
+    /** Returns a [BySelector] of a resource in settings package. */
+    @JvmStatic
+    fun settingsResSelector(resourceId: String): BySelector =
+        By.pkg(SETTINGS_PACKAGE).res(SETTINGS_PACKAGE, resourceId)
+
+    /** Returns a [BySelector] of a resource in launcher package. */
+    @JvmStatic
+    fun launcherResSelector(resourceId: String): BySelector =
+        By.pkg(LAUNCHER_PACKAGE).res(LAUNCHER_PACKAGE, resourceId)
+
+    /** Returns a [BySelector] of a resource with the given content description in sysui package. */
+    @JvmStatic
+    fun sysuiDescSelector(contentDescription: String): BySelector =
+        By.pkg(SYSUI_PACKAGE).desc(contentDescription)
+
+    /**
+     * Returns a [BySelector] of a resource with the given content description in launcher package.
+     */
+    @JvmStatic
+    fun launcherDescSelector(contentDescription: String): BySelector =
+        By.pkg(LAUNCHER_PACKAGE).desc(contentDescription)
+
+    /** Returns a [BySelector] of a resource in android package. */
+    @JvmStatic
+    fun androidResSelector(resourceId: String): BySelector = By.res(ANDROID_PACKAGE, resourceId)
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/Retry.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/Retry.kt
new file mode 100644
index 000000000..345969e78
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/Retry.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.utils
+
+/**
+ * Run the function and retry when exceptions thrown.
+ *
+ * @param function The function which needs retry
+ * @param retry Maximum retry count, including the first run
+ * @param backoff Gap between retries in millis
+ */
+fun runWithRetry(function: Runnable, retry: Int = 3, backoff: Long = 1_000) {
+    for (i in 1..retry) {
+        try {
+            function.run()
+            return
+        } catch (e: Exception) {
+            if (i == retry) {
+                throw RuntimeException("Execution failed after retry $retry times", e)
+            } else {
+                Thread.sleep(backoff)
+            }
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/UserUtils.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/UserUtils.kt
new file mode 100644
index 000000000..f19703b03
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/utils/UserUtils.kt
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.utils
+
+import android.app.ActivityManager
+import android.app.IUserSwitchObserver
+import android.app.UserSwitchObserver
+import android.platform.helpers.CommonUtils.println
+import android.platform.uiautomator_helpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomator_helpers.TracingUtils.trace
+import android.util.Log
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.StaleObjectException
+import com.google.common.truth.Truth.assertWithMessage
+import java.time.Duration
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+
+/** DON'T USE FROM TESTS: TAPL user utilities to be used from ui and controller objects */
+object UserUtils {
+    private val TAG = UserUtils::class.java.simpleName
+    private val UI_RESPONSE_USER_SWITCH_COMPLETE_TIMEOUT = Duration.ofMinutes(1)
+    private val EVENT_USER_SWITCH_COMPLETE_TIMEOUT = Duration.ofMinutes(1)
+    private const val DEBUG = false
+
+    private val mActivityManager = ActivityManager.getService()
+
+    /**
+     * String displayed for the "Add guest" item in quick settings. The word "Guest" is shown in
+     * quick settings regardless of whether there is already a guest on the device.
+     */
+    private val sUserSwitchingSelector = By.textStartsWith("Switching to ")
+    private val sUserSwitchedSemaphore = Semaphore(0 /* permits */)
+    private val sUserSwitchedObserver: IUserSwitchObserver =
+        object : UserSwitchObserver() {
+            override fun onUserSwitchComplete(newUserId: Int) {
+                Log.i(TAG, "userSwitchComplete for $newUserId")
+                sUserSwitchedSemaphore.release()
+            }
+        }
+
+    init {
+        if (DEBUG) println("$TAG#registerUserSwitchedObserver")
+        mActivityManager.registerUserSwitchObserver(sUserSwitchedObserver, TAG)
+    }
+
+    private fun runThenWaitForUserSwitchCompleteEvent(switchUser: Runnable) {
+        trace("switchUserAndWaitForUserSwitchedEvent") {
+            if (DEBUG) println("$TAG#switchUserAndWaitForUserSwitchedEvent")
+            sUserSwitchedSemaphore.drainPermits()
+            switchUser.run()
+            try {
+                assertWithMessage("User switched event wasn't received")
+                    .that(
+                        sUserSwitchedSemaphore.tryAcquire(
+                            /* permits */ 1,
+                            EVENT_USER_SWITCH_COMPLETE_TIMEOUT.toSeconds(),
+                            TimeUnit.SECONDS,
+                        )
+                    )
+                    .isTrue()
+            } catch (e: InterruptedException) {
+                throw AssertionError("Interrupted while verifying user switched", e)
+            }
+        }
+    }
+
+    private fun waitUntilSwitchingUserDialogIsGone() {
+        trace("waitUntilSwitchingUserDialogIsGone") {
+            if (DEBUG) println("$TAG#waitUntilSwitchingUserDialogIsGone")
+            try {
+                sUserSwitchingSelector.assertInvisible(UI_RESPONSE_USER_SWITCH_COMPLETE_TIMEOUT) {
+                    "Switching user dialog is not gone"
+                }
+            } catch (e: StaleObjectException) {
+                // ignore
+            }
+        }
+    }
+
+    @JvmStatic
+    fun runThenWaitUntilSwitchCompleted(switchUser: Runnable) {
+        trace("switchUserAndWaitUntilSwitchCompleted") {
+            if (DEBUG) println("$TAG#switchUserAndWaitUntilSwitchCompleted")
+            runThenWaitForUserSwitchCompleteEvent(switchUser)
+            waitUntilSwitchingUserDialogIsGone()
+            // There's an incredible amount of jank, etc. after switching users. Wait a long
+            // time.
+            trace("wait a long time for jank to disappear") {
+                try {
+                    TimeUnit.SECONDS.sleep(EVENT_USER_SWITCH_COMPLETE_TIMEOUT.toSeconds())
+                } catch (ignored: InterruptedException) {}
+            }
+        }
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/rule/VolumePanelRule.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/rule/VolumePanelRule.kt
new file mode 100644
index 000000000..b11af72ff
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/rule/VolumePanelRule.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.volume.panel.rule
+
+import android.media.AudioManager
+import android.platform.systemui_tapl.ui.Root.Companion.get
+import android.platform.systemui_tapl.volume.panel.ui.VolumePanel
+import org.junit.rules.TestWatcher
+import org.junit.runner.Description
+
+/**
+ * Rule that opens the Volume Panel for the duration of the test and ensures it's closed afterwards.
+ */
+class VolumePanelRule(private val mAudioManager: AudioManager) : TestWatcher() {
+
+    /** Returns [VolumePanel] for easy access the opened panel. */
+    val volumePanel: VolumePanel
+        get() = checkNotNull(mutableVolumePanel) { "Volume Panel hasn't been opened yet" }
+
+    private var mutableVolumePanel: VolumePanel? = null
+
+    override fun starting(description: Description) {
+        super.starting(description)
+        // Open the volume dialog
+        mAudioManager.adjustSuggestedStreamVolume(
+            AudioManager.ADJUST_SAME,
+            AudioManager.STREAM_MUSIC,
+            AudioManager.FLAG_SHOW_UI,
+        )
+        mutableVolumePanel = get().volumeDialog.openNewVolumePanel()
+    }
+
+    override fun finished(description: Description) {
+        mutableVolumePanel?.done()
+        super.finished(description)
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/SliderStream.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/SliderStream.kt
new file mode 100644
index 000000000..714c4d40d
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/SliderStream.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.volume.panel.ui
+
+import android.media.AudioManager
+import androidx.annotation.IntDef
+
+/** [AudioManager].STREAM_* supported by the [VolumePanelSlider]. */
+@Retention(AnnotationRetention.SOURCE)
+@IntDef(
+    value =
+        [
+            AudioManager.STREAM_MUSIC,
+            AudioManager.STREAM_VOICE_CALL,
+            AudioManager.STREAM_RING,
+            AudioManager.STREAM_NOTIFICATION,
+            AudioManager.STREAM_ALARM,
+        ]
+)
+annotation class SliderStream {
+
+    companion object {
+        private val resourceIdsByStream =
+            mapOf(
+                AudioManager.STREAM_MUSIC to "Media",
+                AudioManager.STREAM_VOICE_CALL to "Call",
+                AudioManager.STREAM_RING to "Ring",
+                AudioManager.STREAM_NOTIFICATION to "Notification",
+                AudioManager.STREAM_ALARM to "Alarm",
+            )
+
+        fun getResourceId(@SliderStream stream: Int): String =
+            resourceIdsByStream[stream] ?: throw IllegalArgumentException("Unknown stream $stream")
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanel.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanel.kt
new file mode 100644
index 000000000..eb6846ec7
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanel.kt
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.volume.panel.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils.LONG_WAIT
+import android.platform.systemui_tapl.utils.DeviceUtils.sysuiResSelector
+import android.platform.systemui_tapl.utils.SYSUI_PACKAGE
+import android.platform.uiautomator_helpers.DeviceHelpers.assertInvisible
+import android.platform.uiautomator_helpers.DeviceHelpers.assertVisible
+import android.platform.uiautomator_helpers.DeviceHelpers.waitForObj
+import androidx.test.uiautomator.By
+import androidx.test.uiautomator.UiObject2
+
+/** Same as com.android.systemui.volume.panel.ui.composable.VolumePanelRoot#VolumePanelTestTag */
+private const val VOLUME_PANEL_TEST_TAG = "VolumePanel"
+
+/** Volume Panel components. */
+class VolumePanel {
+
+    init {
+        sysuiResSelector(VOLUME_PANEL_TEST_TAG).assertVisible(timeout = LONG_WAIT)
+    }
+
+    private val container: UiObject2 =
+        waitForObj(sysuiResSelector(VOLUME_PANEL_TEST_TAG)) { "Can't find volume panel" }
+
+    /** Returns an access points for a particular slider for a [streamType] */
+    fun slider(@SliderStream streamType: Int): VolumePanelSlider =
+        VolumePanelSliderImpl(container, streamType)
+
+    /** Clicks Done button */
+    fun done() {
+        container
+            .waitForObj(By.pkg(SYSUI_PACKAGE).text("Done")) { "Can't find Done button" }
+            .click()
+        sysuiResSelector(VOLUME_PANEL_TEST_TAG).assertInvisible()
+    }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanelSlider.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanelSlider.kt
new file mode 100644
index 000000000..af4246600
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/panel/ui/VolumePanelSlider.kt
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.systemui_tapl.volume.panel.ui
+
+import android.platform.systemui_tapl.utils.DeviceUtils
+import android.platform.uiautomator_helpers.DeviceHelpers.waitForObj
+import android.view.accessibility.AccessibilityNodeInfo
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+
+/**
+ * An access point for the Volume Panel slider.
+ *
+ * @see VolumePanel.slider
+ */
+interface VolumePanelSlider {
+
+    /** Scrolls until the [targetProgress] is met. */
+    fun scrollToProgress(targetProgress: Float)
+}
+
+internal class VolumePanelSliderImpl(container: UiObject2, @SliderStream streamType: Int) :
+    VolumePanelSlider {
+
+    private val sliderObject: UiObject2 =
+        container.waitForObj(DeviceUtils.sysuiResSelector(SliderStream.getResourceId(streamType))) {
+            "Can't find slider=$streamType"
+        }
+
+    override fun scrollToProgress(targetProgress: Float) {
+        val currentProgress = sliderObject.getProgress()
+        val direction =
+            when {
+                targetProgress > currentProgress -> Direction.LEFT
+                targetProgress < currentProgress -> Direction.RIGHT
+                else -> return
+            }
+        sliderObject.scrollUntil(direction) { obj -> obj.getProgress() == targetProgress }
+    }
+
+    // TODO: b/349817024 - Remove this method in favour of the new API
+    private fun UiObject2.getProgress(): Float =
+        with(javaClass.getDeclaredMethod("getAccessibilityNodeInfo")) {
+            val originalIsAccessible = isAccessible
+            return try {
+                isAccessible = true
+                val rangeInfo =
+                    (invoke(this@getProgress) as AccessibilityNodeInfo).rangeInfo
+                        ?: throw RuntimeException(
+                            "No RangeInfo found for the object=[$contentDescription, $resourceName]"
+                        )
+                rangeInfo.current
+            } finally {
+                isAccessible = originalIsAccessible
+            }
+        }
+}
diff --git a/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt
new file mode 100644
index 000000000..3810293e1
--- /dev/null
+++ b/libraries/systemui-tapl/src/android/platform/systemui_tapl/volume/rule/SetupVolumeRule.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.systemui_tapl.volume.rule
+
+import android.media.AudioManager
+import android.platform.systemui_tapl.permissions.rule.AdoptShellPermissionsRule
+import android.util.Log
+import org.junit.rules.TestWatcher
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * Set volume for each provided stream for the duration of the test and reset them back to the
+ * original values afterwards.
+ */
+class SetupVolumeRule(
+    private val audioManager: AudioManager,
+    private val testVolumes: Collection<Volume>,
+) : TestWatcher() {
+
+    constructor(
+        audioManager: AudioManager,
+        vararg testVolumes: Volume,
+    ) : this(audioManager, testVolumes.toList())
+
+    private val adoptShellPermissionRule =
+        AdoptShellPermissionsRule(android.Manifest.permission.MANAGE_NOTIFICATIONS)
+
+    private lateinit var originalVolumes: Collection<Volume>
+
+    override fun apply(base: Statement?, description: Description?): Statement {
+        return adoptShellPermissionRule.apply(super.apply(base, description), description)
+    }
+
+    override fun starting(description: Description) {
+        super.starting(description)
+        originalVolumes =
+            testVolumes.map { Volume(it.audioStream, audioManager.getStreamVolume(it.audioStream)) }
+        for (testVolume in testVolumes) {
+            audioManager.setStreamVolume(testVolume.audioStream, testVolume.volume, 0)
+        }
+        Log.d("SetupVolumeRule", "Volumes set to: $testVolumes")
+    }
+
+    override fun finished(description: Description) {
+        for (volume in originalVolumes) {
+            audioManager.setStreamVolume(volume.audioStream, volume.volume, 0)
+        }
+        Log.d("SetupVolumeRule", "Volumes restored to: $originalVolumes")
+        super.finished(description)
+    }
+
+    /** Models volume value for a stream. */
+    data class Volume(val audioStream: Int, val volume: Int)
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt
index e31002fbe..16100e9c2 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterFling.kt
@@ -33,6 +33,7 @@ import java.time.temporal.ChronoUnit
  *
  * See [BetterSwipe] for more details on the problem of [UiObject2.fling].
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object BetterFling {
     private const val DEFAULT_FLING_MARGIN_DP = 30
     private const val DEFAULT_PERCENTAGE = 1.0f
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt
index 26c55a89e..3c199f151 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterScroll.kt
@@ -9,11 +9,13 @@ import androidx.test.uiautomator.UiObject2
 import androidx.test.uiautomator.Until
 import java.time.Duration
 
+
 /**
  * A scroll utility that should be used instead of [UiObject2.scroll] for more reliable scrolls.
  *
  * See [BetterSwipe] for more details on the problem of [UiObject2.scroll].
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object BetterScroll {
     private const val DEFAULT_PERCENTAGE = 0.8f
     private val DEFAULT_WAIT_TIMEOUT = Duration.ofSeconds(1)
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt
index ad81e16c4..440d1e3fd 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/BetterSwipe.kt
@@ -58,6 +58,7 @@ private val PAUSE_DURATION: Duration = Duration.of(250, MILLIS)
  * swipe.to(anotherPoint).release()
  * ```
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object BetterSwipe {
 
     private val lastPointerId = AtomicInteger(0)
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt
index f2bfa6332..8f2aa5747 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DeviceHelpers.kt
@@ -38,6 +38,7 @@ import java.time.Duration
 
 private const val TAG = "DeviceHelpers"
 
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object DeviceHelpers {
     private val SHORT_WAIT = Duration.ofMillis(1500)
     private val LONG_WAIT = Duration.ofSeconds(10)
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt
index ae035b9a5..c449f15a8 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/DurationUtils.kt
@@ -24,6 +24,7 @@ private const val CUTTLEFISH_FACTOR = 5L
  *  For physical (non-emulator) devices, the timeout is unchanged,
  *  the if the Build.HARDWARE is Cuttlefish, we increase the factor by 5.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object DurationUtils {
 
     /**
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt
index a77aa85e1..826861109 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/ShellPrivilege.kt
@@ -22,6 +22,7 @@ import androidx.test.platform.app.InstrumentationRegistry
  *
  * @param[permissions] the permission to adopt. Adopt all available permission is it's empty.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 class ShellPrivilege(vararg permissions: String) : AutoCloseable {
 
     private val instrumentation = InstrumentationRegistry.getInstrumentation()
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt
index 5bb318706..eac703868 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/SwipeUtils.kt
@@ -9,6 +9,7 @@ import androidx.test.uiautomator.Direction.RIGHT
 import androidx.test.uiautomator.Direction.UP
 
 /** Common utils to perform swipes. */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 internal object SwipeUtils {
 
     /**
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt
index 0ba36acf4..8f1b71ffb 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/UiObjectUtils.kt
@@ -26,6 +26,7 @@ import androidx.test.uiautomator.UiObject2
 import com.google.common.truth.Truth.assertWithMessage
 
 /** Checks the view is in the vertical (Y) centre of the screen (+- 1 px). */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertInVerticalCentre() {
     assertWithMessage("${this.resourceName} should be vertically (Y) centred (+- 1px)")
         .that(this.stableBounds.centerY())
@@ -33,6 +34,7 @@ fun UiObject2.assertInVerticalCentre() {
 }
 
 /** Checks the view is in the horizontal (X) centre of the screen (+- 1 px). */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertInHorizontalCentre() {
     assertWithMessage("${this.resourceName} should be horizontally (X) centred (+- 1px)")
         .that(this.stableBounds.centerX())
@@ -43,6 +45,7 @@ fun UiObject2.assertInHorizontalCentre() {
  * Checks if centre of the view is on the bottom side by checking y centre is in the bottom half of
  * the screen vertically.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertCentreOnBottomSide() {
     assertWithMessage("${this.resourceName} centre should be on the bottom side")
         .that(this.stableBounds.centerY() > uiDevice.displayHeight / 2)
@@ -53,6 +56,7 @@ fun UiObject2.assertCentreOnBottomSide() {
  * Checks if centre of the view is on the top side by checking y centre is in the top half of the
  * screen vertically.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertCentreOnTopSide() {
     assertWithMessage("${this.resourceName} centre should be on the top side")
         .that(this.stableBounds.centerY() < uiDevice.displayHeight / 2)
@@ -63,6 +67,7 @@ fun UiObject2.assertCentreOnTopSide() {
  * Checks if top of the view is on the bottom side by checking top bound is in the bottom half of
  * the screen vertically.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertTopOnBottomSide() {
     assertWithMessage("${this.resourceName} top should be on the bottom side")
         .that(this.stableBounds.top > uiDevice.displayHeight / 2)
@@ -73,6 +78,7 @@ fun UiObject2.assertTopOnBottomSide() {
  * Checks if top of the view is on the top side by checking top bound is in the top half of the
  * screen vertically.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertTopOnTopSide() {
     assertWithMessage("${this.resourceName} top should be on the top side")
         .that(this.stableBounds.top < uiDevice.displayHeight / 2)
@@ -87,6 +93,7 @@ fun UiObject2.assertCenterOnTheRightSide() {
 }
 
 /** Checks if view horizontal (X) centre is on the left side */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertCenterOnTheLeftSide() {
     assertWithMessage("${this.resourceName} center should be on the left side")
         .that(this.stableBounds.centerX() < uiDevice.displayWidth / 2)
@@ -97,6 +104,7 @@ fun UiObject2.assertCenterOnTheLeftSide() {
  * Checks if view is on the right side by checking left bound is in the middle of the screen or in
  * the right half of the screen horizontally.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertOnTheRightSide() {
     assertWithMessage("${this.resourceName} left should be on the right side")
         .that(this.stableBounds.left >= uiDevice.displayWidth / 2)
@@ -107,6 +115,7 @@ fun UiObject2.assertOnTheRightSide() {
  * Checks if view is on the left side by checking right bound is in the middle of the screen or in
  * the left half of the screen horizontally.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.assertOnTheLeftSide() {
     assertWithMessage("${this.resourceName} right should be on the left side")
         .that(this.stableBounds.right <= uiDevice.displayWidth / 2)
@@ -119,6 +128,7 @@ fun UiObject2.assertOnTheLeftSide() {
  * Before returning, ensures visible bounds stay the same for a few seconds or fails. Useful to get
  * bounds of objects that might be animating.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 val UiObject2.stableBounds: Rect
     get() = waitForValueToSettle("${this.resourceName} bounds") { visibleBounds }
 
@@ -133,6 +143,7 @@ private const val MAX_FIND_ELEMENT_ATTEMPT = 15
  * Uses [BetterSwipe] to perform the scroll.
  */
 @JvmOverloads
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 fun UiObject2.scrollUntilFound(
     selector: BySelector,
     direction: Direction = Direction.DOWN,
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt
index 05ccb3c43..de9802142 100644
--- a/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomator_helpers/WaitUtils.kt
@@ -38,6 +38,7 @@ data class WaitReport(val result: WaitResult, val iterations: Int)
  *
  * Those are meant to make tests more understandable from perfetto traces, and less flaky.
  */
+@Deprecated("Use uiautomatorhelpers, b/376676853")
 object WaitUtils {
     private val DEFAULT_DEADLINE = Duration.ofSeconds(10)
     private val POLLING_WAIT = Duration.ofMillis(100)
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterFling.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterFling.kt
new file mode 100644
index 000000000..c117fd2a7
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterFling.kt
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.uiautomatorhelpers
+
+import android.graphics.Rect
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.SwipeUtils.calculateStartEndPoint
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.util.TypedValue
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import java.time.Duration
+import java.time.temporal.ChronoUnit
+
+/**
+ * A fling utility that should be used instead of [UiObject2.fling] for more reliable flings.
+ *
+ * See [BetterSwipe] for more details on the problem of [UiObject2.fling].
+ */
+object BetterFling {
+    private const val DEFAULT_FLING_MARGIN_DP = 30
+    private const val DEFAULT_PERCENTAGE = 1.0f
+    private val DEFAULT_FLING_DURATION = Duration.of(100, ChronoUnit.MILLIS)
+    private val DEFAULT_WAIT_TIMEOUT = Duration.of(5, ChronoUnit.SECONDS)
+
+    /**
+     * Flings [percentage] of [rect] in the given [direction], with [marginDp] margins.
+     *
+     * Note that when direction is [Direction.DOWN], the scroll will be from the top to the bottom
+     * (to scroll down).
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun fling(
+        rect: Rect,
+        direction: Direction,
+        duration: Duration = DEFAULT_FLING_DURATION,
+        marginDp: Int = DEFAULT_FLING_MARGIN_DP,
+        percentage: Float = DEFAULT_PERCENTAGE,
+    ) {
+        val (start, stop) =
+            calculateStartEndPoint(rect, direction, percentage, marginDp.dpToPx().toInt())
+
+        trace("Fling $start -> $stop") {
+            uiDevice.performActionAndWait(
+                { BetterSwipe.from(start).to(stop, duration).release() },
+                Until.scrollFinished(Direction.reverse(direction)),
+                DEFAULT_WAIT_TIMEOUT.toMillis()
+            )
+        }
+    }
+
+    private fun Number.dpToPx(): Float {
+        return TypedValue.applyDimension(
+            TypedValue.COMPLEX_UNIT_DIP,
+            toFloat(),
+            context.resources.displayMetrics,
+        )
+    }
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterScroll.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterScroll.kt
new file mode 100644
index 000000000..27dc45cca
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterScroll.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.graphics.Rect
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.SwipeUtils.calculateStartEndPoint
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+import androidx.test.uiautomator.Until
+import java.time.Duration
+
+/**
+ * A scroll utility that should be used instead of [UiObject2.scroll] for more reliable scrolls.
+ *
+ * See [BetterSwipe] for more details on the problem of [UiObject2.scroll].
+ */
+object BetterScroll {
+    private const val DEFAULT_PERCENTAGE = 0.8f
+    private val DEFAULT_WAIT_TIMEOUT = Duration.ofSeconds(1)
+
+    /**
+     * Scrolls [percentage] of [rect] in the given [direction].
+     *
+     * Note that when direction is [Direction.DOWN], the scroll will be from the top to the bottom
+     * (to scroll down).
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun scroll(
+        rect: Rect,
+        direction: Direction,
+        percentage: Float = DEFAULT_PERCENTAGE,
+    ) {
+        val (start, stop) = calculateStartEndPoint(rect, direction, percentage)
+
+        trace("Scrolling $start -> $stop") {
+            uiDevice.performActionAndWait(
+                { BetterSwipe.from(start).to(stop).pause().release() },
+                Until.scrollFinished(Direction.reverse(direction)),
+                DEFAULT_WAIT_TIMEOUT.toMillis()
+            )
+        }
+    }
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt
new file mode 100644
index 000000000..a6bb07b17
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/BetterSwipe.kt
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.animation.TimeInterpolator
+import android.graphics.Point
+import android.graphics.PointF
+import android.hardware.display.DisplayManager
+import android.os.SystemClock
+import android.os.SystemClock.sleep
+import android.platform.uiautomatorhelpers.DeviceHelpers.context
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.util.Log
+import android.view.Display.DEFAULT_DISPLAY
+import android.view.InputDevice
+import android.view.MotionEvent
+import android.view.MotionEvent.TOOL_TYPE_FINGER
+import android.view.animation.DecelerateInterpolator
+import android.view.animation.LinearInterpolator
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import com.google.common.truth.Truth.assertThat
+import java.time.Duration
+import java.time.temporal.ChronoUnit.MILLIS
+import java.util.concurrent.atomic.AtomicInteger
+
+private val DEFAULT_DURATION: Duration = Duration.of(500, MILLIS)
+private val PAUSE_DURATION: Duration = Duration.of(250, MILLIS)
+
+/**
+ * Allows fine control of swipes on the screen.
+ *
+ * Guarantees that all touches are dispatched, as opposed to [UiDevice] APIs, that might lose
+ * touches in case of high load.
+ *
+ * It is possible to perform operation before the swipe finishes. Timestamp of touch events are set
+ * according to initial time and duration.
+ *
+ * Example usage:
+ * ```
+ * val swipe = BetterSwipe.from(startPoint).to(intermediatePoint)
+ *
+ * assertThat(someUiState).isTrue();
+ *
+ * swipe.to(anotherPoint).release()
+ * ```
+ */
+object BetterSwipe {
+
+    private val lastPointerId = AtomicInteger(0)
+
+    /** Starts a swipe from [start] at the current time. */
+    @JvmStatic fun from(start: PointF) = Swipe(start)
+
+    /** Starts a swipe from [start] at the current time. */
+    @JvmStatic fun from(start: Point) = Swipe(PointF(start.x.toFloat(), start.y.toFloat()))
+
+    class Swipe internal constructor(start: PointF) {
+
+        private val downTime = SystemClock.uptimeMillis()
+        private val pointerId = lastPointerId.incrementAndGet()
+        private var lastPoint: PointF = start
+        private var lastTime: Long = downTime
+        private var released = false
+
+        init {
+            log("Touch $pointerId started at $start")
+            sendPointer(currentTime = downTime, action = MotionEvent.ACTION_DOWN, point = start)
+        }
+
+        /**
+         * Swipes from the current point to [end] in [duration] using [interpolator] for the gesture
+         * speed. Pass [FLING_GESTURE_INTERPOLATOR] for a fling-like gesture that may leave the
+         * surface moving by inertia. Don't use it to drag objects to a precisely specified
+         * position. [PRECISE_GESTURE_INTERPOLATOR] will result in a precise drag-like gesture not
+         * triggering inertia.
+         */
+        @JvmOverloads
+        fun to(
+            end: PointF,
+            duration: Duration = DEFAULT_DURATION,
+            interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR
+        ): Swipe {
+            throwIfReleased()
+            val stepTime = calculateStepTime()
+            log(
+                "Swiping from $lastPoint to $end in $duration " +
+                    "(step time: ${stepTime.toMillis()}ms)" +
+                    "using ${interpolator.javaClass.simpleName}"
+            )
+            lastTime =
+                movePointer(duration = duration, from = lastPoint, to = end, interpolator, stepTime)
+            lastPoint = end
+            return this
+        }
+
+        /**
+         * Swipes from the current point to [end] in [duration] using [interpolator] for the gesture
+         * speed. Pass [FLING_GESTURE_INTERPOLATOR] for a fling-like gesture that may leave the
+         * surface moving by inertia. Don't use it to drag objects to a precisely specified
+         * position. [PRECISE_GESTURE_INTERPOLATOR] will result in a precise drag-like gesture not
+         * triggering inertia.
+         */
+        @JvmOverloads
+        fun to(
+            end: Point,
+            duration: Duration = DEFAULT_DURATION,
+            interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR
+        ): Swipe {
+            return to(PointF(end.x.toFloat(), end.y.toFloat()), duration, interpolator)
+        }
+
+        /** Sends the last point, simulating a finger pause. */
+        fun pause(): Swipe {
+            return to(PointF(lastPoint.x, lastPoint.y), PAUSE_DURATION)
+        }
+
+        /** Moves the pointer up, finishing the swipe. Further calls will result in an exception. */
+        @JvmOverloads
+        fun release(sync: Boolean = true) {
+            throwIfReleased()
+            log("Touch $pointerId released at $lastPoint")
+            sendPointer(
+                currentTime = lastTime,
+                action = MotionEvent.ACTION_UP,
+                point = lastPoint,
+                sync = sync
+            )
+            lastPointerId.decrementAndGet()
+            released = true
+        }
+
+        /** Moves the pointer by [delta], sending the event at [currentTime]. */
+        internal fun moveBy(delta: PointF, currentTime: Long, sync: Boolean) {
+            val targetPoint = PointF(lastPoint.x + delta.x, lastPoint.y + delta.y)
+            sendPointer(currentTime, MotionEvent.ACTION_MOVE, targetPoint, sync)
+            lastTime = currentTime
+            lastPoint = targetPoint
+        }
+
+        private fun throwIfReleased() {
+            check(!released) { "Trying to perform a swipe operation after pointer released" }
+        }
+
+        private fun sendPointer(
+            currentTime: Long,
+            action: Int,
+            point: PointF,
+            sync: Boolean = true
+        ) {
+            val event = getMotionEvent(downTime, currentTime, action, point, pointerId)
+
+            try {
+                trySendMotionEvent(event, sync)
+            } finally {
+                event.recycle()
+            }
+        }
+
+        private fun trySendMotionEvent(event: MotionEvent, sync: Boolean) {
+            ensureThat(
+                    "Injecting motion event",
+                    /* timeout= */ Duration.ofMillis(INJECT_EVENT_TIMEOUT_MILLIS),
+                    /* errorProvider= */ {
+                        "Injecting motion event $event failed after retrying for 10 seconds, " +
+                            "see logcat for the error"
+                    }
+                )
+                /* condition= */ {
+                    try {
+                        return@ensureThat getInstrumentation()
+                            .uiAutomation
+                            .injectInputEvent(event, sync, /* waitForAnimations= */ false)
+                    } catch (t: Throwable) {
+                        throw RuntimeException(t)
+                    }
+                }
+        }
+
+        /** Returns the time when movement finished. */
+        private fun movePointer(
+            duration: Duration,
+            from: PointF,
+            to: PointF,
+            interpolator: TimeInterpolator,
+            stepTime: Duration
+        ): Long {
+            val stepTimeMs = stepTime.toMillis()
+            val durationMs = duration.toMillis()
+            val steps = durationMs / stepTimeMs
+            val startTime = lastTime
+            var currentTime = lastTime
+            val startRealTime = SystemClock.uptimeMillis()
+            for (i in 0 until steps) {
+                // The next pointer event shouldn't be dispatched before its time. However, the code
+                // below might take time. So the time to sleep is calculated dynamically, based on
+                // the expected time of this event.
+                val timeToWait = stepTimeMs * i - (SystemClock.uptimeMillis() - startRealTime)
+                if (timeToWait > 0) sleep(stepTimeMs)
+                currentTime += stepTimeMs
+                val progress = interpolator.getInterpolation(i / (steps - 1f))
+                val point = from.lerp(progress, to)
+                sendPointer(currentTime, MotionEvent.ACTION_MOVE, point)
+            }
+            assertThat(currentTime).isEqualTo(startTime + stepTimeMs * steps)
+            return currentTime
+        }
+    }
+
+    /** Collection of swipes. This can be used to simulate multitouch. */
+    class Swipes internal constructor(vararg starts: PointF) {
+
+        private var lastTime: Long = SystemClock.uptimeMillis()
+        private val swipes: List<Swipe> = starts.map { Swipe(it) }
+
+        /** Moves all the swipes by [delta], in [duration] time with constant speed. */
+        fun moveBy(delta: PointF, duration: Duration = DEFAULT_DURATION): Swipes {
+            log("Moving ${swipes.size} touches by $delta")
+
+            val stepTimeMs = calculateStepTime().toMillis()
+            val durationMs = duration.toMillis()
+            val steps = durationMs / stepTimeMs
+            val startTime = lastTime
+            var currentTime = lastTime
+            val stepDelta = PointF(delta.x / steps, delta.y / steps)
+            (1..steps).forEach { _ ->
+                sleep(stepTimeMs)
+                currentTime += stepTimeMs
+                swipes.forEach { swipe ->
+                    // Sending the move events as not "sync". Otherwise the method waits for them
+                    // to be displatched. As here we're sending many that are supposed to happen at
+                    // the same time, we don't want the method to
+                    // wait after each single injection.
+                    swipe.moveBy(stepDelta, currentTime, sync = false)
+                }
+            }
+            assertThat(currentTime).isEqualTo(startTime + stepTimeMs * steps)
+            lastTime = currentTime
+            return this
+        }
+
+        /** Moves pointers up, finishing the swipe. Further calls will result in an exception. */
+        fun release() {
+            swipes.forEach { it.release(sync = false) }
+        }
+    }
+
+    private fun log(s: String) = Log.d("BetterSwipe", s)
+}
+
+private fun getMotionEvent(
+    downTime: Long,
+    eventTime: Long,
+    action: Int,
+    p: PointF,
+    pointerId: Int,
+): MotionEvent {
+    val properties =
+        MotionEvent.PointerProperties().apply {
+            id = pointerId
+            toolType = TOOL_TYPE_FINGER
+        }
+    val coordinates =
+        MotionEvent.PointerCoords().apply {
+            pressure = 1f
+            size = 1f
+            x = p.x
+            y = p.y
+        }
+    return MotionEvent.obtain(
+        /* downTime= */ downTime,
+        /* eventTime= */ eventTime,
+        /* action= */ action,
+        /* pointerCount= */ 1,
+        /* pointerProperties= */ arrayOf(properties),
+        /* pointerCoords= */ arrayOf(coordinates),
+        /* metaState= */ 0,
+        /* buttonState= */ 0,
+        /* xPrecision= */ 1.0f,
+        /* yPrecision= */ 1.0f,
+        /* deviceId= */ 0,
+        /* edgeFlags= */ 0,
+        /* source= */ InputDevice.SOURCE_TOUCHSCREEN,
+        /* flags= */ 0
+    )
+}
+
+private fun PointF.lerp(amount: Float, b: PointF) =
+    PointF(lerp(x, b.x, amount), lerp(y, b.y, amount))
+
+private fun lerp(start: Float, stop: Float, amount: Float): Float = start + (stop - start) * amount
+
+private fun calculateStepTime(displayId: Int = DEFAULT_DISPLAY): Duration {
+    return getTimeBetweenFrames(displayId).dividedBy(2)
+}
+
+private fun getTimeBetweenFrames(displayId: Int): Duration {
+    return trace("getMillisBetweenFrames") {
+        val displayManager =
+            context.getSystemService(DisplayManager::class.java)
+                ?: error("Couldn't get DisplayManager")
+        val display = displayManager.getDisplay(displayId)
+        val framesPerSecond = display.refreshRate // Frames per second
+        val millisBetweenFrames = 1000 / framesPerSecond
+        Duration.ofMillis(millisBetweenFrames.toLong())
+    }
+}
+
+/**
+ * Interpolator for a fling-like gesture that may leave the surface moving by inertia. Don't use it
+ * to drag objects to a precisely specified position.
+ */
+val FLING_GESTURE_INTERPOLATOR = LinearInterpolator()
+
+/** Interpolator for a precise drag-like gesture not triggering inertia. */
+val PRECISE_GESTURE_INTERPOLATOR = DecelerateInterpolator()
+
+private const val INJECT_EVENT_TIMEOUT_MILLIS = 10_000L
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt
new file mode 100644
index 000000000..343f8266e
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DeviceHelpers.kt
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.uiautomatorhelpers
+
+import android.animation.TimeInterpolator
+import android.app.Instrumentation
+import android.content.Context
+import android.graphics.PointF
+import android.os.Bundle
+import android.os.SystemClock.uptimeMillis
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.platform.uiautomatorhelpers.WaitUtils.ensureThat
+import android.platform.uiautomatorhelpers.WaitUtils.waitFor
+import android.platform.uiautomatorhelpers.WaitUtils.waitForNullable
+import android.platform.uiautomatorhelpers.WaitUtils.waitForPossibleEmpty
+import android.platform.uiautomatorhelpers.WaitUtils.waitForValueToSettle
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.UiDevice
+import androidx.test.uiautomator.UiObject2
+import java.io.IOException
+import java.time.Duration
+
+private const val TAG = "DeviceHelpers"
+
+object DeviceHelpers {
+    private val SHORT_WAIT = Duration.ofMillis(1500)
+    private val LONG_WAIT = Duration.ofSeconds(10)
+    private val DOUBLE_TAP_INTERVAL = Duration.ofMillis(100)
+
+    private val instrumentationRegistry = InstrumentationRegistry.getInstrumentation()
+
+    @JvmStatic
+    val uiDevice: UiDevice
+        get() = UiDevice.getInstance(instrumentationRegistry)
+
+    @JvmStatic
+    val context: Context
+        get() = instrumentationRegistry.targetContext
+
+    /**
+     * Waits for an object to be visible and returns it.
+     *
+     * Throws an error with message provided by [errorProvider] if the object is not found.
+     */
+    @Deprecated(
+        "Use [DeviceHelpers.waitForObj] instead.",
+        ReplaceWith("DeviceHelpers.waitForObj(selector, timeout, errorProvider)"),
+    )
+    fun UiDevice.waitForObj(
+        selector: BySelector,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: () -> String = { "Object $selector not found" },
+    ): UiObject2 = DeviceHelpers.waitForObj(selector, timeout, errorProvider)
+
+    /**
+     * Waits for an object to be visible and returns it.
+     *
+     * Throws an error with message provided by [errorProvider] if the object is not found.
+     */
+    @JvmOverloads
+    @JvmStatic
+    fun waitForObj(
+        selector: BySelector,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: () -> String = { "Object $selector not found" },
+    ): UiObject2 =
+        waitFor("$selector object", timeout, errorProvider) { uiDevice.findObject(selector) }
+
+    /**
+     * Waits for an object that satisfies on the many possible [selectors] and returns it along with
+     * the matching selector.
+     *
+     * Throws an error with message provided by [errorProvider] if the object is not found.
+     */
+    fun waitForFirstObj(
+        vararg selectors: BySelector,
+        timeout: Duration = SHORT_WAIT,
+        errorProvider: () -> String = { "No object found for any $selectors" },
+    ): Pair<UiObject2, BySelector> {
+        return waitFor("$selectors objects", timeout, errorProvider) {
+                selectors.firstNotNullOfOrNull { selector ->
+                    uiDevice.findObject(selector)?.let {
+                        it to selector
+                    }
+                }
+            }
+    }
+
+    /**
+     * Waits for an object to be visible and returns it.
+     *
+     * Throws an error with message provided by [errorProvider] if the object is not found.
+     */
+    fun UiObject2.waitForObj(
+        selector: BySelector,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: () -> String = { "Object $selector not found" },
+    ): UiObject2 = waitFor("$selector object", timeout, errorProvider) { findObject(selector) }
+
+    /**
+     * Waits for an object that satisfies on the many possible [selectors] and returns it along with
+     * the matching selector.
+     *
+     * Throws an error with message provided by [errorProvider] if the object is not found.
+     */
+    fun UiObject2.waitForFirstObj(
+        vararg selectors: BySelector,
+        timeout: Duration = SHORT_WAIT,
+        errorProvider: () -> String = { "No object found for any $selectors" },
+    ): Pair<UiObject2, BySelector> {
+        return waitFor("$selectors objects", timeout, errorProvider) {
+            selectors.firstNotNullOfOrNull { selector ->
+                findObject(selector)?.let {
+                    it to selector
+                }
+            }
+        }
+    }
+
+    /**
+     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
+     */
+    @Deprecated(
+        "Use [DeviceHelpers.waitForNullableObj] instead.",
+        ReplaceWith("DeviceHelpers.waitForNullableObj(selector, timeout)"),
+    )
+    fun UiDevice.waitForNullableObj(
+        selector: BySelector,
+        timeout: Duration = SHORT_WAIT,
+    ): UiObject2? = DeviceHelpers.waitForNullableObj(selector, timeout)
+
+    /**
+     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
+     */
+    fun waitForNullableObj(selector: BySelector, timeout: Duration = SHORT_WAIT): UiObject2? =
+        waitForNullable("nullable $selector objects", timeout) { uiDevice.findObject(selector) }
+
+    /**
+     * Waits for an object to be visible and returns it. Returns `null` if the object is not found.
+     */
+    fun UiObject2.waitForNullableObj(
+        selector: BySelector,
+        timeout: Duration = SHORT_WAIT,
+    ): UiObject2? = waitForNullable("nullable $selector objects", timeout) { findObject(selector) }
+
+    /**
+     * Waits for objects matched by [selector] to be visible and returns them. Returns `null` if no
+     * objects are found
+     */
+    @Deprecated(
+        "Use DeviceHelpers.waitForPossibleEmpty",
+        ReplaceWith(
+            "waitForPossibleEmpty(selector, timeout)",
+            "android.platform.uiautomatorhelpers.DeviceHelpers.waitForPossibleEmpty",
+        ),
+    )
+    fun waitForNullableObjects(
+        selector: BySelector,
+        timeout: Duration = SHORT_WAIT,
+    ): List<UiObject2>? = waitForPossibleEmpty(selector, timeout)
+
+    /**
+     * Waits for objects matched by selector to be visible. Returns an empty list when none is
+     * visible.
+     */
+    fun waitForPossibleEmpty(
+        selector: BySelector,
+        timeout: Duration = SHORT_WAIT,
+    ): List<UiObject2> =
+        waitForPossibleEmpty("$selector objects", timeout) { uiDevice.findObjects(selector) }
+
+    /**
+     * Waits for objects matched by [selector] to be visible and returns them. Returns `null` if no
+     * objects are found
+     */
+    @Deprecated(
+        "Use DeviceHelpers.waitForNullableObjects",
+        ReplaceWith("DeviceHelpers.waitForNullableObjects(selector, timeout)"),
+    )
+    fun UiDevice.waitForNullableObjects(
+        selector: BySelector,
+        timeout: Duration = SHORT_WAIT,
+    ): List<UiObject2>? = DeviceHelpers.waitForNullableObjects(selector, timeout)
+
+    /** Returns [true] when the [selector] is visible. */
+    fun hasObject(selector: BySelector): Boolean =
+        trace("Checking if device has $selector") { uiDevice.hasObject(selector) }
+
+    /** Finds an object with this selector and clicks on it. */
+    fun BySelector.click() {
+        trace("Clicking $this") { waitForObj(this).click() }
+    }
+
+    /**
+     * Asserts visibility of a [selector], waiting for [timeout] until visibility matches the
+     * expected.
+     *
+     * If [container] is provided, the object is searched only inside of it.
+     */
+    @JvmOverloads
+    @JvmStatic
+    @Deprecated(
+        "Use DeviceHelpers.assertVisibility directly",
+        ReplaceWith("DeviceHelpers.assertVisibility(selector, visible, timeout, errorProvider)"),
+    )
+    fun UiDevice.assertVisibility(
+        selector: BySelector,
+        visible: Boolean = true,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: (() -> String)? = null,
+    ) {
+        DeviceHelpers.assertVisibility(selector, visible, timeout, errorProvider)
+    }
+
+    /**
+     * Asserts visibility of a [selector], waiting for [timeout] until visibility matches the
+     * expected.
+     *
+     * If [container] is provided, the object is searched only inside of it.
+     */
+    @JvmOverloads
+    @JvmStatic
+    fun assertVisibility(
+        selector: BySelector,
+        visible: Boolean = true,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: (() -> String)? = null,
+    ) {
+        ensureThat("$selector is ${visible.asVisibilityBoolean()}", timeout, errorProvider) {
+            uiDevice.hasObject(selector) == visible
+        }
+    }
+
+    private fun Boolean.asVisibilityBoolean(): String =
+        when (this) {
+            true -> "visible"
+            false -> "invisible"
+        }
+
+    /**
+     * Asserts visibility of a [selector] inside this [UiObject2], waiting for [timeout] until
+     * visibility matches the expected.
+     */
+    fun UiObject2.assertVisibility(
+        selector: BySelector,
+        visible: Boolean,
+        timeout: Duration = LONG_WAIT,
+        errorProvider: (() -> String)? = null,
+    ) {
+        ensureThat(
+            "$selector is ${visible.asVisibilityBoolean()} inside $this",
+            timeout,
+            errorProvider,
+        ) {
+            hasObject(selector) == visible
+        }
+    }
+
+    /** Asserts that a this selector is visible. Throws otherwise. */
+    fun BySelector.assertVisible(
+        timeout: Duration = LONG_WAIT,
+        errorProvider: (() -> String)? = null,
+    ) {
+        uiDevice.assertVisibility(
+            selector = this,
+            visible = true,
+            timeout = timeout,
+            errorProvider = errorProvider,
+        )
+    }
+
+    /** Asserts that a this selector is invisible. Throws otherwise. */
+    @JvmStatic
+    @JvmOverloads
+    fun BySelector.assertInvisible(
+        timeout: Duration = LONG_WAIT,
+        errorProvider: (() -> String)? = null,
+    ) {
+        uiDevice.assertVisibility(
+            selector = this,
+            visible = false,
+            timeout = timeout,
+            errorProvider = errorProvider,
+        )
+    }
+
+    /**
+     * Executes a shell command on the device.
+     *
+     * Adds some logging. Throws [RuntimeException] In case of failures.
+     */
+    @Deprecated("Use [DeviceHelpers.shell] directly", ReplaceWith("DeviceHelpers.shell(command)"))
+    @JvmStatic
+    fun UiDevice.shell(command: String): String = DeviceHelpers.shell(command)
+
+    /**
+     * Executes a shell command on the device, and return its output one it finishes.
+     *
+     * Adds some logging to [UiDevice.executeShellCommand]. Throws [RuntimeException] In case of
+     * failures. Blocks until the command returns.
+     *
+     * @param command Shell command to execute
+     * @return Standard output of the command.
+     */
+    @JvmStatic
+    fun shell(command: String): String {
+        trace("Executing shell command: $command") {
+            Log.d(TAG, "Executing Shell Command: $command at ${uptimeMillis()}ms")
+            return try {
+                uiDevice.executeShellCommand(command)
+            } catch (e: IOException) {
+                Log.e(TAG, "IOException Occurred.", e)
+                throw RuntimeException(e)
+            }
+        }
+    }
+
+    /** Perform double tap at specified x and y position */
+    @JvmStatic
+    fun UiDevice.doubleTapAt(x: Int, y: Int) {
+        click(x, y)
+        Thread.sleep(DOUBLE_TAP_INTERVAL.toMillis())
+        click(x, y)
+    }
+
+    /**
+     * Aims at replacing [UiDevice.swipe].
+     *
+     * This should be used instead of [UiDevice.swipe] as it causes less flakiness. See
+     * [BetterSwipe].
+     */
+    @JvmStatic
+    @Deprecated(
+        "Use DeviceHelpers.betterSwipe directly",
+        ReplaceWith("DeviceHelpers.betterSwipe(startX, startY, endX, endY, interpolator)"),
+    )
+    fun UiDevice.betterSwipe(
+        startX: Int,
+        startY: Int,
+        endX: Int,
+        endY: Int,
+        interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
+    ) {
+        DeviceHelpers.betterSwipe(startX, startY, endX, endY, interpolator)
+    }
+
+    /**
+     * Aims at replacing [UiDevice.swipe].
+     *
+     * This should be used instead of [UiDevice.swipe] as it causes less flakiness. See
+     * [BetterSwipe].
+     */
+    @JvmStatic
+    fun betterSwipe(
+        startX: Int,
+        startY: Int,
+        endX: Int,
+        endY: Int,
+        interpolator: TimeInterpolator = FLING_GESTURE_INTERPOLATOR,
+    ) {
+        trace("Swiping ($startX,$startY) -> ($endX,$endY)") {
+            BetterSwipe.from(PointF(startX.toFloat(), startY.toFloat()))
+                .to(PointF(endX.toFloat(), endY.toFloat()), interpolator = interpolator)
+                .release()
+        }
+    }
+
+    /** [message] will be visible to the terminal when using `am instrument`. */
+    fun printInstrumentationStatus(tag: String, message: String) {
+        val result =
+            Bundle().apply {
+                putString(Instrumentation.REPORT_KEY_STREAMRESULT, "[$tag]: $message")
+            }
+        instrumentationRegistry.sendStatus(/* resultCode= */ 0, result)
+    }
+
+    /**
+     * Returns whether the screen is on.
+     *
+     * As this uses [waitForValueToSettle], it is resilient to fast screen on/off happening.
+     */
+    @JvmStatic
+    val UiDevice.isScreenOnSettled: Boolean
+        get() = waitForValueToSettle("Screen on") { isScreenOn }
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DurationUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DurationUtils.kt
new file mode 100644
index 000000000..b4f40883c
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/DurationUtils.kt
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.os.Build
+import java.time.Duration
+
+private const val CUTTLEFISH = "cutf_cvm"
+private const val CUTTLEFISH_FACTOR = 5L
+
+/** Platform-dependent duration utils (specifically targeting Cuttlefish)
+ *  For physical (non-emulator) devices, the timeout is unchanged,
+ *  the if the Build.HARDWARE is Cuttlefish, we increase the factor by 5.
+ */
+object DurationUtils {
+
+    /**
+     * For non-cuttlefish platforms, leave the timeout unchanged, otherwise
+     * increase the delay to compensate for slower performance.
+     */
+    fun Duration.platformAdjust() =
+        if (Build.HARDWARE == CUTTLEFISH)
+	    this.multipliedBy(CUTTLEFISH_FACTOR)
+        else
+	    this
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/ShellPrivilege.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/ShellPrivilege.kt
new file mode 100644
index 000000000..60cdbc3be
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/ShellPrivilege.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.content.pm.PackageManager
+import androidx.test.platform.app.InstrumentationRegistry
+
+/**
+ * Adopt shell permissions for the target context.
+ *
+ * @param[permissions] the permission to adopt. Adopt all available permission is it's empty.
+ */
+class ShellPrivilege(vararg permissions: String) : AutoCloseable {
+
+    private val instrumentation = InstrumentationRegistry.getInstrumentation()
+    private val targetContext = instrumentation.targetContext
+    private val uiAutomation = instrumentation.uiAutomation
+    private var permissionsGranted = false
+
+    init {
+        permissionsGranted = grantMissingPermissions(*permissions)
+    }
+
+    /**
+     * @return[Boolean] True is there are any missing permission and we've successfully granted all
+     * of them.
+     */
+    private fun grantMissingPermissions(vararg permissions: String): Boolean {
+        if (permissions.isEmpty()) {
+            uiAutomation.adoptShellPermissionIdentity()
+            return true
+        }
+        val missingPermissions = permissions.filter { !it.isGranted() }.toTypedArray()
+        if (missingPermissions.isEmpty()) return false
+        uiAutomation.adoptShellPermissionIdentity(*missingPermissions)
+        return true
+    }
+
+    override fun close() {
+        if (permissionsGranted) instrumentation.uiAutomation.dropShellPermissionIdentity()
+        permissionsGranted = false
+    }
+
+    private fun String.isGranted(): Boolean =
+        targetContext.checkCallingPermission(this) == PackageManager.PERMISSION_GRANTED
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt
new file mode 100644
index 000000000..48f91cde7
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/SwipeUtils.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.graphics.Point
+import android.graphics.Rect
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.Direction.DOWN
+import androidx.test.uiautomator.Direction.LEFT
+import androidx.test.uiautomator.Direction.RIGHT
+import androidx.test.uiautomator.Direction.UP
+
+/** Common utils to perform swipes. */
+internal object SwipeUtils {
+
+    /**
+     * Calculates start and end point taking into consideration first [marginPx], then [percent].
+     */
+    fun calculateStartEndPoint(
+        rawBound: Rect,
+        direction: Direction,
+        percent: Float = 1.0f,
+        marginPx: Int = 0
+    ): Pair<Point, Point> {
+        val bounds = Rect(rawBound)
+        bounds.inset(marginPx, marginPx)
+        val centerX = bounds.centerX()
+        val centerY = bounds.centerY()
+        return when (direction) {
+            LEFT -> {
+                Point(bounds.right, centerY) to
+                    Point(bounds.right - (bounds.width() * percent).toInt(), centerY)
+            }
+            RIGHT -> {
+                Point(bounds.left, centerY) to
+                    Point(bounds.left + (bounds.width() * percent).toInt(), centerY)
+            }
+            UP -> {
+                Point(centerX, bounds.bottom) to
+                    Point(centerX, bounds.bottom - (bounds.height() * percent).toInt())
+            }
+            DOWN -> {
+                Point(centerX, bounds.top) to
+                    Point(centerX, bounds.top + (bounds.height() * percent).toInt())
+            }
+        }
+    }
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/TracingUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/TracingUtils.kt
new file mode 100644
index 000000000..cb8639a82
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/TracingUtils.kt
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.os.Trace
+import android.util.Log
+
+/** Tracing utils until androidx tracing library is updated in the tree. */
+@Deprecated("Use com.android.app.tracing utils instead.")
+object TracingUtils {
+
+    // from frameworks/base/core/java/android/os/Trace.java MAX_SECTION_NAME_LEN.
+    private const val MAX_TRACE_NAME_LEN = 127
+    private const val TAG = "TracingUtils"
+
+    @Deprecated(
+        "Use com.android.app.tracing.traceSection instead",
+        replaceWith = ReplaceWith("com.android.app.tracing.traceSection(sectionName, block)")
+    )
+    inline fun <T> trace(sectionName: String, block: () -> T): T {
+        Trace.beginSection(sectionName.shortenedIfNeeded())
+        try {
+            return block()
+        } finally {
+            Trace.endSection()
+        }
+    }
+
+    /** Shortens the section name if it's too long. */
+    fun beginSectionSafe(sectionName: String) {
+        Trace.beginSection(sectionName.shortenedIfNeeded())
+    }
+
+    /** Shorten the length of a string to make it less than the limit for atraces. */
+    fun String.shortenedIfNeeded(): String =
+        if (length > MAX_TRACE_NAME_LEN) {
+            Log.w(TAG, "Section name too long: \"$this\" (len=$length, max=$MAX_TRACE_NAME_LEN)")
+            substring(0, MAX_TRACE_NAME_LEN)
+        } else this
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/UiObjectUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/UiObjectUtils.kt
new file mode 100644
index 000000000..1fa3e8439
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/UiObjectUtils.kt
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.uiautomatorhelpers
+
+import android.graphics.PointF
+import android.graphics.Rect
+import android.platform.uiautomatorhelpers.DeviceHelpers.uiDevice
+import android.platform.uiautomatorhelpers.WaitUtils.waitForValueToSettle
+import androidx.test.uiautomator.BySelector
+import androidx.test.uiautomator.Direction
+import androidx.test.uiautomator.UiObject2
+import com.google.common.truth.Truth.assertWithMessage
+
+/** Checks the view is in the vertical (Y) centre of the screen (+- 1 px). */
+fun UiObject2.assertInVerticalCentre() {
+    assertWithMessage("${this.resourceName} should be vertically (Y) centred (+- 1px)")
+        .that(this.stableBounds.centerY())
+        .isIn(uiDevice.displayHeight / 2 - 1..uiDevice.displayHeight / 2 + 1)
+}
+
+/** Checks the view is in the horizontal (X) centre of the screen (+- 1 px). */
+fun UiObject2.assertInHorizontalCentre() {
+    assertWithMessage("${this.resourceName} should be horizontally (X) centred (+- 1px)")
+        .that(this.stableBounds.centerX())
+        .isIn(uiDevice.displayWidth / 2 - 1..uiDevice.displayWidth / 2 + 1)
+}
+
+/**
+ * Checks if centre of the view is on the bottom side by checking y centre is in the bottom half of
+ * the screen vertically.
+ */
+fun UiObject2.assertCentreOnBottomSide() {
+    assertWithMessage("${this.resourceName} centre should be on the bottom side")
+        .that(this.stableBounds.centerY() > uiDevice.displayHeight / 2)
+        .isTrue()
+}
+
+/**
+ * Checks if centre of the view is on the top side by checking y centre is in the top half of the
+ * screen vertically.
+ */
+fun UiObject2.assertCentreOnTopSide() {
+    assertWithMessage("${this.resourceName} centre should be on the top side")
+        .that(this.stableBounds.centerY() < uiDevice.displayHeight / 2)
+        .isTrue()
+}
+
+/**
+ * Checks if top of the view is on the bottom side by checking top bound is in the bottom half of
+ * the screen vertically.
+ */
+fun UiObject2.assertTopOnBottomSide() {
+    assertWithMessage("${this.resourceName} top should be on the bottom side")
+        .that(this.stableBounds.top > uiDevice.displayHeight / 2)
+        .isTrue()
+}
+
+/**
+ * Checks if top of the view is on the top side by checking top bound is in the top half of the
+ * screen vertically.
+ */
+fun UiObject2.assertTopOnTopSide() {
+    assertWithMessage("${this.resourceName} top should be on the top side")
+        .that(this.stableBounds.top < uiDevice.displayHeight / 2)
+        .isTrue()
+}
+
+/** Checks if view horizontal (X) centre is on the right side */
+fun UiObject2.assertCenterOnTheRightSide() {
+    assertWithMessage("${this.resourceName} center should be on the right side")
+        .that(this.stableBounds.centerX() > uiDevice.displayWidth / 2)
+        .isTrue()
+}
+
+/** Checks if view horizontal (X) centre is on the left side */
+fun UiObject2.assertCenterOnTheLeftSide() {
+    assertWithMessage("${this.resourceName} center should be on the left side")
+        .that(this.stableBounds.centerX() < uiDevice.displayWidth / 2)
+        .isTrue()
+}
+
+/**
+ * Checks if view is on the right side by checking left bound is in the middle of the screen or in
+ * the right half of the screen horizontally.
+ */
+fun UiObject2.assertOnTheRightSide() {
+    assertWithMessage("${this.resourceName} left should be on the right side")
+        .that(this.stableBounds.left >= uiDevice.displayWidth / 2)
+        .isTrue()
+}
+
+/**
+ * Checks if view is on the left side by checking right bound is in the middle of the screen or in
+ * the left half of the screen horizontally.
+ */
+fun UiObject2.assertOnTheLeftSide() {
+    assertWithMessage("${this.resourceName} right should be on the left side")
+        .that(this.stableBounds.right <= uiDevice.displayWidth / 2)
+        .isTrue()
+}
+
+/**
+ * Settled visible bounds of the object.
+ *
+ * Before returning, ensures visible bounds stay the same for a few seconds or fails. Useful to get
+ * bounds of objects that might be animating.
+ */
+val UiObject2.stableBounds: Rect
+    get() = waitForValueToSettle("${this.resourceName} bounds") { visibleBounds }
+
+private const val MAX_FIND_ELEMENT_ATTEMPT = 15
+
+/**
+ * Scrolls [this] in [direction] ([Direction.DOWN] by default) until finding [selector]. It returns
+ * the first object that matches [selector] or `null` if it's not found after
+ * [MAX_FIND_ELEMENT_ATTEMPT] scrolls. Caller can also provide additional [condition] to provide
+ * more complex checking on the found object.
+ *
+ * Uses [BetterSwipe] to perform the scroll.
+ */
+@JvmOverloads
+fun UiObject2.scrollUntilFound(
+    selector: BySelector,
+    direction: Direction = Direction.DOWN,
+    condition: (UiObject2) -> Boolean = { true }
+): UiObject2? {
+    val (from, to) = getPointsToScroll(direction)
+    (0 until MAX_FIND_ELEMENT_ATTEMPT).forEach { _ ->
+        val f = findObject(selector)
+        if (f?.let { condition(it) } == true) return f
+        BetterSwipe.from(from).to(to, interpolator = FLING_GESTURE_INTERPOLATOR).release()
+    }
+    return null
+}
+
+private data class Vector2F(val from: PointF, val to: PointF)
+
+private fun UiObject2.getPointsToScroll(direction: Direction): Vector2F {
+    return when (direction) {
+        Direction.DOWN -> {
+            Vector2F(
+                PointF(visibleBounds.exactCenterX(), visibleBounds.bottom.toFloat() - 1f),
+                PointF(visibleBounds.exactCenterX(), visibleBounds.top.toFloat() + 1f)
+            )
+        }
+        Direction.UP -> {
+            Vector2F(
+                PointF(visibleBounds.exactCenterX(), visibleBounds.top.toFloat() + 1f),
+                PointF(visibleBounds.exactCenterX(), visibleBounds.bottom.toFloat() - 1f)
+            )
+        }
+        Direction.LEFT -> {
+            Vector2F(
+                PointF(visibleBounds.left.toFloat() + 1f, visibleBounds.exactCenterY()),
+                PointF(visibleBounds.right.toFloat() - 1f, visibleBounds.exactCenterY())
+            )
+        }
+        Direction.RIGHT -> {
+            Vector2F(
+                PointF(visibleBounds.right.toFloat() - 1f, visibleBounds.exactCenterY()),
+                PointF(visibleBounds.left.toFloat() + 1f, visibleBounds.exactCenterY())
+            )
+        }
+    }
+}
diff --git a/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/WaitUtils.kt b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/WaitUtils.kt
new file mode 100644
index 000000000..414045fa5
--- /dev/null
+++ b/libraries/uiautomator-helpers/src/android/platform/uiautomatorhelpers/WaitUtils.kt
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package android.platform.uiautomatorhelpers
+
+import android.os.SystemClock.sleep
+import android.os.SystemClock.uptimeMillis
+import android.os.Trace
+import android.platform.uiautomatorhelpers.TracingUtils.trace
+import android.platform.uiautomatorhelpers.WaitUtils.LoggerImpl.Companion.withEventualLogging
+import android.util.Log
+import androidx.test.uiautomator.StaleObjectException
+import java.io.Closeable
+import java.time.Duration
+import java.time.Instant.now
+
+sealed interface WaitResult {
+    data class WaitThrown(val thrown: Throwable?) : WaitResult
+    data object WaitSuccess : WaitResult
+    data object WaitFailure : WaitResult
+}
+
+data class WaitReport(val result: WaitResult, val iterations: Int)
+
+/**
+ * Collection of utilities to ensure a certain conditions is met.
+ *
+ * Those are meant to make tests more understandable from perfetto traces, and less flaky.
+ */
+object WaitUtils {
+    private val DEFAULT_DEADLINE = Duration.ofSeconds(10)
+    private val POLLING_WAIT = Duration.ofMillis(100)
+    private val DEFAULT_SETTLE_TIME = Duration.ofSeconds(3)
+    private const val TAG = "WaitUtils"
+    private const val VERBOSE = true
+
+    /**
+     * Ensures that [condition] succeeds within [timeout], or fails with [errorProvider] message.
+     *
+     * This also logs with atrace each iteration, and its entire execution. Those traces are then
+     * visible in perfetto. Note that logs are output only after the end of the method, all
+     * together.
+     *
+     * Example of usage:
+     * ```
+     * ensureThat("screen is on") { uiDevice.isScreenOn }
+     * ```
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun ensureThat(
+        description: String? = null,
+        timeout: Duration = DEFAULT_DEADLINE,
+        errorProvider: (() -> String)? = null,
+        ignoreFailure: Boolean = false,
+        ignoreException: Boolean = false,
+        condition: () -> Boolean,
+    ) {
+        val errorProvider =
+            errorProvider
+                ?: { "Error ensuring that \"$description\" within ${timeout.toMillis()}ms" }
+        waitToBecomeTrue(description, timeout, condition).run {
+            when (result) {
+                WaitResult.WaitSuccess -> return
+                WaitResult.WaitFailure -> {
+                    if (ignoreFailure) {
+                        Log.w(TAG, "Ignoring ensureThat failure: ${errorProvider()}")
+                    } else {
+                        throw FailedEnsureException(errorProvider())
+                    }
+                }
+                is WaitResult.WaitThrown -> {
+                    if (!ignoreException) {
+                        throw RuntimeException("[#$iterations] iteration failed.", result.thrown)
+                    } else {
+                        return
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Wait until [timeout] for [condition] to become true, and then return a [WaitReport] with the
+     * result.
+     *
+     * This can be a useful replacement for [ensureThat] in situations where you want to wait for
+     * the condition to become true, but want a chance to recover if it does not.
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun waitToBecomeTrue(
+        description: String? = null,
+        timeout: Duration = DEFAULT_DEADLINE,
+        condition: () -> Boolean,
+    ): WaitReport {
+        val traceName =
+            if (description != null) {
+                "Ensuring $description"
+            } else {
+                "ensure"
+            }
+        var i = 1
+        trace(traceName) {
+            val startTime = uptimeMillis()
+            val timeoutMs = timeout.toMillis()
+            Log.d(TAG, "Starting $traceName")
+            withEventualLogging(logTimeDelta = true) {
+                log(traceName)
+                while (uptimeMillis() < startTime + timeoutMs) {
+                    trace("iteration $i") {
+                        try {
+                            if (condition()) {
+                                log("[#$i] Condition true")
+                                return WaitReport(WaitResult.WaitSuccess, i)
+                            }
+                        } catch (t: Throwable) {
+                            log("[#$i] Condition failing with exception")
+                            return WaitReport(WaitResult.WaitThrown(t), i)
+                        }
+
+                        log("[#$i] Condition false, might retry.")
+                        sleep(POLLING_WAIT.toMillis())
+                        i++
+                    }
+                }
+                log("[#$i] Condition has always been false. Failing.")
+                return WaitReport(WaitResult.WaitFailure, i)
+            }
+        }
+    }
+
+    /**
+     * Same as [waitForNullableValueToSettle], but assumes that [supplier] return value is non-null.
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun <T> waitForValueToSettle(
+        description: String? = null,
+        minimumSettleTime: Duration = DEFAULT_SETTLE_TIME,
+        timeout: Duration = DEFAULT_DEADLINE,
+        errorProvider: () -> String =
+            defaultWaitForSettleError(minimumSettleTime, description, timeout),
+        supplier: () -> T,
+    ): T {
+        return waitForNullableValueToSettle(
+            description,
+            minimumSettleTime,
+            timeout,
+            errorProvider,
+            supplier
+        )
+            ?: error(errorProvider())
+    }
+
+    /**
+     * Waits for [supplier] to return the same value for at least [minimumSettleTime].
+     *
+     * If the value changes, the timer gets restarted. Fails when reaching [timeoutMs]. The minimum
+     * running time of this method is [minimumSettleTime], in case the value is stable since the
+     * beginning.
+     *
+     * Fails if [supplier] throws an exception.
+     *
+     * Outputs atraces visible with perfetto.
+     *
+     * Example of usage:
+     * ```
+     * val screenOn = waitForValueToSettle("Screen on") { uiDevice.isScreenOn }
+     * ```
+     *
+     * Note: Prefer using [waitForValueToSettle] when [supplier] doesn't return a null value.
+     *
+     * @return the settled value. Throws if it doesn't settle.
+     */
+    @JvmStatic
+    @JvmOverloads
+    fun <T> waitForNullableValueToSettle(
+        description: String? = null,
+        minimumSettleTime: Duration = DEFAULT_SETTLE_TIME,
+        timeout: Duration = DEFAULT_DEADLINE,
+        errorProvider: () -> String =
+            defaultWaitForSettleError(minimumSettleTime, description, timeout),
+        supplier: () -> T?,
+    ): T? {
+        val prefix =
+            if (description != null) {
+                "Waiting for \"$description\" to settle"
+            } else {
+                "waitForValueToSettle"
+            }
+        val traceName =
+            prefix +
+                " (settleTime=${minimumSettleTime.toMillis()}ms, deadline=${timeout.toMillis()}ms)"
+        trace(traceName) {
+            Log.d(TAG, "Starting $traceName")
+            withEventualLogging(logTimeDelta = true) {
+                log(traceName)
+
+                val startTime = now()
+                var settledSince = startTime
+                var previousValue: T? = null
+                var previousValueSet = false
+                while (now().isBefore(startTime + timeout)) {
+                    val newValue =
+                        try {
+                            supplier()
+                        } catch (t: Throwable) {
+                            if (previousValueSet) {
+                                Trace.endSection()
+                            }
+                            log("Supplier has thrown an exception")
+                            throw RuntimeException(t)
+                        }
+                    val currentTime = now()
+                    if (previousValue != newValue || !previousValueSet) {
+                        log("value changed to $newValue")
+                        settledSince = currentTime
+                        if (previousValueSet) {
+                            Trace.endSection()
+                        }
+                        TracingUtils.beginSectionSafe("New value: $newValue")
+                        previousValue = newValue
+                        previousValueSet = true
+                    } else if (now().isAfter(settledSince + minimumSettleTime)) {
+                        log("Got settled value. Returning \"$previousValue\"")
+                        Trace.endSection() // previousValue is guaranteed to be non-null.
+                        return previousValue
+                    }
+                    sleep(POLLING_WAIT.toMillis())
+                }
+                if (previousValueSet) {
+                    Trace.endSection()
+                }
+                error(errorProvider())
+            }
+        }
+    }
+
+    private fun defaultWaitForSettleError(
+        minimumSettleTime: Duration,
+        description: String?,
+        timeout: Duration
+    ): () -> String {
+        return {
+            "Error getting settled (${minimumSettleTime.toMillis()}) " +
+                "value for \"$description\" within ${timeout.toMillis()}."
+        }
+    }
+
+    /**
+     * Waits for [supplier] to return a non-null value within [timeout].
+     *
+     * Returns null after the timeout finished.
+     */
+    fun <T> waitForNullable(
+        description: String,
+        timeout: Duration = DEFAULT_DEADLINE,
+        checker: (T?) -> Boolean = { it != null },
+        supplier: () -> T?,
+    ): T? {
+        var result: T? = null
+
+        ensureThat("Waiting for \"$description\"", timeout, ignoreFailure = true) {
+            result = supplier()
+            checker(result)
+        }
+        return result
+    }
+
+    /** Wraps [waitForNullable] using the default checker, and allowing kotlin supplier syntax. */
+    fun <T> waitForNullable(
+        description: String,
+        timeout: Duration = DEFAULT_DEADLINE,
+        supplier: () -> T?,
+    ): T? = waitForNullable(description, timeout, checker = { it != null }, supplier)
+
+    /**
+     * Waits for [supplier] to return a not null and not empty list within [timeout].
+     *
+     * Returns the not-empty list as soon as it's received, or an empty list once reached the
+     * timeout.
+     */
+    fun <T> waitForPossibleEmpty(
+        description: String,
+        timeout: Duration = DEFAULT_DEADLINE,
+        supplier: () -> List<T>?
+    ): List<T> =
+        waitForNullable(description, timeout, { !it.isNullOrEmpty() }, supplier) ?: emptyList()
+
+    /**
+     * Waits for [supplier] to return a non-null value within [timeout].
+     *
+     * Throws an exception with [errorProvider] provided message if [supplier] failed to produce a
+     * non-null value within [timeout].
+     */
+    fun <T> waitFor(
+        description: String,
+        timeout: Duration = DEFAULT_DEADLINE,
+        errorProvider: () -> String = {
+            "Didn't get a non-null value for \"$description\" within ${timeout.toMillis()}ms"
+        },
+        supplier: () -> T?
+    ): T = waitForNullable(description, timeout, supplier) ?: error(errorProvider())
+
+    /**
+     * Retry a block of code [times] times, if it throws a StaleObjectException.
+     *
+     * This can be used to reduce flakiness in cases where waitForObj throws although the object
+     * does seem to be present.
+     */
+    fun <T> retryIfStale(description: String, times: Int, block: () -> T): T {
+        return trace("retryIfStale: $description") outerTrace@{
+            repeat(times) {
+                trace("attempt #$it") {
+                    try {
+                        return@outerTrace block()
+                    } catch (e: StaleObjectException) {
+                        Log.w(TAG, "Caught a StaleObjectException ($e). Retrying.")
+                    }
+                }
+            }
+            // Run the block once without catching
+            trace("final attempt") { block() }
+        }
+    }
+
+    /** Generic logging interface. */
+    private interface Logger {
+        fun log(s: String)
+    }
+
+    /** Logs all messages when closed. */
+    private class LoggerImpl private constructor(private val logTimeDelta: Boolean) :
+        Closeable, Logger {
+        private val logs = mutableListOf<String>()
+        private val startTime = uptimeMillis()
+
+        companion object {
+            /** Executes [block] and prints all logs at the end. */
+            inline fun <T> withEventualLogging(
+                logTimeDelta: Boolean = false,
+                block: Logger.() -> T
+            ): T = LoggerImpl(logTimeDelta).use { it.block() }
+        }
+
+        override fun log(s: String) {
+            logs += if (logTimeDelta) "+${uptimeMillis() - startTime}ms $s" else s
+        }
+
+        override fun close() {
+            if (VERBOSE) {
+                Log.d(TAG, logs.joinToString("\n"))
+            }
+        }
+    }
+}
+
+/** Exception thrown when [WaitUtils.ensureThat] fails. */
+class FailedEnsureException(message: String? = null) : IllegalStateException(message)
diff --git a/scripts/perf-setup/p24-setup.sh b/scripts/perf-setup/p24-setup.sh
new file mode 100755
index 000000000..d008cfb23
--- /dev/null
+++ b/scripts/perf-setup/p24-setup.sh
@@ -0,0 +1,60 @@
+#!/system/bin/sh
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Performance test setup for 2024 devices
+
+echo "Disabling Tskin thermal mitigation..."
+setprop persist.vendor.disable.thermal.control 1
+
+echo "Disabling TJ thermal mitigation..."
+setprop persist.vendor.disable.thermal.tj.control 1
+
+echo "Clearing cooling device states..."
+for i in /sys/devices/virtual/thermal/cooling_device*/user_vote; do echo 0 > "$i" 2>/dev/null; done
+for i in /sys/devices/virtual/thermal/cooling_device*/cur_state; do echo 0 > "$i" 2>/dev/null; done
+
+echo "Disabling powerhints..."
+setprop vendor.powerhal.init 0
+setprop ctl.restart vendor.power-hal-aidl
+
+# set max freq for all cores
+echo "Locking CPUs to the max freq..."
+for cpu_path in /sys/devices/system/cpu/cpu*[0-9]; do
+  local max_freq=`cat $cpu_path/cpufreq/cpuinfo_max_freq`
+  echo $max_freq > $cpu_path/cpufreq/scaling_max_freq
+  echo $max_freq > $cpu_path/cpufreq/scaling_min_freq
+
+  local cur_freq=`cat $cpu_path/cpufreq/cpuinfo_cur_freq`
+  echo "`basename $cpu_path` -> $cur_freq"
+done
+
+echo "Locking GPU to the max freq..."
+gpu_base_path="/sys/devices/platform/1f000000.mali"
+gpu_max_freq=`cat $gpu_base_path/max_freq`
+echo $gpu_max_freq > $gpu_base_path/scaling_max_freq
+echo $gpu_max_freq > $gpu_base_path/scaling_min_freq
+cat $gpu_base_path/cur_freq
+
+echo "Locking Buses to the max freq..."
+for path in /sys/class/devfreq/*{bci,mif,dsu,int}; do
+  local max_freq=`cat $path/max_freq`
+  echo $max_freq > $path/exynos_data/debug_scaling_devfreq_max
+  echo $max_freq > $path/exynos_data/debug_scaling_devfreq_min
+
+  local cur_freq=`cat $path/cur_freq`
+  echo "`basename $path` -> $cur_freq"
+done
+
diff --git a/tests/automotive/PREUPLOAD.cfg b/tests/automotive/PREUPLOAD.cfg
new file mode 100644
index 000000000..8c1e80ec6
--- /dev/null
+++ b/tests/automotive/PREUPLOAD.cfg
@@ -0,0 +1,11 @@
+[Builtin Hooks]
+bpfmt = true
+google_java_format = true
+
+[Tool Paths]
+google-java-format = ${REPO_ROOT}/prebuilts/tools/common/google-java-format/google-java-format
+google-java-format-diff = ${REPO_ROOT}/prebuilts/tools/common/google-java-format/google-java-format-diff.py
+
+[Hook Scripts]
+checkstyle_hook = ${REPO_ROOT}/prebuilts/checkstyle/checkstyle.py --sha ${PREUPLOAD_COMMIT}
+automotive_preupload_hook_script = ${REPO_ROOT}/platform_testing/tests/automotive/preupload_hook_script.py ${PREUPLOAD_FILES}
\ No newline at end of file
diff --git a/tests/automotive/functional/bluetoothmedia/Android.bp b/tests/automotive/functional/bluetoothmedia/Android.bp
new file mode 100644
index 000000000..3197cfe56
--- /dev/null
+++ b/tests/automotive/functional/bluetoothmedia/Android.bp
@@ -0,0 +1,34 @@
+// Copyright (C) 2023 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_aaos_framework",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "AndroidAutomotiveBluetoothMediaTests",
+    min_sdk_version: "24",
+    static_libs: [
+        "androidx.test.runner",
+        "androidx.test.rules",
+        "automotive-app-grid-helper",
+        "automotive-media-center-app-helper",
+        "automotive-utility-helper",
+        "app-helpers-auto-interfaces",
+        "platform-test-junit-rules",
+    ],
+    srcs: ["src/**/*.java"],
+    test_suites: ["catbox"],
+}
diff --git a/tests/automotive/functional/bluetoothmedia/AndroidManifest.xml b/tests/automotive/functional/bluetoothmedia/AndroidManifest.xml
new file mode 100644
index 000000000..683edeb02
--- /dev/null
+++ b/tests/automotive/functional/bluetoothmedia/AndroidManifest.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright 2021 The Android Open Source Project
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="android.platform.tests">
+  <uses-sdk android:minSdkVersion="23"
+      android:targetSdkVersion="24" />
+  <application>
+    <uses-library android:name="android.test.runner" />
+  </application>
+  <uses-permission android:name="android.permission.BLUETOOTH"/>
+  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+  <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-permission android:name="android.car.permission.CAR_CONTROL_AUDIO_VOLUME"/>
+  <uses-permission android:name="android.car.permission.CAR_CONTROL_AUDIO_SETTINGS"/>
+  <uses-permission android:name="android.car.permission.CAR_DRIVING_STATE"/>
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <instrumentation
+      android:name="androidx.test.runner.AndroidJUnitRunner"
+      android:targetPackage="android.platform.tests"
+      android:label="Android Automotive Bluetooth Media Tests" />
+</manifest>
\ No newline at end of file
diff --git a/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java b/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java
new file mode 100644
index 000000000..546b71ee4
--- /dev/null
+++ b/tests/automotive/functional/bluetoothmedia/src/android/platform/tests/BluetoothMediaTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.platform.tests;
+
+import static junit.framework.Assert.assertTrue;
+
+import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoAppGridHelper;
+import android.platform.helpers.IAutoMediaHelper;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class BluetoothMediaTest {
+    private HelperAccessor<IAutoAppGridHelper> mAppGridHelper;
+    private HelperAccessor<IAutoMediaHelper> mAutoMediaHelper;
+
+    public BluetoothMediaTest() throws Exception {
+        mAppGridHelper = new HelperAccessor<>(IAutoAppGridHelper.class);
+        mAutoMediaHelper = new HelperAccessor<>(IAutoMediaHelper.class);
+    }
+
+    @Before
+    public void openAppGrid() {
+        // Open the APP Grid
+        mAppGridHelper.get().open();
+    }
+
+    @After
+    public void goBackToHomeScreen() {
+        mAppGridHelper.get().goToHomePage();
+    }
+
+    @Test
+    public void testBluetoothMediaDefaultState() {
+        mAppGridHelper.get().openApp("Bluetooth Audio");
+        assertTrue(
+                "Bluetooth audio disconnected label is not present",
+                mAutoMediaHelper.get().isBluetoothAudioDisconnectedLabelVisible());
+        assertTrue(
+                "Connect to Bluetooth label is not present",
+                mAutoMediaHelper.get().isConnectToBluetoothLabelVisible());
+    }
+}
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
index 37ae67224..9921894d3 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/AddUserSettings.java
@@ -77,6 +77,7 @@ public class AddUserSettings {
         // verify new user is seen in list of users
         assertTrue(mMultiUserHelper.getUserByName(newUser.name) != null);
         // Verify new user is non-Admin
+        mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
         assertFalse("New user has Admin Access", mUsersHelper.get().isNewUserAnAdmin(newUser.name));
         // remove new user
         mMultiUserHelper.removeUser(newUser);
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
index cd4960855..bb533b653 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestNotAllowed.java
@@ -23,15 +23,11 @@ import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
-import android.platform.test.rules.ConditionalIgnore;
-import android.platform.test.rules.ConditionalIgnoreRule;
-import android.platform.test.rules.IgnoreOnPortrait;
 
 import androidx.test.runner.AndroidJUnit4;
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -40,7 +36,6 @@ import org.junit.runner.RunWith;
  */
 @RunWith(AndroidJUnit4.class)
 public class DeleteGuestNotAllowed {
-    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private static final String guestUser = MultiUserConstants.GUEST_NAME;
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
@@ -62,7 +57,6 @@ public class DeleteGuestNotAllowed {
     }
 
     @Test
-    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testDeleteGuestNotAllowed() throws Exception {
         // verify that guest user cannot be seen and deleted from list of profiles
         assertFalse(mUsersHelper.get().isUserPresent(guestUser));
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
index 0d3179d2b..b85168a8c 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/DeleteGuestSelfNotAllowed.java
@@ -20,21 +20,18 @@ import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 import android.content.pm.UserInfo;
+import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
-import android.platform.test.rules.ConditionalIgnore;
-import android.platform.test.rules.ConditionalIgnoreRule;
-import android.platform.test.rules.IgnoreOnPortrait;
 import android.util.Log;
 
 import androidx.test.runner.AndroidJUnit4;
 
 import org.junit.After;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -44,9 +41,10 @@ import org.junit.runner.RunWith;
  */
 @RunWith(AndroidJUnit4.class)
 public class DeleteGuestSelfNotAllowed {
-    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private static final String guestUser = MultiUserConstants.GUEST_NAME;
+    private static final String GUEST = AutomotiveConfigConstants.HOME_GUEST_BUTTON;
+    private static final String DRIVER = AutomotiveConfigConstants.HOME_DRIVER_BUTTON;
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
@@ -62,11 +60,10 @@ public class DeleteGuestSelfNotAllowed {
     }
 
     @Test
-    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testDeleteGuestNotAllowed() throws Exception {
         UserInfo previousUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to Guest and verify the user switch
-        mUsersHelper.get().switchUser(previousUser.name, guestUser);
+        mUsersHelper.get().switchUsingUserIcon(GUEST);
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         assertTrue(currentUser.name.equals(guestUser));
         boolean IsDeleteAllowed = true;
@@ -82,6 +79,7 @@ public class DeleteGuestSelfNotAllowed {
         }
         assertFalse(IsDeleteAllowed);
         // switch to initial user before terminating the test
-        mUsersHelper.get().switchUser(currentUser.name, previousUser.name);
+        mUsersHelper.get().switchUsingUserIcon(DRIVER);
+        assertTrue(mMultiUserHelper.getCurrentForegroundUserInfo().name.equals(previousUser.name));
     }
 }
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
index 0e0df24a4..2b5f63f89 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchToGuestFromNonAdmin.java
@@ -20,19 +20,16 @@ import static junit.framework.Assert.assertTrue;
 
 import android.content.pm.UserInfo;
 import android.os.SystemClock;
+import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.scenario.multiuser.MultiUserConstants;
-import android.platform.test.rules.ConditionalIgnore;
-import android.platform.test.rules.ConditionalIgnoreRule;
-import android.platform.test.rules.IgnoreOnPortrait;
 
 import androidx.test.runner.AndroidJUnit4;
 
 import org.junit.After;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -42,10 +39,10 @@ import org.junit.runner.RunWith;
  */
 @RunWith(AndroidJUnit4.class)
 public class SwitchToGuestFromNonAdmin {
-    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private static final String userName = MultiUserConstants.SECONDARY_USER_NAME;
     private static final String guestUser = MultiUserConstants.GUEST_NAME;
+    private static final String GUEST = AutomotiveConfigConstants.HOME_GUEST_BUTTON;
     private static final int WAIT_TIME = 10000;
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
@@ -63,7 +60,6 @@ public class SwitchToGuestFromNonAdmin {
     }
 
     @Test
-    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testSwitchToGuest() throws Exception {
         UserInfo initialUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // add new user
@@ -74,7 +70,7 @@ public class SwitchToGuestFromNonAdmin {
             mTargetUserId, MultiUserConstants.WAIT_FOR_IDLE_TIME_MS);
         UserInfo newUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to guest from new user
-        mUsersHelper.get().switchUser(newUser.name, guestUser);
+        mUsersHelper.get().switchUsingUserIcon(GUEST);
         // verify the user switch
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         assertTrue(currentUser.name.equals(guestUser));
diff --git a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
index 0f759d60e..8a024bf4e 100644
--- a/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
+++ b/tests/automotive/functional/multiuser/src/android/platform/tests/SwitchUserQuickSettings.java
@@ -19,19 +19,16 @@ package android.platform.tests;
 import static junit.framework.Assert.assertTrue;
 
 import android.content.pm.UserInfo;
+import android.platform.helpers.AutomotiveConfigConstants;
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
 import android.platform.scenario.multiuser.MultiUserConstants;
-import android.platform.test.rules.ConditionalIgnore;
-import android.platform.test.rules.ConditionalIgnoreRule;
-import android.platform.test.rules.IgnoreOnPortrait;
 
 import androidx.test.runner.AndroidJUnit4;
 
 import org.junit.After;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -41,9 +38,10 @@ import org.junit.runner.RunWith;
  */
 @RunWith(AndroidJUnit4.class)
 public class SwitchUserQuickSettings {
-    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private static final String guestUser = MultiUserConstants.GUEST_NAME;
+    private static final String GUEST = AutomotiveConfigConstants.HOME_GUEST_BUTTON;
+    private static final String DRIVER = AutomotiveConfigConstants.HOME_DRIVER_BUTTON;
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
@@ -59,15 +57,16 @@ public class SwitchUserQuickSettings {
     }
 
     @Test
-    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testSwitchUser() throws Exception {
         UserInfo previousUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // switch to Guest
-        mUsersHelper.get().switchUser(previousUser.name, guestUser);
+        mUsersHelper.get().switchUsingUserIcon(GUEST);
         UserInfo currentUser = mMultiUserHelper.getCurrentForegroundUserInfo();
         // verify the user switch
         assertTrue(currentUser.name.equals(guestUser));
         // switch to initial user before terminating the test
-        mUsersHelper.get().switchUser(currentUser.name, previousUser.name);
+        mUsersHelper.get().switchUsingUserIcon(DRIVER);
+        assertTrue(
+            mMultiUserHelper.getCurrentForegroundUserInfo().name.equals(previousUser.name));
     }
 }
diff --git a/tests/automotive/functional/profileicon/src/android/platform/tests/ProfileIconTest.java b/tests/automotive/functional/profileicon/src/android/platform/tests/ProfileIconTest.java
index a8f4720ad..c7a946556 100644
--- a/tests/automotive/functional/profileicon/src/android/platform/tests/ProfileIconTest.java
+++ b/tests/automotive/functional/profileicon/src/android/platform/tests/ProfileIconTest.java
@@ -20,42 +20,42 @@ import static junit.framework.Assert.assertTrue;
 
 import android.platform.helpers.HelperAccessor;
 import android.platform.helpers.IAutoHomeHelper;
+import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.IAutoUserHelper;
 import android.platform.helpers.MultiUserHelper;
+import android.platform.helpers.SettingsConstants;
 import android.platform.scenario.multiuser.MultiUserConstants;
-import android.platform.test.rules.ConditionalIgnore;
-import android.platform.test.rules.ConditionalIgnoreRule;
-import android.platform.test.rules.IgnoreOnPortrait;
+import android.platform.helpers.AutomotiveConfigConstants;
 
 import androidx.test.runner.AndroidJUnit4;
 
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class ProfileIconTest {
-    @Rule public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();
 
     private static final String USER_NAME = MultiUserConstants.GUEST_NAME;
+    private static final String GUEST = AutomotiveConfigConstants.HOME_GUEST_BUTTON;
 
     private final MultiUserHelper mMultiUserHelper = MultiUserHelper.getInstance();
 
     private HelperAccessor<IAutoUserHelper> mUsersHelper;
-
+    private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoHomeHelper> mHomeHelper;
 
     public ProfileIconTest() {
         mHomeHelper = new HelperAccessor<>(IAutoHomeHelper.class);
         mUsersHelper = new HelperAccessor<>(IAutoUserHelper.class);
+        mSettingHelper = new HelperAccessor<>(IAutoSettingHelper.class);
     }
 
     @Test
-    @ConditionalIgnore(condition = IgnoreOnPortrait.class)
     public void testToVerifyGuestProfile() throws Exception {
-        mUsersHelper.get().switchUser("Driver", USER_NAME);
+        mUsersHelper.get().switchUsingUserIcon(GUEST);
+        mSettingHelper.get().openSetting(SettingsConstants.PROFILE_ACCOUNT_SETTINGS);
         assertTrue(
                 "Failed to switch from current user to Guest Profile.",
-                USER_NAME.equals(mHomeHelper.get().getUserProfileName()));
+                mUsersHelper.get().getProfileNameFromSettings().contains(USER_NAME));
     }
 }
diff --git a/tests/automotive/functional/settings/Android.bp b/tests/automotive/functional/settings/Android.bp
index af115fd86..27e1e7787 100644
--- a/tests/automotive/functional/settings/Android.bp
+++ b/tests/automotive/functional/settings/Android.bp
@@ -24,6 +24,7 @@ android_test {
         "androidx.test.runner",
         "androidx.test.rules",
         "automotive-settings-app-helper",
+        "automotive-status-bar-helper",
         "automotive-utility-helper",
         "app-helpers-auto-interfaces",
         "hamcrest-library",
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
index 1a475a927..d90d50be0 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/AppInfoSettingTest.java
@@ -33,9 +33,10 @@ public class AppInfoSettingTest {
     @Before
     public void openAppInfoFacet() {
         mSettingHelper.get().openSetting(SettingsConstants.APPS_SETTINGS);
-        assertTrue(
-                "Apps setting did not open.",
-                mSettingHelper.get().checkMenuExists("Reset app grid to A-Z order"));
+        boolean hasAppsInfoUiElement =
+                mSettingHelper.get().checkMenuExists("Reset app grid to A-Z order")
+                        || mSettingHelper.get().checkMenuExists("Recently opened");
+        assertTrue("Apps setting did not open.", hasAppsInfoUiElement);
         mAppInfoSettingsHelper.get().showAllApps();
     }
 
diff --git a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
index 6c2b14e55..0624ae353 100644
--- a/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
+++ b/tests/automotive/functional/settings/src/android/platform/tests/MicroPhoneSettingTest.java
@@ -25,7 +25,8 @@ import android.platform.helpers.IAutoPrivacySettingsHelper;
 import android.platform.helpers.IAutoSettingHelper;
 import android.platform.helpers.SettingsConstants;
 import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.SetFlagsRule;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -36,6 +37,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
+@RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
 public class MicroPhoneSettingTest {
     private static final String USE_MICROPHONE_TXT = "Use microphone";
     private static final String MICROPHONE_OFF_TXT = "Microphone is off.";
@@ -43,7 +45,9 @@ public class MicroPhoneSettingTest {
     private HelperAccessor<IAutoFacetBarHelper> mFacetBarHelper;
     private HelperAccessor<IAutoSettingHelper> mSettingHelper;
     private HelperAccessor<IAutoPrivacySettingsHelper> mPrivacySettingsHelper;
-    @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
 
     public MicroPhoneSettingTest() throws Exception {
         mFacetBarHelper = new HelperAccessor<>(IAutoFacetBarHelper.class);
@@ -80,7 +84,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void manageMicrophonePermissions() {
         mSettingHelper.get().openSetting(SettingsConstants.PRIVACY_SETTINGS);
         assertTrue(
@@ -94,7 +97,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhoneToggleOff() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -111,7 +113,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhoneToggleOn() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -133,7 +134,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhonePanelStatusBar() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -151,7 +151,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhonePanelStatusBarFromHome() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -167,7 +166,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhonePanelSettingsLink() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -181,7 +179,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhonePanelToggle() {
         // turn off microphone
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
@@ -203,7 +200,6 @@ public class MicroPhoneSettingTest {
     }
 
     @Test
-    @RequiresFlagsEnabled(com.android.car.settings.Flags.FLAG_MICROPHONE_PRIVACY_UPDATES)
     public void testMicroPhoneButtonDismiss() {
         mPrivacySettingsHelper.get().turnOnOffMicroPhone(false);
         mPrivacySettingsHelper.get().clickMicroPhoneStatusBar();
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java
new file mode 100644
index 000000000..ff2b39396
--- /dev/null
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/CurrentDateTimeTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.tests;
+
+import static junit.framework.Assert.assertEquals;
+
+import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoStatusBarHelper;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class CurrentDateTimeTest {
+
+    private HelperAccessor<IAutoStatusBarHelper> mStatusBarHelper;
+
+    public CurrentDateTimeTest() {
+        mStatusBarHelper = new HelperAccessor<>(IAutoStatusBarHelper.class);
+    }
+
+    @Test
+    public void testCurrentTime() {
+        assertEquals(
+                "Current local Time",
+                mStatusBarHelper.get().getClockTime(),
+                mStatusBarHelper
+                        .get()
+                        .getCurrentTimeWithTimeZone(mStatusBarHelper.get().getCurrentTimeZone()));
+    }
+
+    @Test
+    public void testCurrentTimeZone() {
+        assertEquals(
+                "Current local Time Zone",
+                mStatusBarHelper.get().getCurrentTimeZone(),
+                mStatusBarHelper.get().getDeviceCurrentTimeZone());
+    }
+}
diff --git a/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java b/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
index 1d0f30457..e49161e70 100644
--- a/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
+++ b/tests/automotive/functional/statusbar/src/android/platform/tests/NetworkPaletteTest.java
@@ -83,6 +83,13 @@ public class NetworkPaletteTest {
         // Turn off Wifi
         mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
         assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
+        // Verifying Wifi is turned ON again
+        mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
+        assertTrue("Wi-Fi Name is not displayed", mStatusBarHelper.get().isWifiNameDisplayed());
+        // Turn off Wifi
+        mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
     }
 
     @Test
@@ -97,6 +104,17 @@ public class NetworkPaletteTest {
         assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
         assertTrue(
                 "Hotspot is not enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
+        // Turn off Wifi and Hotspot
+        mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
+        assertFalse("Wi-Fi is enabled", mSettingHelper.get().isWifiOn());
+        assertFalse("Hotspot is enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
+        // Turn on Wifi and Hotspot
+        mStatusBarHelper.get().networkPaletteToggleOnOff(WIFI);
+        mStatusBarHelper.get().networkPaletteToggleOnOff(HOTSPOT);
+        assertTrue("Wi-Fi is not enabled", mSettingHelper.get().isWifiOn());
+        assertTrue(
+                "Hotspot is not enabled", mStatusBarHelper.get().isNetworkSwitchEnabled(HOTSPOT));
     }
 
     @Test
diff --git a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
index faae69b0a..82a3a14d7 100644
--- a/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
+++ b/tests/automotive/functional/uxrestriction/src/android/platform/tests/UxRestrictionFacetBarTest.java
@@ -113,4 +113,40 @@ public class UxRestrictionFacetBarTest {
                         .get()
                         .isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.NOTIFICATION));
     }
+
+    @Test
+    public void testRestrictedBluetoothPalette() {
+        mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.BLUETOOTH);
+        assertTrue(
+                "Bluetooth palette did not open.",
+                mFacetBarHelper
+                        .get()
+                        .isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.BLUETOOTH));
+    }
+
+    @Test
+    public void testRestrictedWifiPalette() {
+        mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.WIFI);
+        assertTrue(
+                "Wifi palette did not open.",
+                mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.WIFI));
+    }
+
+    @Test
+    public void testRestrictedBrighnessPalette() {
+        mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.BRIGHTNESS);
+        assertTrue(
+                "Brightness palette did not open.",
+                mFacetBarHelper
+                        .get()
+                        .isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.BRIGHTNESS));
+    }
+
+    @Test
+    public void testRestrictedSoundPalette() {
+        mFacetBarHelper.get().clickOnFacetIcon(IAutoFacetBarHelper.FACET_BAR.SOUND);
+        assertTrue(
+                "Sound palette did not open.",
+                mFacetBarHelper.get().isAppInForeground(IAutoFacetBarHelper.VERIFY_OPEN_APP.SOUND));
+    }
 }
diff --git a/tests/automotive/health/appgrid/src/android/platform/scenario/appgrid/OpenApp.java b/tests/automotive/health/appgrid/src/android/platform/scenario/appgrid/OpenApp.java
new file mode 100644
index 000000000..b1a8addce
--- /dev/null
+++ b/tests/automotive/health/appgrid/src/android/platform/scenario/appgrid/OpenApp.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.platform.test.scenario.appgrid;
+
+import android.platform.helpers.HelperAccessor;
+import android.platform.helpers.IAutoAppGridHelper;
+import android.platform.test.scenario.annotation.Scenario;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Opens the Appgrid and exits after. */
+@Scenario
+@RunWith(JUnit4.class)
+public class OpenApp {
+    static HelperAccessor<IAutoAppGridHelper> sHelper =
+            new HelperAccessor<>(IAutoAppGridHelper.class);
+
+    @Test
+    public void testOpen() {
+        sHelper.get().open();
+    }
+}
diff --git a/tests/automotive/health/boottime/src/android/boottime/BootTimeTest.java b/tests/automotive/health/boottime/src/android/boottime/BootTimeTest.java
index 1d70f8469..b46729cae 100644
--- a/tests/automotive/health/boottime/src/android/boottime/BootTimeTest.java
+++ b/tests/automotive/health/boottime/src/android/boottime/BootTimeTest.java
@@ -163,6 +163,8 @@ public class BootTimeTest extends BaseHostJUnit4Test {
         setUpDeviceForSuccessiveBoots();
         CLog.v("Waiting for %d msecs before successive boots.", mBootDelayTime);
         sleep(mBootDelayTime);
+        mRebootLogcatReceiver = new LogcatReceiver(getDevice(), LOGCAT_CMD_ALL, LOGCAT_SIZE, 0);
+        mRebootLogcatReceiver.start();
     }
 
     @Test
@@ -195,7 +197,7 @@ public class BootTimeTest extends BaseHostJUnit4Test {
         if (mForceF2FsShutdown) {
             forseF2FsShutdown();
         }
-        clearAndStartLogcat();
+        clearLogcat();
         sleep(5000);
         getDevice().nonBlockingReboot();
         getDevice().waitForDeviceOnline(mDeviceBootTime);
@@ -271,15 +273,9 @@ public class BootTimeTest extends BaseHostJUnit4Test {
                 filename, LogDataType.HOST_LOG, new FileInputStreamSource(dmesgFile, false));
     }
 
-    private void clearAndStartLogcat() throws DeviceNotAvailableException {
+    private void clearLogcat() throws DeviceNotAvailableException {
         getDevice().executeShellCommand(LOGCAT_CMD_CLEAR);
-        if (mRebootLogcatReceiver != null) {
-            mRebootLogcatReceiver.clear();
-            mRebootLogcatReceiver.stop();
-            mRebootLogcatReceiver = null;
-        }
-        mRebootLogcatReceiver = new LogcatReceiver(getDevice(), LOGCAT_CMD_ALL, LOGCAT_SIZE, 0);
-        mRebootLogcatReceiver.start();
+        mRebootLogcatReceiver.clear();
     }
 
     private void sleep(long duration) {
diff --git a/tests/automotive/health/multiuser/src/android/platform/scenario/multiuser/nonui/SwitchToExistingSecondaryUser.java b/tests/automotive/health/multiuser/src/android/platform/scenario/multiuser/nonui/SwitchToExistingSecondaryUser.java
index 3850abead..8ff426726 100644
--- a/tests/automotive/health/multiuser/src/android/platform/scenario/multiuser/nonui/SwitchToExistingSecondaryUser.java
+++ b/tests/automotive/health/multiuser/src/android/platform/scenario/multiuser/nonui/SwitchToExistingSecondaryUser.java
@@ -87,9 +87,9 @@ public class SwitchToExistingSecondaryUser {
         Assume.assumeTrue(
                 String.format(
                         Locale.US,
-                        "DEFAULT_INITIAL_USER is user %d but must be user 10",
+                        "DEFAULT_INITIAL_USER is user id %d but must be greater or equal to 10",
                         MultiUserConstants.DEFAULT_INITIAL_USER),
-                MultiUserConstants.DEFAULT_INITIAL_USER == 10);
+                MultiUserConstants.DEFAULT_INITIAL_USER >= 10);
         Assume.assumeTrue(
                 String.format(
                         Locale.US,
diff --git a/tests/automotive/mobly_tests/Android.bp b/tests/automotive/mobly_tests/Android.bp
index cdbe384ac..4059e1972 100644
--- a/tests/automotive/mobly_tests/Android.bp
+++ b/tests/automotive/mobly_tests/Android.bp
@@ -6,7 +6,7 @@ python_library_host {
         "mobly",
         "utilities"
     ],
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -33,7 +33,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -54,7 +54,7 @@ python_library_host {
         "utilities",
         "bluetooth_test"
     ],
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/bluetooth_palette/Android.bp b/tests/automotive/mobly_tests/bluetooth_palette/Android.bp
index d8c9a4513..3c7dcb2a0 100644
--- a/tests/automotive/mobly_tests/bluetooth_palette/Android.bp
+++ b/tests/automotive/mobly_tests/bluetooth_palette/Android.bp
@@ -32,7 +32,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -59,7 +59,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -86,7 +86,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -113,7 +113,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/connectivity/Android.bp b/tests/automotive/mobly_tests/connectivity/Android.bp
index e40c369b9..7a9b064a8 100644
--- a/tests/automotive/mobly_tests/connectivity/Android.bp
+++ b/tests/automotive/mobly_tests/connectivity/Android.bp
@@ -32,7 +32,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -59,7 +59,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -86,7 +86,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -113,7 +113,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -140,7 +140,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -167,7 +167,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -194,7 +194,61 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
+
+python_test_host {
+    name: "BluetoothDisablePhoneAfterReconnectTest",
+    main: "connectivity_test_disconnected_phone_after_reconnect.py",
+    srcs: ["connectivity_test_disconnected_phone_after_reconnect.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":AutomotiveSnippet",
+        ":PhoneSnippet",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
+
+python_test_host {
+    name: "BluetoothDisableMediaAfterReconnectTest",
+    main: "connectivity_test_disconnected_media_after_reconnect.py",
+    srcs: ["connectivity_test_disconnected_media_after_reconnect.py"],
+    libs: [
+        "mobly",
+        "utilities",
+        "bluetooth_test",
+    ],
+    test_suites: [
+        "catbox",
+    ],
+    test_options: {
+        unit_test: false,
+    },
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_media_after_reconnect.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_media_after_reconnect.py
new file mode 100644
index 000000000..bd1f798a9
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_media_after_reconnect.py
@@ -0,0 +1,84 @@
+"""
+  Copyright (C) 2024 The Android Open Source Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+
+
+  Test Steps:
+  (0. Flash device)
+  1. Verify by default BT should be ON always
+  2. Disable Media Button from Bluetooth Settings Page
+  3. Disable Bluetooth Button and enable Bluetooth
+  4. Verify After reconnecting Bluetooth - Media remains disabled and not displayed
+
+"""
+
+import logging
+
+from mobly import asserts
+from utilities.main_utils import common_main
+from bluetooth_test import bluetooth_base_test
+from utilities import constants
+
+class BluetoothDisableMediaAfterReconnectTest(bluetooth_base_test.BluetoothBaseTest):
+
+    def setup_test(self):
+        # Pair the devices
+        self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
+        self.call_utils.press_home()
+
+    def test_disable_enable_media(self):
+        # Log BT Connection State after pairing
+        bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
+        logging.info("BT State after pairing : <%s>", bt_connection_state)
+
+        # Navigate to the bluetooth settings page
+        self.call_utils.open_bluetooth_settings_form_status_bar()
+        target_name = self.target.mbs.btGetName()
+        # Disable Media for the listed paired device via the preference button
+        self.call_utils.press_media_toggle_on_device(target_name)
+        self.call_utils.wait_with_log(5)
+        # Confirm that the Media button is unchecked
+        asserts.assert_false(
+            self.discoverer.mbs.isMediaPreferenceChecked(),
+            "Expected phone button to be unchecked after pressing it.")
+
+        # Tap Bluetooth button to Disable Bluetooth
+        self.call_utils.press_bluetooth_toggle_on_device(self.target.mbs.btGetName())
+        self.call_utils.wait_with_log(5)
+        # Tap Grey Bluetooth Button to Enable Bluetooth
+        self.call_utils.press_bluetooth_toggle_on_device(self.target.mbs.btGetName())
+        self.call_utils.wait_with_log(10)
+        # After reconnecting Bluetooth - Confirm that the media button is unchecked
+        asserts.assert_false(
+            self.discoverer.mbs.isMediaPreferenceChecked(),
+            "Expected Media button to be unchecked after pressing it.")
+
+        self.call_utils.wait_with_log(5)
+
+        # Go back to the bluetooth settings page and enable media via the preference button
+        self.call_utils.press_home()
+        self.call_utils.open_bluetooth_settings()
+        self.call_utils.press_media_toggle_on_device(target_name)
+        self.call_utils.wait_with_log(5)
+
+        # Confirm that the Media button is re-enabled
+        asserts.assert_true(
+            self.discoverer.mbs.isMediaPreferenceChecked(),
+            "Expected media button to be checked after pressing it a second time.")
+
+if __name__ == '__main__':
+    # Take test args
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_phone_after_reconnect.py b/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_phone_after_reconnect.py
new file mode 100644
index 000000000..ac50db2a0
--- /dev/null
+++ b/tests/automotive/mobly_tests/connectivity/connectivity_test_disconnected_phone_after_reconnect.py
@@ -0,0 +1,83 @@
+"""
+  Copyright (C) 2024 The Android Open Source Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+
+
+  Test Steps:
+  (0. Flash device)
+  1. Verify by default BT should be ON always
+  2. Disable Phone Button from Bluetooth Settings Page
+  3. Disable Bluetooth Button and enable Bluetooth
+  4. Verify After reconnecting Bluetooth - Phone-HFP remains disabled and not displayed
+
+"""
+
+import logging
+
+from mobly import asserts
+from utilities.main_utils import common_main
+from bluetooth_test import bluetooth_base_test
+from utilities import constants
+
+class BluetoothDisablePhoneAfterReconnectTest(bluetooth_base_test.BluetoothBaseTest):
+
+    def setup_test(self):
+        # Pair the devices
+        self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
+        self.call_utils.press_home()
+
+    def test_disable_enable_phone(self):
+        # Log BT Connection State after pairing
+        bt_connection_state=self.call_utils.get_bt_connection_status_using_adb_command(self.discoverer)
+        logging.info("BT State after pairing : <%s>", bt_connection_state)
+
+        # Navigate to the bluetooth settings page
+        self.call_utils.open_bluetooth_settings_form_status_bar()
+        target_name = self.target.mbs.btGetName()
+        # Disable phone for the listed paired device via the preference button
+        self.call_utils.press_phone_toggle_on_device(target_name)
+        self.call_utils.wait_with_log(5)
+        # Confirm that the phone button is unchecked
+        asserts.assert_false(
+            self.discoverer.mbs.isPhonePreferenceChecked(),
+            "Expected phone button to be unchecked after pressing it.")
+
+        # Tap Bluetooth button to Disable Bluetooth
+        self.call_utils.press_bluetooth_toggle_on_device(self.target.mbs.btGetName())
+        self.call_utils.wait_with_log(5)
+        # Tap Grey Bluetooth Button to Enable Bluetooth
+        self.call_utils.press_bluetooth_toggle_on_device(self.target.mbs.btGetName())
+        self.call_utils.wait_with_log(10)
+        # After reconnecting Bluetooth - Confirm that the phone button is unchecked
+        asserts.assert_false(
+            self.discoverer.mbs.isPhonePreferenceChecked(),
+            "Expected phone button to be unchecked after pressing it.")
+
+        self.call_utils.wait_with_log(constants.DEFAULT_WAIT_TIME_FIVE_SECS)
+
+        # Go back to the bluetooth settings page and enable phone via the preference button
+        self.call_utils.press_home()
+        self.call_utils.open_bluetooth_settings()
+        self.call_utils.press_phone_toggle_on_device(target_name)
+
+        # Confirm that the phone button is re-enabled
+        asserts.assert_true(
+            self.discoverer.mbs.isPhonePreferenceChecked(),
+            "Expected phone button to be checked after pressing it a second time.")
+
+if __name__ == '__main__':
+    # Take test args
+    common_main()
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/dialer/Android.bp b/tests/automotive/mobly_tests/dialer/Android.bp
index f5425bd20..dc68643f4 100644
--- a/tests/automotive/mobly_tests/dialer/Android.bp
+++ b/tests/automotive/mobly_tests/dialer/Android.bp
@@ -32,7 +32,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -59,7 +59,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -85,7 +85,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -112,7 +112,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -139,7 +139,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -166,7 +166,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -193,7 +193,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -220,7 +220,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -247,7 +247,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -274,7 +274,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -300,7 +300,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -329,7 +329,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -356,7 +356,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -383,7 +383,7 @@ python_test_host {
        test_options: {
            unit_test: false,
        },
-       data: [
+       device_common_data: [
            // Package the snippet with the mobly test
            ":AutomotiveSnippet",
            ":PhoneSnippet",
@@ -410,7 +410,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -437,7 +437,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -465,7 +465,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -492,7 +492,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -519,7 +519,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -546,7 +546,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -574,7 +574,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -604,7 +604,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -632,7 +632,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -661,7 +661,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -690,7 +690,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -719,7 +719,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/dialer/dialer_test_launch_from_phone_card.py b/tests/automotive/mobly_tests/dialer/dialer_test_launch_from_phone_card.py
index ba838305a..e55754625 100644
--- a/tests/automotive/mobly_tests/dialer/dialer_test_launch_from_phone_card.py
+++ b/tests/automotive/mobly_tests/dialer/dialer_test_launch_from_phone_card.py
@@ -46,7 +46,7 @@ class BTDialerPhoneCard(bluetooth_sms_base_test.BluetoothSMSBaseTest):
         self.call_utils.wait_with_log(10)
 
         # accept the call (on the unpaired phone)
-        self.phone_notpaired.mbs.clickUIElementWithText(constants.ACCEPT_CALL_TEXT)
+        self.phone_notpaired.mbs.clickUIElementWithText(constants.ANSWER_CALL_TEXT)
         self.call_utils.wait_with_log(10)
         self.call_utils.press_home()
 
diff --git a/tests/automotive/mobly_tests/media/Android.bp b/tests/automotive/mobly_tests/media/Android.bp
index 54247d69b..989c7e5b0 100644
--- a/tests/automotive/mobly_tests/media/Android.bp
+++ b/tests/automotive/mobly_tests/media/Android.bp
@@ -32,7 +32,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -59,7 +59,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -86,7 +86,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -113,7 +113,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -140,7 +140,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -167,7 +167,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -194,7 +194,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -221,7 +221,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -248,7 +248,7 @@ python_test_host {
      test_options: {
          unit_test: false,
      },
-     data: [
+     device_common_data: [
          // Package the snippet with the mobly test
          ":AutomotiveSnippet",
          ":PhoneSnippet",
@@ -275,7 +275,7 @@ python_test_host {
       test_options: {
           unit_test: false,
       },
-      data: [
+      device_common_data: [
           // Package the snippet with the mobly test
           ":AutomotiveSnippet",
           ":PhoneSnippet",
@@ -302,7 +302,7 @@ python_test_host {
       test_options: {
           unit_test: false,
       },
-      data: [
+      device_common_data: [
           // Package the snippet with the mobly test
           ":AutomotiveSnippet",
           ":PhoneSnippet",
@@ -329,7 +329,7 @@ python_test_host {
       test_options: {
           unit_test: false,
       },
-      data: [
+      device_common_data: [
           // Package the snippet with the mobly test
           ":AutomotiveSnippet",
           ":PhoneSnippet",
@@ -356,7 +356,7 @@ python_test_host {
       test_options: {
           unit_test: false,
       },
-      data: [
+      device_common_data: [
           // Package the snippet with the mobly test
           ":AutomotiveSnippet",
           ":PhoneSnippet",
@@ -383,7 +383,7 @@ python_test_host {
         test_options: {
             unit_test: false,
         },
-        data: [
+        device_common_data: [
             // Package the snippet with the mobly test
             ":AutomotiveSnippet",
             ":PhoneSnippet",
@@ -410,7 +410,7 @@ python_test_host {
         test_options: {
             unit_test: false,
         },
-        data: [
+        device_common_data: [
             // Package the snippet with the mobly test
             ":AutomotiveSnippet",
             ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/media/media_test_avrcp_tree_displayed.py b/tests/automotive/mobly_tests/media/media_test_avrcp_tree_displayed.py
index 821acc308..406430fff 100644
--- a/tests/automotive/mobly_tests/media/media_test_avrcp_tree_displayed.py
+++ b/tests/automotive/mobly_tests/media/media_test_avrcp_tree_displayed.py
@@ -56,12 +56,8 @@ class IsTreeDisplayedTest(bluetooth_base_test.BluetoothBaseTest):
         asserts.assert_true(self.common_utils.has_ui_element_with_text(constants.YOUTUBE_MUSIC_APP),
                             '<' + constants.YOUTUBE_MUSIC_APP + '> has to be present on HU screen')
 
-        self.media_utils.open_youtube_music_app_on_hu()
-        asserts.assert_true(
-            self.common_utils.has_ui_element_with_text(constants.YOUTUBE_MUSIC_DOWNLOADS),
-            '<' + constants.YOUTUBE_MUSIC_DOWNLOADS + '> has to be present on HU screen')
-
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_categories_playlists_selectable.py b/tests/automotive/mobly_tests/media/media_test_categories_playlists_selectable.py
index 1374c7808..5f808af5a 100644
--- a/tests/automotive/mobly_tests/media/media_test_categories_playlists_selectable.py
+++ b/tests/automotive/mobly_tests/media/media_test_categories_playlists_selectable.py
@@ -71,6 +71,7 @@ class IsCategoriesPlaylistsSelectable(bluetooth_base_test.BluetoothBaseTest):
                                                                  'present on HU')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_device_sync_after_hu_start.py b/tests/automotive/mobly_tests/media/media_test_device_sync_after_hu_start.py
index 32ceb6da2..e46dc4e56 100644
--- a/tests/automotive/mobly_tests/media/media_test_device_sync_after_hu_start.py
+++ b/tests/automotive/mobly_tests/media/media_test_device_sync_after_hu_start.py
@@ -58,6 +58,8 @@ class IsDeviceSyncedAfterHuStart(bluetooth_base_test.BluetoothBaseTest):
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+
+
         # Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_now_playing_label_displayed.py b/tests/automotive/mobly_tests/media/media_test_now_playing_label_displayed.py
index b568b23d3..fa1fb8c04 100644
--- a/tests/automotive/mobly_tests/media/media_test_now_playing_label_displayed.py
+++ b/tests/automotive/mobly_tests/media/media_test_now_playing_label_displayed.py
@@ -49,17 +49,12 @@ class IsNowPlayingLabelDisplayed(bluetooth_base_test.BluetoothBaseTest):
                             '<Now Playing> label should be displayed')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Minimize now_playing
         self.media_utils.minimize_now_playing()
         # Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
-#         logging.info("Stopping the screen recording on Target")
-#         self.video_utils_service_target.stop_screen_recording()
-#         logging.info("Pull the screen recording from Target")
-#         self.video_utils_service_target.pull_recording_file(self.log_path)
-#         logging.info("delete the screen recording from the Target")
-#         self.video_utils_service_target.delete_screen_recording_from_device()
         super().teardown_test()
 
 
diff --git a/tests/automotive/mobly_tests/media/media_test_play_media_from_widget.py b/tests/automotive/mobly_tests/media/media_test_play_media_from_widget.py
index 86c91c383..78fce2622 100644
--- a/tests/automotive/mobly_tests/media/media_test_play_media_from_widget.py
+++ b/tests/automotive/mobly_tests/media/media_test_play_media_from_widget.py
@@ -51,6 +51,7 @@ class IsAbleToPlayMediaFromWidgetTest(bluetooth_base_test.BluetoothBaseTest):
                             'Media player should be on PLAY mode')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #   Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_play_status_after_reboot.py b/tests/automotive/mobly_tests/media/media_test_play_status_after_reboot.py
index ff2267952..d87b6511d 100644
--- a/tests/automotive/mobly_tests/media/media_test_play_status_after_reboot.py
+++ b/tests/automotive/mobly_tests/media/media_test_play_status_after_reboot.py
@@ -67,6 +67,7 @@ class IsSongPLayingAfterRebootTest(bluetooth_base_test.BluetoothBaseTest):
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_playlist_rendering.py b/tests/automotive/mobly_tests/media/media_test_playlist_rendering.py
index 820b344a1..5a6cdb52e 100644
--- a/tests/automotive/mobly_tests/media/media_test_playlist_rendering.py
+++ b/tests/automotive/mobly_tests/media/media_test_playlist_rendering.py
@@ -38,8 +38,9 @@ class PlaylistRendering(bluetooth_base_test.BluetoothBaseTest):
     def test_playlist_rendering(self):
         """Tests validating is song selectable using playlist on HU"""
         self.media_utils.open_media_app_on_hu()
-        self.call_utils.handle_bluetooth_audio_pop_up()
         self.media_utils.open_youtube_music_app()
+        self.call_utils.wait_with_log(5)
+        self.call_utils.handle_bluetooth_audio_pop_up()
         logging.info("Getting song title from phone device: %s", self.media_utils.get_song_title_from_phone())
         self.media_utils.maximize_now_playing()
         asserts.assert_true(self.media_utils.is_playlist_icon_visible(),
@@ -55,6 +56,7 @@ class PlaylistRendering(bluetooth_base_test.BluetoothBaseTest):
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Minimize now_playing
         self.media_utils.minimize_now_playing()
         #  Close YouTube Music app
diff --git a/tests/automotive/mobly_tests/media/media_test_prev_and_next_song_metadata_validation.py b/tests/automotive/mobly_tests/media/media_test_prev_and_next_song_metadata_validation.py
index 86a333378..11eefb7fb 100644
--- a/tests/automotive/mobly_tests/media/media_test_prev_and_next_song_metadata_validation.py
+++ b/tests/automotive/mobly_tests/media/media_test_prev_and_next_song_metadata_validation.py
@@ -31,17 +31,13 @@ class IsMediaMetadataForNextAndPrevSongOnHuValid(bluetooth_base_test.BluetoothBa
         super().setup_class()
         self.media_utils = MediaUtils(self.target, self.discoverer)
         self.common_utils = CommonUtils(self.target, self.discoverer)
-        super().enable_recording()
         self.media_utils.enable_bt_media_debugging_logs()
 
     def setup_test(self):
         self.common_utils.grant_local_mac_address_permission()
-        logging.info("\tInitializing video services on Target")
-        self.video_utils_service_target = VideoRecording(self.target,self.__class__.__name__)
-        logging.info("Enabling video recording for Target")
-        self.video_utils_service_target.enable_screen_recording()
         self.common_utils.enable_wifi_on_phone_device()
         self.bt_utils.pair_primary_to_secondary()
+        super().enable_recording()
 
     def test_is_media_metadata_valid_on_hu(self):
         """Tests is media metadata on HU valid"""
@@ -49,12 +45,13 @@ class IsMediaMetadataForNextAndPrevSongOnHuValid(bluetooth_base_test.BluetoothBa
         self.call_utils.handle_bluetooth_audio_pop_up()
         self.media_utils.open_youtube_music_app()
         logging.info("Getting song title from phone device: %s", self.media_utils.get_song_title_from_phone())
-        self.call_utils.wait_with_log(5)
         self.media_utils.pause_media_on_hu()
 
         # Current song metadata validation
         current_phone_song_title = self.media_utils.get_song_title_from_phone()
         self.media_utils.maximize_now_playing()
+        self.call_utils.wait_with_log(3)
+        logging.info("MetaData Validation for Current Song")
         current_hu_song_title = self.media_utils.get_song_title_from_hu()
         asserts.assert_true(current_phone_song_title == current_hu_song_title,
                             'Invalid song titles. '
@@ -91,7 +88,7 @@ class IsMediaMetadataForNextAndPrevSongOnHuValid(bluetooth_base_test.BluetoothBa
         # Next song metadata validation
         self.media_utils.click_next_track_on_hu()
         self.media_utils.pause_media_on_hu()
-        # current_phone_next_song_title = self.media_utils.get_song_title_from_phone()
+        logging.info("MetaData Validation after clicking Next Song")
         current_hu_next_song_title = self.media_utils.get_song_title_from_hu()
         asserts.assert_true(current_phone_song_title != current_hu_next_song_title,
                             'Song title on phone device and HU should be different,'
@@ -101,6 +98,7 @@ class IsMediaMetadataForNextAndPrevSongOnHuValid(bluetooth_base_test.BluetoothBa
         self.media_utils.click_previous_track_on_hu()
         self.media_utils.click_previous_track_on_hu()
         self.media_utils.pause_media_on_hu()
+        logging.info("MetaData Validation after clicking Previous Song")
         current_hu_previous_song_title = self.media_utils.get_song_title_from_hu()
         asserts.assert_true(current_phone_song_title == current_hu_previous_song_title,
                             'Invalid song titles. '
@@ -131,17 +129,12 @@ class IsMediaMetadataForNextAndPrevSongOnHuValid(bluetooth_base_test.BluetoothBa
                                       '<' + actual_previous_current_song_max_playing_time + '>')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Minimize now_playing
         self.media_utils.minimize_now_playing()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
-        logging.info("Stopping the screen recording on Target")
-        self.video_utils_service_target.stop_screen_recording()
-        logging.info("Pull the screen recording from Target")
-        self.video_utils_service_target.pull_recording_file(self.log_path)
-        logging.info("delete the screen recording from the Target")
-        self.video_utils_service_target.delete_screen_recording_from_device()
         super().teardown_test()
 
 
diff --git a/tests/automotive/mobly_tests/media/media_test_select_song_from_playlist.py b/tests/automotive/mobly_tests/media/media_test_select_song_from_playlist.py
index c06c3fc01..ee35f0196 100644
--- a/tests/automotive/mobly_tests/media/media_test_select_song_from_playlist.py
+++ b/tests/automotive/mobly_tests/media/media_test_select_song_from_playlist.py
@@ -66,6 +66,7 @@ class SelectSongFromPlaylist(bluetooth_base_test.BluetoothBaseTest):
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Minimize now_playing
         self.media_utils.minimize_now_playing()
         #  Close YouTube Music app
diff --git a/tests/automotive/mobly_tests/media/media_test_song_is_playing.py b/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
index cb14df37c..3a1885329 100644
--- a/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
+++ b/tests/automotive/mobly_tests/media/media_test_song_is_playing.py
@@ -56,6 +56,7 @@ class IsSongPlayingTest(bluetooth_base_test.BluetoothBaseTest):
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_song_metadata_validation.py b/tests/automotive/mobly_tests/media/media_test_song_metadata_validation.py
index 71e440153..fc453470e 100644
--- a/tests/automotive/mobly_tests/media/media_test_song_metadata_validation.py
+++ b/tests/automotive/mobly_tests/media/media_test_song_metadata_validation.py
@@ -87,6 +87,7 @@ class IsMediaMetadataOnHuValid(bluetooth_base_test.BluetoothBaseTest):
                                       '<' + actual_current_song_max_playing_time + '>')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         # Minimize now_playing
         self.media_utils.minimize_now_playing()
         #  Close YouTube Music app
diff --git a/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py b/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
index a33943d4d..3423cf4fb 100644
--- a/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
+++ b/tests/automotive/mobly_tests/media/media_test_stream_when_radio_lunched.py
@@ -54,6 +54,7 @@ class IsMediaStreamPairedWhenRadioLunchedTest(bluetooth_base_test.BluetoothBaseT
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_switch_app_validation.py b/tests/automotive/mobly_tests/media/media_test_switch_app_validation.py
index b2f7553ab..ed24a829b 100644
--- a/tests/automotive/mobly_tests/media/media_test_switch_app_validation.py
+++ b/tests/automotive/mobly_tests/media/media_test_switch_app_validation.py
@@ -77,6 +77,7 @@ class IsAbleToSwitchAppTest(bluetooth_base_test.BluetoothBaseTest):
 
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py b/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
index d9810b33f..7981f62c1 100644
--- a/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
+++ b/tests/automotive/mobly_tests/media/media_test_synchronized_device_disconnected_connected.py
@@ -69,6 +69,7 @@ class IsMediaSynchronizedForReconnectedDevice(bluetooth_base_test.BluetoothBaseT
                             'Song title on phone device and HU should be the same')
 
     def teardown_test(self):
+        self.media_utils.get_bt_dumpsys_metadata()
         #  Close YouTube Music app
         self.media_utils.close_youtube_music_app()
         self.call_utils.press_home()
diff --git a/tests/automotive/mobly_tests/pairing/Android.bp b/tests/automotive/mobly_tests/pairing/Android.bp
index d6236155c..63e446fe8 100644
--- a/tests/automotive/mobly_tests/pairing/Android.bp
+++ b/tests/automotive/mobly_tests/pairing/Android.bp
@@ -32,7 +32,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/perfromance/Android.bp b/tests/automotive/mobly_tests/perfromance/Android.bp
index 040b071aa..830416ecd 100644
--- a/tests/automotive/mobly_tests/perfromance/Android.bp
+++ b/tests/automotive/mobly_tests/perfromance/Android.bp
@@ -31,7 +31,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/sms/Android.bp b/tests/automotive/mobly_tests/sms/Android.bp
index 43c38edf7..1923b292b 100644
--- a/tests/automotive/mobly_tests/sms/Android.bp
+++ b/tests/automotive/mobly_tests/sms/Android.bp
@@ -31,7 +31,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -58,7 +58,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -85,7 +85,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -113,7 +113,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -141,7 +141,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -169,7 +169,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -197,7 +197,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -225,7 +225,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -253,7 +253,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/mobly_tests/utilities/constants.py b/tests/automotive/mobly_tests/utilities/constants.py
index c6763480f..349535090 100644
--- a/tests/automotive/mobly_tests/utilities/constants.py
+++ b/tests/automotive/mobly_tests/utilities/constants.py
@@ -128,6 +128,7 @@ YOUTUBE_MUSIC_PACKAGE = 'com.google.android.apps.youtube.music'
 START_YOUTUBE_MEDIA_SHELL = 'am start ' + YOUTUBE_MUSIC_PACKAGE
 STOP_YOUTUBE_MEDIA_SHELL = 'am force-stop ' + YOUTUBE_MUSIC_PACKAGE
 GET_DUMPSYS_METADATA = 'dumpsys media_session'
+GET_DUMPSYS_METADATA = 'dumpsys bluetooth_manager'
 SONG_METADATA_PATTERN = r"description=.[^\n]+"
 DEFAULT_YOUTUBE_MUSIC_PLAYLIST = 'am start -a android.intent.action.VIEW -d https://music.youtube.com/watch?v=nkBJzfHpq_A'
 BLUETOOTH_AUDIO_APP = "Bluetooth Audio"
@@ -168,13 +169,14 @@ BLUETOOTH_TAG="setprop persist.log.tag.bluetooth verbose"
 BLUETOOTH_NOOPERABLE="setprop persist.bluetooth.btsnoopenable true"
 BLUETOOTH_BTSNOOP_DEFAULT_MODE="settings put global bluetooth_btsnoop_default_mode full"
 
-
 # Media Logs
 PLAYBACK_VIEW_MODEL="setprop persist.log.tag.PlaybackViewModel DEBUG"
 MEDIA_BROWSER_CONNECTOR="setprop persist.log.tag.MediaBrowserConnector DEBUG"
+MEDIA_ITEM_REPOSITORY="setprop persist.log.tag.MediaItemsRepository DEBUG"
+MEDIA_SOURCE_MODEL="setprop persist.log.tag.MediaSourceViewModel DEBUG"
+MEDIA_ACTIVITY="setprop persist.log.tag.MediaActivity DEBUG"
 SETTINGS_CLOCK_SECONDS="settings put secure clock_seconds 1"
 
-
 # Bluetooth State Verification commands
 BLUETOOTH_CONNECTION_STATE = "dumpsys bluetooth_manager | grep ConnectionState"
 BLUETOOTH_MAP = "dumpsys bluetooth_manager | grep -E MceStateMachine"
diff --git a/tests/automotive/mobly_tests/utilities/media_utils.py b/tests/automotive/mobly_tests/utilities/media_utils.py
index a631e0c98..5b9851301 100644
--- a/tests/automotive/mobly_tests/utilities/media_utils.py
+++ b/tests/automotive/mobly_tests/utilities/media_utils.py
@@ -195,7 +195,7 @@ class MediaUtils:
 
     # Minimize playing song
     def minimize_now_playing(self):
-        logging.info("Maximizing playing song on HU")
+        logging.info("Minimizing the now playing song on HU")
         self.discoverer.mbs.minimizeNowPlaying()
 
     # Open playlist
@@ -307,3 +307,12 @@ class MediaUtils:
         self.execute_shell_on_hu_device(constants.PLAYBACK_VIEW_MODEL)
         self.execute_shell_on_hu_device(constants.MEDIA_BROWSER_CONNECTOR)
         self.execute_shell_on_hu_device(constants.SETTINGS_CLOCK_SECONDS)
+
+    # Get bt dumpsys from HU device
+    def get_bt_dumpsys_metadata(self):
+        logging.debug("Getting bt dumpsys from HU device")
+        # get bt dumpsys
+        dumpsys_metadata = self.execute_shell_on_hu_device(constants.GET_DUMPSYS_METADATA).decode(
+            'utf8')
+        logging.debug('bt dumpsys before tear down on HU device: %s"',
+                             dumpsys_metadata)
\ No newline at end of file
diff --git a/tests/automotive/mobly_tests/uxrestriction/Android.bp b/tests/automotive/mobly_tests/uxrestriction/Android.bp
index e17056ceb..139ee06cd 100644
--- a/tests/automotive/mobly_tests/uxrestriction/Android.bp
+++ b/tests/automotive/mobly_tests/uxrestriction/Android.bp
@@ -31,7 +31,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -58,7 +58,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -85,7 +85,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
@@ -112,7 +112,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":AutomotiveSnippet",
         ":PhoneSnippet",
diff --git a/tests/automotive/preupload_hook_script.py b/tests/automotive/preupload_hook_script.py
new file mode 100755
index 000000000..f6cc9d2ed
--- /dev/null
+++ b/tests/automotive/preupload_hook_script.py
@@ -0,0 +1,147 @@
+#!/usr/bin/env python3
+# Copyright 2024, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Preupload hook to perform necessary checks and formatting on python files."""
+
+import argparse
+import concurrent.futures
+import multiprocessing
+import pathlib
+import shlex
+import subprocess
+import sys
+
+
+def _filter_python_files(files: list[pathlib.Path]) -> list[pathlib.Path]:
+  """Filter a list of files and return a new list of python files only."""
+  return [file for file in files if file.suffix == '.py']
+
+
+def _check_run_shell_command(cmd: str, cwd: str = None) -> None:
+  """Run a shell command and raise error if failed."""
+  if subprocess.run(shlex.split(cmd), cwd=cwd, check=False).returncode:
+    print('Preupload files did not pass Asuite preupload hook script.')
+    sys.exit(1)
+
+
+def _run_python_lint(lint_bin: str, files: list[pathlib.Path]) -> None:
+  """Run python lint binary on python files."""
+  run_lint_on_file = lambda file: subprocess.run(
+      shlex.split(f'{lint_bin} {file.as_posix()}'),
+      check=False,
+      capture_output=True,
+  )
+
+  cpu_count = multiprocessing.cpu_count()
+  with concurrent.futures.ThreadPoolExecutor(max_workers=cpu_count) as executor:
+    completed_processes = executor.map(
+        run_lint_on_file, _filter_python_files(files)
+    )
+
+  has_format_issue = False
+  for process in completed_processes:
+    if not process.returncode:
+      continue
+    print(process.stdout.decode())
+    has_format_issue = True
+
+  if has_format_issue:
+    sys.exit(1)
+
+
+def _run_pylint(files: list[pathlib.Path]) -> None:
+  """Run pylint on python files."""
+  _run_python_lint('pylint', files)
+
+
+def _run_gpylint(files: list[pathlib.Path]) -> None:
+  """Run gpylint on python files if gpylint is available."""
+  if subprocess.run(
+      shlex.split('which gpylint'),
+      check=False,
+  ).returncode:
+    print('gpylint not available. Will use pylint instead.')
+    _run_pylint(files)
+    return
+
+  _run_python_lint('gpylint', files)
+
+
+def _run_pyformat(files: list[pathlib.Path]) -> None:
+  """Run pyformat on certain projects."""
+  if subprocess.run(
+      shlex.split('which pyformat'),
+      check=False,
+  ).returncode:
+    print('pyformat not available. Will skip auto formatting.')
+    return
+
+  def _run_pyformat_on_file(file):
+    completed_process = subprocess.run(
+        shlex.split('pyformat --force_quote_type single ' + file.as_posix()),
+        capture_output=True,
+        check=False,
+    )
+
+    if completed_process.stdout:
+      subprocess.run(
+          shlex.split(
+              'pyformat -i --force_quote_type single ' + file.as_posix()
+          ),
+          check=False,
+      )
+      return True
+    return False
+
+  cpu_count = multiprocessing.cpu_count()
+  with concurrent.futures.ThreadPoolExecutor(max_workers=cpu_count) as executor:
+    need_reformat = executor.map(
+        _run_pyformat_on_file, _filter_python_files(files)
+    )
+
+  if any(need_reformat):
+    print(
+        'Reformatting completed. Please add the modified files to git and rerun'
+        ' the repo preupload hook.'
+    )
+    sys.exit(1)
+
+
+def get_preupload_files() -> list[pathlib.Path]:
+  """Get the list of files to be uploaded."""
+  parser = argparse.ArgumentParser()
+  parser.add_argument('preupload_files', nargs='*', help='Files to upload.')
+  args = parser.parse_args()
+  files_to_upload = args.preupload_files
+  if not files_to_upload:
+    # When running by users directly, only consider:
+    # added(A), renamed(R) and modified(M) files
+    # and store them in files_to_upload.
+    cmd = "git status --short | egrep [ARM] | awk '{print $NF}'"
+    files_to_upload = subprocess.check_output(
+        cmd, shell=True, encoding='utf-8'
+    ).splitlines()
+    if files_to_upload:
+      print('Modified files: %s' % files_to_upload)
+  file_paths_to_upload = [
+      pathlib.Path(file).resolve() for file in files_to_upload
+  ]
+  return [file for file in file_paths_to_upload if file.exists()]
+
+
+if __name__ == '__main__':
+  preupload_files = get_preupload_files()
+  _run_pyformat(preupload_files)
+  _run_gpylint(preupload_files)
diff --git a/tests/automotive/snippets/phone/Android.bp b/tests/automotive/snippets/phone/Android.bp
index b0a38c6b8..3b7530c3f 100644
--- a/tests/automotive/snippets/phone/Android.bp
+++ b/tests/automotive/snippets/phone/Android.bp
@@ -29,6 +29,7 @@ android_test {
         "mobly-bundled-snippets-lib",
         "automotive-status-bar-helper",
         "automotive-media-center-app-helper",
+        "android-support-multidex",
     ],
     srcs: ["src/**/*.java"],
     manifest: "AndroidAutomotiveManifest.xml",
@@ -43,10 +44,13 @@ android_test {
         "automotive-general-ui-helper",
         "automotive-dial-app-helper",
         "automotive-phone-helper",
+        "android-support-multidex",
+    ],
+    srcs: [
+        "src/**/PhoneSnippet.java",
+        "src/**/UISnippet.java",
+        "src/**/DialerSnippet.java",
     ],
-    srcs: ["src/**/PhoneSnippet.java",
-           "src/**/UISnippet.java",
-           "src/**/DialerSnippet.java"],
     manifest: "AndroidPhoneManifest.xml",
     compile_multilib: "both",
     target_sdk_version: "31",
diff --git a/tests/codecoverage/hosttest/Android.bp b/tests/codecoverage/hosttest/Android.bp
index ee88ebb28..b2ef8393b 100644
--- a/tests/codecoverage/hosttest/Android.bp
+++ b/tests/codecoverage/hosttest/Android.bp
@@ -14,7 +14,7 @@ java_test_host {
         "junit",
     ],
 
-    data: [
+    device_common_data: [
         ":CoverageInstrumentationSampleTest",
     ],
 }
diff --git a/tests/perf/PerformanceLaunch/Android.bp b/tests/perf/PerformanceLaunch/Android.bp
index fc5aac97e..d5e50f1e3 100644
--- a/tests/perf/PerformanceLaunch/Android.bp
+++ b/tests/perf/PerformanceLaunch/Android.bp
@@ -17,12 +17,23 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
-LOCAK_SDK_VERSION = ["current"]
 android_test {
     name: "PerformanceLaunch",
-    platform_apis: true,
     certificate: "platform",
-    srcs: ["src/**/*.java"],
+    srcs: [
+        "src/**/ComplexLayoutActivity.java",
+        "src/**/DispatchActivity.java",
+        "src/**/EmptyActivity.java",
+        "src/**/EmptyWebViewActivity.java",
+        "src/**/ImageActivity.java",
+        "src/**/ManyConfigResourceActivity.java",
+        "src/**/SimpleActivity.java",
+        "src/**/SimpleSurfaceGLActivity.java",
+        "src/**/SimpleWebViewActivity.java",
+        "src/**/helper/*.java"
+   ],
 
     test_suites: ["device-tests"],
+    sdk_version: "35",
+    min_sdk_version: "30",
 }
diff --git a/tests/perf/PerformanceLaunch/AndroidManifest.xml b/tests/perf/PerformanceLaunch/AndroidManifest.xml
index 675617e58..d7fe17ca6 100644
--- a/tests/perf/PerformanceLaunch/AndroidManifest.xml
+++ b/tests/perf/PerformanceLaunch/AndroidManifest.xml
@@ -19,6 +19,7 @@
     android:versionCode="1"
     android:versionName="1.0" >
 
+    <uses-sdk android:minSdkVersion="30" android:targetSdkVersion="35" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
     <application
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ComplexLayoutActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ComplexLayoutActivity.java
index 73b285642..3cfa36e0d 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ComplexLayoutActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ComplexLayoutActivity.java
@@ -16,7 +16,6 @@
 
 package com.android.performanceLaunch;
 
-import com.android.performanceLaunch.R;
 
 import android.app.Activity;
 import android.os.Bundle;
@@ -26,10 +25,10 @@ public class ComplexLayoutActivity extends Activity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_complex);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 
 }
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyActivity.java
index 9b7a4543c..a53b74816 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyActivity.java
@@ -24,8 +24,8 @@ public class EmptyActivity extends Activity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 }
\ No newline at end of file
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyWebViewActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyWebViewActivity.java
index 04ae5957d..d9b6f6a21 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyWebViewActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/EmptyWebViewActivity.java
@@ -28,12 +28,12 @@ public class EmptyWebViewActivity extends Activity {
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
         getWindow().requestFeature(Window.FEATURE_NO_TITLE);
         mWebView = new WebView(this);
         this.setContentView(mWebView);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 
 }
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ImageActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ImageActivity.java
index 4fea55132..ddbcb398d 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ImageActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ImageActivity.java
@@ -16,7 +16,6 @@
 
 package com.android.performanceLaunch;
 
-import com.android.performanceLaunch.R;
 
 import android.app.Activity;
 import android.os.Bundle;
@@ -26,10 +25,10 @@ public class ImageActivity extends Activity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_background);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 
 }
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ManyConfigResourceActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ManyConfigResourceActivity.java
index cf7e8bd88..a3bdc1478 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ManyConfigResourceActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/ManyConfigResourceActivity.java
@@ -15,20 +15,19 @@
  */
 package com.android.performanceLaunch;
 
-import android.annotation.Nullable;
 import android.app.Activity;
 import android.os.Bundle;
 import android.os.Trace;
 
 public class ManyConfigResourceActivity extends Activity {
     @Override
-    protected void onCreate(@Nullable Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+    protected void onCreate(Bundle savedInstanceState) {
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
 
         for (int i = 0; i < 1000; i++) {
             getResources().getStringArray(R.array.many_configs);
         }
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 }
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleActivity.java
index 66d3f9aa9..f209c8def 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleActivity.java
@@ -16,7 +16,6 @@
 
 package com.android.performanceLaunch;
 
-import com.android.performanceLaunch.R;
 
 import android.app.Activity;
 import android.os.Bundle;
@@ -26,10 +25,9 @@ public class SimpleActivity extends Activity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_simple);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
-
 }
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleSurfaceGLActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleSurfaceGLActivity.java
index 3251b9fbf..75f953c27 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleSurfaceGLActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleSurfaceGLActivity.java
@@ -35,7 +35,7 @@ public class SimpleSurfaceGLActivity extends Activity {
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
 
         // Create a GLSurfaceView instance and set it
@@ -50,7 +50,7 @@ public class SimpleSurfaceGLActivity extends Activity {
                         return WindowInsets.CONSUMED;
                     });
         }
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 
     @Override
diff --git a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleWebViewActivity.java b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleWebViewActivity.java
index fd2ab25f7..8752c9930 100644
--- a/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleWebViewActivity.java
+++ b/tests/perf/PerformanceLaunch/src/com/android/performanceLaunch/SimpleWebViewActivity.java
@@ -28,13 +28,13 @@ public class SimpleWebViewActivity extends Activity {
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
-        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "onCreate");
+        Trace.beginSection("onCreate");
         super.onCreate(savedInstanceState);
         getWindow().requestFeature(Window.FEATURE_NO_TITLE);
         mWebView = new WebView(this);
         mWebView.loadUrl("file:///android_asset/SimpleWebView.html");
         this.setContentView(mWebView);
-        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        Trace.endSection();
     }
 
 }
diff --git a/utils/dpad/src/android/platform/test/utils/DPadUtil.java b/utils/dpad/src/android/platform/test/utils/DPadUtil.java
index 53a165a5f..0cacc284a 100644
--- a/utils/dpad/src/android/platform/test/utils/DPadUtil.java
+++ b/utils/dpad/src/android/platform/test/utils/DPadUtil.java
@@ -141,6 +141,7 @@ public class DPadUtil {
         return mDevice.pressBack();
     }
 
+    /** Long press the given keycode */
     @SuppressLint("DefaultLocale")
     public boolean longPressKeyCode(int keyCode) {
         try {
diff --git a/utils/dpad/src/android/platform/test/utils/DPadUtil2.java b/utils/dpad/src/android/platform/test/utils/DPadUtil2.java
index 69b37414a..065a54b44 100644
--- a/utils/dpad/src/android/platform/test/utils/DPadUtil2.java
+++ b/utils/dpad/src/android/platform/test/utils/DPadUtil2.java
@@ -137,6 +137,7 @@ public class DPadUtil2 {
         return mDevice.pressBack();
     }
 
+    /** Long press the given keycode */
     @SuppressWarnings("DefaultLocale")
     public boolean longPressKeyCode(int keyCode) {
         try {
```

