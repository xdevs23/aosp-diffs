```diff
diff --git a/.gitignore b/.gitignore
index 7035b25ab..d01643a43 100644
--- a/.gitignore
+++ b/.gitignore
@@ -294,22 +294,3 @@ TestResults.qpa
 .cache/
 compile_commands.json
 .gdb_history
-
-# Guest autogenerated files during builds
-guest/vulkan_enc/func_table.cpp
-guest/vulkan_enc/goldfish_vk_counting_guest.cpp
-guest/vulkan_enc/goldfish_vk_counting_guest.h
-guest/vulkan_enc/goldfish_vk_deepcopy_guest.cpp
-guest/vulkan_enc/goldfish_vk_deepcopy_guest.h
-guest/vulkan_enc/goldfish_vk_extension_structs_guest.cpp
-guest/vulkan_enc/goldfish_vk_extension_structs_guest.h
-guest/vulkan_enc/goldfish_vk_marshaling_guest.cpp
-guest/vulkan_enc/goldfish_vk_marshaling_guest.h
-guest/vulkan_enc/goldfish_vk_reserved_marshaling_guest.cpp
-guest/vulkan_enc/goldfish_vk_reserved_marshaling_guest.h
-guest/vulkan_enc/goldfish_vk_transform_guest.cpp
-guest/vulkan_enc/goldfish_vk_transform_guest.h
-guest/vulkan_enc/VkEncoder.cpp
-guest/vulkan_enc/VkEncoder.h
-guest/vulkan_enc/vulkan_gfxstream_structure_type.h
-guest/vulkan_enc/vulkan_gfxstream.h
diff --git a/Android.bp b/Android.bp
index a993c19db..212e9e090 100644
--- a/Android.bp
+++ b/Android.bp
@@ -134,6 +134,7 @@ cc_defaults {
         "gfxstream_cc_defaults",
     ],
     cflags: [
+        "-DGFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT=1",
         "-DGFXSTREAM_BUILD_WITH_TRACING=1",
     ] + select(soong_config_variable("gfxstream", "mesa3d_platforms"), {
         // Android surfaceless build
@@ -143,6 +144,13 @@ cc_defaults {
         // The default when variable is not set is Android
         default: [],
     }),
+    target: {
+        host: {
+            cflags: [
+                "-DGFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT=1",
+            ],
+        }
+    }
 }
 
 cc_defaults {
@@ -155,7 +163,6 @@ cc_defaults {
         "-D_FILE_OFFSET_BITS=64",
         "-DVK_GFXSTREAM_STRUCTURE_TYPE_EXT",
         "-DGFXSTREAM_ENABLE_HOST_GLES=1",
-        "-DGFXSTREAM_ENABLE_HOST_VK_SNAPSHOT=1",
         "-Wno-unreachable-code-loop-increment",
         "-Wno-unused-parameter",
         "-Wno-unused-function",
diff --git a/OWNERS b/OWNERS
index c16651d38..19e53eb80 100644
--- a/OWNERS
+++ b/OWNERS
@@ -6,4 +6,3 @@ mprzybyl@google.com
 msandy@google.com
 natsu@google.com
 sergiuferentz@google.com
-yahan@google.com
diff --git a/codegen/vulkan/vulkan-docs-next/xml/vk.xml b/codegen/vulkan/vulkan-docs-next/xml/vk.xml
new file mode 100644
index 000000000..f02aac088
--- /dev/null
+++ b/codegen/vulkan/vulkan-docs-next/xml/vk.xml
@@ -0,0 +1,26232 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<registry>
+    <comment>
+Copyright 2015-2023 The Khronos Group Inc.
+
+SPDX-License-Identifier: Apache-2.0 OR MIT
+    </comment>
+
+    <comment>
+This file, vk.xml, is the Vulkan API Registry. It is a critically important
+and normative part of the Vulkan Specification, including a canonical
+machine-readable definition of the API, parameter and member validation
+language incorporated into the Specification and reference pages, and other
+material which is registered by Khronos, such as tags used by extension and
+layer authors. The authoritative public version of vk.xml is maintained in
+the default branch (currently named main) of the Khronos Vulkan GitHub
+project. The authoritative private version is maintained in the default
+branch of the member gitlab server.
+    </comment>
+
+    <platforms comment="Vulkan platform names, reserved for use with platform- and window system-specific extensions">
+        <platform name="xlib" protect="VK_USE_PLATFORM_XLIB_KHR" comment="X Window System, Xlib client library"/>
+        <platform name="xlib_xrandr" protect="VK_USE_PLATFORM_XLIB_XRANDR_EXT" comment="X Window System, Xlib client library, XRandR extension"/>
+        <platform name="xcb" protect="VK_USE_PLATFORM_XCB_KHR" comment="X Window System, Xcb client library"/>
+        <platform name="wayland" protect="VK_USE_PLATFORM_WAYLAND_KHR" comment="Wayland display server protocol"/>
+        <platform name="directfb" protect="VK_USE_PLATFORM_DIRECTFB_EXT" comment="DirectFB library"/>
+        <platform name="android" protect="VK_USE_PLATFORM_ANDROID_KHR" comment="Android OS"/>
+        <platform name="win32" protect="VK_USE_PLATFORM_WIN32_KHR" comment="Microsoft Win32 API (also refers to Win64 apps)"/>
+        <platform name="vi" protect="VK_USE_PLATFORM_VI_NN" comment="Nintendo Vi"/>
+        <platform name="ios" protect="VK_USE_PLATFORM_IOS_MVK" comment="Apple IOS"/>
+        <platform name="macos" protect="VK_USE_PLATFORM_MACOS_MVK" comment="Apple MacOS"/>
+        <platform name="metal" protect="VK_USE_PLATFORM_METAL_EXT" comment="Metal on CoreAnimation on Apple platforms"/>
+        <platform name="fuchsia" protect="VK_USE_PLATFORM_FUCHSIA" comment="Fuchsia"/>
+        <platform name="ggp" protect="VK_USE_PLATFORM_GGP" comment="Google Games Platform"/>
+        <platform name="sci" protect="VK_USE_PLATFORM_SCI" comment="NVIDIA SCI"/>
+        <platform name="provisional" protect="VK_ENABLE_BETA_EXTENSIONS" comment="Enable declarations for beta/provisional extensions"/>
+        <platform name="screen" protect="VK_USE_PLATFORM_SCREEN_QNX" comment="QNX Screen Graphics Subsystem"/>
+    </platforms>
+
+    <tags comment="Vulkan vendor/author tags for extensions and layers">
+        <tag name="IMG"         author="Imagination Technologies"      contact="Andrew Garrard @fluppeteer"/>
+        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
+        <tag name="AMDX"        author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
+        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharaldfredriksen-arm"/>
+        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
+        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
+        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
+        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
+        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
+        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang gitlab:@yanjunzhang"/>
+        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang gitlab:@yanjunzhang"/>
+        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
+        <tag name="ANDROID"     author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="CHROMIUM"    author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="FUCHSIA"     author="Google LLC"                    contact="Craig Stout @cdotstout, Jesse Hall @critsec, John Rosasco @rosasco"/>
+        <tag name="GGP"         author="Google, LLC"                   contact="Jean-Francois Roy @jfroy, Hai Nguyen @chaoticbob, Jesse Hall @critsec"/>
+        <tag name="GOOGLE"      author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Jeff Leger @jackohounhd"/>
+        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @karenghavam-lunarg"/>
+        <tag name="NZXT"        author="NZXT Inc."                     contact="Jacob Kiesel @xaeroxe"/>
+        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="Baldur Karlsson @baldurk"/>
+        <tag name="NN"          author="Nintendo Co., Ltd."            contact="Yasuhiro Yoshioka gitlab:@yoshioka_yasuhiro"/>
+        <tag name="MVK"         author="The Brenwill Workshop Ltd."    contact="Bill Hollings @billhollings"/>
+        <tag name="KHR"         author="Khronos"                       contact="Tom Olson @tomolson"/>
+        <tag name="KHX"         author="Khronos"                       contact="Tom Olson @tomolson"/>
+        <tag name="EXT"         author="Multivendor"                   contact="Jon Leech @oddhack"/>
+        <tag name="MESA"        author="Mesa open source project"      contact="Lina Versace @versalinyaa, Daniel Stone @fooishbar, David Airlie @airlied, Faith Ekstrand @gfxstrand"/>
+        <tag name="INTEL"       author="Intel Corporation"             contact="Slawek Grajewski @sgrajewski"/>
+        <tag name="HUAWEI"      author="Huawei Technologies Co. Ltd."  contact="Pan Gao @PanGao-h, Juntao Li @Lawrenceleehw"/>
+        <tag name="VALVE"       author="Valve Corporation"             contact="Pierre-Loup Griffais @plagman, Joshua Ashton @Joshua-Ashton, Hans-Kristian Arntzen @HansKristian-Work"/>
+        <tag name="QNX"         author="BlackBerry Limited"            contact="Mike Gorchak @mgorchak-blackberry, Aaron Ruby @aruby-blackberry"/>
+        <tag name="JUICE"       author="Juice Technologies, Inc."      contact="David McCloskey @damcclos, Dean Beeler @canadacow"/>
+        <tag name="FB"          author="Facebook, Inc"                 contact="Artem Bolgar @artyom17"/>
+        <tag name="RASTERGRID"  author="RasterGrid Kft."               contact="Daniel Rakos @aqnuep"/>
+        <tag name="MSFT"        author="Microsoft Corporation"         contact="Jesse Natalie @jenatali"/>
+    </tags>
+
+    <types comment="Vulkan type definitions">
+        <type name="vk_platform" category="include">#include "vk_platform.h"</type>
+
+            <comment>WSI extensions</comment>
+
+        <type category="include" name="X11/Xlib.h"/>
+        <type category="include" name="X11/extensions/Xrandr.h"/>
+        <type category="include" name="wayland-client.h"/>
+        <type category="include" name="windows.h"/>
+        <type category="include" name="xcb/xcb.h"/>
+        <type category="include" name="directfb.h"/>
+        <type category="include" name="zircon/types.h"/>
+        <type category="include" name="ggp_c/vulkan_types.h"/>
+        <type category="include" name="screen/screen.h"/>
+        <type category="include" name="nvscisync.h"/>
+        <type category="include" name="nvscibuf.h"/>
+            <comment>
+                In the current header structure, each platform's interfaces
+                are confined to a platform-specific header (vulkan_xlib.h,
+                vulkan_win32.h, etc.). These headers are not self-contained,
+                and should not include native headers (X11/Xlib.h,
+                windows.h, etc.). Code should either include vulkan.h after
+                defining the appropriate VK_USE_PLATFORM_platform
+                macros, or include the required native headers prior to
+                explicitly including the corresponding platform header.
+
+                To accomplish this, the dependencies of native types require
+                native headers, but the XML defines the content for those
+                native headers as empty. The actual native header includes
+                can be restored by modifying the native header tags above
+                to #include the header file in the 'name' attribute.
+            </comment>
+
+        <type requires="X11/Xlib.h" name="Display"/>
+        <type requires="X11/Xlib.h" name="VisualID"/>
+        <type requires="X11/Xlib.h" name="Window"/>
+        <type requires="X11/extensions/Xrandr.h" name="RROutput"/>
+        <type requires="wayland-client.h" name="wl_display"/>
+        <type requires="wayland-client.h" name="wl_surface"/>
+        <type requires="windows.h" name="HINSTANCE"/>
+        <type requires="windows.h" name="HWND"/>
+        <type requires="windows.h" name="HMONITOR"/>
+        <type requires="windows.h" name="HANDLE"/>
+        <type requires="windows.h" name="SECURITY_ATTRIBUTES"/>
+        <type requires="windows.h" name="DWORD"/>
+        <type requires="windows.h" name="LPCWSTR"/>
+        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
+        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
+        <type requires="xcb/xcb.h" name="xcb_window_t"/>
+        <type requires="directfb.h" name="IDirectFB"/>
+        <type requires="directfb.h" name="IDirectFBSurface"/>
+        <type requires="zircon/types.h" name="zx_handle_t"/>
+        <type requires="ggp_c/vulkan_types.h" name="GgpStreamDescriptor"/>
+        <type requires="ggp_c/vulkan_types.h" name="GgpFrameToken"/>
+        <type requires="screen/screen.h" name="_screen_context"/>
+        <type requires="screen/screen.h" name="_screen_window"/>
+        <type requires="screen/screen.h" name="_screen_buffer"/>
+        <type requires="nvscisync.h" name="NvSciSyncAttrList"/>
+        <type requires="nvscisync.h" name="NvSciSyncObj"/>
+        <type requires="nvscisync.h" name="NvSciSyncFence"/>
+        <type requires="nvscibuf.h" name="NvSciBufAttrList"/>
+        <type requires="nvscibuf.h" name="NvSciBufObj"/>
+
+        <type category="define" deprecated="true">// DEPRECATED: This define is deprecated. VK_MAKE_API_VERSION should be used instead.
+#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
+    ((((uint32_t)(major)) &lt;&lt; 22U) | (((uint32_t)(minor)) &lt;&lt; 12U) | ((uint32_t)(patch)))</type>
+        <type category="define" deprecated="true">// DEPRECATED: This define is deprecated. VK_API_VERSION_MAJOR should be used instead.
+#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22U)</type>
+        <type category="define" deprecated="true">// DEPRECATED: This define is deprecated. VK_API_VERSION_MINOR should be used instead.
+#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12U) &amp; 0x3FFU)</type>
+        <type category="define" deprecated="true">// DEPRECATED: This define is deprecated. VK_API_VERSION_PATCH should be used instead.
+#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>
+
+        <type category="define">#define <name>VK_MAKE_API_VERSION</name>(variant, major, minor, patch) \
+    ((((uint32_t)(variant)) &lt;&lt; 29U) | (((uint32_t)(major)) &lt;&lt; 22U) | (((uint32_t)(minor)) &lt;&lt; 12U) | ((uint32_t)(patch)))</type>
+        <type category="define">#define <name>VK_API_VERSION_VARIANT</name>(version) ((uint32_t)(version) &gt;&gt; 29U)</type>
+        <type category="define">#define <name>VK_API_VERSION_MAJOR</name>(version) (((uint32_t)(version) &gt;&gt; 22U) &amp; 0x7FU)</type>
+        <type category="define">#define <name>VK_API_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12U) &amp; 0x3FFU)</type>
+        <type category="define">#define <name>VK_API_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>
+
+        <type category="define" requires="VK_HEADER_VERSION">// Vulkan SC variant number
+#define <name>VKSC_API_VARIANT</name> 1</type>
+
+        <type category="define">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
+//#define <name>VK_API_VERSION</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 0, 0) // Patch version should always be set to 0</type>
+        <type category="define">// Vulkan 1.0 version number
+#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 0, 0)// Patch version should always be set to 0</type>
+        <type category="define">// Vulkan 1.1 version number
+#define <name>VK_API_VERSION_1_1</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 1, 0)// Patch version should always be set to 0</type>
+        <type category="define">// Vulkan 1.2 version number
+#define <name>VK_API_VERSION_1_2</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 2, 0)// Patch version should always be set to 0</type>
+        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.3 version number
+#define <name>VK_API_VERSION_1_3</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 3, 0)// Patch version should always be set to 0</type>
+        <type category="define" requires="VKSC_API_VARIANT">// Vulkan SC 1.0 version number
+#define <name>VKSC_API_VERSION_1_0</name> <type>VK_MAKE_API_VERSION</type>(VKSC_API_VARIANT, 1, 0, 0)// Patch version should always be set to 0</type>
+
+        <type api="vulkan" category="define">// Version of this file
+#define <name>VK_HEADER_VERSION</name> 269</type>
+        <type api="vulkan" category="define" requires="VK_HEADER_VERSION">// Complete version of this file
+#define <name>VK_HEADER_VERSION_COMPLETE</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 3, VK_HEADER_VERSION)</type>
+        <type api="vulkansc" category="define">// Version of this file
+#define <name>VK_HEADER_VERSION</name> 13</type>
+        <type api="vulkansc" category="define" requires="VKSC_API_VARIANT">// Complete version of this file
+#define <name>VK_HEADER_VERSION_COMPLETE</name> <type>VK_MAKE_API_VERSION</type>(VKSC_API_VARIANT, 1, 0, VK_HEADER_VERSION)</type>
+
+        <type api="vulkan" category="define">
+#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>
+        <type api="vulkansc" category="define" comment="Extra parenthesis are a MISRA-C requirement that exposes a bug in MSVC">
+#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* (object);</type>
+
+        <type category="define" name="VK_USE_64_BIT_PTR_DEFINES">
+#ifndef VK_USE_64_BIT_PTR_DEFINES
+    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__) || (defined(__riscv) &amp;&amp; __riscv_xlen == 64)
+        #define VK_USE_64_BIT_PTR_DEFINES 1
+    #else
+        #define VK_USE_64_BIT_PTR_DEFINES 0
+    #endif
+#endif</type>
+        <type category="define" requires="VK_USE_64_BIT_PTR_DEFINES" name="VK_NULL_HANDLE">
+#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #if (defined(__cplusplus) &amp;&amp; (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG >= 201103L))
+            #define VK_NULL_HANDLE nullptr
+        #else
+            #define VK_NULL_HANDLE ((void*)0)
+        #endif
+    #else
+        #define VK_NULL_HANDLE 0ULL
+    #endif
+#endif
+#ifndef VK_NULL_HANDLE
+    #define VK_NULL_HANDLE 0
+#endif</type>
+        <type api="vulkan" category="define" requires="VK_NULL_HANDLE" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
+#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
+    #else
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
+    #endif
+#endif</type>
+        <type api="vulkansc" category="define" requires="VK_NULL_HANDLE" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE" comment="Extra parenthesis are a MISRA-C requirement that exposes a bug in MSVC">
+#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *(object);
+    #else
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t (object);
+    #endif
+#endif</type>
+
+        <type category="basetype">struct <name>ANativeWindow</name>;</type>
+        <type category="basetype">struct <name>AHardwareBuffer</name>;</type>
+        <type category="basetype">#ifdef __OBJC__
+@class CAMetalLayer;
+#else
+typedef void <name>CAMetalLayer</name>;
+#endif</type>
+        <type category="basetype">#ifdef __OBJC__
+@protocol MTLDevice;
+typedef id&lt;MTLDevice&gt; MTLDevice_id;
+#else
+typedef void* <name>MTLDevice_id</name>;
+#endif</type>
+        <type category="basetype">#ifdef __OBJC__
+@protocol MTLCommandQueue;
+typedef id&lt;MTLCommandQueue&gt; MTLCommandQueue_id;
+#else
+typedef void* <name>MTLCommandQueue_id</name>;
+#endif</type>
+        <type category="basetype">#ifdef __OBJC__
+@protocol MTLBuffer;
+typedef id&lt;MTLBuffer&gt; MTLBuffer_id;
+#else
+typedef void* <name>MTLBuffer_id</name>;
+#endif</type>
+        <type category="basetype">#ifdef __OBJC__
+@protocol MTLTexture;
+typedef id&lt;MTLTexture&gt; MTLTexture_id;
+#else
+typedef void* <name>MTLTexture_id</name>;
+#endif</type>
+        <type category="basetype">#ifdef __OBJC__
+@protocol MTLSharedEvent;
+typedef id&lt;MTLSharedEvent&gt; MTLSharedEvent_id;
+#else
+typedef void* <name>MTLSharedEvent_id</name>;
+#endif</type>
+        <type category="basetype">typedef struct __IOSurface* <name>IOSurfaceRef</name>;</type>
+
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkFlags64</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceAddress</name>;</type>
+
+            <comment>Basic C types, pulled in via vk_platform.h</comment>
+        <type requires="vk_platform" name="void"/>
+        <type requires="vk_platform" name="char"/>
+        <type requires="vk_platform" name="float"/>
+        <type requires="vk_platform" name="double"/>
+        <type requires="vk_platform" name="int8_t"/>
+        <type requires="vk_platform" name="uint8_t"/>
+        <type requires="vk_platform" name="int16_t"/>
+        <type requires="vk_platform" name="uint16_t"/>
+        <type requires="vk_platform" name="uint32_t"/>
+        <type requires="vk_platform" name="uint64_t"/>
+        <type requires="vk_platform" name="int32_t"/>
+        <type requires="vk_platform" name="int64_t"/>
+        <type requires="vk_platform" name="size_t"/>
+        <type name="int"/>
+
+            <comment>Bitmask types</comment>
+        <type requires="VkFramebufferCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>
+        <type requires="VkRenderPassCreateFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>
+        <type requires="VkSamplerCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>
+        <type requires="VkPipelineLayoutCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>
+        <type requires="VkPipelineCacheCreateFlagBits"    category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>
+        <type api="vulkan" requires="VkPipelineDepthStencilStateCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
+        <type api="vulkansc" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>
+        <type api="vulkan" requires="VkPipelineColorBlendStateCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
+        <type api="vulkansc" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>
+        <type requires="VkPipelineShaderStageCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>
+        <type requires="VkDescriptorSetLayoutCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>
+        <type requires="VkInstanceCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>
+        <type requires="VkDeviceQueueCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>
+        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>
+        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>
+        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>
+        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>
+        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>
+        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>
+        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>
+        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>
+        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>
+        <type requires="VkImageViewCreateFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>
+        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>
+        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>
+        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>
+        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>
+        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>
+        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>
+        <type requires="VkEventCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>
+        <type requires="VkCommandPoolCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>
+        <type requires="VkCommandPoolResetFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>
+        <type requires="VkCommandBufferResetFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>
+        <type requires="VkCommandBufferUsageFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>
+        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryUnmapFlagsKHR</name>;</type>
+        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>
+        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>
+        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>
+        <type requires="VkSubpassDescriptionFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>
+        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>
+        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>
+        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>
+        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>
+        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>
+        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>
+        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>
+        <type requires="VkSubgroupFeatureFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkSubgroupFeatureFlags</name>;</type>
+        <type requires="VkIndirectCommandsLayoutUsageFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsNV</name>;</type>
+        <type requires="VkIndirectStateFlagBitsNV"        category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectStateFlagsNV</name>;</type>
+        <type requires="VkGeometryFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkGeometryFlagsNV" alias="VkGeometryFlagsKHR"/>
+        <type requires="VkGeometryInstanceFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryInstanceFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkGeometryInstanceFlagsNV" alias="VkGeometryInstanceFlagsKHR"/>
+        <type requires="VkBuildAccelerationStructureFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildAccelerationStructureFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkBuildAccelerationStructureFlagsNV" alias="VkBuildAccelerationStructureFlagsKHR"/>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPrivateDataSlotCreateFlags</name>;</type>
+        <type                                             category="bitmask" name="VkPrivateDataSlotCreateFlagsEXT" alias="VkPrivateDataSlotCreateFlags"/>
+        <type requires="VkAccelerationStructureCreateFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorUpdateTemplateCreateFlags</name>;</type>
+        <type                                             category="bitmask" name="VkDescriptorUpdateTemplateCreateFlagsKHR" alias="VkDescriptorUpdateTemplateCreateFlags"/>
+        <type requires="VkPipelineCreationFeedbackFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreationFeedbackFlags</name>;</type>
+        <type                                             category="bitmask" name="VkPipelineCreationFeedbackFlagsEXT" alias="VkPipelineCreationFeedbackFlags"/>
+        <type requires="VkPerformanceCounterDescriptionFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkPerformanceCounterDescriptionFlagsKHR</name>;</type>
+        <type requires="VkAcquireProfilingLockFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAcquireProfilingLockFlagsKHR</name>;</type>
+        <type requires="VkSemaphoreWaitFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreWaitFlags</name>;</type>
+        <type                                             category="bitmask" name="VkSemaphoreWaitFlagsKHR" alias="VkSemaphoreWaitFlags"/>
+        <type requires="VkPipelineCompilerControlFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCompilerControlFlagsAMD</name>;</type>
+        <type requires="VkShaderCorePropertiesFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCorePropertiesFlagsAMD</name>;</type>
+        <type requires="VkDeviceDiagnosticsConfigFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceDiagnosticsConfigFlagsNV</name>;</type>
+        <type requires="VkRefreshObjectFlagBitsKHR"       category="bitmask">typedef <type>VkFlags</type> <name>VkRefreshObjectFlagsKHR</name>;</type>
+        <type bitvalues="VkAccessFlagBits2"               category="bitmask">typedef <type>VkFlags64</type> <name>VkAccessFlags2</name>;</type>
+        <type                                             category="bitmask" name="VkAccessFlags2KHR" alias="VkAccessFlags2"/>
+        <type bitvalues="VkPipelineStageFlagBits2"        category="bitmask">typedef <type>VkFlags64</type> <name>VkPipelineStageFlags2</name>;</type>
+        <type                                             category="bitmask" name="VkPipelineStageFlags2KHR" alias="VkPipelineStageFlags2"/>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInfoFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInstanceFlagsNV</name>;</type>
+        <type bitvalues="VkFormatFeatureFlagBits2"        category="bitmask">typedef <type>VkFlags64</type> <name>VkFormatFeatureFlags2</name>;</type>
+        <type                                             category="bitmask" name="VkFormatFeatureFlags2KHR" alias="VkFormatFeatureFlags2"/>
+        <type requires="VkRenderingFlagBits"              category="bitmask">typedef <type>VkFlags</type> <name>VkRenderingFlags</name>;</type>
+        <type bitvalues="VkMemoryDecompressionMethodFlagBitsNV" category="bitmask">typedef <type>VkFlags64</type> <name>VkMemoryDecompressionMethodFlagsNV</name>;</type>
+        <type                                             category="bitmask" name="VkRenderingFlagsKHR" alias="VkRenderingFlags"/>
+        <type requires="VkBuildMicromapFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildMicromapFlagsEXT</name>;</type>
+        <type requires="VkMicromapCreateFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkMicromapCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDirectDriverLoadingFlagsLUNARG</name>;</type>
+        <type bitvalues="VkPipelineCreateFlagBits2KHR"    category="bitmask">typedef <type>VkFlags64</type> <name>VkPipelineCreateFlags2KHR</name>;</type>
+        <type bitvalues="VkBufferUsageFlagBits2KHR"       category="bitmask">typedef <type>VkFlags64</type> <name>VkBufferUsageFlags2KHR</name>;</type>
+
+            <comment>WSI extensions</comment>
+        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
+        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
+        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
+        <type requires="VkSwapchainCreateFlagBitsKHR"     category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkViSurfaceCreateFlagsNN</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDirectFBSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkIOSSurfaceCreateFlagsMVK</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMacOSSurfaceCreateFlagsMVK</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMetalSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImagePipeSurfaceCreateFlagsFUCHSIA</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkStreamDescriptorSurfaceCreateFlagsGGP</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkHeadlessSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkScreenSurfaceCreateFlagsQNX</name>;</type>
+        <type requires="VkPeerMemoryFeatureFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkPeerMemoryFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkPeerMemoryFeatureFlagsKHR"               alias="VkPeerMemoryFeatureFlags"/>
+        <type requires="VkMemoryAllocateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryAllocateFlags</name>;</type>
+        <type                                             category="bitmask" name="VkMemoryAllocateFlagsKHR"                  alias="VkMemoryAllocateFlags"/>
+        <type requires="VkDeviceGroupPresentModeFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceGroupPresentModeFlagsKHR</name>;</type>
+
+        <type requires="VkDebugReportFlagBitsEXT"         category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolTrimFlags</name>;</type>
+        <type                                             category="bitmask" name="VkCommandPoolTrimFlagsKHR"                 alias="VkCommandPoolTrimFlags"/>
+        <type requires="VkExternalMemoryHandleTypeFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlagsNV</name>;</type>
+        <type requires="VkExternalMemoryFeatureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlagsNV</name>;</type>
+        <type requires="VkExternalMemoryHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalMemoryHandleTypeFlagsKHR"        alias="VkExternalMemoryHandleTypeFlags"/>
+        <type requires="VkExternalMemoryFeatureFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalMemoryFeatureFlagsKHR"           alias="VkExternalMemoryFeatureFlags"/>
+        <type requires="VkExternalSemaphoreHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalSemaphoreHandleTypeFlagsKHR"     alias="VkExternalSemaphoreHandleTypeFlags"/>
+        <type requires="VkExternalSemaphoreFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalSemaphoreFeatureFlagsKHR"        alias="VkExternalSemaphoreFeatureFlags"/>
+        <type requires="VkSemaphoreImportFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreImportFlags</name>;</type>
+        <type                                             category="bitmask" name="VkSemaphoreImportFlagsKHR"                 alias="VkSemaphoreImportFlags"/>
+        <type requires="VkExternalFenceHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalFenceHandleTypeFlagsKHR"         alias="VkExternalFenceHandleTypeFlags"/>
+        <type requires="VkExternalFenceFeatureFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalFenceFeatureFlagsKHR"            alias="VkExternalFenceFeatureFlags"/>
+        <type requires="VkFenceImportFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceImportFlags</name>;</type>
+        <type                                             category="bitmask" name="VkFenceImportFlagsKHR"                     alias="VkFenceImportFlags"/>
+        <type requires="VkSurfaceCounterFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceCounterFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportSwizzleStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDiscardRectangleStateCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageToColorStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageModulationStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageReductionStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkValidationCacheCreateFlagsEXT</name>;</type>
+        <type requires="VkDebugUtilsMessageSeverityFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageSeverityFlagsEXT</name>;</type>
+        <type requires="VkDebugUtilsMessageTypeFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageTypeFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCallbackDataFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceMemoryReportFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationConservativeStateCreateFlagsEXT</name>;</type>
+        <type requires="VkDescriptorBindingFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorBindingFlags</name>;</type>
+        <type                                             category="bitmask" name="VkDescriptorBindingFlagsEXT"               alias="VkDescriptorBindingFlags"/>
+        <type requires="VkConditionalRenderingFlagBitsEXT"  category="bitmask">typedef <type>VkFlags</type> <name>VkConditionalRenderingFlagsEXT</name>;</type>
+        <type requires="VkResolveModeFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkResolveModeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkResolveModeFlagsKHR"                     alias="VkResolveModeFlags"/>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateStreamCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</name>;</type>
+        <type requires="VkSwapchainImageUsageFlagBitsANDROID" category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainImageUsageFlagsANDROID</name>;</type>
+        <type requires="VkToolPurposeFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkToolPurposeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkToolPurposeFlagsEXT"                     alias="VkToolPurposeFlags"/>
+        <type requires="VkSubmitFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkSubmitFlags</name>;</type>
+        <type                                             category="bitmask" name="VkSubmitFlagsKHR"                          alias="VkSubmitFlags"/>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImageFormatConstraintsFlagsFUCHSIA</name>;</type>
+        <type requires="VkHostImageCopyFlagBitsEXT"       category="bitmask">typedef <type>VkFlags</type> <name>VkHostImageCopyFlagsEXT</name>;</type>
+        <type requires="VkImageConstraintsInfoFlagBitsFUCHSIA"   category="bitmask">typedef <type>VkFlags</type> <name>VkImageConstraintsInfoFlagsFUCHSIA</name>;</type>
+        <type requires="VkGraphicsPipelineLibraryFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkGraphicsPipelineLibraryFlagsEXT</name>;</type>
+        <type requires="VkImageCompressionFlagBitsEXT"          category="bitmask">typedef <type>VkFlags</type> <name>VkImageCompressionFlagsEXT</name>;</type>
+        <type requires="VkImageCompressionFixedRateFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkImageCompressionFixedRateFlagsEXT</name>;</type>
+        <type requires="VkExportMetalObjectTypeFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkExportMetalObjectTypeFlagsEXT</name>;</type>
+        <type requires="VkDeviceAddressBindingFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceAddressBindingFlagsEXT</name>;</type>
+        <type requires="VkOpticalFlowGridSizeFlagBitsNV"        category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowGridSizeFlagsNV</name>;</type>
+        <type requires="VkOpticalFlowUsageFlagBitsNV"           category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowUsageFlagsNV</name>;</type>
+        <type requires="VkOpticalFlowSessionCreateFlagBitsNV"   category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowSessionCreateFlagsNV</name>;</type>
+        <type requires="VkOpticalFlowExecuteFlagBitsNV"         category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowExecuteFlagsNV</name>;</type>
+        <type requires="VkFrameBoundaryFlagBitsEXT"       category="bitmask">typedef <type>VkFlags</type> <name>VkFrameBoundaryFlagsEXT</name>;</type>
+        <type requires="VkPresentScalingFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPresentScalingFlagsEXT</name>;</type>
+        <type requires="VkPresentGravityFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPresentGravityFlagsEXT</name>;</type>
+        <type requires="VkShaderCreateFlagBitsEXT"        category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCreateFlagsEXT</name>;</type>
+        <type bitvalues="VkPhysicalDeviceSchedulingControlsFlagBitsARM" category="bitmask">typedef <type>VkFlags64</type> <name>VkPhysicalDeviceSchedulingControlsFlagsARM</name>;</type>
+
+            <comment>Video Core extension</comment>
+        <type requires="VkVideoCodecOperationFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodecOperationFlagsKHR</name>;</type>
+        <type requires="VkVideoCapabilityFlagBitsKHR"               category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCapabilityFlagsKHR</name>;</type>
+        <type requires="VkVideoSessionCreateFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoSessionCreateFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoSessionParametersCreateFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoBeginCodingFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEndCodingFlagsKHR</name>;</type>
+        <type requires="VkVideoCodingControlFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodingControlFlagsKHR</name>;</type>
+
+            <comment>Video Decode Core extension</comment>
+        <type requires="VkVideoDecodeUsageFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeUsageFlagsKHR</name>;</type>
+        <type requires="VkVideoDecodeCapabilityFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeCapabilityFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeFlagsKHR</name>;</type>
+
+            <comment>Video Decode H.264 extension</comment>
+        <type requires="VkVideoDecodeH264PictureLayoutFlagBitsKHR"  category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeH264PictureLayoutFlagsKHR</name>;</type>
+
+            <comment>Video Encode Core extension</comment>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeUsageFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeUsageFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeContentFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeContentFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeCapabilityFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeCapabilityFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeFeedbackFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeFeedbackFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeRateControlModeFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlModeFlagsKHR</name>;</type>
+        <type requires="VkVideoChromaSubsamplingFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoChromaSubsamplingFlagsKHR</name>;</type>
+        <type requires="VkVideoComponentBitDepthFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoComponentBitDepthFlagsKHR</name>;</type>
+
+            <comment>Video Encode H.264 extension</comment>
+        <type requires="VkVideoEncodeH264CapabilityFlagBitsEXT"             category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264CapabilityFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH264StdFlagBitsEXT"                    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264StdFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH264RateControlFlagBitsEXT"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264RateControlFlagsEXT</name>;</type>
+
+            <comment>Video Encode H.265 extension</comment>
+        <type requires="VkVideoEncodeH265CapabilityFlagBitsEXT"             category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CapabilityFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265StdFlagBitsEXT"                    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265StdFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265RateControlFlagBitsEXT"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265RateControlFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265CtbSizeFlagBitsEXT"                category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CtbSizeFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265TransformBlockSizeFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265TransformBlockSizeFlagsEXT</name>;</type>
+
+            <comment>Types which can be void pointers or class pointers, selected at compile time</comment>
+        <type category="handle"                           objtypeenum="VK_OBJECT_TYPE_INSTANCE"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_PHYSICAL_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
+        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUEUE"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
+        <type category="handle" parent="VkCommandPool"    objtypeenum="VK_OBJECT_TYPE_COMMAND_BUFFER"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEVICE_MEMORY"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_COMMAND_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SHADER_MODULE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
+        <type category="handle" parent="VkDescriptorPool" objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FENCE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SEMAPHORE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_EVENT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUERY_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FRAMEBUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_RENDER_PASS"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_CACHE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutNV</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorUpdateTemplate</name>)</type>
+        <type category="handle" name="VkDescriptorUpdateTemplateKHR" alias="VkDescriptorUpdateTemplate"/>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSamplerYcbcrConversion</name>)</type>
+        <type category="handle" name="VkSamplerYcbcrConversionKHR"   alias="VkSamplerYcbcrConversion"/>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkValidationCacheEXT</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureKHR</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureNV</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPerformanceConfigurationINTEL</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferCollectionFUCHSIA</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeferredOperationKHR</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPrivateDataSlot</name>)</type>
+        <type category="handle" name="VkPrivateDataSlotEXT"          alias="VkPrivateDataSlot"/>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_MODULE_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuModuleNVX</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_FUNCTION_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuFunctionNVX</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkOpticalFlowSessionNV</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_MICROMAP_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkMicromapEXT</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SHADER_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderEXT</name>)</type>
+
+            <comment>WSI extensions</comment>
+        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DISPLAY_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
+        <type category="handle" parent="VkDisplayKHR"     objtypeenum="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_SURFACE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SWAPCHAIN_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugUtilsMessengerEXT</name>)</type>
+
+            <comment>Video extensions</comment>
+        <type category="handle" parent="VkDevice"          objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionKHR</name>)</type>
+        <type category="handle" parent="VkVideoSessionKHR" objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionParametersKHR</name>)</type>
+
+            <comment>VK_NV_external_sci_sync2</comment>
+        <type category="handle" parent="VkDevice"          objtypeenum="VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphoreSciSyncPoolNV</name>)</type>
+
+            <comment>Types generated from corresponding enums tags below</comment>
+        <type name="VkAttachmentLoadOp" category="enum"/>
+        <type name="VkAttachmentStoreOp" category="enum"/>
+        <type name="VkBlendFactor" category="enum"/>
+        <type name="VkBlendOp" category="enum"/>
+        <type name="VkBorderColor" category="enum"/>
+        <type name="VkFramebufferCreateFlagBits" category="enum"/>
+        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
+        <type name="VkRenderPassCreateFlagBits" category="enum"/>
+        <type name="VkSamplerCreateFlagBits" category="enum"/>
+        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
+        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
+        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
+        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
+        <type name="VkInstanceCreateFlagBits" category="enum"/>
+        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
+        <type name="VkBufferCreateFlagBits" category="enum"/>
+        <type name="VkBufferUsageFlagBits" category="enum"/>
+        <type name="VkColorComponentFlagBits" category="enum"/>
+        <type name="VkComponentSwizzle" category="enum"/>
+        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
+        <type name="VkCommandPoolResetFlagBits" category="enum"/>
+        <type name="VkCommandBufferResetFlagBits" category="enum"/>
+        <type name="VkCommandBufferLevel" category="enum"/>
+        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
+        <type name="VkCompareOp" category="enum"/>
+        <type name="VkCullModeFlagBits" category="enum"/>
+        <type name="VkDescriptorType" category="enum"/>
+        <type name="VkDeviceCreateFlagBits" category="enum"/>
+        <type name="VkDynamicState" category="enum"/>
+        <type name="VkFenceCreateFlagBits" category="enum"/>
+        <type name="VkPolygonMode" category="enum"/>
+        <type name="VkFormat" category="enum"/>
+        <type name="VkFormatFeatureFlagBits" category="enum"/>
+        <type name="VkFrontFace" category="enum"/>
+        <type name="VkImageAspectFlagBits" category="enum"/>
+        <type name="VkImageCreateFlagBits" category="enum"/>
+        <type name="VkImageLayout" category="enum"/>
+        <type name="VkImageTiling" category="enum"/>
+        <type name="VkImageType" category="enum"/>
+        <type name="VkImageUsageFlagBits" category="enum"/>
+        <type name="VkImageViewCreateFlagBits" category="enum"/>
+        <type name="VkImageViewType" category="enum"/>
+        <type name="VkSharingMode" category="enum"/>
+        <type name="VkIndexType" category="enum"/>
+        <type name="VkLogicOp" category="enum"/>
+        <type name="VkMemoryHeapFlagBits" category="enum"/>
+        <type name="VkAccessFlagBits" category="enum"/>
+        <type name="VkMemoryPropertyFlagBits" category="enum"/>
+        <type name="VkPhysicalDeviceType" category="enum"/>
+        <type name="VkPipelineBindPoint" category="enum"/>
+        <type name="VkPipelineCreateFlagBits" category="enum"/>
+        <type name="VkPrimitiveTopology" category="enum"/>
+        <type name="VkQueryControlFlagBits" category="enum"/>
+        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
+        <type name="VkQueryResultFlagBits" category="enum"/>
+        <type name="VkQueryType" category="enum"/>
+        <type name="VkQueueFlagBits" category="enum"/>
+        <type name="VkSubpassContents" category="enum"/>
+        <type name="VkResult" category="enum"/>
+        <type name="VkShaderStageFlagBits" category="enum"/>
+        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
+        <type name="VkStencilFaceFlagBits" category="enum"/>
+        <type name="VkStencilOp" category="enum"/>
+        <type name="VkStructureType" category="enum"/>
+        <type name="VkSystemAllocationScope" category="enum"/>
+        <type name="VkInternalAllocationType" category="enum"/>
+        <type name="VkSamplerAddressMode" category="enum"/>
+        <type name="VkFilter" category="enum"/>
+        <type name="VkSamplerMipmapMode" category="enum"/>
+        <type name="VkVertexInputRate" category="enum"/>
+        <type name="VkPipelineStageFlagBits" category="enum"/>
+        <type name="VkSparseImageFormatFlagBits" category="enum"/>
+        <type name="VkSampleCountFlagBits" category="enum"/>
+        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
+        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
+        <type name="VkDependencyFlagBits" category="enum"/>
+        <type name="VkObjectType" category="enum"/>
+        <type name="VkEventCreateFlagBits" category="enum"/>
+        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
+        <type name="VkSemaphoreCreateFlagBits" category="enum"/>
+        <type name="VkRayTracingInvocationReorderModeNV" category="enum"/>
+
+        <comment>Extensions</comment>
+        <type name="VkIndirectCommandsLayoutUsageFlagBitsNV" category="enum"/>
+        <type name="VkIndirectCommandsTokenTypeNV" category="enum"/>
+        <type name="VkIndirectStateFlagBitsNV" category="enum"/>
+        <type name="VkPrivateDataSlotCreateFlagBits" category="enum"/>
+        <type category="enum" name="VkPrivateDataSlotCreateFlagBitsEXT"            alias="VkPrivateDataSlotCreateFlagBits"/>
+        <type name="VkDescriptorUpdateTemplateType" category="enum"/>
+        <type category="enum" name="VkDescriptorUpdateTemplateTypeKHR"             alias="VkDescriptorUpdateTemplateType"/>
+        <type name="VkViewportCoordinateSwizzleNV" category="enum"/>
+        <type name="VkDiscardRectangleModeEXT" category="enum"/>
+        <type name="VkSubpassDescriptionFlagBits" category="enum"/>
+        <type name="VkPointClippingBehavior" category="enum"/>
+        <type category="enum" name="VkPointClippingBehaviorKHR"                    alias="VkPointClippingBehavior"/>
+        <type name="VkCoverageModulationModeNV" category="enum"/>
+        <type name="VkCoverageReductionModeNV" category="enum"/>
+        <type name="VkValidationCacheHeaderVersionEXT" category="enum"/>
+        <type name="VkShaderInfoTypeAMD" category="enum"/>
+        <type name="VkQueueGlobalPriorityKHR" category="enum"/>
+        <type name="VkQueueGlobalPriorityEXT" category="enum"                      alias="VkQueueGlobalPriorityKHR"/>
+        <type name="VkTimeDomainEXT" category="enum"/>
+        <type name="VkConservativeRasterizationModeEXT" category="enum"/>
+        <type name="VkResolveModeFlagBits" category="enum"/>
+        <type category="enum" name="VkResolveModeFlagBitsKHR"                      alias="VkResolveModeFlagBits"/>
+        <type name="VkDescriptorBindingFlagBits" category="enum"/>
+        <type category="enum" name="VkDescriptorBindingFlagBitsEXT"                alias="VkDescriptorBindingFlagBits"/>
+        <type name="VkConditionalRenderingFlagBitsEXT" category="enum"/>
+        <type name="VkSemaphoreType" category="enum"/>
+        <type category="enum" name="VkSemaphoreTypeKHR"                            alias="VkSemaphoreType"/>
+        <type name="VkGeometryFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkGeometryFlagBitsNV"                          alias="VkGeometryFlagBitsKHR"/>
+        <type name="VkGeometryInstanceFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkGeometryInstanceFlagBitsNV"                  alias="VkGeometryInstanceFlagBitsKHR"/>
+        <type name="VkBuildAccelerationStructureFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkBuildAccelerationStructureFlagBitsNV"        alias="VkBuildAccelerationStructureFlagBitsKHR"/>
+        <type name="VkAccelerationStructureCreateFlagBitsKHR" category="enum"/>
+        <type name="VkBuildAccelerationStructureModeKHR" category="enum"/>
+        <type name="VkCopyAccelerationStructureModeKHR" category="enum"/>
+        <type category="enum" name="VkCopyAccelerationStructureModeNV"             alias="VkCopyAccelerationStructureModeKHR"/>
+        <type name="VkAccelerationStructureTypeKHR" category="enum"/>
+        <type category="enum" name="VkAccelerationStructureTypeNV"                 alias="VkAccelerationStructureTypeKHR"/>
+        <type name="VkGeometryTypeKHR" category="enum"/>
+        <type category="enum" name="VkGeometryTypeNV"                              alias="VkGeometryTypeKHR"/>
+        <type name="VkRayTracingShaderGroupTypeKHR" category="enum"/>
+        <type category="enum" name="VkRayTracingShaderGroupTypeNV"                 alias="VkRayTracingShaderGroupTypeKHR"/>
+        <type name="VkAccelerationStructureMemoryRequirementsTypeNV" category="enum"/>
+        <type name="VkAccelerationStructureBuildTypeKHR" category="enum"/>
+        <type name="VkAccelerationStructureCompatibilityKHR" category="enum"/>
+        <type name="VkShaderGroupShaderKHR" category="enum"/>
+        <type name="VkMemoryOverallocationBehaviorAMD" category="enum"/>
+        <type name="VkDeviceDiagnosticsConfigFlagBitsNV" category="enum"/>
+        <type name="VkPipelineCreationFeedbackFlagBits" category="enum"/>
+        <type category="enum" name="VkPipelineCreationFeedbackFlagBitsEXT"         alias="VkPipelineCreationFeedbackFlagBits"/>
+        <type name="VkPerformanceCounterScopeKHR" category="enum"/>
+        <type name="VkPerformanceCounterUnitKHR" category="enum"/>
+        <type name="VkPerformanceCounterStorageKHR" category="enum"/>
+        <type name="VkPerformanceCounterDescriptionFlagBitsKHR" category="enum"/>
+        <type name="VkAcquireProfilingLockFlagBitsKHR" category="enum"/>
+        <type name="VkSemaphoreWaitFlagBits" category="enum"/>
+        <type category="enum" name="VkSemaphoreWaitFlagBitsKHR"                    alias="VkSemaphoreWaitFlagBits"/>
+        <type name="VkPerformanceConfigurationTypeINTEL" category="enum"/>
+        <type name="VkQueryPoolSamplingModeINTEL" category="enum"/>
+        <type name="VkPerformanceOverrideTypeINTEL" category="enum"/>
+        <type name="VkPerformanceParameterTypeINTEL" category="enum"/>
+        <type name="VkPerformanceValueTypeINTEL" category="enum"/>
+        <type name="VkLineRasterizationModeKHR" category="enum"/>
+        <type name="VkLineRasterizationModeEXT" category="enum" alias="VkLineRasterizationModeKHR"/>
+        <type name="VkShaderModuleCreateFlagBits" category="enum"/>
+        <type name="VkPipelineCompilerControlFlagBitsAMD" category="enum"/>
+        <type name="VkShaderCorePropertiesFlagBitsAMD" category="enum"/>
+        <type name="VkRefreshObjectFlagBitsKHR" category="enum"/>
+        <type name="VkFaultLevel" category="enum"/>
+        <type name="VkFaultType" category="enum"/>
+        <type name="VkFaultQueryBehavior" category="enum"/>
+        <type name="VkPipelineMatchControl" category="enum"/>
+        <type name="VkSciSyncClientTypeNV" category="enum"/>
+        <type name="VkSciSyncPrimitiveTypeNV" category="enum"/>
+        <type name="VkToolPurposeFlagBits" category="enum"/>
+        <type category="enum" name="VkToolPurposeFlagBitsEXT"                      alias="VkToolPurposeFlagBits"/>
+        <type name="VkFragmentShadingRateNV" category="enum"/>
+        <type name="VkFragmentShadingRateTypeNV" category="enum"/>
+        <type name="VkSubpassMergeStatusEXT" category="enum"/>
+        <type name="VkAccessFlagBits2" category="enum"/>
+        <type category="enum" name="VkAccessFlagBits2KHR"                          alias="VkAccessFlagBits2"/>
+        <type name="VkPipelineStageFlagBits2" category="enum"/>
+        <type category="enum" name="VkPipelineStageFlagBits2KHR"                   alias="VkPipelineStageFlagBits2"/>
+        <type name="VkProvokingVertexModeEXT" category="enum"/>
+        <type name="VkPipelineCacheValidationVersion" category="enum"/>
+        <type name="VkImageFormatConstraintsFlagBitsFUCHSIA" category="enum"/>
+        <type name="VkHostImageCopyFlagBitsEXT" category="enum"/>
+        <type name="VkImageConstraintsInfoFlagBitsFUCHSIA" category="enum"/>
+        <type name="VkFormatFeatureFlagBits2" category="enum"/>
+        <type category="enum" name="VkFormatFeatureFlagBits2KHR"                   alias="VkFormatFeatureFlagBits2"/>
+        <type name="VkRenderingFlagBits" category="enum"/>
+        <type category="enum" name="VkRenderingFlagBitsKHR"                        alias="VkRenderingFlagBits"/>
+        <type name="VkPipelineDepthStencilStateCreateFlagBits" category="enum"/>
+        <type name="VkPipelineColorBlendStateCreateFlagBits" category="enum"/>
+        <type name="VkImageCompressionFlagBitsEXT" category="enum"/>
+        <type name="VkImageCompressionFixedRateFlagBitsEXT" category="enum"/>
+        <type name="VkExportMetalObjectTypeFlagBitsEXT" category="enum"/>
+        <type name="VkPipelineRobustnessBufferBehaviorEXT" category="enum"/>
+        <type name="VkPipelineRobustnessImageBehaviorEXT" category="enum"/>
+        <type name="VkDeviceAddressBindingFlagBitsEXT" category="enum"/>
+        <type name="VkDeviceAddressBindingTypeEXT" category="enum"/>
+        <type name="VkMicromapTypeEXT" category="enum"/>
+        <type name="VkBuildMicromapModeEXT" category="enum"/>
+        <type name="VkCopyMicromapModeEXT" category="enum"/>
+        <type name="VkBuildMicromapFlagBitsEXT" category="enum"/>
+        <type name="VkMicromapCreateFlagBitsEXT" category="enum"/>
+        <type name="VkOpacityMicromapFormatEXT" category="enum"/>
+        <type name="VkOpacityMicromapSpecialIndexEXT" category="enum"/>
+        <type name="VkDeviceFaultVendorBinaryHeaderVersionEXT" category="enum"/>
+        <type name="VkFrameBoundaryFlagBitsEXT" category="enum"/>
+        <type name="VkMemoryDecompressionMethodFlagBitsNV" category="enum"/>
+        <type name="VkDepthBiasRepresentationEXT" category="enum"/>
+        <type name="VkDirectDriverLoadingModeLUNARG" category="enum"/>
+        <type name="VkPipelineCreateFlagBits2KHR" category="enum"/>
+        <type name="VkBufferUsageFlagBits2KHR" category="enum"/>
+        <type name="VkDisplacementMicromapFormatNV" category="enum"/>
+        <type name="VkShaderCreateFlagBitsEXT" category="enum"/>
+        <type name="VkShaderCodeTypeEXT" category="enum"/>
+        <type name="VkScopeKHR" category="enum"/>
+        <type name="VkComponentTypeKHR" category="enum"/>
+        <type category="enum" name="VkScopeNV"                                     alias="VkScopeKHR"/>
+        <type category="enum" name="VkComponentTypeNV"                             alias="VkComponentTypeKHR"/>
+        <type name="VkCubicFilterWeightsQCOM" category="enum"/>
+        <type name="VkBlockMatchWindowCompareModeQCOM" category="enum"/>
+        <type name="VkLayeredDriverUnderlyingApiMSFT" category="enum"/>
+
+            <comment>WSI extensions</comment>
+        <type name="VkColorSpaceKHR" category="enum"/>
+        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
+        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
+        <type name="VkPresentModeKHR" category="enum"/>
+        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
+        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
+        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
+        <type name="VkDeviceMemoryReportEventTypeEXT" category="enum"/>
+        <type name="VkRasterizationOrderAMD" category="enum"/>
+        <type name="VkExternalMemoryHandleTypeFlagBitsNV" category="enum"/>
+        <type name="VkExternalMemoryFeatureFlagBitsNV" category="enum"/>
+        <type name="VkValidationCheckEXT" category="enum"/>
+        <type name="VkValidationFeatureEnableEXT" category="enum"/>
+        <type name="VkValidationFeatureDisableEXT" category="enum"/>
+        <type name="VkExternalMemoryHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalMemoryHandleTypeFlagBitsKHR"         alias="VkExternalMemoryHandleTypeFlagBits"/>
+        <type name="VkExternalMemoryFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalMemoryFeatureFlagBitsKHR"            alias="VkExternalMemoryFeatureFlagBits"/>
+        <type name="VkExternalSemaphoreHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalSemaphoreHandleTypeFlagBitsKHR"      alias="VkExternalSemaphoreHandleTypeFlagBits"/>
+        <type name="VkExternalSemaphoreFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalSemaphoreFeatureFlagBitsKHR"         alias="VkExternalSemaphoreFeatureFlagBits"/>
+        <type name="VkSemaphoreImportFlagBits" category="enum"/>
+        <type category="enum" name="VkSemaphoreImportFlagBitsKHR"                  alias="VkSemaphoreImportFlagBits"/>
+        <type name="VkExternalFenceHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalFenceHandleTypeFlagBitsKHR"          alias="VkExternalFenceHandleTypeFlagBits"/>
+        <type name="VkExternalFenceFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalFenceFeatureFlagBitsKHR"             alias="VkExternalFenceFeatureFlagBits"/>
+        <type name="VkFenceImportFlagBits" category="enum"/>
+        <type category="enum" name="VkFenceImportFlagBitsKHR"                      alias="VkFenceImportFlagBits"/>
+        <type name="VkSurfaceCounterFlagBitsEXT" category="enum"/>
+        <type name="VkDisplayPowerStateEXT" category="enum"/>
+        <type name="VkDeviceEventTypeEXT" category="enum"/>
+        <type name="VkDisplayEventTypeEXT" category="enum"/>
+        <type name="VkPeerMemoryFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkPeerMemoryFeatureFlagBitsKHR"                alias="VkPeerMemoryFeatureFlagBits"/>
+        <type name="VkMemoryAllocateFlagBits" category="enum"/>
+        <type category="enum" name="VkMemoryAllocateFlagBitsKHR"                   alias="VkMemoryAllocateFlagBits"/>
+        <type name="VkDeviceGroupPresentModeFlagBitsKHR" category="enum"/>
+        <type name="VkSwapchainCreateFlagBitsKHR" category="enum"/>
+        <type name="VkSubgroupFeatureFlagBits" category="enum"/>
+        <type name="VkTessellationDomainOrigin" category="enum"/>
+        <type category="enum" name="VkTessellationDomainOriginKHR"                 alias="VkTessellationDomainOrigin"/>
+        <type name="VkSamplerYcbcrModelConversion" category="enum"/>
+        <type category="enum" name="VkSamplerYcbcrModelConversionKHR"              alias="VkSamplerYcbcrModelConversion"/>
+        <type name="VkSamplerYcbcrRange" category="enum"/>
+        <type category="enum" name="VkSamplerYcbcrRangeKHR"                        alias="VkSamplerYcbcrRange"/>
+        <type name="VkChromaLocation" category="enum"/>
+        <type category="enum" name="VkChromaLocationKHR"                           alias="VkChromaLocation"/>
+        <type name="VkSamplerReductionMode" category="enum"/>
+        <type category="enum" name="VkSamplerReductionModeEXT"                     alias="VkSamplerReductionMode"/>
+        <type name="VkBlendOverlapEXT" category="enum"/>
+        <type name="VkDebugUtilsMessageSeverityFlagBitsEXT" category="enum"/>
+        <type name="VkDebugUtilsMessageTypeFlagBitsEXT" category="enum"/>
+        <type name="VkFullScreenExclusiveEXT" category="enum"/>
+        <type name="VkShaderFloatControlsIndependence" category="enum"/>
+        <type category="enum" name="VkShaderFloatControlsIndependenceKHR"          alias="VkShaderFloatControlsIndependence"/>
+        <type name="VkSwapchainImageUsageFlagBitsANDROID" category="enum"/>
+        <type name="VkFragmentShadingRateCombinerOpKHR" category="enum"/>
+        <type name="VkSubmitFlagBits" category="enum"/>
+        <type category="enum" name="VkSubmitFlagBitsKHR"                           alias="VkSubmitFlagBits"/>
+        <type name="VkGraphicsPipelineLibraryFlagBitsEXT" category="enum"/>
+        <type name="VkOpticalFlowGridSizeFlagBitsNV" category="enum"/>
+        <type name="VkOpticalFlowUsageFlagBitsNV" category="enum"/>
+        <type name="VkOpticalFlowPerformanceLevelNV" category="enum"/>
+        <type name="VkOpticalFlowSessionBindingPointNV" category="enum"/>
+        <type name="VkOpticalFlowSessionCreateFlagBitsNV" category="enum"/>
+        <type name="VkOpticalFlowExecuteFlagBitsNV" category="enum"/>
+        <type name="VkDeviceFaultAddressTypeEXT" category="enum"/>
+        <type name="VkPresentScalingFlagBitsEXT" category="enum"/>
+        <type name="VkPresentGravityFlagBitsEXT" category="enum"/>
+        <type name="VkLatencyMarkerNV" category="enum"/>
+        <type name="VkOutOfBandQueueTypeNV" category="enum"/>
+        <type name="VkPhysicalDeviceSchedulingControlsFlagBitsARM" category="enum"/>
+
+            <comment>Enumerated types in the header, but not used by the API</comment>
+        <type name="VkVendorId" category="enum"/>
+        <type name="VkDriverId" category="enum"/>
+        <type category="enum" name="VkDriverIdKHR"                                 alias="VkDriverId"/>
+        <type name="VkShadingRatePaletteEntryNV" category="enum"/>
+        <type name="VkCoarseSampleOrderTypeNV" category="enum"/>
+        <type name="VkPipelineExecutableStatisticFormatKHR" category="enum"/>
+
+            <comment>Video Core extensions</comment>
+        <type name="VkVideoCodecOperationFlagBitsKHR" category="enum"/>
+        <type name="VkVideoChromaSubsamplingFlagBitsKHR" category="enum"/>
+        <type name="VkVideoComponentBitDepthFlagBitsKHR" category="enum"/>
+        <type name="VkVideoCapabilityFlagBitsKHR" category="enum"/>
+        <type name="VkVideoSessionCreateFlagBitsKHR" category="enum"/>
+        <type name="VkVideoCodingControlFlagBitsKHR" category="enum"/>
+        <type name="VkQueryResultStatusKHR" category="enum"/>
+
+            <comment>Video Decode extensions</comment>
+        <type name="VkVideoDecodeUsageFlagBitsKHR" category="enum"/>
+        <type name="VkVideoDecodeCapabilityFlagBitsKHR" category="enum"/>
+
+            <comment>Video H.264 Decode extensions</comment>
+        <type name="VkVideoDecodeH264PictureLayoutFlagBitsKHR" category="enum"/>
+
+            <comment>Video H.265 Decode extensions</comment>
+
+            <comment>Video Encode extensions</comment>
+        <type name="VkVideoEncodeUsageFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeContentFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeTuningModeKHR" category="enum"/>
+        <type name="VkVideoEncodeCapabilityFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeFeedbackFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeRateControlModeFlagBitsKHR" category="enum"/>
+
+           <comment>Video H.264 Encode extensions</comment>
+        <type name="VkVideoEncodeH264CapabilityFlagBitsEXT"             category="enum"/>
+        <type name="VkVideoEncodeH264StdFlagBitsEXT"                    category="enum"/>
+        <type name="VkVideoEncodeH264RateControlFlagBitsEXT"            category="enum"/>
+
+           <comment>Video H.265 Encode extensions</comment>
+        <type name="VkVideoEncodeH265CapabilityFlagBitsEXT"             category="enum"/>
+        <type name="VkVideoEncodeH265StdFlagBitsEXT"                    category="enum"/>
+        <type name="VkVideoEncodeH265RateControlFlagBitsEXT"            category="enum"/>
+        <type name="VkVideoEncodeH265CtbSizeFlagBitsEXT"                category="enum"/>
+        <type name="VkVideoEncodeH265TransformBlockSizeFlagBitsEXT"     category="enum"/>
+
+        <comment>The PFN_vk*Function types are used by VkAllocationCallbacks below</comment>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>VkInternalAllocationType</type>                    allocationType,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>VkInternalAllocationType</type>                    allocationType,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>void</type>*                                       pOriginal,
+    <type>size_t</type>                                      size,
+    <type>size_t</type>                                      alignment,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>size_t</type>                                      alignment,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>void</type>*                                       pMemory);</type>
+
+            <comment>The PFN_vkVoidFunction type are used by VkGet*ProcAddr below</comment>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>
+
+            <comment>The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension</comment>
+        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
+    <type>VkDebugReportFlagsEXT</type>                       flags,
+    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
+    <type>uint64_t</type>                                    object,
+    <type>size_t</type>                                      location,
+    <type>int32_t</type>                                     messageCode,
+    const <type>char</type>*                                 pLayerPrefix,
+    const <type>char</type>*                                 pMessage,
+    <type>void</type>*                                       pUserData);</type>
+
+            <comment>The PFN_vkDebugUtilsMessengerCallbackEXT type are used by the VK_EXT_debug_utils extension</comment>
+        <type category="funcpointer" requires="VkDebugUtilsMessengerCallbackDataEXT">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugUtilsMessengerCallbackEXT</name>)(
+    <type>VkDebugUtilsMessageSeverityFlagBitsEXT</type>           messageSeverity,
+    <type>VkDebugUtilsMessageTypeFlagsEXT</type>                  messageTypes,
+    const <type>VkDebugUtilsMessengerCallbackDataEXT</type>*      pCallbackData,
+    <type>void</type>*                                            pUserData);</type>
+
+            <comment>The PFN_vkFaultCallbackFunction type is used by VKSC_VERSION_1_0</comment>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFaultCallbackFunction</name>)(
+    <type>VkBool32</type>                                    unrecordedFaults,
+    <type>uint32_t</type>                                    faultCount,
+    const <type>VkFaultData</type>*                          pFaults);</type>
+
+            <comment>The PFN_vkDeviceMemoryReportCallbackEXT type is used by the VK_EXT_device_memory_report extension</comment>
+        <type category="funcpointer" requires="VkDeviceMemoryReportCallbackDataEXT">typedef void (VKAPI_PTR *<name>PFN_vkDeviceMemoryReportCallbackEXT</name>)(
+    const <type>VkDeviceMemoryReportCallbackDataEXT</type>*  pCallbackData,
+    <type>void</type>*                                       pUserData);</type>
+
+            <comment>The PFN_vkGetInstanceProcAddrLUNARG type is used by the
+                     VkDirectDriverLoadingInfoLUNARG structure.
+                     We cannot introduce an explicit dependency on the
+                     equivalent PFN_vkGetInstanceProcAddr type, even though
+                     it is implicitly generated in the C header, because
+                     that results in multiple definitions.</comment>
+        <type category="funcpointer" requires="VkInstance">typedef PFN_vkVoidFunction (VKAPI_PTR *<name>PFN_vkGetInstanceProcAddrLUNARG</name>)(
+    <type>VkInstance</type> instance, const <type>char</type>* pName);</type>
+
+            <comment>Struct types</comment>
+        <type category="struct" name="VkBaseOutStructure">
+            <member><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">struct <type>VkBaseOutStructure</type>* <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkBaseInStructure">
+            <member><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const struct <type>VkBaseInStructure</type>* <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkOffset2D">
+            <member><type>int32_t</type>        <name>x</name></member>
+            <member><type>int32_t</type>        <name>y</name></member>
+        </type>
+        <type category="struct" name="VkOffset3D">
+            <member><type>int32_t</type>        <name>x</name></member>
+            <member><type>int32_t</type>        <name>y</name></member>
+            <member><type>int32_t</type>        <name>z</name></member>
+        </type>
+        <type category="struct" name="VkExtent2D">
+            <member><type>uint32_t</type>        <name>width</name></member>
+            <member><type>uint32_t</type>        <name>height</name></member>
+        </type>
+        <type category="struct" name="VkExtent3D">
+            <member><type>uint32_t</type>        <name>width</name></member>
+            <member><type>uint32_t</type>        <name>height</name></member>
+            <member><type>uint32_t</type>        <name>depth</name></member>
+        </type>
+        <type category="struct" name="VkViewport">
+            <member noautovalidity="true"><type>float</type> <name>x</name></member>
+            <member noautovalidity="true"><type>float</type> <name>y</name></member>
+            <member noautovalidity="true"><type>float</type> <name>width</name></member>
+            <member noautovalidity="true"><type>float</type> <name>height</name></member>
+            <member><type>float</type>                       <name>minDepth</name></member>
+            <member><type>float</type>                       <name>maxDepth</name></member>
+        </type>
+        <type category="struct" name="VkRect2D">
+            <member><type>VkOffset2D</type>     <name>offset</name></member>
+            <member><type>VkExtent2D</type>     <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkClearRect">
+            <member><type>VkRect2D</type>       <name>rect</name></member>
+            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>       <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkComponentMapping">
+            <member><type>VkComponentSwizzle</type> <name>r</name></member>
+            <member><type>VkComponentSwizzle</type> <name>g</name></member>
+            <member><type>VkComponentSwizzle</type> <name>b</name></member>
+            <member><type>VkComponentSwizzle</type> <name>a</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true">
+            <member limittype="noauto"><type>uint32_t</type>       <name>apiVersion</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>driverVersion</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>vendorID</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>deviceID</name></member>
+            <member limittype="noauto"><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
+            <member limittype="noauto"><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="struct"><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
+            <member limittype="struct"><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
+        </type>
+        <type category="struct" name="VkExtensionProperties" returnedonly="true">
+            <member><type>char</type>            <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>extension name</comment></member>
+            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the extension specification implemented</comment></member>
+        </type>
+        <type category="struct" name="VkLayerProperties" returnedonly="true">
+            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>layer name</comment></member>
+            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the layer specification implemented</comment></member>
+            <member><type>uint32_t</type>        <name>implementationVersion</name><comment>build or release version of the layer's library</comment></member>
+            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the layer</comment></member>
+        </type>
+        <type category="struct" name="VkApplicationInfo">
+            <member values="VK_STRUCTURE_TYPE_APPLICATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
+            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
+            <member><type>uint32_t</type>        <name>engineVersion</name></member>
+            <member><type>uint32_t</type>        <name>apiVersion</name></member>
+        </type>
+        <type category="struct" name="VkAllocationCallbacks">
+            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
+            <member noautovalidity="true"><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
+            <member noautovalidity="true"><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
+            <member noautovalidity="true"><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
+            <member optional="true" noautovalidity="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
+            <member optional="true" noautovalidity="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>        <name>queueCount</name></member>
+            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
+        </type>
+        <type category="struct" name="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
+            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
+            <member optional="true" deprecated="ignored"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
+            <member len="enabledLayerCount,null-terminated" deprecated="ignored">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
+            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
+            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
+        </type>
+        <type category="struct" name="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>
+            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
+            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
+            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name><comment>Extension names to be enabled</comment></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true">
+            <member optional="true" limittype="bitmask"><type>VkQueueFlags</type>           <name>queueFlags</name><comment>Queue flags</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>queueCount</name></member>
+            <member limittype="bits"><type>uint32_t</type>               <name>timestampValidBits</name></member>
+            <member limittype="min,mul"><type>VkExtent3D</type>             <name>minImageTransferGranularity</name><comment>Minimum alignment requirement for image transfers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
+            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
+            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
+            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
+            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+        </type>
+        <type category="struct" name="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>           <name>allocationSize</name><comment>Size of memory allocation</comment></member>
+            <member><type>uint32_t</type>               <name>memoryTypeIndex</name><comment>Index of the of the memory type to allocate from</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>alignment</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>memoryTypeBits</name><comment>Bitmask of the allowed memory type indices into memoryTypes[] for this object</comment></member>
+        </type>
+        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true">
+            <member limittype="bitmask" optional="true"><type>VkImageAspectFlags</type>       <name>aspectMask</name></member>
+            <member limittype="min,mul"><type>VkExtent3D</type>                                <name>imageGranularity</name></member>
+            <member limittype="bitmask" optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
+            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
+            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryType" returnedonly="true">
+            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name><comment>Memory properties of this memory type</comment></member>
+            <member><type>uint32_t</type>               <name>heapIndex</name><comment>Index of the memory heap allocations of this memory type are taken from</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryHeap" returnedonly="true">
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Available memory in the heap</comment></member>
+            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name><comment>Flags for the heap</comment></member>
+        </type>
+        <type category="struct" name="VkMappedMemoryRange">
+            <member values="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>         <name>memory</name><comment>Mapped memory object</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the memory object where the range starts</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Size of the range within the memory object</comment></member>
+        </type>
+        <type category="struct" name="VkFormatProperties" returnedonly="true">
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name><comment>Format features in case of linear tiling</comment></member>
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name><comment>Format features in case of optimal tiling</comment></member>
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name><comment>Format features supported by buffers</comment></member>
+        </type>
+        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
+            <member><type>VkExtent3D</type>             <name>maxExtent</name><comment>max image dimensions for this resource type</comment></member>
+            <member><type>uint32_t</type>               <name>maxMipLevels</name><comment>max number of mipmap levels for this resource type</comment></member>
+            <member><type>uint32_t</type>               <name>maxArrayLayers</name><comment>max array size for this resource type</comment></member>
+            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name><comment>supported sample counts for this resource type</comment></member>
+            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name><comment>max size (in bytes) of this resource type</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorBufferInfo">
+            <member optional="true"><type>VkBuffer</type>               <name>buffer</name><comment>Buffer used for this descriptor slot.</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Base offset from buffer start in bytes to update in the descriptor set.</comment></member>
+            <member><type>VkDeviceSize</type>           <name>range</name><comment>Size in bytes of the buffer resource for this descriptor update.</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorImageInfo">
+            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name><comment>Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.</comment></member>
+            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name><comment>Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.</comment></member>
+            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name><comment>Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).</comment></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
+            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
+            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name><comment>Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name><comment>Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name><comment>Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.</comment></member>
+        </type>
+        <type category="struct" name="VkCopyDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDescriptorSet</type>        <name>srcSet</name><comment>Source descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>srcBinding</name><comment>Binding within the source descriptor set to copy from</comment></member>
+            <member><type>uint32_t</type>               <name>srcArrayElement</name><comment>Array element within the source binding to copy from</comment></member>
+            <member><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to copy to</comment></member>
+            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to copy to</comment></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
+        </type>
+        <type category="struct" name="VkBufferUsageFlags2CreateInfoKHR" structextends="VkBufferViewCreateInfo,VkBufferCreateInfo,VkPhysicalDeviceExternalBufferInfo,VkDescriptorBufferBindingInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBufferUsageFlags2KHR</type>         <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name><comment>Buffer creation flags</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member noautovalidity="true"><type>VkBufferUsageFlags</type>     <name>usage</name><comment>Buffer usage flags</comment></member>
+            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
+        </type>
+        <type category="struct" name="VkBufferViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkBufferViewCreateFlags</type> <name>flags</name></member>
+            <member><type>VkBuffer</type>               <name>buffer</name></member>
+            <member><type>VkFormat</type>               <name>format</name><comment>Optionally specifies format of elements</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>range</name><comment>View size specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkImageSubresource">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>mipLevel</name></member>
+            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresourceLayers">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>mipLevel</name></member>
+            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>               <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresourceRange">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
+            <member><type>uint32_t</type>               <name>levelCount</name></member>
+            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>               <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
+            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
+            <member><type>VkBuffer</type>               <name>buffer</name><comment>Buffer to sync</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the buffer to sync</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Amount of bytes to sync</comment></member>
+        </type>
+        <type category="struct" name="VkImageMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member><type>VkImageLayout</type>          <name>oldLayout</name><comment>Current layout of the image</comment></member>
+            <member><type>VkImageLayout</type>          <name>newLayout</name><comment>New layout to transition the image to</comment></member>
+            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
+            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
+            <member><type>VkImage</type>                <name>image</name><comment>Image to sync</comment></member>
+            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name><comment>Subresource range to sync</comment></member>
+        </type>
+        <type category="struct" name="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name><comment>Image creation flags</comment></member>
+            <member><type>VkImageType</type>            <name>imageType</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+            <member><type>uint32_t</type>               <name>mipLevels</name></member>
+            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
+            <member><type>VkImageTiling</type>          <name>tiling</name></member>
+            <member><type>VkImageUsageFlags</type>      <name>usage</name><comment>Image usage flags</comment></member>
+            <member><type>VkSharingMode</type>          <name>sharingMode</name><comment>Cross-queue-family sharing mode</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name><comment>Number of queue families to share across</comment></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name><comment>Array of queue family indices to share across</comment></member>
+            <member><type>VkImageLayout</type>          <name>initialLayout</name><comment>Initial image layout for all subresources</comment></member>
+        </type>
+        <type category="struct" name="VkSubresourceLayout">
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>rowPitch</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>arrayPitch</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>depthPitch</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>
+            <member><type>VkImage</type>                <name>image</name></member>
+            <member><type>VkImageViewType</type>        <name>viewType</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkComponentMapping</type>     <name>components</name></member>
+            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
+        </type>
+        <type category="struct" name="VkBufferCopy">
+            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
+            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkSparseMemoryBind">
+            <member><type>VkDeviceSize</type>           <name>resourceOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
+            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkSparseMemoryBindFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryBind">
+            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
+            <member><type>VkOffset3D</type>             <name>offset</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
+            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkSparseMemoryBindFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseBufferMemoryBindInfo">
+            <member><type>VkBuffer</type> <name>buffer</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
+            <member><type>VkImage</type> <name>image</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryBindInfo">
+            <member><type>VkImage</type> <name>image</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
+            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
+            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
+            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
+        </type>
+        <type category="struct" name="VkImageCopy">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>             <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageBlit">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkBufferImageCopy">
+            <member><type>VkDeviceSize</type>           <name>bufferOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>bufferRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>             <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>                <name>srcAddress</name></member>
+            <member><type>VkDeviceAddress</type>                <name>dstAddress</name></member>
+            <member><type>VkDeviceSize</type>                   <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryToImageIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>                <name>srcAddress</name></member>
+            <member><type>uint32_t</type>                       <name>bufferRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>                       <name>bufferImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type>       <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>                     <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>                     <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageResolve">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkShaderModuleCreateInfo" structextends="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true">const <type>void</type>*            <name>pNext</name><comment>noautovalidity because this structure can be either an explicit parameter, or passed in a pNext chain</comment></member>
+            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>
+            <member><type>size_t</type>                 <name>codeSize</name><comment>Specified in bytes</comment></member>
+            <member len="latexmath:[\textrm{codeSize} \over 4]" altlen="codeSize / 4">const <type>uint32_t</type>*            <name>pCode</name><comment>Binary code of size codeSize</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutBinding">
+            <member><type>uint32_t</type>               <name>binding</name><comment>Binding number for this entry</comment></member>
+            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Type of the descriptors in this binding</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name><comment>Number of descriptors in this binding</comment></member>
+            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Shader stages this binding is visible to</comment></member>
+            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name><comment>Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name><comment>Number of bindings in the descriptor set layout</comment></member>
+            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name><comment>Array of descriptor set layout bindings</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolSize">
+            <member><type>VkDescriptorType</type>       <name>type</name></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>maxSets</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>poolSizeCount</name></member>
+            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDescriptorPool</type>       <name>descriptorPool</name></member>
+            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
+            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
+        </type>
+        <type category="struct" name="VkSpecializationMapEntry">
+            <member><type>uint32_t</type>                     <name>constantID</name><comment>The SpecConstant ID specified in the BIL</comment></member>
+            <member><type>uint32_t</type>                     <name>offset</name><comment>Offset of the value in the data block</comment></member>
+            <member noautovalidity="true"><type>size_t</type> <name>size</name><comment>Size in bytes of the SpecConstant</comment></member>
+        </type>
+        <type category="struct" name="VkSpecializationInfo">
+            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name><comment>Number of entries in the map</comment></member>
+            <member len="mapEntryCount">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name><comment>Array of map entries</comment></member>
+            <member optional="true"><type>size_t</type>                 <name>dataSize</name><comment>Size in bytes of pData</comment></member>
+            <member len="dataSize">const <type>void</type>*            <name>pData</name><comment>Pointer to SpecConstant data</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkShaderStageFlagBits</type>  <name>stage</name><comment>Shader stage</comment></member>
+            <member optional="true"><type>VkShaderModule</type> <name>module</name><comment>Module containing entry point</comment></member>
+            <member api="vulkan" len="null-terminated">const <type>char</type>* <name>pName</name><comment>Null-terminated entry point name</comment></member>
+            <member api="vulkansc" optional="true" len="null-terminated">const <type>char</type>* <name>pName</name><comment>Null-terminated entry point name</comment></member>
+            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
+        </type>
+        <type category="struct" name="VkComputePipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkComputePipelineIndirectBufferInfoNV">
+            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>               <name>deviceAddress</name></member>
+            <member><type>VkDeviceSize</type>                  <name>size</name></member>
+            <member><type>VkDeviceAddress</type>               <name>pipelineDeviceAddressCaptureReplay</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCreateFlags2CreateInfoKHR" structextends="VkComputePipelineCreateInfo,VkGraphicsPipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkPipelineCreateFlags2KHR</type>      <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVertexInputBindingDescription">
+            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>uint32_t</type>               <name>stride</name><comment>Distance between vertices in bytes (0 = no advancement)</comment></member>
+            <member><type>VkVertexInputRate</type>      <name>inputRate</name><comment>The rate at which the vertex data is consumed</comment></member>
+        </type>
+        <type category="struct" name="VkVertexInputAttributeDescription">
+            <member><type>uint32_t</type>               <name>location</name><comment>location of the shader vertex attrib</comment></member>
+            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>VkFormat</type>               <name>format</name><comment>format of source data</comment></member>
+            <member><type>uint32_t</type>               <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name><comment>number of bindings</comment></member>
+            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name><comment>number of attributes</comment></member>
+            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
+        </type>
+        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
+            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>scissorCount</name></member>
+            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
+            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
+            <member><type>VkPolygonMode</type>          <name>polygonMode</name><comment>optional (GL45)</comment></member>
+            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
+            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
+            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
+            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
+            <member><type>float</type>                  <name>depthBiasClamp</name></member>
+            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
+            <member><type>float</type>                  <name>lineWidth</name></member>
+        </type>
+        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name><comment>Number of samples used for rasterization</comment></member>
+            <member><type>VkBool32</type>               <name>sampleShadingEnable</name><comment>optional (GL45)</comment></member>
+            <member><type>float</type>                  <name>minSampleShading</name><comment>optional (GL45)</comment></member>
+            <member optional="true" len="latexmath:[\lceil{\mathit{rasterizationSamples} \over 32}\rceil]" altlen="(rasterizationSamples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name><comment>Array of sampleMask words</comment></member>
+            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
+            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendAttachmentState">
+            <member><type>VkBool32</type>               <name>blendEnable</name></member>
+            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
+            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
+            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
+            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
+            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
+            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
+            <member optional="true" len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
+            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
+        </type>
+        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>dynamicStateCount</name></member>
+            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
+        </type>
+        <type category="struct" name="VkStencilOpState">
+            <member><type>VkStencilOp</type>            <name>failOp</name></member>
+            <member><type>VkStencilOp</type>            <name>passOp</name></member>
+            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
+            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
+            <member><type>uint32_t</type>               <name>compareMask</name></member>
+            <member><type>uint32_t</type>               <name>writeMask</name></member>
+            <member><type>uint32_t</type>               <name>reference</name></member>
+        </type>
+        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
+            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
+            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
+            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name><comment>optional (depth_bounds_test)</comment></member>
+            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
+            <member><type>VkStencilOpState</type>       <name>front</name></member>
+            <member><type>VkStencilOpState</type>       <name>back</name></member>
+            <member><type>float</type>                  <name>minDepthBounds</name></member>
+            <member><type>float</type>                  <name>maxDepthBounds</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member noautovalidity="true" optional="true"><type>uint32_t</type> <name>stageCount</name></member>
+            <member api="vulkan" noautovalidity="true" len="stageCount" optional="true">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member api="vulkansc" noautovalidity="true" len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
+            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
+            <member noautovalidity="true" optional="true"><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member noautovalidity="true"><type>uint32_t</type>               <name>subpass</name></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>
+            <member api="vulkan" optional="true"><type>size_t</type>           <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
+            <member api="vulkansc"><type>size_t</type>                         <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
+            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name><comment>Initial data to populate cache</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheHeaderVersionOne">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>uint32_t</type>               <name>headerSize</name></member>
+            <member><type>VkPipelineCacheHeaderVersion</type> <name>headerVersion</name></member>
+            <member><type>uint32_t</type>               <name>vendorID</name></member>
+            <member><type>uint32_t</type>               <name>deviceID</name></member>
+            <member><type>uint8_t</type>                <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPipelineCacheStageValidationIndexEntry">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>uint64_t</type>               <name>codeSize</name></member>
+            <member><type>uint64_t</type>               <name>codeOffset</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheSafetyCriticalIndexEntry">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>uint8_t</type>                <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member><type>uint64_t</type>               <name>pipelineMemorySize</name></member>
+            <member><type>uint64_t</type>               <name>jsonSize</name></member>
+            <member><type>uint64_t</type>               <name>jsonOffset</name></member>
+            <member><type>uint32_t</type>               <name>stageIndexCount</name></member>
+            <member><type>uint32_t</type>               <name>stageIndexStride</name></member>
+            <member><type>uint64_t</type>               <name>stageIndexOffset</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheHeaderVersionSafetyCriticalOne">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkPipelineCacheHeaderVersionOne</type>        <name>headerVersionOne</name></member>
+            <member><type>VkPipelineCacheValidationVersion</type>       <name>validationVersion</name></member>
+            <member><type>uint32_t</type>                               <name>implementationData</name></member>
+            <member><type>uint32_t</type>                               <name>pipelineIndexCount</name></member>
+            <member><type>uint32_t</type>                               <name>pipelineIndexStride</name></member>
+            <member><type>uint64_t</type>                               <name>pipelineIndexOffset</name></member>
+        </type>
+        <type category="struct" name="VkPushConstantRange">
+            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Which stages use the range</comment></member>
+            <member><type>uint32_t</type>               <name>offset</name><comment>Start of the range, in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>size</name><comment>Size of the range, in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name><comment>Number of descriptor sets interfaced by the pipeline</comment></member>
+            <member optional="false,true" len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name><comment>Array of setCount number of descriptor set layout objects defining the layout of the</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name><comment>Number of push-constant ranges used by the pipeline</comment></member>
+            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name><comment>Array of pushConstantRangeCount number of ranges used by various shader stages</comment></member>
+        </type>
+        <type category="struct" name="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>
+            <member><type>VkFilter</type>               <name>magFilter</name><comment>Filter mode for magnification</comment></member>
+            <member><type>VkFilter</type>               <name>minFilter</name><comment>Filter mode for minifiation</comment></member>
+            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name><comment>Mipmap selection mode</comment></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
+            <member><type>float</type>                  <name>mipLodBias</name></member>
+            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
+            <member><type>float</type>                  <name>maxAnisotropy</name></member>
+            <member><type>VkBool32</type>               <name>compareEnable</name></member>
+            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
+            <member><type>float</type>                  <name>minLod</name></member>
+            <member><type>float</type>                  <name>maxLod</name></member>
+            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
+            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
+        </type>
+        <type category="struct" name="VkCommandPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name><comment>Command pool creation flags</comment></member>
+            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkCommandPool</type>          <name>commandPool</name></member>
+            <member><type>VkCommandBufferLevel</type>   <name>level</name></member>
+            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name><comment>Render pass for secondary command buffers</comment></member>
+            <member><type>uint32_t</type>               <name>subpass</name></member>
+            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name><comment>Framebuffer for secondary command buffers</comment></member>
+            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name><comment>Whether this secondary command buffer may be executed during an occlusion query</comment></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name><comment>Query flags used by this secondary command buffer, if executed during an occlusion query</comment></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Pipeline statistics that may be counted for this secondary command buffer</comment></member>
+        </type>
+        <type category="struct" name="VkCommandBufferBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name><comment>Command buffer usage flags</comment></member>
+            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name><comment>Pointer to inheritance info for secondary command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
+            <member><type>VkRect2D</type>               <name>renderArea</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
+            <member len="clearValueCount" noautovalidity="true">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
+        </type>
+        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
+            <member><type>float</type>                  <name>float32</name>[4]</member>
+            <member><type>int32_t</type>                <name>int32</name>[4]</member>
+            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
+        </type>
+        <type category="struct" name="VkClearDepthStencilValue">
+            <member><type>float</type>                  <name>depth</name></member>
+            <member><type>uint32_t</type>               <name>stencil</name></member>
+        </type>
+        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
+            <member noautovalidity="true"><type>VkClearColorValue</type>      <name>color</name></member>
+            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
+        </type>
+        <type category="struct" name="VkClearAttachment">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
+            <member noautovalidity="true"><type>VkClearValue</type>           <name>clearValue</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescription">
+            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
+            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
+            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
+            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
+            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReference">
+            <member><type>uint32_t</type>               <name>attachment</name></member>
+            <member><type>VkImageLayout</type>          <name>layout</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDescription">
+            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name><comment>Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
+            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
+            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
+            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
+            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDependency">
+            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
+            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkRenderPassCreateFlags</type> <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
+            <member><type>uint32_t</type>               <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
+        </type>
+        <type category="struct" name="VkEventCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name><comment>Event creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name><comment>Fence creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures">
+            <member><type>VkBool32</type>               <name>robustBufferAccess</name><comment>out of bounds buffer accesses are well defined</comment></member>
+            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name><comment>full 32-bit range of indices for indexed draw calls</comment></member>
+            <member><type>VkBool32</type>               <name>imageCubeArray</name><comment>image views which are arrays of cube maps</comment></member>
+            <member><type>VkBool32</type>               <name>independentBlend</name><comment>blending operations are controlled per-attachment</comment></member>
+            <member><type>VkBool32</type>               <name>geometryShader</name><comment>geometry stage</comment></member>
+            <member><type>VkBool32</type>               <name>tessellationShader</name><comment>tessellation control and evaluation stage</comment></member>
+            <member><type>VkBool32</type>               <name>sampleRateShading</name><comment>per-sample shading and interpolation</comment></member>
+            <member><type>VkBool32</type>               <name>dualSrcBlend</name><comment>blend operations which take two sources</comment></member>
+            <member><type>VkBool32</type>               <name>logicOp</name><comment>logic operations</comment></member>
+            <member><type>VkBool32</type>               <name>multiDrawIndirect</name><comment>multi draw indirect</comment></member>
+            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name><comment>indirect drawing can use non-zero firstInstance</comment></member>
+            <member><type>VkBool32</type>               <name>depthClamp</name><comment>depth clamping</comment></member>
+            <member><type>VkBool32</type>               <name>depthBiasClamp</name><comment>depth bias clamping</comment></member>
+            <member><type>VkBool32</type>               <name>fillModeNonSolid</name><comment>point and wireframe fill modes</comment></member>
+            <member><type>VkBool32</type>               <name>depthBounds</name><comment>depth bounds test</comment></member>
+            <member><type>VkBool32</type>               <name>wideLines</name><comment>lines with width greater than 1</comment></member>
+            <member><type>VkBool32</type>               <name>largePoints</name><comment>points with size greater than 1</comment></member>
+            <member><type>VkBool32</type>               <name>alphaToOne</name><comment>the fragment alpha component can be forced to maximum representable alpha value</comment></member>
+            <member><type>VkBool32</type>               <name>multiViewport</name><comment>viewport arrays</comment></member>
+            <member><type>VkBool32</type>               <name>samplerAnisotropy</name><comment>anisotropic sampler filtering</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionETC2</name><comment>ETC texture compression formats</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name><comment>ASTC LDR texture compression formats</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionBC</name><comment>BC1-7 texture compressed formats</comment></member>
+            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name><comment>precise occlusion queries returning actual sample counts</comment></member>
+            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name><comment>pipeline statistics query</comment></member>
+            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages</comment></member>
+            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in the fragment stage</comment></member>
+            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name><comment>tessellation and geometry stages can export point size</comment></member>
+            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name><comment>image gather with run-time values and independent offsets</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name><comment>the extended set of formats can be used for storage images</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name><comment>multisample images can be used for storage images</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name><comment>read from storage image does not require format qualifier</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name><comment>write to storage image does not require format qualifier</comment></member>
+            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name><comment>arrays of uniform buffers can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name><comment>arrays of sampled images can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name><comment>arrays of storage buffers can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name><comment>arrays of storage images can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderClipDistance</name><comment>clip distance in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderCullDistance</name><comment>cull distance in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderFloat64</name><comment>64-bit floats (doubles) in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderInt64</name><comment>64-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderInt16</name><comment>16-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderResourceResidency</name><comment>shader can use texture operations that return resource residency information (requires sparseNonResident support)</comment></member>
+            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name><comment>shader can use texture operations that specify minimum resource LOD</comment></member>
+            <member><type>VkBool32</type>               <name>sparseBinding</name><comment>Sparse resources support: Resource memory can be managed at opaque page level rather than object level</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name><comment>Sparse resources support: GPU can access partially resident buffers </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name><comment>Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name><comment>Sparse resources support: GPU can access partially resident 3D images </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name><comment>Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)</comment></member>
+            <member><type>VkBool32</type>               <name>variableMultisampleRate</name><comment>multisample rate must be the same for all pipelines in a subpass</comment></member>
+            <member><type>VkBool32</type>               <name>inheritedQueries</name><comment>Queries may be inherited from primary to secondary command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true">
+            <member limittype="bitmask"><type>VkBool32</type>           <name>residencyStandard2DBlockShape</name><comment>Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>residencyStandard2DMultisampleBlockShape</name><comment>Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>residencyStandard3DBlockShape</name><comment>Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>residencyAlignedMipSize</name><comment>Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>residencyNonResidentStrict</name><comment>Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true">
+                <comment>resource maximum sizes</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension1D</name><comment>max 1D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension2D</name><comment>max 2D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension3D</name><comment>max 3D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimensionCube</name><comment>max cubemap image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageArrayLayers</name><comment>max layers for image arrays</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelBufferElements</name><comment>max texel buffer size (fstexels)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxUniformBufferRange</name><comment>max uniform buffer range (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxStorageBufferRange</name><comment>max storage buffer range (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPushConstantsSize</name><comment>max size of the push constants pool (bytes)</comment></member>
+                <comment>memory limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxMemoryAllocationCount</name><comment>max number of device memory allocations supported</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxSamplerAllocationCount</name><comment>max number of samplers that can be allocated on a device</comment></member>
+            <member limittype="min,mul"><type>VkDeviceSize</type>           <name>bufferImageGranularity</name><comment>Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage</comment></member>
+            <member limittype="max"><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name><comment>Total address space available for sparse allocations (bytes)</comment></member>
+                <comment>descriptor set limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxBoundDescriptorSets</name><comment>max number of descriptors sets that can be bound to a pipeline</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name><comment>max number of samplers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name><comment>max number of uniform buffers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name><comment>max number of storage buffers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name><comment>max number of sampled images allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name><comment>max number of storage images allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name><comment>max number of input attachments allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageResources</name><comment>max number of resources allowed by a single stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name><comment>max number of samplers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name><comment>max number of uniform buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name><comment>max number of dynamic uniform buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name><comment>max number of storage buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name><comment>max number of dynamic storage buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name><comment>max number of sampled images allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name><comment>max number of storage images allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name><comment>max number of input attachments allowed in all stages in a descriptor set</comment></member>
+                <comment>vertex stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributes</name><comment>max number of vertex input attribute slots</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindings</name><comment>max number of vertex input binding slots</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name><comment>max vertex input attribute offset added to vertex buffer offset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindingStride</name><comment>max vertex input binding stride</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexOutputComponents</name><comment>max number of output components written by vertex shader</comment></member>
+                <comment>tessellation control stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name><comment>max level supported by tessellation primitive generator</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationPatchSize</name><comment>max patch size (vertices)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name><comment>max number of input components per-vertex in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name><comment>max number of output components per-vertex in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name><comment>max number of output components per-patch in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name><comment>max total number of per-vertex and per-patch output components in TCS</comment></member>
+                <comment>tessellation evaluation stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name><comment>max number of input components per vertex in TES</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name><comment>max number of output components per vertex in TES</comment></member>
+                <comment>geometry stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name><comment>max invocation count supported in geometry shader</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryInputComponents</name><comment>max number of input components read in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputComponents</name><comment>max number of output components written in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputVertices</name><comment>max number of vertices that can be emitted in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name><comment>max total number of components (all vertices) written in geometry stage</comment></member>
+                <comment>fragment stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentInputComponents</name><comment>max number of input components read in fragment stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name><comment>max number of output attachments written in fragment stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name><comment>max number of output attachments written when using dual source blending</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name><comment>max total number of storage buffers, storage images and output buffers</comment></member>
+                <comment>compute stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name><comment>max total storage size of work group local storage (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]<comment>max num of compute work groups that may be dispatched by a single command (x,y,z)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name><comment>max total compute invocations in a single local work group</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]<comment>max local size of a compute work group (x,y,z)</comment></member>
+            <member limittype="bits"><type>uint32_t</type>              <name>subPixelPrecisionBits</name><comment>number bits of subpixel precision in screen x and y</comment></member>
+            <member limittype="bits"><type>uint32_t</type>              <name>subTexelPrecisionBits</name><comment>number bits of precision for selecting texel weights</comment></member>
+            <member limittype="bits"><type>uint32_t</type>              <name>mipmapPrecisionBits</name><comment>number bits of precision for selecting mipmap weights</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name><comment>max index value for indexed draw calls (for 32-bit indices)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndirectCount</name><comment>max draw count for indirect drawing calls</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxSamplerLodBias</name><comment>max absolute sampler LOD bias</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxSamplerAnisotropy</name><comment>max degree of sampler anisotropy</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxViewports</name><comment>max number of active viewports</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]<comment>max viewport dimensions (x,y)</comment></member>
+            <member limittype="range"><type>float</type>                <name>viewportBoundsRange</name>[2]<comment>viewport bounds range (min,max)</comment></member>
+            <member limittype="bits"><type>uint32_t</type>              <name>viewportSubPixelBits</name><comment>number bits of subpixel precision for viewport</comment></member>
+            <member limittype="min,pot"><type>size_t</type>             <name>minMemoryMapAlignment</name><comment>min required alignment of pointers returned by MapMemory (bytes)</comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minTexelBufferOffsetAlignment</name><comment>min required alignment for texel buffer offsets (bytes) </comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minUniformBufferOffsetAlignment</name><comment>min required alignment for uniform buffer sizes and offsets (bytes)</comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minStorageBufferOffsetAlignment</name><comment>min required alignment for storage buffer offsets (bytes)</comment></member>
+            <member limittype="min"><type>int32_t</type>                <name>minTexelOffset</name><comment>min texel offset for OpTextureSampleOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelOffset</name><comment>max texel offset for OpTextureSampleOffset</comment></member>
+            <member limittype="min"><type>int32_t</type>                <name>minTexelGatherOffset</name><comment>min texel offset for OpTextureGatherOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelGatherOffset</name><comment>max texel offset for OpTextureGatherOffset</comment></member>
+            <member limittype="min"><type>float</type>                  <name>minInterpolationOffset</name><comment>furthest negative offset for interpolateAtOffset</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxInterpolationOffset</name><comment>furthest positive offset for interpolateAtOffset</comment></member>
+            <member limittype="bits"><type>uint32_t</type>              <name>subPixelInterpolationOffsetBits</name><comment>number of subpixel bits for interpolateAtOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferWidth</name><comment>max width for a framebuffer</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferHeight</name><comment>max height for a framebuffer</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferLayers</name><comment>max layer count for a layered framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name><comment>supported color sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name><comment>supported depth sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name><comment>supported stencil sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name><comment>supported sample counts for a subpass which uses no attachments</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxColorAttachments</name><comment>max number of color attachments per subpass</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name><comment>supported color sample counts for a non-integer sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name><comment>supported sample counts for an integer image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name><comment>supported depth sample counts for a sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name><comment>supported stencil sample counts for a sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name><comment>supported sample counts for a storage image</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxSampleMaskWords</name><comment>max number of sample mask words</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>timestampComputeAndGraphics</name><comment>timestamps on graphics and compute queues</comment></member>
+            <member limittype="min,mul"><type>float</type>              <name>timestampPeriod</name><comment>number of nanoseconds it takes for timestamp query value to increment by 1</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxClipDistances</name><comment>max number of clip distances</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxCullDistances</name><comment>max number of cull distances</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name><comment>max combined number of user clipping</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>discreteQueuePriorities</name><comment>distinct queue priorities available </comment></member>
+            <member limittype="range"><type>float</type>                <name>pointSizeRange</name>[2]<comment>range (min,max) of supported point sizes</comment></member>
+            <member limittype="range"><type>float</type>                <name>lineWidthRange</name>[2]<comment>range (min,max) of supported line widths</comment></member>
+            <member limittype="min,mul"><type>float</type>              <name>pointSizeGranularity</name><comment>granularity of supported point sizes</comment></member>
+            <member limittype="min,mul"><type>float</type>              <name>lineWidthGranularity</name><comment>granularity of supported line widths</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>strictLines</name><comment>line rasterization follows preferred rules</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>           <name>standardSampleLocations</name><comment>supports standard sample locations for all supported sample counts</comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>optimalBufferCopyOffsetAlignment</name><comment>optimal offset of buffer copies</comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>optimalBufferCopyRowPitchAlignment</name><comment>optimal pitch of buffer copies</comment></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>nonCoherentAtomSize</name><comment>minimum size and alignment for non-coherent host-mapped device memory access</comment></member>
+        </type>
+        <type category="struct" name="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name><comment>Semaphore creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>
+            <member><type>VkQueryType</type>            <name>queryType</name></member>
+            <member><type>uint32_t</type>               <name>queryCount</name></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Optional</comment></member>
+        </type>
+        <type category="struct" name="VkFramebufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkRenderPass</type>                           <name>renderPass</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
+            <member noautovalidity="true" len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
+            <member><type>uint32_t</type>               <name>width</name></member>
+            <member><type>uint32_t</type>               <name>height</name></member>
+            <member><type>uint32_t</type>               <name>layers</name></member>
+        </type>
+        <type category="struct" name="VkDrawIndirectCommand">
+            <member><type>uint32_t</type>                       <name>vertexCount</name></member>
+            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
+            <member><type>uint32_t</type>                       <name>firstVertex</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
+        </type>
+        <type category="struct" name="VkDrawIndexedIndirectCommand">
+            <member><type>uint32_t</type>                       <name>indexCount</name></member>
+            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
+            <member><type>uint32_t</type>                       <name>firstIndex</name></member>
+            <member><type>int32_t</type>                        <name>vertexOffset</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
+        </type>
+        <type category="struct" name="VkDispatchIndirectCommand">
+            <member noautovalidity="true"><type>uint32_t</type> <name>x</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>y</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>z</name></member>
+        </type>
+        <type category="struct" name="VkMultiDrawInfoEXT">
+            <member><type>uint32_t</type> <name>firstVertex</name></member>
+            <member><type>uint32_t</type> <name>vertexCount</name></member>
+        </type>
+        <type category="struct" name="VkMultiDrawIndexedInfoEXT">
+            <member><type>uint32_t</type> <name>firstIndex</name></member>
+            <member><type>uint32_t</type> <name>indexCount</name></member>
+            <member><type>int32_t</type> <name>vertexOffset</name></member>
+        </type>
+        <type category="struct" name="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
+            <member optional="false,true" len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
+            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
+        </type>
+            <comment>WSI extensions</comment>
+        <type category="struct" name="VkDisplayPropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayKHR</type>                     <name>display</name><comment>Handle of the display object</comment></member>
+            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name><comment>Name of the display</comment></member>
+            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name><comment>In millimeters?</comment></member>
+            <member><type>VkExtent2D</type>                       <name>physicalResolution</name><comment>Max resolution for CRT?</comment></member>
+            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>one or more bits from VkSurfaceTransformFlagsKHR</comment></member>
+            <member><type>VkBool32</type>                         <name>planeReorderPossible</name><comment>VK_TRUE if the overlay plane's z-order can be changed on this display.</comment></member>
+            <member><type>VkBool32</type>                         <name>persistentContent</name><comment>VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPlanePropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name><comment>Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.</comment></member>
+            <member><type>uint32_t</type>                         <name>currentStackIndex</name><comment>Current z-order of the plane.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModeParametersKHR">
+            <member><type>VkExtent2D</type>                       <name>visibleRegion</name><comment>Visible scanout region.</comment></member>
+            <member noautovalidity="true"><type>uint32_t</type>   <name>refreshRate</name><comment>Number of times per second the display is updated.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModePropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>Handle of this display mode.</comment></member>
+            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModeCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>
+            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR" returnedonly="true">
+            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name><comment>Types of alpha blending supported, if any.</comment></member>
+            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name><comment>Does the plane have any position and extent restrictions?</comment></member>
+            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
+            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
+            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
+            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
+            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
+        </type>
+        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>The mode to use when displaying this surface</comment></member>
+            <member><type>uint32_t</type>                         <name>planeIndex</name><comment>The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.</comment></member>
+            <member><type>uint32_t</type>                         <name>planeStackIndex</name><comment>The z-order of the plane.</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name><comment>Transform to apply to the images as part of the scanout operation</comment></member>
+            <member><type>float</type>                            <name>globalAlpha</name><comment>Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</comment></member>
+            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name><comment>What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.</comment></member>
+            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>size of the images to use with this surface</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPresentInfoKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkRect2D</type>                         <name>srcRect</name><comment>Rectangle within the presentable image to read pixel data from when presenting to the display.</comment></member>
+            <member><type>VkRect2D</type>                         <name>dstRect</name><comment>Rectangle within the current display mode's visible region to display srcRectangle in.</comment></member>
+            <member><type>VkBool32</type>                         <name>persistent</name><comment>For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.</comment></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilitiesKHR" returnedonly="true">
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
+            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
+            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
+            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
+            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
+            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
+        </type>
+        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type> <name>flags</name></member>
+            <member noautovalidity="true">struct <type>ANativeWindow</type>*    <name>window</name></member>
+        </type>
+        <type category="struct" name="VkViSurfaceCreateInfoNN">
+            <member values="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkViSurfaceCreateFlagsNN</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>void</type>*                            <name>window</name></member>
+        </type>
+        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true">struct <type>wl_display</type>*               <name>display</name></member>
+            <member noautovalidity="true">struct <type>wl_surface</type>*               <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
+            <member><type>HWND</type>                             <name>hwnd</name></member>
+        </type>
+        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>Display</type>*                         <name>dpy</name></member>
+            <member><type>Window</type>                           <name>window</name></member>
+        </type>
+        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>xcb_connection_t</type>*                <name>connection</name></member>
+            <member><type>xcb_window_t</type>                     <name>window</name></member>
+        </type>
+        <type category="struct" name="VkDirectFBSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDirectFBSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>IDirectFB</type>*                       <name>dfb</name></member>
+            <member noautovalidity="true"><type>IDirectFBSurface</type>*                <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkImagePipeSurfaceCreateInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImagePipeSurfaceCreateFlagsFUCHSIA</type>   <name>flags</name></member>
+            <member><type>zx_handle_t</type>                      <name>imagePipeHandle</name></member>
+        </type>
+        <type category="struct" name="VkStreamDescriptorSurfaceCreateInfoGGP">
+            <member values="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkStreamDescriptorSurfaceCreateFlagsGGP</type> <name>flags</name></member>
+            <member><type>GgpStreamDescriptor</type>              <name>streamDescriptor</name></member>
+        </type>
+        <type category="struct" name="VkScreenSurfaceCreateInfoQNX">
+            <member values="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkScreenSurfaceCreateFlagsQNX</type>    <name>flags</name></member>
+            <member noautovalidity="true">struct <type>_screen_context</type>*    <name>context</name></member>
+            <member noautovalidity="true">struct <type>_screen_window</type>*     <name>window</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFormatKHR" returnedonly="true">
+            <member><type>VkFormat</type>                         <name>format</name><comment>Supported pair of rendering format</comment></member>
+            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name><comment>and color space for the surface</comment></member>
+        </type>
+        <type category="struct" name="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>
+            <member><type>VkSurfaceKHR</type>                     <name>surface</name><comment>The swapchain's target surface</comment></member>
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Minimum number of presentation images the application needs</comment></member>
+            <member><type>VkFormat</type>                         <name>imageFormat</name><comment>Format of the presentation images</comment></member>
+            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name><comment>Colorspace of the presentation images</comment></member>
+            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>Dimensions of the presentation images</comment></member>
+            <member><type>uint32_t</type>                         <name>imageArrayLayers</name><comment>Determines the number of views for multiview/stereo presentation</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name><comment>Bits indicating how the presentation images will be used</comment></member>
+            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name><comment>Sharing mode used for the presentation images</comment></member>
+            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name><comment>Number of queue families having access to the images in case of concurrent sharing mode</comment></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name><comment>Array of queue family indices having access to the images in case of concurrent sharing mode</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name><comment>The transform, relative to the device's natural orientation, applied to the image content prior to presentation</comment></member>
+            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name><comment>The alpha blending mode used when compositing this surface with other surfaces in the window system</comment></member>
+            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name><comment>Which presentation mode to use for presents on this swap chain</comment></member>
+            <member><type>VkBool32</type>                         <name>clipped</name><comment>Specifies whether presentable images may be affected by window clip regions</comment></member>
+            <member api="vulkan" optional="true"><type>VkSwapchainKHR</type>                         <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
+            <member api="vulkansc" noautovalidity="true" optional="true"><type>VkSwapchainKHR</type> <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
+        </type>
+        <type category="struct" name="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name><comment>Number of semaphores to wait for before presenting</comment></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name><comment>Semaphores to wait for before presenting</comment></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Number of swapchains to present in this call</comment></member>
+            <member len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name><comment>Swapchains to present an image from</comment></member>
+            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name><comment>Indices of which presentable images to present</comment></member>
+            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name><comment>Optional (i.e. if non-NULL) VkResult for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDebugReportFlagsEXT</type>            <name>flags</name><comment>Indicates which events call this callback</comment></member>
+            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name><comment>Function pointer of a callback function</comment></member>
+            <member optional="true"><type>void</type>*            <name>pUserData</name><comment>User data provided to callback function</comment></member>
+        </type>
+        <type category="struct" name="VkValidationFlagsEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"><type>VkStructureType</type>                  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</comment></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>disabledValidationCheckCount</name><comment>Number of validation checks to disable</comment></member>
+            <member len="disabledValidationCheckCount">const <type>VkValidationCheckEXT</type>* <name>pDisabledValidationChecks</name><comment>Validation checks to disable</comment></member>
+        </type>
+        <type category="struct" name="VkValidationFeaturesEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"><type>VkStructureType</type>  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</comment></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>enabledValidationFeatureCount</name><comment>Number of validation features to enable</comment></member>
+            <member len="enabledValidationFeatureCount">const <type>VkValidationFeatureEnableEXT</type>* <name>pEnabledValidationFeatures</name><comment>Validation features to enable</comment></member>
+            <member optional="true"><type>uint32_t</type>                         <name>disabledValidationFeatureCount</name><comment>Number of validation features to disable</comment></member>
+            <member len="disabledValidationFeatureCount">const <type>VkValidationFeatureDisableEXT</type>* <name>pDisabledValidationFeatures</name><comment>Validation features to disable</comment></member>
+        </type>
+        <type category="struct" name="VkApplicationParametersEXT" allowduplicate="true" structextends="VkApplicationInfo,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>uint32_t</type>                           <name>vendorID</name></member>
+            <member optional="true"><type>uint32_t</type>           <name>deviceID</name></member>
+            <member><type>uint32_t</type>                           <name>key</name></member>
+            <member><type>uint64_t</type>                           <name>value</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name><comment>Rasterization order to use for the pipeline</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
+            <member objecttype="objectType"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
+            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name><comment>Name to apply to the object</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
+            <member  objecttype="objectType"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
+            <member><type>uint64_t</type>                         <name>tagName</name><comment>The name of the tag to set on the object</comment></member>
+            <member><type>size_t</type>                           <name>tagSize</name><comment>The length in bytes of the tag data</comment></member>
+            <member len="tagSize">const <type>void</type>*        <name>pTag</name><comment>Tag data to attach to the object</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name><comment>Name of the debug marker</comment></member>
+            <member><type>float</type>            <name>color</name>[4]<comment>Optional color for debug marker</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationImageCreateInfoNV" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this image uses a dedicated allocation</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationBufferCreateInfoNV" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this buffer uses a dedicated allocation</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
+            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
+        </type>
+        <type category="struct" name="VkExternalImageFormatPropertiesNV" returnedonly="true">
+            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
+            <member optional="true"><type>VkExternalMemoryFeatureFlagsNV</type>   <name>externalMemoryFeatures</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>exportFromImportedHandleTypes</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>compatibleHandleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryImageCreateInfoNV" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>                           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
+            <member optional="true"><type>DWORD</type>                            <name>dwAccess</name></member>
+        </type>
+        <type category="struct" name="VkExportMemorySciBufInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member><type>NvSciBufAttrList</type>                            <name>pAttributes</name></member>
+        </type>
+        <type category="struct" name="VkImportMemorySciBufInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type>     <name>handleType</name></member>
+            <member><type>NvSciBufObj</type>                            <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetSciBufInfoNV">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                         <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type>     <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkMemorySciBufPropertiesNV">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                               <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemorySciBufFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
+            <member><type>VkBool32</type>                                    <name>sciBufImport</name></member>
+            <member><type>VkBool32</type>                                    <name>sciBufExport</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSciBufFeaturesNV"  alias="VkPhysicalDeviceExternalMemorySciBufFeaturesNV"/>
+        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoNV" structextends="VkSubmitInfo,VkSubmitInfo2">
+            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>acquireCount</name></member>
+            <member len="acquireCount">const <type>VkDeviceMemory</type>*            <name>pAcquireSyncs</name></member>
+            <member len="acquireCount">const <type>uint64_t</type>*                  <name>pAcquireKeys</name></member>
+            <member len="acquireCount">const <type>uint32_t</type>*                  <name>pAcquireTimeoutMilliseconds</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>releaseCount</name></member>
+            <member len="releaseCount">const <type>VkDeviceMemory</type>*            <name>pReleaseSyncs</name></member>
+            <member len="releaseCount">const <type>uint64_t</type>*                  <name>pReleaseKeys</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>deviceGeneratedCommands</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>deviceGeneratedCompute</name></member>
+            <member><type>VkBool32</type>                       <name>deviceGeneratedComputePipelines</name></member>
+            <member><type>VkBool32</type>                       <name>deviceGeneratedComputeCaptureReplay</name></member>
+        </type>
+        <type category="struct" name="VkDevicePrivateDataCreateInfo" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                               <name>privateDataSlotRequestCount</name></member>
+        </type>
+        <type category="struct" name="VkDevicePrivateDataCreateInfoEXT" alias="VkDevicePrivateDataCreateInfo"/>
+        <type category="struct" name="VkPrivateDataSlotCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPrivateDataSlotCreateFlags</type>        <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPrivateDataSlotCreateInfoEXT" alias="VkPrivateDataSlotCreateInfo"/>
+        <type category="struct" name="VkPhysicalDevicePrivateDataFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>privateData</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePrivateDataFeaturesEXT" alias="VkPhysicalDevicePrivateDataFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxGraphicsShaderGroupCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectSequenceCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenOffset</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamStride</name></member>
+            <member limittype="min"><type>uint32_t</type>         <name>minSequencesCountBufferOffsetAlignment</name></member>
+            <member limittype="min"><type>uint32_t</type>         <name>minSequencesIndexBufferOffsetAlignment</name></member>
+            <member limittype="min"><type>uint32_t</type>         <name>minIndirectCommandsBufferOffsetAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiDrawPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxMultiDrawCount</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsShaderGroupCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                   <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>*    <name>pStages</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>*                <name>pVertexInputState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>*               <name>pTessellationState</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsPipelineShaderGroupsCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkGraphicsShaderGroupCreateInfoNV</type>*  <name>pGroups</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>pipelineCount</name></member>
+            <member len="pipelineCount">const <type>VkPipeline</type>*                      <name>pPipelines</name></member>
+        </type>
+        <type category="struct" name="VkBindShaderGroupIndirectCommandNV">
+            <member><type>uint32_t</type>         <name>groupIndex</name></member>
+        </type>
+        <type category="struct" name="VkBindIndexBufferIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
+            <member><type>uint32_t</type>         <name>size</name></member>
+            <member><type>VkIndexType</type>      <name>indexType</name></member>
+        </type>
+        <type category="struct" name="VkBindVertexBufferIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
+            <member><type>uint32_t</type>         <name>size</name></member>
+            <member><type>uint32_t</type>         <name>stride</name></member>
+        </type>
+        <type category="struct" name="VkSetStateFlagsIndirectCommandNV">
+            <member><type>uint32_t</type>          <name>data</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsStreamNV">
+            <member><type>VkBuffer</type>      <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>  <name>offset</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsLayoutTokenNV">
+            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkIndirectCommandsTokenTypeNV</type>  <name>tokenType</name></member>
+            <member><type>uint32_t</type>                       <name>stream</name></member>
+            <member><type>uint32_t</type>                       <name>offset</name></member>
+            <member><type>uint32_t</type>                                <name>vertexBindingUnit</name></member>
+            <member><type>VkBool32</type>                                <name>vertexDynamicStride</name></member>
+            <member optional="true"><type>VkPipelineLayout</type>        <name>pushconstantPipelineLayout</name></member>
+            <member optional="true"><type>VkShaderStageFlags</type>      <name>pushconstantShaderStageFlags</name></member>
+            <member><type>uint32_t</type>                                <name>pushconstantOffset</name></member>
+            <member><type>uint32_t</type>                                <name>pushconstantSize</name></member>
+            <member optional="true"><type>VkIndirectStateFlagsNV</type>  <name>indirectStateFlags</name></member>
+            <member optional="true"><type>uint32_t</type>                <name>indexTypeCount</name></member>
+            <member len="indexTypeCount">const <type>VkIndexType</type>* <name>pIndexTypes</name></member>
+            <member len="indexTypeCount">const <type>uint32_t</type>*    <name>pIndexTypeValues</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member optional="true"><type>VkIndirectCommandsLayoutUsageFlagsNV</type>    <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>                     <name>pipelineBindPoint</name></member>
+            <member><type>uint32_t</type>                                <name>tokenCount</name></member>
+            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenNV</type>*  <name>pTokens</name></member>
+            <member><type>uint32_t</type>                                <name>streamCount</name></member>
+            <member len="streamCount">const <type>uint32_t</type>*       <name>pStreamStrides</name></member>
+        </type>
+        <type category="struct" name="VkGeneratedCommandsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkPipelineBindPoint</type>                <name>pipelineBindPoint</name></member>
+            <member><type>VkPipeline</type>                         <name>pipeline</name></member>
+            <member><type>VkIndirectCommandsLayoutNV</type>         <name>indirectCommandsLayout</name></member>
+            <member><type>uint32_t</type>                           <name>streamCount</name></member>
+            <member len="streamCount">const <type>VkIndirectCommandsStreamNV</type>*  <name>pStreams</name></member>
+            <member><type>uint32_t</type>                           <name>sequencesCount</name></member>
+            <member><type>VkBuffer</type>                           <name>preprocessBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>preprocessOffset</name></member>
+            <member><type>VkDeviceSize</type>                       <name>preprocessSize</name></member>
+            <member optional="true"><type>VkBuffer</type>           <name>sequencesCountBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>sequencesCountOffset</name></member>
+            <member optional="true"><type>VkBuffer</type>           <name>sequencesIndexBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>sequencesIndexOffset</name></member>
+        </type>
+        <type category="struct" name="VkGeneratedCommandsMemoryRequirementsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member><type>VkPipelineBindPoint</type>         <name>pipelineBindPoint</name></member>
+            <member optional="true"><type>VkPipeline</type>  <name>pipeline</name></member>
+            <member><type>VkIndirectCommandsLayoutNV</type>  <name>indirectCommandsLayout</name></member>
+            <member><type>uint32_t</type>                    <name>maxSequencesCount</name></member>
+        </type>
+        <type category="struct" name="VkPipelineIndirectDeviceAddressInfoNV">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
+            <member><type>VkPipelineBindPoint</type>           <name>pipelineBindPoint</name></member>
+            <member><type>VkPipeline</type>                    <name>pipeline</name></member>
+        </type>
+        <type category="struct" name="VkBindPipelineIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>               <name>pipelineAddress</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures2" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPhysicalDeviceFeatures</type>         <name>features</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures2KHR"                            alias="VkPhysicalDeviceFeatures2"/>
+        <type category="struct" name="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="struct"><type>VkPhysicalDeviceProperties</type>       <name>properties</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProperties2KHR"                          alias="VkPhysicalDeviceProperties2"/>
+        <type category="struct" name="VkFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFormatProperties</type>               <name>formatProperties</name></member>
+        </type>
+        <type category="struct" name="VkFormatProperties2KHR"                                  alias="VkFormatProperties2"/>
+        <type category="struct" name="VkImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatProperties2KHR"                             alias="VkImageFormatProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkImageType</type>                      <name>type</name></member>
+            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
+            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2KHR"                     alias="VkPhysicalDeviceImageFormatInfo2"/>
+        <type category="struct" name="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="struct"><type>VkQueueFamilyProperties</type>       <name>queueFamilyProperties</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyProperties2KHR"                             alias="VkQueueFamilyProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPhysicalDeviceMemoryProperties</type> <name>memoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties2KHR"                    alias="VkPhysicalDeviceMemoryProperties2"/>
+        <type category="struct" name="VkSparseImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="struct"><type>VkSparseImageFormatProperties</type> <name>properties</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageFormatProperties2KHR"                       alias="VkSparseImageFormatProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkImageType</type>                      <name>type</name></member>
+            <member><type>VkSampleCountFlagBits</type>            <name>samples</name></member>
+            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
+            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2KHR"               alias="VkPhysicalDeviceSparseImageFormatInfo2"/>
+        <type category="struct" name="VkPhysicalDevicePushDescriptorPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPushDescriptors</name></member>
+        </type>
+        <type category="struct" name="VkConformanceVersion">
+            <member><type>uint8_t</type>                          <name>major</name></member>
+            <member><type>uint8_t</type>                          <name>minor</name></member>
+            <member><type>uint8_t</type>                          <name>subminor</name></member>
+            <member><type>uint8_t</type>                          <name>patch</name></member>
+        </type>
+        <type category="struct" name="VkConformanceVersionKHR"                                 alias="VkConformanceVersion"/>
+        <type category="struct" name="VkPhysicalDeviceDriverProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="exact"><type>VkDriverId</type>                  <name>driverID</name></member>
+            <member limittype="exact"><type>char</type>                        <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
+            <member limittype="exact"><type>char</type>                        <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
+            <member limittype="exact"><type>VkConformanceVersion</type>        <name>conformanceVersion</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDriverPropertiesKHR"                     alias="VkPhysicalDeviceDriverProperties"/>
+        <type category="struct" name="VkPresentRegionsKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>VkPresentRegionKHR</type>*   <name>pRegions</name><comment>The regions that have changed</comment></member>
+        </type>
+        <type category="struct" name="VkPresentRegionKHR">
+            <member optional="true"><type>uint32_t</type>         <name>rectangleCount</name><comment>Number of rectangles in pRectangles</comment></member>
+            <member optional="true" len="rectangleCount">const <type>VkRectLayerKHR</type>*   <name>pRectangles</name><comment>Array of rectangles that have changed in a swapchain's image(s)</comment></member>
+        </type>
+        <type category="struct" name="VkRectLayerKHR">
+            <member><type>VkOffset2D</type>                       <name>offset</name><comment>upper-left corner of a rectangle that has not changed, in pixels of a presentation images</comment></member>
+            <member noautovalidity="true"><type>VkExtent2D</type> <name>extent</name><comment>Dimensions of a rectangle that has not changed, in pixels of a presentation images</comment></member>
+            <member><type>uint32_t</type>                         <name>layer</name><comment>Layer of a swapchain's image(s), for stereoscopic-3D images</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVariablePointersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVariablePointersFeaturesKHR"             alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceVariablePointerFeaturesKHR"              alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceVariablePointerFeatures"                 alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkExternalMemoryProperties" returnedonly="true">
+            <member><type>VkExternalMemoryFeatureFlags</type>  <name>externalMemoryFeatures</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryPropertiesKHR"                           alias="VkExternalMemoryProperties"/>
+        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfo"  structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfoKHR"              alias="VkPhysicalDeviceExternalImageFormatInfo"/>
+        <type category="struct" name="VkExternalImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalMemoryProperties</type> <name>externalMemoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkExternalImageFormatPropertiesKHR"                      alias="VkExternalImageFormatProperties"/>
+        <type category="struct" name="VkPhysicalDeviceExternalBufferInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkBufferCreateFlags</type> <name>flags</name></member>
+            <member><type>VkBufferUsageFlags</type>               <name>usage</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalBufferInfoKHR"                   alias="VkPhysicalDeviceExternalBufferInfo"/>
+        <type category="struct" name="VkExternalBufferProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalMemoryProperties</type>    <name>externalMemoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkExternalBufferPropertiesKHR"                           alias="VkExternalBufferProperties"/>
+        <type category="struct" name="VkPhysicalDeviceIDProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>uint8_t</type>                     <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                     <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                     <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint32_t</type>                    <name>deviceNodeMask</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                    <name>deviceLUIDValid</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceIDPropertiesKHR"                         alias="VkPhysicalDeviceIDProperties"/>
+        <type category="struct" name="VkExternalMemoryImageCreateInfo" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryImageCreateInfoKHR"                      alias="VkExternalMemoryImageCreateInfo"/>
+        <type category="struct" name="VkExternalMemoryBufferCreateInfo" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryBufferCreateInfoKHR"                     alias="VkExternalMemoryBufferCreateInfo"/>
+        <type category="struct" name="VkExportMemoryAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryAllocateInfoKHR"                           alias="VkExportMemoryAllocateInfo"/>
+        <type category="struct" name="VkImportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
+            <member><type>DWORD</type>                            <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryZirconHandleInfoFUCHSIA" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>zx_handle_t</type>           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkMemoryZirconHandlePropertiesFUCHSIA" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkMemoryWin32HandlePropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryFdInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>int</type>                              <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkMemoryFdPropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2">
+            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>acquireCount</name></member>
+            <member len="acquireCount">const <type>VkDeviceMemory</type>* <name>pAcquireSyncs</name></member>
+            <member len="acquireCount">const <type>uint64_t</type>* <name>pAcquireKeys</name></member>
+            <member len="acquireCount">const <type>uint32_t</type>* <name>pAcquireTimeouts</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>releaseCount</name></member>
+            <member len="releaseCount">const <type>VkDeviceMemory</type>* <name>pReleaseSyncs</name></member>
+            <member len="releaseCount">const <type>uint64_t</type>* <name>pReleaseKeys</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryMetalHandleInfoEXT" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>void</type>*           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkMemoryMetalHandlePropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetMetalHandleInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfoKHR"                alias="VkPhysicalDeviceExternalSemaphoreInfo"/>
+        <type category="struct" name="VkExternalSemaphoreProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+            <member optional="true"><type>VkExternalSemaphoreFeatureFlags</type> <name>externalSemaphoreFeatures</name></member>
+        </type>
+        <type category="struct" name="VkExternalSemaphorePropertiesKHR"                        alias="VkExternalSemaphoreProperties"/>
+        <type category="struct" name="VkExportSemaphoreCreateInfo" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalSemaphoreHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportSemaphoreCreateInfoKHR"                          alias="VkExportSemaphoreCreateInfo"/>
+        <type category="struct" name="VkImportSemaphoreWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member noautovalidity="true"><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportSemaphoreWin32HandleInfoKHR" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
+            <member><type>DWORD</type>                            <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkD3D12FenceSubmitInfoKHR" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValuesCount</name></member>
+            <member optional="true" len="waitSemaphoreValuesCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValuesCount</name></member>
+            <member optional="true" len="signalSemaphoreValuesCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportSemaphoreFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>int</type>                              <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportSemaphoreZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>zx_handle_t</type>                              <name>zirconHandle</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFenceInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFenceInfoKHR"                    alias="VkPhysicalDeviceExternalFenceInfo"/>
+        <type category="struct" name="VkExternalFenceProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalFenceHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalFenceHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+            <member optional="true"><type>VkExternalFenceFeatureFlags</type> <name>externalFenceFeatures</name></member>
+        </type>
+        <type category="struct" name="VkExternalFencePropertiesKHR"                            alias="VkExternalFenceProperties"/>
+        <type category="struct" name="VkExportFenceCreateInfo" structextends="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalFenceHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportFenceCreateInfoKHR"                              alias="VkExportFenceCreateInfo"/>
+        <type category="struct" name="VkImportFenceWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                        <name>pNext</name></member>
+            <member externsync="true"><type>VkFence</type>                          <name>fence</name></member>
+            <member optional="true"><type>VkFenceImportFlags</type>              <name>flags</name></member>
+            <member noautovalidity="true"><type>VkExternalFenceHandleTypeFlagBits</type>  <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>                             <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>                            <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportFenceWin32HandleInfoKHR" structextends="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
+            <member><type>DWORD</type>                                      <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                                    <name>name</name></member>
+        </type>
+        <type category="struct" name="VkFenceGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFence</type>                                <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportFenceFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
+            <member optional="true"><type>VkFenceImportFlags</type>  <name>flags</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+            <member><type>int</type>                                    <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkFenceGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFence</type>                                <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkExportFenceSciSyncInfoNV" structextends="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>NvSciSyncAttrList</type>                      <name>pAttributes</name></member>
+        </type>
+        <type category="struct" name="VkImportFenceSciSyncInfoNV">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>      <name>handleType</name></member>
+            <member><type>void</type>*                                  <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkFenceGetSciSyncInfoNV">
+            <member values="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkFence</type>                                <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>      <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkExportSemaphoreSciSyncInfoNV" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>NvSciSyncAttrList</type>                      <name>pAttributes</name></member>
+        </type>
+        <type category="struct" name="VkImportSemaphoreSciSyncInfoNV">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>          <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type>  <name>handleType</name></member>
+            <member><type>void</type>*                                  <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetSciSyncInfoNV">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                            <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type>  <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkSciSyncAttributesInfoNV">
+            <member values="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSciSyncClientTypeNV</type>                  <name>clientType</name></member>
+            <member><type>VkSciSyncPrimitiveTypeNV</type>               <name>primitiveType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSciSyncFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncFence</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncSemaphore</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncImport</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncExport</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSciSync2FeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncFence</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncSemaphore2</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncImport</name></member>
+            <member><type>VkBool32</type>                               <name>sciSyncExport</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSciSyncPoolCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>NvSciSyncObj</type>                           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSciSyncCreateInfoNV" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphoreSciSyncPoolNV</type>               <name>semaphorePool</name></member>
+            <member>const <type>NvSciSyncFence</type>*                  <name>pFence</name></member>
+        </type>
+        <type category="struct" name="VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                               <name>semaphoreSciSyncPoolRequestCount</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a renderpass</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a renderpass w/ geometry shader</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a renderpass w/ tessellation shader</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewFeaturesKHR"                    alias="VkPhysicalDeviceMultiviewFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceMultiviewProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPropertiesKHR"                  alias="VkPhysicalDeviceMultiviewProperties"/>
+        <type category="struct" name="VkRenderPassMultiviewCreateInfo" structextends="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"><type>VkStructureType</type>        <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>uint32_t</type>*     <name>pViewMasks</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>int32_t</type>*   <name>pViewOffsets</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>correlationMaskCount</name></member>
+            <member len="correlationMaskCount">const <type>uint32_t</type>* <name>pCorrelationMasks</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassMultiviewCreateInfoKHR"                      alias="VkRenderPassMultiviewCreateInfo"/>
+        <type category="struct" name="VkSurfaceCapabilities2EXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
+            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
+            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
+            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
+            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
+            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
+            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type> <name>supportedSurfaceCounters</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPowerInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDisplayPowerStateEXT</type>           <name>powerState</name></member>
+        </type>
+        <type category="struct" name="VkDeviceEventInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceEventTypeEXT</type>             <name>deviceEvent</name></member>
+        </type>
+        <type category="struct" name="VkDisplayEventInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDisplayEventTypeEXT</type>            <name>displayEvent</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainCounterCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type>         <name>surfaceCounters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGroupProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
+            <member><type>VkPhysicalDevice</type>                 <name>physicalDevices</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
+            <member><type>VkBool32</type>                         <name>subsetAllocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGroupPropertiesKHR"                      alias="VkPhysicalDeviceGroupProperties"/>
+        <type category="struct" name="VkMemoryAllocateFlagsInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkMemoryAllocateFlags</type> <name>flags</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkMemoryAllocateFlagsInfoKHR"                            alias="VkMemoryAllocateFlagsInfo"/>
+        <type category="struct" name="VkBindBufferMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBuffer</type>                         <name>buffer</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+        </type>
+        <type category="struct" name="VkBindBufferMemoryInfoKHR"                               alias="VkBindBufferMemoryInfo"/>
+        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfo" structextends="VkBindBufferMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfoKHR"                    alias="VkBindBufferMemoryDeviceGroupInfo"/>
+        <type category="struct" name="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImage</type>                          <name>image</name></member>
+            <member noautovalidity="true"><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemoryInfoKHR"                                alias="VkBindImageMemoryInfo"/>
+        <type category="struct" name="VkBindImageMemoryDeviceGroupInfo" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>splitInstanceBindRegionCount</name></member>
+            <member len="splitInstanceBindRegionCount">const <type>VkRect2D</type>*  <name>pSplitInstanceBindRegions</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemoryDeviceGroupInfoKHR"                     alias="VkBindImageMemoryDeviceGroupInfo"/>
+        <type category="struct" name="VkDeviceGroupRenderPassBeginInfo" structextends="VkRenderPassBeginInfo,VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceRenderAreaCount</name></member>
+            <member len="deviceRenderAreaCount">const <type>VkRect2D</type>*  <name>pDeviceRenderAreas</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupRenderPassBeginInfoKHR"                     alias="VkDeviceGroupRenderPassBeginInfo"/>
+        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfo" structextends="VkCommandBufferBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfoKHR"                  alias="VkDeviceGroupCommandBufferBeginInfo"/>
+        <type category="struct" name="VkDeviceGroupSubmitInfo" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>uint32_t</type>*    <name>pWaitSemaphoreDeviceIndices</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>commandBufferCount</name></member>
+            <member len="commandBufferCount">const <type>uint32_t</type>*    <name>pCommandBufferDeviceMasks</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>uint32_t</type>*  <name>pSignalSemaphoreDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupSubmitInfoKHR"                              alias="VkDeviceGroupSubmitInfo"/>
+        <type category="struct" name="VkDeviceGroupBindSparseInfo" structextends="VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>resourceDeviceIndex</name></member>
+            <member><type>uint32_t</type>                         <name>memoryDeviceIndex</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupBindSparseInfoKHR"                          alias="VkDeviceGroupBindSparseInfo"/>
+        <type category="struct" name="VkDeviceGroupPresentCapabilitiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>presentMask</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
+            <member><type>VkDeviceGroupPresentModeFlagsKHR</type> <name>modes</name></member>
+        </type>
+        <type category="struct" name="VkImageSwapchainCreateInfoKHR" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSwapchainKHR</type>   <name>swapchain</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemorySwapchainInfoKHR" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
+            <member><type>uint32_t</type>                         <name>imageIndex</name></member>
+        </type>
+        <type category="struct" name="VkAcquireNextImageInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
+            <member><type>uint64_t</type>                         <name>timeout</name></member>
+            <member optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></member>
+            <member optional="true" externsync="true"><type>VkFence</type> <name>fence</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupPresentInfoKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>swapchainCount</name></member>
+            <member len="swapchainCount">const <type>uint32_t</type>* <name>pDeviceMasks</name></member>
+            <member><type>VkDeviceGroupPresentModeFlagBitsKHR</type> <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupDeviceCreateInfo" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
+            <member len="physicalDeviceCount">const <type>VkPhysicalDevice</type>*  <name>pPhysicalDevices</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupDeviceCreateInfoKHR"                        alias="VkDeviceGroupDeviceCreateInfo"/>
+        <type category="struct" name="VkDeviceGroupSwapchainCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceGroupPresentModeFlagsKHR</type>                         <name>modes</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateEntry">
+            <member><type>uint32_t</type>                         <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
+            <member><type>uint32_t</type>                         <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
+            <member><type>uint32_t</type>                         <name>descriptorCount</name><comment>Number of descriptors to write</comment></member>
+            <member><type>VkDescriptorType</type>                 <name>descriptorType</name><comment>Descriptor type to write</comment></member>
+            <member><type>size_t</type>                           <name>offset</name><comment>Offset into pData where the descriptors to update are stored</comment></member>
+            <member><type>size_t</type>                           <name>stride</name><comment>Stride between two descriptors in pData when writing more than one descriptor</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateEntryKHR"                      alias="VkDescriptorUpdateTemplateEntry"/>
+        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorUpdateTemplateCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>                 <name>descriptorUpdateEntryCount</name><comment>Number of descriptor update entries to use for the update template</comment></member>
+            <member len="descriptorUpdateEntryCount">const <type>VkDescriptorUpdateTemplateEntry</type>* <name>pDescriptorUpdateEntries</name><comment>Descriptor update entries for the template</comment></member>
+            <member><type>VkDescriptorUpdateTemplateType</type> <name>templateType</name></member>
+            <member noautovalidity="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></member>
+            <member noautovalidity="true"><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></member>
+            <member noautovalidity="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name><comment>If used for push descriptors, this is the only allowed layout</comment></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>set</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfoKHR"                 alias="VkDescriptorUpdateTemplateCreateInfo"/>
+        <type category="struct" name="VkXYColorEXT" comment="Chromaticity coordinate">
+            <member><type>float</type>   <name>x</name></member>
+            <member><type>float</type>   <name>y</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentIdFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>presentId</name><comment>Present ID in VkPresentInfoKHR</comment></member>
+        </type>
+        <type category="struct" name="VkPresentIdKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>uint64_t</type>* <name>pPresentIds</name><comment>Present ID values for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentWaitFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>presentWait</name><comment>vkWaitForPresentKHR is supported</comment></member>
+        </type>
+        <type category="struct" name="VkHdrMetadataEXT">
+                <comment>Display primary in chromaticity coordinates</comment>
+            <member values="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+                <comment> From SMPTE 2086</comment>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryRed</name><comment>Display primary's Red</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryGreen</name><comment>Display primary's Green</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryBlue</name><comment>Display primary's Blue</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>whitePoint</name><comment>Display primary's Blue</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>maxLuminance</name><comment>Display maximum luminance</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>minLuminance</name><comment>Display minimum luminance</comment></member>
+                <comment> From CTA 861.3</comment>
+            <member noautovalidity="true"><type>float</type>          <name>maxContentLightLevel</name><comment>Content maximum luminance</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>maxFrameAverageLightLevel</name></member>
+        </type>
+        <type category="struct" name="VkDisplayNativeHdrSurfaceCapabilitiesAMD" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>localDimmingSupport</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainDisplayNativeHdrCreateInfoAMD" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>localDimmingEnable</name></member>
+        </type>
+        <type category="struct" name="VkRefreshCycleDurationGOOGLE" returnedonly="true">
+            <member><type>uint64_t</type>                         <name>refreshDuration</name><comment>Number of nanoseconds from the start of one refresh cycle to the next</comment></member>
+        </type>
+        <type category="struct" name="VkPastPresentationTimingGOOGLE" returnedonly="true">
+            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier, previously given to vkQueuePresentKHR</comment></member>
+            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should have been presented, previously given to vkQueuePresentKHR</comment></member>
+            <member><type>uint64_t</type>                         <name>actualPresentTime</name><comment>Time the image was actually displayed</comment></member>
+            <member><type>uint64_t</type>                         <name>earliestPresentTime</name><comment>Earliest time the image could have been displayed</comment></member>
+            <member><type>uint64_t</type>                         <name>presentMargin</name><comment>How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime</comment></member>
+        </type>
+        <type category="struct" name="VkPresentTimesInfoGOOGLE" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>VkPresentTimeGOOGLE</type>*   <name>pTimes</name><comment>The earliest times to present images</comment></member>
+        </type>
+        <type category="struct" name="VkPresentTimeGOOGLE">
+            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier</comment></member>
+            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should be presented</comment></member>
+        </type>
+        <type category="struct" name="VkIOSSurfaceCreateInfoMVK">
+            <member values="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkIOSSurfaceCreateFlagsMVK</type>     <name>flags</name></member>
+            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
+        </type>
+        <type category="struct" name="VkMacOSSurfaceCreateInfoMVK">
+            <member values="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkMacOSSurfaceCreateFlagsMVK</type>   <name>flags</name></member>
+            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
+        </type>
+        <type category="struct" name="VkMetalSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkMetalSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+            <member noautovalidity="true">const <type>CAMetalLayer</type>*      <name>pLayer</name></member>
+        </type>
+        <type category="struct" name="VkViewportWScalingNV">
+            <member><type>float</type>          <name>xcoeff</name></member>
+            <member><type>float</type>          <name>ycoeff</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportWScalingStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>viewportWScalingEnable</name></member>
+            <member><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewportWScalingNV</type>*      <name>pViewportWScalings</name></member>
+        </type>
+        <type category="struct" name="VkViewportSwizzleNV">
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>x</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>y</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>z</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>w</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportSwizzleStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineViewportSwizzleStateCreateFlagsNV</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member len="viewportCount">const <type>VkViewportSwizzleNV</type>*      <name>pViewportSwizzles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDiscardRectanglePropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDiscardRectangles</name><comment>max number of active discard rectangles</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineDiscardRectangleStateCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDiscardRectangleStateCreateFlagsEXT</type>     <name>flags</name></member>
+            <member><type>VkDiscardRectangleModeEXT</type>                                         <name>discardRectangleMode</name></member>
+            <member optional="true"><type>uint32_t</type>                                          <name>discardRectangleCount</name></member>
+            <member noautovalidity="true" len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>perViewPositionAllComponents</name></member>
+        </type>
+        <type category="struct" name="VkInputAttachmentAspectReference">
+            <member><type>uint32_t</type>                        <name>subpass</name></member>
+            <member><type>uint32_t</type>                        <name>inputAttachmentIndex</name></member>
+            <member><type>VkImageAspectFlags</type>              <name>aspectMask</name></member>
+        </type>
+        <type category="struct" name="VkInputAttachmentAspectReferenceKHR"                     alias="VkInputAttachmentAspectReference"/>
+        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfo" structextends="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>aspectReferenceCount</name></member>
+            <member len="aspectReferenceCount">const <type>VkInputAttachmentAspectReference</type>* <name>pAspectReferences</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfoKHR"          alias="VkRenderPassInputAttachmentAspectCreateInfo"/>
+        <type category="struct" name="VkPhysicalDeviceSurfaceInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>VkSurfaceKHR</type> <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilities2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*   <name>pNext</name></member>
+            <member><type>VkSurfaceCapabilitiesKHR</type> <name>surfaceCapabilities</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFormat2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkSurfaceFormatKHR</type> <name>surfaceFormat</name></member>
+        </type>
+        <type category="struct" name="VkDisplayProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPropertiesKHR</type> <name>displayProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPlanePropertiesKHR</type> <name>displayPlaneProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayModeProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayModePropertiesKHR</type> <name>displayModeProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></member>
+            <member><type>uint32_t</type> <name>planeIndex</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneCapabilities2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPlaneCapabilitiesKHR</type> <name>capabilities</name></member>
+        </type>
+        <type category="struct" name="VkSharedPresentSurfaceCapabilitiesKHR" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkImageUsageFlags</type> <name>sharedPresentSupportedUsageFlags</name><comment>Supported image usage flags if swapchain created using a shared present mode</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice16BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice16BitStorageFeaturesKHR"                 alias="VkPhysicalDevice16BitStorageFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceSubgroupProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type>                     <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>supportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>supportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type> <name>quadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkBool32</type> <name>shaderSubgroupExtendedTypes</name><comment>Flag to specify whether subgroup operations with extended types are supported</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"  alias="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
+        <type category="struct" name="VkBufferMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkBuffer</type>                                                             <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryRequirementsInfo2KHR"                      alias="VkBufferMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkDeviceBufferMemoryRequirements">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                           <name>pNext</name></member>
+            <member>const <type>VkBufferCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
+        </type>
+        <type category="struct" name="VkDeviceBufferMemoryRequirementsKHR" alias="VkDeviceBufferMemoryRequirements"/>
+        <type category="struct" name="VkImageMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkImage</type>                                                              <name>image</name></member>
+        </type>
+        <type category="struct" name="VkImageMemoryRequirementsInfo2KHR"                       alias="VkImageMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkImage</type>                                                              <name>image</name></member>
+        </type>
+        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2KHR"                 alias="VkImageSparseMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkDeviceImageMemoryRequirements">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member>const <type>VkImageCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
+            <member optional="true"><type>VkImageAspectFlagBits</type>                                                <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkDeviceImageMemoryRequirementsKHR" alias="VkDeviceImageMemoryRequirements"/>
+        <type category="struct" name="VkMemoryRequirements2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkMemoryRequirements</type>                                                 <name>memoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkMemoryRequirements2KHR"                                alias="VkMemoryRequirements2"/>
+        <type category="struct" name="VkSparseImageMemoryRequirements2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                       <name>pNext</name></member>
+            <member><type>VkSparseImageMemoryRequirements</type>                                      <name>memoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryRequirements2KHR"                     alias="VkSparseImageMemoryRequirements2"/>
+        <type category="struct" name="VkPhysicalDevicePointClippingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="exact"><type>VkPointClippingBehavior</type>     <name>pointClippingBehavior</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePointClippingPropertiesKHR"              alias="VkPhysicalDevicePointClippingProperties"/>
+        <type category="struct" name="VkMemoryDedicatedRequirements" returnedonly="true" structextends="VkMemoryRequirements2">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>prefersDedicatedAllocation</name></member>
+            <member><type>VkBool32</type>                         <name>requiresDedicatedAllocation</name></member>
+        </type>
+        <type category="struct" name="VkMemoryDedicatedRequirementsKHR"                        alias="VkMemoryDedicatedRequirements"/>
+        <type category="struct" name="VkMemoryDedicatedAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
+            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryDedicatedAllocateInfoKHR"                        alias="VkMemoryDedicatedAllocateInfo"/>
+        <type category="struct" name="VkImageViewUsageCreateInfo" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type> <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkImageViewSlicedCreateInfoEXT" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type> <name>sliceOffset</name></member>
+            <member><type>uint32_t</type> <name>sliceCount</name></member>
+        </type>
+        <type category="struct" name="VkImageViewUsageCreateInfoKHR"                           alias="VkImageViewUsageCreateInfo"/>
+        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfo" structextends="VkPipelineTessellationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkTessellationDomainOrigin</type>    <name>domainOrigin</name></member>
+        </type>
+        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"    alias="VkPipelineTessellationDomainOriginStateCreateInfo"/>
+        <type category="struct" name="VkSamplerYcbcrConversionInfo" structextends="VkSamplerCreateInfo,VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSamplerYcbcrConversion</type>      <name>conversion</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionInfoKHR"                         alias="VkSamplerYcbcrConversionInfo"/>
+        <type category="struct" name="VkSamplerYcbcrConversionCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type> <name>ycbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>           <name>ycbcrRange</name></member>
+            <member><type>VkComponentMapping</type>               <name>components</name></member>
+            <member><type>VkChromaLocation</type>              <name>xChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>              <name>yChromaOffset</name></member>
+            <member><type>VkFilter</type>                         <name>chromaFilter</name></member>
+            <member><type>VkBool32</type>                         <name>forceExplicitReconstruction</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionCreateInfoKHR"                   alias="VkSamplerYcbcrConversionCreateInfo"/>
+        <type category="struct" name="VkBindImagePlaneMemoryInfo" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkBindImagePlaneMemoryInfoKHR"                           alias="VkBindImagePlaneMemoryInfo"/>
+        <type category="struct" name="VkImagePlaneMemoryRequirementsInfo" structextends="VkImageMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkImagePlaneMemoryRequirementsInfoKHR"                   alias="VkImagePlaneMemoryRequirementsInfo"/>
+        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"       alias="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
+        <type category="struct" name="VkSamplerYcbcrConversionImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>combinedImageSamplerDescriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"        alias="VkSamplerYcbcrConversionImageFormatProperties"/>
+        <type category="struct" name="VkTextureLODGatherFormatPropertiesAMD" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>supportsTextureGatherLODBiasAMD</name></member>
+        </type>
+        <type category="struct" name="VkConditionalRenderingBeginInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBuffer</type>                         <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
+            <member optional="true"><type>VkConditionalRenderingFlagsEXT</type>    <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkProtectedSubmitInfo" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                        <name>protectedSubmit</name><comment>Submit protected command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProtectedMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>protectedMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProtectedMemoryProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="exact"><type>VkBool32</type>                            <name>protectedNoFault</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueInfo2">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceQueueCreateFlags</type>            <name>flags</name></member>
+            <member><type>uint32_t</type>                            <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                            <name>queueIndex</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCoverageToColorStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageToColorStateCreateFlagsNV</type>                    <name>flags</name></member>
+            <member><type>VkBool32</type>                         <name>coverageToColorEnable</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>coverageToColorLocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>filterMinmaxSingleComponentFormats</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>filterMinmaxImageComponentMapping</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" alias="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
+        <type category="struct" name="VkSampleLocationEXT">
+            <member><type>float</type>                            <name>x</name></member>
+            <member><type>float</type>                            <name>y</name></member>
+        </type>
+        <type category="struct" name="VkSampleLocationsInfoEXT" structextends="VkImageMemoryBarrier,VkImageMemoryBarrier2">
+            <member values="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkSampleCountFlagBits</type>  <name>sampleLocationsPerPixel</name></member>
+            <member><type>VkExtent2D</type>                             <name>sampleLocationGridSize</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>sampleLocationsCount</name></member>
+            <member len="sampleLocationsCount">const <type>VkSampleLocationEXT</type>* <name>pSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentSampleLocationsEXT">
+            <member><type>uint32_t</type>                         <name>attachmentIndex</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkSubpassSampleLocationsEXT">
+            <member><type>uint32_t</type>                         <name>subpassIndex</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassSampleLocationsBeginInfoEXT" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>attachmentInitialSampleLocationsCount</name></member>
+            <member len="attachmentInitialSampleLocationsCount">const <type>VkAttachmentSampleLocationsEXT</type>* <name>pAttachmentInitialSampleLocations</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>postSubpassSampleLocationsCount</name></member>
+            <member len="postSubpassSampleLocationsCount">const <type>VkSubpassSampleLocationsEXT</type>* <name>pPostSubpassSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineSampleLocationsStateCreateInfoEXT" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>sampleLocationsEnable</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSampleLocationsPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkSampleCountFlags</type>               <name>sampleLocationSampleCounts</name></member>
+            <member limittype="max"><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
+            <member limittype="range"><type>float</type>                            <name>sampleLocationCoordinateRange</name>[2]</member>
+            <member limittype="bits"><type>uint32_t</type>                         <name>sampleLocationSubPixelBits</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>variableSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkMultisamplePropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
+        </type>
+        <type category="struct" name="VkSamplerReductionModeCreateInfo" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSamplerReductionMode</type>           <name>reductionMode</name></member>
+        </type>
+        <type category="struct" name="VkSamplerReductionModeCreateInfoEXT" alias="VkSamplerReductionModeCreateInfo"/>
+        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>advancedBlendCoherentOperations</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiDrawFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>multiDraw</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>advancedBlendMaxColorAttachments</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendIndependentBlend</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedSrcColor</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedDstColor</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendCorrelatedOverlap</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendAllOperations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendAdvancedStateCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>srcPremultiplied</name></member>
+            <member><type>VkBool32</type>               <name>dstPremultiplied</name></member>
+            <member><type>VkBlendOverlapEXT</type>      <name>blendOverlap</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>inlineUniformBlock</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT" alias="VkPhysicalDeviceInlineUniformBlockFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxInlineUniformBlockSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT" alias="VkPhysicalDeviceInlineUniformBlockProperties"/>
+        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlock" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                    <name>dataSize</name></member>
+            <member len="dataSize">const <type>void</type>*  <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlockEXT" alias="VkWriteDescriptorSetInlineUniformBlock"/>
+        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfo" structextends="VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                    <name>maxInlineUniformBlockBindings</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT" alias="VkDescriptorPoolInlineUniformBlockCreateInfo"/>
+        <type category="struct" name="VkPipelineCoverageModulationStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageModulationStateCreateFlagsNV</type>                   <name>flags</name></member>
+            <member><type>VkCoverageModulationModeNV</type>                                                       <name>coverageModulationMode</name></member>
+            <member><type>VkBool32</type>                                                                         <name>coverageModulationTableEnable</name></member>
+            <member optional="true"><type>uint32_t</type>                                                         <name>coverageModulationTableCount</name></member>
+            <member noautovalidity="true" optional="true" len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatListCreateInfo" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>viewFormatCount</name></member>
+            <member len="viewFormatCount">const <type>VkFormat</type>*  <name>pViewFormats</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatListCreateInfoKHR"                          alias="VkImageFormatListCreateInfo"/>
+        <type category="struct" name="VkValidationCacheCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkValidationCacheCreateFlagsEXT</type>    <name>flags</name></member>
+            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>
+            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>
+        </type>
+        <type category="struct" name="VkShaderModuleValidationCacheCreateInfoEXT" structextends="VkShaderModuleCreateInfo,VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkValidationCacheEXT</type>    <name>validationCache</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance3Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance3PropertiesKHR"               alias="VkPhysicalDeviceMaintenance3Properties"/>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                                         <name>maintenance4</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4FeaturesKHR" alias="VkPhysicalDeviceMaintenance4Features"/>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxBufferSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4PropertiesKHR" alias="VkPhysicalDeviceMaintenance4Properties"/>
+        <type category="struct" name="VkPhysicalDeviceMaintenance5FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                                         <name>maintenance5</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance5PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>earlyFragmentMultisampleCoverageAfterSampleCounting</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>earlyFragmentSampleMaskTestBeforeSampleCounting</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>depthStencilSwizzleOneSupport</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>polygonModePointSize</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>nonStrictSinglePixelWideLinesUseParallelogram</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>nonStrictWideLinesUseParallelogram</name></member>
+        </type>
+        <type category="struct" name="VkRenderingAreaInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkFormat</type>*           <name>pColorAttachmentFormats</name></member>
+            <member noautovalidity="true"><type>VkFormat</type>                                             <name>depthAttachmentFormat</name></member>
+            <member noautovalidity="true"><type>VkFormat</type>                                             <name>stencilAttachmentFormat</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutSupport" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>         <name>supported</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutSupportKHR"                         alias="VkDescriptorSetLayoutSupport"/>
+        <type category="struct" name="VkPhysicalDeviceShaderDrawParametersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderDrawParameterFeatures"             alias="VkPhysicalDeviceShaderDrawParametersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"            alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        <type category="struct" name="VkPhysicalDeviceFloat16Int8FeaturesKHR"                  alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        <type category="struct" name="VkPhysicalDeviceFloatControlsProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>denormBehaviorIndependence</name></member>
+            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>roundingModeIndependence</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFloatControlsPropertiesKHR"              alias="VkPhysicalDeviceFloatControlsProperties"/>
+        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>hostQueryReset</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeaturesEXT"               alias="VkPhysicalDeviceHostQueryResetFeatures"/>
+        <type category="struct" name="VkNativeBufferUsage2ANDROID">
+            <member><type>uint64_t</type> <name>consumer</name></member>
+            <member><type>uint64_t</type> <name>producer</name></member>
+        </type>
+        <type category="struct" name="VkNativeBufferANDROID">
+            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member>const <type>void</type>* <name>handle</name></member>
+            <member><type>int</type> <name>stride</name></member>
+            <member><type>int</type> <name>format</name></member>
+            <member><type>int</type> <name>usage</name></member>
+            <member><type>VkNativeBufferUsage2ANDROID</type> <name>usage2</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainImageCreateInfoANDROID">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkSwapchainImageUsageFlagsANDROID</type> <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentationPropertiesANDROID">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>sharedImage</name></member>
+        </type>
+        <type category="struct" name="VkShaderResourceUsageAMD" returnedonly="true">
+            <member><type>uint32_t</type> <name>numUsedVgprs</name></member>
+            <member><type>uint32_t</type> <name>numUsedSgprs</name></member>
+            <member><type>uint32_t</type> <name>ldsSizePerLocalWorkGroup</name></member>
+            <member><type>size_t</type> <name>ldsUsageSizeInBytes</name></member>
+            <member><type>size_t</type> <name>scratchMemUsageInBytes</name></member>
+        </type>
+        <type category="struct" name="VkShaderStatisticsInfoAMD" returnedonly="true">
+            <member><type>VkShaderStageFlags</type> <name>shaderStageMask</name></member>
+            <member><type>VkShaderResourceUsageAMD</type> <name>resourceUsage</name></member>
+            <member><type>uint32_t</type> <name>numPhysicalVgprs</name></member>
+            <member><type>uint32_t</type> <name>numPhysicalSgprs</name></member>
+            <member><type>uint32_t</type> <name>numAvailableVgprs</name></member>
+            <member><type>uint32_t</type> <name>numAvailableSgprs</name></member>
+            <member><type>uint32_t</type> <name>computeWorkGroupSize</name>[3]</member>
+        </type>
+        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoKHR" structextends="VkDeviceQueueCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkQueueGlobalPriorityKHR</type>       <name>globalPriority</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoEXT" alias="VkDeviceQueueGlobalPriorityCreateInfoKHR"/>
+        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>globalPriorityQuery</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT" alias="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"/>
+        <type category="struct" name="VkQueueFamilyGlobalPriorityPropertiesKHR" structextends="VkQueueFamilyProperties2">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                     <name>priorityCount</name></member>
+            <member limittype="bitmask"><type>VkQueueGlobalPriorityKHR</type> <name>priorities</name>[<enum>VK_MAX_GLOBAL_PRIORITY_SIZE_KHR</enum>]</member>
+        </type>
+        <type category="struct" name="VkQueueFamilyGlobalPriorityPropertiesEXT" alias="VkQueueFamilyGlobalPriorityPropertiesKHR"/>
+        <type category="struct" name="VkDebugUtilsObjectNameInfoEXT" structextends="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkObjectType</type>                                           <name>objectType</name></member>
+            <member objecttype="objectType"><type>uint64_t</type>                                               <name>objectHandle</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*      <name>pObjectName</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsObjectTagInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkObjectType</type>                           <name>objectType</name></member>
+            <member objecttype="objectType"><type>uint64_t</type>                               <name>objectHandle</name></member>
+            <member><type>uint64_t</type>                               <name>tagName</name></member>
+            <member><type>size_t</type>                                 <name>tagSize</name></member>
+            <member len="tagSize">const <type>void</type>*              <name>pTag</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsLabelEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member len="null-terminated">const <type>char</type>*      <name>pLabelName</name></member>
+            <member><type>float</type>                  <name>color</name>[4]</member>
+        </type>
+        <type category="struct" name="VkDebugUtilsMessengerCreateInfoEXT" allowduplicate="true" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                          <name>pNext</name></member>
+            <member optional="true"><type>VkDebugUtilsMessengerCreateFlagsEXT</type>  <name>flags</name></member>
+            <member><type>VkDebugUtilsMessageSeverityFlagsEXT</type>                  <name>messageSeverity</name></member>
+            <member><type>VkDebugUtilsMessageTypeFlagsEXT</type>                      <name>messageType</name></member>
+            <member><type>PFN_vkDebugUtilsMessengerCallbackEXT</type>                 <name>pfnUserCallback</name></member>
+            <member optional="true"><type>void</type>*                                <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsMessengerCallbackDataEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>VkDebugUtilsMessengerCallbackDataFlagsEXT</type>                          <name>flags</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*                                  <name>pMessageIdName</name></member>
+            <member><type>int32_t</type>                                                            <name>messageIdNumber</name></member>
+            <member len="null-terminated">const <type>char</type>*                                                  <name>pMessage</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>queueLabelCount</name></member>
+            <member len="queueLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                  <name>pQueueLabels</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>cmdBufLabelCount</name></member>
+            <member len="cmdBufLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                 <name>pCmdBufLabels</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>objectCount</name></member>
+            <member len="objectCount">const <type>VkDebugUtilsObjectNameInfoEXT</type>*             <name>pObjects</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>deviceMemoryReport</name></member>
+        </type>
+        <type category="struct" name="VkDeviceDeviceMemoryReportCreateInfoEXT" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>VkDeviceMemoryReportFlagsEXT</type>        <name>flags</name></member>
+            <member><type>PFN_vkDeviceMemoryReportCallbackEXT</type> <name>pfnUserCallback</name></member>
+            <member><type>void</type>*                               <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkDeviceMemoryReportCallbackDataEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceMemoryReportFlagsEXT</type>     <name>flags</name></member>
+            <member><type>VkDeviceMemoryReportEventTypeEXT</type> <name>type</name></member>
+            <member><type>uint64_t</type>                         <name>memoryObjectId</name></member>
+            <member><type>VkDeviceSize</type>                     <name>size</name></member>
+            <member><type>VkObjectType</type>                     <name>objectType</name></member>
+            <member objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></member>
+            <member><type>uint32_t</type>                         <name>heapIndex</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryHostPointerInfoEXT" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>void</type>* <name>pHostPointer</name></member>
+        </type>
+        <type category="struct" name="VkMemoryHostPointerPropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type> <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type> <name>minImportedHostPointerAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="exact"><type>float</type>                 <name>primitiveOverestimationSize</name><comment>The size in pixels the primitive is enlarged at each edge during conservative rasterization</comment></member>
+            <member limittype="max"><type>float</type>                      <name>maxExtraPrimitiveOverestimationSize</name><comment>The maximum additional overestimation the client can specify in the pipeline state</comment></member>
+            <member limittype="min,mul"><type>float</type>                   <name>extraPrimitiveOverestimationSizeGranularity</name><comment>The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>primitiveUnderestimation</name><comment>true if the implementation supports conservative rasterization underestimation mode</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>conservativePointAndLineRasterization</name><comment>true if conservative rasterization also applies to points and lines</comment></member>
+            <member limittype="exact"><type>VkBool32</type>              <name>degenerateTrianglesRasterized</name><comment>true if degenerate triangles (those with zero area after snap) are rasterized</comment></member>
+            <member limittype="exact"><type>VkBool32</type>              <name>degenerateLinesRasterized</name><comment>true if degenerate lines (those with zero length after snap) are rasterized</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fullyCoveredFragmentShaderInputVariable</name><comment>true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>conservativeRasterizationPostDepthCoverage</name><comment>true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask</comment></member>
+        </type>
+        <type category="struct" name="VkCalibratedTimestampInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkTimeDomainEXT</type>        <name>timeDomain</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesAMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="exact"><type>uint32_t</type> <name>shaderEngineCount</name><comment>number of shader engines</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>shaderArraysPerEngineCount</name><comment>number of shader arrays</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>computeUnitsPerShaderArray</name><comment>number of physical CUs per shader array</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>simdPerComputeUnit</name><comment>number of SIMDs per compute unit</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>wavefrontsPerSimd</name><comment>number of wavefront slots in each SIMD</comment></member>
+            <member limittype="max"><type>uint32_t</type>      <name>wavefrontSize</name><comment>maximum number of threads per wavefront</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>sgprsPerSimd</name><comment>number of physical SGPRs per SIMD</comment></member>
+            <member limittype="min"><type>uint32_t</type>      <name>minSgprAllocation</name><comment>minimum number of SGPRs that can be allocated by a wave</comment></member>
+            <member limittype="max"><type>uint32_t</type>      <name>maxSgprAllocation</name><comment>number of available SGPRs</comment></member>
+            <member limittype="min,mul"><type>uint32_t</type>   <name>sgprAllocationGranularity</name><comment>SGPRs are allocated in groups of this size</comment></member>
+            <member limittype="exact"><type>uint32_t</type> <name>vgprsPerSimd</name><comment>number of physical VGPRs per SIMD</comment></member>
+            <member limittype="min"><type>uint32_t</type>      <name>minVgprAllocation</name><comment>minimum number of VGPRs that can be allocated by a wave</comment></member>
+            <member limittype="max"><type>uint32_t</type>      <name>maxVgprAllocation</name><comment>number of available VGPRs</comment></member>
+            <member limittype="min,mul"><type>uint32_t</type>   <name>vgprAllocationGranularity</name><comment>VGPRs are allocated in groups of this size</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCoreProperties2AMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member limittype="bitmask"><type>VkShaderCorePropertiesFlagsAMD</type> <name>shaderCoreFeatures</name><comment>features supported by the shader core</comment></member>
+            <member limittype="max"><type>uint32_t</type> <name>activeComputeUnitCount</name><comment>number of active compute units across all shader engines/arrays</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationConservativeStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationConservativeStateCreateFlagsEXT</type>           <name>flags</name><comment>Reserved</comment></member>
+            <member><type>VkConservativeRasterizationModeEXT</type>                                               <name>conservativeRasterizationMode</name><comment>Conservative rasterization mode</comment></member>
+            <member><type>float</type>                                                                            <name>extraPrimitiveOverestimationSize</name><comment>Extra overestimation to add to the primitive</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUpdateUnusedWhilePending</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingPartiallyBound</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingVariableDescriptorCount</name></member>
+            <member><type>VkBool32</type>               <name>runtimeDescriptorArray</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"           alias="VkPhysicalDeviceDescriptorIndexingFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>robustBufferAccessUpdateAfterBind</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>quadDivergentImplicitLod</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageUpdateAfterBindResources</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"         alias="VkPhysicalDeviceDescriptorIndexingProperties"/>
+        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfo" structextends="VkDescriptorSetLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                           <name>bindingCount</name></member>
+            <member len="bindingCount" optional="false,true">const <type>VkDescriptorBindingFlags</type>* <name>pBindingFlags</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"          alias="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfo" structextends="VkDescriptorSetAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>descriptorSetCount</name></member>
+            <member len="descriptorSetCount">const <type>uint32_t</type>* <name>pDescriptorCounts</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"   alias="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupport" structextends="VkDescriptorSetLayoutSupport" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>         <name>maxVariableDescriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"  alias="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
+        <type category="struct" name="VkAttachmentDescription2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkFormat</type>                                     <name>format</name></member>
+            <member><type>VkSampleCountFlagBits</type>                        <name>samples</name></member>
+            <member><type>VkAttachmentLoadOp</type>                           <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>                          <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
+            <member><type>VkAttachmentLoadOp</type>                           <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>                          <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
+            <member><type>VkImageLayout</type>                                <name>initialLayout</name></member>
+            <member><type>VkImageLayout</type>                                <name>finalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescription2KHR"                             alias="VkAttachmentDescription2"/>
+        <type category="struct" name="VkAttachmentReference2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>attachment</name></member>
+            <member><type>VkImageLayout</type>                     <name>layout</name></member>
+            <member noautovalidity="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReference2KHR"                               alias="VkAttachmentReference2"/>
+        <type category="struct" name="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member optional="true"><type>VkSubpassDescriptionFlags</type>                   <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>                                         <name>pipelineBindPoint</name></member>
+            <member><type>uint32_t</type>                                                    <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>inputAttachmentCount</name></member>
+            <member len="inputAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pInputAttachments</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pColorAttachments</name></member>
+            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference2</type>* <name>pResolveAttachments</name></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>*               <name>pDepthStencilAttachment</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>preserveAttachmentCount</name></member>
+            <member len="preserveAttachmentCount">const <type>uint32_t</type>*               <name>pPreserveAttachments</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDescription2KHR"                                alias="VkSubpassDescription2"/>
+        <type category="struct" name="VkSubpassDependency2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>srcSubpass</name></member>
+            <member><type>uint32_t</type>                          <name>dstSubpass</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>     <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>     <name>dstAccessMask</name></member>
+            <member optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></member>
+            <member><type>int32_t</type>                           <name>viewOffset</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDependency2KHR"                                 alias="VkSubpassDependency2"/>
+        <type category="struct" name="VkRenderPassCreateInfo2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                              <name>pNext</name></member>
+            <member optional="true"><type>VkRenderPassCreateFlags</type>                  <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkAttachmentDescription2</type>*    <name>pAttachments</name></member>
+            <member><type>uint32_t</type>                                                 <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>VkSubpassDescription2</type>*          <name>pSubpasses</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>VkSubpassDependency2</type>*        <name>pDependencies</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>correlatedViewMaskCount</name></member>
+            <member len="correlatedViewMaskCount">const <type>uint32_t</type>*            <name>pCorrelatedViewMasks</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreateInfo2KHR"                              alias="VkRenderPassCreateInfo2"/>
+        <type category="struct" name="VkSubpassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSubpassContents</type>      <name>contents</name></member>
+        </type>
+        <type category="struct" name="VkSubpassBeginInfoKHR"                                   alias="VkSubpassBeginInfo"/>
+        <type category="struct" name="VkSubpassEndInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkSubpassEndInfoKHR"                                     alias="VkSubpassEndInfo"/>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>timelineSemaphore</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"            alias="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint64_t</type>               <name>maxTimelineSemaphoreValueDifference</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"          alias="VkPhysicalDeviceTimelineSemaphoreProperties"/>
+        <type category="struct" name="VkSemaphoreTypeCreateInfo" structextends="VkSemaphoreCreateInfo,VkPhysicalDeviceExternalSemaphoreInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphoreType</type>        <name>semaphoreType</name></member>
+            <member><type>uint64_t</type>               <name>initialValue</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreTypeCreateInfoKHR"                            alias="VkSemaphoreTypeCreateInfo"/>
+        <type category="struct" name="VkTimelineSemaphoreSubmitInfo" structextends="VkSubmitInfo,VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValueCount</name></member>
+            <member optional="true" len="waitSemaphoreValueCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValueCount</name></member>
+            <member optional="true" len="signalSemaphoreValueCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
+        </type>
+        <type category="struct" name="VkTimelineSemaphoreSubmitInfoKHR"                        alias="VkTimelineSemaphoreSubmitInfo"/>
+        <type category="struct" name="VkSemaphoreWaitInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSemaphoreWaitFlags</type> <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>semaphoreCount</name></member>
+            <member len="semaphoreCount">const <type>VkSemaphore</type>* <name>pSemaphores</name></member>
+            <member len="semaphoreCount">const <type>uint64_t</type>*    <name>pValues</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreWaitInfoKHR"                                  alias="VkSemaphoreWaitInfo"/>
+        <type category="struct" name="VkSemaphoreSignalInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphore</type>            <name>semaphore</name></member>
+            <member><type>uint64_t</type>               <name>value</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSignalInfoKHR"                                alias="VkSemaphoreSignalInfo"/>
+        <type category="struct" name="VkVertexInputBindingDivisorDescriptionEXT">
+            <member><type>uint32_t</type>          <name>binding</name></member>
+            <member><type>uint32_t</type>          <name>divisor</name></member>
+        </type>
+        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfoEXT" structextends="VkPipelineVertexInputStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>vertexBindingDivisorCount</name></member>
+            <member len="vertexBindingDivisorCount">const <type>VkVertexInputBindingDivisorDescriptionEXT</type>*      <name>pVertexBindingDivisors</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePCIBusInfoPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciDomain</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciBus</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciDevice</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciFunction</name></member>
+        </type>
+        <type category="struct" name="VkImportAndroidHardwareBufferInfoANDROID" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member>struct <type>AHardwareBuffer</type>*            <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferUsageANDROID" structextends="VkImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint64_t</type>                           <name>androidHardwareBufferUsage</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
+            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetAndroidHardwareBufferInfoANDROID">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferFormatPropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
+            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceConditionalRenderingInfoEXT" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>conditionalRenderingEnable</name><comment>Whether this secondary command buffer may be executed during an active conditional rendering</comment></member>
+        </type>
+        <type category="struct" name="VkExternalFormatANDROID" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice8BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice8BitStorageFeaturesKHR"                  alias="VkPhysicalDevice8BitStorageFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceConditionalRenderingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>conditionalRendering</name></member>
+            <member><type>VkBool32</type>                           <name>inheritedConditionalRendering</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"            alias="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferInt64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedInt64Atomics</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"            alias="VkPhysicalDeviceShaderAtomicInt64Features"/>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicAdd</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicMinMax</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateDivisor</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateZeroDivisor</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyCheckpointPropertiesNV" structextends="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*           <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkPipelineStageFlags</type> <name>checkpointExecutionStageMask</name></member>
+        </type>
+        <type category="struct" name="VkCheckpointDataNV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkPipelineStageFlagBits</type>   <name>stage</name></member>
+            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthStencilResolveProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                             <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                             <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"        alias="VkPhysicalDeviceDepthStencilResolveProperties"/>
+        <type category="struct" name="VkSubpassDescriptionDepthStencilResolve" structextends="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>depthResolveMode</name><comment>depth resolve mode</comment></member>
+            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>stencilResolveMode</name><comment>stencil resolve mode</comment></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>*            <name>pDepthStencilResolveAttachment</name><comment>depth/stencil resolve attachment</comment></member>
+        </type>
+        <type category="struct" name="VkSubpassDescriptionDepthStencilResolveKHR"              alias="VkSubpassDescriptionDepthStencilResolve"/>
+        <type category="struct" name="VkImageViewASTCDecodeModeEXT" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>decodeMode</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceASTCDecodeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>decodeModeSharedExponent</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTransformFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>transformFeedback</name></member>
+            <member><type>VkBool32</type>               <name>geometryStreams</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTransformFeedbackPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreams</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBuffers</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>           <name>maxTransformFeedbackBufferSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreamDataSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataStride</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackQueries</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackStreamsLinesTriangles</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackRasterizationStreamSelect</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackDraw</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateStreamCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationStateStreamCreateFlagsEXT</type>                 <name>flags</name></member>
+            <member><type>uint32_t</type>                                                                         <name>rasterizationStream</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>representativeFragmentTest</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>representativeFragmentTestEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExclusiveScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>exclusiveScissor</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportExclusiveScissorStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                          <name>exclusiveScissorCount</name></member>
+            <member noautovalidity="true" len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCornerSampledImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>cornerSampledImage</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>computeDerivativeGroupQuads</name></member>
+            <member><type>VkBool32</type>                         <name>computeDerivativeGroupLinear</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"   alias="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"/>
+        <type category="struct" name="VkPhysicalDeviceShaderImageFootprintFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>imageFootprint</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocationImageAliasing</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>indirectCopy</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*     <name>pNext</name></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkQueueFlags</type>        <name>supportedQueues</name><comment>Bitfield of which queues are supported for indirect copy</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*       <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>memoryDecompression</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*     <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkMemoryDecompressionMethodFlagsNV</type>    <name>decompressionMethods</name></member>
+            <member limittype="max"><type>uint64_t</type>             <name>maxDecompressionIndirectCount</name></member>
+        </type>
+        <type category="struct" name="VkShadingRatePaletteNV">
+            <member><type>uint32_t</type>                                                               <name>shadingRatePaletteEntryCount</name></member>
+            <member len="shadingRatePaletteEntryCount">const <type>VkShadingRatePaletteEntryNV</type>*  <name>pShadingRatePaletteEntries</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportShadingRateImageStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                             <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                <name>shadingRateImageEnable</name></member>
+            <member optional="true"><type>uint32_t</type>                                                <name>viewportCount</name></member>
+            <member noautovalidity="true" len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShadingRateImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shadingRateImage</name></member>
+            <member><type>VkBool32</type>                            <name>shadingRateCoarseSampleOrder</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShadingRateImagePropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="exact"><type>VkExtent2D</type>                     <name>shadingRateTexelSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>shadingRatePaletteSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>shadingRateMaxCoarseSamples</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>invocationMask</name></member>
+        </type>
+        <type category="struct" name="VkCoarseSampleLocationNV">
+            <member><type>uint32_t</type>                            <name>pixelX</name></member>
+            <member><type>uint32_t</type>                            <name>pixelY</name></member>
+            <member><type>uint32_t</type>                            <name>sample</name></member>
+        </type>
+        <type category="struct" name="VkCoarseSampleOrderCustomNV">
+            <member><type>VkShadingRatePaletteEntryNV</type>         <name>shadingRate</name></member>
+            <member><type>uint32_t</type>                            <name>sampleCount</name></member>
+            <member><type>uint32_t</type>                            <name>sampleLocationCount</name></member>
+            <member len="sampleLocationCount">const <type>VkCoarseSampleLocationNV</type>* <name>pSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                            <name>pNext</name></member>
+            <member><type>VkCoarseSampleOrderTypeNV</type>                                              <name>sampleOrderType</name></member>
+            <member optional="true"><type>uint32_t</type>                                               <name>customSampleOrderCount</name></member>
+            <member len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>*        <name>pCustomSampleOrders</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>taskShader</name></member>
+            <member><type>VkBool32</type>                            <name>meshShader</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxDrawMeshTasksCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskTotalMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskOutputCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshTotalMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
+            <member limittype="min,mul"><type>uint32_t</type>                         <name>meshOutputPerVertexGranularity</name></member>
+            <member limittype="min,mul"><type>uint32_t</type>                         <name>meshOutputPerPrimitiveGranularity</name></member>
+        </type>
+        <type category="struct" name="VkDrawMeshTasksIndirectCommandNV">
+            <member><type>uint32_t</type>               <name>taskCount</name></member>
+            <member><type>uint32_t</type>               <name>firstTask</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>taskShader</name></member>
+            <member><type>VkBool32</type>                            <name>meshShader</name></member>
+            <member><type>VkBool32</type>                            <name>multiviewMeshShader</name></member>
+            <member><type>VkBool32</type>                            <name>primitiveFragmentShadingRateMeshShader</name></member>
+            <member><type>VkBool32</type>                            <name>meshShaderQueries</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupTotalCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupCount</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskPayloadSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskSharedMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskPayloadAndSharedMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupTotalCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupCount</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshSharedMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshPayloadAndSharedMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshPayloadAndOutputMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputComponents</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputLayers</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>meshOutputPerVertexGranularity</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>meshOutputPerPrimitiveGranularity</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxPreferredTaskWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxPreferredMeshWorkGroupInvocations</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>prefersLocalInvocationVertexOutput</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>prefersLocalInvocationPrimitiveOutput</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>prefersCompactVertexOutput</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>prefersCompactPrimitiveOutput</name></member>
+        </type>
+        <type category="struct" name="VkDrawMeshTasksIndirectCommandEXT">
+            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountX</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountY</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountZ</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingShaderGroupCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
+            <member><type>uint32_t</type>               <name>generalShader</name></member>
+            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
+            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
+            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingShaderGroupCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
+            <member><type>uint32_t</type>               <name>generalShader</name></member>
+            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
+            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
+            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
+            <member optional="true">const <type>void</type>* <name>pShaderGroupCaptureReplayHandle</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member><type>uint32_t</type>               <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member><type>uint32_t</type>               <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoNV</type>* <name>pGroups</name></member>
+            <member><type>uint32_t</type>               <name>maxRecursionDepth</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoKHR</type>* <name>pGroups</name></member>
+            <member><type>uint32_t</type>               <name>maxPipelineRayRecursionDepth</name></member>
+            <member optional="true">const <type>VkPipelineLibraryCreateInfoKHR</type>* <name>pLibraryInfo</name></member>
+            <member optional="true">const <type>VkRayTracingPipelineInterfaceCreateInfoKHR</type>* <name>pLibraryInterface</name></member>
+            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkGeometryTrianglesNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>vertexData</name></member>
+            <member><type>VkDeviceSize</type>               <name>vertexOffset</name></member>
+            <member><type>uint32_t</type>                   <name>vertexCount</name></member>
+            <member><type>VkDeviceSize</type>               <name>vertexStride</name></member>
+            <member><type>VkFormat</type>                   <name>vertexFormat</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>indexData</name></member>
+            <member><type>VkDeviceSize</type>               <name>indexOffset</name></member>
+            <member><type>uint32_t</type>                   <name>indexCount</name></member>
+            <member><type>VkIndexType</type>                <name>indexType</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>transformData</name><comment>Optional reference to array of floats representing a 3x4 row major affine transformation matrix.</comment></member>
+            <member><type>VkDeviceSize</type>               <name>transformOffset</name></member>
+        </type>
+        <type category="struct" name="VkGeometryAABBNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>aabbData</name></member>
+            <member><type>uint32_t</type>                   <name>numAABBs</name></member>
+            <member><type>uint32_t</type>                   <name>stride</name><comment>Stride in bytes between AABBs</comment></member>
+            <member><type>VkDeviceSize</type>               <name>offset</name><comment>Offset in bytes of the first AABB in aabbData</comment></member>
+        </type>
+        <type category="struct" name="VkGeometryDataNV">
+            <member><type>VkGeometryTrianglesNV</type>                  <name>triangles</name></member>
+            <member><type>VkGeometryAABBNV</type>                       <name>aabbs</name></member>
+        </type>
+        <type category="struct" name="VkGeometryNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
+            <member><type>VkGeometryTypeKHR</type>                  <name>geometryType</name></member>
+            <member><type>VkGeometryDataNV</type>                              <name>geometry</name></member>
+            <member optional="true"><type>VkGeometryFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureTypeNV</type>         <name>type</name></member>
+            <member optional="true"><type>VkBuildAccelerationStructureFlagsNV</type> <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>instanceCount</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>geometryCount</name></member>
+            <member len="geometryCount">const <type>VkGeometryNV</type>* <name>pGeometries</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                           <name>compactedSize</name></member>
+            <member><type>VkAccelerationStructureInfoNV</type>          <name>info</name></member>
+        </type>
+        <type category="struct" name="VkBindAccelerationStructureMemoryInfoNV">
+            <member values="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>VkAccelerationStructureNV</type>       <name>accelerationStructure</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureKHR" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
+            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureNV" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
+            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMemoryRequirementsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkAccelerationStructureMemoryRequirementsTypeNV</type>                     <name>type</name></member>
+            <member><type>VkAccelerationStructureNV</type>                                           <name>accelerationStructure</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAccelerationStructureFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructure</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureIndirectBuild</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureHostCommands</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingAccelerationStructureUpdateAfterBind</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipeline</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplayMixed</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineTraceRaysIndirect</name></member>
+            <member><type>VkBool32</type>                         <name>rayTraversalPrimitiveCulling</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rayQuery</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAccelerationStructurePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxPrimitiveCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindAccelerationStructures</name></member>
+            <member limittype="min"><type>uint32_t</type>                         <name>minAccelerationStructureScratchOffsetAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayRecursionDepth</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
+            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupBaseAlignment</name></member>
+            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleCaptureReplaySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayDispatchInvocationCount</name></member>
+            <member limittype="min,pot"><type>uint32_t</type>                      <name>shaderGroupHandleAlignment</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayHitAttributeSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRecursionDepth</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
+            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupBaseAlignment</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxTriangleCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkStridedDeviceAddressRegionKHR">
+            <member optional="true"><type>VkDeviceAddress</type>  <name>deviceAddress</name></member>
+            <member><type>VkDeviceSize</type>                     <name>stride</name></member>
+            <member><type>VkDeviceSize</type>                     <name>size</name></member>
+        </type>
+        <type category="struct" name="VkTraceRaysIndirectCommandKHR">
+            <member><type>uint32_t</type>               <name>width</name></member>
+            <member><type>uint32_t</type>               <name>height</name></member>
+            <member><type>uint32_t</type>               <name>depth</name></member>
+        </type>
+        <type category="struct" name="VkTraceRaysIndirectCommand2KHR">
+            <member><type>VkDeviceAddress</type>        <name>raygenShaderRecordAddress</name></member>
+            <member><type>VkDeviceSize</type>           <name>raygenShaderRecordSize</name></member>
+            <member><type>VkDeviceAddress</type>        <name>missShaderBindingTableAddress</name></member>
+            <member><type>VkDeviceSize</type>           <name>missShaderBindingTableSize</name></member>
+            <member><type>VkDeviceSize</type>           <name>missShaderBindingTableStride</name></member>
+            <member><type>VkDeviceAddress</type>        <name>hitShaderBindingTableAddress</name></member>
+            <member><type>VkDeviceSize</type>           <name>hitShaderBindingTableSize</name></member>
+            <member><type>VkDeviceSize</type>           <name>hitShaderBindingTableStride</name></member>
+            <member><type>VkDeviceAddress</type>        <name>callableShaderBindingTableAddress</name></member>
+            <member><type>VkDeviceSize</type>           <name>callableShaderBindingTableSize</name></member>
+            <member><type>VkDeviceSize</type>           <name>callableShaderBindingTableStride</name></member>
+            <member><type>uint32_t</type>               <name>width</name></member>
+            <member><type>uint32_t</type>               <name>height</name></member>
+            <member><type>uint32_t</type>               <name>depth</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingMaintenance1</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineTraceRaysIndirect2</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierPropertiesListEXT" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member optional="true" len="drmFormatModifierCount"><type>VkDrmFormatModifierPropertiesEXT</type>* <name>pDrmFormatModifierProperties</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierPropertiesEXT" returnedonly="true">
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member><type>VkFormatFeatureFlags</type> <name>drmFormatModifierTilingFeatures</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>VkSharingMode</type> <name>sharingMode</name></member>
+            <member optional="true"><type>uint32_t</type> <name>queueFamilyIndexCount</name></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>* <name>pQueueFamilyIndices</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierListCreateInfoEXT" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member len="drmFormatModifierCount">const <type>uint64_t</type>* <name>pDrmFormatModifiers</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierExplicitCreateInfoEXT" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member len="drmFormatModifierPlaneCount">const <type>VkSubresourceLayout</type>* <name>pPlaneLayouts</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierPropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+        </type>
+        <type category="struct" name="VkImageStencilUsageCreateInfo" structextends="VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type> <name>stencilUsage</name></member>
+        </type>
+        <type category="struct" name="VkImageStencilUsageCreateInfoEXT"                        alias="VkImageStencilUsageCreateInfo"/>
+        <type category="struct" name="VkDeviceMemoryOverallocationCreateInfoAMD"  structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkMemoryOverallocationBehaviorAMD</type> <name>overallocationBehavior</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMap</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapDynamic</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapNonSubsampledImages</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapDeferred</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapOffset</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="min"><type>VkExtent2D</type>                       <name>minFragmentDensityTexelSize</name></member>
+            <member limittype="max"><type>VkExtent2D</type>                       <name>maxFragmentDensityTexelSize</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>fragmentDensityInvocations</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="exact"><type>VkBool32</type>                  <name>subsampledLoads</name></member>
+            <member limittype="exact"><type>VkBool32</type>                  <name>subsampledCoarseReconstructionEarlyAccess</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxSubsampledArrayLayers</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetSubsampledSamplers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="min,mul"><type>VkExtent2D</type>                       <name>fragmentDensityOffsetGranularity</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassFragmentDensityMapCreateInfoEXT" structextends="VkRenderPassCreateInfo,VkRenderPassCreateInfo2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkAttachmentReference</type>            <name>fragmentDensityMapAttachment</name></member>
+        </type>
+        <type category="struct" name="VkSubpassFragmentDensityMapOffsetEndInfoQCOM" structextends="VkSubpassEndInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                           <name>fragmentDensityOffsetCount</name></member>
+            <member len="fragmentDensityOffsetCount">const <type>VkOffset2D</type>* <name>pFragmentDensityOffsets</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>scalarBlockLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"            alias="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
+        <type category="struct" name="VkSurfaceProtectedCapabilitiesKHR" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>supportsProtected</name><comment>Represents if surface can be protected</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>uniformBufferStandardLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"  alias="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceDepthClipEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>depthClipEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationDepthClipStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                 <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</type>         <name>flags</name><comment>Reserved</comment></member>
+            <member><type>VkBool32</type>                                                                    <name>depthClipEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryBudgetPropertiesEXT" structextends="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>heapBudget</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+            <member><type>VkDeviceSize</type>                       <name>heapUsage</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryPriorityFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>memoryPriority</name></member>
+        </type>
+        <type category="struct" name="VkMemoryPriorityAllocateInfoEXT" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>float</type>                              <name>priority</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>pageableDeviceLocalMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"          alias="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferAddressFeaturesEXT"                alias="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
+        <type category="struct" name="VkBufferDeviceAddressInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkBuffer</type>                                               <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkBufferDeviceAddressInfoKHR"                            alias="VkBufferDeviceAddressInfo"/>
+        <type category="struct" name="VkBufferDeviceAddressInfoEXT"                            alias="VkBufferDeviceAddressInfo"/>
+        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfo" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint64_t</type>                         <name>opaqueCaptureAddress</name></member>
+        </type>
+        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfoKHR"               alias="VkBufferOpaqueCaptureAddressCreateInfo"/>
+        <type category="struct" name="VkBufferDeviceAddressCreateInfoEXT" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>                  <name>deviceAddress</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageViewImageFormatInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkImageViewType</type>                  <name>imageViewType</name></member>
+        </type>
+        <type category="struct" name="VkFilterCubicImageViewImageFormatPropertiesEXT" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>filterCubic</name><comment>The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT</comment></member>
+            <member><type>VkBool32</type>                         <name>filterCubicMinmax</name><comment>The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                 <name>imagelessFramebuffer</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"         alias="VkPhysicalDeviceImagelessFramebufferFeatures"/>
+        <type category="struct" name="VkFramebufferAttachmentsCreateInfo" structextends="VkFramebufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>attachmentImageInfoCount</name></member>
+            <member len="attachmentImageInfoCount">const <type>VkFramebufferAttachmentImageInfo</type>* <name>pAttachmentImageInfos</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferAttachmentsCreateInfoKHR"                   alias="VkFramebufferAttachmentsCreateInfo"/>
+        <type category="struct" name="VkFramebufferAttachmentImageInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type>       <name>flags</name><comment>Image creation flags</comment></member>
+            <member><type>VkImageUsageFlags</type>                        <name>usage</name><comment>Image usage flags</comment></member>
+            <member><type>uint32_t</type>                                 <name>width</name></member>
+            <member><type>uint32_t</type>                                 <name>height</name></member>
+            <member><type>uint32_t</type>                                 <name>layerCount</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>viewFormatCount</name></member>
+            <member len="viewFormatCount">const <type>VkFormat</type>*    <name>pViewFormats</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferAttachmentImageInfoKHR"                     alias="VkFramebufferAttachmentImageInfo"/>
+        <type category="struct" name="VkRenderPassAttachmentBeginInfo" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkImageView</type>* <name>pAttachments</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassAttachmentBeginInfoKHR"                      alias="VkRenderPassAttachmentBeginInfo"/>
+        <type category="struct" name="VkPhysicalDeviceTextureCompressionASTCHDRFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>textureCompressionASTC_HDR</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT" alias="VkPhysicalDeviceTextureCompressionASTCHDRFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrix</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrixRobustBufferAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>                  <name>cooperativeMatrixSupportedStages</name></member>
+        </type>
+        <type category="struct" name="VkCooperativeMatrixPropertiesNV">
+            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>MSize</name></member>
+            <member><type>uint32_t</type>                            <name>NSize</name></member>
+            <member><type>uint32_t</type>                            <name>KSize</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>AType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>BType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>CType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>DType</name></member>
+            <member><type>VkScopeNV</type>                           <name>scope</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>ycbcrImageArrays</name></member>
+        </type>
+        <type category="struct" name="VkImageViewHandleInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkImageView</type>                         <name>imageView</name></member>
+            <member><type>VkDescriptorType</type>                    <name>descriptorType</name></member>
+            <member optional="true"><type>VkSampler</type>           <name>sampler</name></member>
+        </type>
+        <type category="struct" name="VkImageViewAddressPropertiesNVX" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>    <name>deviceAddress</name></member>
+            <member><type>VkDeviceSize</type>       <name>size</name></member>
+        </type>
+        <type category="struct" name="VkPresentFrameTokenGGP" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>GgpFrameToken</type>                    <name>frameToken</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCreationFeedback" returnedonly="true">
+            <member><type>VkPipelineCreationFeedbackFlags</type>     <name>flags</name></member>
+            <member><type>uint64_t</type>                            <name>duration</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCreationFeedbackEXT" alias="VkPipelineCreationFeedback"/>
+        <type category="struct" name="VkPipelineCreationFeedbackCreateInfo" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR,VkExecutionGraphPipelineCreateInfoAMDX">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>VkPipelineCreationFeedback</type>*         <name>pPipelineCreationFeedback</name><comment>Output pipeline creation feedback.</comment></member>
+            <member optional="true"><type>uint32_t</type>            <name>pipelineStageCreationFeedbackCount</name></member>
+            <member len="pipelineStageCreationFeedbackCount"><type>VkPipelineCreationFeedback</type>* <name>pPipelineStageCreationFeedbacks</name><comment>One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineCreationFeedbackCreateInfoEXT" alias="VkPipelineCreationFeedbackCreateInfo"/>
+        <type category="struct" name="VkSurfaceFullScreenExclusiveInfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFullScreenExclusiveEXT</type>         <name>fullScreenExclusive</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFullScreenExclusiveWin32InfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>HMONITOR</type>         <name>hmonitor</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilitiesFullScreenExclusiveEXT" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>         <name>fullScreenExclusiveSupported</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentBarrierFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>presentBarrier</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilitiesPresentBarrierNV" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>presentBarrierSupported</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainPresentBarrierCreateInfoNV" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>    <name>presentBarrierEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePerformanceQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>performanceCounterQueryPools</name><comment>performance counters supported in query pools</comment></member>
+            <member><type>VkBool32</type>                         <name>performanceCounterMultipleQueryPools</name><comment>performance counters from multiple query pools can be accessed in the same primary command buffer</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePerformanceQueryPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type> <name>allowCommandBufferQueryCopies</name><comment>Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults</comment></member>
+        </type>
+        <type category="struct" name="VkPerformanceCounterKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkPerformanceCounterUnitKHR</type>        <name>unit</name></member>
+            <member><type>VkPerformanceCounterScopeKHR</type>       <name>scope</name></member>
+            <member><type>VkPerformanceCounterStorageKHR</type>     <name>storage</name></member>
+            <member><type>uint8_t</type> <name>uuid</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPerformanceCounterDescriptionKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member optional="true"><type>VkPerformanceCounterDescriptionFlagsKHR</type> <name>flags</name></member>
+            <member><type>char</type>                                    <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>                                    <name>category</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>                                    <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkQueryPoolPerformanceCreateInfoKHR" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member><type>uint32_t</type>                                <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                                <name>counterIndexCount</name></member>
+            <member len="counterIndexCount">const <type>uint32_t</type>* <name>pCounterIndices</name></member>
+        </type>
+        <type category="union" name="VkPerformanceCounterResultKHR" comment="// Union of all the possible return types a counter result could return">
+            <member><type>int32_t</type>  <name>int32</name></member>
+            <member><type>int64_t</type>  <name>int64</name></member>
+            <member><type>uint32_t</type> <name>uint32</name></member>
+            <member><type>uint64_t</type> <name>uint64</name></member>
+            <member><type>float</type>    <name>float32</name></member>
+            <member><type>double</type>   <name>float64</name></member>
+        </type>
+        <type category="struct" name="VkAcquireProfilingLockInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAcquireProfilingLockFlagsKHR</type> <name>flags</name><comment>Acquire profiling lock flags</comment></member>
+            <member><type>uint64_t</type> <name>timeout</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceQuerySubmitInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>            <name>counterPassIndex</name><comment>Index for which counter pass to submit</comment></member>
+        </type>
+        <type category="struct" name="VkPerformanceQueryReservationInfoKHR" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>            <name>maxPerformanceQueriesPerPool</name><comment>Maximum number of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR queries in a query pool</comment></member>
+        </type>
+        <type category="struct" name="VkHeadlessSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkHeadlessSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCoverageReductionModeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>coverageReductionMode</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCoverageReductionStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageReductionStateCreateFlagsNV</type>      <name>flags</name></member>
+            <member><type>VkCoverageReductionModeNV</type>                                          <name>coverageReductionMode</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferMixedSamplesCombinationNV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkCoverageReductionModeNV</type>  <name>coverageReductionMode</name></member>
+            <member><type>VkSampleCountFlagBits</type>      <name>rasterizationSamples</name></member>
+            <member><type>VkSampleCountFlags</type>         <name>depthStencilSamples</name></member>
+            <member><type>VkSampleCountFlags</type>         <name>colorSamples</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderIntegerFunctions2</name></member>
+        </type>
+        <type category="union" name="VkPerformanceValueDataINTEL">
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"><type>uint32_t</type>                           <name>value32</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"><type>uint64_t</type>                           <name>value64</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"><type>float</type>                               <name>valueFloat</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"><type>VkBool32</type>                             <name>valueBool</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL" len="null-terminated">const <type>char</type>*  <name>valueString</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceValueINTEL">
+            <member><type>VkPerformanceValueTypeINTEL</type>        <name>type</name></member>
+            <member selector="type" noautovalidity="true"><type>VkPerformanceValueDataINTEL</type>        <name>data</name></member>
+        </type>
+        <type category="struct" name="VkInitializePerformanceApiInfoINTEL" >
+            <member values="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member optional="true"><type>void</type>*               <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkQueryPoolPerformanceQueryCreateInfoINTEL" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkQueryPoolSamplingModeINTEL</type>        <name>performanceCountersSampling</name></member>
+        </type>
+        <type category="struct" name="VkQueryPoolCreateInfoINTEL"                              alias="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
+        <type category="struct" name="VkPerformanceMarkerInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint64_t</type>                            <name>marker</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceStreamMarkerInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>marker</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceOverrideInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkPerformanceOverrideTypeINTEL</type>      <name>type</name></member>
+            <member><type>VkBool32</type>                            <name>enable</name></member>
+            <member><type>uint64_t</type>                            <name>parameter</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceConfigurationAcquireInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkPerformanceConfigurationTypeINTEL</type> <name>type</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderClockFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSubgroupClock</name></member>
+            <member><type>VkBool32</type>                            <name>shaderDeviceClock</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>indexTypeUint8</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderSMCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderWarpsPerSM</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>shaderSMBuiltins</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderSampleInterlock</name></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderPixelInterlock</name></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderShadingRateInterlock</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>separateDepthStencilLayouts</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"  alias="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
+        <type category="struct" name="VkAttachmentReferenceStencilLayout" structextends="VkAttachmentReference2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>primitiveTopologyListRestart</name></member>
+            <member><type>VkBool32</type>                     <name>primitiveTopologyPatchListRestart</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReferenceStencilLayoutKHR"                   alias="VkAttachmentReferenceStencilLayout"/>
+        <type category="struct" name="VkAttachmentDescriptionStencilLayout" structextends="VkAttachmentDescription2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilInitialLayout</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilFinalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescriptionStencilLayoutKHR"                 alias="VkAttachmentDescriptionStencilLayout"/>
+        <type category="struct" name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>           <name>pipelineExecutableInfo</name></member>
+        </type>
+        <type category="struct" name="VkPipelineInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkPipeline</type>         <name>pipeline</name></member>
+        </type>
+        <type category="struct" name="VkPipelineInfoEXT" alias="VkPipelineInfoKHR"/>
+        <type category="struct" name="VkPipelineExecutablePropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkShaderStageFlags</type> <name>stages</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>uint32_t</type>           <name>subgroupSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkPipeline</type>         <name>pipeline</name></member>
+            <member><type>uint32_t</type>           <name>executableIndex</name></member>
+        </type>
+        <type category="union" name="VkPipelineExecutableStatisticValueKHR" returnedonly="true">
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"><type>VkBool32</type>           <name>b32</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"><type>int64_t</type>            <name>i64</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"><type>uint64_t</type>           <name>u64</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"><type>double</type>             <name>f64</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableStatisticKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>VkPipelineExecutableStatisticFormatKHR</type> <name>format</name></member>
+            <member selector="format" noautovalidity="true"><type>VkPipelineExecutableStatisticValueKHR</type>  <name>value</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableInternalRepresentationKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>VkBool32</type>           <name>isText</name></member>
+            <member><type>size_t</type>             <name>dataSize</name></member>
+            <member optional="true" len="dataSize"><type>void</type>* <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                   <name>shaderDemoteToHelperInvocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" alias="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>texelBufferAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>                       <name>storageTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="exact"><type>VkBool32</type>                         <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>                       <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="exact"><type>VkBool32</type>                         <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT" alias="VkPhysicalDeviceTexelBufferAlignmentProperties"/>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>subgroupSizeControl</name></member>
+            <member><type>VkBool32</type>               <name>computeFullSubgroups</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT" alias="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="min,pot" noautovalidity="true"><type>uint32_t</type> <name>minSubgroupSize</name><comment>The minimum subgroup size supported by this device</comment></member>
+            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type> <name>maxSubgroupSize</name><comment>The maximum subgroup size supported by this device</comment></member>
+            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxComputeWorkgroupSubgroups</name><comment>The maximum number of subgroups supported in a workgroup</comment></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>         <name>requiredSubgroupSizeStages</name><comment>The shader stages that support specifying a subgroup size</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT" alias="VkPhysicalDeviceSubgroupSizeControlProperties"/>
+        <type category="struct" name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo" returnedonly="true" structextends="VkPipelineShaderStageCreateInfo,VkShaderCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>uint32_t</type>               <name>requiredSubgroupSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT" alias="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
+        <type category="struct" name="VkShaderRequiredSubgroupSizeCreateInfoEXT" alias="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
+        <type category="struct" name="VkSubpassShadingPipelineCreateInfoHUAWEI" returnedonly="true" structextends="VkComputePipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member><type>uint32_t</type>               <name>subpass</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max,pot"><type>uint32_t</type>               <name>maxSubpassShadingWorkgroupSizeAspectRatio</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max,pot"><type>uint32_t</type>           <name>maxWorkGroupCount</name>[3]</member>
+            <member limittype="max,pot"><type>uint32_t</type>           <name>maxWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxOutputClusterCount</name></member>
+            <member limittype="exact"><type>VkDeviceSize</type>         <name>indirectBufferOffsetAlignment</name></member>
+        </type>
+        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>uint64_t</type>                      <name>opaqueCaptureAddress</name></member>
+        </type>
+        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"             alias="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
+        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+        </type>
+        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"               alias="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>rectangularLines</name></member>
+            <member><type>VkBool32</type>                           <name>bresenhamLines</name></member>
+            <member><type>VkBool32</type>                           <name>smoothLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledRectangularLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledBresenhamLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledSmoothLines</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeaturesEXT" alias="VkPhysicalDeviceLineRasterizationFeaturesKHR"/>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bits"><type>uint32_t</type>                            <name>lineSubPixelPrecisionBits</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationPropertiesEXT" alias="VkPhysicalDeviceLineRasterizationPropertiesKHR"/>
+        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfoKHR" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                      <name>pNext</name></member>
+            <member><type>VkLineRasterizationModeKHR</type>                                       <name>lineRasterizationMode</name></member>
+            <member><type>VkBool32</type>                                                         <name>stippledLineEnable</name></member>
+            <member><type>uint32_t</type>                                                         <name>lineStippleFactor</name></member>
+            <member><type>uint16_t</type>                                                         <name>lineStipplePattern</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfoEXT" alias="VkPipelineRasterizationLineStateCreateInfoKHR"/>
+        <type category="struct" name="VkPhysicalDevicePipelineCreationCacheControlFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>              <name>pipelineCreationCacheControl</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT" alias="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceVulkan11Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
+            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a renderpass</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a renderpass w/ geometry shader</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a renderpass w/ tessellation shader</comment></member>
+            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
+            <member><type>VkBool32</type>                         <name>protectedMemory</name></member>
+            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan11Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member limittype="exact"><type>uint8_t</type>                          <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="exact"><type>uint8_t</type>                          <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="exact"><type>uint8_t</type>                          <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
+            <member limittype="exact"><type>uint32_t</type>                         <name>deviceNodeMask</name></member>
+            <member limittype="exact"><type>VkBool32</type>                         <name>deviceLUIDValid</name></member>
+            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type>                      <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>subgroupSupportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>subgroupSupportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type>                      <name>subgroupQuadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
+            <member limittype="exact"><type>VkPointClippingBehavior</type>     <name>pointClippingBehavior</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
+            <member limittype="exact"><type>VkBool32</type>                    <name>protectedNoFault</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan12Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>samplerMirrorClampToEdge</name></member>
+            <member><type>VkBool32</type>                         <name>drawIndirectCount</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderBufferInt64Atomics</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSharedInt64Atomics</name></member>
+            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>descriptorIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSampledImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUpdateUnusedWhilePending</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingPartiallyBound</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingVariableDescriptorCount</name></member>
+            <member><type>VkBool32</type>                         <name>runtimeDescriptorArray</name></member>
+            <member><type>VkBool32</type>                         <name>samplerFilterMinmax</name></member>
+            <member><type>VkBool32</type>                         <name>scalarBlockLayout</name></member>
+            <member><type>VkBool32</type>                         <name>imagelessFramebuffer</name></member>
+            <member><type>VkBool32</type>                         <name>uniformBufferStandardLayout</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSubgroupExtendedTypes</name></member>
+            <member><type>VkBool32</type>                         <name>separateDepthStencilLayouts</name></member>
+            <member><type>VkBool32</type>                         <name>hostQueryReset</name></member>
+            <member><type>VkBool32</type>                         <name>timelineSemaphore</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddressMultiDevice</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
+            <member><type>VkBool32</type>                         <name>shaderOutputViewportIndex</name></member>
+            <member><type>VkBool32</type>                         <name>shaderOutputLayer</name></member>
+            <member><type>VkBool32</type>                         <name>subgroupBroadcastDynamicId</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan12Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDriverId</type>                       <name>driverID</name></member>
+            <member limittype="noauto"><type>char</type>                             <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
+            <member limittype="noauto"><type>char</type>                             <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
+            <member limittype="noauto"><type>VkConformanceVersion</type>             <name>conformanceVersion</name></member>
+            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>denormBehaviorIndependence</name></member>
+            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>roundingModeIndependence</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>robustBufferAccessUpdateAfterBind</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>quadDivergentImplicitLod</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageUpdateAfterBindResources</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>               <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>               <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>filterMinmaxSingleComponentFormats</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>filterMinmaxImageComponentMapping</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxTimelineSemaphoreValueDifference</name></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type> <name>framebufferIntegerColorSampleCounts</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan13Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>robustImageAccess</name></member>
+            <member><type>VkBool32</type>                         <name>inlineUniformBlock</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>pipelineCreationCacheControl</name></member>
+            <member><type>VkBool32</type>                         <name>privateData</name></member>
+            <member><type>VkBool32</type>                         <name>shaderDemoteToHelperInvocation</name></member>
+            <member><type>VkBool32</type>                         <name>shaderTerminateInvocation</name></member>
+            <member><type>VkBool32</type>                         <name>subgroupSizeControl</name></member>
+            <member><type>VkBool32</type>                         <name>computeFullSubgroups</name></member>
+            <member><type>VkBool32</type>                         <name>synchronization2</name></member>
+            <member><type>VkBool32</type>                         <name>textureCompressionASTC_HDR</name></member>
+            <member><type>VkBool32</type>                         <name>shaderZeroInitializeWorkgroupMemory</name></member>
+            <member><type>VkBool32</type>                         <name>dynamicRendering</name></member>
+            <member><type>VkBool32</type>                         <name>shaderIntegerDotProduct</name></member>
+            <member><type>VkBool32</type>                         <name>maintenance4</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan13Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="min,pot" noautovalidity="true"><type>uint32_t</type> <name>minSubgroupSize</name><comment>The minimum subgroup size supported by this device</comment></member>
+            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type> <name>maxSubgroupSize</name><comment>The maximum subgroup size supported by this device</comment></member>
+            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxComputeWorkgroupSubgroups</name><comment>The maximum number of subgroups supported in a workgroup</comment></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>         <name>requiredSubgroupSizeStages</name><comment>The shader stages that support specifying a subgroup size</comment></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxInlineUniformBlockSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxInlineUniformTotalSize</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProduct64BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                   <name>integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>                <name>storageTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="exact"><type>VkBool32</type>                  <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>                <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="exact"><type>VkBool32</type>                  <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                   <name>maxBufferSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCompilerControlCreateInfoAMD" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkExecutionGraphPipelineCreateInfoAMDX">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"><type>VkStructureType</type>   <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCompilerControlFlagsAMD</type>                                      <name>compilerControlFlags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCoherentMemoryFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>deviceCoherentMemory</name></member>
+        </type>
+        <type category="struct" name="VkFaultData" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_FAULT_DATA"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkFaultLevel</type>                    <name>faultLevel</name></member>
+            <member><type>VkFaultType</type>                     <name>faultType</name></member>
+        </type>
+        <type category="struct" name="VkFaultCallbackInfo" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>           <name>faultCount</name></member>
+            <member optional="true" len="faultCount"><type>VkFaultData</type>*<name>pFaults</name></member>
+            <member><type>PFN_vkFaultCallbackFunction</type>        <name>pfnFaultCallback</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceToolProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>char</type>                  <name>name</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+            <member><type>char</type>                  <name>version</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+            <member><type>VkToolPurposeFlags</type>    <name>purposes</name></member>
+            <member><type>char</type>                  <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>                  <name>layer</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceToolPropertiesEXT" alias="VkPhysicalDeviceToolProperties"/>
+        <type category="struct" name="VkSamplerCustomBorderColorCreateInfoEXT" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkClearColorValue</type>                                                                      <name>customBorderColor</name></member>
+            <member><type>VkFormat</type>                                                                               <name>format</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCustomBorderColorPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                                                   <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                                                                                      <name>maxCustomBorderColorSamplers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCustomBorderColorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>customBorderColors</name></member>
+            <member><type>VkBool32</type>                           <name>customBorderColorWithoutFormat</name></member>
+        </type>
+        <type category="struct" name="VkSamplerBorderColorComponentMappingCreateInfoEXT" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                       <name>pNext</name></member>
+            <member><type>VkComponentMapping</type>                                                                                <name>components</name></member>
+            <member><type>VkBool32</type>                                                                                          <name>srgb</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>borderColorSwizzle</name></member>
+            <member><type>VkBool32</type>                     <name>borderColorSwizzleFromImage</name></member>
+        </type>
+        <type category="union" name="VkDeviceOrHostAddressKHR">
+            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
+            <member noautovalidity="true"><type>void</type>*                      <name>hostAddress</name></member>
+        </type>
+        <type category="union" name="VkDeviceOrHostAddressConstKHR">
+            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
+            <member noautovalidity="true">const <type>void</type>*                <name>hostAddress</name></member>
+        </type>
+        <type category="union" name="VkDeviceOrHostAddressConstAMDX">
+            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
+            <member noautovalidity="true">const <type>void</type>*                <name>hostAddress</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>VkFormat</type>                                      <name>vertexFormat</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
+            <member><type>VkDeviceSize</type>                                  <name>vertexStride</name></member>
+            <member><type>uint32_t</type>                                      <name>maxVertex</name></member>
+            <member><type>VkIndexType</type>                                   <name>indexType</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>indexData</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>transformData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryAabbsDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
+            <member><type>VkDeviceSize</type>                          <name>stride</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryInstancesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member><type>VkBool32</type>                              <name>arrayOfPointers</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
+        </type>
+        <type category="union" name="VkAccelerationStructureGeometryDataKHR">
+            <member selection="VK_GEOMETRY_TYPE_TRIANGLES_KHR"><type>VkAccelerationStructureGeometryTrianglesDataKHR</type> <name>triangles</name></member>
+            <member selection="VK_GEOMETRY_TYPE_AABBS_KHR"><type>VkAccelerationStructureGeometryAabbsDataKHR</type>         <name>aabbs</name></member>
+            <member selection="VK_GEOMETRY_TYPE_INSTANCES_KHR"><type>VkAccelerationStructureGeometryInstancesDataKHR</type> <name>instances</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkGeometryTypeKHR</type>                      <name>geometryType</name></member>
+            <member selector="geometryType"><type>VkAccelerationStructureGeometryDataKHR</type> <name>geometry</name></member>
+            <member optional="true"><type>VkGeometryFlagsKHR</type>     <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildGeometryInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member><type>VkAccelerationStructureTypeKHR</type>                                     <name>type</name></member>
+            <member optional="true"><type>VkBuildAccelerationStructureFlagsKHR</type>               <name>flags</name></member>
+            <member noautovalidity="true"><type>VkBuildAccelerationStructureModeKHR</type>          <name>mode</name></member>
+            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>srcAccelerationStructure</name></member>
+            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>dstAccelerationStructure</name></member>
+            <member optional="true"><type>uint32_t</type>                                           <name>geometryCount</name></member>
+            <member len="geometryCount" optional="true">const <type>VkAccelerationStructureGeometryKHR</type>*    <name>pGeometries</name></member>
+            <member len="geometryCount,1" optional="true,false">const <type>VkAccelerationStructureGeometryKHR</type>* const*   <name>ppGeometries</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                                           <name>scratchData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildRangeInfoKHR">
+            <member><type>uint32_t</type>                                                <name>primitiveCount</name></member>
+            <member><type>uint32_t</type>                                                <name>primitiveOffset</name></member>
+            <member><type>uint32_t</type>                                                <name>firstVertex</name></member>
+            <member><type>uint32_t</type>                                                <name>transformOffset</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member optional="true"><type>VkAccelerationStructureCreateFlagsKHR</type>   <name>createFlags</name></member>
+            <member><type>VkBuffer</type>                                                <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                                            <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                                            <name>size</name></member>
+            <member><type>VkAccelerationStructureTypeKHR</type>                          <name>type</name></member>
+            <member optional="true"><type>VkDeviceAddress</type>                         <name>deviceAddress</name></member>
+        </type>
+        <type category="struct" name="VkAabbPositionsKHR">
+            <member><type>float</type>                                                   <name>minX</name></member>
+            <member><type>float</type>                                                   <name>minY</name></member>
+            <member><type>float</type>                                                   <name>minZ</name></member>
+            <member><type>float</type>                                                   <name>maxX</name></member>
+            <member><type>float</type>                                                   <name>maxY</name></member>
+            <member><type>float</type>                                                   <name>maxZ</name></member>
+        </type>
+        <type category="struct" name="VkAabbPositionsNV"                                       alias="VkAabbPositionsKHR"/>
+        <type category="struct" name="VkTransformMatrixKHR">
+            <member><type>float</type>                                                   <name>matrix</name>[3][4]</member>
+        </type>
+        <type category="struct" name="VkTransformMatrixNV"                                     alias="VkTransformMatrixKHR"/>
+        <type category="struct" name="VkAccelerationStructureInstanceKHR">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transform</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureInstanceNV"                       alias="VkAccelerationStructureInstanceKHR"/>
+        <type category="struct" name="VkAccelerationStructureDeviceAddressInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>accelerationStructure</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureVersionInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member len="latexmath:[2 \times \mathtt{VK\_UUID\_SIZE}]" altlen="2*VK_UUID_SIZE">const <type>uint8_t</type>*                    <name>pVersionData</name></member>
+        </type>
+        <type category="struct" name="VkCopyAccelerationStructureInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyAccelerationStructureToMemoryInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                               <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryToAccelerationStructureInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                          <name>src</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineInterfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                                               <name>maxPipelineRayPayloadSize</name></member>
+            <member><type>uint32_t</type>                                               <name>maxPipelineRayHitAttributeSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineLibraryCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                               <name>libraryCount</name></member>
+            <member len="libraryCount">const <type>VkPipeline</type>*                   <name>pLibraries</name></member>
+        </type>
+        <type category="struct" name="VkRefreshObjectKHR">
+            <member><type>VkObjectType</type>                                       <name>objectType</name></member>
+            <member objecttype="objectType" externsync="true"><type>uint64_t</type> <name>objectHandle</name></member>
+            <member optional="true"><type>VkRefreshObjectFlagsKHR</type>            <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkRefreshObjectListKHR">
+            <member values="VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>uint32_t</type>                                           <name>objectCount</name></member>
+            <member len="objectCount">const <type>VkRefreshObjectKHR</type>*        <name>pObjects</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>extendedDynamicState</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2LogicOp</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2PatchControlPoints</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3TessellationDomainOrigin</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClampEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3PolygonMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3RasterizationSamples</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3SampleMask</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3AlphaToCoverageEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3AlphaToOneEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3LogicOpEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendEquation</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorWriteMask</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3RasterizationStream</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ConservativeRasterizationMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ExtraPrimitiveOverestimationSize</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClipEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3SampleLocationsEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendAdvanced</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ProvokingVertexMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3LineRasterizationMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3LineStippleEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClipNegativeOneToOne</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ViewportWScalingEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ViewportSwizzle</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageToColorEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageToColorLocation</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationTableEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationTable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageReductionMode</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3RepresentativeFragmentTestEnable</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState3ShadingRateImageEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState3PropertiesEXT" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type> <name>dynamicPrimitiveTopologyUnrestricted</name></member>
+        </type>
+        <type category="struct" name="VkColorBlendEquationEXT">
+            <member><type>VkBlendFactor</type>               <name>srcColorBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>               <name>dstColorBlendFactor</name></member>
+            <member><type>VkBlendOp</type>                   <name>colorBlendOp</name></member>
+            <member><type>VkBlendFactor</type>               <name>srcAlphaBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>               <name>dstAlphaBlendFactor</name></member>
+            <member><type>VkBlendOp</type>                   <name>alphaBlendOp</name></member>
+        </type>
+        <type category="struct" name="VkColorBlendAdvancedEXT">
+            <member><type>VkBlendOp</type>                   <name>advancedBlendOp</name></member>
+            <member><type>VkBool32</type>                    <name>srcPremultiplied</name></member>
+            <member><type>VkBool32</type>                    <name>dstPremultiplied</name></member>
+            <member><type>VkBlendOverlapEXT</type>           <name>blendOverlap</name></member>
+            <member><type>VkBool32</type>                    <name>clampResults</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassTransformBeginInfoQCOM" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+        </type>
+        <type category="struct" name="VkCopyCommandTransformInfoQCOM" structextends="VkBufferImageCopy2,VkImageBlit2">
+            <member values="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>*     <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+            <member><type>VkRect2D</type>                        <name>renderArea</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>diagnosticsConfig</name></member>
+        </type>
+        <type category="struct" name="VkDeviceDiagnosticsConfigCreateInfoNV" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceDiagnosticsConfigFlagsNV</type>    <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPipelineOfflineCreateInfo" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR,VkRayTracingPipelineCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>uint8_t</type>                                       <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member><type>VkPipelineMatchControl</type>                        <name>matchControl</name></member>
+            <member><type>VkDeviceSize</type>                                  <name>poolEntrySize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>shaderZeroInitializeWorkgroupMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR" alias="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>shaderSubgroupUniformControlFlow</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRobustness2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>robustBufferAccess2</name></member>
+            <member><type>VkBool32</type>                           <name>robustImageAccess2</name></member>
+            <member><type>VkBool32</type>                           <name>nullDescriptor</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRobustness2PropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>    <name>robustStorageBufferAccessSizeAlignment</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type>    <name>robustUniformBufferAccessSizeAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageRobustnessFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>robustImageAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageRobustnessFeaturesEXT" alias="VkPhysicalDeviceImageRobustnessFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayoutScalarBlockLayout</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout8BitAccess</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout16BitAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePortabilitySubsetFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>constantAlphaColorBlendFactors</name></member>
+            <member><type>VkBool32</type>                           <name>events</name></member>
+            <member><type>VkBool32</type>                           <name>imageViewFormatReinterpretation</name></member>
+            <member><type>VkBool32</type>                           <name>imageViewFormatSwizzle</name></member>
+            <member><type>VkBool32</type>                           <name>imageView2DOn3DImage</name></member>
+            <member><type>VkBool32</type>                           <name>multisampleArrayImage</name></member>
+            <member><type>VkBool32</type>                           <name>mutableComparisonSamplers</name></member>
+            <member><type>VkBool32</type>                           <name>pointPolygons</name></member>
+            <member><type>VkBool32</type>                           <name>samplerMipLodBias</name></member>
+            <member><type>VkBool32</type>                           <name>separateStencilMaskRef</name></member>
+            <member><type>VkBool32</type>                           <name>shaderSampleRateInterpolationFunctions</name></member>
+            <member><type>VkBool32</type>                           <name>tessellationIsolines</name></member>
+            <member><type>VkBool32</type>                           <name>tessellationPointMode</name></member>
+            <member><type>VkBool32</type>                           <name>triangleFans</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeAccessBeyondStride</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePortabilitySubsetPropertiesKHR" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member limittype="min,pot"><type>uint32_t</type>  <name>minVertexInputBindingStrideAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice4444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>formatA4R4G4B4</name></member>
+            <member><type>VkBool32</type>                           <name>formatA4B4G4R4</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>subpassShading</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"><type>VkStructureType</type>  <name>sType</name></member>
+            <member optional="true"><type>void</type>*<name>pNext</name></member>
+            <member><type>VkBool32</type> <name>clustercullingShader</name></member>
+            <member><type>VkBool32</type> <name>multiviewClusterCullingShader</name></member>
+       </type>
+        <type category="struct" name="VkBufferCopy2">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
+            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkBufferCopy2KHR" alias="VkBufferCopy2"/>
+        <type category="struct" name="VkImageCopy2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>                         <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageCopy2KHR" alias="VkImageCopy2"/>
+        <type category="struct" name="VkImageBlit2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageBlit2KHR" alias="VkImageBlit2"/>
+        <type category="struct" name="VkBufferImageCopy2">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>bufferOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type>                           <name>bufferRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>                           <name>bufferImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>                         <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkBufferImageCopy2KHR" alias="VkBufferImageCopy2"/>
+        <type category="struct" name="VkImageResolve2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>srcOffset</name></member>
+            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>                         <name>dstOffset</name></member>
+            <member><type>VkExtent3D</type>                         <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkImageResolve2KHR" alias="VkImageResolve2"/>
+        <type category="struct" name="VkCopyBufferInfo2">
+            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBuffer</type>                           <name>srcBuffer</name></member>
+            <member><type>VkBuffer</type>                           <name>dstBuffer</name></member>
+            <member><type>uint32_t</type>                           <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferCopy2</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyBufferInfo2KHR" alias="VkCopyBufferInfo2"/>
+        <type category="struct" name="VkCopyImageInfo2">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkImage</type>                            <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                      <name>srcImageLayout</name></member>
+            <member><type>VkImage</type>                            <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                      <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                           <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageCopy2</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageInfo2KHR" alias="VkCopyImageInfo2"/>
+        <type category="struct" name="VkBlitImageInfo2">
+            <member values="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkImage</type>                                <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                          <name>srcImageLayout</name></member>
+            <member><type>VkImage</type>                                <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                          <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                               <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageBlit2</type>*  <name>pRegions</name></member>
+            <member><type>VkFilter</type>                               <name>filter</name></member>
+        </type>
+        <type category="struct" name="VkBlitImageInfo2KHR" alias="VkBlitImageInfo2"/>
+        <type category="struct" name="VkCopyBufferToImageInfo2">
+            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member><type>VkBuffer</type>                                    <name>srcBuffer</name></member>
+            <member><type>VkImage</type>                                     <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                               <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                                    <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferImageCopy2</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyBufferToImageInfo2KHR" alias="VkCopyBufferToImageInfo2"/>
+        <type category="struct" name="VkCopyImageToBufferInfo2">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>VkImage</type>                                       <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                                 <name>srcImageLayout</name></member>
+            <member><type>VkBuffer</type>                                      <name>dstBuffer</name></member>
+            <member><type>uint32_t</type>                                      <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferImageCopy2</type>*   <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageToBufferInfo2KHR" alias="VkCopyImageToBufferInfo2"/>
+        <type category="struct" name="VkResolveImageInfo2">
+            <member values="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>VkImage</type>                                    <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
+            <member><type>VkImage</type>                                    <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageResolve2</type>*   <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkResolveImageInfo2KHR" alias="VkResolveImageInfo2"/>
+        <type category="struct" name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageInt64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageInt64Atomics</name></member>
+        </type>
+        <type category="struct" name="VkFragmentShadingRateAttachmentInfoKHR" structextends="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>* <name>pFragmentShadingRateAttachment</name></member>
+            <member><type>VkExtent2D</type>                 <name>shadingRateAttachmentTexelSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineFragmentShadingRateStateCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member><type>VkExtent2D</type>                                 <name>fragmentSize</name></member>
+            <member noautovalidity="true"><type>VkFragmentShadingRateCombinerOpKHR</type>         <name>combinerOps</name>[2]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>           <name>pipelineFragmentShadingRate</name></member>
+            <member><type>VkBool32</type>           <name>primitiveFragmentShadingRate</name></member>
+            <member><type>VkBool32</type>           <name>attachmentFragmentShadingRate</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="min"><type>VkExtent2D</type>             <name>minFragmentShadingRateAttachmentTexelSize</name></member>
+            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentShadingRateAttachmentTexelSize</name></member>
+            <member limittype="max,pot"><type>uint32_t</type>                <name>maxFragmentShadingRateAttachmentTexelSizeAspectRatio</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>primitiveFragmentShadingRateWithMultipleViewports</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>layeredShadingRateAttachments</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateNonTrivialCombinerOps</name></member>
+            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentSize</name></member>
+            <member limittype="max,pot"><type>uint32_t</type>                <name>maxFragmentSizeAspectRatio</name></member>
+            <member limittype="max"><type>uint32_t</type>                   <name>maxFragmentShadingRateCoverageSamples</name></member>
+            <member limittype="max"><type>VkSampleCountFlagBits</type>  <name>maxFragmentShadingRateRasterizationSamples</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderDepthStencilWrites</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithSampleMask</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderSampleMask</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithConservativeRasterization</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithFragmentShaderInterlock</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithCustomSampleLocations</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateStrictMultiplyCombiner</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkSampleCountFlags</type> <name>sampleCounts</name></member>
+            <member><type>VkExtent2D</type>         <name>fragmentSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderTerminateInvocationFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                       <name>shaderTerminateInvocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR" alias="VkPhysicalDeviceShaderTerminateInvocationFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>fragmentShadingRateEnums</name></member>
+            <member><type>VkBool32</type>                           <name>supersampleFragmentShadingRates</name></member>
+            <member><type>VkBool32</type>                           <name>noInvocationFragmentShadingRates</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member limittype="max"><type>VkSampleCountFlagBits</type>              <name>maxFragmentShadingRateInvocationCount</name></member>
+        </type>
+        <type category="struct" name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkFragmentShadingRateTypeNV</type>        <name>shadingRateType</name></member>
+            <member noautovalidity="true"><type>VkFragmentShadingRateNV</type>            <name>shadingRate</name></member>
+            <member noautovalidity="true"><type>VkFragmentShadingRateCombinerOpKHR</type> <name>combinerOps</name>[2]</member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildSizesInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>accelerationStructureSize</name></member>
+            <member><type>VkDeviceSize</type>                       <name>updateScratchSize</name></member>
+            <member><type>VkDeviceSize</type>                       <name>buildScratchSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImage2DViewOf3DFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>image2DViewOf3D</name></member>
+            <member><type>VkBool32</type>                                        <name>sampler2DViewOf3D</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>imageSlicedViewOf3D</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>attachmentFeedbackLoopDynamicState</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>mutableDescriptorType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE" alias="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"/>
+        <type category="struct" name="VkMutableDescriptorTypeListEXT">
+            <member optional="true"><type>uint32_t</type>                          <name>descriptorTypeCount</name></member>
+            <member len="descriptorTypeCount">const <type>VkDescriptorType</type>* <name>pDescriptorTypes</name></member>
+        </type>
+        <type category="struct" name="VkMutableDescriptorTypeListVALVE" alias="VkMutableDescriptorTypeListEXT"/>
+        <type category="struct" name="VkMutableDescriptorTypeCreateInfoEXT" structextends="VkDescriptorSetLayoutCreateInfo,VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                       <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                          <name>mutableDescriptorTypeListCount</name></member>
+            <member len="mutableDescriptorTypeListCount">const <type>VkMutableDescriptorTypeListEXT</type>* <name>pMutableDescriptorTypeLists</name></member>
+        </type>
+        <type category="struct" name="VkMutableDescriptorTypeCreateInfoVALVE" alias="VkMutableDescriptorTypeCreateInfoEXT"/>
+        <type category="struct" name="VkPhysicalDeviceDepthClipControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                                    <name>depthClipControl</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportDepthClipControlCreateInfoEXT" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>negativeOneToOne</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>vertexInputDynamicState</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>externalMemoryRDMA</name></member>
+        </type>
+        <type category="struct" name="VkVertexInputBindingDescription2EXT">
+            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>uint32_t</type>                       <name>binding</name></member>
+            <member><type>uint32_t</type>                       <name>stride</name></member>
+            <member><type>VkVertexInputRate</type>              <name>inputRate</name></member>
+            <member><type>uint32_t</type>                       <name>divisor</name></member>
+        </type>
+        <type category="struct" name="VkVertexInputAttributeDescription2EXT">
+            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>uint32_t</type>                       <name>location</name><comment>location of the shader vertex attrib</comment></member>
+            <member><type>uint32_t</type>                       <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>VkFormat</type>                       <name>format</name><comment>format of source data</comment></member>
+            <member><type>uint32_t</type>                       <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceColorWriteEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>colorWriteEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorWriteCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
+            <member len="attachmentCount">const <type>VkBool32</type>*  <name>pColorWriteEnables</name></member>
+        </type>
+        <type category="struct" name="VkMemoryBarrier2" structextends="VkSubpassDependency2">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
+        </type>
+        <type category="struct" name="VkMemoryBarrier2KHR" alias="VkMemoryBarrier2"/>
+        <type category="struct" name="VkImageMemoryBarrier2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
+            <member><type>VkImageLayout</type>                          <name>oldLayout</name></member>
+            <member><type>VkImageLayout</type>                          <name>newLayout</name></member>
+            <member><type>uint32_t</type>                               <name>srcQueueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                               <name>dstQueueFamilyIndex</name></member>
+            <member><type>VkImage</type>                                <name>image</name></member>
+            <member><type>VkImageSubresourceRange</type>                <name>subresourceRange</name></member>
+        </type>
+        <type category="struct" name="VkImageMemoryBarrier2KHR" alias="VkImageMemoryBarrier2"/>
+        <type category="struct" name="VkBufferMemoryBarrier2">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
+            <member><type>uint32_t</type>                               <name>srcQueueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                               <name>dstQueueFamilyIndex</name></member>
+            <member><type>VkBuffer</type>                               <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                           <name>offset</name></member>
+            <member><type>VkDeviceSize</type>                           <name>size</name></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryBarrier2KHR" alias="VkBufferMemoryBarrier2"/>
+        <type category="struct" name="VkDependencyInfo">
+            <member values="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                  <name>pNext</name></member>
+            <member optional="true"><type>VkDependencyFlags</type>                            <name>dependencyFlags</name></member>
+            <member optional="true"><type>uint32_t</type>                                     <name>memoryBarrierCount</name></member>
+            <member len="memoryBarrierCount">const <type>VkMemoryBarrier2</type>*             <name>pMemoryBarriers</name></member>
+            <member optional="true"><type>uint32_t</type>                                     <name>bufferMemoryBarrierCount</name></member>
+            <member len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier2</type>* <name>pBufferMemoryBarriers</name></member>
+            <member optional="true"><type>uint32_t</type>                                     <name>imageMemoryBarrierCount</name></member>
+            <member len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier2</type>*   <name>pImageMemoryBarriers</name></member>
+        </type>
+        <type category="struct" name="VkDependencyInfoKHR" alias="VkDependencyInfo"/>
+        <type category="struct" name="VkSemaphoreSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"><type>VkStructureType</type>           <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                                                                <name>semaphore</name></member>
+            <member><type>uint64_t</type>                                                                   <name>value</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2</type>                                      <name>stageMask</name></member>
+            <member><type>uint32_t</type>                                                                   <name>deviceIndex</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSubmitInfoKHR" alias="VkSemaphoreSubmitInfo"/>
+        <type category="struct" name="VkCommandBufferSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"><type>VkStructureType</type>      <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member><type>VkCommandBuffer</type>                                                            <name>commandBuffer</name></member>
+            <member><type>uint32_t</type>                                                                   <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferSubmitInfoKHR" alias="VkCommandBufferSubmitInfo"/>
+        <type category="struct" name="VkSubmitInfo2">
+            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"><type>VkStructureType</type>                   <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member optional="true"><type>VkSubmitFlags</type>                                              <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>waitSemaphoreInfoCount</name></member>
+            <member len="waitSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfo</type>*                  <name>pWaitSemaphoreInfos</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>commandBufferInfoCount</name></member>
+            <member len="commandBufferInfoCount">const <type>VkCommandBufferSubmitInfo</type>*              <name>pCommandBufferInfos</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>signalSemaphoreInfoCount</name></member>
+            <member len="signalSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfo</type>*                <name>pSignalSemaphoreInfos</name></member>
+        </type>
+        <type category="struct" name="VkSubmitInfo2KHR" alias="VkSubmitInfo2"/>
+        <type category="struct" name="VkQueueFamilyCheckpointProperties2NV" structextends="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*           <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkPipelineStageFlags2</type> <name>checkpointExecutionStageMask</name></member>
+        </type>
+        <type category="struct" name="VkCheckpointData2NV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkPipelineStageFlags2</type>   <name>stage</name></member>
+            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSynchronization2Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>synchronization2</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSynchronization2FeaturesKHR" alias="VkPhysicalDeviceSynchronization2Features"/>
+        <type category="struct" name="VkPhysicalDeviceHostImageCopyFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>hostImageCopy</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceHostImageCopyPropertiesEXT" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true" limittype="noauto"><type>uint32_t</type>                                  <name>copySrcLayoutCount</name></member>
+            <member optional="true" limittype="noauto" len="copySrcLayoutCount"><type>VkImageLayout</type>*   <name>pCopySrcLayouts</name></member>
+            <member optional="true" limittype="noauto"><type>uint32_t</type>                                  <name>copyDstLayoutCount</name></member>
+            <member optional="true" limittype="noauto" len="copyDstLayoutCount"><type>VkImageLayout</type>*   <name>pCopyDstLayouts</name></member>
+            <member optional="true" limittype="noauto"><type>uint8_t</type>                                   <name>optimalTilingLayoutUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="bitmask"><type>VkBool32</type>                                                 <name>identicalMemoryTypeRequirements</name></member>
+        </type>
+        <type category="struct" name="VkMemoryToImageCopyEXT">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member>const <type>void</type>*                                    <name>pHostPointer</name></member>
+            <member><type>uint32_t</type>                                       <name>memoryRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>                                       <name>memoryImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type>                       <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>                                     <name>imageOffset</name></member>
+            <member><type>VkExtent3D</type>                                     <name>imageExtent</name></member>
+        </type>
+        <type category="struct" name="VkImageToMemoryCopyEXT">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>void</type>*                                          <name>pHostPointer</name></member>
+            <member><type>uint32_t</type>                                       <name>memoryRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>                                       <name>memoryImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type>                       <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>                                     <name>imageOffset</name></member>
+            <member><type>VkExtent3D</type>                                     <name>imageExtent</name></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryToImageInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkHostImageCopyFlagsEXT</type>    <name>flags</name></member>
+            <member><type>VkImage</type>                                    <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkMemoryToImageCopyEXT</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageToMemoryInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkHostImageCopyFlagsEXT</type>    <name>flags</name></member>
+            <member><type>VkImage</type>                                    <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
+            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageToMemoryCopyEXT</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageToImageInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkHostImageCopyFlagsEXT</type>    <name>flags</name></member>
+            <member><type>VkImage</type>                                    <name>srcImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
+            <member><type>VkImage</type>                                    <name>dstImage</name></member>
+            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageCopy2</type>*      <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkHostImageLayoutTransitionInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkImage</type>                      <name>image</name></member>
+            <member><type>VkImageLayout</type>                <name>oldLayout</name></member>
+            <member><type>VkImageLayout</type>                <name>newLayout</name></member>
+            <member><type>VkImageSubresourceRange</type>      <name>subresourceRange</name></member>
+        </type>
+        <type category="struct" name="VkSubresourceHostMemcpySizeEXT" returnedonly="true" structextends="VkSubresourceLayout2KHR">
+            <member values="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                 <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkHostImageCopyDevicePerformanceQueryEXT" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>optimalDeviceAccess</name><comment>Specifies if device access is optimal</comment></member>
+            <member><type>VkBool32</type>                     <name>identicalMemoryLayout</name><comment>Specifies if memory layout is identical</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanSC10Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>deviceNoDynamicHostAllocations</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>deviceDestroyFreesMemory</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>commandPoolMultipleCommandBuffersRecording</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>commandPoolResetCommandBuffer</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>commandBufferSimultaneousUse</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>secondaryCommandBufferNullOrImagelessFramebuffer</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>recycleDescriptorSetMemory</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>   <name>recyclePipelineMemory</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxRenderPassSubpasses</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxRenderPassDependencies</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxSubpassInputAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxSubpassPreserveAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxFramebufferAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxDescriptorSetLayoutBindings</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxQueryFaultCount</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxCallbackFaultCount</name></member>
+            <member limittype="max"><type>uint32_t</type>       <name>maxCommandPoolCommandBuffers</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>   <name>maxCommandBufferSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelinePoolSize">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                   <name>poolEntrySize</name></member>
+            <member><type>uint32_t</type>                       <name>poolEntryCount</name></member>
+        </type>
+        <type category="struct" name="VkDeviceObjectReservationCreateInfo" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>pipelineCacheCreateInfoCount</name></member>
+            <member len="pipelineCacheCreateInfoCount">const <type>VkPipelineCacheCreateInfo</type>* <name>pPipelineCacheCreateInfos</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>pipelinePoolSizeCount</name></member>
+            <member len="pipelinePoolSizeCount">const <type>VkPipelinePoolSize</type>* <name>pPipelinePoolSizes</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>semaphoreRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>commandBufferRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>fenceRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>deviceMemoryRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>bufferRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>imageRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>eventRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>queryPoolRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>bufferViewRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>imageViewRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>layeredImageViewRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>pipelineCacheRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>pipelineLayoutRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>renderPassRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>graphicsPipelineRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>computePipelineRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>descriptorSetLayoutRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>samplerRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>descriptorPoolRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>descriptorSetRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>framebufferRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>commandPoolRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>samplerYcbcrConversionRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>surfaceRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>swapchainRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>displayModeRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>subpassDescriptionRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>attachmentDescriptionRequestCount</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>descriptorSetLayoutBindingRequestCount</name></member>
+            <member><type>uint32_t</type>                       <name>descriptorSetLayoutBindingLimit</name></member>
+            <member><type>uint32_t</type>                       <name>maxImageViewMipLevels</name></member>
+            <member><type>uint32_t</type>                       <name>maxImageViewArrayLayers</name></member>
+            <member><type>uint32_t</type>                       <name>maxLayeredImageViewMipLevels</name></member>
+            <member><type>uint32_t</type>                       <name>maxOcclusionQueriesPerPool</name></member>
+            <member><type>uint32_t</type>                       <name>maxPipelineStatisticsQueriesPerPool</name></member>
+            <member><type>uint32_t</type>                       <name>maxTimestampQueriesPerPool</name></member>
+            <member><type>uint32_t</type>                       <name>maxImmutableSamplersPerDescriptorSetLayout</name></member>
+        </type>
+        <type category="struct" name="VkCommandPoolMemoryReservationCreateInfo" structextends="VkCommandPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>  <name>commandPoolReservedSize</name></member>
+            <member><type>uint32_t</type>      <name>commandPoolMaxCommandBuffers</name></member>
+        </type>
+        <type category="struct" name="VkCommandPoolMemoryConsumption" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                   <name>commandPoolAllocated</name></member>
+            <member><type>VkDeviceSize</type>                   <name>commandPoolReservedSize</name></member>
+            <member><type>VkDeviceSize</type>                   <name>commandBufferAllocated</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanSC10Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>shaderAtomicInstructions</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>primitivesGeneratedQuery</name></member>
+            <member><type>VkBool32</type>               <name>primitivesGeneratedQueryWithRasterizerDiscard</name></member>
+            <member><type>VkBool32</type>               <name>primitivesGeneratedQueryWithNonZeroStreams</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLegacyDitheringFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>legacyDithering</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*   <name>pNext</name></member>
+            <member><type>VkBool32</type>                <name>multisampledRenderToSingleSampled</name></member>
+        </type>
+        <type category="struct" name="VkSubpassResolvePerformanceQueryEXT" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>optimal</name></member>
+        </type>
+        <type category="struct" name="VkMultisampledRenderToSingleSampledInfoEXT" structextends="VkSubpassDescription2,VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
+            <member><type>VkBool32</type>                      <name>multisampledRenderToSingleSampledEnable</name></member>
+            <member><type>VkSampleCountFlagBits</type>         <name>rasterizationSamples</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineProtectedAccessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>pipelineProtectedAccess</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyVideoPropertiesKHR" returnedonly="true" structextends="VkQueueFamilyProperties2">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkVideoCodecOperationFlagsKHR</type>  <name>videoCodecOperations</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyQueryResultStatusPropertiesKHR" returnedonly="true" structextends="VkQueueFamilyProperties2">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                                           <name>queryResultStatusSupport</name></member>
+        </type>
+        <type category="struct" name="VkVideoProfileListInfoKHR" structextends="VkPhysicalDeviceImageFormatInfo2,VkPhysicalDeviceVideoFormatInfoKHR,VkImageCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                      <name>profileCount</name></member>
+            <member len="profileCount">const <type>VkVideoProfileInfoKHR</type>*               <name>pProfiles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVideoFormatInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                          <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type>                                    <name>imageUsage</name></member>
+        </type>
+        <type category="struct" name="VkVideoFormatPropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                                  <name>pNext</name></member>
+            <member><type>VkFormat</type>                                                               <name>format</name></member>
+            <member><type>VkComponentMapping</type>                                                     <name>componentMapping</name></member>
+            <member><type>VkImageCreateFlags</type>                                                     <name>imageCreateFlags</name></member>
+            <member><type>VkImageType</type>                                                            <name>imageType</name></member>
+            <member><type>VkImageTiling</type>                                                          <name>imageTiling</name></member>
+            <member><type>VkImageUsageFlags</type>                                                      <name>imageUsageFlags</name></member>
+        </type>
+        <type category="struct" name="VkVideoProfileInfoKHR" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkVideoCodecOperationFlagBitsKHR</type>   <name>videoCodecOperation</name></member>
+            <member><type>VkVideoChromaSubsamplingFlagsKHR</type>   <name>chromaSubsampling</name></member>
+            <member><type>VkVideoComponentBitDepthFlagsKHR</type>   <name>lumaBitDepth</name></member>
+            <member optional="true"><type>VkVideoComponentBitDepthFlagsKHR</type> <name>chromaBitDepth</name></member>
+        </type>
+        <type category="struct" name="VkVideoCapabilitiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkVideoCapabilityFlagsKHR</type>        <name>flags</name></member>
+            <member><type>VkDeviceSize</type>                     <name>minBitstreamBufferOffsetAlignment</name></member>
+            <member><type>VkDeviceSize</type>                     <name>minBitstreamBufferSizeAlignment</name></member>
+            <member><type>VkExtent2D</type>                       <name>pictureAccessGranularity</name></member>
+            <member><type>VkExtent2D</type>                       <name>minCodedExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxCodedExtent</name></member>
+            <member><type>uint32_t</type>                         <name>maxDpbSlots</name></member>
+            <member><type>uint32_t</type>                         <name>maxActiveReferencePictures</name></member>
+            <member><type>VkExtensionProperties</type>            <name>stdHeaderVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionMemoryRequirementsKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*             <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
+            <member><type>VkMemoryRequirements</type>              <name>memoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkBindVideoSessionMemoryInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
+            <member><type>VkDeviceMemory</type>                    <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                      <name>memoryOffset</name></member>
+            <member><type>VkDeviceSize</type>                      <name>memorySize</name></member>
+        </type>
+        <type category="struct" name="VkVideoPictureResourceInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkOffset2D</type>         <name>codedOffset</name><comment>The offset to be used for the picture resource, currently only used in field mode</comment></member>
+            <member><type>VkExtent2D</type>         <name>codedExtent</name><comment>The extent to be used for the picture resource</comment></member>
+            <member><type>uint32_t</type>           <name>baseArrayLayer</name><comment>The first array layer to be accessed for the Decode or Encode Operations</comment></member>
+            <member><type>VkImageView</type>        <name>imageViewBinding</name><comment>The ImageView binding of the resource</comment></member>
+        </type>
+        <type category="struct" name="VkVideoReferenceSlotInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>int32_t</type>                            <name>slotIndex</name><comment>The reference slot index</comment></member>
+            <member optional="true">const <type>VkVideoPictureResourceInfoKHR</type>* <name>pPictureResource</name><comment>The reference picture resource</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                 <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkVideoDecodeCapabilityFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeUsageInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkVideoDecodeUsageFlagsKHR</type> <name>videoUsageHints</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoDecodeFlagsKHR</type>  <name>flags</name></member>
+            <member><type>VkBuffer</type>                               <name>srcBuffer</name></member>
+            <member><type>VkDeviceSize</type>                           <name>srcBufferOffset</name></member>
+            <member><type>VkDeviceSize</type>                           <name>srcBufferRange</name></member>
+            <member><type>VkVideoPictureResourceInfoKHR</type>          <name>dstPictureResource</name></member>
+            <member optional="true">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pSetupReferenceSlot</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
+        </type>
+            <comment>Video Decode Codec Standard specific structures</comment>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std.h">#include "vk_video/vulkan_video_codec_h264std.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ProfileIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264LevelIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ChromaFormatIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PocType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ScalingLists"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SequenceParameterSetVui"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264AspectRatioIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264HrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SpsVuiFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264WeightedBipredIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SliceType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264CabacInitIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264DisableDeblockingFilterIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PictureType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ModificationOfPicNumsIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264MemMgmtControlOp"/>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std_decode.h">#include "vk_video/vulkan_video_codec_h264std_decode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264ReferenceInfoFlags"/>
+        <type category="struct" name="VkVideoDecodeH264ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                  <name>pNext</name></member>
+            <member><type>StdVideoH264ProfileIdc</type>                                       <name>stdProfileIdc</name></member>
+            <member optional="true"><type>VkVideoDecodeH264PictureLayoutFlagBitsKHR</type>    <name>pictureLayout</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>StdVideoH264LevelIdc</type>             <name>maxLevelIdc</name></member>
+            <member><type>VkOffset2D</type>                       <name>fieldOffsetGranularity</name></member>
+        </type>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SequenceParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PictureParameterSet"/>
+        <type category="struct" name="VkVideoDecodeH264SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                       <name>stdSPSCount</name></member>
+            <member len="stdSPSCount">const <type>StdVideoH264SequenceParameterSet</type>*      <name>pStdSPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                       <name>stdPPSCount</name></member>
+            <member len="stdPPSCount">const <type>StdVideoH264PictureParameterSet</type>*       <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>maxStdSPSCount</name></member>
+            <member><type>uint32_t</type>                                                                  <name>maxStdPPSCount</name></member>
+            <member optional="true">const <type>VkVideoDecodeH264SessionParametersAddInfoKHR</type>*       <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*           <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH264PictureInfo</type>*  <name>pStdPictureInfo</name></member>
+            <member><type>uint32_t</type>                              <name>sliceCount</name></member>
+            <member len="sliceCount">const <type>uint32_t</type>*      <name>pSliceOffsets</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH264ReferenceInfo</type>* <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std.h">#include "vk_video/vulkan_video_codec_h265std.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265ProfileIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265VideoParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SequenceParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PictureParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265DecPicBufMgr"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265HrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265VpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265LevelIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265ScalingLists"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SequenceParameterSetVui"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PredictorPaletteEntries"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SubLayerHrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265HrdFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SpsVuiFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SliceType"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PictureType"/>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std_decode.h">#include "vk_video/vulkan_video_codec_h265std_decode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265ReferenceInfoFlags"/>
+        <type category="struct" name="VkVideoDecodeH265ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>StdVideoH265LevelIdc</type>                             <name>maxLevelIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>stdVPSCount</name></member>
+            <member len="stdVPSCount">const <type>StdVideoH265VideoParameterSet</type>*     <name>pStdVPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>stdSPSCount</name></member>
+            <member len="stdSPSCount">const <type>StdVideoH265SequenceParameterSet</type>*  <name>pStdSPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>stdPPSCount</name></member>
+            <member len="stdPPSCount">const <type>StdVideoH265PictureParameterSet</type>*   <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdVPSCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
+            <member optional="true">const <type>VkVideoDecodeH265SessionParametersAddInfoKHR</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH265PictureInfo</type>*       <name>pStdPictureInfo</name></member>
+            <member><type>uint32_t</type>                                   <name>sliceSegmentCount</name></member>
+            <member len="sliceSegmentCount">const <type>uint32_t</type>*    <name>pSliceSegmentOffsets</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH265ReferenceInfo</type>*  <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>uint32_t</type>                                      <name>queueFamilyIndex</name></member>
+            <member optional="true"><type>VkVideoSessionCreateFlagsKHR</type>  <name>flags</name></member>
+            <member>const <type>VkVideoProfileInfoKHR</type>*                  <name>pVideoProfile</name></member>
+            <member><type>VkFormat</type>                                      <name>pictureFormat</name></member>
+            <member><type>VkExtent2D</type>                                    <name>maxCodedExtent</name></member>
+            <member><type>VkFormat</type>                                      <name>referencePictureFormat</name></member>
+            <member><type>uint32_t</type>                                      <name>maxDpbSlots</name></member>
+            <member><type>uint32_t</type>                                      <name>maxActiveReferencePictures</name></member>
+            <member>const <type>VkExtensionProperties</type>*                  <name>pStdHeaderVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoSessionParametersCreateFlagsKHR</type> <name>flags</name></member>
+            <member optional="true"><type>VkVideoSessionParametersKHR</type>            <name>videoSessionParametersTemplate</name></member>
+            <member><type>VkVideoSessionKHR</type>                                      <name>videoSession</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                                               <name>updateSequenceCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeSessionParametersGetInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkVideoSessionParametersKHR</type>                    <name>videoSessionParameters</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member><type>VkBool32</type>                                       <name>hasOverrides</name></member>
+        </type>
+        <type category="struct" name="VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                             <name>pNext</name></member>
+            <member optional="true"><type>VkVideoBeginCodingFlagsKHR</type>              <name>flags</name></member>
+            <member><type>VkVideoSessionKHR</type>                                       <name>videoSession</name></member>
+            <member optional="true"><type>VkVideoSessionParametersKHR</type>             <name>videoSessionParameters</name></member>
+            <member optional="true"><type>uint32_t</type>                                <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
+        </type>
+        <type category="struct" name="VkVideoEndCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEndCodingFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVideoCodingControlInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkVideoCodingControlFlagsKHR</type>  <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeUsageInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeUsageFlagsKHR</type>     <name>videoUsageHints</name></member>
+            <member optional="true"><type>VkVideoEncodeContentFlagsKHR</type>   <name>videoContentHints</name></member>
+            <member optional="true"><type>VkVideoEncodeTuningModeKHR</type>     <name>tuningMode</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeFlagsKHR</type>  <name>flags</name></member>
+            <member><type>VkBuffer</type>                               <name>dstBuffer</name></member>
+            <member><type>VkDeviceSize</type>                           <name>dstBufferOffset</name></member>
+            <member><type>VkDeviceSize</type>                           <name>dstBufferRange</name></member>
+            <member><type>VkVideoPictureResourceInfoKHR</type>          <name>srcPictureResource</name></member>
+            <member optional="true">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pSetupReferenceSlot</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
+            <member><type>uint32_t</type>                               <name>precedingExternallyEncodedBytes</name></member>
+        </type>
+        <type category="struct" name="VkQueryPoolVideoEncodeFeedbackCreateInfoKHR" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkVideoEncodeFeedbackFlagsKHR</type>          <name>encodeFeedbackFlags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeQualityLevelInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                               <name>qualityLevel</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member>const <type>VkVideoProfileInfoKHR</type>*           <name>pVideoProfile</name></member>
+            <member><type>uint32_t</type>                               <name>qualityLevel</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeQualityLevelPropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkVideoEncodeRateControlModeFlagBitsKHR</type> <name>preferredRateControlMode</name></member>
+            <member><type>uint32_t</type>                               <name>preferredRateControlLayerCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeRateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeRateControlFlagsKHR</type> <name>flags</name></member>
+            <member optional="true"><type>VkVideoEncodeRateControlModeFlagBitsKHR</type> <name>rateControlMode</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>layerCount</name></member>
+            <member len="layerCount">const <type>VkVideoEncodeRateControlLayerInfoKHR</type>* <name>pLayers</name></member>
+            <member><type>uint32_t</type>                               <name>virtualBufferSizeInMs</name></member>
+            <member><type>uint32_t</type>                               <name>initialVirtualBufferSizeInMs</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeRateControlLayerInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint64_t</type>                               <name>averageBitrate</name></member>
+            <member><type>uint64_t</type>                               <name>maxBitrate</name></member>
+            <member><type>uint32_t</type>                               <name>frameRateNumerator</name></member>
+            <member><type>uint32_t</type>                               <name>frameRateDenominator</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkVideoEncodeCapabilityFlagsKHR</type>       <name>flags</name></member>
+            <member><type>VkVideoEncodeRateControlModeFlagsKHR</type>  <name>rateControlModes</name></member>
+            <member><type>uint32_t</type>                              <name>maxRateControlLayers</name></member>
+            <member><type>uint64_t</type>                              <name>maxBitrate</name></member>
+            <member><type>uint32_t</type>                              <name>maxQualityLevels</name></member>
+            <member><type>VkExtent2D</type>                            <name>encodeInputPictureGranularity</name></member>
+            <member><type>VkVideoEncodeFeedbackFlagsKHR</type>         <name>supportedEncodeFeedbackFlags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264CapabilitiesEXT" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkVideoEncodeH264CapabilityFlagsEXT</type> <name>flags</name></member>
+            <member><type>StdVideoH264LevelIdc</type>                  <name>maxLevelIdc</name></member>
+            <member><type>uint32_t</type>                              <name>maxSliceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxPPictureL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxBPictureL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxL1ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxTemporalLayerCount</name></member>
+            <member><type>VkBool32</type>                              <name>expectDyadicTemporalLayerPattern</name></member>
+            <member><type>int32_t</type>                               <name>minQp</name></member>
+            <member><type>int32_t</type>                               <name>maxQp</name></member>
+            <member><type>VkBool32</type>                              <name>prefersGopRemainingFrames</name></member>
+            <member><type>VkBool32</type>                              <name>requiresGopRemainingFrames</name></member>
+            <member noautovalidity="true"><type>VkVideoEncodeH264StdFlagsEXT</type> <name>stdSyntaxFlags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264QualityLevelPropertiesEXT" returnedonly="true" structextends="VkVideoEncodeQualityLevelPropertiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkVideoEncodeH264RateControlFlagsEXT</type>   <name>preferredRateControlFlags</name></member>
+            <member><type>uint32_t</type>                               <name>preferredGopFrameCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredIdrPeriod</name></member>
+            <member><type>uint32_t</type>                               <name>preferredConsecutiveBFrameCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredTemporalLayerCount</name></member>
+            <member><type>VkVideoEncodeH264QpEXT</type>                 <name>preferredConstantQp</name></member>
+            <member><type>uint32_t</type>                               <name>preferredMaxL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredMaxL1ReferenceCount</name></member>
+            <member><type>VkBool32</type>                               <name>preferredStdEntropyCodingModeFlag</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std_encode.h">#include "vk_video/vulkan_video_codec_h264std_encode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264SliceHeader"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264SliceHeaderFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264ReferenceListsInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264ReferenceInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefMgmtFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefListModEntry"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefPicMarkingEntry"/>
+        <type category="struct" name="VkVideoEncodeH264SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>useMaxLevelIdc</name></member>
+            <member><type>StdVideoH264LevelIdc</type>                   <name>maxLevelIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                                  <name>stdSPSCount</name></member>
+            <member len="stdSPSCount" optional="true">const <type>StdVideoH264SequenceParameterSet</type>* <name>pStdSPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                                  <name>stdPPSCount</name></member>
+            <member len="stdPPSCount" optional="true">const <type>StdVideoH264PictureParameterSet</type>*  <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
+            <member optional="true">const <type>VkVideoEncodeH264SessionParametersAddInfoEXT</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersGetInfoEXT" structextends="VkVideoEncodeSessionParametersGetInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>writeStdSPS</name></member>
+            <member><type>VkBool32</type>                               <name>writeStdPPS</name></member>
+            <member><type>uint32_t</type>                               <name>stdSPSId</name></member>
+            <member><type>uint32_t</type>                               <name>stdPPSId</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersFeedbackInfoEXT" structextends="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>hasStdSPSOverrides</name></member>
+            <member><type>VkBool32</type>                               <name>hasStdPPSOverrides</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264DpbSlotInfoEXT" structextends="VkVideoReferenceSlotInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                          <name>pNext</name></member>
+            <member>const <type>StdVideoEncodeH264ReferenceInfo</type>*                               <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264PictureInfoEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                        <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                           <name>naluSliceEntryCount</name></member>
+            <member len="naluSliceEntryCount">const <type>VkVideoEncodeH264NaluSliceInfoEXT</type>* <name>pNaluSliceEntries</name></member>
+            <member>const <type>StdVideoEncodeH264PictureInfo</type>*                               <name>pStdPictureInfo</name></member>
+            <member><type>VkBool32</type>                                                           <name>generatePrefixNalu</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264ProfileInfoEXT" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
+            <member><type>StdVideoH264ProfileIdc</type>                  <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264NaluSliceInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>int32_t</type>                                         <name>constantQp</name></member>
+            <member>const <type>StdVideoEncodeH264SliceHeader</type>*            <name>pStdSliceHeader</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264RateControlInfoEXT" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeH264RateControlFlagsEXT</type> <name>flags</name></member>
+            <member><type>uint32_t</type>                                        <name>gopFrameCount</name></member>
+            <member><type>uint32_t</type>                                        <name>idrPeriod</name></member>
+            <member><type>uint32_t</type>                                        <name>consecutiveBFrameCount</name></member>
+            <member><type>uint32_t</type>                                        <name>temporalLayerCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264QpEXT">
+            <member noautovalidity="true"><type>int32_t</type> <name>qpI</name></member>
+            <member noautovalidity="true"><type>int32_t</type> <name>qpP</name></member>
+            <member noautovalidity="true"><type>int32_t</type> <name>qpB</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264FrameSizeEXT">
+            <member noautovalidity="true"><type>uint32_t</type> <name>frameISize</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>framePSize</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>frameBSize</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264GopRemainingFrameInfoEXT" structextends="VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>useGopRemainingFrames</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingI</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingP</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingB</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264RateControlLayerInfoEXT" structextends="VkVideoEncodeRateControlLayerInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>useMinQp</name></member>
+            <member><type>VkVideoEncodeH264QpEXT</type>                          <name>minQp</name></member>
+            <member><type>VkBool32</type>                                        <name>useMaxQp</name></member>
+            <member><type>VkVideoEncodeH264QpEXT</type>                          <name>maxQp</name></member>
+            <member><type>VkBool32</type>                                        <name>useMaxFrameSize</name></member>
+            <member><type>VkVideoEncodeH264FrameSizeEXT</type>                   <name>maxFrameSize</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265CapabilitiesEXT" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkVideoEncodeH265CapabilityFlagsEXT</type> <name>flags</name></member>
+            <member><type>StdVideoH265LevelIdc</type>                  <name>maxLevelIdc</name></member>
+            <member><type>uint32_t</type>                              <name>maxSliceSegmentCount</name></member>
+            <member><type>VkExtent2D</type>                            <name>maxTiles</name></member>
+            <member><type>VkVideoEncodeH265CtbSizeFlagsEXT</type>      <name>ctbSizes</name></member>
+            <member><type>VkVideoEncodeH265TransformBlockSizeFlagsEXT</type>      <name>transformBlockSizes</name></member>
+            <member><type>uint32_t</type>                              <name>maxPPictureL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxBPictureL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxL1ReferenceCount</name></member>
+            <member><type>uint32_t</type>                              <name>maxSubLayerCount</name></member>
+            <member><type>VkBool32</type>                              <name>expectDyadicTemporalSubLayerPattern</name></member>
+            <member><type>int32_t</type>                               <name>minQp</name></member>
+            <member><type>int32_t</type>                               <name>maxQp</name></member>
+            <member><type>VkBool32</type>                              <name>prefersGopRemainingFrames</name></member>
+            <member><type>VkBool32</type>                              <name>requiresGopRemainingFrames</name></member>
+            <member noautovalidity="true"><type>VkVideoEncodeH265StdFlagsEXT</type> <name>stdSyntaxFlags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265QualityLevelPropertiesEXT" returnedonly="true" structextends="VkVideoEncodeQualityLevelPropertiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkVideoEncodeH265RateControlFlagsEXT</type>   <name>preferredRateControlFlags</name></member>
+            <member><type>uint32_t</type>                               <name>preferredGopFrameCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredIdrPeriod</name></member>
+            <member><type>uint32_t</type>                               <name>preferredConsecutiveBFrameCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredSubLayerCount</name></member>
+            <member><type>VkVideoEncodeH265QpEXT</type>                 <name>preferredConstantQp</name></member>
+            <member><type>uint32_t</type>                               <name>preferredMaxL0ReferenceCount</name></member>
+            <member><type>uint32_t</type>                               <name>preferredMaxL1ReferenceCount</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std_encode.h">#include "vk_video/vulkan_video_codec_h265std_encode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceSegmentHeader"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceListsInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceSegmentHeaderFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceModificationFlags"/>
+        <type category="struct" name="VkVideoEncodeH265SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>useMaxLevelIdc</name></member>
+            <member><type>StdVideoH265LevelIdc</type>                   <name>maxLevelIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                                  <name>stdVPSCount</name></member>
+            <member len="stdVPSCount" optional="true">const <type>StdVideoH265VideoParameterSet</type>*    <name>pStdVPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                                  <name>stdSPSCount</name></member>
+            <member len="stdSPSCount" optional="true">const <type>StdVideoH265SequenceParameterSet</type>* <name>pStdSPSs</name></member>
+            <member optional="true"><type>uint32_t</type>                                                  <name>stdPPSCount</name></member>
+            <member len="stdPPSCount" optional="true">const <type>StdVideoH265PictureParameterSet</type>*  <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdVPSCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
+            <member optional="true">const <type>VkVideoEncodeH265SessionParametersAddInfoEXT</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersGetInfoEXT" structextends="VkVideoEncodeSessionParametersGetInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>writeStdVPS</name></member>
+            <member><type>VkBool32</type>                               <name>writeStdSPS</name></member>
+            <member><type>VkBool32</type>                               <name>writeStdPPS</name></member>
+            <member><type>uint32_t</type>                               <name>stdVPSId</name></member>
+            <member><type>uint32_t</type>                               <name>stdSPSId</name></member>
+            <member><type>uint32_t</type>                               <name>stdPPSId</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersFeedbackInfoEXT" structextends="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>hasStdVPSOverrides</name></member>
+            <member><type>VkBool32</type>                               <name>hasStdSPSOverrides</name></member>
+            <member><type>VkBool32</type>                               <name>hasStdPPSOverrides</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265PictureInfoEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                       <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                          <name>naluSliceSegmentEntryCount</name></member>
+            <member len="naluSliceSegmentEntryCount">const <type>VkVideoEncodeH265NaluSliceSegmentInfoEXT</type>* <name>pNaluSliceSegmentEntries</name></member>
+            <member>const <type>StdVideoEncodeH265PictureInfo</type>*                              <name>pStdPictureInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265NaluSliceSegmentInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member><type>int32_t</type>                                                    <name>constantQp</name></member>
+            <member>const <type>StdVideoEncodeH265SliceSegmentHeader</type>*                <name>pStdSliceSegmentHeader</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265RateControlInfoEXT" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeH265RateControlFlagsEXT</type> <name>flags</name></member>
+            <member><type>uint32_t</type>                                        <name>gopFrameCount</name></member>
+            <member><type>uint32_t</type>                                        <name>idrPeriod</name></member>
+            <member><type>uint32_t</type>                                        <name>consecutiveBFrameCount</name></member>
+            <member><type>uint32_t</type>                                        <name>subLayerCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265QpEXT">
+            <member noautovalidity="true"><type>int32_t</type> <name>qpI</name></member>
+            <member noautovalidity="true"><type>int32_t</type> <name>qpP</name></member>
+            <member noautovalidity="true"><type>int32_t</type> <name>qpB</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265FrameSizeEXT">
+            <member noautovalidity="true"><type>uint32_t</type> <name>frameISize</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>framePSize</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>frameBSize</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265GopRemainingFrameInfoEXT" structextends="VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>useGopRemainingFrames</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingI</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingP</name></member>
+            <member><type>uint32_t</type>                       <name>gopRemainingB</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265RateControlLayerInfoEXT" structextends="VkVideoEncodeRateControlLayerInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>useMinQp</name></member>
+            <member><type>VkVideoEncodeH265QpEXT</type>                          <name>minQp</name></member>
+            <member><type>VkBool32</type>                                        <name>useMaxQp</name></member>
+            <member><type>VkVideoEncodeH265QpEXT</type>                          <name>maxQp</name></member>
+            <member><type>VkBool32</type>                                        <name>useMaxFrameSize</name></member>
+            <member><type>VkVideoEncodeH265FrameSizeEXT</type>                   <name>maxFrameSize</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265ProfileInfoEXT" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265DpbSlotInfoEXT" structextends="VkVideoReferenceSlotInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*              <name>pNext</name></member>
+            <member>const <type>StdVideoEncodeH265ReferenceInfo</type>*   <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>inheritedViewportScissor2D</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceViewportScissorInfoNV" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                       <name>viewportScissor2D</name></member>
+            <member><type>uint32_t</type>                                       <name>viewportDepthCount</name></member>
+            <member noautovalidity="true">const <type>VkViewport</type>*        <name>pViewportDepths</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>ycbcr2plane444Formats</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProvokingVertexFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>provokingVertexLast</name></member>
+            <member><type>VkBool32</type>                           <name>transformFeedbackPreservesProvokingVertex</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProvokingVertexPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                            <name>provokingVertexModePerPipeline</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                            <name>transformFeedbackPreservesTriangleFanProvokingVertex</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkProvokingVertexModeEXT</type>           <name>provokingVertexMode</name></member>
+        </type>
+        <type category="struct" name="VkCuModuleCreateInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>size_t</type>                 <name>dataSize</name></member>
+            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkCuFunctionCreateInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkCuModuleNVX</type>                      <name>module</name></member>
+            <member len="null-terminated">const <type>char</type>*  <name>pName</name></member>
+        </type>
+        <type category="struct" name="VkCuLaunchInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkCuFunctionNVX</type>        <name>function</name></member>
+            <member><type>uint32_t</type>               <name>gridDimX</name></member>
+            <member><type>uint32_t</type>               <name>gridDimY</name></member>
+            <member><type>uint32_t</type>               <name>gridDimZ</name></member>
+            <member><type>uint32_t</type>               <name>blockDimX</name></member>
+            <member><type>uint32_t</type>               <name>blockDimY</name></member>
+            <member><type>uint32_t</type>               <name>blockDimZ</name></member>
+            <member><type>uint32_t</type>               <name>sharedMemBytes</name></member>
+            <member optional="true"><type>size_t</type>                 <name>paramCount</name></member>
+            <member len="paramCount">const <type>void</type>* const *    <name>pParams</name></member>
+            <member optional="true"><type>size_t</type>                 <name>extraCount</name></member>
+            <member len="extraCount">const <type>void</type>* const *    <name>pExtras</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorBufferFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>descriptorBuffer</name></member>
+            <member><type>VkBool32</type>                           <name>descriptorBufferCaptureReplay</name></member>
+            <member><type>VkBool32</type>                           <name>descriptorBufferImageLayoutIgnored</name></member>
+            <member><type>VkBool32</type>                           <name>descriptorBufferPushDescriptors</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorBufferPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>combinedImageSamplerDescriptorSingleArray</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>bufferlessPushDescriptors</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>allowSamplerImageViewPostSubmitCreation</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>                     <name>descriptorBufferOffsetAlignment</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorBufferBindings</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxResourceDescriptorBufferBindings</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxSamplerDescriptorBufferBindings</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxEmbeddedImmutableSamplerBindings</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxEmbeddedImmutableSamplers</name></member>
+            <member limittype="noauto"><type>size_t</type>                           <name>bufferCaptureReplayDescriptorDataSize</name></member>
+            <member limittype="noauto"><type>size_t</type>                           <name>imageCaptureReplayDescriptorDataSize</name></member>
+            <member limittype="noauto"><type>size_t</type>                           <name>imageViewCaptureReplayDescriptorDataSize</name></member>
+            <member limittype="noauto"><type>size_t</type>                           <name>samplerCaptureReplayDescriptorDataSize</name></member>
+            <member limittype="noauto"><type>size_t</type>                           <name>accelerationStructureCaptureReplayDescriptorDataSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>samplerDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>combinedImageSamplerDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>sampledImageDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>storageImageDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>uniformTexelBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>robustUniformTexelBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>storageTexelBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>robustStorageTexelBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>uniformBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>robustUniformBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>storageBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>robustStorageBufferDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>inputAttachmentDescriptorSize</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>accelerationStructureDescriptorSize</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                        <name>maxSamplerDescriptorBufferRange</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                        <name>maxResourceDescriptorBufferRange</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                        <name>samplerDescriptorBufferAddressSpaceSize</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                        <name>resourceDescriptorBufferAddressSpaceSize</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                        <name>descriptorBufferAddressSpaceSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="max"><type>size_t</type>                              <name>combinedImageSamplerDensityMapDescriptorSize</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorAddressInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>                         <name>address</name></member>
+            <member><type>VkDeviceSize</type>                            <name>range</name></member>
+            <member><type>VkFormat</type>                                <name>format</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorBufferBindingInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>                         <name>address</name></member>
+            <member><type>VkBufferUsageFlags</type>                      <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorBufferBindingPushDescriptorBufferHandleEXT" structextends="VkDescriptorBufferBindingInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member ><type>VkBuffer</type>                               <name>buffer</name></member>
+        </type>
+        <type category="union" name="VkDescriptorDataEXT">
+            <member selection="VK_DESCRIPTOR_TYPE_SAMPLER">const <type>VkSampler</type>*                                                     <name>pSampler</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER">const <type>VkDescriptorImageInfo</type>*                          <name>pCombinedImageSampler</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT">const <type>VkDescriptorImageInfo</type>*                                <name>pInputAttachmentImage</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE" optional="true">const <type>VkDescriptorImageInfo</type>*                   <name>pSampledImage</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE" optional="true">const <type>VkDescriptorImageInfo</type>*                   <name>pStorageImage</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*       <name>pUniformTexelBuffer</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*       <name>pStorageTexelBuffer</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*             <name>pUniformBuffer</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*             <name>pStorageBuffer</name></member>
+            <member selection="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"><type>VkDeviceAddress</type> <name>accelerationStructure</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorGetInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDescriptorType</type>       <name>type</name></member>
+            <member selector="type" noautovalidity="true"><type>VkDescriptorDataEXT</type>  <name>data</name></member>
+        </type>
+        <type category="struct" name="VkBufferCaptureDescriptorDataInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBuffer</type>               <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkImageCaptureDescriptorDataInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkImage</type>                <name>image</name></member>
+        </type>
+        <type category="struct" name="VkImageViewCaptureDescriptorDataInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkImageView</type>                <name>imageView</name></member>
+        </type>
+        <type category="struct" name="VkSamplerCaptureDescriptorDataInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSampler</type>              <name>sampler</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureCaptureDescriptorDataInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAccelerationStructureKHR</type>             <name>accelerationStructure</name></member>
+            <member optional="true"><type>VkAccelerationStructureNV</type>              <name>accelerationStructureNV</name></member>
+        </type>
+        <type category="struct" name="VkOpaqueCaptureDescriptorDataCreateInfoEXT" structextends="VkBufferCreateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkSamplerCreateInfo,VkAccelerationStructureCreateInfoKHR,VkAccelerationStructureCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member>const <type>void</type>*            <name>opaqueCaptureDescriptorData</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderIntegerDotProduct</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" alias="VkPhysicalDeviceShaderIntegerDotProductFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR" alias="VkPhysicalDeviceShaderIntegerDotProductProperties"/>
+        <type category="struct" name="VkPhysicalDeviceDrmPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type> <name>hasPrimary</name></member>
+            <member limittype="bitmask"><type>VkBool32</type> <name>hasRender</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>primaryMajor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>primaryMinor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>renderMajor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>renderMinor</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderBarycentric</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>              <name>triStripVertexOrderIndependentOfProvokingVertex</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>rayTracingMotionBlur</name></member>
+            <member><type>VkBool32</type>                           <name>rayTracingMotionBlurPipelineTraceRaysIndirect</name></member>
+        </type>
+        <type name="VkAccelerationStructureMotionInstanceTypeNV" category="enum"/>
+        <type category="struct" name="VkAccelerationStructureGeometryMotionTrianglesDataNV" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMotionInfoNV" structextends="VkAccelerationStructureCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>uint32_t</type>                                       <name>maxInstances</name></member>
+            <member optional="true"><type>VkAccelerationStructureMotionInfoFlagsNV</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSRTDataNV">
+            <member><type>float</type> <name>sx</name></member>
+            <member><type>float</type> <name>a</name></member>
+            <member><type>float</type> <name>b</name></member>
+            <member><type>float</type> <name>pvx</name></member>
+            <member><type>float</type> <name>sy</name></member>
+            <member><type>float</type> <name>c</name></member>
+            <member><type>float</type> <name>pvy</name></member>
+            <member><type>float</type> <name>sz</name></member>
+            <member><type>float</type> <name>pvz</name></member>
+            <member><type>float</type> <name>qx</name></member>
+            <member><type>float</type> <name>qy</name></member>
+            <member><type>float</type> <name>qz</name></member>
+            <member><type>float</type> <name>qw</name></member>
+            <member><type>float</type> <name>tx</name></member>
+            <member><type>float</type> <name>ty</name></member>
+            <member><type>float</type> <name>tz</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureSRTMotionInstanceNV">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkSRTDataNV</type>                                             <name>transformT0</name></member>
+            <member><type>VkSRTDataNV</type>                                             <name>transformT1</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMatrixMotionInstanceNV">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT0</name></member>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT1</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="union" name="VkAccelerationStructureMotionInstanceDataNV">
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"><type>VkAccelerationStructureInstanceKHR</type>            <name>staticInstance</name></member>
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"><type>VkAccelerationStructureMatrixMotionInstanceNV</type> <name>matrixMotionInstance</name></member>
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"><type>VkAccelerationStructureSRTMotionInstanceNV</type>    <name>srtMotionInstance</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMotionInstanceNV">
+            <member><type>VkAccelerationStructureMotionInstanceTypeNV</type> <name>type</name></member>
+            <member optional="true"><type>VkAccelerationStructureMotionInstanceFlagsNV</type> <name>flags</name></member>
+            <member selector="type"><type>VkAccelerationStructureMotionInstanceDataNV</type> <name>data</name></member>
+        </type>
+        <type category="basetype">typedef <type>void</type>* <name>VkRemoteAddressNV</name>;</type>
+        <type category="struct" name="VkMemoryGetRemoteAddressInfoNV">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryBufferCollectionFUCHSIA" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionImageCreateInfoFUCHSIA" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionBufferCreateInfoFUCHSIA" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionCreateInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>zx_handle_t</type>                      <name>collectionToken</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionPropertiesFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+            <member><type>uint32_t</type>                         <name>bufferCount</name></member>
+            <member><type>uint32_t</type>                         <name>createInfoIndex</name></member>
+            <member><type>uint64_t</type>                         <name>sysmemPixelFormat</name></member>
+            <member><type>VkFormatFeatureFlags</type>             <name>formatFeatures</name></member>
+            <member><type>VkSysmemColorSpaceFUCHSIA</type>        <name>sysmemColorSpaceIndex</name></member>
+            <member><type>VkComponentMapping</type>               <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>    <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>              <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                 <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                 <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkBufferConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBufferCreateInfo</type>                        <name>createInfo</name></member>
+            <member optional="true"><type>VkFormatFeatureFlags</type>      <name>requiredFormatFeatures</name></member>
+            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>  <name>bufferCollectionConstraints</name></member>
+        </type>
+        <type category="struct" name="VkSysmemColorSpaceFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>colorSpace</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkImageCreateInfo</type>                                      <name>imageCreateInfo</name></member>
+            <member><type>VkFormatFeatureFlags</type>                                   <name>requiredFormatFeatures</name></member>
+            <member optional="true"><type>VkImageFormatConstraintsFlagsFUCHSIA</type>   <name>flags</name></member>
+            <member optional="true"><type>uint64_t</type>                               <name>sysmemPixelFormat</name></member>
+            <member><type>uint32_t</type>                                               <name>colorSpaceCount</name></member>
+            <member len="colorSpaceCount">const <type>VkSysmemColorSpaceFUCHSIA</type>* <name>pColorSpaces</name></member>
+        </type>
+        <type category="struct" name="VkImageConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                         <name>formatConstraintsCount</name></member>
+            <member len="formatConstraintsCount">const <type>VkImageFormatConstraintsInfoFUCHSIA</type>* <name>pFormatConstraints</name></member>
+            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>                         <name>bufferCollectionConstraints</name></member>
+            <member optional="true"><type>VkImageConstraintsInfoFlagsFUCHSIA</type>               <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCount</name></member>
+            <member><type>uint32_t</type>                        <name>maxBufferCount</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForCamping</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForDedicatedSlack</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForSharedSlack</name></member>
+        </type>
+        <type category="handle" parent="VkDevice" objtypeenum="VK_OBJECT_TYPE_CUDA_MODULE_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCudaModuleNV</name>)</type>
+        <type category="handle" parent="VkDevice" objtypeenum="VK_OBJECT_TYPE_CUDA_FUNCTION_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCudaFunctionNV</name>)</type>
+        <type category="struct" name="VkCudaModuleCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>size_t</type>                 <name>dataSize</name></member>
+            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkCudaFunctionCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkCudaModuleNV</type>         <name>module</name></member>
+            <member len="null-terminated">const <type>char</type>*            <name>pName</name></member>
+        </type>
+        <type category="struct" name="VkCudaLaunchInfoNV">
+            <member values="VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkCudaFunctionNV</type>       <name>function</name></member>
+            <member><type>uint32_t</type>               <name>gridDimX</name></member>
+            <member><type>uint32_t</type>               <name>gridDimY</name></member>
+            <member><type>uint32_t</type>               <name>gridDimZ</name></member>
+            <member><type>uint32_t</type>               <name>blockDimX</name></member>
+            <member><type>uint32_t</type>               <name>blockDimY</name></member>
+            <member><type>uint32_t</type>               <name>blockDimZ</name></member>
+            <member><type>uint32_t</type>               <name>sharedMemBytes</name></member>
+            <member optional="true"><type>size_t</type>                 <name>paramCount</name></member>
+            <member optional="true" len="paramCount">const <type>void</type>* const *    <name>pParams</name></member>
+            <member optional="true"><type>size_t</type>                 <name>extraCount</name></member>
+            <member optional="true" len="extraCount">const <type>void</type>* const *    <name>pExtras</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>formatRgba10x6WithoutYCbCrSampler</name></member>
+        </type>
+        <type category="struct" name="VkFormatProperties3" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>linearTilingFeatures</name></member>
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>optimalTilingFeatures</name></member>
+            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>bufferFeatures</name></member>
+        </type>
+        <type category="struct" name="VkFormatProperties3KHR" alias="VkFormatProperties3"/>
+        <type category="struct" name="VkDrmFormatModifierPropertiesList2EXT" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member optional="true" len="drmFormatModifierCount"><type>VkDrmFormatModifierProperties2EXT</type>* <name>pDrmFormatModifierProperties</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierProperties2EXT" returnedonly="true">
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member><type>VkFormatFeatureFlags2</type> <name>drmFormatModifierTilingFeatures</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferFormatProperties2ANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+            <member><type>VkFormatFeatureFlags2</type>              <name>formatFeatures</name></member>
+            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRenderingCreateInfo" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkFormat</type>*           <name>pColorAttachmentFormats</name></member>
+            <member noautovalidity="true"><type>VkFormat</type>                                             <name>depthAttachmentFormat</name></member>
+            <member noautovalidity="true"><type>VkFormat</type>                                             <name>stencilAttachmentFormat</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRenderingCreateInfoKHR" alias="VkPipelineRenderingCreateInfo"/>
+        <type category="struct" name="VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_INFO"><type>VkStructureType</type>                  <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkRenderingFlags</type>                                           <name>flags</name></member>
+            <member><type>VkRect2D</type>                                                                   <name>renderArea</name></member>
+            <member><type>uint32_t</type>                                                                   <name>layerCount</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkRenderingAttachmentInfo</type>*                <name>pColorAttachments</name></member>
+            <member optional="true">const <type>VkRenderingAttachmentInfo</type>*                           <name>pDepthAttachment</name></member>
+            <member optional="true">const <type>VkRenderingAttachmentInfo</type>*                           <name>pStencilAttachment</name></member>
+        </type>
+        <type category="struct" name="VkRenderingInfoKHR" alias="VkRenderingInfo"/>
+        <type category="struct" name="VkRenderingAttachmentInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"><type>VkStructureType</type>       <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+            <member optional="true"><type>VkResolveModeFlagBits</type>                                      <name>resolveMode</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>resolveImageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>resolveImageLayout</name></member>
+            <member><type>VkAttachmentLoadOp</type>                                                         <name>loadOp</name></member>
+            <member><type>VkAttachmentStoreOp</type>                                                        <name>storeOp</name></member>
+            <member><type>VkClearValue</type>                                                               <name>clearValue</name></member>
+        </type>
+        <type category="struct" name="VkRenderingAttachmentInfoKHR" alias="VkRenderingAttachmentInfo"/>
+        <type category="struct" name="VkRenderingFragmentShadingRateAttachmentInfoKHR" structextends="VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member  optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+            <member><type>VkExtent2D</type>                                                                 <name>shadingRateAttachmentTexelSize</name></member>
+        </type>
+        <type category="struct" name="VkRenderingFragmentDensityMapAttachmentInfoEXT" structextends="VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>VkImageView</type>                                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDynamicRenderingFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                   <name>dynamicRendering</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDynamicRenderingFeaturesKHR" alias="VkPhysicalDeviceDynamicRenderingFeatures"/>
+        <type category="struct" name="VkCommandBufferInheritanceRenderingInfo" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkRenderingFlags</type>                                           <name>flags</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member api="vulkan" optional="true"><type>uint32_t</type>                                      <name>colorAttachmentCount</name></member>
+            <member api="vulkansc"><type>uint32_t</type>                                                    <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkFormat</type>*                                 <name>pColorAttachmentFormats</name></member>
+            <member><type>VkFormat</type>                                                                   <name>depthAttachmentFormat</name></member>
+            <member><type>VkFormat</type>                                                                   <name>stencilAttachmentFormat</name></member>
+            <member optional="true"><type>VkSampleCountFlagBits</type>                                      <name>rasterizationSamples</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceRenderingInfoKHR" alias="VkCommandBufferInheritanceRenderingInfo"/>
+        <type category="struct" name="VkAttachmentSampleCountInfoAMD" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkSampleCountFlagBits</type>* <name>pColorAttachmentSamples</name></member>
+            <member noautovalidity="true" optional="true"><type>VkSampleCountFlagBits</type>                <name>depthStencilAttachmentSamples</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentSampleCountInfoNV" alias="VkAttachmentSampleCountInfoAMD"/>
+        <type category="struct" name="VkMultiviewPerViewAttributesInfoNVX" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo,VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>perViewAttributes</name></member>
+            <member><type>VkBool32</type>                               <name>perViewAttributesPositionXOnly</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageViewMinLodFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>minLod</name></member>
+        </type>
+        <type category="struct" name="VkImageViewMinLodCreateInfoEXT" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>float</type>                       <name>minLod</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rasterizationOrderColorAttachmentAccess</name></member>
+            <member><type>VkBool32</type>                         <name>rasterizationOrderDepthAttachmentAccess</name></member>
+            <member><type>VkBool32</type>                         <name>rasterizationOrderStencilAttachmentAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM" alias="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"/>
+        <type category="struct" name="VkPhysicalDeviceLinearColorAttachmentFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>linearColorAttachment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>graphicsPipelineLibrary</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>graphicsPipelineLibraryFastLinking</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                     <name>graphicsPipelineLibraryIndependentInterpolationDecoration</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsPipelineLibraryCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
+            <member><type>VkGraphicsPipelineLibraryFlagsEXT</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                           <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                              <name>descriptorSetHostMapping</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetBindingReferenceVALVE">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
+            <member><type>VkDescriptorSetLayout</type>                                                             <name>descriptorSetLayout</name></member>
+            <member><type>uint32_t</type>                                                                          <name>binding</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutHostMappingInfoVALVE">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                                                    <name>pNext</name></member>
+            <member><type>size_t</type>                                                                                   <name>descriptorOffset</name></member>
+            <member><type>uint32_t</type>                                                                                 <name>descriptorSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceNestedCommandBufferFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>nestedCommandBuffer</name></member>
+            <member><type>VkBool32</type>                                        <name>nestedCommandBufferRendering</name></member>
+            <member><type>VkBool32</type>                                        <name>nestedCommandBufferSimultaneousUse</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceNestedCommandBufferPropertiesEXT" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                        <name>maxCommandBufferNestingLevel</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                         <name>shaderModuleIdentifier</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="noauto"><type>uint8_t</type> <name>shaderModuleIdentifierAlgorithmUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageModuleIdentifierCreateInfoEXT" structextends="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>            <name>identifierSize</name></member>
+            <member len="identifierSize">const <type>uint8_t</type>* <name>pIdentifier</name></member>
+        </type>
+        <type category="struct" name="VkShaderModuleIdentifierEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>identifierSize</name></member>
+            <member><type>uint8_t</type>                        <name>identifier</name>[<enum>VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT</enum>]</member>
+        </type>
+        <type category="struct" name="VkImageCompressionControlEXT" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkImageCompressionFlagsEXT</type>   <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>             <name>compressionControlPlaneCount</name></member>
+            <member noautovalidity="true" len="compressionControlPlaneCount"><type>VkImageCompressionFixedRateFlagsEXT</type>* <name>pFixedRateFlags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageCompressionControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                             <name>imageCompressionControl</name></member>
+        </type>
+        <type category="struct" name="VkImageCompressionPropertiesEXT" structextends="VkImageFormatProperties2,VkSurfaceFormat2KHR,VkSubresourceLayout2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                <name>pNext</name></member>
+            <member><type>VkImageCompressionFlagsEXT</type>           <name>imageCompressionFlags</name></member>
+            <member><type>VkImageCompressionFixedRateFlagsEXT</type>  <name>imageCompressionFixedRateFlags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                             <name>imageCompressionControlSwapchain</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresource2KHR">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkImageSubresource</type>     <name>imageSubresource</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresource2EXT" alias="VkImageSubresource2KHR"/>
+        <type category="struct" name="VkSubresourceLayout2KHR"  returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkSubresourceLayout</type>    <name>subresourceLayout</name></member>
+        </type>
+        <type category="struct" name="VkSubresourceLayout2EXT" alias="VkSubresourceLayout2KHR"/>
+        <type category="struct" name="VkRenderPassCreationControlEXT" structextends="VkRenderPassCreateInfo2,VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                 <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                    <name>disallowMerging</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreationFeedbackInfoEXT" returnedonly="true">
+            <member><type>uint32_t</type>                                                                          <name>postMergeSubpassCount</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreationFeedbackCreateInfoEXT" structextends="VkRenderPassCreateInfo2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                              <name>pNext</name></member>
+            <member><type>VkRenderPassCreationFeedbackInfoEXT</type>*                                                     <name>pRenderPassFeedback</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassSubpassFeedbackInfoEXT" returnedonly="true">
+            <member><type>VkSubpassMergeStatusEXT</type>                                                          <name>subpassMergeStatus</name></member>
+            <member><type>char</type>                                                                             <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>uint32_t</type>                                                                         <name>postMergeIndex</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassSubpassFeedbackCreateInfoEXT" structextends="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type>     <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                 <name>pNext</name></member>
+            <member><type>VkRenderPassSubpassFeedbackInfoEXT</type>*                                                         <name>pSubpassFeedback</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                       <name>subpassMergeFeedback</name></member>
+        </type>
+        <type category="struct" name="VkMicromapBuildInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member><type>VkMicromapTypeEXT</type>                                     <name>type</name></member>
+            <member optional="true"><type>VkBuildMicromapFlagsEXT</type>               <name>flags</name></member>
+            <member noautovalidity="true"><type>VkBuildMicromapModeEXT</type>          <name>mode</name></member>
+            <member optional="true" noautovalidity="true"><type>VkMicromapEXT</type>                   <name>dstMicromap</name></member>
+            <member optional="true"><type>uint32_t</type>                                           <name>usageCountsCount</name></member>
+            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*    <name>pUsageCounts</name></member>
+            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const*   <name>ppUsageCounts</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                               <name>data</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                                    <name>scratchData</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                               <name>triangleArray</name></member>
+            <member><type>VkDeviceSize</type>                                                                      <name>triangleArrayStride</name></member>
+        </type>
+        <type category="struct" name="VkMicromapCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member optional="true"><type>VkMicromapCreateFlagsEXT</type>   <name>createFlags</name></member>
+            <member><type>VkBuffer</type>                                                <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                                            <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                                            <name>size</name></member>
+            <member><type>VkMicromapTypeEXT</type>                          <name>type</name></member>
+            <member optional="true"><type>VkDeviceAddress</type>                         <name>deviceAddress</name></member>
+        </type>
+        <type category="struct" name="VkMicromapVersionInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member len="latexmath:[2 \times \mathtt{VK\_UUID\_SIZE}]" altlen="2*VK_UUID_SIZE">const <type>uint8_t</type>*                    <name>pVersionData</name></member>
+        </type>
+        <type category="struct" name="VkCopyMicromapInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkMicromapEXT</type>                             <name>src</name></member>
+            <member><type>VkMicromapEXT</type>                             <name>dst</name></member>
+            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyMicromapToMemoryInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkMicromapEXT</type>                             <name>src</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                               <name>dst</name></member>
+            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryToMicromapInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                          <name>src</name></member>
+            <member><type>VkMicromapEXT</type>                             <name>dst</name></member>
+            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkMicromapBuildSizesInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>micromapSize</name></member>
+            <member><type>VkDeviceSize</type>                       <name>buildScratchSize</name></member>
+            <member><type>VkBool32</type>                           <name>discardable</name></member>
+        </type>
+        <type category="struct" name="VkMicromapUsageEXT">
+            <member><type>uint32_t</type>                                               <name>count</name></member>
+            <member><type>uint32_t</type>                                               <name>subdivisionLevel</name></member>
+            <member><type>uint32_t</type>                                               <name>format</name><comment>Interpretation depends on parent type</comment></member>
+        </type>
+        <type category="struct" name="VkMicromapTriangleEXT">
+            <member><type>uint32_t</type>                                               <name>dataOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>uint16_t</type>                                               <name>subdivisionLevel</name></member>
+            <member><type>uint16_t</type>                                               <name>format</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceOpacityMicromapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>micromap</name></member>
+            <member><type>VkBool32</type>                         <name>micromapCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>micromapHostCommands</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceOpacityMicromapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxOpacity2StateSubdivisionLevel</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxOpacity4StateSubdivisionLevel</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureTrianglesOpacityMicromapEXT" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
+            <member><type>VkIndexType</type>                                            <name>indexType</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>indexBuffer</name></member>
+            <member><type>VkDeviceSize</type>                                           <name>indexStride</name></member>
+            <member><type>uint32_t</type>                                               <name>baseTriangle</name></member>
+            <member optional="true"><type>uint32_t</type>                               <name>usageCountsCount</name></member>
+            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*  <name>pUsageCounts</name></member>
+            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const* <name>ppUsageCounts</name></member>
+            <member optional="true"><type>VkMicromapEXT</type>                          <name>micromap</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDisplacementMicromapFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>displacementMicromap</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDisplacementMicromapPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDisplacementMicromapSubdivisionLevel</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureTrianglesDisplacementMicromapNV" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
+
+            <member><type>VkFormat</type>                                               <name>displacementBiasAndScaleFormat</name></member>
+            <member><type>VkFormat</type>                                               <name>displacementVectorFormat</name></member>
+
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacementBiasAndScaleBuffer</name></member>
+            <member><type>VkDeviceSize</type>                                           <name>displacementBiasAndScaleStride</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacementVectorBuffer</name></member>
+            <member><type>VkDeviceSize</type>                                           <name>displacementVectorStride</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacedMicromapPrimitiveFlags</name></member>
+            <member><type>VkDeviceSize</type>                                           <name>displacedMicromapPrimitiveFlagsStride</name></member>
+            <member><type>VkIndexType</type>                                            <name>indexType</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>indexBuffer</name></member>
+            <member><type>VkDeviceSize</type>                                           <name>indexStride</name></member>
+
+            <member><type>uint32_t</type>                                               <name>baseTriangle</name></member>
+
+            <member optional="true"><type>uint32_t</type>                                                          <name>usageCountsCount</name></member>
+            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*                  <name>pUsageCounts</name></member>
+            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const*   <name>ppUsageCounts</name></member>
+
+            <member optional="true"><type>VkMicromapEXT</type>                          <name>micromap</name></member>
+        </type>
+        <type category="struct" name="VkPipelinePropertiesIdentifierEXT">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>uint8_t</type>                            <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelinePropertiesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>pipelinePropertiesIdentifier</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>shaderEarlyAndLateFragmentTests</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryAcquireUnmodifiedEXT" structextends="VkBufferMemoryBarrier,VkBufferMemoryBarrier2,VkImageMemoryBarrier,VkImageMemoryBarrier2">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>acquireUnmodifiedMemory</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalObjectCreateInfoEXT" structextends="VkInstanceCreateInfo,VkMemoryAllocateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferViewCreateInfo,VkSemaphoreCreateInfo,VkEventCreateInfo" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkExportMetalObjectTypeFlagBitsEXT</type>  <name>exportObjectType</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalObjectsInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalDeviceInfoEXT" structextends="VkExportMetalObjectsInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>MTLDevice_id</type>                               <name>mtlDevice</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalCommandQueueInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>VkQueue</type>                                    <name>queue</name></member>
+            <member><type>MTLCommandQueue_id</type>                         <name>mtlCommandQueue</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalBufferInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                             <name>memory</name></member>
+            <member><type>MTLBuffer_id</type>                               <name>mtlBuffer</name></member>
+        </type>
+        <type category="struct" name="VkImportMetalBufferInfoEXT" structextends="VkMemoryAllocateInfo" allowduplicate="false">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>MTLBuffer_id</type>                               <name>mtlBuffer</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalTextureInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkImage</type>                    <name>image</name></member>
+            <member optional="true"><type>VkImageView</type>                <name>imageView</name></member>
+            <member optional="true"><type>VkBufferView</type>               <name>bufferView</name></member>
+            <member><type>VkImageAspectFlagBits</type>                      <name>plane</name></member>
+            <member><type>MTLTexture_id</type>                              <name>mtlTexture</name></member>
+        </type>
+        <type category="struct" name="VkImportMetalTextureInfoEXT" structextends="VkImageCreateInfo" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>VkImageAspectFlagBits</type>                      <name>plane</name></member>
+            <member><type>MTLTexture_id</type>                              <name>mtlTexture</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalIOSurfaceInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>VkImage</type>                                    <name>image</name></member>
+            <member><type>IOSurfaceRef</type>                               <name>ioSurface</name></member>
+        </type>
+        <type category="struct" name="VkImportMetalIOSurfaceInfoEXT" structextends="VkImageCreateInfo" allowduplicate="false">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>IOSurfaceRef</type>               <name>ioSurface</name></member>
+        </type>
+        <type category="struct" name="VkExportMetalSharedEventInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkSemaphore</type>                <name>semaphore</name></member>
+            <member optional="true"><type>VkEvent</type>                    <name>event</name></member>
+            <member><type>MTLSharedEvent_id</type>                          <name>mtlSharedEvent</name></member>
+        </type>
+        <type category="struct" name="VkImportMetalSharedEventInfoEXT" structextends="VkSemaphoreCreateInfo,VkEventCreateInfo" allowduplicate="false">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member><type>MTLSharedEvent_id</type>                          <name>mtlSharedEvent</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                   <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                      <name>nonSeamlessCubeMap</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineRobustnessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                       <name>pipelineRobustness</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRobustnessCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkPipelineShaderStageCreateInfo,VkRayTracingPipelineCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>storageBuffers</name></member>
+            <member><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>uniformBuffers</name></member>
+            <member><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>vertexInputs</name></member>
+            <member><type>VkPipelineRobustnessImageBehaviorEXT</type>    <name>images</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineRobustnessPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="exact"><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>defaultRobustnessStorageBuffers</name></member>
+            <member limittype="exact"><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>defaultRobustnessUniformBuffers</name></member>
+            <member limittype="exact"><type>VkPipelineRobustnessBufferBehaviorEXT</type>   <name>defaultRobustnessVertexInputs</name></member>
+            <member limittype="exact"><type>VkPipelineRobustnessImageBehaviorEXT</type>    <name>defaultRobustnessImages</name></member>
+        </type>
+        <type category="struct" name="VkImageViewSampleWeightCreateInfoQCOM" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
+            <member><type>VkOffset2D</type>                        <name>filterCenter</name></member>
+            <member><type>VkExtent2D</type>                        <name>filterSize</name></member>
+            <member><type>uint32_t</type>                          <name>numPhases</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageProcessingFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>textureSampleWeighted</name></member>
+            <member><type>VkBool32</type>                           <name>textureBoxFilter</name></member>
+            <member><type>VkBool32</type>                           <name>textureBlockMatch</name></member>
+         </type>
+        <type category="struct" name="VkPhysicalDeviceImageProcessingPropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max" optional="true"><type>uint32_t</type>         <name>maxWeightFilterPhases</name></member>
+            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxWeightFilterDimension</name></member>
+            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxBlockMatchRegion</name></member>
+            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxBoxFilterBlockSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTilePropertiesFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>tileProperties</name></member>
+        </type>
+        <type category="struct" name="VkTilePropertiesQCOM">
+            <member values="VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkExtent3D</type>                       <name>tileSize</name></member>
+            <member><type>VkExtent2D</type>                       <name>apronSize</name></member>
+            <member><type>VkOffset2D</type>                       <name>origin</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAmigoProfilingFeaturesSEC" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>amigoProfiling</name></member>
+        </type>
+        <type category="struct" name="VkAmigoProfilingSubmitInfoSEC" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>uint64_t</type>                         <name>firstDrawTimestamp</name></member>
+            <member><type>uint64_t</type>                         <name>swapBufferTimestamp</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>attachmentFeedbackLoopLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthClampZeroOneFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>depthClampZeroOne</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAddressBindingReportFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>reportAddressBinding</name></member>
+        </type>
+        <type category="struct" name="VkDeviceAddressBindingCallbackDataEXT" structextends="VkDebugUtilsMessengerCallbackDataEXT">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceAddressBindingFlagsEXT</type>     <name>flags</name></member>
+            <member><type>VkDeviceAddress</type>                    <name>baseAddress</name></member>
+            <member><type>VkDeviceSize</type>                       <name>size</name></member>
+            <member><type>VkDeviceAddressBindingTypeEXT</type>      <name>bindingType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceOpticalFlowFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>opticalFlow</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceOpticalFlowPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkOpticalFlowGridSizeFlagsNV</type> <name>supportedOutputGridSizes</name></member>
+            <member limittype="bitmask"><type>VkOpticalFlowGridSizeFlagsNV</type> <name>supportedHintGridSizes</name></member>
+            <member limittype="noauto"><type>VkBool32</type> <name>hintSupported</name></member>
+            <member limittype="noauto"><type>VkBool32</type> <name>costSupported</name></member>
+            <member limittype="noauto"><type>VkBool32</type> <name>bidirectionalFlowSupported</name></member>
+            <member limittype="noauto"><type>VkBool32</type> <name>globalFlowSupported</name></member>
+            <member limittype="noauto"><type>uint32_t</type>  <name>minWidth</name></member>
+            <member limittype="noauto"><type>uint32_t</type>  <name>minHeight</name></member>
+            <member limittype="noauto"><type>uint32_t</type>  <name>maxWidth</name></member>
+            <member limittype="noauto"><type>uint32_t</type>  <name>maxHeight</name></member>
+            <member limittype="noauto"><type>uint32_t</type>  <name>maxNumRegionsOfInterest</name></member>
+        </type>
+        <type category="struct" name="VkOpticalFlowImageFormatInfoNV" structextends="VkPhysicalDeviceImageFormatInfo2,VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkOpticalFlowUsageFlagsNV</type> <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkOpticalFlowImageFormatPropertiesNV" returnedonly="true" >
+            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkFormat</type> <name>format</name></member>
+        </type>
+        <type category="struct" name="VkOpticalFlowSessionCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                              <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                           <name>width</name></member>
+            <member><type>uint32_t</type>                                                           <name>height</name></member>
+            <member><type>VkFormat</type>                                                           <name>imageFormat</name></member>
+            <member><type>VkFormat</type>                                                           <name>flowVectorFormat</name></member>
+            <member optional="true"><type>VkFormat</type>                                           <name>costFormat</name></member>
+            <member><type>VkOpticalFlowGridSizeFlagsNV</type>                                       <name>outputGridSize</name></member>
+            <member optional="true"><type>VkOpticalFlowGridSizeFlagsNV</type>                       <name>hintGridSize</name></member>
+            <member optional="true"><type>VkOpticalFlowPerformanceLevelNV</type>                    <name>performanceLevel</name></member>
+            <member optional="true"><type>VkOpticalFlowSessionCreateFlagsNV</type>                  <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkOpticalFlowSessionCreatePrivateDataInfoNV" structextends="VkOpticalFlowSessionCreateInfoNV"><comment>NV internal use only</comment>
+            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                              <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                           <name>id</name></member>
+            <member><type>uint32_t</type>                                                           <name>size</name></member>
+            <member>const <type>void</type>*                                                        <name>pPrivateData</name></member>
+        </type>
+        <type category="struct" name="VkOpticalFlowExecuteInfoNV">
+            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>VkOpticalFlowExecuteFlagsNV</type>        <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                           <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkRect2D</type>*                  <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFaultFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>deviceFault</name></member>
+            <member><type>VkBool32</type>                            <name>deviceFaultVendorBinary</name></member>
+        </type>
+        <type category="struct" name="VkDeviceFaultAddressInfoEXT">
+            <member><type>VkDeviceFaultAddressTypeEXT</type>         <name>addressType</name></member>
+            <member><type>VkDeviceAddress</type>                     <name>reportedAddress</name></member>
+            <member><type>VkDeviceSize</type>                        <name>addressPrecision</name></member>
+        </type>
+        <type category="struct" name="VkDeviceFaultVendorInfoEXT">
+            <member noautovalidity="true"><type>char</type>          <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the fault</comment></member>
+            <member><type>uint64_t</type>                            <name>vendorFaultCode</name></member>
+            <member><type>uint64_t</type>                            <name>vendorFaultData</name></member>
+        </type>
+        <type category="struct" name="VkDeviceFaultCountsEXT">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                            <name>addressInfoCount</name></member>
+            <member optional="true"><type>uint32_t</type>                            <name>vendorInfoCount</name></member>
+            <member optional="true"><type>VkDeviceSize</type>                        <name>vendorBinarySize</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkDeviceFaultInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member noautovalidity="true"><type>char</type>          <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the fault</comment></member>
+            <member optional="true"><type>VkDeviceFaultAddressInfoEXT</type>* <name>pAddressInfos</name></member>
+            <member optional="true"><type>VkDeviceFaultVendorInfoEXT</type>*  <name>pVendorInfos</name></member>
+            <member optional="true"><type>void</type>*                        <name>pVendorBinaryData</name></member>
+        </type>
+        <type category="struct" name="VkDeviceFaultVendorBinaryHeaderVersionOneEXT">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>uint32_t</type>               <name>headerSize</name></member>
+            <member><type>VkDeviceFaultVendorBinaryHeaderVersionEXT</type> <name>headerVersion</name></member>
+            <member><type>uint32_t</type>               <name>vendorID</name></member>
+            <member><type>uint32_t</type>               <name>deviceID</name></member>
+            <member><type>uint32_t</type>               <name>driverVersion</name></member>
+            <member><type>uint8_t</type>                <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member><type>uint32_t</type>               <name>applicationNameOffset</name></member>
+            <member><type>uint32_t</type>               <name>applicationVersion</name></member>
+            <member><type>uint32_t</type>               <name>engineNameOffset</name></member>
+            <member><type>uint32_t</type>               <name>engineVersion</name></member>
+            <member><type>uint32_t</type>               <name>apiVersion</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                               <name>pipelineLibraryGroupHandles</name></member>
+        </type>
+        <type category="struct" name="VkDepthBiasInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>float</type>                              <name>depthBiasConstantFactor</name></member>
+            <member><type>float</type>                              <name>depthBiasClamp</name></member>
+            <member><type>float</type>                              <name>depthBiasSlopeFactor</name></member>
+        </type>
+        <type category="struct" name="VkDepthBiasRepresentationInfoEXT" structextends="VkDepthBiasInfoEXT,VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDepthBiasRepresentationEXT</type>       <name>depthBiasRepresentation</name></member>
+            <member><type>VkBool32</type>                           <name>depthBiasExact</name></member>
+        </type>
+        <type category="struct" name="VkDecompressMemoryRegionNV">
+            <member><type>VkDeviceAddress</type>   <name>srcAddress</name></member>
+            <member><type>VkDeviceAddress</type>   <name>dstAddress</name></member>
+            <member><type>VkDeviceSize</type>      <name>compressedSize</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>      <name>decompressedSize</name><comment>Specified in bytes</comment></member>
+            <member><type>VkMemoryDecompressionMethodFlagsNV</type> <name>decompressionMethod</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="bitmask"><type>uint64_t</type>                   <name>shaderCoreMask</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderCoreCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderWarpsPerCore</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                 <name>shaderCoreBuiltins</name></member>
+        </type>
+        <type category="struct" name="VkFrameBoundaryEXT" structextends="VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member optional="true"><type>VkFrameBoundaryFlagsEXT</type>            <name>flags</name></member>
+            <member><type>uint64_t</type>                                           <name>frameID</name></member>
+            <member optional="true"><type>uint32_t</type>                           <name>imageCount</name></member>
+            <member optional="true" len="imageCount">const <type>VkImage</type>*    <name>pImages</name></member>
+            <member optional="true"><type>uint32_t</type>                           <name>bufferCount</name></member>
+            <member optional="true" len="bufferCount">const <type>VkBuffer</type>*  <name>pBuffers</name></member>
+            <member optional="true"><type>uint64_t</type>                           <name>tagName</name></member>
+            <member optional="true"><type>size_t</type>                             <name>tagSize</name></member>
+            <member optional="true" len="tagSize">const <type>void</type>*          <name>pTag</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFrameBoundaryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                 <name>frameBoundary</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                 <name>dynamicRenderingUnusedAttachments</name></member>
+        </type>
+        <type category="struct" name="VkSurfacePresentModeEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkPresentModeKHR</type>                    <name>presentMode</name></member>
+        </type>
+        <type category="struct" name="VkSurfacePresentScalingCapabilitiesEXT" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                    <name>pNext</name></member>
+            <member optional="true"><type>VkPresentScalingFlagsEXT</type> <name>supportedPresentScaling</name></member>
+            <member optional="true"><type>VkPresentGravityFlagsEXT</type> <name>supportedPresentGravityX</name></member>
+            <member optional="true"><type>VkPresentGravityFlagsEXT</type> <name>supportedPresentGravityY</name></member>
+            <member optional="true"><type>VkExtent2D</type>               <name>minScaledImageExtent</name><comment>Supported minimum image width and height for the surface when scaling is used</comment></member>
+            <member optional="true"><type>VkExtent2D</type>               <name>maxScaledImageExtent</name><comment>Supported maximum image width and height for the surface when scaling is used</comment></member>
+        </type>
+        <type category="struct" name="VkSurfacePresentModeCompatibilityEXT" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>presentModeCount</name></member>
+            <member optional="true" len="presentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name><comment>Output list of present modes compatible with the one specified in VkSurfacePresentModeEXT</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>swapchainMaintenance1</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainPresentFenceInfoEXT" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount">const <type>VkFence</type>* <name>pFences</name><comment>Fence to signal for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkSwapchainPresentModesCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>presentModeCount</name></member><comment>Length of the pPresentModes array</comment>
+            <member len="presentModeCount">const <type>VkPresentModeKHR</type>* <name>pPresentModes</name></member><comment>Presentation modes which will be usable with this swapchain</comment>
+        </type>
+        <type category="struct" name="VkSwapchainPresentModeInfoEXT" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount">const <type>VkPresentModeKHR</type>* <name>pPresentModes</name><comment>Presentation mode for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkSwapchainPresentScalingCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member optional="true"><type>VkPresentScalingFlagsEXT</type>    <name>scalingBehavior</name></member>
+            <member optional="true"><type>VkPresentGravityFlagsEXT</type>    <name>presentGravityX</name></member>
+            <member optional="true"><type>VkPresentGravityFlagsEXT</type>    <name>presentGravityY</name></member>
+        </type>
+        <type category="struct" name="VkReleaseSwapchainImagesInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member externsync="true"><type>VkSwapchainKHR</type>            <name>swapchain</name><comment>Swapchain for which images are being released</comment></member>
+            <member><type>uint32_t</type>                                    <name>imageIndexCount</name><comment>Number of indices to release</comment></member>
+            <member len="imageIndexCount">const <type>uint32_t</type>*       <name>pImageIndices</name><comment>Indices of which presentable images to release</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthBiasControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>depthBiasControl</name></member>
+            <member><type>VkBool32</type>                           <name>leastRepresentableValueForceUnormRepresentation</name></member>
+            <member><type>VkBool32</type>                           <name>floatRepresentation</name></member>
+            <member><type>VkBool32</type>                           <name>depthBiasExact</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                                         <name>rayTracingInvocationReorder</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="noauto"><type>VkRayTracingInvocationReorderModeNV</type>                                    <name>rayTracingInvocationReorderReorderingHint</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*  <name>pNext</name></member>
+            <member><type>VkBool32</type>                                     <name>extendedSparseAddressSpace</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                        <name>pNext</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                 <name>extendedSparseAddressSpaceSize</name><comment>Total address space available for extended sparse allocations (bytes)</comment></member>
+            <member limittype="bitmask"><type>VkImageUsageFlags</type>        <name>extendedSparseImageUsageFlags</name><comment>Bitfield of which image usages are supported for extended sparse allocations</comment></member>
+            <member limittype="bitmask"><type>VkBufferUsageFlags</type>       <name>extendedSparseBufferUsageFlags</name><comment>Bitfield of which buffer usages are supported for extended sparse allocations</comment></member>
+        </type>
+        <type category="struct" name="VkDirectDriverLoadingInfoLUNARG">
+            <member values="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                  <name>pNext</name></member>
+            <member><type>VkDirectDriverLoadingFlagsLUNARG</type>                                             <name>flags</name></member>
+            <member noautovalidity="true"><type>PFN_vkGetInstanceProcAddrLUNARG</type>                        <name>pfnGetInstanceProcAddr</name></member>
+        </type>
+        <type category="struct" name="VkDirectDriverLoadingListLUNARG" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                 <name>pNext</name></member>
+            <member><type>VkDirectDriverLoadingModeLUNARG</type>                             <name>mode</name></member>
+            <member><type>uint32_t</type>                                                    <name>driverCount</name></member>
+            <member len="driverCount">const <type>VkDirectDriverLoadingInfoLUNARG</type>*    <name>pDrivers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>multiviewPerViewViewports</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>rayTracingPositionFetch</name></member>
+        </type>
+        <type category="struct" name="VkDeviceImageSubresourceInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                              <name>pNext</name></member>
+            <member>const <type>VkImageCreateInfo</type>*                                                 <name>pCreateInfo</name></member>
+            <member>const <type>VkImageSubresource2KHR</type>*                                            <name>pSubresource</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="exact"><type>uint32_t</type>         <name>pixelRate</name></member>
+            <member limittype="exact"><type>uint32_t</type>         <name>texelRate</name></member>
+            <member limittype="exact"><type>uint32_t</type>         <name>fmaRate</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>multiviewPerViewRenderAreas</name></member>
+        </type>
+        <type category="struct" name="VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM" structextends="VkRenderPassBeginInfo,VkRenderingInfo">
+            <member values="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>perViewRenderAreaCount</name></member>
+            <member len="perViewRenderAreaCount">const <type>VkRect2D</type>*  <name>pPerViewRenderAreas</name></member>
+        </type>
+        <type category="struct" name="VkQueryLowLatencySupportNV" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>void</type>*                                       <name>pQueriedLowLatencyData</name></member>
+        </type>
+        <type category="struct" name="VkMemoryMapInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></member>
+            <member externsync="true"><type>VkDeviceMemory</type> <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
+            <member><type>VkDeviceSize</type>                     <name>size</name></member>
+        </type>
+        <type category="struct" name="VkMemoryUnmapInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkMemoryUnmapFlagsKHR</type>  <name>flags</name></member>
+            <member externsync="true"><type>VkDeviceMemory</type>       <name>memory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderObjectFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                           <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                              <name>shaderObject</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderObjectPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                             <name>pNext</name></member>
+            <member limittype="noauto"><type>uint8_t</type>                                                              <name>shaderBinaryUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint32_t</type>                                                             <name>shaderBinaryVersion</name></member>
+        </type>
+        <type category="struct" name="VkShaderCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"><type>VkStructureType</type>       <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                             <name>pNext</name></member>
+            <member optional="true"><type>VkShaderCreateFlagsEXT</type>                                  <name>flags</name></member>
+            <member><type>VkShaderStageFlagBits</type>                                                   <name>stage</name></member>
+            <member optional="true"><type>VkShaderStageFlags</type>                                      <name>nextStage</name></member>
+            <member><type>VkShaderCodeTypeEXT</type>                                                     <name>codeType</name></member>
+            <member><type>size_t</type>                                                                  <name>codeSize</name></member>
+            <member len="codeSize">const <type>void</type>*                                              <name>pCode</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*                       <name>pName</name></member>
+            <member optional="true"><type>uint32_t</type>                                                <name>setLayoutCount</name></member>
+            <member optional="true" len="setLayoutCount">const <type>VkDescriptorSetLayout</type>*       <name>pSetLayouts</name></member>
+            <member optional="true"><type>uint32_t</type>                                                <name>pushConstantRangeCount</name></member>
+            <member optional="true" len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name></member>
+            <member optional="true">const <type>VkSpecializationInfo</type>*                             <name>pSpecializationInfo</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderTileImageFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>shaderTileImageColorReadAccess</name></member>
+            <member><type>VkBool32</type>                           <name>shaderTileImageDepthReadAccess</name></member>
+            <member><type>VkBool32</type>                           <name>shaderTileImageStencilReadAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderTileImagePropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member limittype="noauto"><type>VkBool32</type>        <name>shaderTileImageCoherentReadAccelerated</name></member>
+            <member limittype="noauto"><type>VkBool32</type>        <name>shaderTileImageReadSampleFromPixelRateInvocation</name></member>
+            <member limittype="noauto"><type>VkBool32</type>        <name>shaderTileImageReadFromHelperInvocation</name></member>
+        </type>
+        <type category="struct" name="VkImportScreenBufferInfoQNX" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member noautovalidity="true">struct <type>_screen_buffer</type>*       <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkScreenBufferPropertiesQNX" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
+            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkScreenBufferFormatPropertiesQNX" structextends="VkScreenBufferPropertiesQNX" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+            <member><type>uint64_t</type>                           <name>screenUsage</name></member>
+            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
+            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkExternalFormatQNX" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
+            <member><type>VkBool32</type>                                    <name>screenBufferImport</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrix</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrixRobustBufferAccess</name></member>
+        </type>
+        <type category="struct" name="VkCooperativeMatrixPropertiesKHR">
+            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>MSize</name></member>
+            <member><type>uint32_t</type>                            <name>NSize</name></member>
+            <member><type>uint32_t</type>                            <name>KSize</name></member>
+            <member><type>VkComponentTypeKHR</type>                  <name>AType</name></member>
+            <member><type>VkComponentTypeKHR</type>                  <name>BType</name></member>
+            <member><type>VkComponentTypeKHR</type>                  <name>CType</name></member>
+            <member><type>VkComponentTypeKHR</type>                  <name>ResultType</name></member>
+            <member><type>VkBool32</type>                            <name>saturatingAccumulation</name></member>
+            <member><type>VkScopeKHR</type>                          <name>scope</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>cooperativeMatrixSupportedStages</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderEnqueuePropertiesAMDX" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true"  optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphDepth</name></member>
+            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderOutputNodes</name></member>
+            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderPayloadSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderPayloadCount</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                                <name>executionGraphDispatchAddressAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderEnqueueFeaturesAMDX" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                   <name>shaderEnqueue</name></member>
+        </type>
+        <type category="struct" name="VkExecutionGraphPipelineCreateInfoAMDX">
+            <member values="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>                      <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>stageCount</name></member>
+            <member optional="true" len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>*    <name>pStages</name></member>
+            <member optional="true">const <type>VkPipelineLibraryCreateInfoKHR</type>*      <name>pLibraryInfo</name></member>
+            <member><type>VkPipelineLayout</type>                                           <name>layout</name></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>           <name>basePipelineHandle</name></member>
+            <member><type>int32_t</type>                                                    <name>basePipelineIndex</name></member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageNodeCreateInfoAMDX" structextends="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX">  <type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*          <name>pName</name></member>
+            <member><type>uint32_t</type>                                                   <name>index</name></member>
+        </type>
+        <type category="struct" name="VkExecutionGraphPipelineScratchSizeAMDX">
+            <member values="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX"><type>VkStructureType</type> <name>sType</name></member>
+            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                                               <name>size</name></member>
+        </type>
+        <type category="struct" name="VkDispatchGraphInfoAMDX">
+            <member><type>uint32_t</type>                                                   <name>nodeIndex</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>payloadCount</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstAMDX</type>           <name>payloads</name></member>
+            <member><type>uint64_t</type>                                                   <name>payloadStride</name></member>
+        </type>
+        <type category="struct" name="VkDispatchGraphCountInfoAMDX">
+            <member optional="true"><type>uint32_t</type>                                   <name>count</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstAMDX</type>                  <name>infos</name></member>
+            <member><type>uint64_t</type>                                                   <name>stride</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCubicClampFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>cubicRangeClamp</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceYcbcrDegammaFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>ycbcrDegamma</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM" structextends="VkSamplerYcbcrConversionCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>enableYDegamma</name></member>
+            <member><type>VkBool32</type>                           <name>enableCbCrDegamma</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCubicWeightsFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>selectableCubicWeights</name></member>
+        </type>
+        <type category="struct" name="VkSamplerCubicWeightsCreateInfoQCOM" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkCubicFilterWeightsQCOM</type>         <name>cubicWeights</name></member>
+        </type>
+        <type category="struct" name="VkBlitImageCubicWeightsInfoQCOM" structextends="VkBlitImageInfo2">
+            <member values="VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkCubicFilterWeightsQCOM</type>         <name>cubicWeights</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageProcessing2FeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*   <name>pNext</name></member>
+            <member><type>VkBool32</type>                                      <name>textureBlockMatch2</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageProcessing2PropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                        <name>pNext</name></member>
+            <member limittype="max" optional="true"><type>VkExtent2D</type>  <name>maxBlockMatchWindow</name></member>
+        </type>
+        <type category="struct" name="VkSamplerBlockMatchWindowCreateInfoQCOM" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkExtent2D</type>                                   <name>windowExtent</name></member>
+            <member><type>VkBlockMatchWindowCompareModeQCOM</type>            <name>windowCompareMode</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>descriptorPoolOverallocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLayeredDriverPropertiesMSFT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
+            <member><type>VkLayeredDriverUnderlyingApiMSFT</type>            <name>underlyingAPI</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFormatResolveFeaturesANDROID" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+          <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+          <member optional="true"><type>void</type>*        <name>pNext</name></member>
+          <member><type>VkBool32</type>                     <name>externalFormatResolve</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+          <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+          <member optional="true"><type>void</type>*        <name>pNext</name></member>
+          <member limittype="noauto"><type>VkBool32</type>  <name>nullColorAttachmentWithExternalFormatResolve</name></member>
+          <member limittype="noauto"><type>VkChromaLocation</type>  <name>externalFormatResolveChromaOffsetX</name></member>
+          <member limittype="noauto"><type>VkChromaLocation</type>  <name>externalFormatResolveChromaOffsetY</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferFormatResolvePropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+          <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+          <member optional="true"><type>void</type>*        <name>pNext</name></member>
+          <member><type>VkFormat</type>                     <name>colorAttachmentFormat</name></member>
+        </type>
+        <type category="struct" name="VkLatencySleepModeInfoNV">
+            <member values="VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>lowLatencyMode</name></member>
+            <member><type>VkBool32</type> <name>lowLatencyBoost</name></member>
+            <member><type>uint32_t</type> <name>minimumIntervalUs</name></member>
+        </type>
+        <type category="struct" name="VkLatencySleepInfoNV">
+            <member values="VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkSemaphore</type> <name>signalSemaphore</name></member>
+            <member><type>uint64_t</type> <name>value</name></member>
+        </type>
+        <type category="struct" name="VkSetLatencyMarkerInfoNV">
+            <member values="VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>presentID</name></member>
+            <member><type>VkLatencyMarkerNV</type> <name>marker</name></member>
+        </type>
+        <type category="struct" name="VkGetLatencyMarkerInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkLatencyTimingsFrameReportNV</type>* <name>pTimings</name></member>
+        </type>
+        <type category="struct" name="VkLatencyTimingsFrameReportNV">
+            <member values="VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type>               <name>presentID</name></member>
+            <member><type>uint64_t</type>               <name>inputSampleTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>simStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>simEndTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>renderSubmitStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>renderSubmitEndTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>presentStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>presentEndTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>driverStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>driverEndTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>osRenderQueueStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>osRenderQueueEndTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>gpuRenderStartTimeUs</name></member>
+            <member><type>uint64_t</type>               <name>gpuRenderEndTimeUs</name></member>
+        </type>
+        <type category="struct" name="VkOutOfBandQueueTypeInfoNV">
+            <member values="VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkOutOfBandQueueTypeNV</type> <name>queueType</name></member>
+        </type>
+        <type category="struct" name="VkLatencySubmissionPresentIdNV" structextends="VkSubmitInfo,VkSubmitInfo2">
+            <member values="VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>uint64_t</type>                         <name>presentID</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainLatencyCreateInfoNV" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member optional="true"><type>VkBool32</type>                           <name>latencyModeEnable</name></member>
+        </type>
+        <type category="struct" name="VkLatencySurfaceCapabilitiesNV" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>presentModeCount</name></member>
+            <member optional="true" len="presentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCudaKernelLaunchFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>cudaKernelLaunchFeatures</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCudaKernelLaunchPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>computeCapabilityMinor</name></member>
+            <member limittype="min"><type>uint32_t</type>         <name>computeCapabilityMajor</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueShaderCoreControlCreateInfoARM" structextends="VkDeviceQueueCreateInfo,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>shaderCoreCount</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSchedulingControlsFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>schedulingControls</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSchedulingControlsPropertiesARM" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
+            <member><type>VkPhysicalDeviceSchedulingControlsFlagsARM</type>  <name>schedulingControlsFlags</name></member>
+        </type>
+    </types>
+
+
+    <comment>Vulkan enumerant (token) definitions</comment>
+
+    <enums name="API Constants" comment="Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate">
+        <enum type="uint32_t" value="256"       name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
+        <enum type="uint32_t" value="16"        name="VK_UUID_SIZE"/>
+        <enum type="uint32_t" value="8"         name="VK_LUID_SIZE"/>
+        <enum                                   name="VK_LUID_SIZE_KHR" alias="VK_LUID_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_EXTENSION_NAME_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DESCRIPTION_SIZE"/>
+        <enum type="uint32_t" value="32"        name="VK_MAX_MEMORY_TYPES"/>
+        <enum type="uint32_t" value="16"        name="VK_MAX_MEMORY_HEAPS" comment="The maximum number of unique memory heaps, each of which supporting 1 or more memory types"/>
+        <enum type="float"    value="1000.0F"   name="VK_LOD_CLAMP_NONE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_MIP_LEVELS"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_ARRAY_LAYERS"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_3D_SLICES_EXT"/>
+        <enum type="uint64_t" value="(~0ULL)"   name="VK_WHOLE_SIZE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_ATTACHMENT_UNUSED"/>
+        <enum type="uint32_t" value="1"         name="VK_TRUE"/>
+        <enum type="uint32_t" value="0"         name="VK_FALSE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_QUEUE_FAMILY_IGNORED"/>
+        <enum type="uint32_t" value="(~1U)"     name="VK_QUEUE_FAMILY_EXTERNAL"/>
+        <enum                                   name="VK_QUEUE_FAMILY_EXTERNAL_KHR" alias="VK_QUEUE_FAMILY_EXTERNAL"/>
+        <enum type="uint32_t" value="(~2U)"     name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_SUBPASS_EXTERNAL"/>
+        <enum type="uint32_t" value="32"        name="VK_MAX_DEVICE_GROUP_SIZE"/>
+        <enum                                   name="VK_MAX_DEVICE_GROUP_SIZE_KHR" alias="VK_MAX_DEVICE_GROUP_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_NAME_SIZE"/>
+        <enum                                   name="VK_MAX_DRIVER_NAME_SIZE_KHR" alias="VK_MAX_DRIVER_NAME_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_INFO_SIZE"/>
+        <enum                                   name="VK_MAX_DRIVER_INFO_SIZE_KHR" alias="VK_MAX_DRIVER_INFO_SIZE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_SHADER_UNUSED_KHR"/>
+        <enum                                   name="VK_SHADER_UNUSED_NV" alias="VK_SHADER_UNUSED_KHR"/>
+        <enum type="uint32_t" value="16"        name="VK_MAX_GLOBAL_PRIORITY_SIZE_KHR"/>
+        <enum                                   name="VK_MAX_GLOBAL_PRIORITY_SIZE_EXT" alias="VK_MAX_GLOBAL_PRIORITY_SIZE_KHR"/>
+        <enum type="uint32_t" value="32"        name="VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_SHADER_INDEX_UNUSED_AMDX"/>
+    </enums>
+
+    <comment>
+        Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
+        their own numeric namespaces. The "name" attribute is the C enum
+        type name, and is pulled in from a type tag definition above
+        (slightly clunky, but retains the type / enum distinction). "type"
+        attributes of "enum" or "bitmask" indicate that these values should
+        be generated inside an appropriate definition.
+    </comment>
+
+    <enums name="VkImageLayout" type="enum">
+        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
+        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
+        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
+        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
+        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
+        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
+        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"              comment="Optimal layout when image is used only as source of transfer operations"/>
+        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"              comment="Optimal layout when image is used only as destination of transfer operations"/>
+        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
+    </enums>
+    <enums name="VkAttachmentLoadOp" type="enum">
+        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
+        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
+        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
+    </enums>
+    <enums name="VkAttachmentStoreOp" type="enum">
+        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
+        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
+    </enums>
+    <enums name="VkImageType" type="enum">
+        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
+        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
+        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
+    </enums>
+    <enums name="VkImageTiling" type="enum">
+        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
+        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
+    </enums>
+    <enums name="VkImageViewType" type="enum">
+        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
+        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
+        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
+        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
+        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
+        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
+        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
+    </enums>
+    <enums name="VkCommandBufferLevel" type="enum">
+        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
+        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
+    </enums>
+    <enums name="VkComponentSwizzle" type="enum">
+        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
+        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
+        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
+        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
+        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
+        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
+        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
+    </enums>
+    <enums name="VkDescriptorType" type="enum">
+        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
+        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
+        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
+        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
+        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
+        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
+        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
+        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
+        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
+        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
+        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
+    </enums>
+    <enums name="VkQueryType" type="enum">
+        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
+        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
+        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
+    </enums>
+    <enums name="VkBorderColor" type="enum">
+        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
+        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
+        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
+        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
+        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
+        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
+    </enums>
+    <enums name="VkPipelineBindPoint" type="enum">
+        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
+        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
+    </enums>
+    <enums name="VkPipelineCacheHeaderVersion" type="enum">
+        <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
+    </enums>
+    <enums name="VkPipelineCacheCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPrimitiveTopology" type="enum">
+        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
+        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
+        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
+        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
+        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
+        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
+        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
+        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
+        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
+        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
+        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
+    </enums>
+    <enums name="VkSharingMode" type="enum">
+        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
+        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
+    </enums>
+    <enums name="VkIndexType" type="enum">
+        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
+        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
+    </enums>
+    <enums name="VkFilter" type="enum">
+        <enum value="0"     name="VK_FILTER_NEAREST"/>
+        <enum value="1"     name="VK_FILTER_LINEAR"/>
+    </enums>
+    <enums name="VkSamplerMipmapMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
+        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
+    </enums>
+    <enums name="VkSamplerAddressMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
+        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
+        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
+        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
+            <comment>
+                value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
+                enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
+                alias!
+            </comment>
+    </enums>
+    <enums name="VkCompareOp" type="enum">
+        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
+        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
+        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
+        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
+        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
+        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
+        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
+        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
+    </enums>
+    <enums name="VkPolygonMode" type="enum">
+        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
+        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
+        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
+    </enums>
+    <enums name="VkFrontFace" type="enum">
+        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
+        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
+    </enums>
+    <enums name="VkBlendFactor" type="enum">
+        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
+        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
+        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
+        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
+        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
+        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
+        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
+        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
+        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
+        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
+        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
+        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
+        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
+        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
+        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
+        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
+        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
+        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
+        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
+    </enums>
+    <enums name="VkBlendOp" type="enum">
+        <enum value="0"     name="VK_BLEND_OP_ADD"/>
+        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
+        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
+        <enum value="3"     name="VK_BLEND_OP_MIN"/>
+        <enum value="4"     name="VK_BLEND_OP_MAX"/>
+    </enums>
+    <enums name="VkStencilOp" type="enum">
+        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
+        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
+        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
+        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
+        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
+        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
+        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
+        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
+    </enums>
+    <enums name="VkLogicOp" type="enum">
+        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
+        <enum value="1"     name="VK_LOGIC_OP_AND"/>
+        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
+        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
+        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
+        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
+        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
+        <enum value="7"     name="VK_LOGIC_OP_OR"/>
+        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
+        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
+        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
+        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
+        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
+        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
+        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
+        <enum value="15"    name="VK_LOGIC_OP_SET"/>
+    </enums>
+    <enums name="VkInternalAllocationType" type="enum">
+        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
+    </enums>
+    <enums name="VkSystemAllocationScope" type="enum">
+        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
+        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
+        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
+        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
+        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
+    </enums>
+    <enums name="VkPhysicalDeviceType" type="enum">
+        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
+        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
+        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
+        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
+        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
+    </enums>
+    <enums name="VkVertexInputRate" type="enum">
+        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
+        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
+    </enums>
+    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
+        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
+        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
+        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
+        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
+        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
+        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
+        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
+        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
+        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
+        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
+        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
+        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
+        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
+        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
+        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
+        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
+        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
+        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
+        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
+        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
+        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
+        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
+        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
+        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
+        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
+        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
+        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
+        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
+        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
+        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
+        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
+        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
+        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
+        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
+        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
+        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
+        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
+        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
+        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
+        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
+        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
+        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
+        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
+        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
+        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
+        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
+        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
+        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
+        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
+        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
+        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
+        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
+        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
+        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
+        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
+        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
+        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
+        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
+        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
+        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
+        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
+        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
+        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
+        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
+        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
+        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
+        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
+        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
+        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
+        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
+        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
+        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
+        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
+        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
+        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
+        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
+        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
+        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
+        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
+        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
+        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
+        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
+        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
+        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
+        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
+        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
+        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
+        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
+        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
+        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
+        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
+        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
+        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
+        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
+        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
+        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
+        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
+        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
+        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
+        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
+        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
+        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
+        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
+        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
+        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
+        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
+        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
+        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
+        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
+        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
+        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
+        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
+        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
+        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
+        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
+        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
+        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
+        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
+        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
+        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
+        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
+        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
+        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
+        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
+        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
+        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
+        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
+        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
+        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
+        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
+        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
+        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
+        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
+        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
+        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
+        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
+        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
+        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
+        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
+        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
+        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
+        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
+        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
+        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
+        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
+        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
+        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
+        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
+        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
+        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
+        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
+        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
+        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
+        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
+        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
+        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
+        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
+        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
+        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
+        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
+        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
+        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
+        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
+        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
+        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
+        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
+        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
+        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
+        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
+        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
+        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
+        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
+        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
+        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
+        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
+        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
+        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
+        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
+        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
+        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
+        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
+        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
+        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
+        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
+        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
+    </enums>
+    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
+        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
+        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
+        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
+        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
+        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
+        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
+        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
+        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
+        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
+        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
+        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
+        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
+        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
+        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
+        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
+        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
+        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
+        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
+        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
+        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
+        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
+        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
+        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
+        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
+        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
+        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
+        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
+        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
+        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
+        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
+        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
+        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
+        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
+        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
+        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
+        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
+        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
+        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
+        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
+        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
+        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
+        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
+        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
+        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
+        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
+        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
+        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
+        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
+        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
+    </enums>
+    <enums name="VkSubpassContents" type="enum">
+        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
+        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
+    </enums>
+    <enums name="VkResult" type="enum" comment="API result codes">
+            <comment>Return codes (positive values)</comment>
+        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
+        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
+        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
+        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
+        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
+        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
+            <comment>Error codes (negative values)</comment>
+        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
+        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
+        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of an object has failed"/>
+        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
+        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
+        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
+        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
+        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
+        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
+        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
+        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
+        <enum value="-12"   name="VK_ERROR_FRAGMENTED_POOL" comment="A requested pool allocation has failed due to fragmentation of the pool's memory"/>
+        <enum value="-13"   name="VK_ERROR_UNKNOWN" comment="An unknown error has occurred, due to an implementation or application bug"/>
+            <unused start="-14" comment="This is the next unused available error code (negative value)"/>
+    </enums>
+    <enums name="VkDynamicState" type="enum">
+        <enum value="0"     name="VK_DYNAMIC_STATE_VIEWPORT"/>
+        <enum value="1"     name="VK_DYNAMIC_STATE_SCISSOR"/>
+        <enum value="2"     name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
+        <enum value="3"     name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
+        <enum value="4"     name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
+        <enum value="5"     name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
+        <enum value="6"     name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
+        <enum value="7"     name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
+        <enum value="8"     name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
+    </enums>
+    <enums name="VkDescriptorUpdateTemplateType" type="enum">
+        <enum value="0"     name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"   comment="Create descriptor update template for descriptor set updates"/>
+    </enums>
+    <enums name="VkObjectType" type="enum" comment="Enums to track objects of various types - also see objtypeenum attributes on type tags">
+        <enum value="0"     name="VK_OBJECT_TYPE_UNKNOWN"/>
+        <enum value="1"     name="VK_OBJECT_TYPE_INSTANCE"/>
+        <enum value="2"     name="VK_OBJECT_TYPE_PHYSICAL_DEVICE"/>
+        <enum value="3"     name="VK_OBJECT_TYPE_DEVICE"/>
+        <enum value="4"     name="VK_OBJECT_TYPE_QUEUE"/>
+        <enum value="5"     name="VK_OBJECT_TYPE_SEMAPHORE"/>
+        <enum value="6"     name="VK_OBJECT_TYPE_COMMAND_BUFFER"/>
+        <enum value="7"     name="VK_OBJECT_TYPE_FENCE"/>
+        <enum value="8"     name="VK_OBJECT_TYPE_DEVICE_MEMORY"/>
+        <enum value="9"     name="VK_OBJECT_TYPE_BUFFER"/>
+        <enum value="10"    name="VK_OBJECT_TYPE_IMAGE"/>
+        <enum value="11"    name="VK_OBJECT_TYPE_EVENT"/>
+        <enum value="12"    name="VK_OBJECT_TYPE_QUERY_POOL"/>
+        <enum value="13"    name="VK_OBJECT_TYPE_BUFFER_VIEW"/>
+        <enum value="14"    name="VK_OBJECT_TYPE_IMAGE_VIEW"/>
+        <enum value="15"    name="VK_OBJECT_TYPE_SHADER_MODULE"/>
+        <enum value="16"    name="VK_OBJECT_TYPE_PIPELINE_CACHE"/>
+        <enum value="17"    name="VK_OBJECT_TYPE_PIPELINE_LAYOUT"/>
+        <enum value="18"    name="VK_OBJECT_TYPE_RENDER_PASS"/>
+        <enum value="19"    name="VK_OBJECT_TYPE_PIPELINE"/>
+        <enum value="20"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"/>
+        <enum value="21"    name="VK_OBJECT_TYPE_SAMPLER"/>
+        <enum value="22"    name="VK_OBJECT_TYPE_DESCRIPTOR_POOL"/>
+        <enum value="23"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET"/>
+        <enum value="24"    name="VK_OBJECT_TYPE_FRAMEBUFFER"/>
+        <enum value="25"    name="VK_OBJECT_TYPE_COMMAND_POOL"/>
+    </enums>
+    <enums name="VkRayTracingInvocationReorderModeNV" type="enum">
+        <enum value="0"     name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV"/>
+        <enum value="1"     name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV"/>
+    </enums>
+    <enums name="VkDirectDriverLoadingModeLUNARG" type="enum">
+        <enum value="0"     name="VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG"/>
+        <enum value="1"     name="VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG"/>
+    </enums>
+
+        <comment>Flags</comment>
+    <enums name="VkQueueFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
+        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
+        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
+        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
+    </enums>
+    <enums name="VkCullModeFlagBits" type="bitmask">
+        <enum value="0"     name="VK_CULL_MODE_NONE"/>
+        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
+        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
+        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
+    </enums>
+    <enums name="VkRenderPassCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkDeviceQueueCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
+        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
+        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
+        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
+        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
+    </enums>
+    <enums name="VkMemoryHeapFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
+    </enums>
+    <enums name="VkAccessFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
+        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
+        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
+        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
+        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
+        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
+        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
+        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
+        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
+        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
+        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
+        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
+        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
+        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
+        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
+        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
+        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
+    </enums>
+    <enums name="VkBufferUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
+        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
+        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
+        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
+        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
+        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
+        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
+        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
+        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
+    </enums>
+    <enums name="VkBufferUsageFlagBits2KHR" type="bitmask" bitwidth="64">
+        <enum bitpos="0"    name="VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR"/>
+        <enum bitpos="5"    name="VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR"/>
+        <enum bitpos="6"    name="VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR"/>
+        <enum bitpos="7"    name="VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR"/>
+        <enum bitpos="8"    name="VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR"/>
+    </enums>
+    <enums name="VkBufferCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
+        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
+        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
+    </enums>
+    <enums name="VkShaderStageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
+        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
+        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
+        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
+        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
+        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
+        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
+        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
+    </enums>
+    <enums name="VkImageUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
+        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
+        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
+        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
+        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
+        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
+        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
+        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
+    </enums>
+    <enums name="VkImageCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
+        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
+        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images"/>
+        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
+        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
+    </enums>
+    <enums name="VkImageViewCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkSamplerCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
+        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
+        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
+    </enums>
+    <enums name="VkPipelineCreateFlagBits2KHR" type="bitmask" bitwidth="64">
+        <enum bitpos="0"    name="VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR"/>
+    </enums>
+    <enums name="VkPipelineShaderStageCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkColorComponentFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
+        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
+        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
+        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
+    </enums>
+    <enums name="VkFenceCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
+    </enums>
+    <enums name="VkSemaphoreCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkFormatFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
+        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
+        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it is used for storage images"/>
+        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
+        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
+        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it is used for storage texel buffers"/>
+        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
+        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
+        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it is used for color attachment images"/>
+        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
+        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
+        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
+        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
+    </enums>
+    <enums name="VkQueryControlFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
+    </enums>
+    <enums name="VkQueryResultFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
+        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
+        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
+        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results are not available"/>
+    </enums>
+    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
+        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
+        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
+    </enums>
+    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
+        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
+        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
+        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
+        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
+        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
+        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
+        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
+        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
+        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
+        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
+    </enums>
+    <enums name="VkImageAspectFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
+        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
+        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
+        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
+    </enums>
+    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"         comment="Image uses a single mip tail region for all array layers"/>
+        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"       comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels."/>
+        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
+    </enums>
+    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
+    </enums>
+    <enums name="VkPipelineStageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
+        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
+        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
+        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
+        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" comment="Tessellation control shading"/>
+        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" comment="Tessellation evaluation shading"/>
+        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
+        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
+        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
+        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
+        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
+        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
+        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
+        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
+        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
+        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
+        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
+    </enums>
+    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
+        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
+    </enums>
+    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
+    </enums>
+    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
+    </enums>
+    <enums name="VkSampleCountFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
+        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
+        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
+        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
+        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
+        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
+        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
+    </enums>
+    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
+    </enums>
+    <enums name="VkStencilFaceFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
+        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
+        <enum value="0x00000003" name="VK_STENCIL_FACE_FRONT_AND_BACK"               comment="Front and back faces"/>
+        <enum api="vulkan"  name="VK_STENCIL_FRONT_AND_BACK" alias="VK_STENCIL_FACE_FRONT_AND_BACK" deprecated="aliased"/>
+    </enums>
+    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
+    </enums>
+    <enums name="VkDependencyFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
+    </enums>
+    <enums name="VkSemaphoreType" type="enum">
+        <enum value="0"     name="VK_SEMAPHORE_TYPE_BINARY"/>
+        <enum value="1"     name="VK_SEMAPHORE_TYPE_TIMELINE"/>
+    </enums>
+    <enums name="VkSemaphoreWaitFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SEMAPHORE_WAIT_ANY_BIT"/>
+    </enums>
+
+        <comment>WSI Extensions</comment>
+    <enums name="VkPresentModeKHR" type="enum">
+        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
+        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
+        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
+        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
+    </enums>
+    <enums name="VkColorSpaceKHR" type="enum">
+        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
+        <enum api="vulkan"  name="VK_COLORSPACE_SRGB_NONLINEAR_KHR" alias="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" deprecated="aliased"/>
+    </enums>
+    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
+    </enums>
+    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
+    </enums>
+    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
+        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
+        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
+        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
+        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
+    </enums>
+    <enums name="VkSwapchainImageUsageFlagBitsANDROID" type="bitmask">
+      <enum bitpos="0"      name="VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID"/>
+    </enums>
+    <enums name="VkTimeDomainEXT" type="enum">
+        <enum value="0"     name="VK_TIME_DOMAIN_DEVICE_EXT"/>
+        <enum value="1"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT"/>
+        <enum value="2"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT"/>
+        <enum value="3"     name="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT"/>
+    </enums>
+    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
+    </enums>
+    <enums name="VkDebugReportObjectTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
+        <enum value="1"     name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
+        <enum value="2"     name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
+        <enum value="3"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
+        <enum value="4"     name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
+        <enum value="5"     name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
+        <enum value="6"     name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
+        <enum value="7"     name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
+        <enum value="8"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
+        <enum value="9"     name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
+        <enum value="10"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
+        <enum value="11"    name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
+        <enum value="12"    name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
+        <enum value="13"    name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
+        <enum value="14"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
+        <enum value="15"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
+        <enum value="16"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
+        <enum value="17"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
+        <enum value="18"    name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
+        <enum value="19"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
+        <enum value="20"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
+        <enum value="21"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
+        <enum value="22"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
+        <enum value="23"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
+        <enum value="24"    name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
+        <enum value="25"    name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
+        <enum value="26"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
+        <enum value="27"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
+        <enum value="28"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"/>
+        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" deprecated="aliased"/>
+        <enum value="29"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"/>
+        <enum value="30"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"/>
+            <comment>NVX_device_generated_commands formerly used these enum values, but that extension has been removed
+                value 31 / name VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT
+                value 32 / name VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT
+            </comment>
+        <enum value="33"    name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"/>
+        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" deprecated="aliased"/>
+    </enums>
+    <enums name="VkDeviceMemoryReportEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT"/>
+        <enum value="1"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT"/>
+        <enum value="2"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT"/>
+        <enum value="3"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT"/>
+        <enum value="4"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT"/>
+    </enums>
+    <enums name="VkRasterizationOrderAMD" type="enum">
+        <enum value="0"     name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>
+        <enum value="1"     name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>
+    </enums>
+    <enums name="VkExternalMemoryHandleTypeFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"/>
+    </enums>
+    <enums name="VkExternalMemoryFeatureFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"/>
+    </enums>
+    <enums name="VkValidationCheckEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_CHECK_ALL_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_CHECK_SHADERS_EXT"/>
+    </enums>
+    <enums name="VkValidationFeatureEnableEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"/>
+        <enum value="2"     name="VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT"/>
+        <enum value="3"     name="VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT"/>
+        <enum value="4"     name="VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT"/>
+    </enums>
+    <enums name="VkValidationFeatureDisableEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"/>
+        <enum value="2"     name="VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"/>
+        <enum value="3"     name="VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"/>
+        <enum value="4"     name="VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"/>
+        <enum value="5"     name="VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"/>
+        <enum value="6"     name="VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"/>
+        <enum value="7"     name="VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT"/>
+    </enums>
+    <enums name="VkSubgroupFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SUBGROUP_FEATURE_BASIC_BIT"              comment="Basic subgroup operations"/>
+        <enum bitpos="1"    name="VK_SUBGROUP_FEATURE_VOTE_BIT"               comment="Vote subgroup operations"/>
+        <enum bitpos="2"    name="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"         comment="Arithmetic subgroup operations"/>
+        <enum bitpos="3"    name="VK_SUBGROUP_FEATURE_BALLOT_BIT"             comment="Ballot subgroup operations"/>
+        <enum bitpos="4"    name="VK_SUBGROUP_FEATURE_SHUFFLE_BIT"            comment="Shuffle subgroup operations"/>
+        <enum bitpos="5"    name="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"   comment="Shuffle relative subgroup operations"/>
+        <enum bitpos="6"    name="VK_SUBGROUP_FEATURE_CLUSTERED_BIT"          comment="Clustered subgroup operations"/>
+        <enum bitpos="7"    name="VK_SUBGROUP_FEATURE_QUAD_BIT"               comment="Quad subgroup operations"/>
+    </enums>
+    <enums name="VkIndirectCommandsLayoutUsageFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"/>
+        <enum bitpos="1"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"/>
+        <enum bitpos="2"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"/>
+    </enums>
+    <enums name="VkIndirectStateFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"/>
+    </enums>
+    <enums name="VkIndirectCommandsTokenTypeNV" type="enum">
+        <enum value="0"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV"/>
+        <enum value="1"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV"/>
+        <enum value="2"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV"/>
+        <enum value="3"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV"/>
+        <enum value="4"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV"/>
+        <enum value="5"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV"/>
+        <enum value="6"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV"/>
+        <enum value="7"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV"/>
+    </enums>
+    <enums name="VkPrivateDataSlotCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkDescriptorSetLayoutCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkExternalMemoryHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
+        <enum bitpos="4"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
+        <enum bitpos="5"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
+        <enum bitpos="6"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
+    </enums>
+    <enums name="VkExternalMemoryFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkExternalSemaphoreHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+        <enum               name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+        <enum bitpos="4"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
+    </enums>
+    <enums name="VkExternalSemaphoreFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkSemaphoreImportFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
+    </enums>
+    <enums name="VkExternalFenceHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
+    </enums>
+    <enums name="VkExternalFenceFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkFenceImportFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
+    </enums>
+    <enums name="VkSurfaceCounterFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_SURFACE_COUNTER_VBLANK_BIT_EXT"/>
+        <enum               name="VK_SURFACE_COUNTER_VBLANK_EXT" alias="VK_SURFACE_COUNTER_VBLANK_BIT_EXT" deprecated="aliased"/>
+    </enums>
+    <enums name="VkDisplayPowerStateEXT" type="enum">
+        <enum value="0"     name="VK_DISPLAY_POWER_STATE_OFF_EXT"/>
+        <enum value="1"     name="VK_DISPLAY_POWER_STATE_SUSPEND_EXT"/>
+        <enum value="2"     name="VK_DISPLAY_POWER_STATE_ON_EXT"/>
+    </enums>
+    <enums name="VkDeviceEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"/>
+    </enums>
+    <enums name="VkDisplayEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"/>
+    </enums>
+    <enums name="VkPeerMemoryFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"           comment="Can read with vkCmdCopy commands"/>
+        <enum bitpos="1"    name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"           comment="Can write with vkCmdCopy commands"/>
+        <enum bitpos="2"    name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"        comment="Can read with any access type/command"/>
+        <enum bitpos="3"    name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"        comment="Can write with and access type/command"/>
+    </enums>
+    <enums name="VkMemoryAllocateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"            comment="Force allocation on specific devices"/>
+    </enums>
+    <enums name="VkDeviceGroupPresentModeFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"        comment="Present from local memory"/>
+        <enum bitpos="1"    name="VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"       comment="Present from remote memory"/>
+        <enum bitpos="2"    name="VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"          comment="Present sum of local and/or remote memory"/>
+        <enum bitpos="3"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR" comment="Each physical device presents from local memory"/>
+    </enums>
+    <enums name="VkSwapchainCreateFlagBitsKHR" type="bitmask">
+    </enums>
+    <enums name="VkViewportCoordinateSwizzleNV" type="enum">
+        <enum value="0"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"/>
+        <enum value="1"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"/>
+        <enum value="2"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"/>
+        <enum value="3"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"/>
+        <enum value="4"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"/>
+        <enum value="5"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"/>
+        <enum value="6"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"/>
+        <enum value="7"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"/>
+    </enums>
+    <enums name="VkDiscardRectangleModeEXT" type="enum">
+        <enum value="0"     name="VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"/>
+        <enum value="1"     name="VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"/>
+    </enums>
+    <enums name="VkSubpassDescriptionFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPointClippingBehavior" type="enum">
+        <enum value="0"     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
+        <enum value="1"     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
+    </enums>
+    <enums name="VkSamplerReductionMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
+        <enum value="1"     name="VK_SAMPLER_REDUCTION_MODE_MIN"/>
+        <enum value="2"     name="VK_SAMPLER_REDUCTION_MODE_MAX"/>
+    </enums>
+    <enums name="VkTessellationDomainOrigin" type="enum">
+        <enum value="0"     name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
+        <enum value="1"     name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
+    </enums>
+    <enums name="VkSamplerYcbcrModelConversion" type="enum">
+        <enum value="0"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
+        <enum value="1"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" comment="just range expansion"/>
+        <enum value="2"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"      comment="aka HD YUV"/>
+        <enum value="3"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"      comment="aka SD YUV"/>
+        <enum value="4"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"     comment="aka UHD YUV"/>
+    </enums>
+    <enums name="VkSamplerYcbcrRange" type="enum">
+        <enum value="0"     name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"    comment="Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)"/>
+        <enum value="1"     name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"  comment="Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240"/>
+    </enums>
+    <enums name="VkChromaLocation" type="enum">
+        <enum value="0"     name="VK_CHROMA_LOCATION_COSITED_EVEN"/>
+        <enum value="1"     name="VK_CHROMA_LOCATION_MIDPOINT"/>
+    </enums>
+    <enums name="VkBlendOverlapEXT" type="enum">
+        <enum value="0"     name="VK_BLEND_OVERLAP_UNCORRELATED_EXT"/>
+        <enum value="1"     name="VK_BLEND_OVERLAP_DISJOINT_EXT"/>
+        <enum value="2"     name="VK_BLEND_OVERLAP_CONJOINT_EXT"/>
+    </enums>
+    <enums name="VkCoverageModulationModeNV" type="enum">
+        <enum value="0"     name="VK_COVERAGE_MODULATION_MODE_NONE_NV"/>
+        <enum value="1"     name="VK_COVERAGE_MODULATION_MODE_RGB_NV"/>
+        <enum value="2"     name="VK_COVERAGE_MODULATION_MODE_ALPHA_NV"/>
+        <enum value="3"     name="VK_COVERAGE_MODULATION_MODE_RGBA_NV"/>
+    </enums>
+    <enums name="VkCoverageReductionModeNV" type="enum">
+        <enum value="0"     name="VK_COVERAGE_REDUCTION_MODE_MERGE_NV"/>
+        <enum value="1"     name="VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"/>
+    </enums>
+    <enums name="VkValidationCacheHeaderVersionEXT" type="enum">
+        <enum value="1"     name="VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"/>
+    </enums>
+    <enums name="VkShaderInfoTypeAMD" type="enum">
+        <enum value="0"     name="VK_SHADER_INFO_TYPE_STATISTICS_AMD"/>
+        <enum value="1"     name="VK_SHADER_INFO_TYPE_BINARY_AMD"/>
+        <enum value="2"     name="VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"/>
+    </enums>
+    <enums name="VkQueueGlobalPriorityKHR" type="enum">
+        <enum value="128"   name="VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR"/>
+        <enum value="256"   name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR"/>
+        <enum value="512"   name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR"/>
+        <enum value="1024"  name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR"/>
+        <enum               name="VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"         alias="VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR"/>
+        <enum               name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"      alias="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR"/>
+        <enum               name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"        alias="VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR"/>
+        <enum               name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"    alias="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR"/>
+    </enums>
+    <enums name="VkDebugUtilsMessageSeverityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"/>
+        <enum bitpos="12"   name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"/>
+    </enums>
+    <enums name="VkDebugUtilsMessageTypeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"/>
+    </enums>
+    <enums name="VkConservativeRasterizationModeEXT" type="enum">
+        <enum value="0"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"/>
+        <enum value="1"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"/>
+        <enum value="2"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"/>
+    </enums>
+    <enums name="VkDescriptorBindingFlagBits" type="bitmask">
+        <enum bitpos="0" name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
+        <enum bitpos="1" name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
+        <enum bitpos="2" name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
+        <enum bitpos="3" name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
+    </enums>
+    <enums name="VkVendorId" type="enum">
+        <comment>Vendor IDs are now represented as enums instead of the old
+                 &lt;vendorids&gt; tag, allowing them to be included in the
+                 API headers.</comment>
+        <enum value="0x10001" name="VK_VENDOR_ID_VIV"   comment="Vivante vendor ID"/>
+        <enum value="0x10002" name="VK_VENDOR_ID_VSI"   comment="VeriSilicon vendor ID"/>
+        <enum value="0x10003" name="VK_VENDOR_ID_KAZAN" comment="Kazan Software Renderer"/>
+        <enum value="0x10004" name="VK_VENDOR_ID_CODEPLAY" comment="Codeplay Software Ltd. vendor ID"/>
+        <enum value="0x10005" name="VK_VENDOR_ID_MESA"  comment="Mesa vendor ID"/>
+        <enum value="0x10006" name="VK_VENDOR_ID_POCL"  comment="PoCL vendor ID"/>
+        <enum value="0x10007" name="VK_VENDOR_ID_MOBILEYE"  comment="Mobileye vendor ID"/>
+            <unused start="0x10008" comment="This is the next unused available Khronos vendor ID"/>
+    </enums>
+    <enums name="VkDriverId" type="enum">
+        <comment>Driver IDs are now represented as enums instead of the old
+                 &lt;driverids&gt; tag, allowing them to be included in the
+                 API headers.</comment>
+        <enum value="1"       name="VK_DRIVER_ID_AMD_PROPRIETARY"               comment="Advanced Micro Devices, Inc."/>
+        <enum value="2"       name="VK_DRIVER_ID_AMD_OPEN_SOURCE"               comment="Advanced Micro Devices, Inc."/>
+        <enum value="3"       name="VK_DRIVER_ID_MESA_RADV"                     comment="Mesa open source project"/>
+        <enum value="4"       name="VK_DRIVER_ID_NVIDIA_PROPRIETARY"            comment="NVIDIA Corporation"/>
+        <enum value="5"       name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"     comment="Intel Corporation"/>
+        <enum value="6"       name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"        comment="Intel Corporation"/>
+        <enum value="7"       name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"       comment="Imagination Technologies"/>
+        <enum value="8"       name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"          comment="Qualcomm Technologies, Inc."/>
+        <enum value="9"       name="VK_DRIVER_ID_ARM_PROPRIETARY"               comment="Arm Limited"/>
+        <enum value="10"      name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"            comment="Google LLC"/>
+        <enum value="11"      name="VK_DRIVER_ID_GGP_PROPRIETARY"               comment="Google LLC"/>
+        <enum value="12"      name="VK_DRIVER_ID_BROADCOM_PROPRIETARY"          comment="Broadcom Inc."/>
+        <enum value="13"      name="VK_DRIVER_ID_MESA_LLVMPIPE"                 comment="Mesa"/>
+        <enum value="14"      name="VK_DRIVER_ID_MOLTENVK"                      comment="MoltenVK"/>
+        <enum value="15"      name="VK_DRIVER_ID_COREAVI_PROPRIETARY"           comment="Core Avionics &amp; Industrial Inc."/>
+        <enum value="16"      name="VK_DRIVER_ID_JUICE_PROPRIETARY"             comment="Juice Technologies, Inc."/>
+        <enum value="17"      name="VK_DRIVER_ID_VERISILICON_PROPRIETARY"       comment="Verisilicon, Inc."/>
+        <enum value="18"      name="VK_DRIVER_ID_MESA_TURNIP"                   comment="Mesa open source project"/>
+        <enum value="19"      name="VK_DRIVER_ID_MESA_V3DV"                     comment="Mesa open source project"/>
+        <enum value="20"      name="VK_DRIVER_ID_MESA_PANVK"                    comment="Mesa open source project"/>
+        <enum value="21"      name="VK_DRIVER_ID_SAMSUNG_PROPRIETARY"           comment="Samsung Electronics Co., Ltd."/>
+        <enum value="22"      name="VK_DRIVER_ID_MESA_VENUS"                    comment="Mesa open source project"/>
+        <enum value="23"      name="VK_DRIVER_ID_MESA_DOZEN"                    comment="Mesa open source project"/>
+        <enum value="24"      name="VK_DRIVER_ID_MESA_NVK"                      comment="Mesa open source project"/>
+        <enum value="25"      name="VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA"  comment="Imagination Technologies"/>
+        <enum value="26"      name="VK_DRIVER_ID_MESA_AGXV"                     comment="Mesa open source project"/>
+    </enums>
+    <enums name="VkConditionalRenderingFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"/>
+    </enums>
+    <enums name="VkResolveModeFlagBits" type="bitmask">
+        <enum value="0" name="VK_RESOLVE_MODE_NONE"/>
+        <enum bitpos="0" name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
+        <enum bitpos="1" name="VK_RESOLVE_MODE_AVERAGE_BIT"/>
+        <enum bitpos="2" name="VK_RESOLVE_MODE_MIN_BIT"/>
+        <enum bitpos="3" name="VK_RESOLVE_MODE_MAX_BIT"/>
+    </enums>
+    <enums name="VkShadingRatePaletteEntryNV" type="enum">
+        <enum value="0" name="VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"/>
+        <enum value="1" name="VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="2" name="VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="3" name="VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="4" name="VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="5" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"/>
+        <enum value="6" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"/>
+        <enum value="7" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"/>
+        <enum value="8" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"/>
+        <enum value="9" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"/>
+        <enum value="10" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"/>
+        <enum value="11" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"/>
+    </enums>
+    <enums name="VkCoarseSampleOrderTypeNV" type="enum">
+        <enum value="0" name="VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"/>
+        <enum value="1" name="VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"/>
+        <enum value="2" name="VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"/>
+        <enum value="3" name="VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"/>
+    </enums>
+    <enums name="VkGeometryInstanceFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
+        <enum bitpos="2" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
+        <enum bitpos="3" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
+        <enum            name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
+    </enums>
+    <enums name="VkGeometryFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
+    </enums>
+    <enums name="VkBuildAccelerationStructureFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
+        <enum bitpos="2" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
+        <enum bitpos="3" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
+        <enum bitpos="4" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureCreateFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"/>
+    </enums>
+    <enums name="VkCopyAccelerationStructureModeKHR" type="enum">
+        <enum value="0" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
+        <enum value="1" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
+        <enum value="2" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"/>
+        <enum value="3" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"/>
+    </enums>
+    <enums name="VkBuildAccelerationStructureModeKHR" type="enum">
+        <enum value="0" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR"/>
+        <enum value="1" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureTypeKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"/>
+    </enums>
+    <enums name="VkGeometryTypeKHR" type="enum">
+        <enum value="0" name="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
+        <enum value="1" name="VK_GEOMETRY_TYPE_AABBS_KHR"/>
+        <enum value="2" name="VK_GEOMETRY_TYPE_INSTANCES_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureMemoryRequirementsTypeNV" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"/>
+    </enums>
+    <enums name="VkAccelerationStructureBuildTypeKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR"/>
+    </enums>
+    <enums name="VkRayTracingShaderGroupTypeKHR" type="enum">
+        <enum value="0" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
+        <enum value="1" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
+        <enum value="2" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureCompatibilityKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR"/>
+    </enums>
+    <enums name="VkShaderGroupShaderKHR" type="enum">
+        <enum value="0" name="VK_SHADER_GROUP_SHADER_GENERAL_KHR"/>
+        <enum value="1" name="VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR"/>
+        <enum value="2" name="VK_SHADER_GROUP_SHADER_ANY_HIT_KHR"/>
+        <enum value="3" name="VK_SHADER_GROUP_SHADER_INTERSECTION_KHR"/>
+    </enums>
+    <enums name="VkMemoryOverallocationBehaviorAMD" type="enum">
+        <enum value="0"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"/>
+        <enum value="1"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"/>
+        <enum value="2"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"/>
+    </enums>
+    <enums name="VkFramebufferCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkDeviceDiagnosticsConfigFlagBitsNV" type="bitmask">
+        <enum bitpos="0" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"/>
+        <enum bitpos="1" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"/>
+        <enum bitpos="2" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"/>
+        <enum bitpos="3" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV"/>
+    </enums>
+    <enums name="VkPipelineCreationFeedbackFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"/>
+        <enum               name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"/>
+        <enum bitpos="1"    name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"/>
+        <enum               name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"/>
+        <enum bitpos="2"    name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"/>
+        <enum               name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"/>
+    </enums>
+    <enums name="VkFullScreenExclusiveEXT" type="enum">
+        <enum value="0"     name="VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT"/>
+        <enum value="1"     name="VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT"/>
+        <enum value="2"     name="VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT"/>
+        <enum value="3"     name="VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT"/>
+    </enums>
+    <enums name="VkPerformanceCounterScopeKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"/>
+        <enum               name="VK_QUERY_SCOPE_COMMAND_BUFFER_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR" deprecated="aliased"/>
+        <enum               name="VK_QUERY_SCOPE_RENDER_PASS_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR" deprecated="aliased"/>
+        <enum               name="VK_QUERY_SCOPE_COMMAND_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR" deprecated="aliased"/>
+    </enums>
+    <enums name="VkMemoryDecompressionMethodFlagBitsNV" type="bitmask" bitwidth="64">
+        <enum bitpos="0" name="VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV"/>
+    </enums>
+    <enums name="VkPerformanceCounterUnitKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR"/>
+        <enum value="3"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR"/>
+        <enum value="4"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR"/>
+        <enum value="5"     name="VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR"/>
+        <enum value="6"     name="VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR"/>
+        <enum value="7"     name="VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR"/>
+        <enum value="8"     name="VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR"/>
+        <enum value="9"     name="VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR"/>
+        <enum value="10"    name="VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR"/>
+    </enums>
+    <enums name="VkPerformanceCounterStorageKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR"/>
+        <enum value="3"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR"/>
+        <enum value="4"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR"/>
+        <enum value="5"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR"/>
+    </enums>
+    <enums name="VkPerformanceCounterDescriptionFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR"/>
+        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR" deprecated="aliased"/>
+        <enum bitpos="1"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR"/>
+        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR" deprecated="aliased"/>
+    </enums>
+    <enums name="VkAcquireProfilingLockFlagBitsKHR" type="bitmask">
+    </enums>
+    <enums name="VkShaderCorePropertiesFlagBitsAMD" type="bitmask">
+    </enums>
+    <enums name="VkRefreshObjectFlagBitsKHR" type="bitmask">
+    </enums>
+    <enums name="VkPerformanceConfigurationTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"/>
+    </enums>
+    <enums name="VkQueryPoolSamplingModeINTEL" type="enum">
+        <enum value="0"     name="VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceOverrideTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceParameterTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceValueTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"/>
+        <enum value="2"     name="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"/>
+        <enum value="3"     name="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"/>
+        <enum value="4"     name="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"/>
+    </enums>
+    <enums name="VkShaderFloatControlsIndependence" type="enum">
+        <enum value="0"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
+        <enum value="1"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
+        <enum value="2"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
+    </enums>
+    <enums name="VkPipelineExecutableStatisticFormatKHR" type="enum">
+        <enum value="0" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"/>
+        <enum value="1" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"/>
+        <enum value="2" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"/>
+        <enum value="3" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"/>
+    </enums>
+    <enums name="VkLineRasterizationModeKHR" type="enum">
+        <enum value="0"     name="VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR"/>
+        <enum               name="VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT"             alias="VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR"/>
+        <enum value="1"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR"/>
+        <enum               name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT"         alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR"/>
+        <enum value="2"     name="VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR"/>
+        <enum               name="VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT"           alias="VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR"/>
+        <enum value="3"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR"/>
+        <enum               name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT"  alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR"/>
+    </enums>
+    <enums name="VkShaderModuleCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineCompilerControlFlagBitsAMD" type="bitmask">
+    </enums>
+    <enums name="VkFaultLevel" type="enum">
+        <enum value="0"    name="VK_FAULT_LEVEL_UNASSIGNED"/>
+        <enum value="1"    name="VK_FAULT_LEVEL_CRITICAL"/>
+        <enum value="2"    name="VK_FAULT_LEVEL_RECOVERABLE"/>
+        <enum value="3"    name="VK_FAULT_LEVEL_WARNING"/>
+    </enums>
+    <enums name="VkFaultType" type="enum">
+        <enum value="0"    name="VK_FAULT_TYPE_INVALID"/>
+        <enum value="1"    name="VK_FAULT_TYPE_UNASSIGNED"/>
+        <enum value="2"    name="VK_FAULT_TYPE_IMPLEMENTATION"/>
+        <enum value="3"    name="VK_FAULT_TYPE_SYSTEM"/>
+        <enum value="4"    name="VK_FAULT_TYPE_PHYSICAL_DEVICE"/>
+        <enum value="5"    name="VK_FAULT_TYPE_COMMAND_BUFFER_FULL"/>
+        <enum value="6"    name="VK_FAULT_TYPE_INVALID_API_USAGE"/>
+    </enums>
+    <enums name="VkFaultQueryBehavior" type="enum">
+        <enum value="0"    name="VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS"/>
+    </enums>
+    <enums name="VkToolPurposeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_TOOL_PURPOSE_VALIDATION_BIT"/>
+        <enum               name="VK_TOOL_PURPOSE_VALIDATION_BIT_EXT"          alias="VK_TOOL_PURPOSE_VALIDATION_BIT"/>
+        <enum bitpos="1"    name="VK_TOOL_PURPOSE_PROFILING_BIT"/>
+        <enum               name="VK_TOOL_PURPOSE_PROFILING_BIT_EXT"           alias="VK_TOOL_PURPOSE_PROFILING_BIT"/>
+        <enum bitpos="2"    name="VK_TOOL_PURPOSE_TRACING_BIT"/>
+        <enum               name="VK_TOOL_PURPOSE_TRACING_BIT_EXT"             alias="VK_TOOL_PURPOSE_TRACING_BIT"/>
+        <enum bitpos="3"    name="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"/>
+        <enum               name="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT" alias="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"/>
+        <enum bitpos="4"    name="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"/>
+        <enum               name="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT"  alias="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"/>
+    </enums>
+    <enums name="VkPipelineMatchControl" type="enum">
+        <enum value="0"     name="VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH"/>
+    </enums>
+    <enums name="VkFragmentShadingRateCombinerOpKHR" type="enum">
+        <enum value="0" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR"/>
+        <enum value="1" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR"/>
+        <enum value="2" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR"/>
+        <enum value="3" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR"/>
+        <enum value="4" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR"/>
+    </enums>
+    <enums name="VkFragmentShadingRateNV" type="enum">
+        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV"/>
+        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV"/>
+        <enum value="4"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV"/>
+        <enum value="5"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV"/>
+        <enum value="6"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV"/>
+        <enum value="9"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV"/>
+        <enum value="10" name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV"/>
+        <enum value="11" name="VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="12" name="VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="13" name="VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="14" name="VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="15" name="VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV"/>
+    </enums>
+    <enums name="VkFragmentShadingRateTypeNV" type="enum">
+        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV"/>
+        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV"/>
+    </enums>
+    <enums name="VkSubpassMergeStatusEXT" type="enum">
+        <enum value="0"  name="VK_SUBPASS_MERGE_STATUS_MERGED_EXT"/>
+        <enum value="1"  name="VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT"/>
+        <enum value="2"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT"/>
+        <enum value="3"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT"/>
+        <enum value="4"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT"/>
+        <enum value="5"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT"/>
+        <enum value="6"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT"/>
+        <enum value="7"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT"/>
+        <enum value="8"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT"/>
+        <enum value="9"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT"/>
+        <enum value="10" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT"/>
+        <enum value="11" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT"/>
+        <enum value="12" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT"/>
+        <enum value="13" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT"/>
+    </enums>
+    <enums name="VkAccessFlagBits2" type="bitmask" bitwidth="64">
+        <enum value="0"     name="VK_ACCESS_2_NONE"/>
+        <enum               name="VK_ACCESS_2_NONE_KHR" alias="VK_ACCESS_2_NONE"/>
+        <enum bitpos="0"    name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR" alias="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"/>
+        <enum bitpos="1"    name="VK_ACCESS_2_INDEX_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_INDEX_READ_BIT_KHR" alias="VK_ACCESS_2_INDEX_READ_BIT"/>
+        <enum bitpos="2"    name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR" alias="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"/>
+        <enum bitpos="3"    name="VK_ACCESS_2_UNIFORM_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_UNIFORM_READ_BIT_KHR" alias="VK_ACCESS_2_UNIFORM_READ_BIT"/>
+        <enum bitpos="4"    name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"/>
+        <enum bitpos="5"    name="VK_ACCESS_2_SHADER_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_SHADER_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_READ_BIT"/>
+        <enum bitpos="6"    name="VK_ACCESS_2_SHADER_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_SHADER_WRITE_BIT_KHR" alias="VK_ACCESS_2_SHADER_WRITE_BIT"/>
+        <enum bitpos="7"    name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"/>
+        <enum bitpos="8"    name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR" alias="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"/>
+        <enum bitpos="9"    name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"/>
+        <enum bitpos="10"   name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR" alias="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"/>
+        <enum bitpos="11"   name="VK_ACCESS_2_TRANSFER_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_TRANSFER_READ_BIT_KHR" alias="VK_ACCESS_2_TRANSFER_READ_BIT"/>
+        <enum bitpos="12"   name="VK_ACCESS_2_TRANSFER_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR" alias="VK_ACCESS_2_TRANSFER_WRITE_BIT"/>
+        <enum bitpos="13"   name="VK_ACCESS_2_HOST_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_HOST_READ_BIT_KHR" alias="VK_ACCESS_2_HOST_READ_BIT"/>
+        <enum bitpos="14"   name="VK_ACCESS_2_HOST_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_HOST_WRITE_BIT_KHR" alias="VK_ACCESS_2_HOST_WRITE_BIT"/>
+        <enum bitpos="15"   name="VK_ACCESS_2_MEMORY_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_MEMORY_READ_BIT_KHR" alias="VK_ACCESS_2_MEMORY_READ_BIT"/>
+        <enum bitpos="16"   name="VK_ACCESS_2_MEMORY_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_MEMORY_WRITE_BIT_KHR" alias="VK_ACCESS_2_MEMORY_WRITE_BIT"/>
+            <comment>bitpos 17-31 are specified by extensions to the original VkAccessFlagBits enum</comment>
+        <enum bitpos="32"   name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"/>
+        <enum bitpos="33"   name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT"/>
+        <enum               name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_STORAGE_READ_BIT"/>
+        <enum bitpos="34"   name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"/>
+        <enum               name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR" alias="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"/>
+    </enums>
+    <enums name="VkPipelineStageFlagBits2" type="bitmask" bitwidth="64">
+        <enum value="0"    name="VK_PIPELINE_STAGE_2_NONE"/>
+        <enum               name="VK_PIPELINE_STAGE_2_NONE_KHR" alias="VK_PIPELINE_STAGE_2_NONE"/>
+        <enum bitpos="0"    name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"/>
+        <enum bitpos="1"    name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"/>
+        <enum bitpos="2"    name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"/>
+        <enum bitpos="3"    name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"/>
+        <enum bitpos="4"    name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"/>
+        <enum bitpos="5"    name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"/>
+        <enum bitpos="6"    name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"/>
+        <enum bitpos="7"    name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"/>
+        <enum bitpos="8"    name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"/>
+        <enum bitpos="9"    name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
+        <enum bitpos="10"   name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
+        <enum bitpos="11"   name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
+        <enum bitpos="12"   name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TRANSFER_BIT" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
+        <enum bitpos="13"   name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"/>
+        <enum bitpos="14"   name="VK_PIPELINE_STAGE_2_HOST_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_HOST_BIT_KHR" alias="VK_PIPELINE_STAGE_2_HOST_BIT"/>
+        <enum bitpos="15"   name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"/>
+        <enum bitpos="16"   name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"/>
+            <comment>bitpos 17-31 are specified by extensions to the original VkPipelineStageFlagBits enum</comment>
+        <enum bitpos="32"   name="VK_PIPELINE_STAGE_2_COPY_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_COPY_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COPY_BIT"/>
+        <enum bitpos="33"   name="VK_PIPELINE_STAGE_2_RESOLVE_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_RESOLVE_BIT"/>
+        <enum bitpos="34"   name="VK_PIPELINE_STAGE_2_BLIT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_BLIT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_BLIT_BIT"/>
+        <enum bitpos="35"   name="VK_PIPELINE_STAGE_2_CLEAR_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR" alias="VK_PIPELINE_STAGE_2_CLEAR_BIT"/>
+        <enum bitpos="36"   name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
+        <enum bitpos="37"   name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
+        <enum bitpos="38"   name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"/>
+        <enum               name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"/>
+    </enums>
+    <enums name="VkSubmitFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SUBMIT_PROTECTED_BIT"/>
+        <enum               name="VK_SUBMIT_PROTECTED_BIT_KHR" alias="VK_SUBMIT_PROTECTED_BIT"/>
+    </enums>
+    <enums name="VkEventCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineLayoutCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkSciSyncClientTypeNV" type="enum">
+        <enum value="0"    name="VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV"/>
+        <enum value="1"    name="VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV"/>
+        <enum value="2"    name="VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV"/>
+    </enums>
+    <enums name="VkSciSyncPrimitiveTypeNV" type="enum">
+        <enum value="0"   name="VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV"/>
+        <enum value="1"   name="VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV"/>
+    </enums>
+    <enums name="VkProvokingVertexModeEXT" type="enum">
+        <enum value="0"     name="VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT"/>
+        <enum value="1"     name="VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT"/>
+    </enums>
+    <enums name="VkPipelineCacheValidationVersion" type="enum">
+        <enum value="1"     name="VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE"/>
+    </enums>
+    <enums name="VkAccelerationStructureMotionInstanceTypeNV" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"/>
+    </enums>
+    <enums name="VkPipelineColorBlendStateCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineDepthStencilStateCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkGraphicsPipelineLibraryFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"   name="VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT"/>
+        <enum bitpos="1"   name="VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT"/>
+        <enum bitpos="2"   name="VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT"/>
+        <enum bitpos="3"   name="VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT"/>
+    </enums>
+    <enums name="VkDeviceAddressBindingFlagBitsEXT" type="bitmask">
+        <enum bitpos="0" name="VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT"/>
+    </enums>
+    <enums name="VkDeviceAddressBindingTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT"/>
+        <enum value="1"     name="VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT"/>
+    </enums>
+    <enums name="VkFrameBoundaryFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"     name="VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT"/>
+    </enums>
+    <enums name="VkPresentScalingFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_PRESENT_SCALING_STRETCH_BIT_EXT"/>
+    </enums>
+    <enums name="VkPresentGravityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_PRESENT_GRAVITY_MIN_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_PRESENT_GRAVITY_MAX_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_PRESENT_GRAVITY_CENTERED_BIT_EXT"/>
+    </enums>
+    <enums name="VkPhysicalDeviceSchedulingControlsFlagBitsARM" type="bitmask">
+        <enum bitpos="0"    name="VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM"/>
+    </enums>
+
+    <enums name="VkVideoCodecOperationFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_CODEC_OPERATION_NONE_KHR"/>
+    </enums>
+    <enums name="VkVideoChromaSubsamplingFlagBitsKHR" type="bitmask" comment="Vulkan video chroma subsampling definitions">
+        <enum value="0"     name="VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoComponentBitDepthFlagBitsKHR" type="bitmask" comment="Vulkan video component bit depth definitions">
+        <enum value="0"     name="VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoCapabilityFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoSessionCreateFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoDecodeH264PictureLayoutFlagBitsKHR" type="bitmask">
+        <enum value="0"       name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"/>
+        <enum bitpos="0"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"/>
+        <enum bitpos="1"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoCodingControlFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"/>
+    </enums>
+    <enums name="VkQueryResultStatusKHR" type="enum">
+        <enum value="-1"    name="VK_QUERY_RESULT_STATUS_ERROR_KHR"/>
+        <enum value="0"     name="VK_QUERY_RESULT_STATUS_NOT_READY_KHR"/>
+        <enum value="1"     name="VK_QUERY_RESULT_STATUS_COMPLETE_KHR"/>
+    </enums>
+    <enums name="VkVideoDecodeUsageFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_DECODE_USAGE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoDecodeCapabilityFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeUsageFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeContentFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeTuningModeKHR" type="enum">
+        <enum value="0"     name="VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR"/>
+        <enum value="1"     name="VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR"/>
+        <enum value="2"     name="VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR"/>
+        <enum value="3"     name="VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR"/>
+        <enum value="4"     name="VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeCapabilityFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeFeedbackFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeRateControlModeFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeH264CapabilityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/>
+        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/>
+        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/>
+        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH264StdFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT"/>
+        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT"/>
+        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT"/>
+        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="10"   name="VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT"/>
+        <enum bitpos="11"   name="VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT"/>
+        <enum bitpos="12"   name="VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="13"   name="VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT"/>
+        <enum bitpos="14"   name="VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="15"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT"/>
+        <enum bitpos="16"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT"/>
+        <enum bitpos="17"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT"/>
+        <enum bitpos="19"   name="VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_EXT"/>
+        <enum bitpos="20"   name="VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH264RateControlFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT"/>
+    </enums>
+    <enums name="VkHostImageCopyFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_HOST_IMAGE_COPY_MEMCPY_EXT"/>
+    </enums>
+    <enums name="VkImageFormatConstraintsFlagBitsFUCHSIA" type="bitmask">
+    </enums>
+    <enums name="VkImageConstraintsInfoFlagBitsFUCHSIA" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA"/>
+        <enum bitpos="1"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA"/>
+        <enum bitpos="2"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA"/>
+        <enum bitpos="3"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA"/>
+        <enum bitpos="4"    name="VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA"/>
+    </enums>
+    <enums name="VkFormatFeatureFlagBits2" type="bitmask" bitwidth="64">
+        <enum bitpos="0"    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"/>
+        <enum bitpos="1"    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"/>
+        <enum bitpos="2"    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"/>
+        <enum bitpos="3"    name="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
+        <enum bitpos="4"    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"/>
+        <enum bitpos="5"    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"/>
+        <enum bitpos="6"    name="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"/>
+        <enum bitpos="7"    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"/>
+        <enum bitpos="8"    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"/>
+        <enum bitpos="9"    name="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"/>
+        <enum bitpos="10"   name="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"/>
+        <enum bitpos="11"   name="VK_FORMAT_FEATURE_2_BLIT_DST_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_2_BLIT_DST_BIT"/>
+        <enum bitpos="12"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"/>
+        <enum bitpos="13"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"/>
+        <enum bitpos="14"   name="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"/>
+        <enum bitpos="15"   name="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"/>
+        <enum bitpos="16"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
+        <enum bitpos="17"   name="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"/>
+        <enum bitpos="18"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
+        <enum bitpos="19"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
+        <enum bitpos="20"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+        <enum bitpos="21"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+        <enum bitpos="22"   name="VK_FORMAT_FEATURE_2_DISJOINT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_DISJOINT_BIT"/>
+        <enum bitpos="23"   name="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"/>
+        <enum bitpos="31"   name="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"/>
+        <enum bitpos="32"   name="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"/>
+        <enum bitpos="33"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"/>
+        <enum               name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"/>
+    </enums>
+    <enums name="VkRenderingFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"/>
+        <enum               name="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR" alias="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"/>
+        <enum bitpos="1"    name="VK_RENDERING_SUSPENDING_BIT"/>
+        <enum               name="VK_RENDERING_SUSPENDING_BIT_KHR" alias="VK_RENDERING_SUSPENDING_BIT"/>
+        <enum bitpos="2"    name="VK_RENDERING_RESUMING_BIT"/>
+        <enum               name="VK_RENDERING_RESUMING_BIT_KHR" alias="VK_RENDERING_RESUMING_BIT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265CapabilityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/>
+        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/>
+        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/>
+        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT"/>
+        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265StdFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT"/>
+        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT"/>
+        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="10"   name="VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="11"   name="VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT"/>
+        <enum bitpos="12"   name="VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="13"   name="VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="14"   name="VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="15"   name="VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="16"   name="VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="17"   name="VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="18"   name="VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT"/>
+        <enum bitpos="19"   name="VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_EXT"/>
+        <enum bitpos="20"   name="VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265RateControlFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/>
+        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/>
+        <enum bitpos="4"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265CtbSizeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265TransformBlockSizeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT"/>
+        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT"/>
+    </enums>
+    <enums name="VkExportMetalObjectTypeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT"/>
+        <enum bitpos="3"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT"/>
+        <enum bitpos="4"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT"/>
+        <enum bitpos="5"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT"/>
+    </enums>
+    <enums name="VkInstanceCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkImageCompressionFlagBitsEXT" type="bitmask">
+        <enum value="0"      name="VK_IMAGE_COMPRESSION_DEFAULT_EXT"/>
+        <enum bitpos="0"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT"/>
+        <enum bitpos="1"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT"/>
+        <enum bitpos="2"     name="VK_IMAGE_COMPRESSION_DISABLED_EXT"/>
+    </enums>
+    <enums name="VkImageCompressionFixedRateFlagBitsEXT" type="bitmask">
+        <enum value="0"      name="VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT"/>
+        <enum bitpos="0"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT"/>
+        <enum bitpos="1"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT"/>
+        <enum bitpos="2"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT"/>
+        <enum bitpos="3"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT"/>
+        <enum bitpos="4"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT"/>
+        <enum bitpos="5"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT"/>
+        <enum bitpos="6"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT"/>
+        <enum bitpos="7"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT"/>
+        <enum bitpos="8"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT"/>
+        <enum bitpos="9"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT"/>
+        <enum bitpos="10"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT"/>
+        <enum bitpos="11"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT"/>
+        <enum bitpos="12"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT"/>
+        <enum bitpos="13"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT"/>
+        <enum bitpos="14"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT"/>
+        <enum bitpos="15"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT"/>
+        <enum bitpos="16"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT"/>
+        <enum bitpos="17"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT"/>
+        <enum bitpos="18"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT"/>
+        <enum bitpos="19"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT"/>
+        <enum bitpos="20"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT"/>
+        <enum bitpos="21"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT"/>
+        <enum bitpos="22"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT"/>
+        <enum bitpos="23"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT"/>
+    </enums>
+    <enums name="VkPipelineRobustnessBufferBehaviorEXT" type="enum">
+        <enum value="0"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT" />
+        <enum value="1"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT" />
+        <enum value="2"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT" />
+        <enum value="3"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT" />
+    </enums>
+    <enums name="VkPipelineRobustnessImageBehaviorEXT" type="enum">
+        <enum value="0"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT" />
+        <enum value="1"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT" />
+        <enum value="2"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT" />
+        <enum value="3"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT" />
+    </enums>
+    <enums name="VkOpticalFlowGridSizeFlagBitsNV" type="bitmask">
+        <enum value="0"       name="VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV"/>
+        <enum bitpos="0"      name="VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV"/>
+        <enum bitpos="1"      name="VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV"/>
+        <enum bitpos="2"      name="VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV"/>
+        <enum bitpos="3"      name="VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV"/>
+    </enums>
+    <enums name="VkOpticalFlowUsageFlagBitsNV" type="bitmask">
+        <enum value="0"       name="VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV"/>
+        <enum bitpos="0"      name="VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV"/>
+        <enum bitpos="1"      name="VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV"/>
+        <enum bitpos="2"      name="VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV"/>
+        <enum bitpos="3"      name="VK_OPTICAL_FLOW_USAGE_COST_BIT_NV"/>
+        <enum bitpos="4"      name="VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV"/>
+    </enums>
+    <enums name="VkOpticalFlowPerformanceLevelNV" type="enum">
+        <enum value="0"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV"/>
+        <enum value="1"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV"/>
+        <enum value="2"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV"/>
+        <enum value="3"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV"/>
+    </enums>
+    <enums name="VkOpticalFlowSessionBindingPointNV" type="enum">
+        <enum value="0"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV"/>
+        <enum value="1"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV"/>
+        <enum value="2"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV"/>
+        <enum value="3"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV"/>
+        <enum value="4"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV"/>
+        <enum value="5"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV"/>
+        <enum value="6"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV"/>
+        <enum value="7"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV"/>
+        <enum value="8"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV"/>
+    </enums>
+    <enums name="VkOpticalFlowSessionCreateFlagBitsNV" type="bitmask">
+        <enum bitpos="0"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV"/>
+        <enum bitpos="1"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV"/>
+        <enum bitpos="2"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV"/>
+        <enum bitpos="3"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV"/>
+        <enum bitpos="4"      name="VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV"/>
+    </enums>
+    <enums name="VkOpticalFlowExecuteFlagBitsNV" type="bitmask">
+        <enum bitpos="0"      name="VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV"/>
+    </enums>
+    <enums name="VkMicromapTypeEXT" type="enum">
+        <enum value="0" name="VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT"/>
+    </enums>
+    <enums name="VkBuildMicromapFlagBitsEXT" type="bitmask">
+        <enum bitpos="0" name="VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT"/>
+        <enum bitpos="1" name="VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT"/>
+        <enum bitpos="2" name="VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT"/>
+    </enums>
+    <enums name="VkMicromapCreateFlagBitsEXT" type="bitmask">
+        <enum bitpos="0" name="VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"/>
+    </enums>
+    <enums name="VkCopyMicromapModeEXT" type="enum">
+        <enum value="0" name="VK_COPY_MICROMAP_MODE_CLONE_EXT"/>
+        <enum value="1" name="VK_COPY_MICROMAP_MODE_SERIALIZE_EXT"/>
+        <enum value="2" name="VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT"/>
+        <enum value="3" name="VK_COPY_MICROMAP_MODE_COMPACT_EXT"/>
+    </enums>
+    <enums name="VkBuildMicromapModeEXT" type="enum">
+        <enum value="0" name="VK_BUILD_MICROMAP_MODE_BUILD_EXT"/>
+    </enums>
+    <enums name="VkOpacityMicromapFormatEXT" type="enum">
+        <enum value="1" name="VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT"/>
+        <enum value="2" name="VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT"/>
+    </enums>
+    <enums name="VkOpacityMicromapSpecialIndexEXT" type="enum">
+        <enum value="-1" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT"/>
+        <enum value="-2" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT"/>
+        <enum value="-3" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT"/>
+        <enum value="-4" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT"/>
+    </enums>
+    <enums name="VkDepthBiasRepresentationEXT" type="enum">
+        <enum value="0"     name="VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT"/>
+        <enum value="1"     name="VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT"/>
+        <enum value="2"     name="VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT"/>
+    </enums>
+    <enums name="VkDeviceFaultAddressTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT" comment="Currently unused"/>
+        <enum value="1"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT"/>
+        <enum value="2"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT"/>
+        <enum value="3"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT"/>
+        <enum value="4"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT"/>
+        <enum value="5"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT"/>
+        <enum value="6"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT"/>
+    </enums>
+    <enums name="VkDeviceFaultVendorBinaryHeaderVersionEXT" type="enum">
+        <enum value="1"     name="VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT"/>
+    </enums>
+    <enums name="VkDisplacementMicromapFormatNV" type="enum">
+        <enum value="1" name="VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV"/>
+        <enum value="2" name="VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/>
+        <enum value="3" name="VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/>
+    </enums>
+    <enums name="VkShaderCreateFlagBitsEXT" type="bitmask">
+        <enum bitpos="0" name="VK_SHADER_CREATE_LINK_STAGE_BIT_EXT"/>
+    </enums>
+    <enums name="VkShaderCodeTypeEXT" type="enum">
+        <enum value="0" name="VK_SHADER_CODE_TYPE_BINARY_EXT"/>
+        <enum value="1" name="VK_SHADER_CODE_TYPE_SPIRV_EXT"/>
+    </enums>
+    <enums name="VkScopeKHR" type="enum">
+        <enum value="1"     name="VK_SCOPE_DEVICE_KHR"/>
+        <enum value="2"     name="VK_SCOPE_WORKGROUP_KHR"/>
+        <enum value="3"     name="VK_SCOPE_SUBGROUP_KHR"/>
+        <enum value="5"     name="VK_SCOPE_QUEUE_FAMILY_KHR"/>
+    </enums>
+    <enums name="VkComponentTypeKHR" type="enum">
+        <enum value="0"     name="VK_COMPONENT_TYPE_FLOAT16_KHR"/>
+        <enum value="1"     name="VK_COMPONENT_TYPE_FLOAT32_KHR"/>
+        <enum value="2"     name="VK_COMPONENT_TYPE_FLOAT64_KHR"/>
+        <enum value="3"     name="VK_COMPONENT_TYPE_SINT8_KHR"/>
+        <enum value="4"     name="VK_COMPONENT_TYPE_SINT16_KHR"/>
+        <enum value="5"     name="VK_COMPONENT_TYPE_SINT32_KHR"/>
+        <enum value="6"     name="VK_COMPONENT_TYPE_SINT64_KHR"/>
+        <enum value="7"     name="VK_COMPONENT_TYPE_UINT8_KHR"/>
+        <enum value="8"     name="VK_COMPONENT_TYPE_UINT16_KHR"/>
+        <enum value="9"     name="VK_COMPONENT_TYPE_UINT32_KHR"/>
+        <enum value="10"    name="VK_COMPONENT_TYPE_UINT64_KHR"/>
+    </enums>
+    <enums name="VkCubicFilterWeightsQCOM" type="enum">
+        <enum value="0"     name="VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM"/>
+        <enum value="1"     name="VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM"/>
+        <enum value="2"     name="VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM"/>
+        <enum value="3"     name="VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM"/>
+    </enums>
+    <enums name="VkBlockMatchWindowCompareModeQCOM" type="enum">
+        <enum value="0" name="VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM"/>
+        <enum value="1" name="VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM"/>
+    </enums>
+    <enums name="VkLayeredDriverUnderlyingApiMSFT" type="enum">
+        <enum value="0" name="VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT"/>
+        <enum value="1" name="VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT"/>
+    </enums>
+    <enums name="VkLatencyMarkerNV" type="enum">
+        <enum value="0"    name="VK_LATENCY_MARKER_SIMULATION_START_NV"/>
+        <enum value="1"    name="VK_LATENCY_MARKER_SIMULATION_END_NV"/>
+        <enum value="2"    name="VK_LATENCY_MARKER_RENDERSUBMIT_START_NV"/>
+        <enum value="3"    name="VK_LATENCY_MARKER_RENDERSUBMIT_END_NV"/>
+        <enum value="4"    name="VK_LATENCY_MARKER_PRESENT_START_NV"/>
+        <enum value="5"    name="VK_LATENCY_MARKER_PRESENT_END_NV"/>
+        <enum value="6"    name="VK_LATENCY_MARKER_INPUT_SAMPLE_NV"/>
+        <enum value="7"    name="VK_LATENCY_MARKER_TRIGGER_FLASH_NV"/>
+        <enum value="8"    name="VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV"/>
+        <enum value="9"    name="VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV"/>
+        <enum value="10"   name="VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV"/>
+        <enum value="11"   name="VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV"/>
+    </enums>
+    <enums name="VkOutOfBandQueueTypeNV" type="enum">
+        <enum value="0"    name="VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV"/>
+        <enum value="1"    name="VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV"/>
+    </enums>
+
+    <commands comment="Vulkan command definitions">
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
+            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
+            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkInstance</type>* <name>pInstance</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
+            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkPhysicalDevice objects enumerated from pname:instance</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
+            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
+        </command>
+        <command>
+            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
+        </command>
+        <command>
+            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
+            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
+            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
+            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDevice</type>* <name>pDevice</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST,VK_ERROR_INVALID_PIPELINE_CACHE_DATA">
+            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDevice</type>* <name>pDevice</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
+            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkQueue objects created from pname:device</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceVersion</name></proto>
+            <param><type>uint32_t</type>* <name>pApiVersion</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
+            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
+        </command>
+
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
+            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>uint32_t</type> <name>queueIndex</name></param>
+            <param><type>VkQueue</type>* <name>pQueue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
+            <param len="submitCount">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkQueue objects created from pname:device</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkFreeMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkDeviceSize</type> <name>size</name></param>
+            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
+            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
+            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
+            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkImage</type> <name>image</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command queues="sparse_binding" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyFence</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>fenceCount</name></param>
+            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>fenceCount</name></param>
+            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
+            <param><type>VkBool32</type> <name>waitAll</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkEvent</type>* <name>pEvent</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+            <param><type>VkDeviceSize</type> <name>stride</name></param>
+            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkResetQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+        </command>
+        <command name="vkResetQueryPoolEXT"                        alias="vkResetQueryPool"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBufferView</type>* <name>pView</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkImage</type>* <name>pImage</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyImage</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
+            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkImageView</type>* <name>pView</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_PIPELINE_CACHE_DATA">
+            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkPipelineCache</type> <name>dstCache</name></param>
+            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
+            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkRenderPass</type> <name>renderpass</name></param>
+            <param><type>VkExtent2D</type>* <name>pMaxWorkgroupSize</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSampler</type>* <name>pSampler</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySampler</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
+            <implicitexternsyncparams>
+                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pAllocateInfo-&gt;descriptorPool">const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param len="pAllocateInfo-&gt;descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
+            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
+            <param len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
+            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
+            <param len="descriptorCopyCount">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkRenderPass</type> <name>renderPass</name></param>
+            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetRenderingAreaGranularityKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderingAreaInfoKHR</type>* <name>pRenderingAreaInfo</name></param>
+            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pAllocateInfo-&gt;commandPool">const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param len="pAllocateInfo-&gt;commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
+            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR">
+            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetAttachmentFeedbackLoopEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstScissor</name></param>
+            <param><type>uint32_t</type> <name>scissorCount</name></param>
+            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>lineWidth</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
+            <param><type>float</type> <name>depthBiasClamp</name></param>
+            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>minDepthBounds</name></param>
+            <param><type>float</type> <name>maxDepthBounds</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>compareMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>writeMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>reference</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>firstSet</name></param>
+            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
+            <param len="descriptorSetCount" optional="false,true">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
+            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkIndexType</type> <name>indexType</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDraw</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>vertexCount</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstVertex</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>indexCount</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstIndex</name></param>
+            <param><type>int32_t</type> <name>vertexOffset</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMultiEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
+            <param noautovalidity="true" len="drawCount" stride="stride">const <type>VkMultiDrawInfoEXT</type>* <name>pVertexInfo</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMultiIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
+            <param noautovalidity="true" len="drawCount" stride="stride">const <type>VkMultiDrawIndexedInfoEXT</type>* <name>pIndexInfo</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+            <param optional="true">const <type>int32_t</type>* <name>pVertexOffset</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdSubpassShadingHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawClusterHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawClusterIndirectHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdUpdatePipelineIndirectBufferNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type>           <name>pipelineBindPoint</name></param>
+            <param><type>VkPipeline</type>                    <name>pipeline</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
+            <param><type>VkFilter</type> <name>filter</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMemoryIndirectNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type> <name>copyBufferAddress</name></param>
+            <param><type>uint32_t</type> <name>copyCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMemoryToImageIndirectNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type> <name>copyBufferAddress</name></param>
+            <param><type>uint32_t</type> <name>copyCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param len="copyCount">const <type>VkImageSubresourceLayers</type>* <name>pImageSubresources</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
+            <param len="dataSize">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action" comment="transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification">
+            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>size</name></param>
+            <param><type>uint32_t</type> <name>data</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+            <param noautovalidity="true">const <type>VkClearColorValue</type>* <name>pColor</name></param>
+            <param><type>uint32_t</type> <name>rangeCount</name></param>
+            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
+            <param><type>uint32_t</type> <name>rangeCount</name></param>
+            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
+            <param><type>uint32_t</type> <name>rectCount</name></param>
+            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>eventCount</name></param>
+            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
+            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
+            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
+            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
+            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
+        </command>
+        <command queues="transfer,graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
+            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
+            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
+            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
+            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
+            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginConditionalRenderingEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkConditionalRenderingBeginInfoEXT</type>* <name>pConditionalRenderingBegin</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndConditionalRenderingEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode,opticalflow" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+        </command>
+        <command queues="transfer,graphics,compute,decode,encode,opticalflow" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>stride</name></param>
+            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
+            <param><type>uint32_t</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>size</name></param>
+            <param len="size">const <type>void</type>* <name>pValues</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
+            <param><type>VkSubpassContents</type> <name>contents</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkSubpassContents</type> <name>contents</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="indirection">
+            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
+            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>planeIndex</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
+            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
+            <param><type>uint32_t</type> <name>planeIndex</name></param>
+            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>swapchainCount</name></param>
+            <param api="vulkan" len="swapchainCount" externsync="pCreateInfos[].surface,pCreateInfos[].oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param api="vulkansc" len="swapchainCount" externsync="pCreateInfos[].surface">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkBool32</type>* <name>pSupported</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
+            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
+            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT">
+            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param api="vulkan" externsync="pCreateInfo-&gt;surface,pCreateInfo-&gt;oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param api="vulkansc" externsync="pCreateInfo-&gt;surface">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
+            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param externsync="pPresentInfo-&gt;pWaitSemaphores[],pPresentInfo-&gt;pSwapchains[]">const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateViSurfaceNN</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkViSurfaceCreateInfoNN</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param>struct <type>wl_display</type>* <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>VisualID</type> <name>visualID</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>xcb_connection_t</type>* <name>connection</name></param>
+            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDirectFBSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDirectFBSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceDirectFBPresentationSupportEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>IDirectFB</type>* <name>dfb</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateImagePipeSurfaceFUCHSIA</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkImagePipeSurfaceCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateStreamDescriptorSurfaceGGP</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkStreamDescriptorSurfaceCreateInfoGGP</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateScreenSurfaceQNX</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkScreenSurfaceCreateInfoQNX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceScreenPresentationSupportQNX</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param>struct <type>_screen_window</type>* <name>window</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
+            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>object</name></param>
+            <param><type>size_t</type> <name>location</name></param>
+            <param><type>int32_t</type> <name>messageCode</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pLayerPrefix</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pMessage</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pNameInfo-&gt;object">const <type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pTagInfo-&gt;object">const <type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
+            <param optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>externalHandleType</name></param>
+            <param><type>VkExternalImageFormatPropertiesNV</type>* <name>pExternalImageFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action,indirection">
+            <proto><type>void</type> <name>vkCmdExecuteGeneratedCommandsNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>isPreprocessed</name></param>
+            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdPreprocessGeneratedCommandsNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindPipelineShaderGroupNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>groupIndex</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetGeneratedCommandsMemoryRequirementsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkGeneratedCommandsMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkIndirectCommandsLayoutCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkIndirectCommandsLayoutNV</type>* <name>pIndirectCommandsLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkIndirectCommandsLayoutNV</type> <name>indirectCommandsLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceFeatures2</type>* <name>pFeatures</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceFeatures2KHR"                        alias="vkGetPhysicalDeviceFeatures2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceProperties2</type>* <name>pProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceProperties2KHR"                      alias="vkGetPhysicalDeviceProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkFormatProperties2</type>* <name>pFormatProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceFormatProperties2KHR"                alias="vkGetPhysicalDeviceFormatProperties2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceImageFormatInfo2</type>* <name>pImageFormatInfo</name></param>
+            <param><type>VkImageFormatProperties2</type>* <name>pImageFormatProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"           alias="vkGetPhysicalDeviceImageFormatProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
+            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties2</type>* <name>pQueueFamilyProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"           alias="vkGetPhysicalDeviceQueueFamilyProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceMemoryProperties2</type>* <name>pMemoryProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceMemoryProperties2KHR"                alias="vkGetPhysicalDeviceMemoryProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSparseImageFormatInfo2</type>* <name>pFormatInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties2</type>* <name>pProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"     alias="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdPushDescriptorSetKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>set</name></param>
+            <param><type>uint32_t</type> <name>descriptorWriteCount</name></param>
+            <param len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkTrimCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true"><type>VkCommandPoolTrimFlags</type> <name>flags</name></param>
+        </command>
+        <command name="vkTrimCommandPoolKHR"                                   alias="vkTrimCommandPool"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalBufferProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalBufferInfo</type>* <name>pExternalBufferInfo</name></param>
+            <param><type>VkExternalBufferProperties</type>* <name>pExternalBufferProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"         alias="vkGetPhysicalDeviceExternalBufferProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandlePropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>HANDLE</type> <name>handle</name></param>
+            <param><type>VkMemoryWin32HandlePropertiesKHR</type>* <name>pMemoryWin32HandleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryFdPropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>int</type> <name>fd</name></param>
+            <param><type>VkMemoryFdPropertiesKHR</type>* <name>pMemoryFdProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
+            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandlePropertiesFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>zx_handle_t</type> <name>zirconHandle</name></param>
+            <param><type>VkMemoryZirconHandlePropertiesFUCHSIA</type>* <name>pMemoryZirconHandleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryRemoteAddressNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetRemoteAddressInfoNV</type>* <name>pMemoryGetRemoteAddressInfo</name></param>
+            <param><type>VkRemoteAddressNV</type>* <name>pAddress</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetMemorySciBufNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetSciBufInfoNV</type>* <name>pGetSciBufInfo</name></param>
+            <param><type>NvSciBufObj</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>NvSciBufObj</type> <name>handle</name></param>
+            <param><type>VkMemorySciBufPropertiesNV</type>* <name>pMemorySciBufProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSciBufAttributesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>NvSciBufAttrList</type> <name>pAttributes</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalSemaphoreProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalSemaphoreInfo</type>* <name>pExternalSemaphoreInfo</name></param>
+            <param><type>VkExternalSemaphoreProperties</type>* <name>pExternalSemaphoreProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"      alias="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreWin32HandleInfoKHR</type>* <name>pImportSemaphoreWin32HandleInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreFdInfoKHR</type>* <name>pImportSemaphoreFdInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
+            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreZirconHandleInfoFUCHSIA</type>* <name>pImportSemaphoreZirconHandleInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalFenceProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalFenceInfo</type>* <name>pExternalFenceInfo</name></param>
+            <param><type>VkExternalFenceProperties</type>* <name>pExternalFenceProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"          alias="vkGetPhysicalDeviceExternalFenceProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetFenceWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportFenceWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceWin32HandleInfoKHR</type>* <name>pImportFenceWin32HandleInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetFenceFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportFenceFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceFdInfoKHR</type>* <name>pImportFenceFdInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT">
+            <proto><type>VkResult</type> <name>vkGetFenceSciSyncFenceNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetSciSyncInfoNV</type>* <name>pGetSciSyncHandleInfo</name></param>
+            <param><type>void</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT">
+            <proto><type>VkResult</type> <name>vkGetFenceSciSyncObjNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetSciSyncInfoNV</type>* <name>pGetSciSyncHandleInfo</name></param>
+            <param><type>void</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT">
+            <proto><type>VkResult</type> <name>vkImportFenceSciSyncFenceNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceSciSyncInfoNV</type>* <name>pImportFenceSciSyncInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT">
+            <proto><type>VkResult</type> <name>vkImportFenceSciSyncObjNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceSciSyncInfoNV</type>* <name>pImportFenceSciSyncInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreSciSyncObjNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetSciSyncInfoNV</type>* <name>pGetSciSyncInfo</name></param>
+            <param><type>void</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED_EXT,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreSciSyncObjNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreSciSyncInfoNV</type>* <name>pImportSemaphoreSciSyncInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSciSyncAttributesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkSciSyncAttributesInfoNV</type>* <name>pSciSyncAttributesInfo</name></param>
+            <param><type>NvSciSyncAttrList</type> <name>pAttributes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSemaphoreSciSyncPoolNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreSciSyncPoolCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSemaphoreSciSyncPoolNV</type>* <name>pSemaphorePool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySemaphoreSciSyncPoolNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSemaphoreSciSyncPoolNV</type> <name>semaphorePool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkReleaseDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireXlibDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRandROutputDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>RROutput</type> <name>rrOutput</name></param>
+            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireWinrtDisplayNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetWinrtDisplayNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>deviceRelativeId</name></param>
+            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkDisplayPowerControlEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayPowerInfoEXT</type>* <name>pDisplayPowerInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkRegisterDeviceEventEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceEventInfoEXT</type>* <name>pDeviceEventInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkRegisterDisplayEventEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayEventInfoEXT</type>* <name>pDisplayEventInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR">
+            <proto><type>VkResult</type> <name>vkGetSwapchainCounterEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>VkSurfaceCounterFlagBitsEXT</type> <name>counter</name></param>
+            <param><type>uint64_t</type>* <name>pCounterValue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2EXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkSurfaceCapabilities2EXT</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceGroups</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceGroupCount</name></param>
+            <param optional="true" len="pPhysicalDeviceGroupCount"><type>VkPhysicalDeviceGroupProperties</type>* <name>pPhysicalDeviceGroupProperties</name></param>
+        </command>
+        <command name="vkEnumeratePhysicalDeviceGroupsKHR"                     alias="vkEnumeratePhysicalDeviceGroups"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceGroupPeerMemoryFeatures</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>heapIndex</name></param>
+            <param><type>uint32_t</type> <name>localDeviceIndex</name></param>
+            <param><type>uint32_t</type> <name>remoteDeviceIndex</name></param>
+            <param><type>VkPeerMemoryFeatureFlags</type>* <name>pPeerMemoryFeatures</name></param>
+        </command>
+        <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"                  alias="vkGetDeviceGroupPeerMemoryFeatures"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkBindBufferMemory2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindBufferMemoryInfo</type>* <name>pBindInfos</name></param>
+        </command>
+        <command name="vkBindBufferMemory2KHR"                                 alias="vkBindBufferMemory2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindImageMemory2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindImageMemoryInfo</type>* <name>pBindInfos</name></param>
+        </command>
+        <command name="vkBindImageMemory2KHR"                                  alias="vkBindImageMemory2"/>
+        <command queues="graphics,compute,transfer" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDeviceMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>deviceMask</name></param>
+        </command>
+        <command name="vkCmdSetDeviceMaskKHR"                                  alias="vkCmdSetDeviceMask"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupPresentCapabilitiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceGroupPresentCapabilitiesKHR</type>* <name>pDeviceGroupPresentCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkAcquireNextImage2KHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAcquireNextImageInfoKHR</type>* <name>pAcquireInfo</name></param>
+            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDispatchBase</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>baseGroupX</name></param>
+            <param><type>uint32_t</type> <name>baseGroupY</name></param>
+            <param><type>uint32_t</type> <name>baseGroupZ</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command name="vkCmdDispatchBaseKHR"                                   alias="vkCmdDispatchBase"/>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDevicePresentRectanglesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pRectCount</name></param>
+            <param optional="true" len="pRectCount"><type>VkRect2D</type>* <name>pRects</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorUpdateTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorUpdateTemplateCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type>* <name>pDescriptorUpdateTemplate</name></param>
+        </command>
+        <command name="vkCreateDescriptorUpdateTemplateKHR"                    alias="vkCreateDescriptorUpdateTemplate"/>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorUpdateTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command name="vkDestroyDescriptorUpdateTemplateKHR"                   alias="vkDestroyDescriptorUpdateTemplate"/>
+        <command>
+            <proto><type>void</type> <name>vkUpdateDescriptorSetWithTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command name="vkUpdateDescriptorSetWithTemplateKHR"                   alias="vkUpdateDescriptorSetWithTemplate"/>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdPushDescriptorSetWithTemplateKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>set</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetHdrMetadataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>swapchainCount</name></param>
+            <param len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
+            <param len="swapchainCount">const <type>VkHdrMetadataEXT</type>* <name>pMetadata</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkGetSwapchainStatusKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetRefreshCycleDurationGOOGLE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>VkRefreshCycleDurationGOOGLE</type>* <name>pDisplayTimingProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPastPresentationTimingGOOGLE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentationTimingCount</name></param>
+            <param optional="true" len="pPresentationTimingCount"><type>VkPastPresentationTimingGOOGLE</type>* <name>pPresentationTimings</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateIOSSurfaceMVK</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkIOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateMacOSSurfaceMVK</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkMacOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateMetalSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkMetalSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewportWScalingNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewportWScalingNV</type>* <name>pViewportWScalings</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstDiscardRectangle</name></param>
+            <param><type>uint32_t</type> <name>discardRectangleCount</name></param>
+            <param len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>discardRectangleEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDiscardRectangleModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDiscardRectangleModeEXT</type> <name>discardRectangleMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetSampleLocationsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSampleLocationsInfoEXT</type>* <name>pSampleLocationsInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMultisamplePropertiesEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
+            <param><type>VkMultisamplePropertiesEXT</type>* <name>pMultisampleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param><type>VkSurfaceCapabilities2KHR</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormats2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
+            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormat2KHR</type>* <name>pSurfaceFormats</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPlaneProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayModeProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayModeProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilities2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkDisplayPlaneInfo2KHR</type>* <name>pDisplayPlaneInfo</name></param>
+            <param><type>VkDisplayPlaneCapabilities2KHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetBufferMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetBufferMemoryRequirements2KHR"                      alias="vkGetBufferMemoryRequirements2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetImageMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetImageMemoryRequirements2KHR"                       alias="vkGetImageMemoryRequirements2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageSparseMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetImageSparseMemoryRequirements2KHR"                 alias="vkGetImageSparseMemoryRequirements2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceBufferMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceBufferMemoryRequirements</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetDeviceBufferMemoryRequirementsKHR" alias="vkGetDeviceBufferMemoryRequirements"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceImageMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceImageMemoryRequirements</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetDeviceImageMemoryRequirementsKHR" alias="vkGetDeviceImageMemoryRequirements"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceImageSparseMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceImageMemoryRequirements</type>* <name>pInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetDeviceImageSparseMemoryRequirementsKHR" alias="vkGetDeviceImageSparseMemoryRequirements"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSamplerYcbcrConversion</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSamplerYcbcrConversionCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSamplerYcbcrConversion</type>* <name>pYcbcrConversion</name></param>
+        </command>
+        <command name="vkCreateSamplerYcbcrConversionKHR"                      alias="vkCreateSamplerYcbcrConversion"/>
+        <command>
+            <proto><type>void</type> <name>vkDestroySamplerYcbcrConversion</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSamplerYcbcrConversion</type> <name>ycbcrConversion</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command name="vkDestroySamplerYcbcrConversionKHR"                     alias="vkDestroySamplerYcbcrConversion"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceQueue2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceQueueInfo2</type>* <name>pQueueInfo</name></param>
+            <param><type>VkQueue</type>* <name>pQueue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateValidationCacheEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkValidationCacheCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkValidationCacheEXT</type>* <name>pValidationCache</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyValidationCacheEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetValidationCacheDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkMergeValidationCachesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkValidationCacheEXT</type> <name>dstCache</name></param>
+            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
+            <param len="srcCacheCount">const <type>VkValidationCacheEXT</type>* <name>pSrcCaches</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSupport</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param><type>VkDescriptorSetLayoutSupport</type>* <name>pSupport</name></param>
+        </command>
+        <command name="vkGetDescriptorSetLayoutSupportKHR"                     alias="vkGetDescriptorSetLayoutSupport"/>
+        <command>
+            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsageANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
+            <param><type>int</type>* <name>grallocUsage</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsage2ANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
+            <param><type>VkSwapchainImageUsageFlagsANDROID</type> <name>swapchainImageUsage</name></param>
+            <param><type>uint64_t</type>* <name>grallocConsumerUsage</name></param>
+            <param><type>uint64_t</type>* <name>grallocProducerUsage</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkAcquireImageANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>int</type> <name>nativeFenceFd</name></param>
+            <param optional="true"><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param optional="true"><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkQueueSignalReleaseImageANDROID</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param><type>uint32_t</type> <name>waitSemaphoreCount</name></param>
+            <param len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>int</type>* <name>pNativeFenceFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetShaderInfoAMD</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>VkShaderStageFlagBits</type> <name>shaderStage</name></param>
+            <param><type>VkShaderInfoTypeAMD</type> <name>infoType</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pInfoSize</name></param>
+            <param optional="true" len="pInfoSize"><type>void</type>* <name>pInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetLocalDimmingAMD</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapChain</name></param>
+            <param><type>VkBool32</type> <name>localDimmingEnable</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pTimeDomainCount</name></param>
+            <param optional="true" len="pTimeDomainCount"><type>VkTimeDomainEXT</type>* <name>pTimeDomains</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetCalibratedTimestampsEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>timestampCount</name></param>
+            <param len="timestampCount">const <type>VkCalibratedTimestampInfoEXT</type>* <name>pTimestampInfos</name></param>
+            <param len="timestampCount"><type>uint64_t</type>* <name>pTimestamps</name></param>
+            <param><type>uint64_t</type>* <name>pMaxDeviation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectNameEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pNameInfo-&gt;objectHandle">const <type>VkDebugUtilsObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectTagEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pTagInfo-&gt;objectHandle">const <type>VkDebugUtilsObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueBeginDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueEndDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueInsertDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdInsertDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDebugUtilsMessengerEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDebugUtilsMessengerCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDebugUtilsMessengerEXT</type>* <name>pMessenger</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDebugUtilsMessengerEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkDebugUtilsMessengerEXT</type> <name>messenger</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSubmitDebugUtilsMessageEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param><type>VkDebugUtilsMessageSeverityFlagBitsEXT</type> <name>messageSeverity</name></param>
+            <param><type>VkDebugUtilsMessageTypeFlagsEXT</type> <name>messageTypes</name></param>
+            <param>const <type>VkDebugUtilsMessengerCallbackDataEXT</type>* <name>pCallbackData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryHostPointerPropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param>const <type>void</type>* <name>pHostPointer</name></param>
+            <param><type>VkMemoryHostPointerPropertiesEXT</type>* <name>pMemoryHostPointerProperties</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteBufferMarkerAMD</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>uint32_t</type> <name>marker</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRenderPass2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderPassCreateInfo2</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
+        </command>
+        <command name="vkCreateRenderPass2KHR"                                 alias="vkCreateRenderPass2"/>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdBeginRenderPass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkRenderPassBeginInfo</type>*      <name>pRenderPassBegin</name></param>
+            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
+        </command>
+        <command name="vkCmdBeginRenderPass2KHR"                               alias="vkCmdBeginRenderPass2"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdNextSubpass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
+            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
+        </command>
+        <command name="vkCmdNextSubpass2KHR"                                   alias="vkCmdNextSubpass2"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
+            <proto><type>void</type> <name>vkCmdEndRenderPass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
+        </command>
+        <command name="vkCmdEndRenderPass2KHR"                                 alias="vkCmdEndRenderPass2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreCounterValue</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param><type>uint64_t</type>* <name>pValue</name></param>
+        </command>
+        <command name="vkGetSemaphoreCounterValueKHR"              alias="vkGetSemaphoreCounterValue"/>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkWaitSemaphores</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreWaitInfo</type>* <name>pWaitInfo</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command name="vkWaitSemaphoresKHR"                        alias="vkWaitSemaphores"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSignalSemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreSignalInfo</type>* <name>pSignalInfo</name></param>
+        </command>
+        <command name="vkSignalSemaphoreKHR"                       alias="vkSignalSemaphore"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR">
+            <proto><type>VkResult</type> <name>vkGetAndroidHardwareBufferPropertiesANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const struct <type>AHardwareBuffer</type>* <name>buffer</name></param>
+            <param><type>VkAndroidHardwareBufferPropertiesANDROID</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryAndroidHardwareBufferANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetAndroidHardwareBufferInfoANDROID</type>* <name>pInfo</name></param>
+            <param>struct <type>AHardwareBuffer</type>** <name>pBuffer</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndirectCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command name="vkCmdDrawIndirectCountKHR"                              alias="vkCmdDrawIndirectCount"/>
+        <command name="vkCmdDrawIndirectCountAMD"                              alias="vkCmdDrawIndirectCount"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndexedIndirectCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command name="vkCmdDrawIndexedIndirectCountKHR"                       alias="vkCmdDrawIndexedIndirectCount"/>
+        <command name="vkCmdDrawIndexedIndirectCountAMD"                       alias="vkCmdDrawIndexedIndirectCount"/>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdSetCheckpointNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pCheckpointMarker</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetQueueCheckpointDataNV</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
+            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointDataNV</type>* <name>pCheckpointData</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindTransformFeedbackBuffersEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+            <param optional="true" len="bindingCount" noautovalidity="true">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBeginTransformFeedbackEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
+            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
+            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdEndTransformFeedbackEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
+            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
+            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginQueryIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
+            <param><type>uint32_t</type> <name>index</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndQueryIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param><type>uint32_t</type> <name>index</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawIndirectByteCountEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>VkBuffer</type> <name>counterBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>counterBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>counterOffset</name></param>
+            <param><type>uint32_t</type> <name>vertexStride</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetExclusiveScissorNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
+            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
+            <param len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetExclusiveScissorEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
+            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
+            <param len="exclusiveScissorCount">const <type>VkBool32</type>* <name>pExclusiveScissorEnables</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindShadingRateImageNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewportShadingRatePaletteNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoarseSampleOrderNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCoarseSampleOrderTypeNV</type> <name>sampleOrderType</name></param>
+            <param optional="true"><type>uint32_t</type> <name>customSampleOrderCount</name></param>
+            <param len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>* <name>pCustomSampleOrders</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>taskCount</name></param>
+            <param><type>uint32_t</type> <name>firstTask</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCompileDeferredNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>shader</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkAccelerationStructureNV</type>* <name>pAccelerationStructure</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindInvocationMaskHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkAccelerationStructureKHR</type> <name>accelerationStructure</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyAccelerationStructureNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetAccelerationStructureMemoryRequirementsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2KHR</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindAccelerationStructureMemoryNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindAccelerationStructureMemoryInfoNV</type>* <name>pBindInfos</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>src</name></param>
+            <param><type>VkCopyAccelerationStructureModeKHR</type> <name>mode</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureToMemoryKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureToMemoryKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMemoryToAccelerationStructureKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyMemoryToAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type> <name>queryType</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type> <name>queryType</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructureNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkAccelerationStructureInfoNV</type>* <name>pInfo</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>instanceData</name></param>
+            <param><type>VkDeviceSize</type> <name>instanceOffset</name></param>
+            <param><type>VkBool32</type> <name>update</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
+            <param optional="true"><type>VkAccelerationStructureNV</type> <name>src</name></param>
+            <param><type>VkBuffer</type> <name>scratch</name></param>
+            <param><type>VkDeviceSize</type> <name>scratchOffset</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkWriteAccelerationStructuresPropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type>  <name>queryType</name></param>
+            <param><type>size_t</type>       <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+            <param><type>size_t</type> <name>stride</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdTraceRaysKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
+            <param><type>uint32_t</type> <name>width</name></param>
+            <param><type>uint32_t</type> <name>height</name></param>
+            <param><type>uint32_t</type> <name>depth</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdTraceRaysNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>raygenShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>raygenShaderBindingOffset</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>missShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>missShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>missShaderBindingStride</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>hitShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>hitShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>hitShaderBindingStride</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>callableShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>callableShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>callableShaderBindingStride</name></param>
+            <param><type>uint32_t</type> <name>width</name></param>
+            <param><type>uint32_t</type> <name>height</name></param>
+            <param><type>uint32_t</type> <name>depth</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRayTracingShaderGroupHandlesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>firstGroup</name></param>
+            <param><type>uint32_t</type> <name>groupCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command name="vkGetRayTracingShaderGroupHandlesNV"                 alias="vkGetRayTracingShaderGroupHandlesKHR"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRayTracingCaptureReplayShaderGroupHandlesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>firstGroup</name></param>
+            <param><type>uint32_t</type> <name>groupCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetAccelerationStructureHandleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkan" successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command api="vulkansc" successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesNV</type>* <name>pProperties</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdTraceRaysIndirectKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
+            <param><type>VkDeviceAddress</type> <name>indirectDeviceAddress</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdTraceRaysIndirect2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type> <name>indirectDeviceAddress</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceAccelerationStructureCompatibilityKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureVersionInfoKHR</type>* <name>pVersionInfo</name></param>
+            <param><type>VkAccelerationStructureCompatibilityKHR</type>* <name>pCompatibility</name></param>
+        </command>
+        <command>
+            <proto><type>VkDeviceSize</type> <name>vkGetRayTracingShaderGroupStackSizeKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>group</name></param>
+            <param><type>VkShaderGroupShaderKHR</type> <name>groupShader</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetRayTracingPipelineStackSizeKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>pipelineStackSize</name></param>
+        </command>
+        <command>
+            <proto><type>uint32_t</type> <name>vkGetImageViewHandleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageViewHandleInfoNVX</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>vkGetImageViewAddressNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageViewAddressPropertiesNVX</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModes2EXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
+            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModes2EXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkAcquireFullScreenExclusiveModeEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkReleaseFullScreenExclusiveModeEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCounterCount</name></param>
+            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterKHR</type>* <name>pCounters</name></param>
+            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterDescriptionKHR</type>* <name>pCounterDescriptions</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkQueryPoolPerformanceCreateInfoKHR</type>* <name>pPerformanceQueryCreateInfo</name></param>
+            <param><type>uint32_t</type>* <name>pNumPasses</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_TIMEOUT">
+            <proto><type>VkResult</type> <name>vkAcquireProfilingLockKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAcquireProfilingLockInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkReleaseProfilingLockKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetImageDrmFormatModifierPropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageDrmFormatModifierPropertiesEXT</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>uint64_t</type> <name>vkGetBufferOpaqueCaptureAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetBufferOpaqueCaptureAddressKHR" alias="vkGetBufferOpaqueCaptureAddress"/>
+        <command>
+            <proto><type>VkDeviceAddress</type> <name>vkGetBufferDeviceAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetBufferDeviceAddressKHR"        alias="vkGetBufferDeviceAddress"/>
+        <command name="vkGetBufferDeviceAddressEXT"        alias="vkGetBufferDeviceAddress"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateHeadlessSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkHeadlessSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCombinationCount</name></param>
+            <param optional="true" len="pCombinationCount"><type>VkFramebufferMixedSamplesCombinationNV</type>* <name>pCombinations</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkInitializePerformanceApiINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkInitializePerformanceApiInfoINTEL</type>* <name>pInitializeInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUninitializePerformanceApiINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY" tasks="action,state">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceMarkerINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY" tasks="action,state">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceStreamMarkerINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceStreamMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY" tasks="state">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceOverrideINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceOverrideInfoINTEL</type>* <name>pOverrideInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkAcquirePerformanceConfigurationINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPerformanceConfigurationAcquireInfoINTEL</type>* <name>pAcquireInfo</name></param>
+            <param><type>VkPerformanceConfigurationINTEL</type>* <name>pConfiguration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkReleasePerformanceConfigurationINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkQueueSetPerformanceConfigurationINTEL</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPerformanceParameterINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPerformanceParameterTypeINTEL</type> <name>parameter</name></param>
+            <param><type>VkPerformanceValueINTEL</type>* <name>pValue</name></param>
+        </command>
+        <command>
+            <proto><type>uint64_t</type> <name>vkGetDeviceMemoryOpaqueCaptureAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceMemoryOpaqueCaptureAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"        alias="vkGetDeviceMemoryOpaqueCaptureAddress"/>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutablePropertiesKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineInfoKHR</type>*        <name>pPipelineInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pExecutableCount</name></param>
+            <param optional="true" len="pExecutableCount"><type>VkPipelineExecutablePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutableStatisticsKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pStatisticCount</name></param>
+            <param optional="true" len="pStatisticCount"><type>VkPipelineExecutableStatisticKHR</type>* <name>pStatistics</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutableInternalRepresentationsKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pInternalRepresentationCount</name></param>
+            <param optional="true" len="pInternalRepresentationCount"><type>VkPipelineExecutableInternalRepresentationKHR</type>* <name>pInternalRepresentations</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLineStippleKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>lineStippleFactor</name></param>
+            <param><type>uint16_t</type> <name>lineStipplePattern</name></param>
+        </command>
+        <command name="vkCmdSetLineStippleEXT" alias="vkCmdSetLineStippleKHR"/>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetFaultData</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFaultQueryBehavior</type> <name>faultQueryBehavior</name></param>
+            <param><type>VkBool32</type>* <name>pUnrecordedFaults</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pFaultCount</name></param>
+            <param optional="true" len="pFaultCount"><type>VkFaultData</type>* <name>pFaults</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceToolProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pToolCount</name></param>
+            <param optional="true" len="pToolCount"><type>VkPhysicalDeviceToolProperties</type>* <name>pToolProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceToolPropertiesEXT" alias="vkGetPhysicalDeviceToolProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param>const <type>VkAccelerationStructureCreateInfoKHR</type>*        <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>*       <name>pAllocator</name></param>
+            <param><type>VkAccelerationStructureKHR</type>*                        <name>pAccelerationStructure</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                                    <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresIndirectKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                  <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                           <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkDeviceAddress</type>*             <name>pIndirectDeviceAddresses</name></param>
+            <param len="infoCount">const <type>uint32_t</type>*                    <name>pIndirectStrides</name></param>
+            <param len="infoCount">const <type>uint32_t</type>* const*             <name>ppMaxPrimitiveCounts</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBuildAccelerationStructuresKHR</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
+        </command>
+        <command>
+            <proto><type>VkDeviceAddress</type> <name>vkGetAccelerationStructureDeviceAddressKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureDeviceAddressInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDeferredOperationKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDeferredOperationKHR</type>* <name>pDeferredOperation</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDeferredOperationKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>uint32_t</type> <name>vkGetDeferredOperationMaxConcurrencyKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY">
+            <proto><type>VkResult</type> <name>vkGetDeferredOperationResultKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_THREAD_DONE_KHR,VK_THREAD_IDLE_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDeferredOperationJoinKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPipelineIndirectMemoryRequirementsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>VkDeviceAddress</type> <name>vkGetPipelineIndirectDeviceAddressNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineIndirectDeviceAddressInfoNV</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCullMode</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkCullModeFlags</type> <name>cullMode</name></param>
+        </command>
+        <command name="vkCmdSetCullModeEXT" alias="vkCmdSetCullMode"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetFrontFace</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkFrontFace</type> <name>frontFace</name></param>
+        </command>
+        <command name="vkCmdSetFrontFaceEXT" alias="vkCmdSetFrontFace"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetPrimitiveTopology</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPrimitiveTopology</type> <name>primitiveTopology</name></param>
+        </command>
+        <command name="vkCmdSetPrimitiveTopologyEXT" alias="vkCmdSetPrimitiveTopology"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewportWithCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
+        </command>
+        <command name="vkCmdSetViewportWithCountEXT" alias="vkCmdSetViewportWithCount"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetScissorWithCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>scissorCount</name></param>
+            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
+        </command>
+        <command name="vkCmdSetScissorWithCountEXT" alias="vkCmdSetScissorWithCount"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindIndexBuffer2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkDeviceSize</type> <name>size</name></param>
+            <param><type>VkIndexType</type> <name>indexType</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindVertexBuffers2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
+            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pStrides</name></param>
+        </command>
+        <command name="vkCmdBindVertexBuffers2EXT" alias="vkCmdBindVertexBuffers2"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthTestEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthTestEnable</name></param>
+        </command>
+        <command name="vkCmdSetDepthTestEnableEXT" alias="vkCmdSetDepthTestEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthWriteEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthWriteEnable</name></param>
+        </command>
+        <command name="vkCmdSetDepthWriteEnableEXT" alias="vkCmdSetDepthWriteEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthCompareOp</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCompareOp</type> <name>depthCompareOp</name></param>
+        </command>
+        <command name="vkCmdSetDepthCompareOpEXT" alias="vkCmdSetDepthCompareOp"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthBoundsTestEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthBoundsTestEnable</name></param>
+        </command>
+        <command name="vkCmdSetDepthBoundsTestEnableEXT" alias="vkCmdSetDepthBoundsTestEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetStencilTestEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>stencilTestEnable</name></param>
+        </command>
+        <command name="vkCmdSetStencilTestEnableEXT" alias="vkCmdSetStencilTestEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetStencilOp</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>VkStencilOp</type> <name>failOp</name></param>
+            <param><type>VkStencilOp</type> <name>passOp</name></param>
+            <param><type>VkStencilOp</type> <name>depthFailOp</name></param>
+            <param><type>VkCompareOp</type> <name>compareOp</name></param>
+        </command>
+        <command name="vkCmdSetStencilOpEXT" alias="vkCmdSetStencilOp"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetPatchControlPointsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>patchControlPoints</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetRasterizerDiscardEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>rasterizerDiscardEnable</name></param>
+        </command>
+        <command name="vkCmdSetRasterizerDiscardEnableEXT" alias="vkCmdSetRasterizerDiscardEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthBiasEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthBiasEnable</name></param>
+        </command>
+        <command name="vkCmdSetDepthBiasEnableEXT" alias="vkCmdSetDepthBiasEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLogicOpEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkLogicOp</type> <name>logicOp</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetPrimitiveRestartEnable</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>primitiveRestartEnable</name></param>
+        </command>
+        <command name="vkCmdSetPrimitiveRestartEnableEXT" alias="vkCmdSetPrimitiveRestartEnable"/>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetTessellationDomainOriginEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkTessellationDomainOrigin</type> <name>domainOrigin</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthClampEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthClampEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetPolygonModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPolygonMode</type> <name>polygonMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetRasterizationSamplesEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetSampleMaskEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkSampleCountFlagBits</type>  <name>samples</name></param>
+            <param len="latexmath:[\lceil{\mathit{samples} \over 32}\rceil]" altlen="(samples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetAlphaToCoverageEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>alphaToCoverageEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetAlphaToOneEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>alphaToOneEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLogicOpEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>logicOpEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetColorBlendEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstAttachment</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkBool32</type>* <name>pColorBlendEnables</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetColorBlendEquationEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstAttachment</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkColorBlendEquationEXT</type>* <name>pColorBlendEquations</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetColorWriteMaskEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstAttachment</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount" optional="false,true">const <type>VkColorComponentFlags</type>* <name>pColorWriteMasks</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetRasterizationStreamEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>rasterizationStream</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetConservativeRasterizationModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkConservativeRasterizationModeEXT</type> <name>conservativeRasterizationMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetExtraPrimitiveOverestimationSizeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>extraPrimitiveOverestimationSize</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthClipEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthClipEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetSampleLocationsEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>sampleLocationsEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetColorBlendAdvancedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstAttachment</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkColorBlendAdvancedEXT</type>* <name>pColorBlendAdvanced</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetProvokingVertexModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkProvokingVertexModeEXT</type> <name>provokingVertexMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLineRasterizationModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkLineRasterizationModeEXT</type> <name>lineRasterizationMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetLineStippleEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>stippledLineEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthClipNegativeOneToOneEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>negativeOneToOne</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewportWScalingEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>viewportWScalingEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetViewportSwizzleNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewportSwizzleNV</type>* <name>pViewportSwizzles</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageToColorEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>coverageToColorEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageToColorLocationNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>coverageToColorLocation</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageModulationModeNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCoverageModulationModeNV</type> <name>coverageModulationMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageModulationTableEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>coverageModulationTableEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageModulationTableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>coverageModulationTableCount</name></param>
+            <param len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetShadingRateImageEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>shadingRateImageEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetCoverageReductionModeNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCoverageReductionModeNV</type> <name>coverageReductionMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetRepresentativeFragmentTestEnableNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>representativeFragmentTestEnable</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePrivateDataSlot</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPrivateDataSlotCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPrivateDataSlot</type>* <name>pPrivateDataSlot</name></param>
+        </command>
+        <command name="vkCreatePrivateDataSlotEXT" alias="vkCreatePrivateDataSlot"/>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPrivateDataSlot</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command name="vkDestroyPrivateDataSlotEXT" alias="vkDestroyPrivateDataSlot"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetPrivateData</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkObjectType</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
+            <param><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
+            <param><type>uint64_t</type> <name>data</name></param>
+        </command>
+        <command name="vkSetPrivateDataEXT" alias="vkSetPrivateData"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPrivateData</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkObjectType</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
+            <param><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
+            <param><type>uint64_t</type>* <name>pData</name></param>
+        </command>
+        <command name="vkGetPrivateDataEXT" alias="vkGetPrivateData"/>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyBuffer2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyBufferInfo2</type>* <name>pCopyBufferInfo</name></param>
+        </command>
+        <command name="vkCmdCopyBuffer2KHR" alias="vkCmdCopyBuffer2"/>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyImage2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyImageInfo2</type>* <name>pCopyImageInfo</name></param>
+        </command>
+        <command name="vkCmdCopyImage2KHR" alias="vkCmdCopyImage2"/>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBlitImage2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkBlitImageInfo2</type>* <name>pBlitImageInfo</name></param>
+        </command>
+        <command name="vkCmdBlitImage2KHR" alias="vkCmdBlitImage2"/>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyBufferToImage2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyBufferToImageInfo2</type>* <name>pCopyBufferToImageInfo</name></param>
+        </command>
+        <command name="vkCmdCopyBufferToImage2KHR" alias="vkCmdCopyBufferToImage2"/>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyImageToBuffer2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyImageToBufferInfo2</type>* <name>pCopyImageToBufferInfo</name></param>
+        </command>
+        <command name="vkCmdCopyImageToBuffer2KHR" alias="vkCmdCopyImageToBuffer2"/>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdResolveImage2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkResolveImageInfo2</type>* <name>pResolveImageInfo</name></param>
+        </command>
+        <command name="vkCmdResolveImage2KHR" alias="vkCmdResolveImage2"/>
+        <command queues="graphics,compute,transfer" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdRefreshObjectsKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkRefreshObjectListKHR</type>* <name>pRefreshObjects</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceRefreshableObjectTypesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pRefreshableObjectTypeCount</name></param>
+            <param optional="true" len="pRefreshableObjectTypeCount"><type>VkObjectType</type>* <name>pRefreshableObjectTypes</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
+            <param>const <type>VkExtent2D</type>*                           <name>pFragmentSize</name></param>
+            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceFragmentShadingRatesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pFragmentShadingRateCount</name></param>
+            <param optional="true" len="pFragmentShadingRateCount"><type>VkPhysicalDeviceFragmentShadingRateKHR</type>* <name>pFragmentShadingRates</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateEnumNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
+            <param><type>VkFragmentShadingRateNV</type>                     <name>shadingRate</name></param>
+            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetAccelerationStructureBuildSizesKHR</name></proto>
+            <param><type>VkDevice</type>                                            <name>device</name></param>
+            <param><type>VkAccelerationStructureBuildTypeKHR</type>                 <name>buildType</name></param>
+            <param>const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>*  <name>pBuildInfo</name></param>
+            <param optional="true" len="pBuildInfo-&gt;geometryCount">const <type>uint32_t</type>*  <name>pMaxPrimitiveCounts</name></param>
+            <param><type>VkAccelerationStructureBuildSizesInfoKHR</type>*           <name>pSizeInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetVertexInputEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>vertexBindingDescriptionCount</name></param>
+            <param len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription2EXT</type>* <name>pVertexBindingDescriptions</name></param>
+            <param optional="true"><type>uint32_t</type> <name>vertexAttributeDescriptionCount</name></param>
+            <param len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription2EXT</type>* <name>pVertexAttributeDescriptions</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type>                                    <name>vkCmdSetColorWriteEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>       <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkBool32</type>*   <name>pColorWriteEnables</name></param>
+        </command>
+        <command queues="graphics,compute,decode,encode" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdSetEvent2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkEvent</type>                                             <name>event</name></param>
+            <param>const <type>VkDependencyInfo</type>*                             <name>pDependencyInfo</name></param>
+        </command>
+        <command name="vkCmdSetEvent2KHR" alias="vkCmdSetEvent2"/>
+        <command queues="graphics,compute,decode,encode" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdResetEvent2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkEvent</type>                                             <name>event</name></param>
+            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stageMask</name></param>
+        </command>
+        <command name="vkCmdResetEvent2KHR" alias="vkCmdResetEvent2"/>
+        <command queues="graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdWaitEvents2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                            <name>eventCount</name></param>
+            <param len="eventCount">const <type>VkEvent</type>*                     <name>pEvents</name></param>
+            <param len="eventCount">const <type>VkDependencyInfo</type>*            <name>pDependencyInfos</name></param>
+        </command>
+        <command name="vkCmdWaitEvents2KHR" alias="vkCmdWaitEvents2"/>
+        <command queues="transfer,graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
+            <proto><type>void</type> <name>vkCmdPipelineBarrier2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param>const <type>VkDependencyInfo</type>*                             <name>pDependencyInfo</name></param>
+        </command>
+        <command name="vkCmdPipelineBarrier2KHR" alias="vkCmdPipelineBarrier2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueSubmit2</name></proto>
+            <param externsync="true"><type>VkQueue</type>                           <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type>                            <name>submitCount</name></param>
+            <param len="submitCount">const <type>VkSubmitInfo2</type>*              <name>pSubmits</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type>           <name>fence</name></param>
+        </command>
+        <command name="vkQueueSubmit2KHR" alias="vkQueueSubmit2"/>
+        <command queues="transfer,graphics,compute,decode,encode" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteTimestamp2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stage</name></param>
+            <param><type>VkQueryPool</type>                                         <name>queryPool</name></param>
+            <param><type>uint32_t</type>                                            <name>query</name></param>
+        </command>
+        <command name="vkCmdWriteTimestamp2KHR" alias="vkCmdWriteTimestamp2"/>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteBufferMarker2AMD</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stage</name></param>
+            <param><type>VkBuffer</type>                                            <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type>                                        <name>dstOffset</name></param>
+            <param><type>uint32_t</type>                                            <name>marker</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetQueueCheckpointData2NV</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
+            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointData2NV</type>* <name>pCheckpointData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkCopyMemoryToImageEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCopyMemoryToImageInfoEXT</type>* <name>pCopyMemoryToImageInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkCopyImageToMemoryEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCopyImageToMemoryInfoEXT</type>* <name>pCopyImageToMemoryInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkCopyImageToImageEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCopyImageToImageInfoEXT</type>* <name>pCopyImageToImageInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkTransitionImageLayoutEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>transitionCount</name></param>
+            <param len="transitionCount">const <type>VkHostImageLayoutTransitionInfoEXT</type>* <name>pTransitions</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetCommandPoolMemoryConsumption</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true" externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCommandPoolMemoryConsumption</type>* <name>pConsumption</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkVideoProfileInfoKHR</type>* <name>pVideoProfile</name></param>
+            <param><type>VkVideoCapabilitiesKHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoFormatPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceVideoFormatInfoKHR</type>* <name>pVideoFormatInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pVideoFormatPropertyCount</name></param>
+            <param optional="true" len="pVideoFormatPropertyCount"><type>VkVideoFormatPropertiesKHR</type>* <name>pVideoFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR</type>* <name>pQualityLevelInfo</name></param>
+            <param><type>VkVideoEncodeQualityLevelPropertiesKHR</type>* <name>pQualityLevelProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateVideoSessionKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkVideoSessionCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkVideoSessionKHR</type>* <name>pVideoSession</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyVideoSessionKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkVideoSessionParametersCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkVideoSessionParametersKHR</type>* <name>pVideoSessionParameters</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR">
+            <proto><type>VkResult</type> <name>vkUpdateVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
+            <param>const <type>VkVideoSessionParametersUpdateInfoKHR</type>* <name>pUpdateInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetEncodedVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkVideoEncodeSessionParametersGetInfoKHR</type>* <name>pVideoSessionParametersInfo</name></param>
+            <param optional="true"><type>VkVideoEncodeSessionParametersFeedbackInfoKHR</type>* <name>pFeedbackInfo</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE">
+            <proto><type>VkResult</type> <name>vkGetVideoSessionMemoryRequirementsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pMemoryRequirementsCount</name></param>
+            <param optional="true" len="pMemoryRequirementsCount"><type>VkVideoSessionMemoryRequirementsKHR</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindVideoSessionMemoryKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param><type>uint32_t</type> <name>bindSessionMemoryInfoCount</name></param>
+            <param len="bindSessionMemoryInfoCount">const <type>VkBindVideoSessionMemoryInfoKHR</type>* <name>pBindSessionMemoryInfos</name></param>
+        </command>
+        <command queues="decode" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDecodeVideoKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoDecodeInfoKHR</type>* <name>pDecodeInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" videocoding="outside" cmdbufferlevel="primary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginVideoCodingKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoBeginCodingInfoKHR</type>* <name>pBeginInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
+            <proto><type>void</type> <name>vkCmdControlVideoCodingKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoCodingControlInfoKHR</type>* <name>pCodingControlInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndVideoCodingKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoEndCodingInfoKHR</type>* <name>pEndCodingInfo</name></param>
+        </command>
+        <command queues="encode" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
+            <proto><type>void</type> <name>vkCmdEncodeVideoKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoEncodeInfoKHR</type>* <name>pEncodeInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDecompressMemoryNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>decompressRegionCount</name></param>
+            <param len="decompressRegionCount">const <type>VkDecompressMemoryRegionNV</type>* <name>pDecompressMemoryRegions</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdDecompressMemoryIndirectCountNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type> <name>indirectCommandsAddress</name></param>
+            <param><type>VkDeviceAddress</type> <name>indirectCommandsCountAddress</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateCuModuleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCuModuleCreateInfoNVX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCuModuleNVX</type>* <name>pModule</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateCuFunctionNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCuFunctionCreateInfoNVX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCuFunctionNVX</type>* <name>pFunction</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCuModuleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCuModuleNVX</type> <name>module</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCuFunctionNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCuFunctionNVX</type> <name>function</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCuLaunchKernelNVX</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCuLaunchInfoNVX</type>* <name>pLaunchInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSizeEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDescriptorSetLayout</type> <name>layout</name></param>
+            <param><type>VkDeviceSize</type>* <name>pLayoutSizeInBytes</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetLayoutBindingOffsetEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDescriptorSetLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>binding</name></param>
+            <param><type>VkDeviceSize</type>* <name>pOffset</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorGetInfoEXT</type>* <name>pDescriptorInfo</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pDescriptor</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindDescriptorBuffersEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>bufferCount</name></param>
+            <param len="bufferCount">const <type>VkDescriptorBufferBindingInfoEXT</type>* <name>pBindingInfos</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDescriptorBufferOffsetsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>firstSet</name></param>
+            <param><type>uint32_t</type> <name>setCount</name></param>
+            <param len="setCount">const <type>uint32_t</type>* <name>pBufferIndices</name></param>
+            <param len="setCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindDescriptorBufferEmbeddedSamplersEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>set</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetBufferOpaqueCaptureDescriptorDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
+            <param><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetImageOpaqueCaptureDescriptorDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
+            <param><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetImageViewOpaqueCaptureDescriptorDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageViewCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
+            <param><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSamplerOpaqueCaptureDescriptorDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSamplerCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
+            <param><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
+            <param><type>void</type>* <name>pData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetDeviceMemoryPriorityEXT</name></proto>
+            <param><type>VkDevice</type>       <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>float</type>          <name>priority</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireDrmDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>int32_t</type> <name>drmFd</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDrmDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>int32_t</type> <name>drmFd</name></param>
+            <param><type>uint32_t</type> <name>connectorId</name></param>
+            <param><type>VkDisplayKHR</type>* <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkWaitForPresentKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>uint64_t</type> <name>presentId</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateBufferCollectionFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferCollectionCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type>* <name>pCollection</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkSetBufferCollectionBufferConstraintsFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param>const <type>VkBufferConstraintsInfoFUCHSIA</type>* <name>pBufferConstraintsInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkSetBufferCollectionImageConstraintsFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param>const <type>VkImageConstraintsInfoFUCHSIA</type>* <name>pImageConstraintsInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBufferCollectionFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetBufferCollectionPropertiesFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param><type>VkBufferCollectionPropertiesFUCHSIA</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateCudaModuleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCudaModuleCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCudaModuleNV</type>* <name>pModule</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetCudaModuleCacheNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCudaModuleNV</type> <name>module</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pCacheSize</name></param>
+            <param optional="true" len="pCacheSize"><type>void</type>* <name>pCacheData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateCudaFunctionNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCudaFunctionCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCudaFunctionNV</type>* <name>pFunction</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCudaModuleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCudaModuleNV</type> <name>module</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCudaFunctionNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCudaFunctionNV</type> <name>function</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCudaLaunchKernelNV</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCudaLaunchInfoNV</type>* <name>pLaunchInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdBeginRendering</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param>const <type>VkRenderingInfo</type>*                              <name>pRenderingInfo</name></param>
+        </command>
+        <command name="vkCmdBeginRenderingKHR" alias="vkCmdBeginRendering"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action,state">
+            <proto><type>void</type> <name>vkCmdEndRendering</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+        </command>
+
+        <command name="vkCmdEndRenderingKHR" alias="vkCmdEndRendering"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetLayoutHostMappingInfoVALVE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorSetBindingReferenceVALVE</type>* <name>pBindingReference</name></param>
+            <param><type>VkDescriptorSetLayoutHostMappingInfoVALVE</type>* <name>pHostMapping</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetHostMappingVALVE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
+            <param><type>void</type>** <name>ppData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateMicromapEXT</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param>const <type>VkMicromapCreateInfoEXT</type>*        <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>*       <name>pAllocator</name></param>
+            <param><type>VkMicromapEXT</type>*                        <name>pMicromap</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdBuildMicromapsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                                    <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkMicromapBuildInfoEXT</type>* <name>pInfos</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBuildMicromapsEXT</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkMicromapBuildInfoEXT</type>* <name>pInfos</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyMicromapEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkMicromapEXT</type> <name>micromap</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMicromapEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyMicromapInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyMicromapEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyMicromapInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMicromapToMemoryEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyMicromapToMemoryInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyMicromapToMemoryEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyMicromapToMemoryInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdCopyMemoryToMicromapEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyMemoryToMicromapInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyMemoryToMicromapEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyMemoryToMicromapInfoEXT</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdWriteMicromapsPropertiesEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>micromapCount</name></param>
+            <param len="micromapCount">const <type>VkMicromapEXT</type>* <name>pMicromaps</name></param>
+            <param><type>VkQueryType</type> <name>queryType</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkWriteMicromapsPropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>micromapCount</name></param>
+            <param len="micromapCount">const <type>VkMicromapEXT</type>* <name>pMicromaps</name></param>
+            <param><type>VkQueryType</type>  <name>queryType</name></param>
+            <param><type>size_t</type>       <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+            <param><type>size_t</type> <name>stride</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceMicromapCompatibilityEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMicromapVersionInfoEXT</type>* <name>pVersionInfo</name></param>
+            <param><type>VkAccelerationStructureCompatibilityKHR</type>* <name>pCompatibility</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetMicromapBuildSizesEXT</name></proto>
+            <param><type>VkDevice</type>                                            <name>device</name></param>
+            <param><type>VkAccelerationStructureBuildTypeKHR</type>                 <name>buildType</name></param>
+            <param>const <type>VkMicromapBuildInfoEXT</type>*  <name>pBuildInfo</name></param>
+            <param><type>VkMicromapBuildSizesInfoEXT</type>*           <name>pSizeInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetShaderModuleIdentifierEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkShaderModule</type> <name>shaderModule</name></param>
+            <param><type>VkShaderModuleIdentifierEXT</type>* <name>pIdentifier</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetShaderModuleCreateInfoIdentifierEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param><type>VkShaderModuleIdentifierEXT</type>* <name>pIdentifier</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSubresourceLayout2KHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param>const <type>VkImageSubresource2KHR</type>* <name>pSubresource</name></param>
+            <param><type>VkSubresourceLayout2KHR</type>* <name>pLayout</name></param>
+        </command>
+        <command name="vkGetImageSubresourceLayout2EXT"        alias="vkGetImageSubresourceLayout2KHR"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelinePropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineInfoEXT</type>* <name>pPipelineInfo</name></param>
+            <param noautovalidity="true" validstructs="VkPipelinePropertiesIdentifierEXT"><type>VkBaseOutStructure</type>* <name>pPipelineProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkExportMetalObjectsEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExportMetalObjectsInfoEXT</type>* <name>pMetalObjectsInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE">
+            <proto><type>VkResult</type> <name>vkGetFramebufferTilePropertiesQCOM</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFramebuffer</type> <name>framebuffer</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertiesCount</name></param>
+            <param optional="true" len="pPropertiesCount"><type>VkTilePropertiesQCOM</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkGetDynamicRenderingTilePropertiesQCOM</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderingInfo</type>* <name>pRenderingInfo</name></param>
+            <param><type>VkTilePropertiesQCOM</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceOpticalFlowImageFormatsNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkOpticalFlowImageFormatInfoNV</type>* <name>pOpticalFlowImageFormatInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pFormatCount</name></param>
+            <param optional="true" len="pFormatCount"><type>VkOpticalFlowImageFormatPropertiesNV</type>* <name>pImageFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateOpticalFlowSessionNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkOpticalFlowSessionCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkOpticalFlowSessionNV</type>* <name>pSession</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyOpticalFlowSessionNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkBindOpticalFlowSessionImageNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
+            <param><type>VkOpticalFlowSessionBindingPointNV</type> <name>bindingPoint</name></param>
+            <param optional="true"><type>VkImageView</type> <name>view</name></param>
+            <param><type>VkImageLayout</type> <name>layout</name></param>
+        </command>
+        <command queues="opticalflow" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
+            <proto><type>void</type> <name>vkCmdOpticalFlowExecuteNV</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
+            <param>const <type>VkOpticalFlowExecuteInfoNV</type>* <name>pExecuteInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDeviceFaultInfoEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceFaultCountsEXT</type>* <name>pFaultCounts</name></param>
+            <param optional="true"><type>VkDeviceFaultInfoEXT</type>* <name>pFaultInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdSetDepthBias2EXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDepthBiasInfoEXT</type>*         <name>pDepthBiasInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkReleaseSwapchainImagesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkReleaseSwapchainImagesInfoEXT</type>* <name>pReleaseInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceImageSubresourceLayoutKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceImageSubresourceInfoKHR</type>* <name>pInfo</name></param>
+            <param><type>VkSubresourceLayout2KHR</type>* <name>pLayout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkMapMemory2KHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryMapInfoKHR</type>* <name>pMemoryMapInfo</name></param>
+            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkUnmapMemory2KHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryUnmapInfoKHR</type>* <name>pMemoryUnmapInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT">
+            <proto><type>VkResult</type> <name>vkCreateShadersEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkShaderCreateInfoEXT</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkShaderEXT</type>* <name>pShaders</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyShaderEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkShaderEXT</type> <name>shader</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetShaderBinaryDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkShaderEXT</type> <name>shader</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
+            <proto><type>void</type> <name>vkCmdBindShadersEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>stageCount</name></param>
+            <param len="stageCount">const <type>VkShaderStageFlagBits</type>* <name>pStages</name></param>
+            <param optional="true,true" len="stageCount">const <type>VkShaderEXT</type>* <name>pShaders</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR">
+            <proto><type>VkResult</type> <name>vkGetScreenBufferPropertiesQNX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const struct <type>_screen_buffer</type>* <name>buffer</name></param>
+            <param><type>VkScreenBufferPropertiesQNX</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetExecutionGraphPipelineScratchSizeAMDX</name></proto>
+            <param><type>VkDevice</type>                                        <name>device</name></param>
+            <param><type>VkPipeline</type>                                      <name>executionGraph</name></param>
+            <param><type>VkExecutionGraphPipelineScratchSizeAMDX</type>*         <name>pSizeInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetExecutionGraphPipelineNodeIndexAMDX</name></proto>
+            <param><type>VkDevice</type>                                        <name>device</name></param>
+            <param><type>VkPipeline</type>                                      <name>executionGraph</name></param>
+            <param>const <type>VkPipelineShaderStageNodeCreateInfoAMDX</type>*   <name>pNodeInfo</name></param>
+            <param><type>uint32_t</type>*                                       <name>pNodeIndex</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateExecutionGraphPipelinesAMDX</name></proto>
+            <param><type>VkDevice</type>                                        <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type>                 <name>pipelineCache</name></param>
+            <param><type>uint32_t</type>                                        <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkExecutionGraphPipelineCreateInfoAMDX</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>*    <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>*               <name>pPipelines</name></param>
+        </command>
+        <command queues="graphics,compute" tasks="action" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdInitializeGraphScratchMemoryAMDX</name></proto>
+            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
+        </command>
+        <command queues="graphics,compute" tasks="action" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdDispatchGraphAMDX</name></proto>
+            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
+            <param>const <type>VkDispatchGraphCountInfoAMDX</type>*              <name>pCountInfo</name></param>
+        </command>
+        <command queues="graphics,compute" tasks="action" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdDispatchGraphIndirectAMDX</name></proto>
+            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
+            <param>const <type>VkDispatchGraphCountInfoAMDX</type>*              <name>pCountInfo</name></param>
+        </command>
+        <command queues="graphics,compute" tasks="action" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdDispatchGraphIndirectCountAMDX</name></proto>
+            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
+            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
+            <param><type>VkDeviceAddress</type>                                 <name>countInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkSetLatencySleepModeNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param>const <type>VkLatencySleepModeInfoNV</type>* <name>pSleepModeInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>vkLatencySleepNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param>const <type>VkLatencySleepInfoNV</type>* <name>pSleepInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetLatencyMarkerNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param>const <type>VkSetLatencyMarkerInfoNV</type>* <name>pLatencyMarkerInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetLatencyTimingsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>uint32_t</type>* <name>pTimingCount</name></param>
+            <param><type>VkGetLatencyMarkerInfoNV</type>* <name>pLatencyMarkerInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueNotifyOutOfBandNV</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param>const <type>VkOutOfBandQueueTypeInfoNV</type>* <name>pQueueTypeInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryMetalHandleEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetMetalHandleInfoEXT</type>* <name>pGetMetalHandleInfo</name></param>
+            <param><type>void</type>** <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryMetalHandlePropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>void</type>* <name>handle</name></param>
+            <param><type>VkMemoryMetalHandlePropertiesEXT</type>* <name>pMemoryMetalHandleProperties</name></param>
+        </command>
+    </commands>
+
+    <feature api="vulkan,vulkansc" name="VK_VERSION_1_0" number="1.0" comment="Vulkan core API interface definitions">
+        <require comment="Header boilerplate">
+            <type name="vk_platform"/>
+            <type name="VK_DEFINE_HANDLE"/>
+            <type name="VK_USE_64_BIT_PTR_DEFINES"/>
+            <type name="VK_DEFINE_NON_DISPATCHABLE_HANDLE"/>
+            <type name="VK_NULL_HANDLE"/>
+        </require>
+        <require comment="Fundamental types used by many commands and structures">
+            <type name="VkBool32"/>
+            <type name="VkDeviceAddress"/>
+            <type name="VkDeviceSize"/>
+            <type name="VkExtent2D"/>
+            <type name="VkExtent3D"/>
+            <type name="VkFlags"/>
+            <type name="VkOffset2D"/>
+            <type name="VkOffset3D"/>
+            <type name="VkRect2D"/>
+            <type name="VkResult"/>
+            <type name="VkStructureType"/>
+        </require>
+        <require comment="API constants">
+            <enum name="VK_ATTACHMENT_UNUSED"/>
+            <enum name="VK_FALSE"/>
+            <enum name="VK_LOD_CLAMP_NONE"/>
+            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
+            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
+            <enum name="VK_REMAINING_MIP_LEVELS"/>
+            <enum name="VK_SUBPASS_EXTERNAL"/>
+            <enum name="VK_TRUE"/>
+            <enum name="VK_WHOLE_SIZE"/>
+            <enum name="VK_MAX_MEMORY_TYPES"/>
+            <enum name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
+            <enum name="VK_UUID_SIZE"/>
+            <enum name="VK_MAX_EXTENSION_NAME_SIZE"/>
+            <enum name="VK_MAX_DESCRIPTION_SIZE"/>
+            <enum name="VK_MAX_MEMORY_HEAPS"/>
+            <type name="VkPipelineCacheHeaderVersion"/>
+        </require>
+        <require comment="These types are part of the API, though not directly used in API commands or data structures">
+            <type name="VkBaseInStructure"/>
+            <type name="VkBaseOutStructure"/>
+            <type name="VkBufferMemoryBarrier"/>
+            <type name="VkDispatchIndirectCommand"/>
+            <type name="VkDrawIndexedIndirectCommand"/>
+            <type name="VkDrawIndirectCommand"/>
+            <type name="VkImageMemoryBarrier"/>
+            <type name="VkMemoryBarrier"/>
+            <type name="VkObjectType"/>
+            <type name="VkPipelineCacheHeaderVersionOne"/>
+            <type name="VkVendorId"/>
+        </require>
+        <require comment="API version macros">
+            <type name="VK_API_VERSION"/>
+            <type name="VK_API_VERSION_1_0"/>
+            <type name="VK_HEADER_VERSION"/>
+            <type name="VK_HEADER_VERSION_COMPLETE"/>
+            <type name="VK_MAKE_VERSION"/>
+            <type name="VK_VERSION_MAJOR"/>
+            <type name="VK_VERSION_MINOR"/>
+            <type name="VK_VERSION_PATCH"/>
+            <type name="VK_MAKE_API_VERSION"/>
+            <type name="VK_API_VERSION_VARIANT"/>
+            <type name="VK_API_VERSION_MAJOR"/>
+            <type name="VK_API_VERSION_MINOR"/>
+            <type name="VK_API_VERSION_PATCH"/>
+        </require>
+        <require comment="Device initialization">
+            <type name="PFN_vkAllocationFunction"/>
+            <type name="PFN_vkFreeFunction"/>
+            <type name="PFN_vkInternalAllocationNotification"/>
+            <type name="PFN_vkInternalFreeNotification"/>
+            <type name="PFN_vkReallocationFunction"/>
+            <type name="PFN_vkVoidFunction"/>
+            <type name="VkAllocationCallbacks"/>
+            <type name="VkApplicationInfo"/>
+            <type name="VkFormat"/>
+            <type name="VkFormatFeatureFlagBits"/>
+            <type name="VkFormatFeatureFlags"/>
+            <type name="VkFormatProperties"/>
+            <type name="VkImageCreateFlagBits"/>
+            <type name="VkImageCreateFlags"/>
+            <type name="VkImageFormatProperties"/>
+            <type name="VkImageTiling"/>
+            <type name="VkImageType"/>
+            <type name="VkImageUsageFlagBits"/>
+            <type name="VkImageUsageFlags"/>
+            <type name="VkInstance"/>
+            <type name="VkInstanceCreateFlags"/>
+            <type name="VkInstanceCreateFlagBits"/>
+            <type name="VkInstanceCreateInfo"/>
+            <type name="VkInternalAllocationType"/>
+            <type name="VkMemoryHeap"/>
+            <type name="VkMemoryHeapFlagBits"/>
+            <type name="VkMemoryHeapFlags"/>
+            <type name="VkMemoryPropertyFlagBits"/>
+            <type name="VkMemoryPropertyFlags"/>
+            <type name="VkMemoryType"/>
+            <type name="VkPhysicalDevice"/>
+            <type name="VkPhysicalDeviceFeatures"/>
+            <type name="VkPhysicalDeviceLimits"/>
+            <type name="VkPhysicalDeviceMemoryProperties"/>
+            <type name="VkPhysicalDeviceProperties"/>
+            <type name="VkPhysicalDeviceSparseProperties"/>
+            <type name="VkPhysicalDeviceType"/>
+            <type name="VkQueueFamilyProperties"/>
+            <type name="VkQueueFlagBits"/>
+            <type name="VkQueueFlags"/>
+            <type name="VkSampleCountFlagBits"/>
+            <type name="VkSampleCountFlags"/>
+            <type name="VkSystemAllocationScope"/>
+            <command name="vkCreateInstance"/>
+            <command name="vkDestroyInstance"/>
+            <command name="vkEnumeratePhysicalDevices"/>
+            <command name="vkGetPhysicalDeviceFeatures"/>
+            <command name="vkGetPhysicalDeviceFormatProperties"/>
+            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
+            <command name="vkGetPhysicalDeviceProperties"/>
+            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
+            <command name="vkGetPhysicalDeviceMemoryProperties"/>
+            <command name="vkGetInstanceProcAddr"/>
+            <command name="vkGetDeviceProcAddr"/>
+        </require>
+        <require comment="Device commands">
+            <type name="VkDevice"/>
+            <type name="VkDeviceCreateFlags" comment="Will add VkDeviceCreateFlagBits when bits are defined in the future"/>
+            <type name="VkDeviceCreateInfo"/>
+            <type name="VkDeviceQueueCreateFlags" comment="VkDeviceQueueCreateFlagBits was added later"/>
+            <type name="VkDeviceQueueCreateInfo"/>
+            <command name="vkCreateDevice"/>
+            <command name="vkDestroyDevice"/>
+        </require>
+        <require comment="Extension discovery commands">
+            <type name="VkExtensionProperties"/>
+            <command name="vkEnumerateInstanceExtensionProperties"/>
+            <command name="vkEnumerateDeviceExtensionProperties"/>
+        </require>
+        <require comment="Layer discovery commands">
+            <type name="VkLayerProperties"/>
+            <command name="vkEnumerateInstanceLayerProperties"/>
+            <command name="vkEnumerateDeviceLayerProperties"/>
+        </require>
+        <require comment="Queue commands">
+            <type name="VkPipelineStageFlagBits"/>
+            <type name="VkPipelineStageFlags"/>
+            <type name="VkQueue"/>
+            <type name="VkSubmitInfo"/>
+            <command name="vkGetDeviceQueue"/>
+            <command name="vkQueueSubmit"/>
+            <command name="vkQueueWaitIdle"/>
+            <command name="vkDeviceWaitIdle"/>
+        </require>
+        <require comment="Memory commands">
+            <type name="VkMappedMemoryRange"/>
+            <type name="VkMemoryAllocateInfo"/>
+            <type name="VkMemoryMapFlags"/>
+            <command name="vkAllocateMemory"/>
+            <command name="vkFreeMemory"/>
+            <command name="vkMapMemory"/>
+            <command name="vkUnmapMemory"/>
+            <command name="vkFlushMappedMemoryRanges"/>
+            <command name="vkInvalidateMappedMemoryRanges"/>
+            <command name="vkGetDeviceMemoryCommitment"/>
+        </require>
+        <require comment="Memory management API commands">
+            <type name="VkDeviceMemory"/>
+            <type name="VkMemoryRequirements"/>
+            <command name="vkBindBufferMemory"/>
+            <command name="vkBindImageMemory"/>
+            <command name="vkGetBufferMemoryRequirements"/>
+            <command name="vkGetImageMemoryRequirements"/>
+        </require>
+        <require comment="Sparse resource memory management API commands">
+            <type name="VkBindSparseInfo"/>
+            <type name="VkImageAspectFlagBits"/>
+            <type name="VkImageAspectFlags"/>
+            <type name="VkImageSubresource"/>
+            <type name="VkSparseBufferMemoryBindInfo"/>
+            <type name="VkSparseImageFormatFlagBits"/>
+            <type name="VkSparseImageFormatFlags"/>
+            <type name="VkSparseImageFormatProperties"/>
+            <type name="VkSparseImageMemoryBind"/>
+            <type name="VkSparseImageMemoryBindInfo"/>
+            <type name="VkSparseImageMemoryRequirements"/>
+            <type name="VkSparseImageOpaqueMemoryBindInfo"/>
+            <type name="VkSparseMemoryBind"/>
+            <type name="VkSparseMemoryBindFlagBits"/>
+            <type name="VkSparseMemoryBindFlags"/>
+            <command name="vkGetImageSparseMemoryRequirements"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
+            <command name="vkQueueBindSparse"/>
+        </require>
+        <require comment="Fence commands">
+            <type name="VkFence"/>
+            <type name="VkFenceCreateFlagBits"/>
+            <type name="VkFenceCreateFlags"/>
+            <type name="VkFenceCreateInfo"/>
+            <command name="vkCreateFence"/>
+            <command name="vkDestroyFence"/>
+            <command name="vkResetFences"/>
+            <command name="vkGetFenceStatus"/>
+            <command name="vkWaitForFences"/>
+        </require>
+        <require comment="Queue semaphore commands">
+            <type name="VkSemaphore"/>
+            <type name="VkSemaphoreCreateFlags" comment="Will add VkSemaphoreCreateFlagBits when bits are defined in the future"/>
+            <type name="VkSemaphoreCreateInfo"/>
+            <command name="vkCreateSemaphore"/>
+            <command name="vkDestroySemaphore"/>
+        </require>
+        <require comment="Event commands">
+            <type name="VkEvent"/>
+            <type name="VkEventCreateFlags"/>
+            <type name="VkEventCreateFlagBits"/>
+            <type name="VkEventCreateInfo"/>
+            <command name="vkCreateEvent"/>
+            <command name="vkDestroyEvent"/>
+            <command name="vkGetEventStatus"/>
+            <command name="vkSetEvent"/>
+            <command name="vkResetEvent"/>
+        </require>
+        <require comment="Query commands">
+            <type name="VkQueryPipelineStatisticFlagBits"/>
+            <type name="VkQueryPipelineStatisticFlags"/>
+            <type name="VkQueryPool"/>
+            <type name="VkQueryPoolCreateFlags" comment="Will add VkQueryPoolCreateFlagBits when bits are defined in the future"/>
+            <type name="VkQueryPoolCreateInfo"/>
+            <type name="VkQueryResultFlagBits"/>
+            <type name="VkQueryResultFlags"/>
+            <type name="VkQueryType"/>
+            <command name="vkCreateQueryPool"/>
+            <command name="vkDestroyQueryPool"/>
+            <command name="vkGetQueryPoolResults"/>
+        </require>
+        <require comment="Buffer commands">
+            <type name="VkBuffer"/>
+            <type name="VkBufferCreateFlagBits"/>
+            <type name="VkBufferCreateFlags"/>
+            <type name="VkBufferCreateInfo"/>
+            <type name="VkBufferUsageFlagBits"/>
+            <type name="VkBufferUsageFlags"/>
+            <type name="VkSharingMode"/>
+            <command name="vkCreateBuffer"/>
+            <command name="vkDestroyBuffer"/>
+        </require>
+        <require comment="Buffer view commands">
+            <type name="VkBufferView"/>
+            <type name="VkBufferViewCreateFlags" comment="Will add VkBufferViewFlagBits when bits are defined in the future"/>
+            <type name="VkBufferViewCreateInfo"/>
+            <command name="vkCreateBufferView"/>
+            <command name="vkDestroyBufferView"/>
+        </require>
+        <require comment="Image commands">
+            <type name="VkImage"/>
+            <type name="VkImageCreateInfo"/>
+            <type name="VkImageLayout"/>
+            <type name="VkSubresourceLayout"/>
+            <command name="vkCreateImage"/>
+            <command name="vkDestroyImage"/>
+            <command name="vkGetImageSubresourceLayout"/>
+        </require>
+        <require comment="Image view commands">
+            <type name="VkComponentMapping"/>
+            <type name="VkComponentSwizzle"/>
+            <type name="VkImageSubresourceRange"/>
+            <type name="VkImageView"/>
+            <type name="VkImageViewCreateFlagBits"/>
+            <type name="VkImageViewCreateFlags"/>
+            <type name="VkImageViewCreateInfo"/>
+            <type name="VkImageViewType"/>
+            <command name="vkCreateImageView"/>
+            <command name="vkDestroyImageView"/>
+        </require>
+        <require comment="Shader commands">
+            <type name="VkShaderModule"/>
+            <type name="VkShaderModuleCreateFlags"/>
+            <type name="VkShaderModuleCreateInfo"/>
+            <command name="vkCreateShaderModule"/>
+            <command name="vkDestroyShaderModule"/>
+        </require>
+        <require comment="Pipeline Cache commands">
+            <type name="VkPipelineCache"/>
+            <type name="VkPipelineCacheCreateFlags" comment="VkPipelineCacheCreateFlagBits was added later"/>
+            <type name="VkPipelineCacheCreateInfo"/>
+            <command name="vkCreatePipelineCache"/>
+            <command name="vkDestroyPipelineCache"/>
+            <command name="vkGetPipelineCacheData"/>
+            <command name="vkMergePipelineCaches"/>
+        </require>
+        <require comment="Pipeline commands">
+            <type name="VkBlendFactor"/>
+            <type name="VkBlendOp"/>
+            <type name="VkColorComponentFlagBits"/>
+            <type name="VkColorComponentFlags"/>
+            <type name="VkCompareOp"/>
+            <type name="VkComputePipelineCreateInfo"/>
+            <type name="VkCullModeFlagBits"/>
+            <type name="VkCullModeFlags"/>
+            <type name="VkDynamicState"/>
+            <type name="VkFrontFace"/>
+            <type name="VkGraphicsPipelineCreateInfo"/>
+            <type name="VkLogicOp"/>
+            <type name="VkPipeline"/>
+            <type name="VkPipelineColorBlendAttachmentState"/>
+            <type name="VkPipelineColorBlendStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineColorBlendStateCreateInfo"/>
+            <type name="VkPipelineCreateFlagBits"/>
+            <type name="VkPipelineCreateFlags"/>
+            <type name="VkPipelineDepthStencilStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineDepthStencilStateCreateInfo"/>
+            <type name="VkPipelineDynamicStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineDynamicStateCreateInfo"/>
+            <type name="VkPipelineInputAssemblyStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineInputAssemblyStateCreateInfo"/>
+            <type name="VkPipelineLayoutCreateFlags" comment="Will add VkPipelineLayoutCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineMultisampleStateCreateFlags" comment="Will add VkPipelineMultisampleStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineMultisampleStateCreateInfo"/>
+            <type name="VkPipelineRasterizationStateCreateFlags" comment="Will add VkPipelineRasterizationStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineRasterizationStateCreateInfo"/>
+            <type name="VkPipelineShaderStageCreateFlagBits"/>
+            <type name="VkPipelineShaderStageCreateFlags"/>
+            <type name="VkPipelineShaderStageCreateInfo"/>
+            <type name="VkPipelineTessellationStateCreateFlags" comment="Will add VkPipelineTessellationStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineTessellationStateCreateInfo"/>
+            <type name="VkPipelineVertexInputStateCreateFlags" comment="Will add VkPipelineVertexInputStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineVertexInputStateCreateInfo"/>
+            <type name="VkPipelineViewportStateCreateFlags" comment="Will add VkPipelineViewportStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineViewportStateCreateInfo"/>
+            <type name="VkPolygonMode"/>
+            <type name="VkPrimitiveTopology"/>
+            <type name="VkSampleMask"/>
+            <type name="VkShaderStageFlagBits"/>
+            <type name="VkShaderStageFlags"/>
+            <type name="VkSpecializationInfo"/>
+            <type name="VkSpecializationMapEntry"/>
+            <type name="VkStencilOp"/>
+            <type name="VkStencilOpState"/>
+            <type name="VkVertexInputAttributeDescription"/>
+            <type name="VkVertexInputBindingDescription"/>
+            <type name="VkVertexInputRate"/>
+            <type name="VkViewport"/>
+            <command name="vkCreateGraphicsPipelines"/>
+            <command name="vkCreateComputePipelines"/>
+            <command name="vkDestroyPipeline"/>
+        </require>
+        <require comment="Pipeline layout commands">
+            <type name="VkPipelineLayout"/>
+            <type name="VkPipelineLayoutCreateInfo"/>
+            <type name="VkPushConstantRange"/>
+            <command name="vkCreatePipelineLayout"/>
+            <command name="vkDestroyPipelineLayout"/>
+        </require>
+        <require comment="Sampler commands">
+            <type name="VkBorderColor"/>
+            <type name="VkFilter"/>
+            <type name="VkSampler"/>
+            <type name="VkSamplerAddressMode"/>
+            <type name="VkSamplerCreateFlagBits"/>
+            <type name="VkSamplerCreateFlags"/>
+            <type name="VkSamplerCreateInfo"/>
+            <type name="VkSamplerMipmapMode"/>
+            <command name="vkCreateSampler"/>
+            <command name="vkDestroySampler"/>
+        </require>
+        <require comment="Descriptor set commands">
+            <type name="VkCopyDescriptorSet"/>
+            <type name="VkDescriptorBufferInfo"/>
+            <type name="VkDescriptorImageInfo"/>
+            <type name="VkDescriptorPool"/>
+            <type name="VkDescriptorPoolCreateFlagBits"/>
+            <type name="VkDescriptorPoolCreateFlags"/>
+            <type name="VkDescriptorPoolCreateInfo"/>
+            <type name="VkDescriptorPoolResetFlags"/>
+            <type name="VkDescriptorPoolSize"/>
+            <type name="VkDescriptorSet"/>
+            <type name="VkDescriptorSetAllocateInfo"/>
+            <type name="VkDescriptorSetLayout"/>
+            <type name="VkDescriptorSetLayoutBinding"/>
+            <type name="VkDescriptorSetLayoutCreateFlagBits"/>
+            <type name="VkDescriptorSetLayoutCreateFlags"/>
+            <type name="VkDescriptorSetLayoutCreateInfo"/>
+            <type name="VkDescriptorType"/>
+            <type name="VkWriteDescriptorSet"/>
+            <command name="vkCreateDescriptorSetLayout"/>
+            <command name="vkDestroyDescriptorSetLayout"/>
+            <command name="vkCreateDescriptorPool"/>
+            <command name="vkDestroyDescriptorPool"/>
+            <command name="vkResetDescriptorPool"/>
+            <command name="vkAllocateDescriptorSets"/>
+            <command name="vkFreeDescriptorSets"/>
+            <command name="vkUpdateDescriptorSets"/>
+        </require>
+        <require comment="Pass commands">
+            <type name="VkAccessFlagBits"/>
+            <type name="VkAccessFlags"/>
+            <type name="VkAttachmentDescription"/>
+            <type name="VkAttachmentDescriptionFlagBits"/>
+            <type name="VkAttachmentDescriptionFlags"/>
+            <type name="VkAttachmentLoadOp"/>
+            <type name="VkAttachmentReference"/>
+            <type name="VkAttachmentStoreOp"/>
+            <type name="VkDependencyFlagBits"/>
+            <type name="VkDependencyFlags"/>
+            <type name="VkFramebuffer"/>
+            <type name="VkFramebufferCreateFlagBits"/>
+            <type name="VkFramebufferCreateFlags"/>
+            <type name="VkFramebufferCreateInfo"/>
+            <type name="VkPipelineBindPoint"/>
+            <type name="VkRenderPass"/>
+            <type name="VkRenderPassCreateFlagBits"/>
+            <type name="VkRenderPassCreateFlags"/>
+            <type name="VkRenderPassCreateInfo"/>
+            <type name="VkSubpassDependency"/>
+            <type name="VkSubpassDescription"/>
+            <type name="VkSubpassDescriptionFlagBits"/>
+            <type name="VkSubpassDescriptionFlags"/>
+            <command name="vkCreateFramebuffer"/>
+            <command name="vkDestroyFramebuffer"/>
+            <command name="vkCreateRenderPass"/>
+            <command name="vkDestroyRenderPass"/>
+            <command name="vkGetRenderAreaGranularity"/>
+        </require>
+        <require comment="Command pool commands">
+            <type name="VkCommandPool"/>
+            <type name="VkCommandPoolCreateFlagBits"/>
+            <type name="VkCommandPoolCreateFlags"/>
+            <type name="VkCommandPoolCreateInfo"/>
+            <type name="VkCommandPoolResetFlagBits"/>
+            <type name="VkCommandPoolResetFlags"/>
+            <command name="vkCreateCommandPool"/>
+            <command name="vkDestroyCommandPool"/>
+            <command name="vkResetCommandPool"/>
+        </require>
+        <require comment="Command buffer commands">
+            <type name="VkCommandBuffer"/>
+            <type name="VkCommandBufferAllocateInfo"/>
+            <type name="VkCommandBufferBeginInfo"/>
+            <type name="VkCommandBufferInheritanceInfo"/>
+            <type name="VkCommandBufferLevel"/>
+            <type name="VkCommandBufferResetFlagBits"/>
+            <type name="VkCommandBufferResetFlags"/>
+            <type name="VkCommandBufferUsageFlagBits"/>
+            <type name="VkCommandBufferUsageFlags"/>
+            <type name="VkQueryControlFlagBits"/>
+            <type name="VkQueryControlFlags"/>
+            <command name="vkAllocateCommandBuffers"/>
+            <command name="vkFreeCommandBuffers"/>
+            <command name="vkBeginCommandBuffer"/>
+            <command name="vkEndCommandBuffer"/>
+            <command name="vkResetCommandBuffer"/>
+        </require>
+        <require comment="Command buffer building commands">
+            <type name="VkBufferCopy"/>
+            <type name="VkBufferImageCopy"/>
+            <type name="VkClearAttachment"/>
+            <type name="VkClearColorValue"/>
+            <type name="VkClearDepthStencilValue"/>
+            <type name="VkClearRect"/>
+            <type name="VkClearValue"/>
+            <type name="VkImageBlit"/>
+            <type name="VkImageCopy"/>
+            <type name="VkImageResolve"/>
+            <type name="VkImageSubresourceLayers"/>
+            <type name="VkIndexType"/>
+            <type name="VkRenderPassBeginInfo"/>
+            <type name="VkStencilFaceFlagBits"/>
+            <type name="VkStencilFaceFlags"/>
+            <type name="VkSubpassContents"/>
+            <command name="vkCmdBindPipeline"/>
+            <command name="vkCmdSetViewport"/>
+            <command name="vkCmdSetScissor"/>
+            <command name="vkCmdSetLineWidth"/>
+            <command name="vkCmdSetDepthBias"/>
+            <command name="vkCmdSetBlendConstants"/>
+            <command name="vkCmdSetDepthBounds"/>
+            <command name="vkCmdSetStencilCompareMask"/>
+            <command name="vkCmdSetStencilWriteMask"/>
+            <command name="vkCmdSetStencilReference"/>
+            <command name="vkCmdBindDescriptorSets"/>
+            <command name="vkCmdBindIndexBuffer"/>
+            <command name="vkCmdBindVertexBuffers"/>
+            <command name="vkCmdDraw"/>
+            <command name="vkCmdDrawIndexed"/>
+            <command name="vkCmdDrawIndirect"/>
+            <command name="vkCmdDrawIndexedIndirect"/>
+            <command name="vkCmdDispatch"/>
+            <command name="vkCmdDispatchIndirect"/>
+            <command name="vkCmdCopyBuffer"/>
+            <command name="vkCmdCopyImage"/>
+            <command name="vkCmdBlitImage"/>
+            <command name="vkCmdCopyBufferToImage"/>
+            <command name="vkCmdCopyImageToBuffer"/>
+            <command name="vkCmdUpdateBuffer"/>
+            <command name="vkCmdFillBuffer"/>
+            <command name="vkCmdClearColorImage"/>
+            <command name="vkCmdClearDepthStencilImage"/>
+            <command name="vkCmdClearAttachments"/>
+            <command name="vkCmdResolveImage"/>
+            <command name="vkCmdSetEvent"/>
+            <command name="vkCmdResetEvent"/>
+            <command name="vkCmdWaitEvents"/>
+            <command name="vkCmdPipelineBarrier"/>
+            <command name="vkCmdBeginQuery"/>
+            <command name="vkCmdEndQuery"/>
+            <command name="vkCmdResetQueryPool"/>
+            <command name="vkCmdWriteTimestamp"/>
+            <command name="vkCmdCopyQueryPoolResults"/>
+            <command name="vkCmdPushConstants"/>
+            <command name="vkCmdBeginRenderPass"/>
+            <command name="vkCmdNextSubpass"/>
+            <command name="vkCmdEndRenderPass"/>
+            <command name="vkCmdExecuteCommands"/>
+        </require>
+    </feature>
+    <feature api="vulkan,vulkansc" name="VK_VERSION_1_1" number="1.1" comment="Vulkan 1.1 core API interface definitions.">
+        <require>
+            <type name="VK_API_VERSION_1_1"/>
+        </require>
+        <require comment="Device Initialization">
+            <command name="vkEnumerateInstanceVersion"/>
+        </require>
+        <require comment="Promoted from VK_KHR_relaxed_block_layout, which has no API"/>
+        <require comment="Promoted from VK_KHR_storage_buffer_storage_class, which has no API"/>
+        <require comment="Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95">
+            <enum extends="VkStructureType" extnumber="95"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"/>
+            <type                                       name="VkPhysicalDeviceSubgroupProperties"/>
+            <type                                       name="VkSubgroupFeatureFlags"/>
+            <type                                       name="VkSubgroupFeatureFlagBits"/>
+        </require>
+        <require comment="Promoted from VK_KHR_bind_memory2">
+            <command name="vkBindBufferMemory2"/>
+            <command name="vkBindImageMemory2"/>
+            <enum extends="VkStructureType" extnumber="158" offset="0"          name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
+            <enum extends="VkStructureType" extnumber="158" offset="1"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
+            <enum bitpos="10" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_ALIAS_BIT"/>
+            <type name="VkBindBufferMemoryInfo"/>
+            <type name="VkBindImageMemoryInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_16bit_storage">
+            <enum extends="VkStructureType" extnumber="84"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
+            <type name="VkPhysicalDevice16BitStorageFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_dedicated_allocation">
+            <enum extends="VkStructureType" extnumber="128" offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
+            <enum extends="VkStructureType" extnumber="128" offset="1"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
+            <type name="VkMemoryDedicatedRequirements"/>
+            <type name="VkMemoryDedicatedAllocateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group">
+            <enum extends="VkStructureType" extnumber="61"  offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
+            <comment>offset 1 reserved for the old VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX enum</comment>
+            <comment>offset 2 reserved for the old VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX enum</comment>
+            <enum extends="VkStructureType" extnumber="61"  offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="4"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="5"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="6"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
+            <type name="VkPeerMemoryFeatureFlags"/>
+            <type name="VkPeerMemoryFeatureFlagBits"/>
+            <type name="VkMemoryAllocateFlags"/>
+            <type name="VkMemoryAllocateFlagBits"/>
+            <type name="VkMemoryAllocateFlagsInfo"/>
+            <type name="VkDeviceGroupRenderPassBeginInfo"/>
+            <type name="VkDeviceGroupCommandBufferBeginInfo"/>
+            <type name="VkDeviceGroupSubmitInfo"/>
+            <type name="VkDeviceGroupBindSparseInfo"/>
+            <command name="vkGetDeviceGroupPeerMemoryFeatures"/>
+            <command name="vkCmdSetDeviceMask"/>
+            <command name="vkCmdDispatchBase"/>
+            <enum bitpos="3"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
+            <enum bitpos="4"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
+            <enum extends="VkPipelineCreateFlagBits"                            name="VK_PIPELINE_CREATE_DISPATCH_BASE" alias="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
+            <enum bitpos="2"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_DEVICE_GROUP_BIT" comment="Dependency is across devices"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group + VK_KHR_bind_memory2">
+            <enum extends="VkStructureType" extnumber="61"  offset="13"         name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="14"         name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
+            <type name="VkBindBufferMemoryDeviceGroupInfo"/>
+            <type name="VkBindImageMemoryDeviceGroupInfo"/>
+            <enum bitpos="6"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" comment="Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group_creation">
+            <enum extends="VkStructureType" extnumber="71"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="71"  offset="1"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
+            <enum name="VK_MAX_DEVICE_GROUP_SIZE"/>
+            <type name="VkPhysicalDeviceGroupProperties"/>
+            <type name="VkDeviceGroupDeviceCreateInfo"/>
+            <command name="vkEnumeratePhysicalDeviceGroups"/>
+            <enum bitpos="1"  extends="VkMemoryHeapFlagBits"                    name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" comment="If set, heap allocations allocate multiple instances by default"/>
+        </require>
+        <require comment="Promoted from VK_KHR_get_memory_requirements2">
+            <enum extends="VkStructureType" extnumber="147" offset="0"          name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="1"          name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="3"          name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="4"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
+            <type name="VkBufferMemoryRequirementsInfo2"/>
+            <type name="VkImageMemoryRequirementsInfo2"/>
+            <type name="VkImageSparseMemoryRequirementsInfo2"/>
+            <type name="VkMemoryRequirements2"/>
+            <type name="VkSparseImageMemoryRequirements2"/>
+            <command name="vkGetImageMemoryRequirements2"/>
+            <command name="vkGetBufferMemoryRequirements2"/>
+            <command name="vkGetImageSparseMemoryRequirements2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_get_physical_device_properties2">
+            <enum extends="VkStructureType" extnumber="60"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="2"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="5"          name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="6"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="7"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="8"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
+            <type name="VkPhysicalDeviceFeatures2"/>
+            <type name="VkPhysicalDeviceProperties2"/>
+            <type name="VkFormatProperties2"/>
+            <type name="VkImageFormatProperties2"/>
+            <type name="VkPhysicalDeviceImageFormatInfo2"/>
+            <type name="VkQueueFamilyProperties2"/>
+            <type name="VkPhysicalDeviceMemoryProperties2"/>
+            <type name="VkSparseImageFormatProperties2"/>
+            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
+            <command name="vkGetPhysicalDeviceFeatures2"/>
+            <command name="vkGetPhysicalDeviceProperties2"/>
+            <command name="vkGetPhysicalDeviceFormatProperties2"/>
+            <command name="vkGetPhysicalDeviceImageFormatProperties2"/>
+            <command name="vkGetPhysicalDeviceQueueFamilyProperties2"/>
+            <command name="vkGetPhysicalDeviceMemoryProperties2"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance1">
+            <enum extends="VkResult"        extnumber="70"  offset="0"  dir="-" name="VK_ERROR_OUT_OF_POOL_MEMORY"/>
+            <enum bitpos="14" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT" comment="Format can be used as the source image of image transfer commands"/>
+            <enum bitpos="15" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT" comment="Format can be used as the destination image of image transfer commands"/>
+            <enum bitpos="5"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" comment="The 3D image can be viewed as a 2D or 2D array image"/>
+            <command name="vkTrimCommandPool"/>
+            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
+            <type name="VkCommandPoolTrimFlags"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance2">
+            <enum bitpos="7"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
+            <enum bitpos="8"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
+            <enum extends="VkStructureType" extnumber="118" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="118" offset="1"          name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="118" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="118" offset="3"          name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
+            <enum extends="VkImageLayout"   extnumber="118" offset="0"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
+            <enum extends="VkImageLayout"   extnumber="118" offset="1"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
+            <type name="VkPhysicalDevicePointClippingProperties"/>
+            <type name="VkPointClippingBehavior"/>
+            <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
+            <type name="VkInputAttachmentAspectReference"/>
+            <type name="VkImageViewUsageCreateInfo"/>
+            <type name="VkTessellationDomainOrigin"/>
+            <type name="VkPipelineTessellationDomainOriginStateCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_multiview">
+            <enum extends="VkStructureType" extnumber="54"  offset="0"          name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="54"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="54"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
+            <enum bitpos="1"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
+            <type name="VkRenderPassMultiviewCreateInfo"/>
+            <type name="VkPhysicalDeviceMultiviewFeatures"/>
+            <type name="VkPhysicalDeviceMultiviewProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_variable_pointers">
+            <enum extends="VkStructureType" extnumber="121" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+            <enum api="vulkan" extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+            <type name="VkPhysicalDeviceVariablePointerFeatures"/>
+            <type name="VkPhysicalDeviceVariablePointersFeatures"/>
+        </require>
+        <require comment="Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they were not actually promoted from an extension.">
+            <enum extends="VkStructureType" extnumber="146" offset="0"          name="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"/>
+            <enum extends="VkStructureType" extnumber="146" offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="146" offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="146" offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"/>
+            <enum bitpos="4"  extends="VkQueueFlagBits"                         name="VK_QUEUE_PROTECTED_BIT" comment="Queues may support protected operations"/>
+            <enum bitpos="0"  extends="VkDeviceQueueCreateFlagBits"             name="VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT" comment="Queue is a protected-capable device queue"/>
+            <type name="VkDeviceQueueCreateFlagBits" comment="This is a temporary workaround for processors not recognizing that VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT above also requires this type"/>
+            <enum bitpos="5"  extends="VkMemoryPropertyFlagBits"                name="VK_MEMORY_PROPERTY_PROTECTED_BIT" comment="Memory is protected"/>
+            <enum bitpos="3"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_PROTECTED_BIT" comment="Buffer requires protected memory"/>
+            <enum bitpos="11" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_PROTECTED_BIT" comment="Image requires protected memory"/>
+            <enum bitpos="2"  extends="VkCommandPoolCreateFlagBits"             name="VK_COMMAND_POOL_CREATE_PROTECTED_BIT" comment="Command buffers allocated from pool are protected command buffers"/>
+            <type name="VkPhysicalDeviceProtectedMemoryFeatures"/>
+            <type name="VkPhysicalDeviceProtectedMemoryProperties"/>
+            <type name="VkDeviceQueueInfo2"/>
+            <type name="VkProtectedSubmitInfo"/>
+            <command name="vkGetDeviceQueue2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_sampler_ycbcr_conversion">
+            <enum extends="VkStructureType" extnumber="157" offset="0"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="1"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="2"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="157" offset="5"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
+            <enum extends="VkObjectType"    extnumber="157" offset="0"          name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
+            <enum extends="VkFormat"        extnumber="157" offset="0"          name="VK_FORMAT_G8B8G8R8_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="1"          name="VK_FORMAT_B8G8R8G8_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="2"          name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="3"          name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="4"          name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="5"          name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="6"          name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="7"          name="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="8"          name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="9"          name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="10"         name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="11"         name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="12"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="13"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="14"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="15"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="16"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="17"         name="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="18"         name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="19"         name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="20"         name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="21"         name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="22"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="23"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="24"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="25"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="26"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="27"         name="VK_FORMAT_G16B16G16R16_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="28"         name="VK_FORMAT_B16G16R16G16_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="29"         name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="30"         name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="31"         name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="32"         name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="33"         name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
+            <enum bitpos="4"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
+            <enum bitpos="5"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
+            <enum bitpos="6"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
+            <enum bitpos="9"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_DISJOINT_BIT"/>
+            <enum bitpos="17" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT" comment="Format can have midpoint rather than cosited chroma samples"/>
+            <enum bitpos="18" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT" comment="Format can be used with linear filtering whilst color conversion is enabled"/>
+            <enum bitpos="19" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT" comment="Format can have different chroma, min and mag filters"/>
+            <enum bitpos="20" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+            <enum bitpos="21" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+            <enum bitpos="22" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_DISJOINT_BIT" comment="Format supports disjoint planes"/>
+            <enum bitpos="23" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT" comment="Format can have cosited rather than midpoint chroma samples"/>
+            <type name="VkSamplerYcbcrConversionCreateInfo"/>
+            <type name="VkSamplerYcbcrConversionInfo"/>
+            <type name="VkBindImagePlaneMemoryInfo"/>
+            <type name="VkImagePlaneMemoryRequirementsInfo"/>
+            <type name="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
+            <type name="VkSamplerYcbcrConversionImageFormatProperties"/>
+            <command name="vkCreateSamplerYcbcrConversion"/>
+            <command name="vkDestroySamplerYcbcrConversion"/>
+            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
+            <type name="VkSamplerYcbcrConversion"/>
+            <type name="VkSamplerYcbcrModelConversion"/>
+            <type name="VkSamplerYcbcrRange"/>
+            <type name="VkChromaLocation"/>
+        </require>
+        <require comment="Promoted from VK_KHR_descriptor_update_template">
+            <enum extends="VkStructureType" extnumber="86"  offset="0"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
+            <enum extends="VkObjectType"    extnumber="86"  offset="0"          name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
+            <command name="vkCreateDescriptorUpdateTemplate"/>
+            <command name="vkDestroyDescriptorUpdateTemplate"/>
+            <command name="vkUpdateDescriptorSetWithTemplate"/>
+            <type name="VkDescriptorUpdateTemplate"/>
+            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
+            <type name="VkDescriptorUpdateTemplateType"/>
+            <type name="VkDescriptorUpdateTemplateEntry"/>
+            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_memory_capabilities">
+            <enum extends="VkStructureType" extnumber="72"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="3"          name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+            <enum name="VK_LUID_SIZE"/>
+            <type name="VkExternalMemoryHandleTypeFlags"/>
+            <type name="VkExternalMemoryHandleTypeFlagBits"/>
+            <type name="VkExternalMemoryFeatureFlags"/>
+            <type name="VkExternalMemoryFeatureFlagBits"/>
+            <type name="VkExternalMemoryProperties"/>
+            <type name="VkPhysicalDeviceExternalImageFormatInfo"/>
+            <type name="VkExternalImageFormatProperties"/>
+            <type name="VkPhysicalDeviceExternalBufferInfo"/>
+            <type name="VkExternalBufferProperties"/>
+            <type name="VkPhysicalDeviceIDProperties"/>
+            <command name="vkGetPhysicalDeviceExternalBufferProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_memory">
+            <enum extends="VkStructureType" extnumber="73"  offset="0"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="73"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="73"  offset="2"          name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
+            <enum extends="VkResult"        extnumber="73"  offset="3"  dir="-" name="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
+            <enum name="VK_QUEUE_FAMILY_EXTERNAL"/>
+            <type name="VkExternalMemoryImageCreateInfo"/>
+            <type name="VkExternalMemoryBufferCreateInfo"/>
+            <type name="VkExportMemoryAllocateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_fence_capabilities">
+            <enum extends="VkStructureType" extnumber="113" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
+            <enum extends="VkStructureType" extnumber="113" offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
+            <type name="VkExternalFenceHandleTypeFlags"/>
+            <type name="VkExternalFenceHandleTypeFlagBits"/>
+            <type name="VkExternalFenceFeatureFlags"/>
+            <type name="VkExternalFenceFeatureFlagBits"/>
+            <type name="VkPhysicalDeviceExternalFenceInfo"/>
+            <type name="VkExternalFenceProperties"/>
+            <command name="vkGetPhysicalDeviceExternalFenceProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_fence">
+            <enum extends="VkStructureType" extnumber="114" offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
+            <type name="VkFenceImportFlags"/>
+            <type name="VkFenceImportFlagBits"/>
+            <type name="VkExportFenceCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_semaphore">
+            <enum extends="VkStructureType" extnumber="78"  offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
+            <type name="VkSemaphoreImportFlags"/>
+            <type name="VkSemaphoreImportFlagBits"/>
+            <type name="VkExportSemaphoreCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_semaphore_capabilities">
+            <enum extends="VkStructureType" extnumber="77"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
+            <enum extends="VkStructureType" extnumber="77"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
+            <type name="VkExternalSemaphoreHandleTypeFlags"/>
+            <type name="VkExternalSemaphoreHandleTypeFlagBits"/>
+            <type name="VkExternalSemaphoreFeatureFlags"/>
+            <type name="VkExternalSemaphoreFeatureFlagBits"/>
+            <type name="VkPhysicalDeviceExternalSemaphoreInfo"/>
+            <type name="VkExternalSemaphoreProperties"/>
+            <command name="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance3">
+            <enum extends="VkStructureType" extnumber="169" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="169" offset="1"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
+            <type name="VkPhysicalDeviceMaintenance3Properties"/>
+            <type name="VkDescriptorSetLayoutSupport"/>
+            <command name="vkGetDescriptorSetLayoutSupport"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_draw_parameters, with a feature support query added">
+            <enum extends="VkStructureType" extnumber="64"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
+            <enum api="vulkan" extends="VkStructureType"                                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderDrawParameterFeatures"/>
+            <type name="VkPhysicalDeviceShaderDrawParametersFeatures"/>
+        </require>
+    </feature>
+    <feature api="vulkan,vulkansc" name="VK_VERSION_1_2" number="1.2" comment="Vulkan 1.2 core API interface definitions.">
+        <require>
+            <type name="VK_API_VERSION_1_2"/>
+        </require>
+        <require>
+            <enum extends="VkStructureType" value="49" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"/>
+            <enum extends="VkStructureType" value="50" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"/>
+            <enum extends="VkStructureType" value="51" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"/>
+            <enum extends="VkStructureType" value="52" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"/>
+            <type name="VkPhysicalDeviceVulkan11Features"/>
+            <type name="VkPhysicalDeviceVulkan11Properties"/>
+            <type name="VkPhysicalDeviceVulkan12Features"/>
+            <type name="VkPhysicalDeviceVulkan12Properties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_image_format_list (extension 148)">
+            <enum offset="0" extends="VkStructureType"  extnumber="148"         name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
+            <type name="VkImageFormatListCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_sampler_mirror_clamp_to_edge (extension 15)">
+            <enum value="4" extends="VkSamplerAddressMode"                      name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="No need to add an extnumber attribute, since this uses a core enum value"/>
+        </require>
+        <require comment="Promoted from VK_KHR_draw_indirect_count (extension 170)">
+            <command name="vkCmdDrawIndirectCount"/>
+            <command name="vkCmdDrawIndexedIndirectCount"/>
+        </require>
+        <require comment="Promoted from VK_KHR_create_renderpass2 (extension 110)">
+            <enum offset="0" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
+            <enum offset="1" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
+            <enum offset="2" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
+            <enum offset="3" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
+            <enum offset="4" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
+            <enum offset="5" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
+            <enum offset="6" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
+            <command name="vkCreateRenderPass2"/>
+            <command name="vkCmdBeginRenderPass2"/>
+            <command name="vkCmdNextSubpass2"/>
+            <command name="vkCmdEndRenderPass2"/>
+            <type name="VkRenderPassCreateInfo2"/>
+            <type name="VkAttachmentDescription2"/>
+            <type name="VkAttachmentReference2"/>
+            <type name="VkSubpassDescription2"/>
+            <type name="VkSubpassDependency2"/>
+            <type name="VkSubpassBeginInfo"/>
+            <type name="VkSubpassEndInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_8bit_storage (extension 178)">
+            <enum offset="0" extends="VkStructureType" extnumber="178"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
+            <type name="VkPhysicalDevice8BitStorageFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_driver_properties (extension 197)">
+            <enum offset="0" extends="VkStructureType" extnumber="197"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
+            <enum name="VK_MAX_DRIVER_NAME_SIZE"/>
+            <enum name="VK_MAX_DRIVER_INFO_SIZE"/>
+            <type name="VkDriverId"/>
+            <type name="VkConformanceVersion"/>
+            <type name="VkPhysicalDeviceDriverProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_atomic_int64 (extension 181)">
+            <enum offset="0" extends="VkStructureType" extnumber="181"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderAtomicInt64Features"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_float16_int8 (extension 83)">
+            <enum offset="0" extends="VkStructureType" extnumber="83"           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_float_controls (extension 198)">
+            <enum offset="0" extends="VkStructureType" extnumber="198"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
+            <type name="VkPhysicalDeviceFloatControlsProperties"/>
+            <type name="VkShaderFloatControlsIndependence"/>
+        </require>
+        <require comment="Promoted from VK_EXT_descriptor_indexing (extension 162)">
+            <enum offset="0" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
+            <enum offset="1" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
+            <enum offset="3" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
+            <enum bitpos="1" extends="VkDescriptorPoolCreateFlagBits"           name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
+            <enum bitpos="1" extends="VkDescriptorSetLayoutCreateFlagBits"      name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
+            <enum offset="0" dir="-" extends="VkResult" extnumber="162"         name="VK_ERROR_FRAGMENTATION"/>
+            <type name="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
+            <type name="VkPhysicalDeviceDescriptorIndexingFeatures"/>
+            <type name="VkPhysicalDeviceDescriptorIndexingProperties"/>
+            <type name="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
+            <type name="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
+            <type name="VkDescriptorBindingFlagBits"/>
+            <type name="VkDescriptorBindingFlags"/>
+        </require>
+        <require comment="Promoted from VK_KHR_depth_stencil_resolve (extension 200)">
+            <enum offset="0" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
+            <type name="VkSubpassDescriptionDepthStencilResolve"/>
+            <type name="VkPhysicalDeviceDepthStencilResolveProperties"/>
+            <type name="VkResolveModeFlagBits"/>
+            <type name="VkResolveModeFlags"/>
+        </require>
+        <require comment="Promoted from VK_EXT_scalar_block_layout (extension 222))">
+            <type                                                               name="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
+            <enum offset="0" extends="VkStructureType" extnumber="222"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
+        </require>
+        <require comment="Promoted from VK_EXT_shader_viewport_index_layer, which has no API (extension 163)"/>
+        <require comment="Promoted from VK_EXT_separate_stencil_usage (extension 247)">
+            <enum offset="0" extends="VkStructureType" extnumber="247"          name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
+            <type name="VkImageStencilUsageCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_EXT_sampler_filter_minmax (extension 131)">
+            <enum offset="0" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
+            <enum bitpos="16" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT" comment="Format can be used with min/max reduction filtering"/>
+            <type name="VkSamplerReductionMode"/>
+            <type name="VkSamplerReductionModeCreateInfo"/>
+            <type name="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_vulkan_memory_model (extension 212)">
+            <enum offset="0" extends="VkStructureType" extnumber="212"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
+            <type name="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_imageless_framebuffer (extension 109)">
+            <type name="VkPhysicalDeviceImagelessFramebufferFeatures"/>
+            <type name="VkFramebufferAttachmentsCreateInfo"/>
+            <type name="VkFramebufferAttachmentImageInfo"/>
+            <type name="VkRenderPassAttachmentBeginInfo"/>
+            <enum offset="0" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
+            <enum offset="2" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
+            <enum bitpos="0" extends="VkFramebufferCreateFlagBits"              name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
+        </require>
+        <require comment="Promoted from VK_KHR_uniform_buffer_standard_layout (extension 254)">
+            <type name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
+            <enum offset="0" extends="VkStructureType" extnumber="254"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_subgroup_extended_types (extension 176)">
+            <enum offset="0" extends="VkStructureType" extnumber="176"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_spirv_1_4 (extension 237)">
+        </require>
+        <require comment="Promoted from VK_KHR_separate_depth_stencil_layouts (extension 242)">
+            <enum offset="0" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
+            <enum offset="2" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
+            <enum offset="0" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
+            <enum offset="1" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
+            <enum offset="2" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
+            <enum offset="3" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
+            <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
+            <type name="VkAttachmentReferenceStencilLayout"/>
+            <type name="VkAttachmentDescriptionStencilLayout"/>
+        </require>
+        <require comment="Promoted from VK_EXT_host_query_reset (extension 262)">
+            <enum offset="0" extends="VkStructureType" extnumber="262"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
+            <type name="VkPhysicalDeviceHostQueryResetFeatures"/>
+            <command name="vkResetQueryPool"/>
+        </require>
+        <require comment="Promoted from VK_KHR_timeline_semaphore (extension 208)">
+            <enum offset="0" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
+            <enum offset="5" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
+            <type name="VkSemaphoreType"/>
+            <type name="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
+            <type name="VkPhysicalDeviceTimelineSemaphoreProperties"/>
+            <type name="VkSemaphoreTypeCreateInfo"/>
+            <type name="VkTimelineSemaphoreSubmitInfo"/>
+            <type name="VkSemaphoreWaitFlagBits"/>
+            <type name="VkSemaphoreWaitFlags"/>
+            <type name="VkSemaphoreWaitInfo"/>
+            <type name="VkSemaphoreSignalInfo"/>
+            <command name="vkGetSemaphoreCounterValue"/>
+            <command name="vkWaitSemaphores"/>
+            <command name="vkSignalSemaphore"/>
+        </require>
+        <require comment="Promoted from VK_KHR_buffer_device_address (extension 258)">
+            <enum offset="0" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="245"          name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+            <enum offset="2" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
+            <enum bitpos="17" extends="VkBufferUsageFlagBits"                   name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+            <enum bitpos="4"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+            <enum bitpos="1" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
+            <enum bitpos="2" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+            <enum offset="0" dir="-" extends="VkResult" extnumber="258"         name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+            <type name="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
+            <type name="VkBufferDeviceAddressInfo"/>
+            <type name="VkBufferOpaqueCaptureAddressCreateInfo"/>
+            <type name="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
+            <type name="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
+            <command name="vkGetBufferDeviceAddress"/>
+            <command name="vkGetBufferOpaqueCaptureAddress"/>
+            <command name="vkGetDeviceMemoryOpaqueCaptureAddress"/>
+        </require>
+    </feature>
+    <feature api="vulkan,vulkansc" name="VK_VERSION_1_3" number="1.3" comment="Vulkan 1.3 core API interface definitions.">
+        <require>
+            <type name="VK_API_VERSION_1_3"/>
+        </require>
+        <require>
+            <type name="VkFlags64"/>
+        </require>
+        <require>
+            <enum extends="VkStructureType" value="53"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"/>
+            <enum extends="VkStructureType" value="54"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"/>
+            <type name="VkPhysicalDeviceVulkan13Features"/>
+            <type name="VkPhysicalDeviceVulkan13Properties"/>
+        </require>
+        <require comment="Promoted from VK_EXT_pipeline_creation_feedback (extension 193)">
+            <enum offset="0" extends="VkStructureType"  extnumber="193"         name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"/>
+            <type name="VkPipelineCreationFeedbackFlagBits"/>
+            <type name="VkPipelineCreationFeedbackFlags"/>
+            <type name="VkPipelineCreationFeedbackCreateInfo"/>
+            <type name="VkPipelineCreationFeedback"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_terminate_invocation (extension 216)">
+            <enum offset="0" extends="VkStructureType"  extnumber="216"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderTerminateInvocationFeatures"/>
+        </require>
+        <require comment="Promoted from VK_EXT_tooling_info (extension 246)">
+            <enum offset="0" extends="VkStructureType"  extnumber="246"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"/>
+            <type name="VkToolPurposeFlagBits"/>
+            <type name="VkToolPurposeFlags"/>
+            <type name="VkPhysicalDeviceToolProperties"/>
+            <command name="vkGetPhysicalDeviceToolProperties"/>
+        </require>
+        <require comment="Promoted from VK_EXT_shader_demote_to_helper_invocation (extension 277)">
+            <enum offset="0" extends="VkStructureType"  extnumber="277"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_non_semantic_info (extension 294)">
+        </require>
+        <require comment="Promoted from VK_EXT_private_data (extension 296)">
+            <enum offset="0" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"/>
+            <enum offset="1" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"/>
+            <enum offset="2" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"/>
+            <enum offset="0" extends="VkObjectType"     extnumber="296"         name="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"/>
+            <type name="VkPhysicalDevicePrivateDataFeatures"/>
+            <type name="VkDevicePrivateDataCreateInfo"/>
+            <type name="VkPrivateDataSlotCreateInfo"/>
+            <type name="VkPrivateDataSlot"/>
+            <type name="VkPrivateDataSlotCreateFlags" comment="Will add VkPrivateDataSlotCreateFlagBits when bits are defined in the future"/>
+            <command name="vkCreatePrivateDataSlot"/>
+            <command name="vkDestroyPrivateDataSlot"/>
+            <command name="vkSetPrivateData"/>
+            <command name="vkGetPrivateData"/>
+        </require>
+        <require comment="Promoted from VK_EXT_pipeline_creation_cache_control (extension 298)">
+            <enum offset="0" extends="VkStructureType"  extnumber="298"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"/>
+            <type name="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
+            <enum bitpos="8" extends="VkPipelineCreateFlagBits"                 name="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
+            <enum bitpos="9" extends="VkPipelineCreateFlagBits"                 name="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"/>
+            <enum offset="0" extends="VkResult"         extnumber="298"         name="VK_PIPELINE_COMPILE_REQUIRED"/>
+            <enum bitpos="0" extends="VkPipelineCacheCreateFlagBits"            name="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"/>
+        </require>
+        <require comment="Promoted from VK_KHR_synchronization2 (extension 315)">
+            <enum offset="0" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"/>
+            <enum offset="1" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"/>
+            <enum offset="2" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"/>
+            <enum offset="3" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"/>
+            <enum offset="4" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"/>
+            <enum offset="5" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"/>
+            <enum offset="6" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"/>
+            <enum offset="7" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"/>
+            <enum bitpos="0" extends="VkEventCreateFlagBits"                    name="VK_EVENT_CREATE_DEVICE_ONLY_BIT"/>
+            <enum offset="0" extends="VkImageLayout"    extnumber="315"         name="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"/>
+            <enum offset="1" extends="VkImageLayout"    extnumber="315"         name="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"/>
+            <enum value="0"  extends="VkPipelineStageFlagBits"                  name="VK_PIPELINE_STAGE_NONE"/>
+            <enum value="0"  extends="VkAccessFlagBits"                         name="VK_ACCESS_NONE"/>
+            <type name="VkPipelineStageFlags2"/>
+            <type name="VkPipelineStageFlagBits2"/>
+            <type name="VkAccessFlags2"/>
+            <type name="VkAccessFlagBits2"/>
+            <type name="VkMemoryBarrier2"/>
+            <type name="VkBufferMemoryBarrier2"/>
+            <type name="VkImageMemoryBarrier2"/>
+            <type name="VkDependencyInfo"/>
+            <type name="VkSubmitInfo2"/>
+            <type name="VkSemaphoreSubmitInfo"/>
+            <type name="VkCommandBufferSubmitInfo"/>
+            <type name="VkSubmitFlagBits"/>
+            <type name="VkSubmitFlags"/>
+            <type name="VkPhysicalDeviceSynchronization2Features"/>
+            <command name="vkCmdSetEvent2"/>
+            <command name="vkCmdResetEvent2"/>
+            <command name="vkCmdWaitEvents2"/>
+            <command name="vkCmdPipelineBarrier2"/>
+            <command name="vkCmdWriteTimestamp2"/>
+            <command name="vkQueueSubmit2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_zero_initialize_workgroup_memory (extension 326)">
+            <enum offset="0" extends="VkStructureType"  extnumber="326"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"/>
+            <type name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"/>
+        </require>
+        <require comment="Promoted from VK_EXT_image_robustness (extension 336)">
+            <enum offset="0" extends="VkStructureType"  extnumber="336"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"/>
+            <type name="VkPhysicalDeviceImageRobustnessFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_copy_commands2 (extension 338)">
+            <enum offset="0" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"/>
+            <enum offset="1" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"/>
+            <enum offset="2" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"/>
+            <enum offset="3" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"/>
+            <enum offset="4" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"/>
+            <enum offset="5" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"/>
+            <enum offset="6" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BUFFER_COPY_2"/>
+            <enum offset="7" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_COPY_2"/>
+            <enum offset="8" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"/>
+            <enum offset="9" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"/>
+            <enum offset="10" extends="VkStructureType" extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"/>
+            <type name="VkCopyBufferInfo2"/>
+            <type name="VkCopyImageInfo2"/>
+            <type name="VkCopyBufferToImageInfo2"/>
+            <type name="VkCopyImageToBufferInfo2"/>
+            <type name="VkBlitImageInfo2"/>
+            <type name="VkResolveImageInfo2"/>
+            <type name="VkBufferCopy2"/>
+            <type name="VkImageCopy2"/>
+            <type name="VkImageBlit2"/>
+            <type name="VkBufferImageCopy2"/>
+            <type name="VkImageResolve2"/>
+            <command name="vkCmdCopyBuffer2"/>
+            <command name="vkCmdCopyImage2"/>
+            <command name="vkCmdCopyBufferToImage2"/>
+            <command name="vkCmdCopyImageToBuffer2"/>
+            <command name="vkCmdBlitImage2"/>
+            <command name="vkCmdResolveImage2"/>
+        </require>
+        <require comment="Promoted from VK_EXT_subgroup_size_control (STDPROMOTE/PROPLIMCHANGE) (extension 226)">
+            <type name="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
+            <type name="VkPhysicalDeviceSubgroupSizeControlProperties"/>
+            <type name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
+            <enum offset="0" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"/>
+            <enum offset="1" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
+            <enum offset="2" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"/>
+            <enum bitpos="0" extends="VkPipelineShaderStageCreateFlagBits"      name="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"/>
+            <enum bitpos="1" extends="VkPipelineShaderStageCreateFlagBits"      name="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"/>
+        </require>
+        <require comment="Promoted from VK_EXT_inline_uniform_block (STDPROMOTE/PROPLIMCHANGE) (extension 139)">
+            <enum offset="0" extends="VkDescriptorType" extnumber="139"         name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"/>
+            <enum offset="0" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"/>
+            <enum offset="3" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"/>
+            <type name="VkPhysicalDeviceInlineUniformBlockFeatures"/>
+            <type name="VkPhysicalDeviceInlineUniformBlockProperties"/>
+            <type name="VkWriteDescriptorSetInlineUniformBlock"/>
+            <type name="VkDescriptorPoolInlineUniformBlockCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_EXT_ycbcr_2plane_444_formats (does not promote the Feature struct, just the formats) (extension 331)">
+            <enum offset="0" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"/>
+            <enum offset="1" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"/>
+            <enum offset="2" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"/>
+            <enum offset="3" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"/>
+        </require>
+        <require comment="Promoted from VK_EXT_4444_formats (does not promote the Feature struct, just the formats) (extension 341)">
+            <enum offset="0" extends="VkFormat" extnumber="341"                 name="VK_FORMAT_A4R4G4B4_UNORM_PACK16"/>
+            <enum offset="1" extends="VkFormat" extnumber="341"                 name="VK_FORMAT_A4B4G4R4_UNORM_PACK16"/>
+        </require>
+        <require comment="Promoted from VK_EXT_texture_compression_astc_hdr (Feature struct is promoted, but becomes optional) (extension 67)">
+            <enum offset="0"  extends="VkStructureType" extnumber="67"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"/>
+            <type name="VkPhysicalDeviceTextureCompressionASTCHDRFeatures"/>
+            <enum offset="0"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"/>
+            <enum offset="1"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"/>
+            <enum offset="2"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"/>
+            <enum offset="3"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"/>
+            <enum offset="4"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"/>
+            <enum offset="5"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"/>
+            <enum offset="6"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"/>
+            <enum offset="7"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"/>
+            <enum offset="8"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"/>
+            <enum offset="9"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"/>
+            <enum offset="10" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"/>
+            <enum offset="11" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"/>
+            <enum offset="12" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"/>
+            <enum offset="13" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"/>
+        </require>
+        <require comment="Promoted from VK_KHR_dynamic_rendering (extension 45)">
+            <command name="vkCmdBeginRendering"/>
+            <command name="vkCmdEndRendering"/>
+            <enum offset="0" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_INFO"/>
+            <enum offset="1" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"/>
+            <enum offset="2" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"/>
+            <enum offset="4" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"/>
+            <enum offset="0" extends="VkAttachmentStoreOp" extnumber="302"      name="VK_ATTACHMENT_STORE_OP_NONE"/>
+            <type name="VkRenderingInfo"/>
+            <type name="VkRenderingAttachmentInfo"/>
+            <type name="VkPipelineRenderingCreateInfo"/>
+            <type name="VkPhysicalDeviceDynamicRenderingFeatures"/>
+            <type name="VkCommandBufferInheritanceRenderingInfo"/>
+            <type name="VkRenderingFlags"/>
+            <type name="VkRenderingFlagBits"/>
+        </require>
+        <require comment="Promoted from VK_EXT_extended_dynamic_state (Feature struct is not promoted) (extension 268)">
+            <enum offset="0" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_CULL_MODE"/>
+            <enum offset="1" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_FRONT_FACE"/>
+            <enum offset="2" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"/>
+            <enum offset="3" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"/>
+            <enum offset="4" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"/>
+            <enum offset="5" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"/>
+            <enum offset="6" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"/>
+            <enum offset="7" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"/>
+            <enum offset="8" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"/>
+            <enum offset="9" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"/>
+            <enum offset="10" extends="VkDynamicState" extnumber="268"          name="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"/>
+            <enum offset="11" extends="VkDynamicState" extnumber="268"          name="VK_DYNAMIC_STATE_STENCIL_OP"/>
+            <command name="vkCmdSetCullMode"/>
+            <command name="vkCmdSetFrontFace"/>
+            <command name="vkCmdSetPrimitiveTopology"/>
+            <command name="vkCmdSetViewportWithCount"/>
+            <command name="vkCmdSetScissorWithCount"/>
+            <command name="vkCmdBindVertexBuffers2"/>
+            <command name="vkCmdSetDepthTestEnable"/>
+            <command name="vkCmdSetDepthWriteEnable"/>
+            <command name="vkCmdSetDepthCompareOp"/>
+            <command name="vkCmdSetDepthBoundsTestEnable"/>
+            <command name="vkCmdSetStencilTestEnable"/>
+            <command name="vkCmdSetStencilOp"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_integer_dot_product (extension 281)">
+            <enum offset="0" extends="VkStructureType" extnumber="281"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="281"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"/>
+            <type name="VkPhysicalDeviceShaderIntegerDotProductFeatures"/>
+            <type name="VkPhysicalDeviceShaderIntegerDotProductProperties"/>
+        </require>
+        <require comment="Promoted from VK_EXT_texel_buffer_alignment (extension 282)">
+            <enum offset="1" extends="VkStructureType" extnumber="282"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"/>
+            <type name="VkPhysicalDeviceTexelBufferAlignmentProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_format_feature_flags2 (extension 361)">
+            <enum offset="0" extends="VkStructureType" extnumber="361"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"/>
+            <type name="VkFormatFeatureFlags2"/>
+            <type name="VkFormatFeatureFlagBits2"/>
+            <type name="VkFormatProperties3"/>
+        </require>
+        <require comment="Promoted from VK_EXT_extended_dynamic_state2 (Feature struct and optional state are not promoted) (extension 378)">
+            <enum offset="1" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"/>
+            <enum offset="2" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"/>
+            <enum offset="4" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"/>
+            <command name="vkCmdSetRasterizerDiscardEnable"/>
+            <command name="vkCmdSetDepthBiasEnable"/>
+            <command name="vkCmdSetPrimitiveRestartEnable"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance4 (extension 414)">
+            <enum offset="0" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"/>
+            <enum offset="3" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"/>
+            <enum value="0"  extends="VkImageAspectFlagBits"                    name="VK_IMAGE_ASPECT_NONE"/>
+            <type name="VkPhysicalDeviceMaintenance4Features"/>
+            <type name="VkPhysicalDeviceMaintenance4Properties"/>
+            <type name="VkDeviceBufferMemoryRequirements"/>
+            <type name="VkDeviceImageMemoryRequirements"/>
+            <command name="vkGetDeviceBufferMemoryRequirements"/>
+            <command name="vkGetDeviceImageMemoryRequirements"/>
+            <command name="vkGetDeviceImageSparseMemoryRequirements"/>
+        </require>
+    </feature>
+
+    <feature api="vulkansc" name="VKSC_VERSION_1_0" number="1.0" comment="Vulkan SC core API interface definitions">
+        <require>
+            <type name="VKSC_API_VARIANT"/>
+            <type name="VKSC_API_VERSION_1_0"/>
+            <type name="VkPhysicalDeviceVulkanSC10Features"/>
+            <type name="VkPhysicalDeviceVulkanSC10Properties"/>
+            <enum offset="0" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES"/>
+            <enum offset="1" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES"/>
+            <enum offset="1" extnumber="12" extends="VkResult" dir="-"  name="VK_ERROR_VALIDATION_FAILED"/>
+        </require>
+        <require comment="static memory functionality">
+            <type name="VkDeviceObjectReservationCreateInfo"/>
+            <type name="VkCommandPoolMemoryReservationCreateInfo"/>
+            <type name="VkCommandPoolMemoryConsumption"/>
+            <type name="VkPipelinePoolSize"/>
+            <command name="vkGetCommandPoolMemoryConsumption"/>
+            <enum offset="2" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO"/>
+            <enum offset="3" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO"/>
+            <enum offset="4" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION"/>
+            <enum offset="5" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE"/>
+        </require>
+        <require comment="fault handling functionality">
+            <enum offset="7" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_FAULT_DATA"/>
+            <enum offset="8" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO"/>
+            <type name="VkFaultData"/>
+            <type name="VkFaultCallbackInfo"/>
+            <type name="VkFaultLevel"/>
+            <type name="VkFaultType"/>
+            <type name="VkFaultQueryBehavior"/>
+            <type name="PFN_vkFaultCallbackFunction"/>
+            <command name="vkGetFaultData"/>
+        </require>
+        <require comment="pipeline offline create info">
+            <enum offset="10" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO"/>
+            <type name="VkPipelineOfflineCreateInfo"/>
+            <type name="VkPipelineMatchControl"/>
+        </require>
+        <require comment="pipeline cache functionality">
+            <enum offset="0" extnumber="299" extends="VkResult" dir="-" name="VK_ERROR_INVALID_PIPELINE_CACHE_DATA"/>
+            <enum offset="1" extnumber="299" extends="VkResult" dir="-" name="VK_ERROR_NO_PIPELINE_MATCH"/>
+            <enum bitpos="1" extends="VkPipelineCacheCreateFlagBits"    name="VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT"/>
+            <enum bitpos="2" extends="VkPipelineCacheCreateFlagBits"    name="VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT"/>
+            <type name="VkPipelineCacheCreateFlagBits" comment="This should be picked up from the extends= attributes above"/>
+        </require>
+        <require comment="seu safe memory functionality">
+            <enum bitpos="2" extends="VkMemoryHeapFlagBits"             name="VK_MEMORY_HEAP_SEU_SAFE_BIT"/>
+        </require>
+        <require comment="pipeline cache header - These types are part of the API, though not all directly used in API commands or data structures">
+            <enum offset="1" extnumber="299" extends="VkPipelineCacheHeaderVersion"    name="VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE"/>
+            <type name="VkPipelineCacheValidationVersion"/>
+            <type name="VkPipelineCacheStageValidationIndexEntry"/>
+            <type name="VkPipelineCacheSafetyCriticalIndexEntry"/>
+            <type name="VkPipelineCacheHeaderVersionSafetyCriticalOne"/>
+        </require>
+
+        <remove comment="SC 1.0 removes some features from Vulkan 1.0/1.1/1.2">
+            <enum name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
+            <!--enum name="VK_OBJECT_TYPE_SHADER_MODULE" comment="leave this present for compatibility"/-->
+            <enum name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
+            <enum name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
+            <enum name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"/>
+
+            <!-- Remove Vulkan and deprecated macros -->
+            <type name="VK_API_VERSION"/>
+            <type name="VK_MAKE_VERSION"/>
+            <type name="VK_VERSION_MAJOR"/>
+            <type name="VK_VERSION_MINOR"/>
+            <type name="VK_VERSION_PATCH"/>
+
+            <!--type name="VkShaderModule" comment="leave this present for compatibility"/-->
+            <type name="VkShaderModuleCreateFlags"/>
+            <type name="VkShaderModuleCreateFlagBits"/>
+            <type name="VkShaderModuleCreateInfo"/>
+            <type name="VkCommandPoolTrimFlags"/>
+            <command name="vkCreateShaderModule"/>
+            <command name="vkDestroyShaderModule"/>
+            <command name="vkMergePipelineCaches"/>
+            <command name="vkGetPipelineCacheData"/>
+            <command name="vkTrimCommandPool"/>
+            <command name="vkDestroyCommandPool"/>
+            <command name="vkDestroyDescriptorPool"/>
+            <command name="vkDestroyQueryPool"/>
+            <command name="vkDestroySwapchainKHR"/>
+            <command name="vkFreeMemory"/>
+
+            <!-- Descriptor update templates are unsupported -->
+            <enum name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
+            <enum name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
+            <command name="vkCreateDescriptorUpdateTemplate"/>
+            <command name="vkDestroyDescriptorUpdateTemplate"/>
+            <command name="vkUpdateDescriptorSetWithTemplate"/>
+            <type name="VkDescriptorUpdateTemplate"/>
+            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
+            <type name="VkDescriptorUpdateTemplateType"/>
+            <type name="VkDescriptorUpdateTemplateEntry"/>
+            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
+            <enum name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
+
+            <!-- Sparse resources are unsupported -->
+            <enum name="VK_QUEUE_SPARSE_BINDING_BIT"/>
+            <!--type name="VkPhysicalDeviceSparseProperties" comment="needed for VkPhysicalDeviceProperties"/-->
+            <type name="VkSparseImageFormatProperties"/>
+            <type name="VkSparseImageFormatFlagBits"/>
+            <type name="VkSparseImageFormatFlags"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
+            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
+            <enum name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
+            <type name="VkSparseImageFormatProperties2"/>
+            <enum name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
+            <type name="VkSparseImageMemoryRequirements"/>
+            <command name="vkGetImageSparseMemoryRequirements"/>
+            <command name="vkGetImageSparseMemoryRequirements2"/>
+            <type name="VkImageSparseMemoryRequirementsInfo2"/>
+            <enum name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
+            <type name="VkSparseImageMemoryRequirements2"/>
+            <enum name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
+            <type name="VkSparseMemoryBind"/>
+            <type name="VkSparseMemoryBindFlagBits"/>
+            <type name="VkSparseMemoryBindFlags"/>
+            <type name="VkSparseBufferMemoryBindInfo"/>
+            <type name="VkSparseImageOpaqueMemoryBindInfo"/>
+            <type name="VkSparseImageMemoryBindInfo"/>
+            <type name="VkSparseImageMemoryBind"/>
+            <command name="vkQueueBindSparse"/>
+            <type name="VkBindSparseInfo"/>
+            <enum name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
+            <type name="VkDeviceGroupBindSparseInfo"/>
+            <enum name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
+
+            <command name="vkDestroySemaphoreSciSyncPoolNV"/>
+        </remove>
+    </feature>
+
+    <extensions comment="Vulkan extension interface definitions">
+        <extension name="VK_KHR_surface" number="1" type="instance" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="25"                                                name="VK_KHR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_surface&quot;"                        name="VK_KHR_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_SURFACE_LOST_KHR"/>
+                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SURFACE_KHR"/>
+                <type name="VkSurfaceKHR"/>
+                <type name="VkSurfaceTransformFlagBitsKHR"/>
+                <type name="VkPresentModeKHR"/>
+                <type name="VkColorSpaceKHR"/>
+                <type name="VkCompositeAlphaFlagBitsKHR"/>
+                <type name="VkCompositeAlphaFlagsKHR"/>
+                <type name="VkSurfaceCapabilitiesKHR"/>
+                <type name="VkSurfaceFormatKHR"/>
+                <command name="vkDestroySurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
+                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_swapchain" number="2" type="device" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="70"                                                name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_swapchain&quot;"                      name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
+                <enum offset="2" extends="VkImageLayout"                        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
+                <enum offset="3" extends="VkResult"                             name="VK_SUBOPTIMAL_KHR"/>
+                <enum offset="4" extends="VkResult" dir="-"                     name="VK_ERROR_OUT_OF_DATE_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SWAPCHAIN_KHR"/>
+                <type name="VkSwapchainCreateFlagBitsKHR"/>
+                <type name="VkSwapchainCreateFlagsKHR"/>
+                <type name="VkSwapchainCreateInfoKHR"/>
+                <type name="VkSwapchainKHR"/>
+                <type name="VkPresentInfoKHR"/>
+                <command name="vkCreateSwapchainKHR"/>
+                <command name="vkDestroySwapchainKHR"/>
+                <command name="vkGetSwapchainImagesKHR"/>
+                <command name="vkAcquireNextImageKHR"/>
+                <command name="vkQueuePresentKHR"/>
+            </require>
+            <require depends="VK_VERSION_1_1">
+                <comment>This duplicates definitions in VK_KHR_device_group below</comment>
+                <enum extends="VkStructureType" extnumber="61"  offset="7"      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="8"      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="9"      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="10"     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="11"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="12"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+                <type name="VkImageSwapchainCreateInfoKHR"/>
+                <type name="VkBindImageMemorySwapchainInfoKHR"/>
+                <type name="VkAcquireNextImageInfoKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
+                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
+                <type name="VkDeviceGroupPresentInfoKHR"/>
+                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
+                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
+                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
+                <command name="vkAcquireNextImage2KHR"/>
+                <enum bitpos="1" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"     comment="Swapchain is protected"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_display" number="3" type="instance" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Norbert Nopper @FslNopper" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="23"                                                name="VK_KHR_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_display&quot;"                        name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_KHR"/>
+                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"/>
+                <type name="VkDisplayKHR"/>
+                <type name="VkDisplayModeCreateFlagsKHR"/>
+                <type name="VkDisplayModeCreateInfoKHR"/>
+                <type name="VkDisplayModeKHR"/>
+                <type name="VkDisplayModeParametersKHR"/>
+                <type name="VkDisplayModePropertiesKHR"/>
+                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
+                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
+                <type name="VkDisplayPlaneCapabilitiesKHR"/>
+                <type name="VkDisplayPlanePropertiesKHR"/>
+                <type name="VkDisplayPropertiesKHR"/>
+                <type name="VkDisplaySurfaceCreateFlagsKHR"/>
+                <type name="VkDisplaySurfaceCreateInfoKHR"/>
+                <type name="VkSurfaceTransformFlagsKHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
+                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
+                <command name="vkGetDisplayModePropertiesKHR"/>
+                <command name="vkCreateDisplayModeKHR"/>
+                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
+                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_display_swapchain" number="4" type="device" depends="VK_KHR_swapchain+VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="10"                                                name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_display_swapchain&quot;"              name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
+                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
+                <type name="VkDisplayPresentInfoKHR"/>
+                <command name="vkCreateSharedSwapchainsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_xlib_surface" number="5" type="instance" depends="VK_KHR_surface" platform="xlib" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_xlib_surface&quot;"                   name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkXlibSurfaceCreateFlagsKHR"/>
+                <type name="VkXlibSurfaceCreateInfoKHR"/>
+                <command name="vkCreateXlibSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_xcb_surface" number="6" type="instance" depends="VK_KHR_surface" platform="xcb" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_xcb_surface&quot;"                    name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkXcbSurfaceCreateFlagsKHR"/>
+                <type name="VkXcbSurfaceCreateInfoKHR"/>
+                <command name="vkCreateXcbSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_wayland_surface" number="7" type="instance" depends="VK_KHR_surface" platform="wayland" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_wayland_surface&quot;"                name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
+                <type name="VkWaylandSurfaceCreateInfoKHR"/>
+                <command name="vkCreateWaylandSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_mir_surface" number="8" type="instance" depends="VK_KHR_surface" author="KHR" supported="disabled" comment="Extension permanently disabled. Extension number should not be reused" ratified="vulkan">
+            <require>
+                <enum value="4"                                                 name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_mir_surface&quot;"                    name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_android_surface" number="9" type="instance" depends="VK_KHR_surface" platform="android" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_android_surface&quot;"                name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
+                <type name="ANativeWindow"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
+                <type name="VkAndroidSurfaceCreateInfoKHR"/>
+                <command name="vkCreateAndroidSurfaceKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_win32_surface" number="10" type="instance" depends="VK_KHR_surface" platform="win32" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_win32_surface&quot;"                  name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkWin32SurfaceCreateFlagsKHR"/>
+                <type name="VkWin32SurfaceCreateInfoKHR"/>
+                <command name="vkCreateWin32SurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_ANDROID_native_buffer" number="11" type="device" author="ANDROID" platform="android" contact="Jesse Hall @critsec" supported="disabled">
+            <require>
+                <comment>VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It is not exposed to applications and uses types that are not part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.</comment>
+                <enum value="8"                                                 name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
+                <enum value="11"                                                name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
+                <enum value="&quot;VK_ANDROID_native_buffer&quot;"              name="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
+                <enum                                                           name="VK_ANDROID_NATIVE_BUFFER_NAME" alias="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"/>
+                <type name="VkNativeBufferANDROID"/>
+                <type name="VkSwapchainImageCreateInfoANDROID"/>
+                <type name="VkPhysicalDevicePresentationPropertiesANDROID"/>
+                <type name="VkNativeBufferUsage2ANDROID"/>
+                <type name="VkSwapchainImageUsageFlagBitsANDROID"/>
+                <type name="VkSwapchainImageUsageFlagsANDROID"/>
+                <command name="vkGetSwapchainGrallocUsageANDROID"/>
+                <command name="vkAcquireImageANDROID"/>
+                <command name="vkQueueSignalReleaseImageANDROID"/>
+                <command name="vkGetSwapchainGrallocUsage2ANDROID"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_report" number="12" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_debug_utils">
+            <require>
+                <enum value="10"                                                name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_report&quot;"                   name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
+                <enum alias="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT" deprecated="aliased"/>
+                <enum api="vulkan" offset="1" extends="VkResult" dir="-"        name="VK_ERROR_VALIDATION_FAILED_EXT"/>
+                <enum api="vulkansc" extends="VkResult"                         name="VK_ERROR_VALIDATION_FAILED_EXT" alias="VK_ERROR_VALIDATION_FAILED"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"/>
+                <type name="VkDebugReportCallbackEXT"/>
+                <type name="PFN_vkDebugReportCallbackEXT"/>
+                <type name="VkDebugReportFlagBitsEXT"/>
+                <type name="VkDebugReportFlagsEXT"/>
+                <type name="VkDebugReportObjectTypeEXT"/>
+                <type name="VkDebugReportCallbackCreateInfoEXT"/>
+                <command name="vkCreateDebugReportCallbackEXT"/>
+                <command name="vkDestroyDebugReportCallbackEXT"/>
+                <command name="vkDebugReportMessageEXT"/>
+            </require>
+            <require depends="VK_VERSION_1_1">
+                <comment>This duplicates definitions in other extensions, below</comment>
+                <enum extends="VkDebugReportObjectTypeEXT" extnumber="157" offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+                <enum extends="VkDebugReportObjectTypeEXT" extnumber="86"  offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_glsl_shader" number="13" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" deprecatedby="">
+            <require>
+                <enum value="1"                                                 name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_glsl_shader&quot;"                     name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_INVALID_SHADER_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_range_unrestricted" type="device" number="14" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_range_unrestricted&quot;"       name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" type="device" number="15" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="3"                                                 name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"   name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
+                <enum value="4" extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated"/>
+                <enum           extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR" alias="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"  deprecated="aliased" comment="Introduced for consistency with extension suffixing rules"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_filter_cubic" number="16" type="device" author="IMG" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_filter_cubic&quot;"                   name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
+                <enum extends="VkFilter"                                        name="VK_FILTER_CUBIC_IMG" alias="VK_FILTER_CUBIC_EXT"/>
+                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_17" number="17" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_17_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_17&quot;"                   name="VK_AMD_EXTENSION_17_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_18" number="18" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_18_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_18&quot;"                   name="VK_AMD_EXTENSION_18_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_rasterization_order" number="19" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_rasterization_order&quot;"            name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
+                <type name="VkRasterizationOrderAMD"/>
+                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_20" number="20" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_20_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_20&quot;"                   name="VK_AMD_EXTENSION_20_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_trinary_minmax" number="21" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_trinary_minmax&quot;"          name="VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_explicit_vertex_parameter" number="22" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_explicit_vertex_parameter&quot;" name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_marker" number="23" type="device" depends="VK_EXT_debug_report" author="Baldur Karlsson" contact="Baldur Karlsson @baldurk" specialuse="debugging" supported="vulkan" promotedto="VK_EXT_debug_utils">
+            <require>
+                <enum value="4"                                                 name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_marker&quot;"                   name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
+                <type name="VkDebugReportObjectTypeEXT"/>
+                <type name="VkDebugMarkerObjectNameInfoEXT"/>
+                <type name="VkDebugMarkerObjectTagInfoEXT"/>
+                <type name="VkDebugMarkerMarkerInfoEXT"/>
+                <command name="vkDebugMarkerSetObjectTagEXT"/>
+                <command name="vkDebugMarkerSetObjectNameEXT"/>
+                <command name="vkCmdDebugMarkerBeginEXT"/>
+                <command name="vkCmdDebugMarkerEndEXT"/>
+                <command name="vkCmdDebugMarkerInsertEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_queue" number="24" type="device" depends="VK_VERSION_1_1+VK_KHR_synchronization2" author="KHR" contact="Tony Zlatinski @tzlatinski" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="8"                                         name="VK_KHR_VIDEO_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_queue&quot;"            name="VK_KHR_VIDEO_QUEUE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"/>
+                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"/>
+                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"/>
+                <enum offset="10" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"/>
+                <enum offset="11" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"/>
+                <enum offset="12" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"/>
+                <enum offset="13" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"/>
+                <enum offset="14" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"/>
+                <enum offset="15" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"/>
+                <enum offset="16" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"/>
+
+                <enum offset="0"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_KHR"             comment="VkVideoSessionKHR"/>
+                <enum offset="1"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"  comment="VkVideoSessionParametersKHR"/>
+
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR"/>
+                <enum bitpos="4" extends="VkQueryResultFlagBits"        name="VK_QUERY_RESULT_WITH_STATUS_BIT_KHR"/>
+
+                <enum offset="0" extends="VkResult" dir="-"             name="VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR"/>
+                <enum offset="1" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR"/>
+                <enum offset="2" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR"/>
+                <enum offset="3" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR"/>
+                <enum offset="4" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR"/>
+                <enum offset="5" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR"/>
+
+                <type name="VkVideoSessionKHR"/>
+                <type name="VkVideoSessionParametersKHR"/>
+
+                <type name="VkVideoCodecOperationFlagBitsKHR"/>
+                <type name="VkVideoCodecOperationFlagsKHR"/>
+                <type name="VkVideoChromaSubsamplingFlagBitsKHR"/>
+                <type name="VkVideoChromaSubsamplingFlagsKHR"/>
+                <type name="VkVideoComponentBitDepthFlagBitsKHR"/>
+                <type name="VkVideoComponentBitDepthFlagsKHR"/>
+                <type name="VkVideoCapabilityFlagBitsKHR"/>
+                <type name="VkVideoCapabilityFlagsKHR"/>
+                <type name="VkVideoSessionCreateFlagBitsKHR"/>
+                <type name="VkVideoSessionCreateFlagsKHR"/>
+                <type name="VkVideoSessionParametersCreateFlagsKHR"/>
+                <type name="VkVideoBeginCodingFlagsKHR"/>
+                <type name="VkVideoEndCodingFlagsKHR"/>
+                <type name="VkVideoCodingControlFlagBitsKHR"/>
+                <type name="VkVideoCodingControlFlagsKHR"/>
+
+                <type name="VkQueueFamilyQueryResultStatusPropertiesKHR"/>
+                <type name="VkQueryResultStatusKHR"/>
+
+                <type name="VkQueueFamilyVideoPropertiesKHR"/>
+                <type name="VkVideoProfileInfoKHR"/>
+                <type name="VkVideoProfileListInfoKHR"/>
+                <type name="VkVideoCapabilitiesKHR"/>
+                <type name="VkPhysicalDeviceVideoFormatInfoKHR"/>
+                <type name="VkVideoFormatPropertiesKHR"/>
+                <type name="VkVideoPictureResourceInfoKHR"/>
+                <type name="VkVideoReferenceSlotInfoKHR"/>
+                <type name="VkVideoSessionMemoryRequirementsKHR"/>
+                <type name="VkBindVideoSessionMemoryInfoKHR"/>
+                <type name="VkVideoSessionCreateInfoKHR"/>
+                <type name="VkVideoSessionParametersCreateInfoKHR"/>
+                <type name="VkVideoSessionParametersUpdateInfoKHR"/>
+                <type name="VkVideoBeginCodingInfoKHR"/>
+                <type name="VkVideoEndCodingInfoKHR"/>
+                <type name="VkVideoCodingControlInfoKHR"/>
+
+                <command name="vkGetPhysicalDeviceVideoCapabilitiesKHR"/>
+                <command name="vkGetPhysicalDeviceVideoFormatPropertiesKHR"/>
+
+                <command name="vkCreateVideoSessionKHR"/>
+                <command name="vkDestroyVideoSessionKHR"/>
+                <command name="vkGetVideoSessionMemoryRequirementsKHR"/>
+                <command name="vkBindVideoSessionMemoryKHR"/>
+                <command name="vkCreateVideoSessionParametersKHR"/>
+                <command name="vkUpdateVideoSessionParametersKHR"/>
+                <command name="vkDestroyVideoSessionParametersKHR"/>
+                <command name="vkCmdBeginVideoCodingKHR"/>
+                <command name="vkCmdEndVideoCodingKHR"/>
+                <command name="vkCmdControlVideoCodingKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_decode_queue" number="25" type="device" depends="VK_KHR_video_queue+VK_KHR_synchronization2" author="KHR" contact="jake.beju@amd.com" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="7"                                         name="VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_decode_queue&quot;"     name="VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"/>
+                <enum bitpos="5" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_DECODE_BIT_KHR"/>
+                <!-- VkPipelineStageFlagBits bitpos="26" is reserved by this extension, but not used -->
+                <enum bitpos="26" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
+                <enum bitpos="35" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR"/>
+                <enum bitpos="36" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR"/>
+                <enum bitpos="13" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR"/>
+                <enum bitpos="14" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR"/>
+                <enum bitpos="10" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"/>
+                <enum bitpos="11" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR"/>
+                <enum bitpos="12" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"/>
+                <enum bitpos="25" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR"/>
+                <enum bitpos="26" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR"/>
+                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR"/>
+                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR"/>
+                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR"/>
+
+                <type name="VkVideoDecodeCapabilityFlagBitsKHR"/>
+                <type name="VkVideoDecodeCapabilityFlagsKHR"/>
+                <type name="VkVideoDecodeCapabilitiesKHR"/>
+
+                <type name="VkVideoDecodeUsageFlagBitsKHR"/>
+                <type name="VkVideoDecodeUsageFlagsKHR"/>
+                <type name="VkVideoDecodeUsageInfoKHR"/>
+
+                <type name="VkVideoDecodeFlagsKHR"/>
+
+                <type name="VkVideoDecodeInfoKHR"/>
+                <command name="vkCmdDecodeVideoKHR"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="25" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR"/>
+                <enum bitpos="26" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gcn_shader" number="26" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_GCN_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gcn_shader&quot;"                     name="VK_AMD_GCN_SHADER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_dedicated_allocation" number="27" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" deprecatedby="VK_KHR_dedicated_allocation">
+            <require>
+                <enum value="1"                                                 name="VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_dedicated_allocation&quot;"            name="VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"/>
+                <type name="VkDedicatedAllocationImageCreateInfoNV"/>
+                <type name="VkDedicatedAllocationBufferCreateInfoNV"/>
+                <type name="VkDedicatedAllocationMemoryAllocateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_28" number="28" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_EXT_EXTENSION_28_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_28&quot;"                   name="VK_EXT_EXTENSION_28_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_transform_feedback" number="29" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" specialuse="glemulation,d3demulation,devtools" supported="vulkan" depends="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_transform_feedback&quot;"             name="VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME"/>
+                <command name="vkCmdBindTransformFeedbackBuffersEXT"/>
+                <command name="vkCmdBeginTransformFeedbackEXT"/>
+                <command name="vkCmdEndTransformFeedbackEXT"/>
+                <command name="vkCmdBeginQueryIndexedEXT"/>
+                <command name="vkCmdEndQueryIndexedEXT"/>
+                <command name="vkCmdDrawIndirectByteCountEXT"/>
+
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"/>
+
+                <enum offset="4" extends="VkQueryType"                          name="VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"/>
+
+                <enum bitpos="11" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
+                <enum bitpos="12" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>
+
+                <enum bitpos="25" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
+                <enum bitpos="26" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
+                <enum bitpos="27" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
+
+                <enum bitpos="24" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"/>
+
+                <type name="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
+                <type name="VkPhysicalDeviceTransformFeedbackPropertiesEXT"/>
+                <type name="VkPipelineRasterizationStateStreamCreateInfoEXT"/>
+
+                <type name="VkPipelineRasterizationStateStreamCreateFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_binary_import" number="30" type="device" author="NVX" contact="Eric Werness @ewerness-nv,Liam Middlebrook @liam-middlebrook" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NVX_BINARY_IMPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_binary_import&quot;"                  name="VK_NVX_BINARY_IMPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_MODULE_NVX"/>
+                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_FUNCTION_NVX"/>
+                <type name="VkCuModuleNVX"/>
+                <type name="VkCuFunctionNVX"/>
+                <type name="VkCuModuleCreateInfoNVX"/>
+                <type name="VkCuFunctionCreateInfoNVX"/>
+                <type name="VkCuLaunchInfoNVX"/>
+                <command name="vkCreateCuModuleNVX"/>
+                <command name="vkCreateCuFunctionNVX"/>
+                <command name="vkDestroyCuModuleNVX"/>
+                <command name="vkDestroyCuFunctionNVX"/>
+                <command name="vkCmdCuLaunchKernelNVX"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT"/>
+                <enum offset="1" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_image_view_handle" number="31" type="device" author="NVX" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_image_view_handle&quot;"              name="VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"/>
+                <type name="VkImageViewHandleInfoNVX"/>
+                <type name="VkImageViewAddressPropertiesNVX"/>
+                <command name="vkGetImageViewHandleNVX"/>
+                <command name="vkGetImageViewAddressNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_32" number="32" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_32_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_32&quot;"                   name="VK_AMD_EXTENSION_32_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_33" number="33" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_33_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_33&quot;"                   name="VK_AMD_EXTENSION_33_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_draw_indirect_count" number="34" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_KHR_draw_indirect_count">
+            <require>
+                <enum value="2"                                                 name="VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_draw_indirect_count&quot;"            name="VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
+                <command name="vkCmdDrawIndirectCountAMD"/>
+                <command name="vkCmdDrawIndexedIndirectCountAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_35" number="35" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_35_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_35&quot;"                   name="VK_AMD_EXTENSION_35_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_negative_viewport_height" number="36" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" obsoletedby="VK_KHR_maintenance1">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_negative_viewport_height&quot;"       name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gpu_shader_half_float" number="37" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
+            <require>
+                <enum value="2"                                                 name="VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gpu_shader_half_float&quot;"          name="VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_ballot" number="38" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_BALLOT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_ballot&quot;"                  name="VK_AMD_SHADER_BALLOT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_encode_h264" number="39" type="device" depends="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="12"                                                name="VK_EXT_VIDEO_ENCODE_H264_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_encode_h264&quot;"              name="VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="13" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="16" extends="VkVideoCodecOperationFlagBitsKHR"    name="VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeH264CapabilityFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264CapabilityFlagsEXT"/>
+                <type name="VkVideoEncodeH264StdFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264StdFlagsEXT"/>
+                <type name="VkVideoEncodeH264CapabilitiesEXT"/>
+                <type name="VkVideoEncodeH264QualityLevelPropertiesEXT"/>
+                <type name="VkVideoEncodeH264SessionCreateInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersAddInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersGetInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersFeedbackInfoEXT"/>
+                <type name="VkVideoEncodeH264PictureInfoEXT"/>
+                <type name="VkVideoEncodeH264DpbSlotInfoEXT"/>
+                <type name="VkVideoEncodeH264NaluSliceInfoEXT"/>
+                <type name="VkVideoEncodeH264ProfileInfoEXT"/>
+                <type name="VkVideoEncodeH264RateControlInfoEXT"/>
+                <type name="VkVideoEncodeH264RateControlFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264RateControlFlagsEXT"/>
+                <type name="VkVideoEncodeH264RateControlLayerInfoEXT"/>
+                <type name="VkVideoEncodeH264QpEXT"/>
+                <type name="VkVideoEncodeH264FrameSizeEXT"/>
+                <type name="VkVideoEncodeH264GopRemainingFrameInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_encode_h265" number="40" type="device" depends="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="12"                                             name="VK_EXT_VIDEO_ENCODE_H265_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_encode_h265&quot;"           name="VK_EXT_VIDEO_ENCODE_H265_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="9" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="10" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="11" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="12" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="13" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="14" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="17" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeH265CapabilityFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265CapabilityFlagsEXT"/>
+                <type name="VkVideoEncodeH265StdFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265StdFlagsEXT"/>
+                <type name="VkVideoEncodeH265CtbSizeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265CtbSizeFlagsEXT"/>
+                <type name="VkVideoEncodeH265TransformBlockSizeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265TransformBlockSizeFlagsEXT"/>
+                <type name="VkVideoEncodeH265CapabilitiesEXT"/>
+                <type name="VkVideoEncodeH265SessionCreateInfoEXT"/>
+                <type name="VkVideoEncodeH265QualityLevelPropertiesEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersAddInfoEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersGetInfoEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersFeedbackInfoEXT"/>
+                <type name="VkVideoEncodeH265PictureInfoEXT"/>
+                <type name="VkVideoEncodeH265DpbSlotInfoEXT"/>
+                <type name="VkVideoEncodeH265NaluSliceSegmentInfoEXT"/>
+                <type name="VkVideoEncodeH265ProfileInfoEXT"/>
+                <type name="VkVideoEncodeH265RateControlInfoEXT"/>
+                <type name="VkVideoEncodeH265RateControlFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265RateControlFlagsEXT"/>
+                <type name="VkVideoEncodeH265RateControlLayerInfoEXT"/>
+                <type name="VkVideoEncodeH265QpEXT"/>
+                <type name="VkVideoEncodeH265FrameSizeEXT"/>
+                <type name="VkVideoEncodeH265GopRemainingFrameInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_decode_h264" number="41" type="device" depends="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="8"                                              name="VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_decode_h264&quot;"           name="VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
+                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"/>
+                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"/>
+                <enum bitpos="0" extends="VkVideoCodecOperationFlagBitsKHR"  name="VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR"/>
+                <type name="VkVideoDecodeH264PictureLayoutFlagBitsKHR"/>
+                <type name="VkVideoDecodeH264PictureLayoutFlagsKHR"/>
+                <type name="VkVideoDecodeH264ProfileInfoKHR"/>
+                <type name="VkVideoDecodeH264CapabilitiesKHR"/>
+                <type name="VkVideoDecodeH264SessionParametersCreateInfoKHR"/>
+                <type name="VkVideoDecodeH264SessionParametersAddInfoKHR"/>
+                <type name="VkVideoDecodeH264PictureInfoKHR"/>
+                <type name="VkVideoDecodeH264DpbSlotInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_texture_gather_bias_lod" number="42" author="AMD" contact="Rex Xu @amdrexu" supported="vulkan" type="device" depends="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_texture_gather_bias_lod&quot;"        name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"/>
+                <type name="VkTextureLODGatherFormatPropertiesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_info" number="43" author="AMD" contact="Jaakko Konttinen @jaakkoamd" supported="vulkan" specialuse="devtools" type="device">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_info&quot;"                    name="VK_AMD_SHADER_INFO_EXTENSION_NAME"/>
+                <type name="VkShaderInfoTypeAMD"/>
+                <type name="VkShaderResourceUsageAMD"/>
+                <type name="VkShaderStatisticsInfoAMD"/>
+                <command name="vkGetShaderInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_44" number="44" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_44_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_44&quot;"                   name="VK_AMD_EXTENSION_44_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_dynamic_rendering" number="45" author="KHR" type="device" depends="VK_KHR_depth_stencil_resolve+VK_KHR_get_physical_device_properties2" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_dynamic_rendering&quot;"              name="VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME"/>
+                <command name="vkCmdBeginRenderingKHR"/>
+                <command name="vkCmdEndRenderingKHR"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDERING_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR" alias="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"/>
+                <enum extends="VkAttachmentStoreOp"                             name="VK_ATTACHMENT_STORE_OP_NONE_KHR" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
+                <type name="VkRenderingInfoKHR"/>
+                <type name="VkRenderingAttachmentInfoKHR"/>
+                <type name="VkPipelineRenderingCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceDynamicRenderingFeaturesKHR"/>
+                <type name="VkCommandBufferInheritanceRenderingInfoKHR"/>
+                <type name="VkRenderingFlagsKHR"/>
+                <type name="VkRenderingFlagBitsKHR"/>
+            </require>
+            <require depends="VK_KHR_fragment_shading_rate">
+                <enum bitpos="21" extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum alias="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" deprecated="aliased"/>
+                <enum offset="6" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
+                <type name="VkRenderingFragmentShadingRateAttachmentInfoKHR"/>
+            </require>
+            <require depends="VK_EXT_fragment_density_map">
+                <enum bitpos="22" extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
+                <enum alias="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT" deprecated="aliased"/>
+                <enum offset="7" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"/>
+                <type name="VkRenderingFragmentDensityMapAttachmentInfoEXT"/>
+            </require>
+            <require depends="VK_AMD_mixed_attachment_samples">
+                <enum offset="8" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
+                <type name="VkAttachmentSampleCountInfoAMD"/>
+            </require>
+            <require depends="VK_NV_framebuffer_mixed_samples">
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV" alias="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
+                <type name="VkAttachmentSampleCountInfoNV"/>
+            </require>
+            <require depends="VK_NVX_multiview_per_view_attributes">
+                <enum offset="9" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"/>
+                <type name="VkMultiviewPerViewAttributesInfoNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_46" number="46" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_46_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_46&quot;"                   name="VK_AMD_EXTENSION_46_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_image_load_store_lod" number="47" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" type="device">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_image_load_store_lod&quot;"    name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_extension_48" number="48" author="NVX" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_NVX_EXTENSION_48_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_extension_48&quot;"                   name="VK_NVX_EXTENSION_48_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_49" number="49" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_GOOGLE_EXTENSION_49_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_49&quot;"                name="VK_GOOGLE_EXTENSION_49_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_stream_descriptor_surface" number="50" type="instance" depends="VK_KHR_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_stream_descriptor_surface&quot;"      name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"/>
+                <type name="VkStreamDescriptorSurfaceCreateFlagsGGP"/>
+                <type name="VkStreamDescriptorSurfaceCreateInfoGGP"/>
+                <command name="vkCreateStreamDescriptorSurfaceGGP"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_corner_sampled_image" number="51" author="NV" type="device" depends="VK_KHR_get_physical_device_properties2" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_corner_sampled_image&quot;"            name="VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME"/>
+                <enum bitpos="13" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceCornerSampledImageFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_private_vendor_info" number="52" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkansc">
+            <require>
+                <enum value="2"                                                 name="VK_NV_PRIVATE_VENDOR_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_private_vendor_info&quot;"             name="VK_NV_PRIVATE_VENDOR_INFO_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_53" number="53" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_NV_EXTENSION_53_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_53&quot;"                    name="VK_NV_EXTENSION_53_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_multiview" number="54" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_MULTIVIEW_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_multiview&quot;"                      name="VK_KHR_MULTIVIEW_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
+                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR" alias="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
+                <type name="VkRenderPassMultiviewCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceMultiviewFeaturesKHR"/>
+                <type name="VkPhysicalDeviceMultiviewPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_format_pvrtc" number="55" type="device" author="IMG" contact="Stuart Smith" supported="vulkan" deprecatedby="">
+            <require>
+                <enum value="1"                                                 name="VK_IMG_FORMAT_PVRTC_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_format_pvrtc&quot;"                   name="VK_IMG_FORMAT_PVRTC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="1" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="2" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="3" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="4" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="5" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="6" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="7" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_capabilities" number="56" type="instance" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory_capabilities">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_capabilities&quot;"    name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
+                <type name="VkExternalMemoryHandleTypeFlagsNV"/>
+                <type name="VkExternalMemoryHandleTypeFlagBitsNV"/>
+                <type name="VkExternalMemoryFeatureFlagsNV"/>
+                <type name="VkExternalMemoryFeatureFlagBitsNV"/>
+                <type name="VkExternalImageFormatPropertiesNV"/>
+                <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory" number="57" type="device" depends="VK_NV_external_memory_capabilities" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory&quot;"                 name="VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"/>
+                <type name="VkExternalMemoryImageCreateInfoNV"/>
+                <type name="VkExportMemoryAllocateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_win32" number="58" type="device" depends="VK_NV_external_memory" author="NV" contact="James Jones @cubanismo" platform="win32" supported="vulkan" deprecatedby="VK_KHR_external_memory_win32">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_win32&quot;"           name="VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
+                <type name="VkImportMemoryWin32HandleInfoNV"/>
+                <type name="VkExportMemoryWin32HandleInfoNV"/>
+                <command name="vkGetMemoryWin32HandleNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_win32_keyed_mutex" number="59" type="device" depends="VK_NV_external_memory_win32" author="NV" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" promotedto="VK_KHR_win32_keyed_mutex">
+            <require>
+                <enum value="2"                                                 name="VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_win32_keyed_mutex&quot;"               name="VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"/>
+                <type name="VkWin32KeyedMutexAcquireReleaseInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_physical_device_properties2" number="60" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_physical_device_properties2&quot;" name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
+                <type name="VkPhysicalDeviceFeatures2KHR"/>
+                <type name="VkPhysicalDeviceProperties2KHR"/>
+                <type name="VkFormatProperties2KHR"/>
+                <type name="VkImageFormatProperties2KHR"/>
+                <type name="VkPhysicalDeviceImageFormatInfo2KHR"/>
+                <type name="VkQueueFamilyProperties2KHR"/>
+                <type name="VkPhysicalDeviceMemoryProperties2KHR"/>
+                <type name="VkSparseImageFormatProperties2KHR"/>
+                <type name="VkPhysicalDeviceSparseImageFormatInfo2KHR"/>
+                <command name="vkGetPhysicalDeviceFeatures2KHR"/>
+                <command name="vkGetPhysicalDeviceProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceFormatProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceMemoryProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_device_group" number="61" type="device" author="KHR" depends="VK_KHR_device_group_creation" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="4"                                                 name="VK_KHR_DEVICE_GROUP_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_device_group&quot;"                   name="VK_KHR_DEVICE_GROUP_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
+                <type name="VkPeerMemoryFeatureFlagsKHR"/>
+                <type name="VkPeerMemoryFeatureFlagBitsKHR"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"/>
+                <type name="VkMemoryAllocateFlagsKHR"/>
+                <type name="VkMemoryAllocateFlagBitsKHR"/>
+                <enum extends="VkMemoryAllocateFlagBits"                        name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"/>
+                <type name="VkMemoryAllocateFlagsInfoKHR"/>
+                <type name="VkDeviceGroupRenderPassBeginInfoKHR"/>
+                <type name="VkDeviceGroupCommandBufferBeginInfoKHR"/>
+                <type name="VkDeviceGroupSubmitInfoKHR"/>
+                <type name="VkDeviceGroupBindSparseInfoKHR"/>
+                <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"/>
+                <command name="vkCmdSetDeviceMaskKHR"/>
+                <command name="vkCmdDispatchBaseKHR"/>
+                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR" alias="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
+                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" alias="VK_PIPELINE_CREATE_DISPATCH_BASE"/>
+                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" alias="VK_DEPENDENCY_DEVICE_GROUP_BIT"/>
+            </require>
+            <require depends="VK_KHR_bind_memory2">
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
+                <type name="VkBindBufferMemoryDeviceGroupInfoKHR"/>
+                <type name="VkBindImageMemoryDeviceGroupInfoKHR"/>
+                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" alias="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+            </require>
+            <require depends="VK_KHR_surface">
+                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
+                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
+                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
+                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
+            </require>
+            <require depends="VK_KHR_swapchain">
+                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
+                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
+                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
+                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+                <type name="VkImageSwapchainCreateInfoKHR"/>
+                <type name="VkBindImageMemorySwapchainInfoKHR"/>
+                <type name="VkAcquireNextImageInfoKHR"/>
+                <type name="VkDeviceGroupPresentInfoKHR"/>
+                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
+                <command name="vkAcquireNextImage2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_flags" number="62" type="instance" author="GOOGLE" contact="Tobin Ehlis @tobine" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_validation_features">
+            <require>
+                <enum value="2"                                                 name="VK_EXT_VALIDATION_FLAGS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_flags&quot;"               name="VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"/>
+                <type name="VkValidationFlagsEXT"/>
+                <type name="VkValidationCheckEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NN_vi_surface" number="63" type="instance" author="NN" contact="Mathias Heyer gitlab:@mheyer" depends="VK_KHR_surface" platform="vi" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NN_VI_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NN_vi_surface&quot;"                      name="VK_NN_VI_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"/>
+                <type name="VkViSurfaceCreateFlagsNN"/>
+                <type name="VkViSurfaceCreateInfoNN"/>
+                <command name="vkCreateViSurfaceNN"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_draw_parameters" number="64" type="device" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_draw_parameters&quot;"         name="VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_subgroup_ballot" number="65" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_subgroup_ballot&quot;"         name="VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_subgroup_vote" number="66" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_subgroup_vote&quot;"           name="VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_texture_compression_astc_hdr" number="67" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_texture_compression_astc_hdr&quot;"   name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"/>
+                <type name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"/>
+                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_astc_decode_mode" number="68" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_astc_decode_mode&quot;"               name="VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"/>
+                <type name="VkImageViewASTCDecodeModeEXT"/>
+                <type name="VkPhysicalDeviceASTCDecodeFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_robustness" depends="VK_KHR_get_physical_device_properties2" number="69" type="device" author="IMG" contact="Jarred Davies" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_robustness&quot;"            name="VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDevicePipelineRobustnessFeaturesEXT"/>
+                <type name="VkPhysicalDevicePipelineRobustnessPropertiesEXT"/>
+                <type name="VkPipelineRobustnessCreateInfoEXT"/>
+                <type name="VkPipelineRobustnessBufferBehaviorEXT"/>
+                <type name="VkPipelineRobustnessImageBehaviorEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance1" number="70" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_MAINTENANCE_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance1&quot;"                   name="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_1_SPEC_VERSION"                 name="VK_KHR_MAINTENANCE1_SPEC_VERSION" deprecated="aliased"/>
+                <enum alias="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"               name="VK_KHR_MAINTENANCE1_EXTENSION_NAME" deprecated="aliased"/>
+                <enum extends="VkResult"                                        name="VK_ERROR_OUT_OF_POOL_MEMORY_KHR" alias="VK_ERROR_OUT_OF_POOL_MEMORY"/>
+                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_DST_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/>
+                <type name="VkCommandPoolTrimFlagsKHR"/>
+                <command name="vkTrimCommandPoolKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_device_group_creation" number="71" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_device_group_creation&quot;"          name="VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
+                <enum name="VK_MAX_DEVICE_GROUP_SIZE_KHR"/>
+                <type name="VkPhysicalDeviceGroupPropertiesKHR"/>
+                <type name="VkDeviceGroupDeviceCreateInfoKHR"/>
+                <command name="vkEnumeratePhysicalDeviceGroupsKHR"/>
+                <enum extends="VkMemoryHeapFlagBits"                            name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR" alias="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_capabilities" number="72" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_capabilities&quot;"   name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalMemoryHandleTypeFlagsKHR"/>
+                <type name="VkExternalMemoryHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
+                <type name="VkExternalMemoryFeatureFlagsKHR"/>
+                <type name="VkExternalMemoryFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkExternalMemoryPropertiesKHR"/>
+                <type name="VkPhysicalDeviceExternalImageFormatInfoKHR"/>
+                <type name="VkExternalImageFormatPropertiesKHR"/>
+                <type name="VkPhysicalDeviceExternalBufferInfoKHR"/>
+                <type name="VkExternalBufferPropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory" number="73" type="device" depends="VK_KHR_external_memory_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory&quot;"                name="VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
+                <enum extends="VkResult"                                        name="VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR" alias="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
+                <enum name="VK_QUEUE_FAMILY_EXTERNAL_KHR"/>
+                <type name="VkExternalMemoryImageCreateInfoKHR"/>
+                <type name="VkExternalMemoryBufferCreateInfoKHR"/>
+                <type name="VkExportMemoryAllocateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_win32" number="74" type="device" depends="VK_KHR_external_memory" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_win32&quot;"          name="VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportMemoryWin32HandleInfoKHR"/>
+                <type name="VkExportMemoryWin32HandleInfoKHR"/>
+                <type name="VkMemoryWin32HandlePropertiesKHR"/>
+                <type name="VkMemoryGetWin32HandleInfoKHR"/>
+                <command name="vkGetMemoryWin32HandleKHR"/>
+                <command name="vkGetMemoryWin32HandlePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_fd" number="75" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_fd&quot;"             name="VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"/>
+                <type name="VkImportMemoryFdInfoKHR"/>
+                <type name="VkMemoryFdPropertiesKHR"/>
+                <type name="VkMemoryGetFdInfoKHR"/>
+                <command name="vkGetMemoryFdKHR"/>
+                <command name="vkGetMemoryFdPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_win32_keyed_mutex" number="76" type="device" depends="VK_KHR_external_memory_win32" author="KHR" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_win32_keyed_mutex&quot;"              name="VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"/>
+                <type name="VkWin32KeyedMutexAcquireReleaseInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_capabilities" number="77" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_capabilities&quot;" name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalSemaphoreHandleTypeFlagsKHR"/>
+                <type name="VkExternalSemaphoreHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
+                <type name="VkExternalSemaphoreFeatureFlagsKHR"/>
+                <type name="VkExternalSemaphoreFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkPhysicalDeviceExternalSemaphoreInfoKHR"/>
+                <type name="VkExternalSemaphorePropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore" number="78" type="device" depends="VK_KHR_external_semaphore_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore&quot;"         name="VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
+                <type name="VkSemaphoreImportFlagsKHR"/>
+                <type name="VkSemaphoreImportFlagBitsKHR"/>
+                <enum extends="VkSemaphoreImportFlagBits"                   name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
+                <type name="VkExportSemaphoreCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_win32" number="79" type="device" depends="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_win32&quot;"   name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportSemaphoreWin32HandleInfoKHR"/>
+                <type name="VkExportSemaphoreWin32HandleInfoKHR"/>
+                <type name="VkD3D12FenceSubmitInfoKHR"/>
+                <type name="VkSemaphoreGetWin32HandleInfoKHR"/>
+                <command name="vkImportSemaphoreWin32HandleKHR"/>
+                <command name="vkGetSemaphoreWin32HandleKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_fd" number="80" type="device" depends="VK_KHR_external_semaphore,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_fd&quot;"      name="VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"/>
+                <type name="VkImportSemaphoreFdInfoKHR"/>
+                <type name="VkSemaphoreGetFdInfoKHR"/>
+                <command name="vkImportSemaphoreFdKHR"/>
+                <command name="vkGetSemaphoreFdKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_push_descriptor" number="81" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_push_descriptor&quot;"            name="VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"/>
+                <enum bitpos="0" extends="VkDescriptorSetLayoutCreateFlagBits"   name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"  comment="Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR"/>
+                <command name="vkCmdPushDescriptorSetKHR"/>
+                <type name="VkPhysicalDevicePushDescriptorPropertiesKHR"/>
+            </require>
+            <require depends="VK_VERSION_1_1">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+            <require depends="VK_KHR_descriptor_update_template">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_conditional_rendering" number="82" type="device" author="NV" contact="Vikram Kushwaha @vkushwaha" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_conditional_rendering&quot;"      name="VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"/>
+                <type name="VkConditionalRenderingFlagsEXT"/>
+                <type name="VkConditionalRenderingFlagBitsEXT"/>
+                <enum bitpos="20" extends="VkAccessFlagBits"                name="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"  comment="read access flag for reading conditional rendering predicate"/>
+                <enum bitpos="9"  extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="Specifies the buffer can be used as predicate in conditional rendering"/>
+                <enum bitpos="18" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
+                <command name="vkCmdBeginConditionalRenderingEXT"/>
+                <command name="vkCmdEndConditionalRenderingEXT"/>
+                <type name="VkConditionalRenderingBeginInfoEXT"/>
+                <type name="VkPhysicalDeviceConditionalRenderingFeaturesEXT"/>
+                <type name="VkCommandBufferInheritanceConditionalRenderingInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_float16_int8" number="83" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_float16_int8&quot;"        name="VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"/>
+                <type name="VkPhysicalDeviceFloat16Int8FeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_16bit_storage" number="84" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class" author="KHR" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_16BIT_STORAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_16bit_storage&quot;"              name="VK_KHR_16BIT_STORAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
+                <type name="VkPhysicalDevice16BitStorageFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_incremental_present" number="85" type="device" author="KHR" depends="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_incremental_present&quot;"        name="VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"/>
+                <type name="VkPresentRegionsKHR"/>
+                <type name="VkPresentRegionKHR"/>
+                <type name="VkRectLayerKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_descriptor_update_template" number="86" type="device" author="KHR" contact="Markus Tavenrath @mtavenrath" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_descriptor_update_template&quot;" name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
+                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR" alias="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
+                <command name="vkCreateDescriptorUpdateTemplateKHR"/>
+                <command name="vkDestroyDescriptorUpdateTemplateKHR"/>
+                <command name="vkUpdateDescriptorSetWithTemplateKHR"/>
+                <type name="VkDescriptorUpdateTemplateKHR"/>
+                <type name="VkDescriptorUpdateTemplateCreateFlagsKHR"/>
+                <type name="VkDescriptorUpdateTemplateTypeKHR"/>
+                <type name="VkDescriptorUpdateTemplateEntryKHR"/>
+                <type name="VkDescriptorUpdateTemplateCreateInfoKHR"/>
+                <enum extends="VkDescriptorUpdateTemplateType"              name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
+            </require>
+            <require depends="VK_KHR_push_descriptor">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_device_generated_commands" number="87" type="device" author="NVX" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
+            <require>
+                <enum value="3"                                             name="VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_device_generated_commands&quot;"  name="VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_clip_space_w_scaling" number="88" type="device" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_clip_space_w_scaling&quot;"        name="VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"/>
+                <type name="VkViewportWScalingNV"/>
+                <type name="VkPipelineViewportWScalingStateCreateInfoNV"/>
+                <command name="vkCmdSetViewportWScalingNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_direct_mode_display" number="89" type="instance" depends="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_direct_mode_display&quot;"        name="VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkReleaseDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_acquire_xlib_display" number="90" type="instance" depends="VK_EXT_direct_mode_display" author="NV" contact="James Jones @cubanismo" platform="xlib_xrandr" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_acquire_xlib_display&quot;"       name="VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireXlibDisplayEXT"/>
+                <command name="vkGetRandROutputDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_display_surface_counter" number="91" type="instance" depends="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_display_surface_counter&quot;"    name="VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME"/>
+                <enum offset="0"                                           extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"/>
+                <enum api="vulkan" extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT" alias="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT" deprecated="aliased"/>
+                <type name="VkSurfaceCounterFlagsEXT"/>
+                <type name="VkSurfaceCounterFlagBitsEXT"/>
+                <type name="VkSurfaceCapabilities2EXT"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilities2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_display_control" number="92" type="device" depends="VK_EXT_display_surface_counter+VK_KHR_swapchain" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DISPLAY_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_display_control&quot;"            name="VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"/>
+                <type name="VkDisplayPowerStateEXT"/>
+                <type name="VkDeviceEventTypeEXT"/>
+                <type name="VkDisplayEventTypeEXT"/>
+                <type name="VkDisplayPowerInfoEXT"/>
+                <type name="VkDeviceEventInfoEXT"/>
+                <type name="VkDisplayEventInfoEXT"/>
+                <type name="VkSwapchainCounterCreateInfoEXT"/>
+                <command name="vkDisplayPowerControlEXT"/>
+                <command name="vkRegisterDeviceEventEXT"/>
+                <command name="vkRegisterDisplayEventEXT"/>
+                <command name="vkGetSwapchainCounterEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_display_timing" number="93" type="device" author="GOOGLE" depends="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_display_timing&quot;"          name="VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"/>
+                <type name="VkRefreshCycleDurationGOOGLE"/>
+                <type name="VkPastPresentationTimingGOOGLE"/>
+                <type name="VkPresentTimesInfoGOOGLE"/>
+                <type name="VkPresentTimeGOOGLE"/>
+                <command name="vkGetRefreshCycleDurationGOOGLE"/>
+                <command name="vkGetPastPresentationTimingGOOGLE"/>
+            </require>
+        </extension>
+        <extension name="VK_RESERVED_do_not_use_94" number="94" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
+            <require>
+                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_94_SPEC_VERSION"/>
+                <enum value="&quot;VK_RESERVED_do_not_use_94&quot;"         name="VK_RESERVED_DO_NOT_USE_94_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_sample_mask_override_coverage" number="95" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_sample_mask_override_coverage&quot;" name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME"/>
+                <comment>
+                    enum offset=0 was mistakenly used for the 1.1 core enum
+                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
+                    (value=1000094000). Fortunately, no conflict resulted.
+                </comment>
+            </require>
+        </extension>
+        <extension name="VK_NV_geometry_shader_passthrough" number="96" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_geometry_shader_passthrough&quot;" name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_viewport_array2" number="97" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_viewport_array2&quot;"             name="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"/>
+                <enum alias="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"           name="VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION" deprecated="aliased"/>
+                <enum alias="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"         name="VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME" deprecated="aliased"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_multiview_per_view_attributes" number="98" type="device" depends="VK_KHR_multiview" author="NVX" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_multiview_per_view_attributes&quot;" name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"/>
+                <enum bitpos="0" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"/>
+                <enum bitpos="1" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"/>
+                <type name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_viewport_swizzle" number="99" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_viewport_swizzle&quot;"            name="VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"/>
+                <type name="VkViewportSwizzleNV"/>
+                <type name="VkViewportCoordinateSwizzleNV"/>
+                <type name="VkPipelineViewportSwizzleStateCreateInfoNV"/>
+                <type name="VkPipelineViewportSwizzleStateCreateFlagsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_discard_rectangles" number="100" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_discard_rectangles&quot;"         name="VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"/>
+                <enum offset="1" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT"/>
+                <enum offset="2" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT"/>
+                <type name="VkPhysicalDeviceDiscardRectanglePropertiesEXT"/>
+                <type name="VkPipelineDiscardRectangleStateCreateInfoEXT"/>
+                <type name="VkPipelineDiscardRectangleStateCreateFlagsEXT"/>
+                <type name="VkDiscardRectangleModeEXT"/>
+                <command name="vkCmdSetDiscardRectangleEXT"/>
+                <command name="vkCmdSetDiscardRectangleEnableEXT"/>
+                <command name="vkCmdSetDiscardRectangleModeEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_101" number="101" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_101_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_101&quot;"               name="VK_NV_EXTENSION_101_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_conservative_rasterization" number="102" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_conservative_rasterization&quot;" name="VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT"/>
+                <type name="VkPipelineRasterizationConservativeStateCreateInfoEXT"/>
+                <type name="VkPipelineRasterizationConservativeStateCreateFlagsEXT"/>
+                <type name="VkConservativeRasterizationModeEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_clip_enable" number="103" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" specialuse="d3demulation" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_clip_enable&quot;"          name="VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceDepthClipEnableFeaturesEXT"/>
+                <type name="VkPipelineRasterizationDepthClipStateCreateInfoEXT"/>
+                <type name="VkPipelineRasterizationDepthClipStateCreateFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_104" number="104" author="NV" contact="Mathias Schott gitlab:@mschott" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_104_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_104&quot;"               name="VK_NV_EXTENSION_104_EXTENSION_NAME"/>
+                <enum bitpos="0"  extends="VkPrivateDataSlotCreateFlagBits" name="VK_PRIVATE_DATA_SLOT_CREATE_RESERVED_0_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_swapchain_colorspace" number="105" type="instance" depends="VK_KHR_surface" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan,vulkansc">
+            <require>
+                <enum value="4"                                             name="VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_swapchain_colorspace&quot;"       name="VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME"/>
+                <enum offset="1" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"/>
+                <enum offset="2" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"/>
+                <enum offset="3" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"/>
+                <enum offset="4" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"/>
+                <enum offset="5" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_LINEAR_EXT"/>
+                <enum offset="6" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_NONLINEAR_EXT"/>
+                <enum offset="7" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT2020_LINEAR_EXT"/>
+                <enum offset="8" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_HDR10_ST2084_EXT"/>
+                <enum offset="9" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DOLBYVISION_EXT"/>
+                <enum offset="10" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_HDR10_HLG_EXT"/>
+                <enum offset="11" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"/>
+                <enum offset="12" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"/>
+                <enum offset="13" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_PASS_THROUGH_EXT"/>
+                <enum offset="14" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"/>
+                <enum api="vulkan" extends="VkColorSpaceKHR"                name="VK_COLOR_SPACE_DCI_P3_LINEAR_EXT" alias="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" deprecated="aliased"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_hdr_metadata" number="106" type="device" depends="VK_KHR_swapchain" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_HDR_METADATA_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_hdr_metadata&quot;"               name="VK_EXT_HDR_METADATA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"/>
+                <type name="VkHdrMetadataEXT"/>
+                <type name="VkXYColorEXT"/>
+                <command name="vkSetHdrMetadataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_107" number="107" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_107_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_107&quot;"              name="VK_IMG_EXTENSION_107_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_108" number="108" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_108_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_108&quot;"              name="VK_IMG_EXTENSION_108_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_imageless_framebuffer" depends="VK_KHR_maintenance2+VK_KHR_image_format_list+VK_KHR_get_physical_device_properties2" number="109" author="KHR" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_imageless_framebuffer&quot;"      name="VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"/>
+                <type name="VkFramebufferAttachmentsCreateInfoKHR"/>
+                <type name="VkFramebufferAttachmentImageInfoKHR"/>
+                <type name="VkRenderPassAttachmentBeginInfoKHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
+                <enum extends="VkFramebufferCreateFlagBits"                 name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR" alias="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_create_renderpass2" depends="VK_KHR_multiview+VK_KHR_maintenance2" number="110" author="KHR" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_create_renderpass2&quot;"         name="VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
+                <command name="vkCreateRenderPass2KHR"/>
+                <command name="vkCmdBeginRenderPass2KHR"/>
+                <command name="vkCmdNextSubpass2KHR"/>
+                <command name="vkCmdEndRenderPass2KHR"/>
+                <type name="VkRenderPassCreateInfo2KHR"/>
+                <type name="VkAttachmentDescription2KHR"/>
+                <type name="VkAttachmentReference2KHR"/>
+                <type name="VkSubpassDescription2KHR"/>
+                <type name="VkSubpassDependency2KHR"/>
+                <type name="VkSubpassBeginInfoKHR"/>
+                <type name="VkSubpassEndInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_111" number="111" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_111_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_111&quot;"              name="VK_IMG_EXTENSION_111_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shared_presentable_image" number="112" type="device" depends="VK_KHR_swapchain+VK_KHR_get_surface_capabilities2+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" author="KHR" contact="Alon Or-bach @alonorbach" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shared_presentable_image&quot;"   name="VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"/>
+                <enum offset="0" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"/>
+                <enum offset="1" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"/>
+                <enum offset="0" extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"/>
+                <type name="VkSharedPresentSurfaceCapabilitiesKHR"/>
+                <command name="vkGetSwapchainStatusKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_capabilities" number="113" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_capabilities&quot;" name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalFenceHandleTypeFlagsKHR"/>
+                <type name="VkExternalFenceHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
+                <type name="VkExternalFenceFeatureFlagsKHR"/>
+                <type name="VkExternalFenceFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkPhysicalDeviceExternalFenceInfoKHR"/>
+                <type name="VkExternalFencePropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence" number="114" type="device" depends="VK_KHR_external_fence_capabilities" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence&quot;"             name="VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
+                <type name="VkFenceImportFlagsKHR"/>
+                <type name="VkFenceImportFlagBitsKHR"/>
+                <enum extends="VkFenceImportFlagBits"                       name="VK_FENCE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
+                <type name="VkExportFenceCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_win32" number="115" type="device" depends="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" platform="win32" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_win32&quot;"       name="VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportFenceWin32HandleInfoKHR"/>
+                <type name="VkExportFenceWin32HandleInfoKHR"/>
+                <type name="VkFenceGetWin32HandleInfoKHR"/>
+                <command name="vkImportFenceWin32HandleKHR"/>
+                <command name="vkGetFenceWin32HandleKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_fd" number="116" type="device" depends="VK_KHR_external_fence,VK_VERSION_1_1" author="KHR" contact="Jesse Hall @critsec" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_fd&quot;"          name="VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"/>
+                <type name="VkImportFenceFdInfoKHR"/>
+                <type name="VkFenceGetFdInfoKHR"/>
+                <command name="vkImportFenceFdKHR"/>
+                <command name="vkGetFenceFdKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_performance_query" number="117" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Alon Or-bach @alonorbach" specialuse="devtools" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                    name="VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_performance_query&quot;" name="VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkQueryType"             name="VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR"/>
+                <enum offset="0" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"/>
+                <enum offset="5" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"/>
+                <enum offset="6" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"/>
+                <type name="VkPhysicalDevicePerformanceQueryFeaturesKHR"/>
+                <type name="VkPhysicalDevicePerformanceQueryPropertiesKHR"/>
+                <type name="VkPerformanceCounterKHR"/>
+                <type name="VkPerformanceCounterDescriptionKHR"/>
+                <type name="VkPerformanceCounterDescriptionFlagsKHR"/>
+                <type name="VkPerformanceCounterDescriptionFlagBitsKHR"/>
+                <type name="VkQueryPoolPerformanceCreateInfoKHR"/>
+                <type name="VkPerformanceCounterScopeKHR"/>
+                <type name="VkPerformanceCounterStorageKHR"/>
+                <type name="VkPerformanceCounterUnitKHR"/>
+                <type name="VkPerformanceCounterResultKHR"/>
+                <type name="VkAcquireProfilingLockInfoKHR"/>
+                <type name="VkAcquireProfilingLockFlagsKHR"/>
+                <type name="VkAcquireProfilingLockFlagBitsKHR"/>
+                <type name="VkPerformanceQuerySubmitInfoKHR"/>
+                <command name="vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"/>
+                <command name="vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"/>
+                <command name="vkAcquireProfilingLockKHR"/>
+                <command name="vkReleaseProfilingLockKHR"/>
+            </require>
+            <require depends="VKSC_VERSION_1_0" api="vulkansc">
+                <enum offset="7" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR"/>
+                <type name="VkPerformanceQueryReservationInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance2" number="118" type="device" author="KHR" contact="Michael Worcester @michaelworcester" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_MAINTENANCE_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance2&quot;"               name="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_2_SPEC_VERSION"             name="VK_KHR_MAINTENANCE2_SPEC_VERSION" deprecated="aliased"/>
+                <enum alias="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE2_EXTENSION_NAME" deprecated="aliased"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" alias="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
+                <type name="VkPhysicalDevicePointClippingPropertiesKHR"/>
+                <type name="VkPointClippingBehaviorKHR"/>
+                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
+                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
+                <type name="VkRenderPassInputAttachmentAspectCreateInfoKHR"/>
+                <type name="VkInputAttachmentAspectReferenceKHR"/>
+                <type name="VkImageViewUsageCreateInfoKHR"/>
+                <type name="VkTessellationDomainOriginKHR"/>
+                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
+                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
+                <type name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_119" number="119" author="KHR" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_119_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_119&quot;"              name="VK_KHR_EXTENSION_119_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_surface_capabilities2" number="120" type="instance" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_surface_capabilities2&quot;"  name="VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"/>
+                <type name="VkPhysicalDeviceSurfaceInfo2KHR"/>
+                <type name="VkSurfaceCapabilities2KHR"/>
+                <type name="VkSurfaceFormat2KHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilities2KHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceFormats2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_variable_pointers" number="121" type="device" author="KHR" contact="Jesse Hall @critsec" depends="VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_VARIABLE_POINTERS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_variable_pointers&quot;"          name="VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceVariablePointerFeaturesKHR"/>
+                <type name="VkPhysicalDeviceVariablePointersFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_display_properties2" number="122" type="instance" depends="VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_display_properties2&quot;"    name="VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"/>
+                <type name="VkDisplayProperties2KHR"/>
+                <type name="VkDisplayPlaneProperties2KHR"/>
+                <type name="VkDisplayModeProperties2KHR"/>
+                <type name="VkDisplayPlaneInfo2KHR"/>
+                <type name="VkDisplayPlaneCapabilities2KHR"/>
+                <command name="vkGetPhysicalDeviceDisplayProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPlaneProperties2KHR"/>
+                <command name="vkGetDisplayModeProperties2KHR"/>
+                <command name="vkGetDisplayPlaneCapabilities2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_ios_surface" number="123" type="instance" depends="VK_KHR_surface" platform="ios" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface">
+            <require>
+                <enum value="3"                                             name="VK_MVK_IOS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_ios_surface&quot;"                name="VK_MVK_IOS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"/>
+                <type name="VkIOSSurfaceCreateFlagsMVK"/>
+                <type name="VkIOSSurfaceCreateInfoMVK"/>
+                <command name="vkCreateIOSSurfaceMVK"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_macos_surface" number="124" type="instance" depends="VK_KHR_surface" platform="macos" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface">
+            <require>
+                <enum value="3"                                             name="VK_MVK_MACOS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_macos_surface&quot;"              name="VK_MVK_MACOS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"/>
+                <type name="VkMacOSSurfaceCreateFlagsMVK"/>
+                <type name="VkMacOSSurfaceCreateInfoMVK"/>
+                <command name="vkCreateMacOSSurfaceMVK"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_moltenvk" number="125" type="instance" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_MVK_MOLTENVK_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_moltenvk&quot;"                   name="VK_MVK_MOLTENVK_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_dma_buf" number="126" type="device" depends="VK_KHR_external_memory_fd" author="EXT" contact="Lina Versace @versalinyaa" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_dma_buf&quot;"    name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME"/>
+                <enum bitpos="9" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_queue_family_foreign" number="127" type="device" author="EXT" depends="VK_KHR_external_memory,VK_VERSION_1_1" contact="Lina Versace @versalinyaa" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_queue_family_foreign&quot;"       name="VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME"/>
+                <enum                                                       name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_dedicated_allocation" number="128" type="device" author="KHR" depends="VK_KHR_get_memory_requirements2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="3"                                             name="VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_dedicated_allocation&quot;"       name="VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
+                <type name="VkMemoryDedicatedRequirementsKHR"/>
+                <type name="VkMemoryDedicatedAllocateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_utils" number="129" type="instance" author="EXT" contact="Mark Young @marky-lunarg" specialuse="debugging" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DEBUG_UTILS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_utils&quot;"                name="VK_EXT_DEBUG_UTILS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"/>
+                <type name="PFN_vkDebugUtilsMessengerCallbackEXT"/>
+                <type name="VkDebugUtilsLabelEXT"/>
+                <type name="VkDebugUtilsMessageSeverityFlagBitsEXT"/>
+                <type name="VkDebugUtilsMessageSeverityFlagsEXT"/>
+                <type name="VkDebugUtilsMessageTypeFlagBitsEXT"/>
+                <type name="VkDebugUtilsMessageTypeFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCallbackDataEXT"/>
+                <type name="VkDebugUtilsMessengerCallbackDataFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCreateFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCreateInfoEXT"/>
+                <type name="VkDebugUtilsMessengerEXT"/>
+                <type name="VkDebugUtilsObjectNameInfoEXT"/>
+                <type name="VkDebugUtilsObjectTagInfoEXT"/>
+                <command name="vkSetDebugUtilsObjectNameEXT"/>
+                <command name="vkSetDebugUtilsObjectTagEXT"/>
+                <command name="vkQueueBeginDebugUtilsLabelEXT"/>
+                <command name="vkQueueEndDebugUtilsLabelEXT"/>
+                <command name="vkQueueInsertDebugUtilsLabelEXT"/>
+                <command name="vkCmdBeginDebugUtilsLabelEXT"/>
+                <command name="vkCmdEndDebugUtilsLabelEXT"/>
+                <command name="vkCmdInsertDebugUtilsLabelEXT"/>
+                <command name="vkCreateDebugUtilsMessengerEXT"/>
+                <command name="vkDestroyDebugUtilsMessengerEXT"/>
+                <command name="vkSubmitDebugUtilsMessageEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ANDROID_external_memory_android_hardware_buffer" number="130" type="device" author="ANDROID" depends="VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_EXT_queue_family_foreign+VK_KHR_dedicated_allocation" platform="android" contact="Jesse Hall @critsec" supported="vulkan">
+            <require>
+                <enum value="5"                                             name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;" name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME"/>
+                <enum bitpos="10" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"/>
+                <type name="VkAndroidHardwareBufferUsageANDROID"/>
+                <type name="VkAndroidHardwareBufferPropertiesANDROID"/>
+                <type name="VkAndroidHardwareBufferFormatPropertiesANDROID"/>
+                <type name="VkImportAndroidHardwareBufferInfoANDROID"/>
+                <type name="VkMemoryGetAndroidHardwareBufferInfoANDROID"/>
+                <type name="VkExternalFormatANDROID"/>
+                <command name="vkGetAndroidHardwareBufferPropertiesANDROID"/>
+                <command name="vkGetMemoryAndroidHardwareBufferANDROID"/>
+                <type name="AHardwareBuffer"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <type name="VkAndroidHardwareBufferFormatProperties2ANDROID"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_sampler_filter_minmax" number="131" type="device" author="NV" depends="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="2"                                             name="VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_sampler_filter_minmax&quot;"      name="VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT" alias="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MIN_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MIN"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MAX_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MAX"/>
+                <type name="VkSamplerReductionModeEXT"/>
+                <type name="VkSamplerReductionModeCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_storage_buffer_storage_class" number="132" type="device" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_storage_buffer_storage_class&quot;" name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gpu_shader_int16" number="133" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
+            <require>
+                <enum value="2"                                             name="VK_AMD_GPU_SHADER_INT16_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gpu_shader_int16&quot;"           name="VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_134" number="134" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_134_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_134&quot;"              name="VK_AMD_EXTENSION_134_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMDX_shader_enqueue" number="135" author="AMD" depends="VK_KHR_get_physical_device_properties2+VK_KHR_synchronization2+VK_KHR_pipeline_library+VK_KHR_spirv_1_4" type="device" contact="Tobias Hector @tobski" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMDX_shader_enqueue&quot;"             name="VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME"/>
+                <enum                                                       name="VK_SHADER_INDEX_UNUSED_AMDX"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="25" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkPipelineBindPoint"              name="VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <type name="VkPhysicalDeviceShaderEnqueueFeaturesAMDX"/>
+                <type name="VkPhysicalDeviceShaderEnqueuePropertiesAMDX"/>
+                <type name="VkExecutionGraphPipelineScratchSizeAMDX"/>
+                <type name="VkExecutionGraphPipelineCreateInfoAMDX"/>
+                <type name="VkDispatchGraphInfoAMDX"/>
+                <type name="VkDispatchGraphCountInfoAMDX"/>
+                <type name="VkPipelineShaderStageNodeCreateInfoAMDX"/>
+                <type name="VkDeviceOrHostAddressConstAMDX"/>
+                <command name="vkCreateExecutionGraphPipelinesAMDX"/>
+                <command name="vkGetExecutionGraphPipelineScratchSizeAMDX"/>
+                <command name="vkGetExecutionGraphPipelineNodeIndexAMDX"/>
+                <command name="vkCmdInitializeGraphScratchMemoryAMDX"/>
+                <command name="vkCmdDispatchGraphAMDX"/>
+                <command name="vkCmdDispatchGraphIndirectAMDX"/>
+                <command name="vkCmdDispatchGraphIndirectCountAMDX"/>
+            </require>
+            <require depends="VK_KHR_maintenance5">
+                <enum bitpos="25" extends="VkBufferUsageFlagBits2KHR"       name="VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_136" number="136" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_136_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_136&quot;"              name="VK_AMD_EXTENSION_136_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_mixed_attachment_samples" number="137" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_mixed_attachment_samples&quot;"   name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_fragment_mask" number="138" author="AMD" contact="Aaron Hagan @AaronHaganAMD" supported="vulkan" type="device">
+            <require>
+                <enum value="1"                                             name="VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_fragment_mask&quot;"       name="VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_inline_uniform_block" number="139" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2+VK_KHR_maintenance1" contact="Daniel Rakos @aqnuep" supported="vulkan" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_inline_uniform_block&quot;"       name="VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME"/>
+                <enum extends="VkDescriptorType"                            name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT" alias="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT" alias="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"/>
+                <type name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT"/>
+                <type name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT"/>
+                <type name="VkWriteDescriptorSetInlineUniformBlockEXT"/>
+                <type name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_140" number="140" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_140_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_140&quot;"              name="VK_AMD_EXTENSION_140_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_stencil_export" number="141" type="device" author="EXT" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_stencil_export&quot;"      name="VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_142" number="142" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_142_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_142&quot;"              name="VK_AMD_EXTENSION_142_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_143" number="143" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_143_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_143&quot;"              name="VK_AMD_EXTENSION_143_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_sample_locations" number="144" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_sample_locations&quot;"           name="VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME"/>
+                <enum bitpos="12" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"/>
+                <type name="VkSampleLocationEXT"/>
+                <type name="VkSampleLocationsInfoEXT"/>
+                <type name="VkAttachmentSampleLocationsEXT"/>
+                <type name="VkSubpassSampleLocationsEXT"/>
+                <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
+                <type name="VkPipelineSampleLocationsStateCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceSampleLocationsPropertiesEXT"/>
+                <type name="VkMultisamplePropertiesEXT"/>
+                <command name="vkCmdSetSampleLocationsEXT"/>
+                <command name="vkGetPhysicalDeviceMultisamplePropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_relaxed_block_layout" number="145" type="device" author="KHR" contact="John Kessenich @johnkslang" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_relaxed_block_layout&quot;"       name="VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_RESERVED_do_not_use_146" number="146" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
+            <require>
+                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_146_SPEC_VERSION"/>
+                <enum value="&quot;VK_RESERVED_do_not_use_146&quot;"        name="VK_RESERVED_DO_NOT_USE_146_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_memory_requirements2" number="147" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1" name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_memory_requirements2&quot;"   name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
+                <type name="VkBufferMemoryRequirementsInfo2KHR"/>
+                <type name="VkImageMemoryRequirementsInfo2KHR"/>
+                <type name="VkImageSparseMemoryRequirementsInfo2KHR"/>
+                <type name="VkMemoryRequirements2KHR"/>
+                <type name="VkSparseImageMemoryRequirements2KHR"/>
+                <command name="vkGetImageMemoryRequirements2KHR"/>
+                <command name="vkGetBufferMemoryRequirements2KHR"/>
+                <command name="vkGetImageSparseMemoryRequirements2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_image_format_list" number="148" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_image_format_list&quot;"          name="VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
+                <type name="VkImageFormatListCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_blend_operation_advanced" number="149" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_blend_operation_advanced&quot;"   name="VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT"/>
+                <type name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT"/>
+                <type name="VkPipelineColorBlendAdvancedStateCreateInfoEXT"/>
+                <type name="VkBlendOverlapEXT"/>
+                <enum offset="0" extends="VkBlendOp"                        name="VK_BLEND_OP_ZERO_EXT"/>
+                <enum offset="1" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_EXT"/>
+                <enum offset="2" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_EXT"/>
+                <enum offset="3" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OVER_EXT"/>
+                <enum offset="4" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OVER_EXT"/>
+                <enum offset="5" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_IN_EXT"/>
+                <enum offset="6" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_IN_EXT"/>
+                <enum offset="7" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OUT_EXT"/>
+                <enum offset="8" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OUT_EXT"/>
+                <enum offset="9" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_ATOP_EXT"/>
+                <enum offset="10" extends="VkBlendOp"                       name="VK_BLEND_OP_DST_ATOP_EXT"/>
+                <enum offset="11" extends="VkBlendOp"                       name="VK_BLEND_OP_XOR_EXT"/>
+                <enum offset="12" extends="VkBlendOp"                       name="VK_BLEND_OP_MULTIPLY_EXT"/>
+                <enum offset="13" extends="VkBlendOp"                       name="VK_BLEND_OP_SCREEN_EXT"/>
+                <enum offset="14" extends="VkBlendOp"                       name="VK_BLEND_OP_OVERLAY_EXT"/>
+                <enum offset="15" extends="VkBlendOp"                       name="VK_BLEND_OP_DARKEN_EXT"/>
+                <enum offset="16" extends="VkBlendOp"                       name="VK_BLEND_OP_LIGHTEN_EXT"/>
+                <enum offset="17" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORDODGE_EXT"/>
+                <enum offset="18" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORBURN_EXT"/>
+                <enum offset="19" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDLIGHT_EXT"/>
+                <enum offset="20" extends="VkBlendOp"                       name="VK_BLEND_OP_SOFTLIGHT_EXT"/>
+                <enum offset="21" extends="VkBlendOp"                       name="VK_BLEND_OP_DIFFERENCE_EXT"/>
+                <enum offset="22" extends="VkBlendOp"                       name="VK_BLEND_OP_EXCLUSION_EXT"/>
+                <enum offset="23" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_EXT"/>
+                <enum offset="24" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_RGB_EXT"/>
+                <enum offset="25" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARDODGE_EXT"/>
+                <enum offset="26" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARBURN_EXT"/>
+                <enum offset="27" extends="VkBlendOp"                       name="VK_BLEND_OP_VIVIDLIGHT_EXT"/>
+                <enum offset="28" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARLIGHT_EXT"/>
+                <enum offset="29" extends="VkBlendOp"                       name="VK_BLEND_OP_PINLIGHT_EXT"/>
+                <enum offset="30" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDMIX_EXT"/>
+                <enum offset="31" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_HUE_EXT"/>
+                <enum offset="32" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_SATURATION_EXT"/>
+                <enum offset="33" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_COLOR_EXT"/>
+                <enum offset="34" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_LUMINOSITY_EXT"/>
+                <enum offset="35" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_EXT"/>
+                <enum offset="36" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_EXT"/>
+                <enum offset="37" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"/>
+                <enum offset="38" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_DARKER_EXT"/>
+                <enum offset="39" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_EXT"/>
+                <enum offset="40" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_CLAMPED_EXT"/>
+                <enum offset="41" extends="VkBlendOp"                       name="VK_BLEND_OP_CONTRAST_EXT"/>
+                <enum offset="42" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_OVG_EXT"/>
+                <enum offset="43" extends="VkBlendOp"                       name="VK_BLEND_OP_RED_EXT"/>
+                <enum offset="44" extends="VkBlendOp"                       name="VK_BLEND_OP_GREEN_EXT"/>
+                <enum offset="45" extends="VkBlendOp"                       name="VK_BLEND_OP_BLUE_EXT"/>
+                <enum bitpos="19" extends="VkAccessFlagBits"                name="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_coverage_to_color" number="150" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_coverage_to_color&quot;"  name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"/>
+                <type name="VkPipelineCoverageToColorStateCreateFlagsNV"/>
+                <type name="VkPipelineCoverageToColorStateCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_acceleration_structure" number="151" type="device" depends="VK_VERSION_1_1+VK_EXT_descriptor_indexing+VK_KHR_buffer_device_address+VK_KHR_deferred_host_operations" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
+            <require>
+                <enum value="13"                                            name="VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_acceleration_structure&quot;"     name="VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME"/>
+                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"/>
+                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"/>
+                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"/>
+                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"/>
+                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"/>
+                <enum offset="9"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"/>
+                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"/>
+                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"/>
+                <enum offset="12" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"/>
+                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"/>
+                <enum offset="14" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"/>
+                <enum offset="17" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"/>
+                <enum offset="20" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"/>
+                <enum bitpos="25" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum offset="0"  extends="VkDescriptorType"                name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR"/>
+                <enum bitpos="21" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum bitpos="22" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+                <enum offset="0"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"/>
+                <enum offset="1"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"/>
+                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"/>
+                <enum offset="0"  extends="VkIndexType" extnumber="166"     name="VK_INDEX_TYPE_NONE_KHR"/>
+                <enum bitpos="29" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
+                <enum bitpos="19" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"/>
+                <enum bitpos="20" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"/>
+                <type name="VkAccelerationStructureTypeKHR"/>
+                <type name="VkDeviceOrHostAddressKHR"/>
+                <type name="VkDeviceOrHostAddressConstKHR"/>
+                <type name="VkAccelerationStructureBuildRangeInfoKHR"/>
+                <type name="VkAabbPositionsKHR"/>
+                <type name="VkAccelerationStructureGeometryTrianglesDataKHR"/>
+                <type name="VkTransformMatrixKHR"/>
+                <type name="VkAccelerationStructureBuildGeometryInfoKHR"/>
+                <type name="VkAccelerationStructureBuildTypeKHR"/>
+                <type name="VkAccelerationStructureGeometryAabbsDataKHR"/>
+                <type name="VkAccelerationStructureInstanceKHR"/>
+                <type name="VkAccelerationStructureGeometryInstancesDataKHR"/>
+                <type name="VkAccelerationStructureGeometryDataKHR"/>
+                <type name="VkAccelerationStructureGeometryKHR"/>
+                <type name="VkGeometryFlagsKHR"/>
+                <type name="VkGeometryInstanceFlagsKHR"/>
+                <type name="VkGeometryFlagBitsKHR"/>
+                <type name="VkGeometryInstanceFlagBitsKHR"/>
+                <type name="VkAccelerationStructureCreateInfoKHR"/>
+                <type name="VkAccelerationStructureKHR"/>
+                <type name="VkBuildAccelerationStructureFlagBitsKHR"/>
+                <type name="VkBuildAccelerationStructureFlagsKHR"/>
+                <type name="VkCopyAccelerationStructureModeKHR"/>
+                <type name="VkGeometryTypeKHR"/>
+                <type name="VkWriteDescriptorSetAccelerationStructureKHR"/>
+                <type name="VkPhysicalDeviceAccelerationStructureFeaturesKHR"/>
+                <type name="VkPhysicalDeviceAccelerationStructurePropertiesKHR"/>
+                <type name="VkAccelerationStructureDeviceAddressInfoKHR"/>
+                <type name="VkAccelerationStructureVersionInfoKHR"/>
+                <type name="VkCopyAccelerationStructureToMemoryInfoKHR"/>
+                <type name="VkCopyMemoryToAccelerationStructureInfoKHR"/>
+                <type name="VkCopyAccelerationStructureInfoKHR"/>
+                <type name="VkAccelerationStructureCompatibilityKHR"/>
+                <type name="VkAccelerationStructureCreateFlagBitsKHR"/>
+                <type name="VkAccelerationStructureCreateFlagsKHR"/>
+                <type name="VkBuildAccelerationStructureModeKHR"/>
+                <type name="VkAccelerationStructureBuildSizesInfoKHR"/>
+                <command name="vkCreateAccelerationStructureKHR"/>
+                <command name="vkDestroyAccelerationStructureKHR"/>
+                <command name="vkCmdBuildAccelerationStructuresKHR"/>
+                <command name="vkCmdBuildAccelerationStructuresIndirectKHR"/>
+                <command name="vkBuildAccelerationStructuresKHR"/>
+                <command name="vkCopyAccelerationStructureKHR"/>
+                <command name="vkCopyAccelerationStructureToMemoryKHR"/>
+                <command name="vkCopyMemoryToAccelerationStructureKHR"/>
+                <command name="vkWriteAccelerationStructuresPropertiesKHR"/>
+                <command name="vkCmdCopyAccelerationStructureKHR"/>
+                <command name="vkCmdCopyAccelerationStructureToMemoryKHR"/>
+                <command name="vkCmdCopyMemoryToAccelerationStructureKHR"/>
+                <command name="vkGetAccelerationStructureDeviceAddressKHR"/>
+                <command name="vkCmdWriteAccelerationStructuresPropertiesKHR"/>
+                <command name="vkGetDeviceAccelerationStructureCompatibilityKHR"/>
+                <command name="vkGetAccelerationStructureBuildSizesKHR"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="29" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum offset="0"  extends="VkDebugReportObjectTypeEXT"      name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_tracing_pipeline" number="348" type="device" depends="VK_KHR_spirv_1_4+VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_tracing_pipeline&quot;"       name="VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME"/>
+                <enum                                                       name="VK_SHADER_UNUSED_KHR"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"/>
+                <enum offset="15" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"/>
+                <enum offset="16" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"/>
+                <enum offset="18" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"/>
+                <enum bitpos="8"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
+                <enum bitpos="9"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
+                <enum bitpos="10" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
+                <enum bitpos="11" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_MISS_BIT_KHR"/>
+                <enum bitpos="12" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
+                <enum bitpos="13" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
+                <enum bitpos="21" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum bitpos="10" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
+                <enum offset="0"  extends="VkPipelineBindPoint" extnumber="166" name="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
+                <enum bitpos="14" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="15" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="16" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"/>
+                <enum bitpos="17" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"/>
+                <enum bitpos="12" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
+                <enum bitpos="13" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"/>
+                <enum bitpos="19" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"/>
+                <enum offset="0"  extends="VkDynamicState"                  name="VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR"/>
+                <type name="VkRayTracingShaderGroupCreateInfoKHR"/>
+                <type name="VkRayTracingShaderGroupTypeKHR"/>
+                <type name="VkRayTracingPipelineCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
+                <type name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR"/>
+                <type name="VkStridedDeviceAddressRegionKHR"/>
+                <type name="VkTraceRaysIndirectCommandKHR"/>
+                <type name="VkRayTracingPipelineInterfaceCreateInfoKHR"/>
+                <type name="VkShaderGroupShaderKHR"/>
+                <command name="vkCmdTraceRaysKHR"/>
+                <command name="vkCreateRayTracingPipelinesKHR"/>
+                <command name="vkGetRayTracingShaderGroupHandlesKHR"/>
+                <command name="vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"/>
+                <command name="vkCmdTraceRaysIndirectKHR"/>
+                <command name="vkGetRayTracingShaderGroupStackSizeKHR"/>
+                <command name="vkCmdSetRayTracingPipelineStackSizeKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_query" number="349" type="device" depends="VK_KHR_spirv_1_4+VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RAY_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_query&quot;"                  name="VK_KHR_RAY_QUERY_EXTENSION_NAME"/>
+                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceRayQueryFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_152" number="152" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_152_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_152&quot;"               name="VK_NV_EXTENSION_152_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_framebuffer_mixed_samples" number="153" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_framebuffer_mixed_samples&quot;"   name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"/>
+                <type name="VkPipelineCoverageModulationStateCreateInfoNV"/>
+                <type name="VkPipelineCoverageModulationStateCreateFlagsNV"/>
+                <type name="VkCoverageModulationModeNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fill_rectangle" number="154" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FILL_RECTANGLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fill_rectangle&quot;"              name="VK_NV_FILL_RECTANGLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkPolygonMode"                    name="VK_POLYGON_MODE_FILL_RECTANGLE_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_sm_builtins" number="155" type="device" depends="VK_VERSION_1_1" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_sm_builtins&quot;"          name="VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"/>
+                <type name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV"/>
+                <type name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_post_depth_coverage" number="156" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_post_depth_coverage&quot;"        name="VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_sampler_ycbcr_conversion" number="157" type="device" depends="VK_KHR_maintenance1+VK_KHR_bind_memory2+VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2" author="KHR" contact="Andrew Garrard @fluppeteer" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="14"                                            name="VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_sampler_ycbcr_conversion&quot;"   name="VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
+                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR" alias="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8B8G8R8_422_UNORM_KHR" alias="VK_FORMAT_G8B8G8R8_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B8G8R8G8_422_UNORM_KHR" alias="VK_FORMAT_B8G8R8G8_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6_UNORM_PACK16_KHR" alias="VK_FORMAT_R10X6_UNORM_PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" alias="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" alias="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4_UNORM_PACK16_KHR" alias="VK_FORMAT_R12X4_UNORM_PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" alias="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" alias="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16B16G16R16_422_UNORM_KHR" alias="VK_FORMAT_G16B16G16R16_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B16G16R16G16_422_UNORM_KHR" alias="VK_FORMAT_B16G16R16G16_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_2_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_DISJOINT_BIT_KHR" alias="VK_IMAGE_CREATE_DISJOINT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_DISJOINT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"/>
+                <type name="VkSamplerYcbcrConversionCreateInfoKHR"/>
+                <type name="VkSamplerYcbcrConversionInfoKHR"/>
+                <type name="VkBindImagePlaneMemoryInfoKHR"/>
+                <type name="VkImagePlaneMemoryRequirementsInfoKHR"/>
+                <type name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"/>
+                <type name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"/>
+                <command name="vkCreateSamplerYcbcrConversionKHR"/>
+                <command name="vkDestroySamplerYcbcrConversionKHR"/>
+                <type name="VkSamplerYcbcrConversionKHR"/>
+                <type name="VkSamplerYcbcrModelConversionKHR"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"/>
+                <type name="VkSamplerYcbcrRangeKHR"/>
+                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"/>
+                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"/>
+                <type name="VkChromaLocationKHR"/>
+                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_COSITED_EVEN_KHR" alias="VK_CHROMA_LOCATION_COSITED_EVEN"/>
+                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_MIDPOINT_KHR" alias="VK_CHROMA_LOCATION_MIDPOINT"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum extends="VkDebugReportObjectTypeEXT" offset="0"       name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_bind_memory2" number="158" type="device" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_BIND_MEMORY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_bind_memory2&quot;"               name="VK_KHR_BIND_MEMORY_2_EXTENSION_NAME"/>
+                <command name="vkBindBufferMemory2KHR"/>
+                <command name="vkBindImageMemory2KHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_ALIAS_BIT_KHR" alias="VK_IMAGE_CREATE_ALIAS_BIT"/>
+                <type name="VkBindBufferMemoryInfoKHR"/>
+                <type name="VkBindImageMemoryInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_drm_format_modifier" number="159" type="device" depends="((VK_KHR_bind_memory2+VK_KHR_get_physical_device_properties2+VK_KHR_sampler_ycbcr_conversion),VK_VERSION_1_1)+(VK_KHR_image_format_list,VK_VERSION_1_2)" author="EXT" contact="Lina Versace @versalinyaa" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_drm_format_modifier&quot;"  name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME"/>
+                <enum offset="0" dir="-" extends="VkResult"                 name="VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkImageTiling"                    name="VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"/>
+                <enum bitpos="7"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"/>
+                <enum bitpos="8"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"/>
+                <enum bitpos="9"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"/>
+                <enum bitpos="10" extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"/>
+                <type name="VkDrmFormatModifierPropertiesListEXT"/>
+                <type name="VkDrmFormatModifierPropertiesEXT"/>
+                <type name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT"/>
+                <type name="VkImageDrmFormatModifierListCreateInfoEXT"/>
+                <type name="VkImageDrmFormatModifierExplicitCreateInfoEXT"/>
+                <type name="VkImageDrmFormatModifierPropertiesEXT"/>
+                <command name="vkGetImageDrmFormatModifierPropertiesEXT"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <type name="VkDrmFormatModifierPropertiesList2EXT"/>
+                <type name="VkDrmFormatModifierProperties2EXT"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_160" number="160" author="EXT" contact="Mark Young @marky-lunarg" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_160_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_160&quot;"              name="VK_EXT_EXTENSION_160_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_cache" number="161" type="device" author="GOOGLE" contact="Cort Stratton @cdwfs" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_VALIDATION_CACHE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_cache&quot;"           name="VK_EXT_VALIDATION_CACHE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"/>
+                <type name="VkValidationCacheEXT"/>
+                <type name="VkValidationCacheCreateInfoEXT"/>
+                <type name="VkShaderModuleValidationCacheCreateInfoEXT"/>
+                <type name="VkValidationCacheHeaderVersionEXT"/>
+                <type name="VkValidationCacheCreateFlagsEXT"/>
+                <command name="vkCreateValidationCacheEXT"/>
+                <command name="vkDestroyValidationCacheEXT"/>
+                <command name="vkMergeValidationCachesEXT"/>
+                <command name="vkGetValidationCacheDataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_descriptor_indexing" number="162" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_maintenance3" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_descriptor_indexing&quot;"        name="VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
+                <enum extends="VkDescriptorPoolCreateFlagBits"              name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
+                <enum extends="VkDescriptorSetLayoutCreateFlagBits"         name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_FRAGMENTATION_EXT" alias="VK_ERROR_FRAGMENTATION"/>
+                <type name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
+                <type name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"/>
+                <type name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"/>
+                <type name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"/>
+                <type name="VkDescriptorBindingFlagBitsEXT"/>
+                <type name="VkDescriptorBindingFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_viewport_index_layer" number="163" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_viewport_index_layer&quot;" name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_portability_subset" number="164" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Bill Hollings @billhollings" platform="provisional" supported="vulkan" provisional="true" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_portability_subset&quot;"         name="VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <type name="VkPhysicalDevicePortabilitySubsetFeaturesKHR"/>
+                <type name="VkPhysicalDevicePortabilitySubsetPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shading_rate_image" number="165" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="3"                                             name="VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shading_rate_image&quot;"          name="VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"/>
+                <enum            extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV" alias="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
+                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"/>
+                <enum            extends="VkAccessFlagBits"                 name="VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV" alias="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+                <enum            extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum            extends="VkPipelineStageFlagBits"          name="VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"/>
+                <enum offset="6" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"/>
+                <type name="VkShadingRatePaletteEntryNV"/>
+                <type name="VkShadingRatePaletteNV"/>
+                <type name="VkPipelineViewportShadingRateImageStateCreateInfoNV"/>
+                <type name="VkPhysicalDeviceShadingRateImageFeaturesNV"/>
+                <type name="VkPhysicalDeviceShadingRateImagePropertiesNV"/>
+                <type name="VkCoarseSampleLocationNV"/>
+                <type name="VkCoarseSampleOrderCustomNV"/>
+                <type name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV"/>
+                <type name="VkCoarseSampleOrderTypeNV"/>
+                <command name="vkCmdBindShadingRateImageNV"/>
+                <command name="vkCmdSetViewportShadingRatePaletteNV"/>
+                <command name="vkCmdSetCoarseSampleOrderNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_ray_tracing" number="166" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_get_memory_requirements2" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="3"                               name="VK_NV_RAY_TRACING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_ray_tracing&quot;"   name="VK_NV_RAY_TRACING_EXTENSION_NAME"/>
+                <enum                                         name="VK_SHADER_UNUSED_NV"/>
+                <enum offset="0"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"/>
+                <enum offset="1"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"/>
+                <enum offset="3"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_NV"/>
+                <enum offset="4"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"/>
+                <enum offset="5"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"/>
+                <enum offset="6"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"/>
+                <enum offset="7"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"/>
+                <enum offset="8"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"/>
+                <enum offset="9"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"/>
+                <enum offset="11" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"/>
+                <enum offset="12" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_RAYGEN_BIT_NV" alias="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_ANY_HIT_BIT_NV" alias="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV" alias="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_MISS_BIT_NV" alias="VK_SHADER_STAGE_MISS_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_INTERSECTION_BIT_NV" alias="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CALLABLE_BIT_NV" alias="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum extends="VkBufferUsageFlagBits"         name="VK_BUFFER_USAGE_RAY_TRACING_BIT_NV" alias="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
+                <enum extends="VkPipelineBindPoint"           name="VK_PIPELINE_BIND_POINT_RAY_TRACING_NV" alias="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
+                <enum offset="0" extends="VkDescriptorType"   name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"/>
+                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+                <enum offset="0" extends="VkQueryType"        name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"/>
+                <enum bitpos="5" extends="VkPipelineCreateFlagBits"      name="VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"/>
+                <enum offset="0" extends="VkObjectType"       name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"/>
+                <enum extends="VkIndexType"                   name="VK_INDEX_TYPE_NONE_NV" alias="VK_INDEX_TYPE_NONE_KHR"/>
+                <type name="VkRayTracingShaderGroupCreateInfoNV"/>
+                <type name="VkRayTracingShaderGroupTypeNV"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
+                <type name="VkRayTracingPipelineCreateInfoNV"/>
+                <type name="VkGeometryTypeNV"/>
+                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_TRIANGLES_NV" alias="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
+                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_AABBS_NV" alias="VK_GEOMETRY_TYPE_AABBS_KHR"/>
+                <type name="VkAccelerationStructureTypeNV"/>
+                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
+                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
+                <type name="VkGeometryTrianglesNV"/>
+                <type name="VkGeometryAABBNV"/>
+                <type name="VkGeometryDataNV"/>
+                <type name="VkGeometryNV"/>
+                <type name="VkGeometryFlagsNV"/>
+                <type name="VkGeometryFlagBitsNV"/>
+                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_OPAQUE_BIT_NV" alias="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
+                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV" alias="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
+                <type name="VkGeometryInstanceFlagsNV"/>
+                <type name="VkGeometryInstanceFlagBitsNV"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
+                <type name="VkAccelerationStructureInfoNV"/>
+                <type name="VkAccelerationStructureCreateInfoNV"/>
+                <type name="VkAccelerationStructureNV"/>
+                <type name="VkBuildAccelerationStructureFlagBitsNV"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
+                <type name="VkBuildAccelerationStructureFlagsNV"/>
+                <type name="VkCopyAccelerationStructureModeNV"/>
+                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
+                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
+                <type name="VkBindAccelerationStructureMemoryInfoNV"/>
+                <type name="VkWriteDescriptorSetAccelerationStructureNV"/>
+                <type name="VkAccelerationStructureMemoryRequirementsInfoNV"/>
+                <type name="VkPhysicalDeviceRayTracingPropertiesNV"/>
+                <type name="VkAccelerationStructureMemoryRequirementsTypeNV"/>
+                <type name="VkTransformMatrixNV"/>
+                <type name="VkAabbPositionsNV"/>
+                <type name="VkAccelerationStructureInstanceNV"/>
+                <command name="vkCreateAccelerationStructureNV"/>
+                <command name="vkDestroyAccelerationStructureNV"/>
+                <command name="vkGetAccelerationStructureMemoryRequirementsNV"/>
+                <command name="vkBindAccelerationStructureMemoryNV"/>
+                <command name="vkCmdBuildAccelerationStructureNV"/>
+                <command name="vkCmdCopyAccelerationStructureNV"/>
+                <command name="vkCmdTraceRaysNV"/>
+                <command name="vkCreateRayTracingPipelinesNV"/>
+                <command name="vkGetRayTracingShaderGroupHandlesNV"/>
+                <command name="vkGetAccelerationStructureHandleNV"/>
+                <command name="vkCmdWriteAccelerationStructuresPropertiesNV"/>
+                <command name="vkCompileDeferredNV"/>
+            </require>
+            <require depends="VK_KHR_get_memory_requirements2">
+                <type name="VkMemoryRequirements2KHR"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT" name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_representative_fragment_test" number="167" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_representative_fragment_test&quot;" name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"/>
+                <type name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_168" number="168" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_168_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_168&quot;"               name="VK_NV_EXTENSION_168_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance3" number="169" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_MAINTENANCE_3_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance3&quot;"               name="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_3_SPEC_VERSION"             name="VK_KHR_MAINTENANCE3_SPEC_VERSION" deprecated="aliased"/>
+                <enum alias="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE3_EXTENSION_NAME" deprecated="aliased"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
+                <type name="VkPhysicalDeviceMaintenance3PropertiesKHR"/>
+                <type name="VkDescriptorSetLayoutSupportKHR"/>
+                <command name="vkGetDescriptorSetLayoutSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_draw_indirect_count" number="170" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_draw_indirect_count&quot;"        name="VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
+                <command name="vkCmdDrawIndirectCountKHR"/>
+                <command name="vkCmdDrawIndexedIndirectCountKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_filter_cubic" number="171" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan,vulkansc">
+            <require>
+                <enum value="3"                                             name="VK_EXT_FILTER_CUBIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_filter_cubic&quot;"               name="VK_EXT_FILTER_CUBIC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkFilter" extnumber="16"          name="VK_FILTER_CUBIC_EXT"/>
+                <enum bitpos="13" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceImageViewImageFormatInfoEXT"/>
+                <type name="VkFilterCubicImageViewImageFormatPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_shader_resolve" number="172" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
+            <require>
+                <enum value="4"                                                 name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_shader_resolve&quot;"    name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME"/>
+                <enum bitpos="2" extends="VkSubpassDescriptionFlagBits"         name="VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM"/>
+                <enum bitpos="3" extends="VkSubpassDescriptionFlagBits"         name="VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_173" number="173" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_173_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_173&quot;"             name="VK_QCOM_EXTENSION_173_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_174" number="174" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_174_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_174&quot;"             name="VK_QCOM_EXTENSION_174_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_global_priority" number="175" type="device" author="EXT" contact="Andres Rodriguez @lostgoat" supported="vulkan,vulkansc" promotedto="VK_KHR_global_priority">
+            <require>
+                <enum value="2"                                             name="VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_global_priority&quot;"            name="VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR"/>
+                <enum extends="VkResult" name="VK_ERROR_NOT_PERMITTED_EXT" alias="VK_ERROR_NOT_PERMITTED_KHR"/>
+                <type name="VkDeviceQueueGlobalPriorityCreateInfoEXT"/>
+                <type name="VkQueueGlobalPriorityEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_subgroup_extended_types" number="176" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Neil Henning @sheredom" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_subgroup_extended_types&quot;" name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_177" number="177" author="EXT" contact="Neil Henning @sheredom" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_177_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_177&quot;"              name="VK_EXT_EXTENSION_177_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_8bit_storage" number="178" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_8BIT_STORAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_8bit_storage&quot;"               name="VK_KHR_8BIT_STORAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
+                <type name="VkPhysicalDevice8BitStorageFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_host" number="179" type="device" author="EXT" depends="VK_KHR_external_memory,VK_VERSION_1_1" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_host&quot;"       name="VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"/>
+                <enum bitpos="7" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"/>
+                <enum bitpos="8" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"/>
+                <type name="VkImportMemoryHostPointerInfoEXT"/>
+                <type name="VkMemoryHostPointerPropertiesEXT"/>
+                <type name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT"/>
+                <command name="vkGetMemoryHostPointerPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_buffer_marker" number="180" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                          name="VK_AMD_BUFFER_MARKER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_buffer_marker&quot;"           name="VK_AMD_BUFFER_MARKER_EXTENSION_NAME"/>
+                <command name="vkCmdWriteBufferMarkerAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_atomic_int64" number="181" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Aaron Hagan @ahagan" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_atomic_int64&quot;"        name="VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_clock" number="182" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Aaron Hagan @ahagan" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                          name="VK_KHR_SHADER_CLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_clock&quot;"            name="VK_KHR_SHADER_CLOCK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceShaderClockFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_183" number="183" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_183_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_183&quot;"              name="VK_AMD_EXTENSION_183_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_pipeline_compiler_control" number="184" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_pipeline_compiler_control&quot;"  name="VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"/>
+                <type name="VkPipelineCompilerControlFlagBitsAMD"/>
+                <type name="VkPipelineCompilerControlFlagsAMD"/>
+                <type name="VkPipelineCompilerControlCreateInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_calibrated_timestamps" number="185" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_calibrated_timestamps&quot;"      name="VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"/>
+                <type name="VkTimeDomainEXT"/>
+                <type name="VkCalibratedTimestampInfoEXT"/>
+                <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"/>
+                <command name="vkGetCalibratedTimestampsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_core_properties" number="186" type="device" author="AMD" depends="VK_KHR_get_physical_device_properties2" contact="Martin Dinkov @mdinkov" supported="vulkan">
+            <require>
+                <enum value="2"                                          name="VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_core_properties&quot;"  name="VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"/>
+                <type name="VkPhysicalDeviceShaderCorePropertiesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_187" number="187" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_187_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_187&quot;"              name="VK_AMD_EXTENSION_187_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_decode_h265" number="188" type="device" depends="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="7"                                             name="VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_decode_h265&quot;"          name="VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"/>
+                <enum bitpos="1" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR"/>
+
+                <type name="VkVideoDecodeH265ProfileInfoKHR"/>
+                <type name="VkVideoDecodeH265CapabilitiesKHR"/>
+
+                <type name="VkVideoDecodeH265SessionParametersCreateInfoKHR"/>
+                <type name="VkVideoDecodeH265SessionParametersAddInfoKHR"/>
+                <type name="VkVideoDecodeH265PictureInfoKHR"/>
+                <type name="VkVideoDecodeH265DpbSlotInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_global_priority" number="189" type="device" author="KHR" contact="Tobias Hector @tobski" depends="VK_KHR_get_physical_device_properties2" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_global_priority&quot;"            name="VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" extnumber="175"  name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR"/>
+                <enum offset="0" extends="VkStructureType" extnumber="389"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType" extnumber="389"  name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR"/>
+                <enum extends="VkResult" extnumber="175" offset="1" dir="-" name="VK_ERROR_NOT_PERMITTED_KHR"/>
+                <enum                                                       name="VK_MAX_GLOBAL_PRIORITY_SIZE_KHR"/>
+                <type                                                       name="VkDeviceQueueGlobalPriorityCreateInfoKHR"/>
+                <type                                                       name="VkQueueGlobalPriorityKHR"/>
+                <type                                                       name="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"/>
+                <type                                                       name="VkQueueFamilyGlobalPriorityPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_memory_overallocation_behavior" number="190" type="device" author="AMD" contact="Martin Dinkov @mdinkov" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_memory_overallocation_behavior&quot;"    name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"/>
+                <type name="VkMemoryOverallocationBehaviorAMD"/>
+                <type name="VkDeviceMemoryOverallocationCreateInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_vertex_attribute_divisor" number="191" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan,vulkansc">
+            <require>
+                <enum value="3"                                         name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_vertex_attribute_divisor&quot;"   name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"/>
+                <type name="VkVertexInputBindingDivisorDescriptionEXT"/>
+                <type name="VkPipelineVertexInputDivisorStateCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_frame_token" number="192" type="device" depends="VK_KHR_swapchain+VK_GGP_stream_descriptor_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_GGP_FRAME_TOKEN_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_frame_token&quot;"                    name="VK_GGP_FRAME_TOKEN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"/>
+                <type name="VkPresentFrameTokenGGP"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_creation_feedback" number="193" type="device" author="GOOGLE" contact="Jean-Francois Roy @jfroy" specialuse="devtools" supported="vulkan" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_creation_feedback&quot;" name="VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"/>
+                <type name="VkPipelineCreationFeedbackFlagBitsEXT"/>
+                <type name="VkPipelineCreationFeedbackFlagsEXT"/>
+                <type name="VkPipelineCreationFeedbackCreateInfoEXT"/>
+                <type name="VkPipelineCreationFeedbackEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_194" number="194" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_194_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_194&quot;"       name="VK_GOOGLE_EXTENSION_194_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_195" number="195" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_195_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_195&quot;"       name="VK_GOOGLE_EXTENSION_195_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_196" number="196" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_196_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_196&quot;"       name="VK_GOOGLE_EXTENSION_196_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_driver_properties" number="197" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_driver_properties&quot;"          name="VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
+                <enum name="VK_MAX_DRIVER_NAME_SIZE_KHR"/>
+                <enum name="VK_MAX_DRIVER_INFO_SIZE_KHR"/>
+                <type name="VkDriverIdKHR"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_PROPRIETARY_KHR" alias="VK_DRIVER_ID_AMD_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR" alias="VK_DRIVER_ID_AMD_OPEN_SOURCE"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_MESA_RADV_KHR" alias="VK_DRIVER_ID_MESA_RADV"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR" alias="VK_DRIVER_ID_NVIDIA_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR" alias="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR" alias="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR" alias="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_ARM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_ARM_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR" alias="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GGP_PROPRIETARY_KHR" alias="VK_DRIVER_ID_GGP_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_BROADCOM_PROPRIETARY"/>
+                <type name="VkConformanceVersionKHR"/>
+                <type name="VkPhysicalDeviceDriverPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_float_controls" number="198" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_float_controls&quot;"      name="VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
+                <type name="VkPhysicalDeviceFloatControlsPropertiesKHR"/>
+                <type name="VkShaderFloatControlsIndependenceKHR"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR" alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR"         alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR"        alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_subgroup_partitioned" number="199" type="device" depends="VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_subgroup_partitioned&quot;" name="VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME"/>
+                <enum bitpos="8" extends="VkSubgroupFeatureFlagBits"        name="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_depth_stencil_resolve" number="200" type="device" depends="VK_KHR_create_renderpass2" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_depth_stencil_resolve&quot;"      name="VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
+                <type name="VkSubpassDescriptionDepthStencilResolveKHR"/>
+                <type name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"/>
+                <type name="VkResolveModeFlagBitsKHR"/>
+                <type name="VkResolveModeFlagsKHR"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_NONE_KHR" alias="VK_RESOLVE_MODE_NONE"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR" alias="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_AVERAGE_BIT_KHR" alias="VK_RESOLVE_MODE_AVERAGE_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MIN_BIT_KHR" alias="VK_RESOLVE_MODE_MIN_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MAX_BIT_KHR" alias="VK_RESOLVE_MODE_MAX_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_swapchain_mutable_format" number="201" type="device" author="KHR" depends="VK_KHR_swapchain+(VK_KHR_maintenance2,VK_VERSION_1_1)+(VK_KHR_image_format_list,VK_VERSION_1_2)" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                         name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_swapchain_mutable_format&quot;" name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME"/>
+                <enum bitpos="2" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_compute_shader_derivatives" number="202" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_compute_shader_derivatives&quot;" name="VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_mesh_shader" number="203" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_MESH_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_mesh_shader&quot;"             name="VK_NV_MESH_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"/>
+                <enum extends="VkShaderStageFlagBits"                   name="VK_SHADER_STAGE_TASK_BIT_NV" alias="VK_SHADER_STAGE_TASK_BIT_EXT"/>
+                <enum extends="VkShaderStageFlagBits"                   name="VK_SHADER_STAGE_MESH_BIT_NV" alias="VK_SHADER_STAGE_MESH_BIT_EXT"/>
+                <enum extends="VkPipelineStageFlagBits"                 name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"/>
+                <enum extends="VkPipelineStageFlagBits"                 name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"/>
+                <command name="vkCmdDrawMeshTasksNV"/>
+                <command name="vkCmdDrawMeshTasksIndirectNV"/>
+                <command name="vkCmdDrawMeshTasksIndirectCountNV"/>
+                <type name="VkPhysicalDeviceMeshShaderFeaturesNV"/>
+                <type name="VkPhysicalDeviceMeshShaderPropertiesNV"/>
+                <type name="VkDrawMeshTasksIndirectCommandNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_shader_barycentric" number="204" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan" promotedto="VK_KHR_fragment_shader_barycentric">
+            <require>
+                <enum value="1"                                         name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_shader_barycentric&quot;" name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_image_footprint" number="205" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_image_footprint&quot;"  name="VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceShaderImageFootprintFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_scissor_exclusive" number="206" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_scissor_exclusive&quot;"       name="VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"/>
+                <enum offset="0" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV"/>
+                <enum offset="1" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"/>
+                <type name="VkPipelineViewportExclusiveScissorStateCreateInfoNV"/>
+                <type name="VkPhysicalDeviceExclusiveScissorFeaturesNV"/>
+                <command name="vkCmdSetExclusiveScissorEnableNV"/>
+                <command name="vkCmdSetExclusiveScissorNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_diagnostic_checkpoints" type="device" number="207" depends="VK_KHR_get_physical_device_properties2" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_diagnostic_checkpoints&quot;" name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"/>
+                <type name="VkQueueFamilyCheckpointPropertiesNV"/>
+                <type name="VkCheckpointDataNV"/>
+                <command name="vkCmdSetCheckpointNV"/>
+                <command name="vkGetQueueCheckpointDataNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_timeline_semaphore" number="208" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_timeline_semaphore&quot;"     name="VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
+                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_BINARY_KHR" alias="VK_SEMAPHORE_TYPE_BINARY"/>
+                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_TIMELINE_KHR" alias="VK_SEMAPHORE_TYPE_TIMELINE"/>
+                <enum extends="VkSemaphoreWaitFlagBits"                     name="VK_SEMAPHORE_WAIT_ANY_BIT_KHR" alias="VK_SEMAPHORE_WAIT_ANY_BIT"/>
+                <type name="VkSemaphoreTypeKHR"/>
+                <type name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"/>
+                <type name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"/>
+                <type name="VkSemaphoreTypeCreateInfoKHR"/>
+                <type name="VkTimelineSemaphoreSubmitInfoKHR"/>
+                <type name="VkSemaphoreWaitFlagBitsKHR"/>
+                <type name="VkSemaphoreWaitFlagsKHR"/>
+                <type name="VkSemaphoreWaitInfoKHR"/>
+                <type name="VkSemaphoreSignalInfoKHR"/>
+                <command name="vkGetSemaphoreCounterValueKHR"/>
+                <command name="vkWaitSemaphoresKHR"/>
+                <command name="vkSignalSemaphoreKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_209" number="209" type="device" author="KHR" contact="Ian Elliott @ianelliott" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_209_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_209&quot;"          name="VK_KHR_EXTENSION_209_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_shader_integer_functions2" number="210" type="device" depends="VK_KHR_get_physical_device_properties2" author="INTEL" contact="Ian Romanick @ianromanick" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_shader_integer_functions2&quot;" name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"/>
+                <type name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_performance_query" number="211" type="device" author="INTEL" contact="Lionel Landwerlin @llandwerlin" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_performance_query&quot;"    name="VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL" alias="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL" deprecated="aliased"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"/>
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"/>
+                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"/>
+                <type name="VkPerformanceConfigurationTypeINTEL"/>
+                <type name="VkQueryPoolSamplingModeINTEL"/>
+                <type name="VkPerformanceOverrideTypeINTEL"/>
+                <type name="VkPerformanceParameterTypeINTEL"/>
+                <type name="VkPerformanceValueTypeINTEL"/>
+                <type name="VkPerformanceValueDataINTEL"/>
+                <type name="VkPerformanceValueINTEL"/>
+                <type name="VkInitializePerformanceApiInfoINTEL"/>
+                <type name="VkQueryPoolCreateInfoINTEL"/>
+                <type name="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
+                <type name="VkPerformanceMarkerInfoINTEL"/>
+                <type name="VkPerformanceStreamMarkerInfoINTEL"/>
+                <type name="VkPerformanceOverrideInfoINTEL"/>
+                <type name="VkPerformanceConfigurationAcquireInfoINTEL"/>
+                <type name="VkPerformanceConfigurationINTEL"/>
+                <command name="vkInitializePerformanceApiINTEL"/>
+                <command name="vkUninitializePerformanceApiINTEL"/>
+                <command name="vkCmdSetPerformanceMarkerINTEL"/>
+                <command name="vkCmdSetPerformanceStreamMarkerINTEL"/>
+                <command name="vkCmdSetPerformanceOverrideINTEL"/>
+                <command name="vkAcquirePerformanceConfigurationINTEL"/>
+                <command name="vkReleasePerformanceConfigurationINTEL"/>
+                <command name="vkQueueSetPerformanceConfigurationINTEL"/>
+                <command name="vkGetPerformanceParameterINTEL"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_vulkan_memory_model" number="212" type="device" author="KHR" contact="Jeff Bolz @jeffbolznv" depends="VK_KHR_get_physical_device_properties2" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="3"                                         name="VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_vulkan_memory_model&quot;"    name="VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
+                <type name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pci_bus_info" number="213" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Matthaeus G. Chajdas @anteru" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                         name="VK_EXT_PCI_BUS_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pci_bus_info&quot;"           name="VK_EXT_PCI_BUS_INFO_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDevicePCIBusInfoPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_display_native_hdr" number="214" type="device" author="AMD" depends="VK_KHR_get_physical_device_properties2+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_display_native_hdr&quot;"     name="VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"/>
+                <enum offset="0" extends="VkColorSpaceKHR"              name="VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"/>
+                <type name="VkDisplayNativeHdrSurfaceCapabilitiesAMD"/>
+                <type name="VkSwapchainDisplayNativeHdrCreateInfoAMD"/>
+                <command name="vkSetLocalDimmingAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_imagepipe_surface" number="215" type="instance" author="FUCHSIA" depends="VK_KHR_surface" platform="fuchsia" contact="Craig Stout @cdotstout" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_imagepipe_surface&quot;"  name="VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"/>
+                <type name="VkImagePipeSurfaceCreateFlagsFUCHSIA"/>
+                <type name="VkImagePipeSurfaceCreateInfoFUCHSIA"/>
+                <command name="vkCreateImagePipeSurfaceFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_terminate_invocation" number="216" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jesse Hall @critsec" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_terminate_invocation&quot;"    name="VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_217" number="217" author="GOOGLE" contact="Jesse Hall @critsec" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_GOOGLE_EXTENSION_217_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_217&quot;"           name="VK_GOOGLE_EXTENSION_217_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_metal_surface" number="218" type="instance" depends="VK_KHR_surface" platform="metal" supported="vulkan" author="EXT" contact="Dzmitry Malyshau @kvark">
+            <require>
+                <enum value="1"                                             name="VK_EXT_METAL_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_metal_surface&quot;"              name="VK_EXT_METAL_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkMetalSurfaceCreateFlagsEXT"/>
+                <type name="VkMetalSurfaceCreateInfoEXT"/>
+                <command name="vkCreateMetalSurfaceEXT"/>
+                <type name="CAMetalLayer"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_density_map" number="219" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_density_map&quot;"       name="VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"/>
+                <enum bitpos="14" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"/>
+                <enum offset="0"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"/>
+                <enum bitpos="24" extends="VkAccessFlagBits"                name="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
+                <enum bitpos="24" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+                <enum bitpos="9"  extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+                <enum bitpos="0"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"/>
+                <enum bitpos="23" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
+                <enum bitpos="0"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"/>
+                <enum bitpos="1"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT"/>
+                <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="24" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_220" number="220" author="EXT" contact="Dzmitry Malyshau @kvark" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_EXT_EXTENSION_220_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_220&quot;"               name="VK_EXT_EXTENSION_220_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_221" number="221" author="KHR" contact="Tobias Hector @tobski" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_KHR_EXTENSION_221_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_221&quot;"               name="VK_KHR_EXTENSION_221_EXTENSION_NAME"/>
+                <enum bitpos="0" extends="VkRenderPassCreateFlagBits"        name="VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_scalar_block_layout" number="222" depends="VK_KHR_get_physical_device_properties2" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_scalar_block_layout&quot;"        name="VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_223" number="223" author="EXT" contact="Tobias Hector @tobski" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_223_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_223&quot;"              name="VK_EXT_EXTENSION_223_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_hlsl_functionality1" number="224" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_hlsl_functionality1&quot;"     name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME"/>
+                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"   name="VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION" deprecated="aliased"/>
+                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME" name="VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME" deprecated="aliased"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_decorate_string" number="225" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_DECORATE_STRING_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_decorate_string&quot;"         name="VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_subgroup_size_control" number="226" type="device" depends="VK_VERSION_1_1" author="EXT" contact="Neil Henning @sheredom" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="2"                                             name="VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_subgroup_size_control&quot;"      name="VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME"/>
+                <type                                                       name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"/>
+                <type                                                       name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"/>
+                <type                                                       name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"/>
+                <enum extends="VkPipelineShaderStageCreateFlagBits"         name="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT" alias="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"/>
+                <enum extends="VkPipelineShaderStageCreateFlagBits"         name="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT" alias="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_fragment_shading_rate" number="227" type="device" depends="(VK_KHR_create_renderpass2,VK_VERSION_1_2)+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" author="KHR" contact="Tobias Hector @tobski" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_fragment_shading_rate&quot;" name="VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME"/>
+                <type name="VkFragmentShadingRateCombinerOpKHR"/>
+                <type name="VkFragmentShadingRateAttachmentInfoKHR"/>
+                <type name="VkPipelineFragmentShadingRateStateCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateKHR"/>
+                <command name="vkGetPhysicalDeviceFragmentShadingRatesKHR"/>
+                <command name="vkCmdSetFragmentShadingRateKHR"/>
+                <enum offset="3" extends="VkImageLayout" extnumber="165"        name="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
+                <enum offset="0" extends="VkDynamicState"                       name="VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"/>
+                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"/>
+                <enum bitpos="23" extends="VkAccessFlagBits"                    name="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+                <enum bitpos="8" extends="VkImageUsageFlagBits"                 name="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="22" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="30" extends="VkFormatFeatureFlagBits"             name="VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="30" extends="VkFormatFeatureFlagBits2"            name="VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_core_properties2" number="228" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" depends="VK_AMD_shader_core_properties">
+            <require>
+                <enum value="1"                                             name="VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_core_properties2&quot;"    name="VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"/>
+                <type                                                       name="VkPhysicalDeviceShaderCoreProperties2AMD"/>
+                <type                                                       name="VkShaderCorePropertiesFlagBitsAMD"/>
+                <type                                                       name="VkShaderCorePropertiesFlagsAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_229" number="229" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_229_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_229&quot;"              name="VK_AMD_EXTENSION_229_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_device_coherent_memory" number="230" type="device" author="AMD" contact="Tobias Hector @tobski" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_device_coherent_memory&quot;"     name="VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME"/>
+                <enum bitpos="6" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"/>
+                <enum bitpos="7" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"/>
+                <type                                                       name="VkPhysicalDeviceCoherentMemoryFeaturesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_231" number="231" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_231_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_231&quot;"              name="VK_AMD_EXTENSION_231_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_232" number="232" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_232_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_232&quot;"              name="VK_AMD_EXTENSION_232_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_233" number="233" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_233_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_233&quot;"              name="VK_AMD_EXTENSION_233_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_234" number="234" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_234_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_234&quot;"              name="VK_AMD_EXTENSION_234_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_image_atomic_int64" number="235" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Tobias Hector @tobski" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_image_atomic_int64&quot;"  name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_236" number="236" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_236_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_236&quot;"              name="VK_AMD_EXTENSION_236_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_spirv_1_4" number="237" type="device" depends="VK_VERSION_1_1+VK_KHR_shader_float_controls" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SPIRV_1_4_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_spirv_1_4&quot;"                  name="VK_KHR_SPIRV_1_4_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_memory_budget" number="238" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_MEMORY_BUDGET_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_memory_budget&quot;"              name="VK_EXT_MEMORY_BUDGET_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceMemoryBudgetPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_memory_priority" number="239" type="device" depends="VK_KHR_get_physical_device_properties2"  author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_MEMORY_PRIORITY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_memory_priority&quot;"            name="VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceMemoryPriorityFeaturesEXT"/>
+                <type name="VkMemoryPriorityAllocateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_surface_protected_capabilities" number="240" type="instance" depends="VK_VERSION_1_1+VK_KHR_get_surface_capabilities2" author="KHR" contact="Sandeep Shinde @sashinde" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_surface_protected_capabilities&quot;"   name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"/>
+                <type name="VkSurfaceProtectedCapabilitiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_dedicated_allocation_image_aliasing" number="241" type="device" depends="VK_KHR_dedicated_allocation+VK_KHR_get_physical_device_properties2" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
+            <require>
+                <enum value="1"                                                         name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_dedicated_allocation_image_aliasing&quot;"     name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_separate_depth_stencil_layouts" number="242" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_create_renderpass2" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                                   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_separate_depth_stencil_layouts&quot;"   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
+                <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"/>
+                <type name="VkAttachmentReferenceStencilLayoutKHR"/>
+                <type name="VkAttachmentDescriptionStencilLayoutKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_243" number="243" author="INTEL" contact="Slawek Grajewski @sgrajewski" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_INTEL_EXTENSION_243_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_243&quot;"             name="VK_INTEL_EXTENSION_243_EXTENSION_NAME"/>
+                <enum bitpos="46" extends="VkAccessFlagBits2"                name="VK_ACCESS_2_RESERVED_46_BIT_INTEL"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_244" number="244" author="MESA" contact="Andres Rodriguez @lostgoat" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_MESA_EXTENSION_244_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_244&quot;"              name="VK_MESA_EXTENSION_244_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_buffer_device_address" number="245" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv"  deprecatedby="VK_KHR_buffer_device_address" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_buffer_device_address&quot;"      name="VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"/>
+                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_DEVICE_ADDRESS_EXT" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+                <type name="VkPhysicalDeviceBufferAddressFeaturesEXT"/>
+                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
+                <type name="VkBufferDeviceAddressInfoEXT"/>
+                <type name="VkBufferDeviceAddressCreateInfoEXT"/>
+                <command name="vkGetBufferDeviceAddressEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_tooling_info" number="246" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_TOOLING_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_tooling_info&quot;"               name="VK_EXT_TOOLING_INFO_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"/>
+                <type                                                       name="VkToolPurposeFlagBitsEXT"/>
+                <type                                                       name="VkToolPurposeFlagsEXT"/>
+                <type                                                       name="VkPhysicalDeviceToolPropertiesEXT"/>
+                <command                                                    name="vkGetPhysicalDeviceToolPropertiesEXT"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum bitpos="5" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_debug_marker">
+                <enum bitpos="6" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_debug_utils">
+                <enum bitpos="5" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
+                <enum bitpos="6" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_separate_stencil_usage" number="247" type="device" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_separate_stencil_usage&quot;"     name="VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
+                <type name="VkImageStencilUsageCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_features" number="248" type="instance" author="LUNARG" contact="Karl Schultz @karl-lunarg" specialuse="debugging" supported="vulkan,vulkansc">
+            <require>
+                <enum value="5"                                             name="VK_EXT_VALIDATION_FEATURES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_features&quot;"        name="VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"/>
+                <type name="VkValidationFeaturesEXT"/>
+                <type name="VkValidationFeatureEnableEXT"/>
+                <type name="VkValidationFeatureDisableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_present_wait" number="249" type="device" depends="VK_KHR_swapchain+VK_KHR_present_id" author="KHR" contact="Keith Packard @keithp" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PRESENT_WAIT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_present_wait&quot;"           name="VK_KHR_PRESENT_WAIT_EXTENSION_NAME"/>
+                <command name="vkWaitForPresentKHR"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"/>
+                <type name="VkPhysicalDevicePresentWaitFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_cooperative_matrix" number="250" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                              name="VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_cooperative_matrix&quot;"           name="VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
+                <type name="VkCooperativeMatrixPropertiesNV"/>
+                <type name="VkScopeNV"/>
+                <enum extends="VkScopeKHR" name="VK_SCOPE_DEVICE_NV"         alias="VK_SCOPE_DEVICE_KHR"/>
+                <enum extends="VkScopeKHR" name="VK_SCOPE_WORKGROUP_NV"      alias="VK_SCOPE_WORKGROUP_KHR"/>
+                <enum extends="VkScopeKHR" name="VK_SCOPE_SUBGROUP_NV"       alias="VK_SCOPE_SUBGROUP_KHR"/>
+                <enum extends="VkScopeKHR" name="VK_SCOPE_QUEUE_FAMILY_NV"   alias="VK_SCOPE_QUEUE_FAMILY_KHR"/>
+                <type name="VkComponentTypeNV"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT16_NV"  alias="VK_COMPONENT_TYPE_FLOAT16_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT32_NV"  alias="VK_COMPONENT_TYPE_FLOAT32_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT64_NV"  alias="VK_COMPONENT_TYPE_FLOAT64_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT8_NV"    alias="VK_COMPONENT_TYPE_SINT8_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT16_NV"   alias="VK_COMPONENT_TYPE_SINT16_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT32_NV"   alias="VK_COMPONENT_TYPE_SINT32_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT64_NV"   alias="VK_COMPONENT_TYPE_SINT64_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT8_NV"    alias="VK_COMPONENT_TYPE_UINT8_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT16_NV"   alias="VK_COMPONENT_TYPE_UINT16_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT32_NV"   alias="VK_COMPONENT_TYPE_UINT32_KHR"/>
+                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT64_NV"   alias="VK_COMPONENT_TYPE_UINT64_KHR"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesNV"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesNV"/>
+                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_coverage_reduction_mode" number="251" depends="VK_NV_framebuffer_mixed_samples+VK_KHR_get_physical_device_properties2" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_coverage_reduction_mode&quot;"     name="VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"/>
+                <type name="VkPhysicalDeviceCoverageReductionModeFeaturesNV"/>
+                <type name="VkPipelineCoverageReductionStateCreateInfoNV"/>
+                <type name="VkPipelineCoverageReductionStateCreateFlagsNV"/>
+                <type name="VkCoverageReductionModeNV"/>
+                <type name="VkFramebufferMixedSamplesCombinationNV"/>
+                <command name="vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_shader_interlock" number="252" author="EXT" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_shader_interlock&quot;"      name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_ycbcr_image_arrays" number="253" type="device" depends="VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_ycbcr_image_arrays&quot;"         name="VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_uniform_buffer_standard_layout" number="254" depends="VK_KHR_get_physical_device_properties2" type="device" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_uniform_buffer_standard_layout&quot;" name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME"/>
+                <type                                                           name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_provoking_vertex" number="255" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @jessehall" specialuse="glemulation" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PROVOKING_VERTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_provoking_vertex&quot;"           name="VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceProvokingVertexFeaturesEXT"/>
+                <type name="VkPhysicalDeviceProvokingVertexPropertiesEXT"/>
+                <type name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"/>
+                <type name="VkProvokingVertexModeEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_full_screen_exclusive" number="256" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" platform="win32" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_full_screen_exclusive&quot;"      name="VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"/>
+                <enum offset="0" extends="VkResult" dir="-"                 name="VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"/>
+                <type name="VkFullScreenExclusiveEXT"/>
+                <type name="VkSurfaceFullScreenExclusiveInfoEXT"/>
+                <type name="VkSurfaceCapabilitiesFullScreenExclusiveEXT"/>
+                <command name="vkGetPhysicalDeviceSurfacePresentModes2EXT"/>
+                <command name="vkAcquireFullScreenExclusiveModeEXT"/>
+                <command name="vkReleaseFullScreenExclusiveModeEXT"/>
+            </require>
+            <require depends="VK_KHR_win32_surface">
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"/>
+                <type name="VkSurfaceFullScreenExclusiveWin32InfoEXT"/>
+            </require>
+            <require depends="VK_KHR_device_group">
+                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
+            </require>
+            <require depends="VK_VERSION_1_1">
+                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_headless_surface" number="257" type="instance" depends="VK_KHR_surface" author="EXT" contact="Lisa Wu @chengtianww" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_HEADLESS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_headless_surface&quot;"               name="VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkHeadlessSurfaceCreateFlagsEXT"/>
+                <type name="VkHeadlessSurfaceCreateInfoEXT"/>
+                <command name="vkCreateHeadlessSurfaceEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_buffer_device_address" number="258" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_device_group),VK_VERSION_1_1" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_buffer_device_address&quot;"      name="VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
+                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"/>
+                <type name="VkBufferDeviceAddressInfoKHR"/>
+                <type name="VkBufferOpaqueCaptureAddressCreateInfoKHR"/>
+                <type name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"/>
+                <type name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"/>
+                <command name="vkGetBufferDeviceAddressKHR"/>
+                <command name="vkGetBufferOpaqueCaptureAddressKHR"/>
+                <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_259" number="259" author="EXT" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_259_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_259&quot;"              name="VK_EXT_EXTENSION_259_EXTENSION_NAME"/>
+                <enum bitpos="9"  extends="VkQueueFlagBits"                 name="VK_QUEUE_RESERVED_9_BIT_EXT"/>
+                <enum bitpos="44" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_44_BIT_EXT"/>
+                <enum bitpos="45" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_45_BIT_EXT"/>
+                <enum bitpos="19" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_RESERVED_19_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_line_rasterization" number="260" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" specialuse="cadsupport" supported="vulkan,vulkansc" promotedto="VK_KHR_line_rasterization">
+            <require>
+                <enum value="1"                                             name="VK_EXT_LINE_RASTERIZATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_line_rasterization&quot;"         name="VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_LINE_STIPPLE_EXT" alias="VK_DYNAMIC_STATE_LINE_STIPPLE_KHR"/>
+                <type name="VkPhysicalDeviceLineRasterizationFeaturesEXT"/>
+                <type name="VkPhysicalDeviceLineRasterizationPropertiesEXT"/>
+                <type name="VkPipelineRasterizationLineStateCreateInfoEXT"/>
+                <type name="VkLineRasterizationModeEXT"/>
+                <command name="vkCmdSetLineStippleEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_atomic_float" number="261" type="device" author="NV" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_atomic_float&quot;"        name="VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_host_query_reset" number="262" author="EXT" contact="Bas Nieuwenhuizen @BNieuwenhuizen" supported="vulkan" type="device" depends="VK_KHR_get_physical_device_properties2" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_HOST_QUERY_RESET_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_host_query_reset&quot;"           name="VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
+                <type name="VkPhysicalDeviceHostQueryResetFeaturesEXT"/>
+                <command name="vkResetQueryPoolEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_263" number="263" author="GGP" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_GGP_EXTENSION_263_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_263&quot;"              name="VK_GGP_EXTENSION_263_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_BRCM_extension_264" number="264" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_BRCM_EXTENSION_264_SPEC_VERSION"/>
+                <enum value="&quot;VK_BRCM_extension_264&quot;"             name="VK_BRCM_EXTENSION_264_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_BRCM_extension_265" number="265" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_BRCM_EXTENSION_265_SPEC_VERSION"/>
+                <enum value="&quot;VK_BRCM_extension_265&quot;"             name="VK_BRCM_EXTENSION_265_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_index_type_uint8" number="266" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_index_type_uint8&quot;"           name="VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"/>
+                <enum offset="0" extends="VkIndexType"                      name="VK_INDEX_TYPE_UINT8_EXT"/>
+                <type name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_267" number="267" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_267_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_267&quot;"              name="VK_EXT_EXTENSION_267_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extended_dynamic_state" number="268" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extended_dynamic_state&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT" comment="Not promoted to 1.3"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_CULL_MODE_EXT" alias="VK_DYNAMIC_STATE_CULL_MODE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_FRONT_FACE_EXT" alias="VK_DYNAMIC_STATE_FRONT_FACE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT" alias="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT" alias="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT" alias="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT" alias="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT" alias="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_STENCIL_OP_EXT" alias="VK_DYNAMIC_STATE_STENCIL_OP"/>
+                <type name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT" comment="Not promoted to 1.3"/>
+                <command name="vkCmdSetCullModeEXT"/>
+                <command name="vkCmdSetFrontFaceEXT"/>
+                <command name="vkCmdSetPrimitiveTopologyEXT"/>
+                <command name="vkCmdSetViewportWithCountEXT"/>
+                <command name="vkCmdSetScissorWithCountEXT"/>
+                <command name="vkCmdBindVertexBuffers2EXT"/>
+                <command name="vkCmdSetDepthTestEnableEXT"/>
+                <command name="vkCmdSetDepthWriteEnableEXT"/>
+                <command name="vkCmdSetDepthCompareOpEXT"/>
+                <command name="vkCmdSetDepthBoundsTestEnableEXT"/>
+                <command name="vkCmdSetStencilTestEnableEXT"/>
+                <command name="vkCmdSetStencilOpEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_deferred_host_operations" number="269" type="device" author="KHR" contact="Josh Barczak @jbarczak" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_deferred_host_operations&quot;"   name="VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"/>
+                <type name="VkDeferredOperationKHR"/>
+                <command name="vkCreateDeferredOperationKHR"/>
+                <command name="vkDestroyDeferredOperationKHR"/>
+                <command name="vkGetDeferredOperationMaxConcurrencyKHR"/>
+                <command name="vkGetDeferredOperationResultKHR"/>
+                <command name="vkDeferredOperationJoinKHR" />
+                <enum extends="VkResult"       offset="0"       name="VK_THREAD_IDLE_KHR" />
+                <enum extends="VkResult"       offset="1"       name="VK_THREAD_DONE_KHR" />
+                <enum extends="VkResult"       offset="2"       name="VK_OPERATION_DEFERRED_KHR" />
+                <enum extends="VkResult"       offset="3"       name="VK_OPERATION_NOT_DEFERRED_KHR" />
+            </require>
+        </extension>
+        <extension name="VK_KHR_pipeline_executable_properties" number="270" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Faith Ekstrand @gfxstrand" specialuse="devtools" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_pipeline_executable_properties&quot;"   name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"/>
+                <enum bitpos="6" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"/>
+                <enum bitpos="7" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"/>
+                <type name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR"/>
+                <type name="VkPipelineInfoKHR"/>
+                <type name="VkPipelineExecutablePropertiesKHR"/>
+                <type name="VkPipelineExecutableInfoKHR"/>
+                <type name="VkPipelineExecutableStatisticFormatKHR"/>
+                <type name="VkPipelineExecutableStatisticValueKHR"/>
+                <type name="VkPipelineExecutableStatisticKHR"/>
+                <type name="VkPipelineExecutableInternalRepresentationKHR"/>
+                <command name="vkGetPipelineExecutablePropertiesKHR"/>
+                <command name="vkGetPipelineExecutableStatisticsKHR"/>
+                <command name="vkGetPipelineExecutableInternalRepresentationsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_host_image_copy" number="271" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_copy_commands2+VK_KHR_format_feature_flags2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_host_image_copy&quot;"        name="VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT"/>
+                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT"/>
+                <enum offset="2"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT"/>
+                <enum offset="3"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT"/>
+                <enum offset="4"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT"/>
+                <enum offset="5"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT"/>
+                <enum offset="6"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT"/>
+                <enum offset="7"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT"/>
+                <enum offset="8"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT"/>
+                <enum offset="9"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT"/>
+                <enum bitpos="22" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT"               comment="Can be used with host image copies"/>
+                <enum bitpos="46" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT"    comment="Host image copies are supported"/>
+                <type name="VkPhysicalDeviceHostImageCopyFeaturesEXT"/>
+                <type name="VkPhysicalDeviceHostImageCopyPropertiesEXT"/>
+                <type name="VkHostImageCopyFlagBitsEXT"/>
+                <type name="VkHostImageCopyFlagsEXT"/>
+                <type name="VkMemoryToImageCopyEXT"/>
+                <type name="VkImageToMemoryCopyEXT"/>
+                <type name="VkCopyMemoryToImageInfoEXT"/>
+                <type name="VkCopyImageToMemoryInfoEXT"/>
+                <type name="VkCopyImageToImageInfoEXT"/>
+                <type name="VkHostImageLayoutTransitionInfoEXT"/>
+                <type name="VkSubresourceHostMemcpySizeEXT"/>
+                <type name="VkHostImageCopyDevicePerformanceQueryEXT"/>
+                <command name="vkCopyMemoryToImageEXT"/>
+                <command name="vkCopyImageToMemoryEXT"/>
+                <command name="vkCopyImageToImageEXT"/>
+                <command name="vkTransitionImageLayoutEXT"/>
+
+                <type name="VkSubresourceLayout2EXT"/>
+                <type name="VkImageSubresource2EXT"/>
+                <command name="vkGetImageSubresourceLayout2EXT" comment="Taken from VK_EXT_image_compression_control. VkStructureType enums defined in that extension"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_map_memory2" number="272" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                               name="VK_KHR_MAP_MEMORY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_map_memory2&quot;"  name="VK_KHR_MAP_MEMORY_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"    name="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"    name="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR"/>
+                <type name="VkMemoryMapInfoKHR"/>
+                <type name="VkMemoryUnmapInfoKHR"/>
+                <type name="VkMemoryUnmapFlagsKHR"/>
+                <command name="vkMapMemory2KHR"/>
+                <command name="vkUnmapMemory2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_273" number="273" type="device" author="INTEL" contact="Faith Ekstrand @gfxstrand" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_INTEL_EXTENSION_273_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_273&quot;"            name="VK_INTEL_EXTENSION_273_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_atomic_float2" number="274" type="device" depends="VK_EXT_shader_atomic_float" author="EXT" contact="Faith Ekstrand @gfxstrand" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_atomic_float2&quot;"       name="VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_surface_maintenance1" number="275" type="instance" depends="VK_KHR_surface+VK_KHR_get_surface_capabilities2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_surface_maintenance1&quot;"       name="VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT"/>
+                <type name="VkSurfacePresentModeEXT"/>
+                <type name="VkPresentScalingFlagBitsEXT"/>
+                <type name="VkPresentScalingFlagsEXT"/>
+                <type name="VkPresentGravityFlagBitsEXT"/>
+                <type name="VkPresentGravityFlagsEXT"/>
+                <type name="VkSurfacePresentScalingCapabilitiesEXT"/>
+                <type name="VkSurfacePresentModeCompatibilityEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_swapchain_maintenance1" number="276" type="device" depends="VK_KHR_swapchain+VK_EXT_surface_maintenance1+VK_KHR_get_physical_device_properties2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_swapchain_maintenance1&quot;"     name="VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT"/>
+                <enum bitpos="3" extends="VkSwapchainCreateFlagBitsKHR"     name="VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT"/>
+                <type name="VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"/>
+                <type name="VkSwapchainPresentFenceInfoEXT"/>
+                <type name="VkSwapchainPresentModesCreateInfoEXT"/>
+                <type name="VkSwapchainPresentModeInfoEXT"/>
+                <type name="VkSwapchainPresentScalingCreateInfoEXT"/>
+                <type name="VkReleaseSwapchainImagesInfoEXT"/>
+                <command name="vkReleaseSwapchainImagesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_demote_to_helper_invocation" number="277" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_demote_to_helper_invocation&quot;" name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_generated_commands" number="278" type="device" depends="VK_VERSION_1_1+VK_KHR_buffer_device_address" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <comment>
+                    This extension requires buffer_device_address functionality.
+                    VK_EXT_buffer_device_address is also acceptable, but since it is deprecated the KHR version is preferred.
+                </comment>
+                <enum value="3"                                             name="VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_generated_commands&quot;"   name="VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"/>
+                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"/>
+                <enum bitpos="18" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"/>
+                <enum bitpos="17" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV"/>
+                <enum bitpos="17" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV"/>
+                <enum bitpos="18" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"/>
+                <type name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV"/>
+                <type name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV"/>
+                <type name="VkGraphicsShaderGroupCreateInfoNV"/>
+                <type name="VkGraphicsPipelineShaderGroupsCreateInfoNV"/>
+                <type name="VkBindShaderGroupIndirectCommandNV"/>
+                <type name="VkBindIndexBufferIndirectCommandNV"/>
+                <type name="VkBindVertexBufferIndirectCommandNV"/>
+                <type name="VkSetStateFlagsIndirectCommandNV"/>
+                <type name="VkIndirectStateFlagBitsNV"/>
+                <type name="VkIndirectStateFlagsNV"/>
+                <type name="VkIndirectCommandsLayoutNV"/>
+                <type name="VkIndirectCommandsTokenTypeNV"/>
+                <type name="VkIndirectCommandsLayoutUsageFlagBitsNV"/>
+                <type name="VkIndirectCommandsLayoutUsageFlagsNV"/>
+                <type name="VkIndirectCommandsStreamNV"/>
+                <type name="VkIndirectCommandsLayoutTokenNV"/>
+                <type name="VkIndirectCommandsLayoutCreateInfoNV"/>
+                <type name="VkGeneratedCommandsInfoNV"/>
+                <type name="VkGeneratedCommandsMemoryRequirementsInfoNV"/>
+                <command name="vkGetGeneratedCommandsMemoryRequirementsNV"/>
+                <command name="vkCmdPreprocessGeneratedCommandsNV"/>
+                <command name="vkCmdExecuteGeneratedCommandsNV"/>
+                <command name="vkCmdBindPipelineShaderGroupNV"/>
+                <command name="vkCreateIndirectCommandsLayoutNV"/>
+                <command name="vkDestroyIndirectCommandsLayoutNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_inherited_viewport_scissor" number="279" type="device" author="NV" contact="David Zhao Akeley @akeley98" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_inherited_viewport_scissor&quot;"  name="VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"/>
+                <type name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV"/>
+                <type name="VkCommandBufferInheritanceViewportScissorInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_280" number="280" type="device" author="KHR" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_280_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_280&quot;"              name="VK_KHR_EXTENSION_280_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_integer_dot_product" number="281" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2" contact="Kevin Petit @kpet" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_integer_dot_product&quot;" name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"/>
+                <type name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"/>
+                <type name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_texel_buffer_alignment" number="282" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_texel_buffer_alignment&quot;"     name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT" comment="Not promoted to 1.3"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"/>
+                <type name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" comment="Not promoted to 1.3"/>
+                <type name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_transform" number="283" type="device" depends="VK_KHR_swapchain+VK_KHR_surface" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="3"                                             name="VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_transform&quot;"     name="VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"/>
+                <enum bitpos="1" extends="VkRenderPassCreateFlagBits"       name="VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"/>
+                <type name="VkRenderPassTransformBeginInfoQCOM"/>
+                <type name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_bias_control" number="284" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Joshua Ashton @Joshua-Ashton" specialuse="d3demulation" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_bias_control&quot;"         name="VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"/>
+                <type name="VkPhysicalDeviceDepthBiasControlFeaturesEXT"/>
+                <type name="VkDepthBiasInfoEXT"/>
+                <type name="VkDepthBiasRepresentationEXT"/>
+                <type name="VkDepthBiasRepresentationInfoEXT"/>
+                <command name="vkCmdSetDepthBias2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_device_memory_report" number="285" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Yiwei Zhang @zhangyiwei" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_device_memory_report&quot;"       name="VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"/>
+                <type name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT"/>
+                <type name="VkDeviceDeviceMemoryReportCreateInfoEXT"/>
+                <type name="VkDeviceMemoryReportCallbackDataEXT"/>
+                <type name="VkDeviceMemoryReportFlagsEXT"/>
+                <type name="VkDeviceMemoryReportEventTypeEXT"/>
+                <type name="PFN_vkDeviceMemoryReportCallbackEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_acquire_drm_display" number="286" type="instance" depends="VK_EXT_direct_mode_display" author="EXT" contact="Drew DeVault sir@cmpwn.com" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_acquire_drm_display&quot;"        name="VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireDrmDisplayEXT"/>
+                <command name="vkGetDrmDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_robustness2" number="287"  type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Liam Middlebrook @liam-middlebrook" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_ROBUSTNESS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_robustness2&quot;"                    name="VK_EXT_ROBUSTNESS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceRobustness2FeaturesEXT"/>
+                <type name="VkPhysicalDeviceRobustness2PropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_custom_border_color" number="288" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Liam Middlebrook @liam-middlebrook" specialuse="glemulation,d3demulation" supported="vulkan,vulkansc">
+            <require>
+                <enum value="12"                                            name="VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_custom_border_color&quot;"        name="VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"/>
+                <enum offset="3" extends="VkBorderColor"                    name="VK_BORDER_COLOR_FLOAT_CUSTOM_EXT"/>
+                <enum offset="4" extends="VkBorderColor"                    name="VK_BORDER_COLOR_INT_CUSTOM_EXT"/>
+                <type name="VkSamplerCustomBorderColorCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceCustomBorderColorPropertiesEXT"/>
+                <type name="VkPhysicalDeviceCustomBorderColorFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_289" number="289" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <comment>
+                    These enums are present only to inform downstream
+                    consumers like KTX2. There is no actual Vulkan extension
+                    corresponding to the enums.
+                </comment>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_289_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_289&quot;"              name="VK_EXT_EXTENSION_289_EXTENSION_NAME"/>
+                <enum extends="VkFormat" extnumber="289" offset="0" name="VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="1" name="VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="2" name="VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="3" name="VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="4" name="VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="5" name="VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="6" name="VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="7" name="VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="8" name="VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="9" name="VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="10" name="VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="11" name="VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="12" name="VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="13" name="VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="14" name="VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="15" name="VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="16" name="VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="17" name="VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="18" name="VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="19" name="VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="20" name="VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="21" name="VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="22" name="VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="23" name="VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="24" name="VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="25" name="VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="26" name="VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="27" name="VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="28" name="VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="29" name="VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_user_type" number="290" type="device" author="GOOGLE" contact="Kaye Mason @chaleur" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_USER_TYPE_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_user_type&quot;"               name="VK_GOOGLE_USER_TYPE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_pipeline_library" number="291" type="device" author="KHR" contact="Christoph Kubisch @pixeljetstream" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_pipeline_library&quot;"           name="VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME"/>
+                <enum bitpos="11" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"/>
+                <type name="VkPipelineLibraryCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_292" number="292" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_292_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_292&quot;"               name="VK_NV_EXTENSION_292_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_present_barrier" number="293" type="device" author="NV" depends="VK_KHR_get_physical_device_properties2+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" contact="Liya Li @liyli" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_PRESENT_BARRIER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_present_barrier&quot;"             name="VK_NV_PRESENT_BARRIER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDevicePresentBarrierFeaturesNV"/>
+                <type name="VkSurfaceCapabilitiesPresentBarrierNV"/>
+                <type name="VkSwapchainPresentBarrierCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_non_semantic_info" number="294" type="device" author="KHR" contact="Baldur Karlsson @baldurk" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_non_semantic_info&quot;"   name="VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_present_id" number="295" type="device" depends="VK_KHR_swapchain+VK_KHR_get_physical_device_properties2" author="KHR" contact="Keith Packard @keithp" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PRESENT_ID_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_present_id&quot;"             name="VK_KHR_PRESENT_ID_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"/>
+                <type name="VkPresentIdKHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"/>
+                <type name="VkPhysicalDevicePresentIdFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_private_data" number="296" type="device" author="NV" contact="Matthew Rusch @mattruschnv" supported="vulkan" depends="VK_KHR_get_physical_device_properties2" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PRIVATE_DATA_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_private_data&quot;"               name="VK_EXT_PRIVATE_DATA_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"/>
+                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT" alias="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"/>
+                <type name="VkPhysicalDevicePrivateDataFeaturesEXT"/>
+                <type name="VkDevicePrivateDataCreateInfoEXT"/>
+                <type name="VkPrivateDataSlotCreateInfoEXT"/>
+                <type name="VkPrivateDataSlotEXT"/>
+                <type name="VkPrivateDataSlotCreateFlagsEXT" comment="Will add VkPrivateDataSlotCreateFlagBits when bits are defined in the future"/>
+                <command name="vkCreatePrivateDataSlotEXT"/>
+                <command name="vkDestroyPrivateDataSlotEXT"/>
+                <command name="vkSetPrivateDataEXT"/>
+                <command name="vkGetPrivateDataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_297" number="297" author="KHR" contact="Corentin Wallez @Kangz" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_297_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_297&quot;"              name="VK_KHR_EXTENSION_297_EXTENSION_NAME"/>
+                <enum bitpos="3" extends="VkPipelineShaderStageCreateFlagBits"  name="VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_creation_cache_control" number="298" type="device" author="AMD" contact="Gregory Grebe @grgrebe_amd" depends="VK_KHR_get_physical_device_properties2" supported="vulkan" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="3"                                             name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_creation_cache_control&quot;"    name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"/>
+                <type name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"/>
+                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT" alias="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
+                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT" alias="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"/>
+                <enum extends="VkResult"                                    name="VK_PIPELINE_COMPILE_REQUIRED_EXT" alias="VK_PIPELINE_COMPILE_REQUIRED"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT" alias="VK_PIPELINE_COMPILE_REQUIRED"/>
+                <enum extends="VkPipelineCacheCreateFlagBits"               name="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT" alias="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"/>
+                <type name="VkPipelineCacheCreateFlagBits" comment="This is a temporary workaround for processors not recognizing that VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT above also requires this type"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_299" number="299" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require comment="used for Vulkan SC 1.0 namespace">
+                <enum value="0"                                         name="VK_KHR_EXTENSION_299_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_299&quot;"          name="VK_KHR_EXTENSION_299_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_encode_queue" number="300"  type="device" depends="VK_KHR_video_queue+VK_KHR_synchronization2" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" provisional="true" platform="provisional" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="10"                                        name="VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_encode_queue&quot;"     name="VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME"/>
+                <!-- VkPipelineStageFlagBits bitpos="27" is reserved by this extension, but not used -->
+                <enum bitpos="27" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS" />
+                <enum bitpos="37" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS" />
+                <enum bitpos="38" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="10" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="6" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_ENCODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="1" extends="VkVideoCodingControlFlagBitsKHR" name="VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="2" extends="VkVideoCodingControlFlagBitsKHR" name="VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="15" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="16" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="13" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="14" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="15" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="27" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="28" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="1" extends="VkVideoSessionCreateFlagBitsKHR" name="VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkQueryResultStatusKHR" dir="-" name="VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR"/>
+
+                <enum offset="0" extends="VkResult" dir="-"             name="VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeFlagsKHR"/>
+                <type name="VkVideoEncodeInfoKHR"/>
+
+                <type name="VkVideoEncodeCapabilityFlagBitsKHR"/>
+                <type name="VkVideoEncodeCapabilityFlagsKHR"/>
+                <type name="VkVideoEncodeCapabilitiesKHR"/>
+
+                <type name="VkQueryPoolVideoEncodeFeedbackCreateInfoKHR"/>
+                <type name="VkVideoEncodeFeedbackFlagBitsKHR"/>
+                <type name="VkVideoEncodeFeedbackFlagsKHR"/>
+
+                <type name="VkVideoEncodeUsageFlagBitsKHR"/>
+                <type name="VkVideoEncodeUsageFlagsKHR"/>
+                <type name="VkVideoEncodeContentFlagBitsKHR"/>
+                <type name="VkVideoEncodeContentFlagsKHR"/>
+                <type name="VkVideoEncodeTuningModeKHR"/>
+                <type name="VkVideoEncodeUsageInfoKHR"/>
+
+                <type name="VkVideoEncodeRateControlFlagsKHR"/>
+                <type name="VkVideoEncodeRateControlModeFlagBitsKHR"/>
+                <type name="VkVideoEncodeRateControlModeFlagsKHR"/>
+                <type name="VkVideoEncodeRateControlInfoKHR"/>
+                <type name="VkVideoEncodeRateControlLayerInfoKHR"/>
+
+                <type name="VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR"/>
+                <type name="VkVideoEncodeQualityLevelPropertiesKHR"/>
+                <type name="VkVideoEncodeQualityLevelInfoKHR"/>
+
+                <type name="VkVideoEncodeSessionParametersGetInfoKHR"/>
+                <type name="VkVideoEncodeSessionParametersFeedbackInfoKHR"/>
+
+                <command name="vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"/>
+                <command name="vkGetEncodedVideoSessionParametersKHR"/>
+                <command name="vkCmdEncodeVideoKHR"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="27" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="28" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_diagnostics_config" number="301" type="device" depends="VK_KHR_get_physical_device_properties2" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_diagnostics_config&quot;"   name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV"/>
+                <type name="VkDeviceDiagnosticsConfigCreateInfoNV"/>
+                <type name="VkDeviceDiagnosticsConfigFlagsNV"/>
+                <type name="VkDeviceDiagnosticsConfigFlagBitsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_store_ops" number="302" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_store_ops&quot;"     name="VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME"/>
+                <enum extends="VkAttachmentStoreOp"                         name="VK_ATTACHMENT_STORE_OP_NONE_QCOM" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_303" number="303" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_303_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_303&quot;"             name="VK_QCOM_EXTENSION_303_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_304" number="304" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_304_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_304&quot;"             name="VK_QCOM_EXTENSION_304_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_305" number="305" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_305_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_305&quot;"             name="VK_QCOM_EXTENSION_305_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_306" number="306" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_306_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_306&quot;"             name="VK_QCOM_EXTENSION_306_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_307" number="307" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_307_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_307&quot;"             name="VK_QCOM_EXTENSION_307_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_cuda_kernel_launch" number="308" type="device" author="NV" contact="Tristan Lorach @tlorach" supported="vulkan" provisional="true">
+            <require>
+                <enum value="2"                                             name="VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_cuda_kernel_launch&quot;"          name="VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_CUDA_MODULE_NV"/>
+                <enum offset="1" extends="VkObjectType"                     name="VK_OBJECT_TYPE_CUDA_FUNCTION_NV"/>
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT"       name="VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV"/>
+                <enum offset="1" extends="VkDebugReportObjectTypeEXT"       name="VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV"/>
+                <type name="VkCudaModuleNV"/>
+                <type name="VkCudaFunctionNV"/>
+                <type name="VkCudaModuleCreateInfoNV"/>
+                <type name="VkCudaFunctionCreateInfoNV"/>
+                <type name="VkCudaLaunchInfoNV"/>
+                <type name="VkPhysicalDeviceCudaKernelLaunchFeaturesNV"/>
+                <type name="VkPhysicalDeviceCudaKernelLaunchPropertiesNV"/>
+                <command name="vkCreateCudaModuleNV"/>
+                <command name="vkGetCudaModuleCacheNV"/>
+                <command name="vkCreateCudaFunctionNV"/>
+                <command name="vkDestroyCudaModuleNV"/>
+                <command name="vkDestroyCudaFunctionNV"/>
+                <command name="vkCmdCudaLaunchKernelNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_object_refresh" number="309" type="device" author="KHR" contact="Aidan Fabius @afabius" supported="vulkansc" ratified="vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_OBJECT_REFRESH_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_object_refresh&quot;"             name="VK_KHR_OBJECT_REFRESH_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR"/>
+                <type name="VkRefreshObjectListKHR"/>
+                <type name="VkRefreshObjectKHR"/>
+                <type name="VkRefreshObjectFlagBitsKHR"/>
+                <type name="VkRefreshObjectFlagsKHR"/>
+                <command name="vkCmdRefreshObjectsKHR"/>
+                <command name="vkGetPhysicalDeviceRefreshableObjectTypesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_310" number="310" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_310_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_310&quot;"             name="VK_QCOM_EXTENSION_310_EXTENSION_NAME"/>
+                <enum bitpos="27" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_RESERVED_27_BIT_QCOM"/>
+                <enum bitpos="27" extends="VkBufferUsageFlagBits2KHR"       name="VK_BUFFER_USAGE_2_RESERVED_27_BIT_QCOM"/>
+                <enum bitpos="51" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_51_BIT_QCOM"/>
+                <enum bitpos="52" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_52_BIT_QCOM"/>
+                <enum bitpos="53" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_53_BIT_QCOM"/>
+                <enum bitpos="54" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_54_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_low_latency" number="311" author="NV" type="device" supported="vulkan" contact="Charles Hansen @cshansen" >
+            <require>
+                <enum value="1"                                             name="VK_NV_LOW_LATENCY_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_low_latency&quot;"                 name="VK_NV_LOW_LATENCY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"/>
+                <type name="VkQueryLowLatencySupportNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_metal_objects" number="312" type="device" platform="metal" supported="vulkan" author="EXT" contact="Bill Hollings @billhollings">
+            <require>
+                <enum value="1"                                             name="VK_EXT_METAL_OBJECTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_metal_objects&quot;"              name="VK_EXT_METAL_OBJECTS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"/>
+                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"/>
+                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"/>
+                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"/>
+                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"/>
+                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"/>
+                <type name="VkExportMetalObjectTypeFlagBitsEXT"/>
+                <type name="VkExportMetalObjectTypeFlagsEXT"/>
+                <type name="VkExportMetalObjectCreateInfoEXT"/>
+                <type name="VkExportMetalObjectsInfoEXT"/>
+                <type name="VkExportMetalDeviceInfoEXT"/>
+                <type name="VkExportMetalCommandQueueInfoEXT"/>
+                <type name="VkExportMetalBufferInfoEXT"/>
+                <type name="VkImportMetalBufferInfoEXT"/>
+                <type name="VkExportMetalTextureInfoEXT"/>
+                <type name="VkImportMetalTextureInfoEXT"/>
+                <type name="VkExportMetalIOSurfaceInfoEXT"/>
+                <type name="VkImportMetalIOSurfaceInfoEXT"/>
+                <type name="VkExportMetalSharedEventInfoEXT"/>
+                <type name="VkImportMetalSharedEventInfoEXT"/>
+                <type name="MTLDevice_id"/>
+                <type name="MTLCommandQueue_id"/>
+                <type name="MTLBuffer_id"/>
+                <type name="MTLTexture_id"/>
+                <type name="MTLSharedEvent_id"/>
+                <type name="IOSurfaceRef"/>
+                <command name="vkExportMetalObjectsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_313" number="313" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_313_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_313&quot;"              name="VK_EXT_EXTENSION_313_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_314" number="314" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_314_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_314&quot;"              name="VK_AMD_EXTENSION_314_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_synchronization2" number="315" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Tobias Hector @tobski" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_synchronization2&quot;"           name="VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"/>
+                <enum extends="VkEventCreateFlagBits"                       name="VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR" alias="VK_EVENT_CREATE_DEVICE_ONLY_BIT"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkPipelineStageFlagBits"                     name="VK_PIPELINE_STAGE_NONE_KHR" alias="VK_PIPELINE_STAGE_NONE"/>
+                <enum extends="VkAccessFlagBits"                            name="VK_ACCESS_NONE_KHR" alias="VK_ACCESS_NONE"/>
+                <type name="VkFlags64"/>
+                <type name="VkPipelineStageFlags2KHR"/>
+                <type name="VkPipelineStageFlagBits2KHR"/>
+                <type name="VkAccessFlags2KHR"/>
+                <type name="VkAccessFlagBits2KHR"/>
+                <type name="VkMemoryBarrier2KHR"/>
+                <type name="VkBufferMemoryBarrier2KHR"/>
+                <type name="VkImageMemoryBarrier2KHR"/>
+                <type name="VkDependencyInfoKHR"/>
+                <type name="VkSubmitInfo2KHR"/>
+                <type name="VkSemaphoreSubmitInfoKHR"/>
+                <type name="VkCommandBufferSubmitInfoKHR"/>
+                <type name="VkSubmitFlagBitsKHR"/>
+                <type name="VkSubmitFlagsKHR"/>
+                <type name="VkPhysicalDeviceSynchronization2FeaturesKHR"/>
+                <command name="vkCmdSetEvent2KHR"/>
+                <command name="vkCmdResetEvent2KHR"/>
+                <command name="vkCmdWaitEvents2KHR"/>
+                <command name="vkCmdPipelineBarrier2KHR"/>
+                <command name="vkCmdWriteTimestamp2KHR"/>
+                <command name="vkQueueSubmit2KHR"/>
+            </require>
+            <require depends="VK_EXT_transform_feedback">
+                <enum bitpos="24" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
+                <enum bitpos="25" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
+                <enum bitpos="26" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
+                <enum bitpos="27" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_conditional_rendering">
+                <enum bitpos="18" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
+                <enum bitpos="20" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT"  comment="read access flag for reading conditional rendering predicate"/>
+            </require>
+            <require depends="VK_NV_device_generated_commands">
+                <enum bitpos="17" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV"/>
+                <enum bitpos="17" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV"/>
+                <enum bitpos="18" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV"/>
+            </require>
+            <require depends="VK_KHR_fragment_shading_rate">
+                <enum bitpos="22" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="23" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+            </require>
+            <require depends="VK_NV_shading_rate_image">
+                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV"    alias="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_acceleration_structure">
+                <enum bitpos="25" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum bitpos="21" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum bitpos="22" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_ray_tracing_pipeline">
+                <enum bitpos="21" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
+            </require>
+            <require depends="VK_NV_ray_tracing">
+                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+            </require>
+            <require depends="VK_EXT_fragment_density_map">
+                <enum bitpos="23" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
+                <enum bitpos="24" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_blend_operation_advanced">
+                <enum bitpos="19" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
+            </require>
+            <require depends="VK_NV_mesh_shader">
+                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"/>
+                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"/>
+            </require>
+            <require depends="VK_AMD_buffer_marker">
+                <command name="vkCmdWriteBufferMarker2AMD"/>
+            </require>
+            <require depends="VK_NV_device_diagnostic_checkpoints">
+                <type name="VkQueueFamilyCheckpointProperties2NV"/>
+                <type name="VkCheckpointData2NV"/>
+                <command name="vkGetQueueCheckpointData2NV"/>
+                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"/>
+                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"/>
+            </require>
+            <require depends="VK_EXT_mesh_shader">
+                <enum bitpos="19" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"/>
+                <enum bitpos="20" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_316" number="316" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_316_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_316&quot;"              name="VK_AMD_EXTENSION_316_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_descriptor_buffer" number="317" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address+VK_KHR_synchronization2+VK_EXT_descriptor_indexing" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_descriptor_buffer&quot;"              name="VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"/>
+                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"/>
+                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
+                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
+                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
+                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
+                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"/>
+                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"/>
+                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"/>
+                <enum bitpos="4" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="5" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT"/>
+                <enum bitpos="21" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="22" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="26" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="5" extends="VkBufferCreateFlagBits"               name="VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
+                <enum bitpos="16" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
+                <enum bitpos="2" extends="VkImageViewCreateFlagBits"            name="VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
+                <enum bitpos="3" extends="VkSamplerCreateFlagBits"              name="VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
+                <enum bitpos="3" extends="VkAccelerationStructureCreateFlagBitsKHR" name="VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
+                <enum bitpos="41" extends="VkAccessFlagBits2"                   name="VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT"/>
+                <enum bitpos="29"  extends="VkPipelineCreateFlagBits"           name="VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <type name="VkPhysicalDeviceDescriptorBufferPropertiesEXT"/>
+                <type name="VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT"/>
+                <type name="VkPhysicalDeviceDescriptorBufferFeaturesEXT"/>
+                <type name="VkDescriptorAddressInfoEXT"/>
+                <type name="VkDescriptorBufferBindingInfoEXT"/>
+                <type name="VkDescriptorBufferBindingPushDescriptorBufferHandleEXT"/>
+                <type name="VkDescriptorDataEXT"/>
+                <type name="VkDescriptorGetInfoEXT"/>
+                <type name="VkBufferCaptureDescriptorDataInfoEXT"/>
+                <type name="VkImageCaptureDescriptorDataInfoEXT"/>
+                <type name="VkImageViewCaptureDescriptorDataInfoEXT"/>
+                <type name="VkSamplerCaptureDescriptorDataInfoEXT"/>
+                <type name="VkOpaqueCaptureDescriptorDataCreateInfoEXT"/>
+                <command name="vkGetDescriptorSetLayoutSizeEXT"/>
+                <command name="vkGetDescriptorSetLayoutBindingOffsetEXT"/>
+                <command name="vkGetDescriptorEXT"/>
+                <command name="vkCmdBindDescriptorBuffersEXT"/>
+                <command name="vkCmdSetDescriptorBufferOffsetsEXT"/>
+                <command name="vkCmdBindDescriptorBufferEmbeddedSamplersEXT"/>
+                <command name="vkGetBufferOpaqueCaptureDescriptorDataEXT"/>
+                <command name="vkGetImageOpaqueCaptureDescriptorDataEXT"/>
+                <command name="vkGetImageViewOpaqueCaptureDescriptorDataEXT"/>
+                <command name="vkGetSamplerOpaqueCaptureDescriptorDataEXT"/>
+            </require>
+            <require depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
+                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
+                <type name="VkAccelerationStructureCaptureDescriptorDataInfoEXT"/>
+                <command name="vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_318" number="318" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_318_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_318&quot;"              name="VK_AMD_EXTENSION_318_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_319" number="319" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_319_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_319&quot;"              name="VK_AMD_EXTENSION_319_EXTENSION_NAME"/>
+                <enum bitpos="3" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD"/>
+                <enum bitpos="0" extends="VkPipelineLayoutCreateFlagBits" name="VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_320" number="320" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_320_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_320&quot;"              name="VK_AMD_EXTENSION_320_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_graphics_pipeline_library" number="321" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_pipeline_library" author="AMD" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_graphics_pipeline_library&quot;"  name="VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"/>
+                <type name="VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT"/>
+                <type name="VkGraphicsPipelineLibraryCreateInfoEXT"/>
+                <type name="VkGraphicsPipelineLibraryFlagBitsEXT"/>
+                <type name="VkGraphicsPipelineLibraryFlagsEXT"/>
+                <type name="VkPipelineLayoutCreateFlagBits"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"/>
+                <enum bitpos="23" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"/>
+                <enum bitpos="10" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT"/>
+                <enum bitpos="1" extends="VkPipelineLayoutCreateFlagBits" name="VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_early_and_late_fragment_tests" number="322" author="EXT" contact="Tobias Hector @tobski" type="device" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_early_and_late_fragment_tests&quot;" name="VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_fragment_shader_barycentric" number="323" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Stu Smith" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                              name="VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_fragment_shader_barycentric&quot;" name="VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" extnumber="204"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"/>
+                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"/>
+                <type name="VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_subgroup_uniform_control_flow" number="324" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_subgroup_uniform_control_flow&quot;" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_325" number="325" author="KHR" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_325_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_325&quot;"              name="VK_KHR_EXTENSION_325_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_zero_initialize_workgroup_memory" number="326" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="1"                                                   name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_zero_initialize_workgroup_memory&quot;" name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"/>
+                <type name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_shading_rate_enums" number="327" type="device" depends="VK_KHR_fragment_shading_rate" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_shading_rate_enums&quot;" name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"/>
+                <enum offset="1" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV"/>
+                <type name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV"/>
+                <type name="VkFragmentShadingRateNV"/>
+                <type name="VkFragmentShadingRateTypeNV"/>
+                <command name="vkCmdSetFragmentShadingRateEnumNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_ray_tracing_motion_blur" number="328" type="device" depends="VK_KHR_ray_tracing_pipeline" author="NV" contact="Eric Werness" supported="vulkan">
+            <require>
+                <enum value="1"                                                    name="VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_ray_tracing_motion_blur&quot;"            name="VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"/>
+                <enum offset="1" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"/>
+                <enum bitpos="5" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"/>
+                <enum bitpos="2" extends="VkAccelerationStructureCreateFlagBitsKHR" name="VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"/>
+                <enum bitpos="20" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"/>
+                <type name="VkAccelerationStructureGeometryMotionTrianglesDataNV"/>
+                <type name="VkAccelerationStructureMotionInfoNV"/>
+                <type name="VkAccelerationStructureMotionInstanceNV"/>
+                <type name="VkAccelerationStructureMotionInstanceDataNV"/>
+                <type name="VkAccelerationStructureMatrixMotionInstanceNV"/>
+                <type name="VkAccelerationStructureSRTMotionInstanceNV"/>
+                <type name="VkSRTDataNV"/>
+                <type name="VkAccelerationStructureMotionInstanceTypeNV"/>
+                <type name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV"/>
+                <type name="VkAccelerationStructureMotionInfoFlagsNV"/>
+                <type name="VkAccelerationStructureMotionInstanceFlagsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_mesh_shader" number="329" type="device" depends="VK_KHR_spirv_1_4" author="EXT" sortorder="1" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_MESH_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_mesh_shader&quot;"            name="VK_EXT_MESH_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"/>
+                <enum bitpos="6" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_TASK_BIT_EXT"/>
+                <enum bitpos="7" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_MESH_BIT_EXT"/>
+                <enum bitpos="19" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"/>
+                <enum bitpos="20" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"/>
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT"/>
+                <enum bitpos="11" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT"/>
+                <enum bitpos="12" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT"/>
+                <command name="vkCmdDrawMeshTasksEXT"/>
+                <command name="vkCmdDrawMeshTasksIndirectEXT"/>
+                <command name="vkCmdDrawMeshTasksIndirectCountEXT"/>
+                <type name="VkPhysicalDeviceMeshShaderFeaturesEXT"/>
+                <type name="VkPhysicalDeviceMeshShaderPropertiesEXT"/>
+                <type name="VkDrawMeshTasksIndirectCommandEXT"/>
+            </require>
+            <require depends="VK_NV_device_generated_commands">
+                <enum offset="0" extends="VkIndirectCommandsTokenTypeNV" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_330" number="330" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_330_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_330&quot;"               name="VK_NV_EXTENSION_330_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_ycbcr_2plane_444_formats" number="331" type="device" depends="VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <comment>
+                    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT and
+                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
+                    were not promoted to Vulkan 1.3.
+                </comment>
+                <enum value="1"                                           name="VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_ycbcr_2plane_444_formats&quot;" name="VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"/>
+                <enum extends="VkFormat"                                  name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT" alias="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"/>
+                <enum extends="VkFormat"                                  name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                  name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                  name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT" alias="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"/>
+                <type name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_332" number="332" author="NV" contact="Tony Zlatinski @tzlatinski" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_332_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_332&quot;"               name="VK_NV_EXTENSION_332_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_density_map2" number="333" type="device" depends="VK_EXT_fragment_density_map" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_density_map2&quot;"      name="VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"/>
+                <enum bitpos="1"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_rotated_copy_commands" number="334" type="device" depends="VK_KHR_swapchain+VK_KHR_copy_commands2" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_rotated_copy_commands&quot;"     name="VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"/>
+                <type name="VkCopyCommandTransformInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_335" number="335" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_335_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_335&quot;"              name="VK_KHR_EXTENSION_335_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_robustness" number="336" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Graeme Leese @gnl21" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_robustness&quot;"           name="VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"/>
+                <type name="VkPhysicalDeviceImageRobustnessFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_workgroup_memory_explicit_layout" number="337" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Caio Marcelo de Oliveira Filho @cmarcelo" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                      name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_workgroup_memory_explicit_layout&quot;"    name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_copy_commands2" number="338" author="KHR" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jeff Leger @jackohound" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_COPY_COMMANDS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_copy_commands2&quot;"             name="VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_COPY_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_COPY_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"/>
+                <type name="VkCopyBufferInfo2KHR"/>
+                <type name="VkCopyImageInfo2KHR"/>
+                <type name="VkCopyBufferToImageInfo2KHR"/>
+                <type name="VkCopyImageToBufferInfo2KHR"/>
+                <type name="VkBlitImageInfo2KHR"/>
+                <type name="VkResolveImageInfo2KHR"/>
+                <type name="VkBufferCopy2KHR"/>
+                <type name="VkImageCopy2KHR"/>
+                <type name="VkImageBlit2KHR"/>
+                <type name="VkBufferImageCopy2KHR"/>
+                <type name="VkImageResolve2KHR"/>
+                <command name="vkCmdCopyBuffer2KHR"/>
+                <command name="vkCmdCopyImage2KHR"/>
+                <command name="vkCmdCopyBufferToImage2KHR"/>
+                <command name="vkCmdCopyImageToBuffer2KHR"/>
+                <command name="vkCmdBlitImage2KHR"/>
+                <command name="vkCmdResolveImage2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_compression_control" number="339" type="device" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_compression_control&quot;"  name="VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceImageCompressionControlFeaturesEXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"/>
+                <type name="VkImageCompressionControlEXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT" alias="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR"/>
+                <type name="VkSubresourceLayout2EXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR"/>
+                <type name="VkImageSubresource2EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"/>
+                <type name="VkImageCompressionPropertiesEXT"/>
+                <type                                                       name="VkImageCompressionFlagBitsEXT"/>
+                <type                                                       name="VkImageCompressionFlagsEXT"/>
+                <type                                                       name="VkImageCompressionFixedRateFlagBitsEXT"/>
+                <type                                                       name="VkImageCompressionFixedRateFlagsEXT"/>
+                <enum offset="0" dir="-" extends="VkResult" name="VK_ERROR_COMPRESSION_EXHAUSTED_EXT"/>
+                <command name="vkGetImageSubresourceLayout2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_attachment_feedback_loop_layout" number="340" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan">
+            <require>
+                <enum value="2"                                                    name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_attachment_feedback_loop_layout&quot;"   name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"/>
+                <enum offset="0" extends="VkImageLayout"                           name="VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT"/>
+                <enum bitpos="19" extends="VkImageUsageFlagBits"                   name="VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
+                <enum bitpos="25" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
+                <enum bitpos="26" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
+                <enum bitpos="3"  extends="VkDependencyFlagBits"                   name="VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT" comment="Dependency may be a feedback loop"/>
+                <type name="VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_4444_formats" number="341" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <comment>
+                    VkPhysicalDevice4444FormatsFeaturesEXT and
+                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
+                    were not promoted to Vulkan 1.3.
+                </comment>
+                <enum value="1"                                             name="VK_EXT_4444_FORMATS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_4444_formats&quot;"               name="VK_EXT_4444_FORMATS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT" alias="VK_FORMAT_A4R4G4B4_UNORM_PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT" alias="VK_FORMAT_A4B4G4R4_UNORM_PACK16"/>
+                <type name="VkPhysicalDevice4444FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_device_fault" number="342" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Ralph Potter gitlab:@r_potter" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DEVICE_FAULT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_device_fault&quot;"               name="VK_EXT_DEVICE_FAULT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"/>
+                <type name="VkPhysicalDeviceFaultFeaturesEXT"/>
+                <type name="VkDeviceFaultCountsEXT"/>
+                <type name="VkDeviceFaultInfoEXT"/>
+                <type name="VkDeviceFaultAddressInfoEXT"/>
+                <type name="VkDeviceFaultAddressTypeEXT"/>
+                <type name="VkDeviceFaultVendorInfoEXT"/>
+                <type name="VkDeviceFaultVendorBinaryHeaderVersionEXT"/>
+                <type name="VkDeviceFaultVendorBinaryHeaderVersionOneEXT"/>
+                <command name="vkGetDeviceFaultInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_rasterization_order_attachment_access" number="343" type="device" depends="VK_KHR_get_physical_device_properties2" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_EXT_rasterization_order_attachment_access">
+            <require>
+                <enum value="1"                                                        name="VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_rasterization_order_attachment_access&quot;" name="VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM"/>
+                <enum extends="VkPipelineColorBlendStateCreateFlagBits"     name="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM" alias="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"/>
+                <enum extends="VkPipelineDepthStencilStateCreateFlagBits"   name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM" alias="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
+                <enum extends="VkPipelineDepthStencilStateCreateFlagBits"   name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM" alias="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
+                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"/>
+                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
+                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_344" number="344" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_ARM_EXTENSION_344_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_344&quot;"              name="VK_ARM_EXTENSION_344_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_rgba10x6_formats" number="345" type="device" depends="VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
+             <require>
+                    <enum value="1"                                                name="VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION"/>
+                    <enum value="&quot;VK_EXT_rgba10x6_formats&quot;"              name="VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME"/>
+                    <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"/>
+                    <type name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_acquire_winrt_display" number="346" type="device" depends="VK_EXT_direct_mode_display" author="NV" contact="Jeff Juliano @jjuliano" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_acquire_winrt_display&quot;"       name="VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireWinrtDisplayNV"/>
+                <command name="vkGetWinrtDisplayNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_directfb_surface" number="347" type="instance" depends="VK_KHR_surface" platform="directfb" supported="vulkan" author="EXT" contact="Nicolas Caramelli @caramelli">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_directfb_surface&quot;"           name="VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkDirectFBSurfaceCreateFlagsEXT"/>
+                <type name="VkDirectFBSurfaceCreateInfoEXT"/>
+                <command name="vkCreateDirectFBSurfaceEXT"/>
+                <command name="vkGetPhysicalDeviceDirectFBPresentationSupportEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_350" number="350" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_350_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_350&quot;"              name="VK_KHR_EXTENSION_350_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_351" number="351" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_351_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_351&quot;"               name="VK_NV_EXTENSION_351_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_VALVE_mutable_descriptor_type" number="352" type="device" supported="vulkan" author="VALVE" contact="Joshua Ashton @Joshua-Ashton,Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_maintenance3" promotedto="VK_EXT_mutable_descriptor_type">
+            <require>
+                <enum value="1"                                                name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION"/>
+                <enum value="&quot;VK_VALVE_mutable_descriptor_type&quot;"     name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"/>
+                <enum extends="VkStructureType"                                name="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE" alias="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"/>
+                <enum extends="VkDescriptorType"                               name="VK_DESCRIPTOR_TYPE_MUTABLE_VALVE" alias="VK_DESCRIPTOR_TYPE_MUTABLE_EXT"/>
+                <enum extends="VkDescriptorPoolCreateFlagBits"                 name="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE" alias="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"/>
+                <enum extends="VkDescriptorSetLayoutCreateFlagBits"            name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"/>
+                <type name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE"/>
+                <type name="VkMutableDescriptorTypeListVALVE"/>
+                <type name="VkMutableDescriptorTypeCreateInfoVALVE"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_vertex_input_dynamic_state" number="353" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc">
+            <require>
+                <enum value="2"                                             name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_vertex_input_dynamic_state&quot;" name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VERTEX_INPUT_EXT"/>
+                <type name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"/>
+                <type name="VkVertexInputBindingDescription2EXT"/>
+                <type name="VkVertexInputAttributeDescription2EXT"/>
+                <command name="vkCmdSetVertexInputEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_physical_device_drm" number="354" author="EXT" type="device" contact="Simon Ser @emersion" supported="vulkan" depends="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_physical_device_drm&quot;"        name="VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME"/>
+
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"/>
+
+                <type name="VkPhysicalDeviceDrmPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_device_address_binding_report" number="355" type="device" depends="VK_KHR_get_physical_device_properties2+VK_EXT_debug_utils" author="EXT" contact="Ralph Potter gitlab:@r_potter" specialuse="debugging,devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_device_address_binding_report&quot;"  name="VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"/>
+                <enum bitpos="3" extends="VkDebugUtilsMessageTypeFlagBitsEXT"   name="VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT"/>
+                <type name="VkPhysicalDeviceAddressBindingReportFeaturesEXT" />
+                <type name="VkDeviceAddressBindingCallbackDataEXT" />
+                <type name="VkDeviceAddressBindingFlagsEXT" />
+                <type name="VkDeviceAddressBindingFlagBitsEXT" />
+                <type name="VkDeviceAddressBindingTypeEXT" />
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_clip_control" number="356" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" specialuse="glemulation">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_clip_control&quot;"         name="VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceDepthClipControlFeaturesEXT"/>
+                <type name="VkPipelineViewportDepthClipControlCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_primitive_topology_list_restart" number="357" type="device" author="EXT" contact="Shahbaz Youssefi @syoussefi" depends="VK_KHR_get_physical_device_properties2" supported="vulkan" specialuse="glemulation">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_primitive_topology_list_restart&quot;"           name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"/>
+                <type name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_358" number="358" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_358_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_358&quot;"              name="VK_KHR_EXTENSION_358_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_359" number="359" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_359_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_359&quot;"              name="VK_EXT_EXTENSION_359_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_360" number="360" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_360_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_360&quot;"              name="VK_EXT_EXTENSION_360_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_format_feature_flags2" number="361" author="KHR" type="device" depends="VK_KHR_get_physical_device_properties2" contact="Lionel Landwerlin @llandwerlin" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_format_feature_flags2&quot;"      name="VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"/>
+                <type                                                       name="VkFormatFeatureFlags2KHR"/>
+                <type                                                       name="VkFormatFeatureFlagBits2KHR"/>
+                <type                                                       name="VkFormatProperties3KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_362" number="362" author="EXT" contact="Lionel Duc @nvlduc" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_362_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_362&quot;"              name="VK_EXT_EXTENSION_362_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_363" number="363" author="EXT" contact="Kaye Mason @chaleur" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_363_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_363&quot;"              name="VK_EXT_EXTENSION_363_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_extension_364" number="364" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_364_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_extension_364&quot;"          name="VK_FUCHSIA_EXTENSION_364_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_external_memory" number="365" type="device" depends="VK_KHR_external_memory_capabilities+VK_KHR_external_memory" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_external_memory&quot;"           name="VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"/>
+                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum bitpos="11" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"/>
+                <type name="VkImportMemoryZirconHandleInfoFUCHSIA"/>
+                <type name="VkMemoryZirconHandlePropertiesFUCHSIA"/>
+                <type name="VkMemoryGetZirconHandleInfoFUCHSIA"/>
+                <command name="vkGetMemoryZirconHandleFUCHSIA"/>
+                <command name="vkGetMemoryZirconHandlePropertiesFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_external_semaphore" number="366" type="device" depends="VK_KHR_external_semaphore_capabilities+VK_KHR_external_semaphore" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_external_semaphore&quot;"        name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum bitpos="7" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"/>
+                <type name="VkImportSemaphoreZirconHandleInfoFUCHSIA"/>
+                <type name="VkSemaphoreGetZirconHandleInfoFUCHSIA"/>
+                <command name="vkImportSemaphoreZirconHandleFUCHSIA"/>
+                <command name="vkGetSemaphoreZirconHandleFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_buffer_collection" number="367" type="device" depends="VK_FUCHSIA_external_memory+VK_KHR_sampler_ycbcr_conversion" author="FUCHSIA" contact="John Rosasco @rosasco" supported="vulkan" platform="fuchsia">
+            <require>
+                <enum value="2"                                         name="VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_buffer_collection&quot;"  name="VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"/>
+                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA" comment="VkBufferCollectionFUCHSIA"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"/>
+                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"/>
+                <type name="VkBufferCollectionFUCHSIA"/>
+                <type name="VkBufferCollectionCreateInfoFUCHSIA"/>
+                <type name="VkImportMemoryBufferCollectionFUCHSIA"/>
+                <type name="VkBufferCollectionImageCreateInfoFUCHSIA"/>
+                <type name="VkBufferConstraintsInfoFUCHSIA"/>
+                <type name="VkBufferCollectionBufferCreateInfoFUCHSIA"/>
+                <type name="VkBufferCollectionPropertiesFUCHSIA"/>
+                <type name="VkImageFormatConstraintsFlagsFUCHSIA" comment="Will add VkImageFormatConstraintsFlagBitsFUCHSIA when bits are defined in the future"/>
+                <type name="VkSysmemColorSpaceFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFlagBitsFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFlagsFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFUCHSIA"/>
+                <type name="VkImageFormatConstraintsInfoFUCHSIA"/>
+                <type name="VkBufferCollectionConstraintsInfoFUCHSIA"/>
+                <command name="vkCreateBufferCollectionFUCHSIA"/>
+                <command name="vkSetBufferCollectionImageConstraintsFUCHSIA"/>
+                <command name="vkSetBufferCollectionBufferConstraintsFUCHSIA"/>
+                <command name="vkDestroyBufferCollectionFUCHSIA"/>
+                <command name="vkGetBufferCollectionPropertiesFUCHSIA"/>
+            </require>
+            <require depends="VK_EXT_debug_report">
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT"   name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_extension_368" number="368" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_368_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_extension_368&quot;"          name="VK_FUCHSIA_EXTENSION_368_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_369" number="369" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_QCOM_EXTENSION_369_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_369&quot;"         name="VK_QCOM_EXTENSION_369_EXTENSION_NAME"/>
+                <enum bitpos="4" extends="VkDescriptorBindingFlagBits"  name="VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_subpass_shading" number="370" type="device" author="HUAWEI" contact="Pan Gao @PanGao-h" depends="VK_KHR_create_renderpass2+VK_KHR_synchronization2" supported="vulkan">
+            <require>
+                <enum value="3"                                         name="VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_subpass_shading&quot;"         name="VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"/>
+                <enum offset="3" extends="VkPipelineBindPoint" extnumber="370" name="VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI"/>
+                <enum bitpos="39" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
+                <enum             extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI" alias="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI" deprecated="aliased"/>
+                <enum bitpos="14" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"/>
+                <type name="VkSubpassShadingPipelineCreateInfoHUAWEI"/>
+                <type name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI"/>
+                <type name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI"/>
+                <command name="vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"/>
+                <command name="vkCmdSubpassShadingHUAWEI"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_invocation_mask" number="371" type="device" depends="VK_KHR_ray_tracing_pipeline+VK_KHR_synchronization2" author="Huawei" contact="Pan Gao @PanGao-h" supported="vulkan">
+            <require>
+                <enum value="1"                                              name="VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_invocation_mask&quot;"        name="VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"/>
+                <enum bitpos="39" extends="VkAccessFlagBits2"                name="VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"/>
+                <enum bitpos="18" extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"/>
+                <enum bitpos="40" extends="VkPipelineStageFlagBits2"         name="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"/>
+                <type name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI"/>
+                <command name="vkCmdBindInvocationMaskHUAWEI"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_rdma" number="372" type="device" depends="VK_KHR_external_memory" author="NV" contact="Carsten Rohde @crohde" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_rdma&quot;"            name="VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"/>
+                <enum bitpos="8" extends="VkMemoryPropertyFlagBits"             name="VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"/>
+                <enum bitpos="12" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"/>
+                <type name="VkRemoteAddressNV"/>
+                <type name="VkMemoryGetRemoteAddressInfoNV"/>
+                <type name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV"/>
+                <command name="vkGetMemoryRemoteAddressNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_properties" number="373" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Mukund Keshava @mkeshavanv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_properties&quot;"        name="VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"/>
+                <type name="VkPipelineInfoEXT"/>
+                <type name="VkPipelinePropertiesIdentifierEXT"/>
+                <type name="VkPhysicalDevicePipelinePropertiesFeaturesEXT"/>
+                <command name="vkGetPipelinePropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_sci_sync" number="374" depends="VK_VERSION_1_1" platform="sci" type="device" author="NV" contact="Kai Zhang @kazhang" supported="vulkansc" deprecatedby="VK_NV_external_sci_sync2">
+            <require>
+                <enum value="2"                                         name="VK_NV_EXTERNAL_SCI_SYNC_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_sci_sync&quot;"       name="VK_NV_EXTERNAL_SCI_SYNC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV"/>
+                <enum bitpos="4" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
+                <enum bitpos="5" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"/>
+                <enum bitpos="5" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
+                <type name="VkSciSyncClientTypeNV"/>
+                <type name="VkSciSyncPrimitiveTypeNV"/>
+                <type name="VkExportFenceSciSyncInfoNV"/>
+                <type name="VkImportFenceSciSyncInfoNV"/>
+                <type name="VkFenceGetSciSyncInfoNV"/>
+                <type name="VkSciSyncAttributesInfoNV"/>
+                <type name="VkExportSemaphoreSciSyncInfoNV"/>
+                <type name="VkImportSemaphoreSciSyncInfoNV"/>
+                <type name="VkSemaphoreGetSciSyncInfoNV"/>
+                <type name="VkPhysicalDeviceExternalSciSyncFeaturesNV"/>
+                <command name="vkGetFenceSciSyncFenceNV"/>
+                <command name="vkGetFenceSciSyncObjNV"/>
+                <command name="vkImportFenceSciSyncFenceNV"/>
+                <command name="vkImportFenceSciSyncObjNV"/>
+                <command name="vkGetPhysicalDeviceSciSyncAttributesNV"/>
+                <command name="vkGetSemaphoreSciSyncObjNV"/>
+                <command name="vkImportSemaphoreSciSyncObjNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_sci_buf" number="375" depends="VK_VERSION_1_1" platform="sci" type="device" author="NV" contact="Kai Zhang @kazhang" supported="vulkansc">
+            <require>
+                <enum value="2"                                         name="VK_NV_EXTERNAL_MEMORY_SCI_BUF_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_sci_buf&quot;" name="VK_NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"/>
+                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"/>
+                <enum bitpos="13" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV"/>
+                <type name="VkExportMemorySciBufInfoNV"/>
+                <type name="VkImportMemorySciBufInfoNV"/>
+                <type name="VkMemoryGetSciBufInfoNV"/>
+                <type name="VkMemorySciBufPropertiesNV"/>
+                <type name="VkPhysicalDeviceExternalMemorySciBufFeaturesNV"/>
+                <type name="VkPhysicalDeviceExternalSciBufFeaturesNV"/>
+                <command name="vkGetMemorySciBufNV"/>
+                <command name="vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV"/>
+                <command name="vkGetPhysicalDeviceSciBufAttributesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_frame_boundary" number="376" type="device" author="EXT" contact="James Fitzpatrick @jamesfitzpatrick" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_FRAME_BOUNDARY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_frame_boundary&quot;"         name="VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"/>
+                <type name="VkPhysicalDeviceFrameBoundaryFeaturesEXT"/>
+                <type name="VkFrameBoundaryEXT"/>
+                <type name="VkFrameBoundaryFlagBitsEXT"/>
+                <type name="VkFrameBoundaryFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_multisampled_render_to_single_sampled" number="377" type="device" depends="VK_KHR_create_renderpass2+VK_KHR_depth_stencil_resolve" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_multisampled_render_to_single_sampled&quot;"   name="VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"/>
+                <enum bitpos="18" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT"/>
+                <type name="VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"/>
+                <type name="VkSubpassResolvePerformanceQueryEXT"/>
+                <type name="VkMultisampledRenderToSingleSampledInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extended_dynamic_state2" number="378" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extended_dynamic_state2&quot;"    name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT" comment="Not promoted to 1.3"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT" comment="Not promoted to 1.3"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT" alias="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"/>
+                <enum offset="3" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LOGIC_OP_EXT" comment="Not promoted to 1.3"/>
+                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT" alias="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"/>
+                <type name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT" comment="Not promoted to 1.3"/>
+                <command name="vkCmdSetPatchControlPointsEXT" comment="Not promoted to 1.3"/>
+                <command name="vkCmdSetRasterizerDiscardEnableEXT"/>
+                <command name="vkCmdSetDepthBiasEnableEXT"/>
+                <command name="vkCmdSetLogicOpEXT" comment="Not promoted to 1.3"/>
+                <command name="vkCmdSetPrimitiveRestartEnableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QNX_screen_surface" number="379" type="instance" depends="VK_KHR_surface" platform="screen" author="QNX" contact="Mike Gorchak @mgorchak-blackberry" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_QNX_SCREEN_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_QNX_screen_surface&quot;"         name="VK_QNX_SCREEN_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"/>
+                <type name="VkScreenSurfaceCreateFlagsQNX"/>
+                <type name="VkScreenSurfaceCreateInfoQNX"/>
+                <command name="vkCreateScreenSurfaceQNX"/>
+                <command name="vkGetPhysicalDeviceScreenPresentationSupportQNX"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_380" number="380" author="KHR" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_380_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_380&quot;"          name="VK_KHR_EXTENSION_380_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_381" number="381" author="KHR" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_381_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_381&quot;"          name="VK_KHR_EXTENSION_381_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_color_write_enable" number="382" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Sharif Elcott @selcott" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                         name="VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_color_write_enable&quot;"     name="VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkDynamicState"               name="VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT"/>
+                <type name="VkPhysicalDeviceColorWriteEnableFeaturesEXT"/>
+                <type name="VkPipelineColorWriteCreateInfoEXT"/>
+                <command name="vkCmdSetColorWriteEnableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_primitives_generated_query" number="383" type="device" depends="VK_EXT_transform_feedback" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" specialuse="glemulation">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_primitives_generated_query&quot;"     name="VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"/>
+                <enum offset="0" extends="VkQueryType"                          name="VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT"/>
+                <type name="VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_384" number="384" type="instance" author="EXT" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_384_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_384&quot;"          name="VK_EXT_EXTENSION_384_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_385" number="385" type="instance" author="MESA" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_MESA_EXTENSION_385_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_385&quot;"         name="VK_MESA_EXTENSION_385_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_386" number="386" author="GOOGLE" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_386_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_386&quot;"       name="VK_GOOGLE_EXTENSION_386_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_tracing_maintenance1" number="387" type="device" depends="VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_tracing_maintenance1&quot;"   name="VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"/>
+                <enum offset="0" extends="VkQueryType"                      name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR"/>
+                <enum offset="1" extends="VkQueryType"                      name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR"/>
+                <type name="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"/>
+            </require>
+            <require depends="VK_KHR_synchronization2">
+                <!-- VkPipelineStageFlagBits bitpos="28" is reserved by this extension, but not used -->
+                <enum bitpos="28" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_synchronization2+VK_KHR_ray_tracing_pipeline">
+                <enum bitpos="40" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_ray_tracing_pipeline">
+                <type name="VkTraceRaysIndirectCommand2KHR"/>
+                <command name="vkCmdTraceRaysIndirect2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_388" number="388" author="EXT" contact="Alan Baker @alan-baker" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_388_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_388&quot;"              name="VK_EXT_EXTENSION_388_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_global_priority_query" number="389" type="device" depends="VK_EXT_global_priority+VK_KHR_get_physical_device_properties2" author="EXT" contact="Yiwei Zhang @zhangyiwei" supported="vulkan" promotedto="VK_KHR_global_priority">
+            <require>
+                <enum value="1"                                         name="VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_global_priority_query&quot;"  name="VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR"/>
+                <enum                                                   name="VK_MAX_GLOBAL_PRIORITY_SIZE_EXT"/>
+                <type                                                   name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"/>
+                <type                                                   name="VkQueueFamilyGlobalPriorityPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_390" number="390" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_390_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_390&quot;"              name="VK_EXT_EXTENSION_390_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_391" number="391" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_391_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_391&quot;"              name="VK_EXT_EXTENSION_391_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_view_min_lod" number="392" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_view_min_lod&quot;"         name="VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"/>
+                <type                                                       name="VkPhysicalDeviceImageViewMinLodFeaturesEXT"/>
+                <type                                                       name="VkImageViewMinLodCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_multi_draw" number="393" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_MULTI_DRAW_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_multi_draw&quot;"             name="VK_EXT_MULTI_DRAW_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceMultiDrawFeaturesEXT"/>
+                <type name="VkPhysicalDeviceMultiDrawPropertiesEXT"/>
+                <command name="vkCmdDrawMultiEXT"/>
+                <command name="vkCmdDrawMultiIndexedEXT"/>
+                <type name="VkMultiDrawInfoEXT"/>
+                <type name="VkMultiDrawIndexedInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_2d_view_of_3d" number="394" depends="VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2" author="EXT" contact="Mike Blumenkrantz @zmike" specialuse="glemulation" type="device" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_2d_view_of_3d&quot;"              name="VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"/>
+                <enum extends="VkImageCreateFlagBits" bitpos="17"  name="VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT" comment="Image is created with a layout where individual slices are capable of being used as 2D images"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_portability_enumeration" number="395" author="KHR" contact="Charles Giessen @charles-lunarg" type="instance" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_portability_enumeration&quot;"    name="VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME"/>
+                <enum bitpos="0" extends="VkInstanceCreateFlagBits"         name="VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_tile_image" number="396" type="device" author="EXT" depends="VK_VERSION_1_3" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_tile_image&quot;"          name="VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceShaderTileImageFeaturesEXT"/>
+                <type name="VkPhysicalDeviceShaderTileImagePropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_opacity_micromap" number="397" type="device"  depends="VK_KHR_acceleration_structure+VK_KHR_synchronization2" author="EXT" contact="Christoph Kubisch @pixeljetstream, Eric Werness" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_OPACITY_MICROMAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_opacity_micromap&quot;"           name="VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"/>
+                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"/>
+                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"/>
+                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"/>
+                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"/>
+                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"/>
+                <enum offset="8"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"/>
+                <enum offset="9"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"/>
+                <enum bitpos="30" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
+                <enum bitpos="44" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MICROMAP_READ_BIT_EXT"/>
+                <enum bitpos="45" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT"/>
+                <enum offset="0"  extends="VkQueryType"                     name="VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT"/>
+                <enum offset="1"  extends="VkQueryType"                     name="VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT"/>
+                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_MICROMAP_EXT"/>
+                <enum bitpos="23" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"/>
+                <enum bitpos="24" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT"/>
+                <enum bitpos="24" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"/>
+                <enum bitpos="4"  extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT"/>
+                <enum bitpos="5"  extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT"/>
+                <enum bitpos="6"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT"/>
+                <enum bitpos="7"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT"/>
+                <enum bitpos="8"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT"/>
+                <type name="VkMicromapTypeEXT"/>
+                <type name="VkMicromapBuildInfoEXT"/>
+                <type name="VkMicromapUsageEXT"/>
+                <type name="VkMicromapCreateInfoEXT"/>
+                <type name="VkMicromapEXT"/>
+                <type name="VkBuildMicromapFlagBitsEXT"/>
+                <type name="VkBuildMicromapFlagsEXT"/>
+                <type name="VkCopyMicromapModeEXT"/>
+                <type name="VkPhysicalDeviceOpacityMicromapFeaturesEXT"/>
+                <type name="VkPhysicalDeviceOpacityMicromapPropertiesEXT"/>
+                <type name="VkMicromapVersionInfoEXT"/>
+                <type name="VkCopyMicromapToMemoryInfoEXT"/>
+                <type name="VkCopyMemoryToMicromapInfoEXT"/>
+                <type name="VkCopyMicromapInfoEXT"/>
+                <type name="VkMicromapCreateFlagBitsEXT"/>
+                <type name="VkMicromapCreateFlagsEXT"/>
+                <type name="VkBuildMicromapModeEXT"/>
+                <type name="VkMicromapBuildSizesInfoEXT"/>
+                <type name="VkOpacityMicromapFormatEXT"/>
+                <type name="VkAccelerationStructureTrianglesOpacityMicromapEXT"/>
+                <type name="VkMicromapTriangleEXT"/>
+                <type name="VkOpacityMicromapSpecialIndexEXT"/>
+                <command name="vkCreateMicromapEXT"/>
+                <command name="vkDestroyMicromapEXT"/>
+                <command name="vkCmdBuildMicromapsEXT"/>
+                <command name="vkBuildMicromapsEXT"/>
+                <command name="vkCopyMicromapEXT"/>
+                <command name="vkCopyMicromapToMemoryEXT"/>
+                <command name="vkCopyMemoryToMicromapEXT"/>
+                <command name="vkWriteMicromapsPropertiesEXT"/>
+                <command name="vkCmdCopyMicromapEXT"/>
+                <command name="vkCmdCopyMicromapToMemoryEXT"/>
+                <command name="vkCmdCopyMemoryToMicromapEXT"/>
+                <command name="vkCmdWriteMicromapsPropertiesEXT"/>
+                <command name="vkGetDeviceMicromapCompatibilityEXT"/>
+                <command name="vkGetMicromapBuildSizesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_displacement_micromap" number="398" type="device" depends="VK_EXT_opacity_micromap" author="NV" contact="Christoph Kubisch @pixeljetstream, Eric Werness @ewerness-nv" supported="vulkan" provisional="true" platform="provisional">
+            <require>
+                <enum value="2"                                        name="VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_displacement_micromap&quot;"  name="VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="28" extends="VkPipelineCreateFlagBits"   name="VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="9"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0"  extends="VkMicromapTypeEXT"          name="VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <type name="VkPhysicalDeviceDisplacementMicromapFeaturesNV"/>
+                <type name="VkPhysicalDeviceDisplacementMicromapPropertiesNV"/>
+                <type name="VkAccelerationStructureTrianglesDisplacementMicromapNV"/>
+                <type name="VkDisplacementMicromapFormatNV"/>
+            </require>
+        </extension>
+        <extension name="VK_JUICE_extension_399" number="399" author="JUICE" contact="Dean Beeler @canadacow" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_JUICE_EXTENSION_399_SPEC_VERSION"/>
+                <enum value="&quot;VK_JUICE_extension_399&quot;"        name="VK_JUICE_EXTENSION_399_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_JUICE_extension_400" number="400" author="JUICE" contact="David McCloskey @damcclos" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_JUICE_EXTENSION_400_SPEC_VERSION"/>
+                <enum value="&quot;VK_JUICE_extension_400&quot;"        name="VK_JUICE_EXTENSION_400_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_load_store_op_none" number="401" author="EXT" type="device" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_load_store_op_none&quot;"          name="VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkAttachmentLoadOp" name="VK_ATTACHMENT_LOAD_OP_NONE_EXT"/>
+                <enum extends="VkAttachmentStoreOp" name="VK_ATTACHMENT_STORE_OP_NONE_EXT" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_402" number="402" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_402_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_402&quot;"           name="VK_FB_EXTENSION_402_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_403" number="403" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_403_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_403&quot;"           name="VK_FB_EXTENSION_403_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_404" number="404" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_404_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_404&quot;"           name="VK_FB_EXTENSION_404_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_cluster_culling_shader" number="405" type="device" depends="VK_KHR_get_physical_device_properties2" author="HUAWEI" contact="Yuchang Wang @richard_Wang2" supported="vulkan">
+            <require>
+                <enum value="2"                                              name="VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_cluster_culling_shader&quot;"   name="VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"/>
+                <enum bitpos="41" extends="VkPipelineStageFlagBits2"         name="VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+                <enum bitpos="19" extends="VkShaderStageFlagBits"            name="VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI"/>
+                <enum bitpos="13" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI"/>
+                <command name="vkCmdDrawClusterHUAWEI"/>
+                <command name="vkCmdDrawClusterIndirectHUAWEI"/>
+                <type name="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI"/>
+                <type name="VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_extension_406" number="406" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_406_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_extension_406&quot;"           name="VK_HUAWEI_EXTENSION_406_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_407" number="407" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_407_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_407&quot;"          name="VK_GGP_EXTENSION_407_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_408" number="408" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_408_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_408&quot;"          name="VK_GGP_EXTENSION_408_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_409" number="409" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_409_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_409&quot;"          name="VK_GGP_EXTENSION_409_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_410" number="410" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_410_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_410&quot;"          name="VK_GGP_EXTENSION_410_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_411" number="411" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_411_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_411&quot;"          name="VK_GGP_EXTENSION_411_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_border_color_swizzle" number="412" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" depends="VK_EXT_custom_border_color" specialuse="glemulation,d3demulation">
+            <require>
+                <enum value="1"                                         name="VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_border_color_swizzle&quot;"   name="VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT"/>
+                <type name="VkSamplerBorderColorComponentMappingCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pageable_device_local_memory" number="413" author="EXT" contact="Piers Daniell @pdaniell-nv" type="device" depends="VK_EXT_memory_priority" supported="vulkan">
+            <require>
+                <enum value="1"                                                  name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pageable_device_local_memory&quot;"    name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"/>
+                <type                                                            name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"/>
+                <command                                                         name="vkSetDeviceMemoryPriorityEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance4" number="414" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_KHR_MAINTENANCE_4_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance4&quot;"               name="VK_KHR_MAINTENANCE_4_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_NONE_KHR" alias="VK_IMAGE_ASPECT_NONE"/>
+                <type name="VkPhysicalDeviceMaintenance4FeaturesKHR"/>
+                <type name="VkPhysicalDeviceMaintenance4PropertiesKHR"/>
+                <type name="VkDeviceBufferMemoryRequirementsKHR"/>
+                <type name="VkDeviceImageMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceBufferMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceImageMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceImageSparseMemoryRequirementsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_extension_415" number="415" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_415_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_extension_415&quot;"         name="VK_HUAWEI_EXTENSION_415_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_shader_core_properties" number="416" type="device" depends="VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_shader_core_properties&quot;" name="VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"/>
+                <type name="VkPhysicalDeviceShaderCorePropertiesARM"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_417" number="417" author="KHR" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_417_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_417&quot;"          name="VK_KHR_EXTENSION_417_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_scheduling_controls" number="418" author="ARM" contact="Kevin Petit @kpet" type="device" depends="VK_ARM_shader_core_builtins" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_scheduling_controls&quot;"    name="VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType" offset="0"              name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"/>
+                <enum extends="VkStructureType" offset="1"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"/>
+                <enum extends="VkStructureType" offset="2"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"/>
+                <type name="VkDeviceQueueShaderCoreControlCreateInfoARM"/>
+                <type name="VkPhysicalDeviceSchedulingControlsFeaturesARM"/>
+                <type name="VkPhysicalDeviceSchedulingControlsPropertiesARM"/>
+                <type name="VkPhysicalDeviceSchedulingControlsFlagsARM"/>
+                <type name="VkPhysicalDeviceSchedulingControlsFlagBitsARM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_sliced_view_of_3d" number="419" depends="VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2" author="EXT" contact="Mike Blumenkrantz @zmike" specialuse="d3demulation" type="device" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_sliced_view_of_3d&quot;"    name="VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"/>
+                <enum name="VK_REMAINING_3D_SLICES_EXT"/>
+                <type name="VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT"/>
+                <type name="VkImageViewSlicedCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_420" number="420" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_420_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_420&quot;"              name="VK_EXT_EXTENSION_420_EXTENSION_NAME"/>
+                <enum bitpos="4" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_VALVE_descriptor_set_host_mapping" number="421" type="device" author="VALVE" contact="Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION"/>
+                <enum value="&quot;VK_VALVE_descriptor_set_host_mapping&quot;"  name="VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"/>
+                <enum offset="1"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"/>
+                <enum offset="2"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"/>
+                <type name="VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE"/>
+                <type name="VkDescriptorSetBindingReferenceVALVE"/>
+                <type name="VkDescriptorSetLayoutHostMappingInfoVALVE"/>
+                <command name="vkGetDescriptorSetLayoutHostMappingInfoVALVE"/>
+                <command name="vkGetDescriptorSetHostMappingVALVE"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_clamp_zero_one" number="422" author="EXT" type="device" contact="Graeme Leese @gnl21" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_clamp_zero_one&quot;"       name="VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceDepthClampZeroOneFeaturesEXT" />
+            </require>
+        </extension>
+        <extension name="VK_EXT_non_seamless_cube_map" number="423" author="EXT" type="device" contact="Georg Lehmann @DadSchoorse" specialuse="d3demulation,glemulation" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_non_seamless_cube_map&quot;"      name="VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME"/>
+                <enum bitpos="2" extends="VkSamplerCreateFlagBits"          name="VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_424" number="424" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_424_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_424&quot;"          name="VK_ARM_EXTENSION_424_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_425" number="425" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_425_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_425&quot;"          name="VK_ARM_EXTENSION_425_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_fragment_density_map_offset" number="426" type="device" depends="VK_KHR_get_physical_device_properties2+VK_EXT_fragment_density_map" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
+            <require>
+                <enum value="1"                                               name="VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_fragment_density_map_offset&quot;" name="VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"/>
+                <enum offset="1"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"/>
+                <enum offset="2"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM"/>
+                <enum bitpos="15" extends="VkImageCreateFlagBits"             name="VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM"/>
+                <type name="VkSubpassFragmentDensityMapOffsetEndInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_copy_memory_indirect" number="427" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_copy_memory_indirect&quot;"    name="VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV"/>
+                <type name="VkCopyMemoryIndirectCommandNV"/>
+                <type name="VkCopyMemoryToImageIndirectCommandNV"/>
+                <type name="VkPhysicalDeviceCopyMemoryIndirectFeaturesNV"/>
+                <type name="VkPhysicalDeviceCopyMemoryIndirectPropertiesNV"/>
+                <command name="vkCmdCopyMemoryIndirectNV"/>
+                <command name="vkCmdCopyMemoryToImageIndirectNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_memory_decompression" number="428" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_memory_decompression&quot;"       name="VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV"/>
+                <type name="VkMemoryDecompressionMethodFlagBitsNV"/>
+                <type name="VkMemoryDecompressionMethodFlagsNV"/>
+                <type name="VkDecompressMemoryRegionNV"/>
+                <type name="VkPhysicalDeviceMemoryDecompressionFeaturesNV"/>
+                <type name="VkPhysicalDeviceMemoryDecompressionPropertiesNV"/>
+                <command name="vkCmdDecompressMemoryNV"/>
+                <command name="vkCmdDecompressMemoryIndirectCountNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_generated_commands_compute" number="429" type="device" depends="VK_NV_device_generated_commands" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
+            <require>
+                <enum value="2"                                           name="VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_generated_commands_compute&quot;"  name="VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"/>
+                <enum offset="3" extends="VkIndirectCommandsTokenTypeNV"  name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV"/>
+                <enum offset="4" extends="VkIndirectCommandsTokenTypeNV"  name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV"/>
+                <enum bitpos="7" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV"/>
+                <type name="VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV"/>
+                <type name="VkComputePipelineIndirectBufferInfoNV"/>
+                <type name="VkPipelineIndirectDeviceAddressInfoNV"/>
+                <type name="VkBindPipelineIndirectCommandNV"/>
+                <command name="vkGetPipelineIndirectMemoryRequirementsNV"/>
+                <command name="vkCmdUpdatePipelineIndirectBufferNV"/>
+                <command name="vkGetPipelineIndirectDeviceAddressNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_430" number="430" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_430_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_430&quot;"           name="VK_NV_EXTENSION_430_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_linear_color_attachment" number="431" type="device" author="NVIDIA" contact="sourav parmar @souravpNV" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_linear_color_attachment&quot;" name="VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"/>
+                <type                                                   name="VkPhysicalDeviceLinearColorAttachmentFeaturesNV"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="38" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV" comment="Format support linear image as render target, it cannot be mixed with non linear attachment"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_432" number="432" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_432_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_432&quot;"           name="VK_NV_EXTENSION_432_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_433" number="433" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_433_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_433&quot;"           name="VK_NV_EXTENSION_433_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_surfaceless_query" number="434" type="instance" depends="VK_KHR_surface" author="GOOGLE" contact="Shahbaz Youssefi @syoussefi" specialuse="glemulation" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_surfaceless_query&quot;"   name="VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_435" number="435" author="KHR" contact="Alan Baker @alan-baker" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_435_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_435&quot;"          name="VK_KHR_EXTENSION_435_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_application_parameters" number="436" type="instance" author="EXT" contact="Daniel Koch @dgkoch" supported="vulkansc">
+            <require>
+                <enum value="1"                                         name="VK_EXT_APPLICATION_PARAMETERS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_application_parameters&quot;" name="VK_EXT_APPLICATION_PARAMETERS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT"/>
+                <type name="VkApplicationParametersEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_437" number="437" author="EXT" contact="Jonathan Weinstein @Jonathan-Weinstein" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_437_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_437&quot;"          name="VK_EXT_EXTENSION_437_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_compression_control_swapchain" number="438" type="device" depends="VK_EXT_image_compression_control" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_compression_control_swapchain&quot;"  name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_extension_439" number="439" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_SEC_EXTENSION_439_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_extension_439&quot;"          name="VK_SEC_EXTENSION_439_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_440" number="440" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_QCOM_EXTENSION_440_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_440&quot;"         name="VK_QCOM_EXTENSION_440_EXTENSION_NAME"/>
+                <enum bitpos="7" extends="VkQueueFlagBits"              name="VK_QUEUE_RESERVED_7_BIT_QCOM"/>
+                <enum bitpos="1" extends="VkDeviceQueueCreateFlagBits"  name="VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_image_processing" number="441" type="device" depends="VK_KHR_format_feature_flags2" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_image_processing&quot;"      name="VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"/>
+                <enum bitpos="4" extends="VkSamplerCreateFlagBits"      name="VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM"/>
+                <enum bitpos="20" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM"/>
+                <enum bitpos="21" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM"/>
+                <enum offset="0" extends="VkDescriptorType"             name="VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM"/>
+                <enum offset="1" extends="VkDescriptorType"             name="VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM"/>
+                <type name="VkImageViewSampleWeightCreateInfoQCOM"/>
+                <type name="VkPhysicalDeviceImageProcessingFeaturesQCOM"/>
+                <type name="VkPhysicalDeviceImageProcessingPropertiesQCOM"/>
+            </require>
+            <require depends="VK_KHR_format_feature_flags2">
+                <enum bitpos="34" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM"/>
+                <enum bitpos="35" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM"/>
+                <enum bitpos="36" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM"/>
+                <enum bitpos="37" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_442" number="442" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_442_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_442&quot;"          name="VK_COREAVI_EXTENSION_442_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_443" number="443" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_443_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_443&quot;"          name="VK_COREAVI_EXTENSION_443_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_444" number="444" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_444_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_444&quot;"          name="VK_COREAVI_EXTENSION_444_EXTENSION_NAME"/>
+                <enum extends="VkCommandPoolResetFlagBits" bitpos="1"       name="VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_445" number="445" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_445_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_445&quot;"          name="VK_COREAVI_EXTENSION_445_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_446" number="446" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_446_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_446&quot;"          name="VK_COREAVI_EXTENSION_446_EXTENSION_NAME"/>
+                <enum bitpos="24" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI"/>
+            </require>
+        </extension>
+        <extension name="VK_COREAVI_extension_447" number="447" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_COREAVI_EXTENSION_447_SPEC_VERSION"/>
+                <enum value="&quot;VK_COREAVI_extension_447&quot;"          name="VK_COREAVI_EXTENSION_447_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_extension_448" number="448" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_SEC_EXTENSION_448_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_extension_448&quot;"          name="VK_SEC_EXTENSION_448_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_extension_449" number="449" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_SEC_EXTENSION_449_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_extension_449&quot;"          name="VK_SEC_EXTENSION_449_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_extension_450" number="450" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_SEC_EXTENSION_450_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_extension_450&quot;"          name="VK_SEC_EXTENSION_450_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_extension_451" number="451" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_SEC_EXTENSION_451_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_extension_451&quot;"          name="VK_SEC_EXTENSION_451_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_nested_command_buffer" number="452" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_nested_command_buffer&quot;"  name="VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkSubpassContents"            name="VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT"/>
+                <enum bitpos="4" extends="VkRenderingFlagBits"          name="VK_RENDERING_CONTENTS_INLINE_BIT_EXT"/>
+                <type                                                   name="VkPhysicalDeviceNestedCommandBufferFeaturesEXT"/>
+                <type                                                   name="VkPhysicalDeviceNestedCommandBufferPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_453" number="453" author="Arm" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_453_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_453&quot;"          name="VK_ARM_EXTENSION_453_EXTENSION_NAME"/>
+                <enum bitpos="11" extends="VkQueueFlagBits"             name="VK_QUEUE_RESERVED_11_BIT_ARM"/>
+                <enum bitpos="43" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM"/>
+                <enum bitpos="49" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_RESERVED_49_BIT_ARM"/>
+                <enum bitpos="50" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_RESERVED_50_BIT_ARM"/>
+                <enum bitpos="47" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM" />
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_acquire_unmodified" number="454" type="device" depends="VK_KHR_external_memory" author="EXT" contact="Lina Versace @versalinyaa" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                         name="VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_acquire_unmodified&quot;"     name="VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"/>
+                <type name="VkExternalMemoryAcquireUnmodifiedEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_455" number="455" author="GOOGLE" contact="Lina Versace @versalinyaa" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_455_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_455&quot;"       name="VK_GOOGLE_EXTENSION_455_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extended_dynamic_state3" number="456" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="2"                                              name="VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extended_dynamic_state3&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"/>
+                <enum offset="3" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT"/>
+                <enum offset="4" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_POLYGON_MODE_EXT"/>
+                <enum offset="5" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT"/>
+                <enum offset="6" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_SAMPLE_MASK_EXT"/>
+                <enum offset="7" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT"/>
+                <enum offset="8" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT"/>
+                <enum offset="9" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT"/>
+                <enum offset="10" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT"/>
+                <enum offset="11" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT"/>
+                <enum offset="12" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT"/>
+                <type name="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT"/>
+                <type name="VkPhysicalDeviceExtendedDynamicState3PropertiesEXT"/>
+                <type name="VkColorBlendEquationEXT"/>
+                <type name="VkColorBlendAdvancedEXT"/>
+                <command name="vkCmdSetDepthClampEnableEXT"/>
+                <command name="vkCmdSetPolygonModeEXT"/>
+                <command name="vkCmdSetRasterizationSamplesEXT"/>
+                <command name="vkCmdSetSampleMaskEXT"/>
+                <command name="vkCmdSetAlphaToCoverageEnableEXT"/>
+                <command name="vkCmdSetAlphaToOneEnableEXT"/>
+                <command name="vkCmdSetLogicOpEnableEXT"/>
+                <command name="vkCmdSetColorBlendEnableEXT"/>
+                <command name="vkCmdSetColorBlendEquationEXT"/>
+                <command name="vkCmdSetColorWriteMaskEXT"/>
+            </require>
+            <require depends="VK_KHR_maintenance2,VK_VERSION_1_1">
+                <enum offset="2" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT"/>
+                <command name="vkCmdSetTessellationDomainOriginEXT"/>
+            </require>
+            <require depends="VK_EXT_transform_feedback">
+                <enum offset="13" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT"/>
+                <command name="vkCmdSetRasterizationStreamEXT"/>
+            </require>
+            <require depends="VK_EXT_conservative_rasterization">
+                <enum offset="14" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT"/>
+                <enum offset="15" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT"/>
+                <command name="vkCmdSetConservativeRasterizationModeEXT"/>
+                <command name="vkCmdSetExtraPrimitiveOverestimationSizeEXT"/>
+            </require>
+            <require depends="VK_EXT_depth_clip_enable">
+                <enum offset="16" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT"/>
+                <command name="vkCmdSetDepthClipEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_sample_locations">
+                <enum offset="17" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT"/>
+                <command name="vkCmdSetSampleLocationsEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_blend_operation_advanced">
+                <enum offset="18" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT"/>
+                <command name="vkCmdSetColorBlendAdvancedEXT"/>
+            </require>
+            <require depends="VK_EXT_provoking_vertex">
+                <enum offset="19" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT"/>
+                <command name="vkCmdSetProvokingVertexModeEXT"/>
+            </require>
+            <require depends="VK_EXT_line_rasterization">
+                <enum offset="20" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT"/>
+                <enum offset="21" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT"/>
+                <command name="vkCmdSetLineRasterizationModeEXT"/>
+                <command name="vkCmdSetLineStippleEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_depth_clip_control">
+                <enum offset="22" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT"/>
+                <command name="vkCmdSetDepthClipNegativeOneToOneEXT"/>
+            </require>
+            <require depends="VK_NV_clip_space_w_scaling">
+                <enum offset="23" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV"/>
+                <command name="vkCmdSetViewportWScalingEnableNV"/>
+            </require>
+            <require depends="VK_NV_viewport_swizzle">
+                <enum offset="24" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV"/>
+                <command name="vkCmdSetViewportSwizzleNV"/>
+            </require>
+            <require depends="VK_NV_fragment_coverage_to_color">
+                <enum offset="25" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV"/>
+                <enum offset="26" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV"/>
+                <command name="vkCmdSetCoverageToColorEnableNV"/>
+                <command name="vkCmdSetCoverageToColorLocationNV"/>
+            </require>
+            <require depends="VK_NV_framebuffer_mixed_samples">
+                <enum offset="27" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV"/>
+                <enum offset="28" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV"/>
+                <enum offset="29" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV"/>
+                <command name="vkCmdSetCoverageModulationModeNV"/>
+                <command name="vkCmdSetCoverageModulationTableEnableNV"/>
+                <command name="vkCmdSetCoverageModulationTableNV"/>
+            </require>
+            <require depends="VK_NV_shading_rate_image">
+                <enum offset="30" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV"/>
+                <command name="vkCmdSetShadingRateImageEnableNV"/>
+            </require>
+            <require depends="VK_NV_representative_fragment_test">
+                <enum offset="31" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV"/>
+                <command name="vkCmdSetRepresentativeFragmentTestEnableNV"/>
+            </require>
+            <require depends="VK_NV_coverage_reduction_mode">
+                <enum offset="32" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV"/>
+                <command name="vkCmdSetCoverageReductionModeNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_457" number="457" author="RASTERGRID" contact="Daniel Rakos @aqnuep" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_457_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_457&quot;"          name="VK_EXT_EXTENSION_457_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_458" number="458" author="RASTERGRID" contact="Daniel Rakos @aqnuep" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_458_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_458&quot;"          name="VK_EXT_EXTENSION_458_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_subpass_merge_feedback" number="459" type="device" author="EXT" contact="Ting Wei @catweiting" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="2"                                              name="VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_subpass_merge_feedback&quot;"      name="VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"/>
+                <type name="VkRenderPassCreationControlEXT"/>
+                <type name="VkRenderPassCreationFeedbackInfoEXT"/>
+                <type name="VkRenderPassCreationFeedbackCreateInfoEXT"/>
+                <type name="VkRenderPassSubpassFeedbackInfoEXT"/>
+                <type name="VkRenderPassSubpassFeedbackCreateInfoEXT"/>
+                <type name="VkSubpassMergeStatusEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_LUNARG_direct_driver_loading" number="460" type="instance" author="LUNARG" contact="Charles Giessen @charles-lunarg" supported="vulkan">
+            <require>
+                <enum value="1"                                           name="VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION"/>
+                <enum value="&quot;VK_LUNARG_direct_driver_loading&quot;" name="VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"/>
+                <enum offset="1" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"/>
+                <type name="VkDirectDriverLoadingFlagsLUNARG" comment="Will add VkDirectDriverLoadingFlagBitsLUNARG when bits are defined in the future"/>
+                <type name="VkDirectDriverLoadingModeLUNARG"/>
+                <type name="VkDirectDriverLoadingInfoLUNARG"/>
+                <type name="VkDirectDriverLoadingListLUNARG"/>
+                <type name="PFN_vkGetInstanceProcAddrLUNARG"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_461" number="461" author="EXT" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_461_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_461&quot;"          name="VK_EXT_EXTENSION_461_EXTENSION_NAME"/>
+                <enum bitpos="39" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_RESERVED_39_BIT_EXT"/>
+                <enum bitpos="23" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_23_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_462" number="462" author="EXT" contact="Joshua Ashton @Joshua-Ashton,Liam Middlebrook @liam-middlebrook" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_462_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_462&quot;"          name="VK_EXT_EXTENSION_462_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_module_identifier" number="463" type="device" depends="VK_KHR_get_physical_device_properties2+VK_EXT_pipeline_creation_cache_control" author="EXT" contact="Hans-Kristian Arntzen @HansKristian-Work" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_module_identifier&quot;"   name="VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"/>
+                <enum name="VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT"/>
+                <type name="VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"/>
+                <type name="VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT"/>
+                <type name="VkPipelineShaderStageModuleIdentifierCreateInfoEXT"/>
+                <type name="VkShaderModuleIdentifierEXT"/>
+                <command name="vkGetShaderModuleIdentifierEXT"/>
+                <command name="vkGetShaderModuleCreateInfoIdentifierEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_rasterization_order_attachment_access" number="464" type="device" depends="VK_KHR_get_physical_device_properties2" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
+            <require>
+                <enum value="1"                                                        name="VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_rasterization_order_attachment_access&quot;" name="VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" extnumber="343" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"/>
+                <type name="VkPipelineColorBlendStateCreateFlagBits"/>
+                <type name="VkPipelineDepthStencilStateCreateFlagBits"/>
+                <enum bitpos="0" extends="VkPipelineColorBlendStateCreateFlagBits"   name="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"/>
+                <enum bitpos="0" extends="VkPipelineDepthStencilStateCreateFlagBits" name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
+                <enum bitpos="1" extends="VkPipelineDepthStencilStateCreateFlagBits" name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
+                <enum bitpos="4" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"/>
+                <enum bitpos="5" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
+                <enum bitpos="6" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_optical_flow" number="465" depends="VK_KHR_get_physical_device_properties2+VK_KHR_format_feature_flags2+VK_KHR_synchronization2" type="device" author="NV" contact="Carsten Rohde @crohde" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_OPTICAL_FLOW_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_optical_flow&quot;"                name="VK_NV_OPTICAL_FLOW_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"/>
+                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"/>
+                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"/>
+                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"/>
+                <enum offset="10"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"/><comment>NV internal use only</comment>
+                <enum offset="0"  extends="VkFormat"                        name="VK_FORMAT_R16G16_S10_5_NV"/>
+                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"/>
+                <enum bitpos="8"  extends="VkQueueFlagBits"                 name="VK_QUEUE_OPTICAL_FLOW_BIT_NV"/>
+                <enum bitpos="29" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
+                <enum bitpos="42" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV"/>
+                <enum bitpos="43" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV"/>
+                <enum bitpos="40" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV"/>
+                <enum bitpos="41" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV"/>
+                <enum bitpos="42" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV"/>
+                <type name="VkPhysicalDeviceOpticalFlowFeaturesNV"/>
+                <type name="VkPhysicalDeviceOpticalFlowPropertiesNV"/>
+                <type name="VkOpticalFlowUsageFlagBitsNV"/>
+                <type name="VkOpticalFlowUsageFlagsNV"/>
+                <type name="VkOpticalFlowImageFormatInfoNV"/>
+                <type name="VkOpticalFlowImageFormatPropertiesNV"/>
+                <type name="VkOpticalFlowGridSizeFlagBitsNV"/>
+                <type name="VkOpticalFlowGridSizeFlagsNV"/>
+                <type name="VkOpticalFlowPerformanceLevelNV"/>
+                <type name="VkOpticalFlowSessionBindingPointNV"/>
+                <type name="VkOpticalFlowSessionCreateFlagBitsNV"/>
+                <type name="VkOpticalFlowSessionCreateFlagsNV"/>
+                <type name="VkOpticalFlowExecuteFlagBitsNV"/>
+                <type name="VkOpticalFlowExecuteFlagsNV"/>
+                <type name="VkOpticalFlowSessionNV"/>
+                <type name="VkOpticalFlowSessionCreateInfoNV"/>
+                <type name="VkOpticalFlowSessionCreatePrivateDataInfoNV"/><comment>NV internal use only</comment>
+                <type name="VkOpticalFlowExecuteInfoNV"/>
+                <command name="vkGetPhysicalDeviceOpticalFlowImageFormatsNV"/>
+                <command name="vkCreateOpticalFlowSessionNV"/>
+                <command name="vkDestroyOpticalFlowSessionNV"/>
+                <command name="vkBindOpticalFlowSessionImageNV"/>
+                <command name="vkCmdOpticalFlowExecuteNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_legacy_dithering" number="466" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" specialuse="glemulation">
+            <require>
+                <enum value="1"                                         name="VK_EXT_LEGACY_DITHERING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_legacy_dithering&quot;"       name="VK_EXT_LEGACY_DITHERING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"/>
+                <enum bitpos="7" extends="VkSubpassDescriptionFlagBits" name="VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
+                <type name="VkPhysicalDeviceLegacyDitheringFeaturesEXT"/>
+            </require>
+            <require depends="VK_VERSION_1_3">
+                <enum bitpos="3" extends="VkRenderingFlagBits"          name="VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_dynamic_rendering">
+                <enum bitpos="3" extends="VkRenderingFlagBits"          name="VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_protected_access" number="467" type="device" depends="VK_KHR_get_physical_device_properties2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_protected_access&quot;"  name="VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT"/>
+                <enum bitpos="27" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT"/>
+                <enum bitpos="30" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT"/>
+                <type name="VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_468" number="468" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_468_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_468&quot;"          name="VK_EXT_EXTENSION_468_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ANDROID_external_format_resolve" number="469" type="device" depends="VK_ANDROID_external_memory_android_hardware_buffer" platform="android" author="ANDROID" contact="Chris Forbes @chrisforbes" specialuse="glemulation" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_ANDROID_external_format_resolve&quot;"  name="VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"/>
+                <type name="VkPhysicalDeviceExternalFormatResolveFeaturesANDROID"/>
+                <type name="VkPhysicalDeviceExternalFormatResolvePropertiesANDROID"/>
+                <type name="VkAndroidHardwareBufferFormatResolvePropertiesANDROID"/>
+            </require>
+            <require depends="VK_KHR_dynamic_rendering">
+                <enum bitpos="4" extends="VkResolveModeFlagBits"            name="VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_470" number="470" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_470_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_470&quot;"          name="VK_AMD_EXTENSION_470_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance5" number="471" type="device" depends="VK_VERSION_1_1+VK_KHR_dynamic_rendering" author="KHR" contact="Stu Smith @stu-s" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_MAINTENANCE_5_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance5&quot;"           name="VK_KHR_MAINTENANCE_5_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR"/>
+                <type name="VkPhysicalDeviceMaintenance5FeaturesKHR"/>
+                <type name="VkPhysicalDeviceMaintenance5PropertiesKHR"/>
+                <enum offset="0" extends="VkFormat"                     name="VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR"/>
+                <enum offset="1" extends="VkFormat"                     name="VK_FORMAT_A8_UNORM_KHR"/>
+                <command name="vkCmdBindIndexBuffer2KHR"/>
+                <command name="vkGetRenderingAreaGranularityKHR"/>
+                <type name="VkRenderingAreaInfoKHR"/>
+                <command name="vkGetDeviceImageSubresourceLayoutKHR"/>
+                <command name="vkGetImageSubresourceLayout2KHR"/>
+                <type name="VkDeviceImageSubresourceInfoKHR"/>
+                <type name="VkImageSubresource2KHR"/>
+                <type name="VkSubresourceLayout2KHR"/>
+                <enum offset="2" extends="VkStructureType" extnumber="339" name="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR"/>
+                <enum offset="3" extends="VkStructureType" extnumber="339" name="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR"/>
+            </require>
+            <require comment="Split off new 64-bit flags separately, for the moment">
+                <type name="VkPipelineCreateFlags2KHR"/>
+                <type name="VkPipelineCreateFlagBits2KHR"/>
+                <type name="VkPipelineCreateFlags2CreateInfoKHR"/>
+                <type name="VkBufferUsageFlags2KHR"/>
+                <type name="VkBufferUsageFlagBits2KHR"/>
+                <type name="VkBufferUsageFlags2CreateInfoKHR"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR"/>
+            </require>
+            <require depends="VK_VERSION_1_1,VK_KHR_device_group">
+                <enum bitpos="3"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR"/>
+                <enum bitpos="4"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR"/>
+            </require>
+            <require depends="VK_NV_ray_tracing">
+                <enum bitpos="5"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV"/>
+            </require>
+            <require depends="VK_KHR_pipeline_executable_properties">
+                <enum bitpos="6"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR"/>
+                <enum bitpos="7"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"/>
+            </require>
+            <require depends="VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control">
+                <enum bitpos="8"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR"/>
+                <enum bitpos="9"  extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR"/>
+            </require>
+            <require depends="VK_EXT_graphics_pipeline_library">
+                <enum bitpos="10" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT"/>
+                <enum bitpos="23" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_pipeline_library">
+                <enum bitpos="11" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_ray_tracing_pipeline">
+                <enum bitpos="12" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
+                <enum bitpos="13" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR"/>
+                <enum bitpos="14" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="15" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="16" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"/>
+                <enum bitpos="17" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"/>
+                <enum bitpos="19" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"/>
+            </require>
+            <require depends="VK_NV_device_generated_commands">
+                <enum bitpos="18" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV"/>
+            </require>
+            <require depends="VK_NV_ray_tracing_motion_blur">
+                <enum bitpos="20" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV"/>
+            </require>
+            <require depends="VK_KHR_dynamic_rendering+VK_KHR_fragment_shading_rate">
+                <enum bitpos="21" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_dynamic_rendering+VK_EXT_fragment_density_map">
+                <enum bitpos="22" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_opacity_micromap">
+                <enum bitpos="24" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_attachment_feedback_loop_layout">
+                <enum bitpos="25" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
+                <enum bitpos="26" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_pipeline_protected_access">
+                <enum bitpos="27" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT"/>
+                <enum bitpos="30" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT"/>
+            </require>
+            <require depends="VK_NV_displacement_micromap">
+                <enum bitpos="28" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"/>
+            </require>
+            <require depends="VK_EXT_descriptor_buffer">
+                <enum bitpos="29" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_conditional_rendering">
+                <enum bitpos="9"  extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_ray_tracing_pipeline">
+                <enum bitpos="10" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"/>
+            </require>
+            <require depends="VK_NV_ray_tracing">
+                <enum extends="VkBufferUsageFlagBits2KHR"                name="VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV" alias="VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"/>
+            </require>
+            <require depends="VK_EXT_transform_feedback">
+                <enum bitpos="11" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
+                <enum bitpos="12" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_video_decode_queue">
+                <enum bitpos="13" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR"/>
+                <enum bitpos="14" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_video_encode_queue">
+                <enum bitpos="15" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="16" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+            </require>
+            <require depends="VK_VERSION_1_2,VK_KHR_buffer_device_address,VK_EXT_buffer_device_address">
+                <enum bitpos="17" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR"/>
+            </require>
+            <require depends="VK_KHR_acceleration_structure">
+                <enum bitpos="19" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"/>
+                <enum bitpos="20" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"/>
+            </require>
+            <require depends="VK_EXT_descriptor_buffer">
+                <enum bitpos="21" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="22" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"/>
+                <enum bitpos="26" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_opacity_micromap">
+                <enum bitpos="23" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"/>
+                <enum bitpos="24" extends="VkBufferUsageFlagBits2KHR"    name="VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_472" number="472" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_472_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_472&quot;"          name="VK_AMD_EXTENSION_472_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_473" number="473" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_473_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_473&quot;"          name="VK_AMD_EXTENSION_473_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_474" number="474" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_474_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_474&quot;"          name="VK_AMD_EXTENSION_474_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_475" number="475" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_475_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_475&quot;"          name="VK_AMD_EXTENSION_475_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_476" number="476" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_476_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_476&quot;"          name="VK_AMD_EXTENSION_476_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_477" number="477" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_477_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_477&quot;"          name="VK_AMD_EXTENSION_477_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_478" number="478" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_478_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_478&quot;"          name="VK_AMD_EXTENSION_478_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_479" number="479" author="AMD" contact="Stu Smith" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_AMD_EXTENSION_479_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_479&quot;"          name="VK_AMD_EXTENSION_479_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_480" number="480" author="EXT" contact="Daniel Stone" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_480_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_480&quot;"          name="VK_EXT_EXTENSION_480_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_481" number="481" author="EXT" contact="Daniel Stone" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_481_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_481&quot;"          name="VK_EXT_EXTENSION_481_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_tracing_position_fetch" number="482" type="device" depends="VK_KHR_acceleration_structure" author="KHR" contact="Eric Werness" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                     name="VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_tracing_position_fetch&quot;"         name="VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"/>
+                <enum bitpos="11" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR"/>
+                <type name="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_object" number="483" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3" type="device" author="EXT" contact="Daniel Story @daniel-story" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                            name="VK_EXT_SHADER_OBJECT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_object&quot;"             name="VK_EXT_SHADER_OBJECT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"/>
+                <enum extnumber="353" offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"/>
+                <enum extnumber="353" offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"/>
+                <enum extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
+                <enum offset="0" extends="VkObjectType"                    name="VK_OBJECT_TYPE_SHADER_EXT"/>
+                <enum offset="0" extends="VkResult"                        name="VK_INCOMPATIBLE_SHADER_BINARY_EXT"/>
+                <enum            extends="VkResult"                        name="VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT" alias="VK_INCOMPATIBLE_SHADER_BINARY_EXT" deprecated="aliased"/>
+                <type name="VkShaderEXT"/>
+                <type name="VkShaderCreateFlagBitsEXT"/>
+                <type name="VkShaderCreateFlagsEXT"/>
+                <type name="VkShaderCodeTypeEXT"/>
+                <type name="VkPhysicalDeviceShaderObjectFeaturesEXT"/>
+                <type name="VkPhysicalDeviceShaderObjectPropertiesEXT"/>
+                <type name="VkShaderCreateInfoEXT"/>
+                <type name="VkShaderRequiredSubgroupSizeCreateInfoEXT"/>
+                <type name="VkVertexInputBindingDescription2EXT"/>
+                <type name="VkVertexInputAttributeDescription2EXT"/>
+                <type name="VkColorBlendEquationEXT"/>
+                <type name="VkColorBlendAdvancedEXT"/>
+                <command name="vkCreateShadersEXT"/>
+                <command name="vkDestroyShaderEXT"/>
+                <command name="vkGetShaderBinaryDataEXT"/>
+                <command name="vkCmdBindShadersEXT"/>
+                <command name="vkCmdSetCullModeEXT"/>
+                <command name="vkCmdSetFrontFaceEXT"/>
+                <command name="vkCmdSetPrimitiveTopologyEXT"/>
+                <command name="vkCmdSetViewportWithCountEXT"/>
+                <command name="vkCmdSetScissorWithCountEXT"/>
+                <command name="vkCmdBindVertexBuffers2EXT"/>
+                <command name="vkCmdSetDepthTestEnableEXT"/>
+                <command name="vkCmdSetDepthWriteEnableEXT"/>
+                <command name="vkCmdSetDepthCompareOpEXT"/>
+                <command name="vkCmdSetDepthBoundsTestEnableEXT"/>
+                <command name="vkCmdSetStencilTestEnableEXT"/>
+                <command name="vkCmdSetStencilOpEXT"/>
+                <command name="vkCmdSetVertexInputEXT"/>
+                <command name="vkCmdSetPatchControlPointsEXT"/>
+                <command name="vkCmdSetRasterizerDiscardEnableEXT"/>
+                <command name="vkCmdSetDepthBiasEnableEXT"/>
+                <command name="vkCmdSetLogicOpEXT"/>
+                <command name="vkCmdSetPrimitiveRestartEnableEXT"/>
+                <command name="vkCmdSetTessellationDomainOriginEXT"/>
+                <command name="vkCmdSetDepthClampEnableEXT"/>
+                <command name="vkCmdSetPolygonModeEXT"/>
+                <command name="vkCmdSetRasterizationSamplesEXT"/>
+                <command name="vkCmdSetSampleMaskEXT"/>
+                <command name="vkCmdSetAlphaToCoverageEnableEXT"/>
+                <command name="vkCmdSetAlphaToOneEnableEXT"/>
+                <command name="vkCmdSetLogicOpEnableEXT"/>
+                <command name="vkCmdSetColorBlendEnableEXT"/>
+                <command name="vkCmdSetColorBlendEquationEXT"/>
+                <command name="vkCmdSetColorWriteMaskEXT"/>
+                <feature name="shaderObject" struct="VkPhysicalDeviceShaderObjectFeaturesEXT"/>
+            </require>
+            <require depends="VK_EXT_transform_feedback">
+                <command name="vkCmdSetRasterizationStreamEXT"/>
+            </require>
+            <require depends="VK_EXT_conservative_rasterization">
+                <command name="vkCmdSetConservativeRasterizationModeEXT"/>
+                <command name="vkCmdSetExtraPrimitiveOverestimationSizeEXT"/>
+            </require>
+            <require depends="VK_EXT_depth_clip_enable">
+                <command name="vkCmdSetDepthClipEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_sample_locations">
+                <command name="vkCmdSetSampleLocationsEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_blend_operation_advanced">
+                <command name="vkCmdSetColorBlendAdvancedEXT"/>
+            </require>
+            <require depends="VK_EXT_provoking_vertex">
+                <command name="vkCmdSetProvokingVertexModeEXT"/>
+            </require>
+            <require depends="VK_EXT_line_rasterization">
+                <command name="vkCmdSetLineRasterizationModeEXT"/>
+                <command name="vkCmdSetLineStippleEnableEXT"/>
+            </require>
+            <require depends="VK_EXT_depth_clip_control">
+                <command name="vkCmdSetDepthClipNegativeOneToOneEXT"/>
+            </require>
+            <require depends="VK_EXT_subgroup_size_control,VK_VERSION_1_3">
+                <enum bitpos="1" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"/>
+                <enum bitpos="2" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_mesh_shader,VK_NV_mesh_shader">
+                <enum bitpos="3" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_device_group,VK_VERSION_1_1">
+                <enum bitpos="4" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT"/>
+            </require>
+            <require depends="VK_KHR_fragment_shading_rate">
+                <enum bitpos="5" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT"/>
+            </require>
+            <require depends="VK_EXT_fragment_density_map">
+                <enum bitpos="6" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
+            </require>
+            <require depends="VK_NV_clip_space_w_scaling">
+                <command name="vkCmdSetViewportWScalingEnableNV"/>
+            </require>
+            <require depends="VK_NV_viewport_swizzle">
+                <command name="vkCmdSetViewportSwizzleNV"/>
+            </require>
+            <require depends="VK_NV_fragment_coverage_to_color">
+                <command name="vkCmdSetCoverageToColorEnableNV"/>
+                <command name="vkCmdSetCoverageToColorLocationNV"/>
+            </require>
+            <require depends="VK_NV_framebuffer_mixed_samples">
+                <command name="vkCmdSetCoverageModulationModeNV"/>
+                <command name="vkCmdSetCoverageModulationTableEnableNV"/>
+                <command name="vkCmdSetCoverageModulationTableNV"/>
+            </require>
+            <require depends="VK_NV_shading_rate_image">
+                <command name="vkCmdSetShadingRateImageEnableNV"/>
+            </require>
+            <require depends="VK_NV_representative_fragment_test">
+                <command name="vkCmdSetRepresentativeFragmentTestEnableNV"/>
+            </require>
+            <require depends="VK_NV_coverage_reduction_mode">
+                <command name="vkCmdSetCoverageReductionModeNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_484" number="484" author="KHR" contact="Chris Glover @cdglove" supported="disabled">
+            <require>
+                <enum value="0"                                          name="VK_EXT_EXTENSION_484_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_484&quot;"           name="VK_EXT_EXTENSION_484_EXTENSION_NAME"/>
+                <enum bitpos="31" extends="VkPipelineCreateFlagBits2KHR" name="VK_PIPELINE_CREATE_2_RESERVED_31_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_tile_properties" number="485" type="device" depends="VK_KHR_get_physical_device_properties2" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                               name="VK_QCOM_TILE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_tile_properties&quot;"             name="VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME"/>
+                <command name="vkGetFramebufferTilePropertiesQCOM"/>
+                <command name="vkGetDynamicRenderingTilePropertiesQCOM"/>
+                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"/>
+                <type name="VkPhysicalDeviceTilePropertiesFeaturesQCOM"/>
+                <type name="VkTilePropertiesQCOM"/>
+            </require>
+            <require depends="VK_KHR_dynamic_rendering">
+                <type name="VkRenderingInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_SEC_amigo_profiling" number="486" type="device" depends="VK_KHR_get_physical_device_properties2" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="vulkan">
+            <require>
+                <enum value="1"                                               name="VK_SEC_AMIGO_PROFILING_SPEC_VERSION"/>
+                <enum value="&quot;VK_SEC_amigo_profiling&quot;"              name="VK_SEC_AMIGO_PROFILING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"/>
+                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"/>
+                <type name="VkPhysicalDeviceAmigoProfilingFeaturesSEC"/>
+                <type name="VkAmigoProfilingSubmitInfoSEC"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_487" number="487" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_487_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_487&quot;"          name="VK_EXT_EXTENSION_487_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_488" number="488" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_488_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_488&quot;"          name="VK_EXT_EXTENSION_488_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_multiview_per_view_viewports" number="489" type="device" author="QCOM" contact="Jeff Leger @jackohound" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_multiview_per_view_viewports&quot;" name="VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"/>
+                <type name="VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_sci_sync2" number="490" author="NV" depends="VK_VERSION_1_1" platform="sci" type="device" contact="Kai Zhang @kazhang" supported="vulkansc">
+            <require>
+                <enum value="1"                                         name="VK_NV_EXTERNAL_SCI_SYNC_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_sci_sync2&quot;"      name="VK_NV_EXTERNAL_SCI_SYNC_2_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkObjectType"                name="VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV"   comment="VkSemaphoreSciSyncPoolNV"/>
+                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV"/>
+                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV"/>
+                <enum offset="2"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV"/>
+                <type name="VkSemaphoreSciSyncPoolNV"/>
+                <type name="VkPhysicalDeviceExternalSciSync2FeaturesNV"/>
+                <type name="VkSemaphoreSciSyncPoolCreateInfoNV"/>
+                <type name="VkSemaphoreSciSyncCreateInfoNV"/>
+                <command name="vkCreateSemaphoreSciSyncPoolNV"/>
+                <command name="vkDestroySemaphoreSciSyncPoolNV"/>
+            </require>
+            <require comment="functionality re-used unmodified from VK_NV_external_sci_sync">
+                <enum extnumber="374" offset="0" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"/>
+                <enum extnumber="374" offset="1" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"/>
+                <enum extnumber="374" offset="2" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"/>
+                <enum extnumber="374" offset="3" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"/>
+                <enum bitpos="4" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
+                <enum bitpos="5" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"/>
+                <type name="VkSciSyncClientTypeNV"/>
+                <type name="VkSciSyncPrimitiveTypeNV"/>
+                <type name="VkExportFenceSciSyncInfoNV"/>
+                <type name="VkImportFenceSciSyncInfoNV"/>
+                <type name="VkFenceGetSciSyncInfoNV"/>
+                <type name="VkSciSyncAttributesInfoNV"/>
+                <command name="vkGetFenceSciSyncFenceNV"/>
+                <command name="vkGetFenceSciSyncObjNV"/>
+                <command name="vkImportFenceSciSyncFenceNV"/>
+                <command name="vkImportFenceSciSyncObjNV"/>
+                <command name="vkGetPhysicalDeviceSciSyncAttributesNV"/>
+            </require>
+            <require depends="VKSC_VERSION_1_0" api="vulkansc">
+                <enum offset="3" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV"/>
+                <type name="VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_ray_tracing_invocation_reorder" number="491" type="device" depends="VK_KHR_ray_tracing_pipeline" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_ray_tracing_invocation_reorder&quot;"  name="VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"/>
+                <type name="VkRayTracingInvocationReorderModeNV"/>
+                <type name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV"/>
+                <type name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_492" number="492" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_492_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_492&quot;"           name="VK_NV_EXTENSION_492_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extended_sparse_address_space" number="493" type="device" author="NV" contact="Russell Chou @russellcnv" supported="vulkan">
+            <require>
+                <enum value="1"                                               name="VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extended_sparse_address_space&quot;" name="VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"/>
+                <type name="VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV"/>
+                <type name="VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_494" number="494" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_494_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_494&quot;"           name="VK_NV_EXTENSION_494_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_mutable_descriptor_type" number="495" type="device" supported="vulkan" author="EXT" contact="Joshua Ashton @Joshua-Ashton,Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_maintenance3">
+            <require>
+                <enum value="1"                                                name="VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_mutable_descriptor_type&quot;"       name="VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" extnumber="352"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"/>
+                <enum offset="2" extends="VkStructureType" extnumber="352"     name="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkDescriptorType" extnumber="352"    name="VK_DESCRIPTOR_TYPE_MUTABLE_EXT"/>
+                <enum bitpos="2" extends="VkDescriptorPoolCreateFlagBits"      name="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"/>
+                <enum bitpos="2" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"/>
+                <type name="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"/>
+                <type name="VkMutableDescriptorTypeListEXT"/>
+                <type name="VkMutableDescriptorTypeCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_496" number="496" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_496_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_496&quot;"              name="VK_EXT_EXTENSION_496_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_497" number="497" author="EXT" contact="Christophe Riccio @christophe" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_497_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_497&quot;"              name="VK_EXT_EXTENSION_497_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_shader_core_builtins" number="498" author="ARM" contact="Kevin Petit @kpet" type="device" depends="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_shader_core_builtins&quot;"   name="VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"/>
+                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"/>
+                <type name="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM"/>
+                <type name="VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_library_group_handles" number="499" type="device" depends="VK_KHR_ray_tracing_pipeline+VK_KHR_pipeline_library" author="EXT" contact="Hans-Kristian Arntzen @HansKristian-Work" supported="vulkan">
+            <require>
+                <enum value="1"                                                  name="VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_library_group_handles&quot;"  name="VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"/>
+                <type name="VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_dynamic_rendering_unused_attachments" number="500" author="EXT" contact="Piers Daniell @pdaniell-nv" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+(VK_KHR_dynamic_rendering,VK_VERSION_1_3)" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                        name="VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_dynamic_rendering_unused_attachments&quot;"  name="VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_501" number="501" author="SEC" contact="Chris Hambacher @chambacher" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_501_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_501&quot;"              name="VK_EXT_EXTENSION_501_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_502" number="502" author="HUAWEI" contact="Pan Gao @PanGao-h" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_502_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_502&quot;"              name="VK_EXT_EXTENSION_502_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_503" number="503" author="HUAWEI" contact="Pan Gao @PanGao-h" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_503_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_503&quot;"              name="VK_EXT_EXTENSION_503_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_504" number="504" author="NV" contact="Piers Daniell @pdaniell-nv" type="instance" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_504_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_504&quot;"               name="VK_NV_EXTENSION_504_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_505" number="505" author="EXT" contact="Jamie Madill @jmadill" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_505_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_505&quot;"              name="VK_EXT_EXTENSION_505_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_low_latency2" number="506" author="NV" contact="Charles Hansen @cshansen" type="device" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_LOW_LATENCY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_low_latency2&quot;"                name="VK_NV_LOW_LATENCY_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"/>
+                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"/>
+                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"/>
+                <type name="VkLatencySleepModeInfoNV"/>
+                <type name="VkLatencySleepInfoNV"/>
+                <type name="VkSetLatencyMarkerInfoNV"/>
+                <type name="VkGetLatencyMarkerInfoNV"/>
+                <type name="VkLatencyTimingsFrameReportNV"/>
+                <type name="VkLatencyMarkerNV"/>
+                <type name="VkLatencySubmissionPresentIdNV"/>
+                <type name="VkSwapchainLatencyCreateInfoNV"/>
+                <type name="VkOutOfBandQueueTypeInfoNV"/>
+                <type name="VkOutOfBandQueueTypeNV"/>
+                <type name="VkLatencySurfaceCapabilitiesNV"/>
+                <command name="vkSetLatencySleepModeNV"/>
+                <command name="vkLatencySleepNV"/>
+                <command name="vkSetLatencyMarkerNV"/>
+                <command name="vkGetLatencyTimingsNV"/>
+                <command name="vkQueueNotifyOutOfBandNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_cooperative_matrix" number="507" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Kevin Petit @kpet" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="2"                                              name="VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_cooperative_matrix&quot;"          name="VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"/>
+                <type name="VkCooperativeMatrixPropertiesKHR"/>
+                <type name="VkScopeKHR"/>
+                <type name="VkComponentTypeKHR"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesKHR"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_508" number="508" author="EXT" contact="Kevin Petit @kpet" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_508_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_508&quot;"              name="VK_EXT_EXTENSION_508_EXTENSION_NAME"/>
+                <enum bitpos="10" extends="VkQueueFlagBits"                 name="VK_QUEUE_RESERVED_10_BIT_EXT" />
+                <enum bitpos="42" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_RESERVED_42_BIT_EXT" />
+                <enum bitpos="47" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_47_BIT_EXT" />
+                <enum bitpos="48" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_48_BIT_EXT" />
+                <enum bitpos="48" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_48_BIT_EXT" />
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_509" number="509" author="EXT" contact="Kevin Petit @kpet" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_509_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_509&quot;"              name="VK_EXT_EXTENSION_509_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_510" number="510" author="MESA" contact="Dave Airlie @airlied" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_MESA_EXTENSION_510_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_510&quot;"             name="VK_MESA_EXTENSION_510_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_multiview_per_view_render_areas" number="511" type="device" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                                   name="VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_multiview_per_view_render_areas&quot;" name="VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"/>
+                <type name="VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM"/>
+               <type name="VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_512" number="512" author="EXT" contact="Jean-Noe Morissette @MagicPoncho" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_512_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_512&quot;"              name="VK_EXT_EXTENSION_512_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_513" number="513" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_513_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_513&quot;"              name="VK_KHR_EXTENSION_513_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_514" number="514" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_514_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_514&quot;"              name="VK_KHR_EXTENSION_514_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_515" number="515" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_515_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_515&quot;"              name="VK_KHR_EXTENSION_515_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_516" number="516" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_516_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_516&quot;"              name="VK_KHR_EXTENSION_516_EXTENSION_NAME"/>
+                <enum bitpos="20" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_RESERVED_20_BIT_KHR"/>
+                <enum bitpos="6" extends="VkBufferCreateFlagBits"           name="VK_BUFFER_CREATE_RESERVED_6_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_517" number="517" author="EXT" contact="Daniel Story" supported="disabled">
+            <require>
+                <enum value="0"                                                name="VK_EXT_EXTENSION_517_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_517&quot;"                 name="VK_EXT_EXTENSION_517_EXTENSION_NAME"/>
+                <enum bitpos="6" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_6_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_518" number="518" author="MESA" contact="Dave Airlie @airlied" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_MESA_EXTENSION_518_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_518&quot;"             name="VK_MESA_EXTENSION_518_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_image_processing2" number="519" type="device" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan" depends="VK_QCOM_image_processing">
+            <require>
+                <enum value="1"                                                   name="VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_image_processing2&quot;"               name="VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"/>
+                <enum offset="2" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"/>
+                <type name="VkPhysicalDeviceImageProcessing2FeaturesQCOM"/>
+                <type name="VkPhysicalDeviceImageProcessing2PropertiesQCOM"/>
+                <type name="VkSamplerBlockMatchWindowCreateInfoQCOM"/>
+                <type name="VkBlockMatchWindowCompareModeQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_filter_cubic_weights" number="520" type="device" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan" depends="VK_EXT_filter_cubic">
+            <require>
+                <enum value="1"                                             name="VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_filter_cubic_weights&quot;"      name="VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"/>
+                <type name="VkPhysicalDeviceCubicWeightsFeaturesQCOM"/>
+                <type name="VkSamplerCubicWeightsCreateInfoQCOM"/>
+                <type name="VkBlitImageCubicWeightsInfoQCOM"/>
+                <type name="VkCubicFilterWeightsQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_ycbcr_degamma" number="521" type="device" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                                   name="VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_ycbcr_degamma&quot;"                   name="VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"/>
+                <type name="VkPhysicalDeviceYcbcrDegammaFeaturesQCOM"/>
+                <type name="VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_filter_cubic_clamp" number="522" type="device" author="QCOM" depends="(VK_EXT_filter_cubic)+(VK_VERSION_1_2,VK_EXT_sampler_filter_minmax)" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                                   name="VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_filter_cubic_clamp&quot;"              name="VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"/>
+                <enum offset="0" extends="VkSamplerReductionMode"                 name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM"/>
+                <type name="VkPhysicalDeviceCubicClampFeaturesQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_523" number="523" author="EXT" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                                name="VK_EXT_EXTENSION_523_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_523&quot;"                 name="VK_EXT_EXTENSION_523_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_524" number="524" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="disabled">
+            <require>
+                <enum value="0"                                                name="VK_EXT_EXTENSION_524_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_524&quot;"                 name="VK_EXT_EXTENSION_524_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_attachment_feedback_loop_dynamic_state" number="525" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2+VK_EXT_attachment_feedback_loop_layout" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
+            <require>
+                <enum value="1"                                                                name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_attachment_feedback_loop_dynamic_state&quot;" name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                                      name="VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT"/>
+                <type name="VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT"/>
+                <command name="vkCmdSetAttachmentFeedbackLoopEnableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_526" number="526" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_526_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_526&quot;"          name="VK_EXT_EXTENSION_526_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_527" number="527" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_527_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_527&quot;"          name="VK_EXT_EXTENSION_527_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_528" number="528" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_528_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_528&quot;"          name="VK_EXT_EXTENSION_528_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_529" number="529" author="KHR" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_529_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_529&quot;"          name="VK_KHR_EXTENSION_529_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QNX_external_memory_screen_buffer" number="530" type="device" author="QNX" depends="((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign" platform="screen" contact="Mike Gorchak @mgorchak-blackberry, Aaron Ruby @aruby-blackberry" supported="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_QNX_external_memory_screen_buffer&quot;" name="VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME"/>
+                <enum bitpos="14" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"/>
+                <type name="VkScreenBufferPropertiesQNX"/>
+                <type name="VkScreenBufferFormatPropertiesQNX"/>
+                <type name="VkImportScreenBufferInfoQNX"/>
+                <type name="VkExternalFormatQNX"/>
+                <type name="VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX"/>
+                <command name="vkGetScreenBufferPropertiesQNX"/>
+            </require>
+        </extension>
+        <extension name="VK_MSFT_layered_driver" number="531" type="device" depends="VK_KHR_get_physical_device_properties2" author="MSFT" contact="Jesse Natalie @jenatali" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_MSFT_LAYERED_DRIVER_SPEC_VERSION"/>
+                <enum value="&quot;VK_MSFT_layered_driver&quot;"        name="VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"/>
+                <type name="VkLayeredDriverUnderlyingApiMSFT"/>
+                <type name="VkPhysicalDeviceLayeredDriverPropertiesMSFT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_532" number="532" author="KHR" contact="Tobias Hector @tobias" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_532_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_532&quot;"         name="VK_KHR_EXTENSION_532_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_533" number="533" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_533_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_533&quot;"          name="VK_EXT_EXTENSION_533_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_534" number="534" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_534_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_534&quot;"          name="VK_KHR_EXTENSION_534_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_line_rasterization" number="535" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
+            <require>
+                <enum value="1"                                             name="VK_KHR_LINE_RASTERIZATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_line_rasterization&quot;"         name="VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" extnumber="260"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType" extnumber="260"  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType" extnumber="260"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR"/>
+                <enum offset="0" extends="VkDynamicState"  extnumber="260"  name="VK_DYNAMIC_STATE_LINE_STIPPLE_KHR"/>
+                <type name="VkPhysicalDeviceLineRasterizationFeaturesKHR"/>
+                <type name="VkPhysicalDeviceLineRasterizationPropertiesKHR"/>
+                <type name="VkPipelineRasterizationLineStateCreateInfoKHR"/>
+                <type name="VkLineRasterizationModeKHR"/>
+                <command name="vkCmdSetLineStippleKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_536" number="536" type="device" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                                   name="VK_QCOM_EXTENSION_536_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_536&quot;"                   name="VK_QCOM_EXTENSION_536_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_537" number="537" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_537_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_537&quot;"          name="VK_EXT_EXTENSION_537_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_538" number="538" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_538_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_538&quot;"          name="VK_EXT_EXTENSION_538_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_539" number="539" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_539_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_539&quot;"          name="VK_EXT_EXTENSION_539_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_540" number="540" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_540_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_540&quot;"          name="VK_EXT_EXTENSION_540_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_541" number="541" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_541_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_541&quot;"          name="VK_EXT_EXTENSION_541_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_542" number="542" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_542_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_542&quot;"          name="VK_EXT_EXTENSION_542_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_543" number="543" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_543_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_543&quot;"          name="VK_EXT_EXTENSION_543_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_544" number="544" author="KHR" contact="Daniel Rakos @aqnuep" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_544_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_544&quot;"          name="VK_KHR_EXTENSION_544_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_545" number="545" author="KHR" contact="Kevin Petit @kpet" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_545_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_545&quot;"          name="VK_KHR_EXTENSION_545_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_546" number="546" author="KHR" contact="Jon Leech @oddhack" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_546_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_546&quot;"          name="VK_KHR_EXTENSION_546_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_descriptor_pool_overallocation" number="547" type="device" author="NV" depends="VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_descriptor_pool_overallocation&quot;"  name="VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"/>
+                <enum bitpos="3" extends="VkDescriptorPoolCreateFlagBits"       name="VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV"/>
+                <enum bitpos="4" extends="VkDescriptorPoolCreateFlagBits"       name="VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV"/>
+                <type name="VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_548" number="548" type="device" author="QCOM" contact="Patrick Boyle @pboyleQCOM" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_QCOM_EXTENSION_548_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_548&quot;"         name="VK_QCOM_EXTENSION_548_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_549" number="549" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_549_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_549&quot;"           name="VK_NV_EXTENSION_549_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_550" number="550" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_550_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_550&quot;"           name="VK_NV_EXTENSION_550_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_551" number="551" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_551_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_551&quot;"           name="VK_NV_EXTENSION_551_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_metal" number="602" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="EXT" contact="Aitor Camacho Larrondo @aitor-lunarg" platform="metal" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_metal&quot;"         name="VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"/>
+                <enum bitpos="16" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT"/>
+                <enum bitpos="17" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT"/>
+                <enum bitpos="18" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT"/>
+                <type name="VkImportMemoryMetalHandleInfoEXT"/>
+                <type name="VkMemoryMetalHandlePropertiesEXT"/>
+                <type name="VkMemoryGetMetalHandleInfoEXT"/>
+                <command name="vkGetMemoryMetalHandleEXT"/>
+                <command name="vkGetMemoryMetalHandlePropertiesEXT"/>
+            </require>
+        </extension>
+    </extensions>
+    <formats>
+        <format name="VK_FORMAT_R4G4_UNORM_PACK8" class="8-bit" blockSize="1" texelsPerBlock="1" packed="8">
+            <component name="R" bits="4" numericFormat="UNORM"/>
+            <component name="G" bits="4" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R4G4B4A4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="R" bits="4" numericFormat="UNORM"/>
+            <component name="G" bits="4" numericFormat="UNORM"/>
+            <component name="B" bits="4" numericFormat="UNORM"/>
+            <component name="A" bits="4" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B4G4R4A4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="B" bits="4" numericFormat="UNORM"/>
+            <component name="G" bits="4" numericFormat="UNORM"/>
+            <component name="R" bits="4" numericFormat="UNORM"/>
+            <component name="A" bits="4" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R5G6B5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="R" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="6" numericFormat="UNORM"/>
+            <component name="B" bits="5" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B5G6R5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="B" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="6" numericFormat="UNORM"/>
+            <component name="R" bits="5" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R5G5B5A1_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="R" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="5" numericFormat="UNORM"/>
+            <component name="B" bits="5" numericFormat="UNORM"/>
+            <component name="A" bits="1" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B5G5R5A1_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="B" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="5" numericFormat="UNORM"/>
+            <component name="R" bits="5" numericFormat="UNORM"/>
+            <component name="A" bits="1" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A1R5G5B5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="A" bits="1" numericFormat="UNORM"/>
+            <component name="R" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="5" numericFormat="UNORM"/>
+            <component name="B" bits="5" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="A" bits="1" numericFormat="UNORM"/>
+            <component name="B" bits="5" numericFormat="UNORM"/>
+            <component name="G" bits="5" numericFormat="UNORM"/>
+            <component name="R" bits="5" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A8_UNORM_KHR" class="8-bit alpha" blockSize="1" texelsPerBlock="1">
+            <component name="A" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R8_UNORM" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <spirvimageformat name="R8"/>
+        </format>
+        <format name="VK_FORMAT_R8_SNORM" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SNORM"/>
+            <spirvimageformat name="R8Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R8_USCALED" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8_SSCALED" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8_UINT" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UINT"/>
+            <spirvimageformat name="R8ui"/>
+        </format>
+        <format name="VK_FORMAT_R8_SINT" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SINT"/>
+            <spirvimageformat name="R8i"/>
+        </format>
+        <format name="VK_FORMAT_R8_SRGB" class="8-bit" blockSize="1" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_UNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <spirvimageformat name="Rg8"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_SNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <spirvimageformat name="Rg8Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_USCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_SSCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_UINT" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <spirvimageformat name="Rg8ui"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_SINT" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <spirvimageformat name="Rg8i"/>
+        </format>
+        <format name="VK_FORMAT_R8G8_SRGB" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_UNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="B" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_SNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <component name="B" bits="8" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_USCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+            <component name="B" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_SSCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+            <component name="B" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_UINT" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <component name="B" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_SINT" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <component name="B" bits="8" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8_SRGB" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+            <component name="B" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_UNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="R" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_SNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <component name="R" bits="8" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_USCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+            <component name="R" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_SSCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_UINT" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <component name="R" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_SINT" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <component name="R" bits="8" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8_SRGB" class="24-bit" blockSize="3" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+            <component name="R" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="A" bits="8" numericFormat="UNORM"/>
+            <spirvimageformat name="Rgba8"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <component name="B" bits="8" numericFormat="SNORM"/>
+            <component name="A" bits="8" numericFormat="SNORM"/>
+            <spirvimageformat name="Rgba8Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+            <component name="B" bits="8" numericFormat="USCALED"/>
+            <component name="A" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+            <component name="B" bits="8" numericFormat="SSCALED"/>
+            <component name="A" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <component name="B" bits="8" numericFormat="UINT"/>
+            <component name="A" bits="8" numericFormat="UINT"/>
+            <spirvimageformat name="Rgba8ui"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <component name="B" bits="8" numericFormat="SINT"/>
+            <component name="A" bits="8" numericFormat="SINT"/>
+            <spirvimageformat name="Rgba8i"/>
+        </format>
+        <format name="VK_FORMAT_R8G8B8A8_SRGB" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+            <component name="B" bits="8" numericFormat="SRGB"/>
+            <component name="A" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <component name="A" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <component name="R" bits="8" numericFormat="SNORM"/>
+            <component name="A" bits="8" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+            <component name="R" bits="8" numericFormat="USCALED"/>
+            <component name="A" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+            <component name="A" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <component name="R" bits="8" numericFormat="UINT"/>
+            <component name="A" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <component name="R" bits="8" numericFormat="SINT"/>
+            <component name="A" bits="8" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8A8_SRGB" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="B" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+            <component name="R" bits="8" numericFormat="SRGB"/>
+            <component name="A" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="UNORM"/>
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="R" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="SNORM"/>
+            <component name="B" bits="8" numericFormat="SNORM"/>
+            <component name="G" bits="8" numericFormat="SNORM"/>
+            <component name="R" bits="8" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="USCALED"/>
+            <component name="B" bits="8" numericFormat="USCALED"/>
+            <component name="G" bits="8" numericFormat="USCALED"/>
+            <component name="R" bits="8" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="SSCALED"/>
+            <component name="B" bits="8" numericFormat="SSCALED"/>
+            <component name="G" bits="8" numericFormat="SSCALED"/>
+            <component name="R" bits="8" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="UINT"/>
+            <component name="B" bits="8" numericFormat="UINT"/>
+            <component name="G" bits="8" numericFormat="UINT"/>
+            <component name="R" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="SINT"/>
+            <component name="B" bits="8" numericFormat="SINT"/>
+            <component name="G" bits="8" numericFormat="SINT"/>
+            <component name="R" bits="8" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_A8B8G8R8_SRGB_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="8" numericFormat="SRGB"/>
+            <component name="B" bits="8" numericFormat="SRGB"/>
+            <component name="G" bits="8" numericFormat="SRGB"/>
+            <component name="R" bits="8" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="UNORM"/>
+            <component name="R" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="B" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SNORM"/>
+            <component name="R" bits="10" numericFormat="SNORM"/>
+            <component name="G" bits="10" numericFormat="SNORM"/>
+            <component name="B" bits="10" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="USCALED"/>
+            <component name="R" bits="10" numericFormat="USCALED"/>
+            <component name="G" bits="10" numericFormat="USCALED"/>
+            <component name="B" bits="10" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SSCALED"/>
+            <component name="R" bits="10" numericFormat="SSCALED"/>
+            <component name="G" bits="10" numericFormat="SSCALED"/>
+            <component name="B" bits="10" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="UINT"/>
+            <component name="R" bits="10" numericFormat="UINT"/>
+            <component name="G" bits="10" numericFormat="UINT"/>
+            <component name="B" bits="10" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_A2R10G10B10_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SINT"/>
+            <component name="R" bits="10" numericFormat="SINT"/>
+            <component name="G" bits="10" numericFormat="SINT"/>
+            <component name="B" bits="10" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="UNORM"/>
+            <component name="B" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="R" bits="10" numericFormat="UNORM"/>
+            <spirvimageformat name="Rgb10A2"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SNORM"/>
+            <component name="B" bits="10" numericFormat="SNORM"/>
+            <component name="G" bits="10" numericFormat="SNORM"/>
+            <component name="R" bits="10" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="USCALED"/>
+            <component name="B" bits="10" numericFormat="USCALED"/>
+            <component name="G" bits="10" numericFormat="USCALED"/>
+            <component name="R" bits="10" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SSCALED"/>
+            <component name="B" bits="10" numericFormat="SSCALED"/>
+            <component name="G" bits="10" numericFormat="SSCALED"/>
+            <component name="R" bits="10" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="UINT"/>
+            <component name="B" bits="10" numericFormat="UINT"/>
+            <component name="G" bits="10" numericFormat="UINT"/>
+            <component name="R" bits="10" numericFormat="UINT"/>
+            <spirvimageformat name="Rgb10a2ui"/>
+        </format>
+        <format name="VK_FORMAT_A2B10G10R10_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="A" bits="2" numericFormat="SINT"/>
+            <component name="B" bits="10" numericFormat="SINT"/>
+            <component name="G" bits="10" numericFormat="SINT"/>
+            <component name="R" bits="10" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R16_UNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UNORM"/>
+            <spirvimageformat name="R16"/>
+        </format>
+        <format name="VK_FORMAT_R16_SNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SNORM"/>
+            <spirvimageformat name="R16Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R16_USCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16_SSCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16_UINT" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UINT"/>
+            <spirvimageformat name="R16ui"/>
+        </format>
+        <format name="VK_FORMAT_R16_SINT" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SINT"/>
+            <spirvimageformat name="R16i"/>
+        </format>
+        <format name="VK_FORMAT_R16_SFLOAT" class="16-bit" blockSize="2" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SFLOAT"/>
+            <spirvimageformat name="R16f"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <spirvimageformat name="Rg16"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SNORM"/>
+            <component name="G" bits="16" numericFormat="SNORM"/>
+            <spirvimageformat name="Rg16Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="USCALED"/>
+            <component name="G" bits="16" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SSCALED"/>
+            <component name="G" bits="16" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UINT"/>
+            <component name="G" bits="16" numericFormat="UINT"/>
+            <spirvimageformat name="Rg16ui"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SINT"/>
+            <component name="G" bits="16" numericFormat="SINT"/>
+            <spirvimageformat name="Rg16i"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_SFLOAT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SFLOAT"/>
+            <component name="G" bits="16" numericFormat="SFLOAT"/>
+            <spirvimageformat name="Rg16f"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_UNORM" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <component name="B" bits="16" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_SNORM" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SNORM"/>
+            <component name="G" bits="16" numericFormat="SNORM"/>
+            <component name="B" bits="16" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_USCALED" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="USCALED"/>
+            <component name="G" bits="16" numericFormat="USCALED"/>
+            <component name="B" bits="16" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_SSCALED" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SSCALED"/>
+            <component name="G" bits="16" numericFormat="SSCALED"/>
+            <component name="B" bits="16" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_UINT" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UINT"/>
+            <component name="G" bits="16" numericFormat="UINT"/>
+            <component name="B" bits="16" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_SINT" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SINT"/>
+            <component name="G" bits="16" numericFormat="SINT"/>
+            <component name="B" bits="16" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16_SFLOAT" class="48-bit" blockSize="6" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SFLOAT"/>
+            <component name="G" bits="16" numericFormat="SFLOAT"/>
+            <component name="B" bits="16" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_UNORM" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <component name="B" bits="16" numericFormat="UNORM"/>
+            <component name="A" bits="16" numericFormat="UNORM"/>
+            <spirvimageformat name="Rgba16"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_SNORM" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SNORM"/>
+            <component name="G" bits="16" numericFormat="SNORM"/>
+            <component name="B" bits="16" numericFormat="SNORM"/>
+            <component name="A" bits="16" numericFormat="SNORM"/>
+            <spirvimageformat name="Rgba16Snorm"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_USCALED" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="USCALED"/>
+            <component name="G" bits="16" numericFormat="USCALED"/>
+            <component name="B" bits="16" numericFormat="USCALED"/>
+            <component name="A" bits="16" numericFormat="USCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_SSCALED" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SSCALED"/>
+            <component name="G" bits="16" numericFormat="SSCALED"/>
+            <component name="B" bits="16" numericFormat="SSCALED"/>
+            <component name="A" bits="16" numericFormat="SSCALED"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="UINT"/>
+            <component name="G" bits="16" numericFormat="UINT"/>
+            <component name="B" bits="16" numericFormat="UINT"/>
+            <component name="A" bits="16" numericFormat="UINT"/>
+            <spirvimageformat name="Rgba16ui"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SINT"/>
+            <component name="G" bits="16" numericFormat="SINT"/>
+            <component name="B" bits="16" numericFormat="SINT"/>
+            <component name="A" bits="16" numericFormat="SINT"/>
+            <spirvimageformat name="Rgba16i"/>
+        </format>
+        <format name="VK_FORMAT_R16G16B16A16_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SFLOAT"/>
+            <component name="G" bits="16" numericFormat="SFLOAT"/>
+            <component name="B" bits="16" numericFormat="SFLOAT"/>
+            <component name="A" bits="16" numericFormat="SFLOAT"/>
+            <spirvimageformat name="Rgba16f"/>
+        </format>
+        <format name="VK_FORMAT_R32_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="UINT"/>
+            <spirvimageformat name="R32ui"/>
+        </format>
+        <format name="VK_FORMAT_R32_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SINT"/>
+            <spirvimageformat name="R32i"/>
+        </format>
+        <format name="VK_FORMAT_R32_SFLOAT" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SFLOAT"/>
+            <spirvimageformat name="R32f"/>
+        </format>
+        <format name="VK_FORMAT_R32G32_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="UINT"/>
+            <component name="G" bits="32" numericFormat="UINT"/>
+            <spirvimageformat name="Rg32ui"/>
+        </format>
+        <format name="VK_FORMAT_R32G32_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SINT"/>
+            <component name="G" bits="32" numericFormat="SINT"/>
+            <spirvimageformat name="Rg32i"/>
+        </format>
+        <format name="VK_FORMAT_R32G32_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SFLOAT"/>
+            <component name="G" bits="32" numericFormat="SFLOAT"/>
+            <spirvimageformat name="Rg32f"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32_UINT" class="96-bit" blockSize="12" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="UINT"/>
+            <component name="G" bits="32" numericFormat="UINT"/>
+            <component name="B" bits="32" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32_SINT" class="96-bit" blockSize="12" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SINT"/>
+            <component name="G" bits="32" numericFormat="SINT"/>
+            <component name="B" bits="32" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32_SFLOAT" class="96-bit" blockSize="12" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SFLOAT"/>
+            <component name="G" bits="32" numericFormat="SFLOAT"/>
+            <component name="B" bits="32" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32A32_UINT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="UINT"/>
+            <component name="G" bits="32" numericFormat="UINT"/>
+            <component name="B" bits="32" numericFormat="UINT"/>
+            <component name="A" bits="32" numericFormat="UINT"/>
+            <spirvimageformat name="Rgba32ui"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32A32_SINT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SINT"/>
+            <component name="G" bits="32" numericFormat="SINT"/>
+            <component name="B" bits="32" numericFormat="SINT"/>
+            <component name="A" bits="32" numericFormat="SINT"/>
+            <spirvimageformat name="Rgba32i"/>
+        </format>
+        <format name="VK_FORMAT_R32G32B32A32_SFLOAT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="32" numericFormat="SFLOAT"/>
+            <component name="G" bits="32" numericFormat="SFLOAT"/>
+            <component name="B" bits="32" numericFormat="SFLOAT"/>
+            <component name="A" bits="32" numericFormat="SFLOAT"/>
+            <spirvimageformat name="Rgba32f"/>
+        </format>
+        <format name="VK_FORMAT_R64_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="UINT"/>
+            <spirvimageformat name="R64ui"/>
+        </format>
+        <format name="VK_FORMAT_R64_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SINT"/>
+            <spirvimageformat name="R64i"/>
+        </format>
+        <format name="VK_FORMAT_R64_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64_UINT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="UINT"/>
+            <component name="G" bits="64" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64_SINT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SINT"/>
+            <component name="G" bits="64" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64_SFLOAT" class="128-bit" blockSize="16" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SFLOAT"/>
+            <component name="G" bits="64" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64_UINT" class="192-bit" blockSize="24" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="UINT"/>
+            <component name="G" bits="64" numericFormat="UINT"/>
+            <component name="B" bits="64" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64_SINT" class="192-bit" blockSize="24" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SINT"/>
+            <component name="G" bits="64" numericFormat="SINT"/>
+            <component name="B" bits="64" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64_SFLOAT" class="192-bit" blockSize="24" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SFLOAT"/>
+            <component name="G" bits="64" numericFormat="SFLOAT"/>
+            <component name="B" bits="64" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64A64_UINT" class="256-bit" blockSize="32" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="UINT"/>
+            <component name="G" bits="64" numericFormat="UINT"/>
+            <component name="B" bits="64" numericFormat="UINT"/>
+            <component name="A" bits="64" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64A64_SINT" class="256-bit" blockSize="32" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SINT"/>
+            <component name="G" bits="64" numericFormat="SINT"/>
+            <component name="B" bits="64" numericFormat="SINT"/>
+            <component name="A" bits="64" numericFormat="SINT"/>
+        </format>
+        <format name="VK_FORMAT_R64G64B64A64_SFLOAT" class="256-bit" blockSize="32" texelsPerBlock="1">
+            <component name="R" bits="64" numericFormat="SFLOAT"/>
+            <component name="G" bits="64" numericFormat="SFLOAT"/>
+            <component name="B" bits="64" numericFormat="SFLOAT"/>
+            <component name="A" bits="64" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_B10G11R11_UFLOAT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="B" bits="10" numericFormat="UFLOAT"/>
+            <component name="G" bits="11" numericFormat="UFLOAT"/>
+            <component name="R" bits="11" numericFormat="UFLOAT"/>
+            <spirvimageformat name="R11fG11fB10f"/>
+        </format>
+        <format name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="B" bits="9" numericFormat="UFLOAT"/>
+            <component name="G" bits="9" numericFormat="UFLOAT"/>
+            <component name="R" bits="9" numericFormat="UFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_D16_UNORM" class="D16" blockSize="2" texelsPerBlock="1">
+            <component name="D" bits="16" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_X8_D24_UNORM_PACK32" class="D24" blockSize="4" texelsPerBlock="1" packed="32">
+            <component name="D" bits="24" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_D32_SFLOAT" class="D32" blockSize="4" texelsPerBlock="1">
+            <component name="D" bits="32" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_S8_UINT" class="S8" blockSize="1" texelsPerBlock="1">
+            <component name="S" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_D16_UNORM_S8_UINT" class="D16S8" blockSize="3" texelsPerBlock="1">
+            <component name="D" bits="16" numericFormat="UNORM"/>
+            <component name="S" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_D24_UNORM_S8_UINT" class="D24S8" blockSize="4" texelsPerBlock="1">
+            <component name="D" bits="24" numericFormat="UNORM"/>
+            <component name="S" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_D32_SFLOAT_S8_UINT" class="D32S8" blockSize="5" texelsPerBlock="1">
+            <component name="D" bits="32" numericFormat="SFLOAT"/>
+            <component name="S" bits="8" numericFormat="UINT"/>
+        </format>
+        <format name="VK_FORMAT_BC1_RGB_UNORM_BLOCK" class="BC1_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC1_RGB_SRGB_BLOCK" class="BC1_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK" class="BC1_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK" class="BC1_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_BC2_UNORM_BLOCK" class="BC2" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC2_SRGB_BLOCK" class="BC2" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_BC3_UNORM_BLOCK" class="BC3" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC3_SRGB_BLOCK" class="BC3" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_BC4_UNORM_BLOCK" class="BC4" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC4_SNORM_BLOCK" class="BC4" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC5_UNORM_BLOCK" class="BC5" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC5_SNORM_BLOCK" class="BC5" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SNORM"/>
+            <component name="G" bits="compressed" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC6H_UFLOAT_BLOCK" class="BC6H" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="UFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="UFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_BC6H_SFLOAT_BLOCK" class="BC6H" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_BC7_UNORM_BLOCK" class="BC7" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_BC7_SRGB_BLOCK" class="BC7" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK" class="ETC2_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK" class="ETC2_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK" class="ETC2_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK" class="ETC2_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK" class="ETC2_EAC_RGBA" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK" class="ETC2_EAC_RGBA" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_EAC_R11_UNORM_BLOCK" class="EAC_R" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
+            <component name="R" bits="11" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_EAC_R11_SNORM_BLOCK" class="EAC_R" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
+            <component name="R" bits="11" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK" class="EAC_RG" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
+            <component name="R" bits="11" numericFormat="UNORM"/>
+            <component name="G" bits="11" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK" class="EAC_RG" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
+            <component name="R" bits="11" numericFormat="SNORM"/>
+            <component name="G" bits="11" numericFormat="SNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC LDR">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_G8B8G8R8_422_UNORM" class="32-bit G8B8G8R8" blockSize="4" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="R" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B8G8R8G8_422_UNORM" class="32-bit B8G8R8G8" blockSize="4" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
+            <component name="B" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+            <component name="R" bits="8" numericFormat="UNORM"/>
+            <component name="G" bits="8" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM" class="8-bit 3-plane 420" blockSize="3" texelsPerBlock="1" chroma="420">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM" class="8-bit 2-plane 420" blockSize="3" texelsPerBlock="1" chroma="420">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8G8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM" class="8-bit 3-plane 422" blockSize="3" texelsPerBlock="1" chroma="422">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM" class="8-bit 2-plane 422" blockSize="3" texelsPerBlock="1" chroma="422">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8G8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM" class="8-bit 3-plane 444" blockSize="3" texelsPerBlock="1" chroma="444">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R10X6_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="R" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
+            <component name="R" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16" class="64-bit R10G10B10A10" blockSize="8" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="R" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="B" bits="10" numericFormat="UNORM"/>
+            <component name="A" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16" class="64-bit G10B10G10R10" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="B" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="R" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16" class="64-bit B10G10R10G10" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
+            <component name="B" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+            <component name="R" bits="10" numericFormat="UNORM"/>
+            <component name="G" bits="10" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16" class="10-bit 3-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16" class="10-bit 2-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16" class="10-bit 3-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16" class="10-bit 2-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16" class="10-bit 3-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_R12X4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="R" bits="12" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
+            <component name="R" bits="12" numericFormat="UNORM"/>
+            <component name="G" bits="12" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16" class="64-bit R12G12B12A12" blockSize="8" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="R" bits="12" numericFormat="UNORM"/>
+            <component name="G" bits="12" numericFormat="UNORM"/>
+            <component name="B" bits="12" numericFormat="UNORM"/>
+            <component name="A" bits="12" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16" class="64-bit G12B12G12R12" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
+            <component name="G" bits="12" numericFormat="UNORM"/>
+            <component name="B" bits="12" numericFormat="UNORM"/>
+            <component name="G" bits="12" numericFormat="UNORM"/>
+            <component name="R" bits="12" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16" class="64-bit B12G12R12G12" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
+            <component name="B" bits="12" numericFormat="UNORM"/>
+            <component name="G" bits="12" numericFormat="UNORM"/>
+            <component name="R" bits="12" numericFormat="UNORM"/>
+            <component name="G" bits="12" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16" class="12-bit 3-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16" class="12-bit 2-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16" class="12-bit 3-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16" class="12-bit 2-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16" class="12-bit 3-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G16B16G16R16_422_UNORM" class="64-bit G16B16G16R16" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <component name="B" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <component name="R" bits="16" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_B16G16R16G16_422_UNORM" class="64-bit B16G16R16G16" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
+            <component name="B" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+            <component name="R" bits="16" numericFormat="UNORM"/>
+            <component name="G" bits="16" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM" class="16-bit 3-plane 420" blockSize="6" texelsPerBlock="1" chroma="420">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM" class="16-bit 2-plane 420" blockSize="6" texelsPerBlock="1" chroma="420">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16G16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM" class="16-bit 3-plane 422" blockSize="6" texelsPerBlock="1" chroma="422">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM" class="16-bit 2-plane 422" blockSize="6" texelsPerBlock="1" chroma="422">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16G16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM" class="16-bit 3-plane 444" blockSize="6" texelsPerBlock="1" chroma="444">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG" class="PVRTC1_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG" class="PVRTC1_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG" class="PVRTC2_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG" class="PVRTC2_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="UNORM"/>
+            <component name="G" bits="compressed" numericFormat="UNORM"/>
+            <component name="B" bits="compressed" numericFormat="UNORM"/>
+            <component name="A" bits="compressed" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG" class="PVRTC1_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG" class="PVRTC1_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG" class="PVRTC2_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG" class="PVRTC2_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
+            <component name="R" bits="compressed" numericFormat="SRGB"/>
+            <component name="G" bits="compressed" numericFormat="SRGB"/>
+            <component name="B" bits="compressed" numericFormat="SRGB"/>
+            <component name="A" bits="compressed" numericFormat="SRGB"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC HDR">
+            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
+            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
+        </format>
+        <format name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM" class="8-bit 2-plane 444" blockSize="3" texelsPerBlock="1" chroma="444">
+            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8G8_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16" class="10-bit 2-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16" class="12-bit 2-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
+            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+        </format>
+        <format name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM" class="16-bit 2-plane 444" blockSize="6" texelsPerBlock="1" chroma="444">
+            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
+            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
+            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
+            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16G16_UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A4R4G4B4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="A" bits="4" numericFormat="UNORM"/>
+            <component name="R" bits="4" numericFormat="UNORM"/>
+            <component name="G" bits="4" numericFormat="UNORM"/>
+            <component name="B" bits="4" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_A4B4G4R4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
+            <component name="A" bits="4" numericFormat="UNORM"/>
+            <component name="B" bits="4" numericFormat="UNORM"/>
+            <component name="G" bits="4" numericFormat="UNORM"/>
+            <component name="R" bits="4" numericFormat="UNORM"/>
+        </format>
+        <format name="VK_FORMAT_R16G16_S10_5_NV" class="32-bit" blockSize="4" texelsPerBlock="1">
+            <component name="R" bits="16" numericFormat="SINT"/>
+            <component name="G" bits="16" numericFormat="SINT"/>
+        </format>
+    </formats>
+    <spirvextensions comment="SPIR-V Extensions allowed in Vulkan and what is required to use it">
+        <spirvextension name="SPV_KHR_variable_pointers">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_variable_pointers"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_explicit_vertex_parameter">
+            <enable extension="VK_AMD_shader_explicit_vertex_parameter"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gcn_shader">
+            <enable extension="VK_AMD_gcn_shader"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gpu_shader_half_float">
+            <enable extension="VK_AMD_gpu_shader_half_float"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gpu_shader_int16">
+            <enable extension="VK_AMD_gpu_shader_int16"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_ballot">
+            <enable extension="VK_AMD_shader_ballot"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_fragment_mask">
+            <enable extension="VK_AMD_shader_fragment_mask"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_image_load_store_lod">
+            <enable extension="VK_AMD_shader_image_load_store_lod"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_trinary_minmax">
+            <enable extension="VK_AMD_shader_trinary_minmax"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_texture_gather_bias_lod">
+            <enable extension="VK_AMD_texture_gather_bias_lod"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_early_and_late_fragment_tests">
+            <enable extension="VK_AMD_shader_early_and_late_fragment_tests"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_draw_parameters">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_shader_draw_parameters"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_8bit_storage">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_KHR_8bit_storage"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_16bit_storage">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_16bit_storage"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_clock">
+            <enable extension="VK_KHR_shader_clock"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_float_controls">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_KHR_shader_float_controls"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_storage_buffer_storage_class">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_storage_buffer_storage_class"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_post_depth_coverage">
+            <enable extension="VK_EXT_post_depth_coverage"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_stencil_export">
+            <enable extension="VK_EXT_shader_stencil_export"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_ballot">
+            <enable extension="VK_EXT_shader_subgroup_ballot"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_subgroup_vote">
+            <enable extension="VK_EXT_shader_subgroup_vote"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_sample_mask_override_coverage">
+            <enable extension="VK_NV_sample_mask_override_coverage"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_geometry_shader_passthrough">
+            <enable extension="VK_NV_geometry_shader_passthrough"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_mesh_shader">
+            <enable extension="VK_NV_mesh_shader"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_viewport_array2">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_subgroup_partitioned">
+            <enable extension="VK_NV_shader_subgroup_partitioned"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_invocation_reorder">
+            <enable extension="VK_NV_ray_tracing_invocation_reorder"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_viewport_index_layer">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_EXT_shader_viewport_index_layer"/>
+        </spirvextension>
+        <spirvextension name="SPV_NVX_multiview_per_view_attributes">
+            <enable extension="VK_NVX_multiview_per_view_attributes"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_descriptor_indexing">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_EXT_descriptor_indexing"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_vulkan_memory_model">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_KHR_vulkan_memory_model"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_compute_shader_derivatives">
+            <enable extension="VK_NV_compute_shader_derivatives"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_fragment_shader_barycentric">
+            <enable extension="VK_NV_fragment_shader_barycentric"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_image_footprint">
+            <enable extension="VK_NV_shader_image_footprint"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shading_rate">
+            <enable extension="VK_NV_shading_rate_image"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_ray_tracing">
+            <enable extension="VK_NV_ray_tracing"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_tracing">
+            <enable extension="VK_KHR_ray_tracing_pipeline"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_query">
+            <enable extension="VK_KHR_ray_query"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_cull_mask">
+            <enable extension="VK_KHR_ray_tracing_maintenance1"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_hlsl_functionality1">
+            <enable extension="VK_GOOGLE_hlsl_functionality1"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_user_type">
+            <enable extension="VK_GOOGLE_user_type"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_decorate_string">
+            <enable extension="VK_GOOGLE_decorate_string"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_fragment_invocation_density">
+            <enable extension="VK_EXT_fragment_density_map"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_physical_storage_buffer">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_KHR_buffer_device_address"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_physical_storage_buffer">
+            <enable extension="VK_EXT_buffer_device_address"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_cooperative_matrix">
+            <enable extension="VK_NV_cooperative_matrix"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_sm_builtins">
+            <enable extension="VK_NV_shader_sm_builtins"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_fragment_shader_interlock">
+            <enable extension="VK_EXT_fragment_shader_interlock"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_demote_to_helper_invocation">
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_EXT_shader_demote_to_helper_invocation"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_fragment_shading_rate">
+            <enable extension="VK_KHR_fragment_shading_rate"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_non_semantic_info">
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_shader_non_semantic_info"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_image_int64">
+            <enable extension="VK_EXT_shader_image_atomic_int64"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_terminate_invocation">
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_shader_terminate_invocation"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_multiview">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_multiview"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_workgroup_memory_explicit_layout">
+            <enable extension="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float_add">
+            <enable extension="VK_EXT_shader_atomic_float"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_fragment_shader_barycentric">
+            <enable extension="VK_KHR_fragment_shader_barycentric"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_subgroup_uniform_control_flow">
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_shader_subgroup_uniform_control_flow"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float_min_max">
+            <enable extension="VK_EXT_shader_atomic_float2"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float16_add">
+            <enable extension="VK_EXT_shader_atomic_float2"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_fragment_fully_covered">
+            <enable extension="VK_EXT_conservative_rasterization"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_integer_dot_product">
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_shader_integer_dot_product"/>
+        </spirvextension>
+        <spirvextension name="SPV_INTEL_shader_integer_functions2">
+            <enable extension="VK_INTEL_shader_integer_functions2"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_device_group">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_device_group"/>
+        </spirvextension>
+        <spirvextension name="SPV_QCOM_image_processing">
+            <enable extension="VK_QCOM_image_processing"/>
+        </spirvextension>
+        <spirvextension name="SPV_QCOM_image_processing2">
+            <enable extension="VK_QCOM_image_processing2"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_mesh_shader">
+            <enable extension="VK_EXT_mesh_shader"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_tracing_position_fetch">
+            <enable extension="VK_KHR_ray_tracing_position_fetch"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_tile_image">
+            <enable extension="VK_EXT_shader_tile_image"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_opacity_micromap">
+            <enable extension="VK_EXT_opacity_micromap"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_cooperative_matrix">
+            <enable extension="VK_KHR_cooperative_matrix"/>
+        </spirvextension>
+        <spirvextension name="SPV_ARM_core_builtins">
+            <enable extension="VK_ARM_shader_core_builtins"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMDX_shader_enqueue">
+            <enable extension="VK_AMDX_shader_enqueue"/>
+        </spirvextension>
+    </spirvextensions>
+    <spirvcapabilities comment="SPIR-V Capabilities allowed in Vulkan and what is required to use it">
+        <spirvcapability name="Matrix">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Shader">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachment">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Sampled1D">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Image1D">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledBuffer">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageBuffer">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageQuery">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="DerivativeControl">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Geometry">
+            <enable struct="VkPhysicalDeviceFeatures" feature="geometryShader" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Tessellation">
+            <enable struct="VkPhysicalDeviceFeatures" feature="tessellationShader" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Float64">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderFloat64" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Int64">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt64" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Int64Atomics">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderBufferInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSharedInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
+            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat16AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat32AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderImageFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat64AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat16MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat32MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderImageFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat64MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="Int64ImageEXT">
+            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
+        </spirvcapability>
+        <spirvcapability name="Int16">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt16" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="TessellationPointSize">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryPointSize">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageGatherExtended">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderImageGatherExtended" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageMultisample">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="UniformBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderUniformBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledImageArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderSampledImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ClipDistance">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderClipDistance" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="CullDistance">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderCullDistance" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageCubeArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampleRateShading">
+            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SparseResidency">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceResidency" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="MinLod">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceMinLod" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledCubeArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageMSArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageExtendedFormats">
+            <enable version="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="InterpolationFunction">
+            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageReadWithoutFormat">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageReadWithoutFormat" requires="VK_VERSION_1_0"/>
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_format_feature_flags2"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageWriteWithoutFormat">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageWriteWithoutFormat" requires="VK_VERSION_1_0"/>
+            <enable version="VK_VERSION_1_3"/>
+            <enable extension="VK_KHR_format_feature_flags2"/>
+        </spirvcapability>
+        <spirvcapability name="MultiViewport">
+            <enable struct="VkPhysicalDeviceFeatures" feature="multiViewport" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="DrawParameters">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="shaderDrawParameters" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceShaderDrawParametersFeatures" feature="shaderDrawParameters" requires="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_shader_draw_parameters"/>
+        </spirvcapability>
+        <spirvcapability name="MultiView">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="multiview" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceMultiviewFeatures" feature="multiview" requires="VK_KHR_multiview"/>
+        </spirvcapability>
+        <spirvcapability name="DeviceGroup">
+            <enable version="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_device_group"/>
+        </spirvcapability>
+        <spirvcapability name="VariablePointersStorageBuffer">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointersStorageBuffer" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointersStorageBuffer" requires="VK_KHR_variable_pointers"/>
+        </spirvcapability>
+        <spirvcapability name="VariablePointers">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointers" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointers" requires="VK_KHR_variable_pointers"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderClockKHR">
+            <enable extension="VK_KHR_shader_clock"/>
+        </spirvcapability>
+        <spirvcapability name="StencilExportEXT">
+            <enable extension="VK_EXT_shader_stencil_export"/>
+        </spirvcapability>
+        <spirvcapability name="SubgroupBallotKHR">
+            <enable extension="VK_EXT_shader_subgroup_ballot"/>
+        </spirvcapability>
+        <spirvcapability name="SubgroupVoteKHR">
+            <enable extension="VK_EXT_shader_subgroup_vote"/>
+        </spirvcapability>
+        <spirvcapability name="ImageReadWriteLodAMD">
+            <enable extension="VK_AMD_shader_image_load_store_lod"/>
+        </spirvcapability>
+        <spirvcapability name="ImageGatherBiasLodAMD">
+            <enable extension="VK_AMD_texture_gather_bias_lod"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentMaskAMD">
+            <enable extension="VK_AMD_shader_fragment_mask"/>
+        </spirvcapability>
+        <spirvcapability name="SampleMaskOverrideCoverageNV">
+            <enable extension="VK_NV_sample_mask_override_coverage"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryShaderPassthroughNV">
+            <enable extension="VK_NV_geometry_shader_passthrough"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndex">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputViewportIndex" requires="VK_VERSION_1_2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderLayer">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputLayer" requires="VK_VERSION_1_2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndexLayerEXT">
+            <enable extension="VK_EXT_shader_viewport_index_layer"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndexLayerNV">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportMaskNV">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvcapability>
+        <spirvcapability name="PerViewAttributesNV">
+            <enable extension="VK_NVX_multiview_per_view_attributes"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBuffer16BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="UniformAndStorageBuffer16BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="uniformAndStorageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="uniformAndStorageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StoragePushConstant16">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storagePushConstant16" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storagePushConstant16" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StorageInputOutput16">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageInputOutput16" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageInputOutput16" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniform">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BASIC_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformVote">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_VOTE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformArithmetic">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformBallot">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BALLOT_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformShuffle">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformShuffleRelative">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformClustered">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_CLUSTERED_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformQuad">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_QUAD_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformPartitionedNV">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV" requires="VK_NV_shader_subgroup_partitioned"/>
+        </spirvcapability>
+        <spirvcapability name="SampleMaskPostDepthCoverage">
+            <enable extension="VK_EXT_post_depth_coverage"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderNonUniform">
+            <enable version="VK_VERSION_1_2"/>
+            <enable extension="VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="RuntimeDescriptorArray">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="runtimeDescriptorArray" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachmentArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformTexelBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageTexelBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="SampledImageArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSampledImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachmentArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformTexelBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageTexelBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentFullyCoveredEXT">
+            <enable extension="VK_EXT_conservative_rasterization"/>
+        </spirvcapability>
+        <spirvcapability name="Float16">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderFloat16" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
+            <enable extension="VK_AMD_gpu_shader_half_float"/>
+        </spirvcapability>
+        <spirvcapability name="Int8">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInt8" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBuffer8BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="UniformAndStorageBuffer8BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="uniformAndStorageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StoragePushConstant8">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storagePushConstant8" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="VulkanMemoryModel">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModel" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
+        </spirvcapability>
+        <spirvcapability name="VulkanMemoryModelDeviceScope">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModelDeviceScope" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
+        </spirvcapability>
+        <spirvcapability name="DenormPreserve">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="DenormFlushToZero">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="SignedZeroInfNanPreserve">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="RoundingModeRTE">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="RoundingModeRTZ">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="ComputeDerivativeGroupQuadsNV">
+            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupQuads" requires="VK_NV_compute_shader_derivatives"/>
+        </spirvcapability>
+        <spirvcapability name="ComputeDerivativeGroupLinearNV">
+            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupLinear" requires="VK_NV_compute_shader_derivatives"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentBarycentricNV">
+            <enable struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV" feature="fragmentShaderBarycentric" requires="VK_NV_fragment_shader_barycentric"/>
+        </spirvcapability>
+        <spirvcapability name="ImageFootprintNV">
+            <enable struct="VkPhysicalDeviceShaderImageFootprintFeaturesNV" feature="imageFootprint" requires="VK_NV_shader_image_footprint"/>
+        </spirvcapability>
+        <spirvcapability name="ShadingRateNV">
+            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
+        </spirvcapability>
+        <spirvcapability name="MeshShadingNV">
+            <enable extension="VK_NV_mesh_shader"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingKHR">
+            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTracingPipeline" requires="VK_KHR_ray_tracing_pipeline"/>
+        </spirvcapability>
+        <spirvcapability name="RayQueryKHR">
+            <enable struct="VkPhysicalDeviceRayQueryFeaturesKHR" feature="rayQuery" requires="VK_KHR_ray_query"/>
+        </spirvcapability>
+        <spirvcapability name="RayTraversalPrimitiveCullingKHR">
+            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTraversalPrimitiveCulling" requires="VK_KHR_ray_tracing_pipeline"/>
+            <enable struct="VkPhysicalDeviceRayQueryFeaturesKHR" feature="rayQuery" requires="VK_KHR_ray_query"/>
+        </spirvcapability>
+        <spirvcapability name="RayCullMaskKHR">
+            <enable struct="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR" feature="rayTracingMaintenance1" requires="VK_KHR_ray_tracing_maintenance1"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingNV">
+            <enable extension="VK_NV_ray_tracing"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingMotionBlurNV">
+            <enable struct="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" feature="rayTracingMotionBlur" requires="VK_NV_ray_tracing_motion_blur"/>
+        </spirvcapability>
+        <spirvcapability name="TransformFeedback">
+            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="transformFeedback" requires="VK_EXT_transform_feedback"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryStreams">
+            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="geometryStreams" requires="VK_EXT_transform_feedback"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentDensityEXT">
+            <enable struct="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" feature="fragmentDensityMap" requires="VK_EXT_fragment_density_map"/>
+        </spirvcapability>
+        <spirvcapability name="PhysicalStorageBufferAddresses">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="bufferDeviceAddress" requires="VK_VERSION_1_2,VK_KHR_buffer_device_address"/>
+            <enable struct="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" feature="bufferDeviceAddress" requires="VK_EXT_buffer_device_address" alias="bufferDeviceAddressEXT"/>
+        </spirvcapability>
+        <spirvcapability name="CooperativeMatrixNV">
+            <enable struct="VkPhysicalDeviceCooperativeMatrixFeaturesNV" feature="cooperativeMatrix" requires="VK_NV_cooperative_matrix"/>
+        </spirvcapability>
+        <spirvcapability name="IntegerFunctions2INTEL">
+            <enable struct="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" feature="shaderIntegerFunctions2" requires="VK_INTEL_shader_integer_functions2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderSMBuiltinsNV">
+            <enable struct="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" feature="shaderSMBuiltins" requires="VK_NV_shader_sm_builtins"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderSampleInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderSampleInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderPixelInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderPixelInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderShadingRateInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderShadingRateInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
+        </spirvcapability>
+        <spirvcapability name="DemoteToHelperInvocationEXT">
+            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderDemoteToHelperInvocation" requires="VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation"/>
+            <enable struct="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" feature="shaderDemoteToHelperInvocation" requires="VK_EXT_shader_demote_to_helper_invocation"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShadingRateKHR">
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="pipelineFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="primitiveFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="attachmentFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayoutKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayout8BitAccessKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout8BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayout16BitAccessKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout16BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInputAllKHR">
+            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInput4x8BitKHR">
+            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInput4x8BitPackedKHR">
+            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductKHR">
+            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentBarycentricKHR">
+            <enable struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR" feature="fragmentShaderBarycentric" requires="VK_KHR_fragment_shader_barycentric"/>
+        </spirvcapability>
+        <spirvcapability name="TextureSampleWeightedQCOM">
+            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureSampleWeighted" requires="VK_QCOM_image_processing"/>
+        </spirvcapability>
+        <spirvcapability name="TextureBoxFilterQCOM">
+            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureBoxFilter" requires="VK_QCOM_image_processing"/>
+        </spirvcapability>
+        <spirvcapability name="TextureBlockMatchQCOM">
+            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureBlockMatch" requires="VK_QCOM_image_processing"/>
+        </spirvcapability>
+        <spirvcapability name="TextureBlockMatch2QCOM">
+            <enable struct="VkPhysicalDeviceImageProcessing2FeaturesQCOM" feature="textureBlockMatch2" requires="VK_QCOM_image_processing2"/>
+        </spirvcapability>
+        <spirvcapability name="MeshShadingEXT">
+            <enable extension="VK_EXT_mesh_shader"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingOpacityMicromapEXT">
+            <enable extension="VK_EXT_opacity_micromap"/>
+        </spirvcapability>
+        <spirvcapability name="CoreBuiltinsARM">
+            <enable struct="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM" feature="shaderCoreBuiltins" requires="VK_ARM_shader_core_builtins"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderInvocationReorderNV">
+            <enable extension="VK_NV_ray_tracing_invocation_reorder"/>
+        </spirvcapability>
+        <spirvcapability name="ClusterCullingShadingHUAWEI">
+            <enable struct="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI" feature="clustercullingShader" requires="VK_HUAWEI_cluster_culling_shader"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingPositionFetchKHR">
+            <enable struct="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR" feature="rayTracingPositionFetch" requires="VK_KHR_ray_tracing_position_fetch"/>
+        </spirvcapability>
+        <spirvcapability name="TileImageColorReadAccessEXT">
+            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageColorReadAccess" requires="VK_EXT_shader_tile_image"/>
+        </spirvcapability>
+        <spirvcapability name="TileImageDepthReadAccessEXT">
+            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageDepthReadAccess" requires="VK_EXT_shader_tile_image"/>
+        </spirvcapability>
+        <spirvcapability name="TileImageStencilReadAccessEXT">
+            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageStencilReadAccess" requires="VK_EXT_shader_tile_image"/>
+        </spirvcapability>
+        <spirvcapability name="CooperativeMatrixKHR">
+            <enable struct="VkPhysicalDeviceCooperativeMatrixFeaturesKHR" feature="cooperativeMatrix" requires="VK_KHR_cooperative_matrix"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderEnqueueAMDX">
+            <enable struct="VkPhysicalDeviceShaderEnqueueFeaturesAMDX" feature="shaderEnqueue" requires="VK_AMDX_shader_enqueue"/>
+        </spirvcapability>
+    </spirvcapabilities>
+    <sync comment="Machine readable representation of the synchronization objects and their mappings">
+        <syncstage name="VK_PIPELINE_STAGE_2_NONE" alias="VK_PIPELINE_STAGE_NONE">
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT" alias="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT">
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT" alias="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT">
+            <syncsupport queues="graphics,compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT" alias="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT">
+            <syncsupport queues="graphics"/>
+            <syncequivalent stage="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT" alias="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT" alias="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT" alias="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT" alias="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT" alias="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT" alias="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT" alias="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT" alias="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT">
+            <syncsupport queues="compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT" alias="VK_PIPELINE_STAGE_TRANSFER_BIT">
+            <syncsupport queues="graphics,compute,transfer"/>
+            <syncequivalent stage="VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_CLEAR_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT" alias="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT">
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_HOST_BIT" alias="VK_PIPELINE_STAGE_HOST_BIT">
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT" alias="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT">
+            <syncsupport queues="graphics"/>
+            <syncequivalent stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT,VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT" alias="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT">
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_COPY_BIT">
+            <syncsupport queues="graphics,compute,transfer"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_RESOLVE_BIT">
+            <syncsupport queues="graphics,compute,transfer"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_BLIT_BIT">
+            <syncsupport queues="graphics,compute,transfer"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_CLEAR_BIT">
+            <syncsupport queues="graphics,compute,transfer"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT">
+            <syncsupport queues="graphics"/>
+            <syncequivalent stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR">
+            <syncsupport queues="decode"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR">
+            <syncsupport queues="encode"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT" alias="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" alias="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT">
+            <syncsupport queues="graphics,compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV" alias="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV">
+            <syncsupport queues="graphics,compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR" alias="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR">
+            <syncsupport queues="compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR">
+            <syncsupport queues="compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT" alias="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT" alias="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT" alias="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR">
+            <syncsupport queues="graphics,compute,transfer"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT">
+            <syncsupport queues="compute"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI">
+            <syncsupport queues="graphics"/>
+        </syncstage>
+        <syncstage name="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV">
+            <syncsupport queues="opticalflow"/>
+        </syncstage>
+        <syncaccess name="VK_ACCESS_2_NONE" alias="VK_ACCESS_NONE">
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT" alias="VK_ACCESS_INDIRECT_COMMAND_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_INDEX_READ_BIT" alias="VK_ACCESS_INDEX_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT" alias="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_UNIFORM_READ_BIT" alias="VK_ACCESS_UNIFORM_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT" alias="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_READ_BIT" alias="VK_ACCESS_SHADER_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+            <syncequivalent access="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT,VK_ACCESS_2_SHADER_STORAGE_READ_BIT,VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_WRITE_BIT" alias="VK_ACCESS_SHADER_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+            <syncequivalent access="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT" alias="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT">
+            <comment>Fragment shader stage is added by the VK_EXT_shader_tile_image extension</comment>
+            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT" alias="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT" alias="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT">
+            <comment>Fragment shader stage is added by the VK_EXT_shader_tile_image extension</comment>
+            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT" alias="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_TRANSFER_READ_BIT" alias="VK_ACCESS_TRANSFER_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_TRANSFER_WRITE_BIT" alias="VK_ACCESS_TRANSFER_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_CLEAR_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_HOST_READ_BIT" alias="VK_ACCESS_HOST_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_HOST_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_HOST_WRITE_BIT" alias="VK_ACCESS_HOST_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_HOST_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_MEMORY_READ_BIT" alias="VK_ACCESS_MEMORY_READ_BIT">
+            <comment>TODO/Suggestion. Introduce 'synclist' (could be a different name) element
+            that specifies the list of stages, accesses, etc. This list can be used by
+            'syncaccess' or 'syncstage' elements. For example, 'syncsupport' in addition to the
+            'stage' attribute can support 'list' attribute to reference 'synclist'.
+            We can have the lists defined for ALL stages and it can be shared between MEMORY_READ
+            and MEMORY_WRITE accesses. Similarly, ALL shader stages list is often used. This proposal
+            is a way to fix duplication problem. When new stage is added multiple places needs to be
+            updated. It is potential source of bugs. The expectation such setup will produce more
+            robust system and also more simple structure to review and validate.
+            </comment>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_MEMORY_WRITE_BIT" alias="VK_ACCESS_MEMORY_WRITE_BIT">
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT" alias="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV" alias="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV" alias="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR" alias="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR" alias="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT" alias="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT" alias="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_MICROMAP_READ_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
+        </syncaccess>
+        <syncaccess name="VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV">
+            <syncsupport stage="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
+        </syncaccess>
+        <syncpipeline name="graphics primitive">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</syncpipelinestage>
+            <syncpipelinestage order="None" before="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT">VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT</syncpipelinestage>
+            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="graphics mesh" depends="VK_NV_mesh_shader,VK_EXT_mesh_shader">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</syncpipelinestage>
+            <syncpipelinestage order="None" before="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT">VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT</syncpipelinestage>
+            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="compute">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT</syncpipelinestage>
+            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="transfer">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_TRANSFER_BIT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="host">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_HOST_BIT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="subpass shading" depends="VK_HUAWEI_subpass_shading">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="command preprocessing" depends="VK_NV_device_generated_commands">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="acceleration structure build" depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="acceleration structure copy" depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="opacity micromap" depends="VK_EXT_opacity_micromap">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="ray tracing" depends="VK_KHR_ray_tracing_pipeline,VK_NV_ray_tracing">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="video decode" depends="VK_KHR_video_decode_queue">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="video encode" depends="VK_KHR_video_encode_queue">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR</syncpipelinestage>
+        </syncpipeline>
+        <syncpipeline name="optical flow" depends="VK_NV_optical_flow">
+            <syncpipelinestage>VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV</syncpipelinestage>
+        </syncpipeline>
+    </sync>
+</registry>
diff --git a/common/end2end/Android.bp b/common/end2end/Android.bp
index 0339e53d9..0df2b6a0a 100644
--- a/common/end2end/Android.bp
+++ b/common/end2end/Android.bp
@@ -13,10 +13,6 @@ cc_test_host {
         "GfxstreamEnd2EndCompositionTests.cpp",
         "GfxstreamEnd2EndGlTests.cpp",
         "GfxstreamEnd2EndVkTests.cpp",
-        "GfxstreamEnd2EndVkSnapshotBasicTests.cpp",
-        "GfxstreamEnd2EndVkSnapshotBufferTests.cpp",
-        "GfxstreamEnd2EndVkSnapshotImageTests.cpp",
-        "GfxstreamEnd2EndVkSnapshotPipelineTests.cpp",
         "KumquatInstance.cpp",
     ],
     header_libs: [
diff --git a/common/end2end/GfxstreamEnd2EndTestUtils.cpp b/common/end2end/GfxstreamEnd2EndTestUtils.cpp
index 6355e932d..fe5cf3032 100644
--- a/common/end2end/GfxstreamEnd2EndTestUtils.cpp
+++ b/common/end2end/GfxstreamEnd2EndTestUtils.cpp
@@ -14,6 +14,8 @@
 
 #include "GfxstreamEnd2EndTestUtils.h"
 
+#include <random>
+#include <vector>
 namespace gfxstream {
 namespace tests {
 namespace utils {
@@ -175,6 +177,18 @@ void readImageData(vkhpp::Image image, uint32_t width, uint32_t height,
     device->unmapMemory(*readbackBufferMemory);
 }
 
+std::vector<uint8_t> getRandomNByteData(size_t len) {
+    std::vector<uint8_t> randomData(len);
+    std::random_device rd;
+    std::mt19937 gen(rd());
+    std::uniform_int_distribution<> distrib(0, 255);  // Generate values from 0 to 255
+    for (auto& byte : randomData) {
+        byte = static_cast<uint8_t>(distrib(gen));
+    }
+    // std::vector is move capable so optimal to return by value.
+    return randomData;
+}
+
 }  // namespace utils
 }  // namespace tests
 }  // namespace gfxstream
\ No newline at end of file
diff --git a/common/end2end/GfxstreamEnd2EndTestUtils.h b/common/end2end/GfxstreamEnd2EndTestUtils.h
index 063ba7ab0..9800d05dd 100644
--- a/common/end2end/GfxstreamEnd2EndTestUtils.h
+++ b/common/end2end/GfxstreamEnd2EndTestUtils.h
@@ -26,6 +26,9 @@ uint32_t getMemoryType(const vkhpp::PhysicalDevice& physicalDevice,
 void readImageData(vkhpp::Image image, uint32_t width, uint32_t height,
                    vkhpp::ImageLayout currentLayout, void* dst, uint64_t dstSize,
                    const GfxstreamEnd2EndTest::TypicalVkTestEnvironment& testEnvironment);
+
+std::vector<uint8_t> getRandomNByteData(size_t len);
+
 }  // namespace utils
 }  // namespace tests
 }  // namespace gfxstream
diff --git a/common/end2end/GfxstreamEnd2EndVkSnapshotBasicTests.cpp b/common/end2end/GfxstreamEnd2EndVkSnapshotBasicTests.cpp
deleted file mode 100644
index ab30da8aa..000000000
--- a/common/end2end/GfxstreamEnd2EndVkSnapshotBasicTests.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (C) 2023 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <string>
-
-#include "GfxstreamEnd2EndTests.h"
-
-namespace gfxstream {
-namespace tests {
-namespace {
-
-class GfxstreamEnd2EndVkSnapshotBasicTest : public GfxstreamEnd2EndTest {};
-
-TEST_P(GfxstreamEnd2EndVkSnapshotBasicTest, BasicSaveLoad) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    SnapshotSaveAndLoad();
-}
-
-INSTANTIATE_TEST_CASE_P(GfxstreamEnd2EndTests, GfxstreamEnd2EndVkSnapshotBasicTest,
-                        ::testing::ValuesIn({
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                        }),
-                        &GetTestName);
-
-}  // namespace
-}  // namespace tests
-}  // namespace gfxstream
\ No newline at end of file
diff --git a/common/end2end/GfxstreamEnd2EndVkSnapshotBufferTests.cpp b/common/end2end/GfxstreamEnd2EndVkSnapshotBufferTests.cpp
deleted file mode 100644
index 941b33418..000000000
--- a/common/end2end/GfxstreamEnd2EndVkSnapshotBufferTests.cpp
+++ /dev/null
@@ -1,293 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <string>
-
-#include "GfxstreamEnd2EndTestUtils.h"
-#include "GfxstreamEnd2EndTests.h"
-
-namespace gfxstream {
-namespace tests {
-namespace {
-
-using testing::Eq;
-using testing::Ge;
-using testing::IsEmpty;
-using testing::IsNull;
-using testing::Not;
-using testing::NotNull;
-
-class GfxstreamEnd2EndVkSnapshotBufferTest : public GfxstreamEnd2EndTest {};
-
-TEST_P(GfxstreamEnd2EndVkSnapshotBufferTest, DeviceLocalBufferContent) {
-    static constexpr vkhpp::DeviceSize kSize = 256;
-
-    std::vector<uint8_t> srcBufferContent(kSize);
-    for (size_t i = 0; i < kSize; i++) {
-        srcBufferContent[i] = static_cast<uint8_t>(i & 0xff);
-    }
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    // Staging buffer
-    const vkhpp::BufferCreateInfo stagingBufferCreateInfo = {
-        .size = static_cast<VkDeviceSize>(kSize),
-        .usage = vkhpp::BufferUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto stagingBuffer = device->createBufferUnique(stagingBufferCreateInfo).value;
-    ASSERT_THAT(stagingBuffer, IsValidHandle());
-
-    vkhpp::MemoryRequirements stagingBufferMemoryRequirements{};
-    device->getBufferMemoryRequirements(*stagingBuffer, &stagingBufferMemoryRequirements);
-
-    const auto stagingBufferMemoryType = utils::getMemoryType(
-        physicalDevice, stagingBufferMemoryRequirements,
-        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
-
-    // Staging memory
-    const vkhpp::MemoryAllocateInfo stagingBufferMemoryAllocateInfo = {
-        .allocationSize = stagingBufferMemoryRequirements.size,
-        .memoryTypeIndex = stagingBufferMemoryType,
-    };
-    auto stagingBufferMemory = device->allocateMemoryUnique(stagingBufferMemoryAllocateInfo).value;
-    ASSERT_THAT(stagingBufferMemory, IsValidHandle());
-    ASSERT_THAT(device->bindBufferMemory(*stagingBuffer, *stagingBufferMemory, 0), IsVkSuccess());
-
-    // Fill memory content
-    void* mapped = nullptr;
-    auto mapResult =
-        device->mapMemory(*stagingBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{}, &mapped);
-    ASSERT_THAT(mapResult, IsVkSuccess());
-    ASSERT_THAT(mapped, NotNull());
-
-    auto* bytes = reinterpret_cast<uint8_t*>(mapped);
-    std::memcpy(bytes, srcBufferContent.data(), kSize);
-
-    const vkhpp::MappedMemoryRange range = {
-        .memory = *stagingBufferMemory,
-        .offset = 0,
-        .size = kSize,
-    };
-    device->unmapMemory(*stagingBufferMemory);
-
-    // Vertex buffer
-    const vkhpp::BufferCreateInfo vertexBufferCreateInfo = {
-        .size = static_cast<VkDeviceSize>(kSize),
-        .usage = vkhpp::BufferUsageFlagBits::eVertexBuffer |
-                 vkhpp::BufferUsageFlagBits::eTransferSrc |
-                 vkhpp::BufferUsageFlagBits::eTransferDst,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto vertexBuffer = device->createBufferUnique(vertexBufferCreateInfo).value;
-    ASSERT_THAT(vertexBuffer, IsValidHandle());
-
-    vkhpp::MemoryRequirements vertexBufferMemoryRequirements{};
-    device->getBufferMemoryRequirements(*vertexBuffer, &vertexBufferMemoryRequirements);
-
-    const auto vertexBufferMemoryType =
-        utils::getMemoryType(physicalDevice, vertexBufferMemoryRequirements,
-                             vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-
-    // Vertex memory
-    const vkhpp::MemoryAllocateInfo vertexBufferMemoryAllocateInfo = {
-        .allocationSize = vertexBufferMemoryRequirements.size,
-        .memoryTypeIndex = vertexBufferMemoryType,
-    };
-    auto vertexBufferMemory = device->allocateMemoryUnique(vertexBufferMemoryAllocateInfo).value;
-    ASSERT_THAT(vertexBufferMemory, IsValidHandle());
-    ASSERT_THAT(device->bindBufferMemory(*vertexBuffer, *vertexBufferMemory, 0), IsVkSuccess());
-
-    // Command buffer
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::BufferCopy bufferCopy = {
-        .size = kSize,
-    };
-    commandBuffer->copyBuffer(*stagingBuffer, *vertexBuffer, 1, &bufferCopy);
-    commandBuffer->end();
-
-    auto transferFence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(transferFence, IsValidHandle());
-
-    // Execute the command to copy image
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer.get(),
-    };
-    queue.submit(submitInfo, *transferFence);
-
-    auto waitResult = device->waitForFences(*transferFence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-
-    // Snapshot
-    SnapshotSaveAndLoad();
-
-    // Read-back buffer
-    const vkhpp::BufferCreateInfo readbackBufferCreateInfo = {
-        .size = static_cast<VkDeviceSize>(kSize),
-        .usage = vkhpp::BufferUsageFlagBits::eTransferDst,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto readbackBuffer = device->createBufferUnique(readbackBufferCreateInfo).value;
-    ASSERT_THAT(readbackBuffer, IsValidHandle());
-
-    vkhpp::MemoryRequirements readbackBufferMemoryRequirements{};
-    device->getBufferMemoryRequirements(*readbackBuffer, &readbackBufferMemoryRequirements);
-
-    const auto readbackBufferMemoryType = utils::getMemoryType(
-        physicalDevice, readbackBufferMemoryRequirements,
-        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
-
-    // Read-back memory
-    const vkhpp::MemoryAllocateInfo readbackBufferMemoryAllocateInfo = {
-        .allocationSize = readbackBufferMemoryRequirements.size,
-        .memoryTypeIndex = readbackBufferMemoryType,
-    };
-    auto readbackBufferMemory =
-        device->allocateMemoryUnique(readbackBufferMemoryAllocateInfo).value;
-    ASSERT_THAT(readbackBufferMemory, IsValidHandle());
-    ASSERT_THAT(device->bindBufferMemory(*readbackBuffer, *readbackBufferMemory, 0), IsVkSuccess());
-
-    auto readbackCommandBuffers =
-        device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(readbackCommandBuffers, Not(IsEmpty()));
-    auto readbackCommandBuffer = std::move(readbackCommandBuffers[0]);
-    ASSERT_THAT(readbackCommandBuffer, IsValidHandle());
-
-    readbackCommandBuffer->begin(commandBufferBeginInfo);
-    readbackCommandBuffer->copyBuffer(*vertexBuffer, *readbackBuffer, 1, &bufferCopy);
-    readbackCommandBuffer->end();
-
-    auto readbackFence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(readbackCommandBuffer, IsValidHandle());
-
-    // Execute the command to copy image back to buffer
-    const vkhpp::SubmitInfo readbackSubmitInfo = {
-        .commandBufferCount = 1,
-        .pCommandBuffers = &readbackCommandBuffer.get(),
-    };
-    queue.submit(readbackSubmitInfo, *readbackFence);
-
-    auto readbackWaitResult = device->waitForFences(*readbackFence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(readbackWaitResult, IsVkSuccess());
-
-    // Verify content
-    mapResult = device->mapMemory(*readbackBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{},
-                                  &mapped);
-    ASSERT_THAT(mapResult, IsVkSuccess());
-    ASSERT_THAT(mapped, NotNull());
-    bytes = reinterpret_cast<uint8_t*>(mapped);
-
-    for (uint32_t i = 0; i < kSize; ++i) {
-        ASSERT_THAT(bytes[i], Eq(srcBufferContent[i]));
-    }
-    device->unmapMemory(*readbackBufferMemory);
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotBufferTest, HostVisibleBufferContent) {
-    static constexpr vkhpp::DeviceSize kSize = 256;
-
-    std::vector<uint8_t> srcBufferContent(kSize);
-    for (size_t i = 0; i < kSize; i++) {
-        srcBufferContent[i] = static_cast<uint8_t>(i & 0xff);
-    }
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    // Vertex buffer
-    const vkhpp::BufferCreateInfo uniformBufferCreateInfo = {
-        .size = static_cast<VkDeviceSize>(kSize),
-        .usage = vkhpp::BufferUsageFlagBits::eUniformBuffer,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto uniformBuffer = device->createBufferUnique(uniformBufferCreateInfo).value;
-    ASSERT_THAT(uniformBuffer, IsValidHandle());
-
-    vkhpp::MemoryRequirements uniformBufferMemoryRequirements{};
-    device->getBufferMemoryRequirements(*uniformBuffer, &uniformBufferMemoryRequirements);
-
-    const auto uniformBufferMemoryType = utils::getMemoryType(
-        physicalDevice, uniformBufferMemoryRequirements,
-        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
-
-    // Vertex memory
-    const vkhpp::MemoryAllocateInfo uniformBufferMemoryAllocateInfo = {
-        .allocationSize = uniformBufferMemoryRequirements.size,
-        .memoryTypeIndex = uniformBufferMemoryType,
-    };
-    auto uniformBufferMemory = device->allocateMemoryUnique(uniformBufferMemoryAllocateInfo).value;
-    ASSERT_THAT(uniformBufferMemory, IsValidHandle());
-    ASSERT_THAT(device->bindBufferMemory(*uniformBuffer, *uniformBufferMemory, 0), IsVkSuccess());
-
-    // Fill memory content
-    void* mapped = nullptr;
-    auto mapResult =
-        device->mapMemory(*uniformBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{}, &mapped);
-    ASSERT_THAT(mapResult, IsVkSuccess());
-    ASSERT_THAT(mapped, NotNull());
-
-    auto* bytes = reinterpret_cast<uint8_t*>(mapped);
-    std::memcpy(bytes, srcBufferContent.data(), kSize);
-
-    device->unmapMemory(*uniformBufferMemory);
-
-    // We need to unmap before snapshot due to limitations of the testing framework.
-    SnapshotSaveAndLoad();
-
-    // Verify content
-    mapResult =
-        device->mapMemory(*uniformBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{}, &mapped);
-    ASSERT_THAT(mapResult, IsVkSuccess());
-    ASSERT_THAT(mapped, NotNull());
-    bytes = reinterpret_cast<uint8_t*>(mapped);
-
-    for (uint32_t i = 0; i < kSize; ++i) {
-        ASSERT_THAT(bytes[i], Eq(srcBufferContent[i]));
-    }
-    device->unmapMemory(*uniformBufferMemory);
-}
-
-INSTANTIATE_TEST_CASE_P(GfxstreamEnd2EndTests, GfxstreamEnd2EndVkSnapshotBufferTest,
-                        ::testing::ValuesIn({
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                        }),
-                        &GetTestName);
-
-}  // namespace
-}  // namespace tests
-}  // namespace gfxstream
diff --git a/common/end2end/GfxstreamEnd2EndVkSnapshotImageTests.cpp b/common/end2end/GfxstreamEnd2EndVkSnapshotImageTests.cpp
deleted file mode 100644
index a32b32cef..000000000
--- a/common/end2end/GfxstreamEnd2EndVkSnapshotImageTests.cpp
+++ /dev/null
@@ -1,621 +0,0 @@
-// Copyright (C) 2023 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <string>
-
-#include "GfxstreamEnd2EndTestUtils.h"
-#include "GfxstreamEnd2EndTests.h"
-
-namespace gfxstream {
-namespace tests {
-namespace {
-
-using testing::Eq;
-using testing::Ge;
-using testing::IsEmpty;
-using testing::IsNull;
-using testing::Not;
-using testing::NotNull;
-
-class GfxstreamEnd2EndVkSnapshotImageTest : public GfxstreamEnd2EndTest {};
-
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, PreserveImageHandle) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eSampled | vkhpp::ImageUsageFlagBits::eTransferDst |
-                 vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    SnapshotSaveAndLoad();
-
-    ASSERT_THAT(device->bindImageMemory(*image, *imageMemory, 0), IsVkSuccess());
-}
-
-// b/346415931
-// We used to have an issue that the handles mismatch when running more device
-// create calls. The first device always work but the second might break.
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, MultipleDevicesPreserveHandles) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    uint32_t graphicsQueueFamilyIndex = -1;
-    {
-        const auto props = physicalDevice.getQueueFamilyProperties();
-        for (uint32_t i = 0; i < props.size(); i++) {
-            const auto& prop = props[i];
-            if (prop.queueFlags & vkhpp::QueueFlagBits::eGraphics) {
-                graphicsQueueFamilyIndex = i;
-                break;
-            }
-        }
-    }
-    ASSERT_THAT(graphicsQueueFamilyIndex, Not(Eq(-1)));
-    const float queuePriority = 1.0f;
-    const vkhpp::DeviceQueueCreateInfo deviceQueueCreateInfo = {
-        .queueFamilyIndex = graphicsQueueFamilyIndex,
-        .queueCount = 1,
-        .pQueuePriorities = &queuePriority,
-    };
-    std::vector<const char*> deviceExtensions = {
-        VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME,
-        VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,
-    };
-    const vkhpp::DeviceCreateInfo deviceCreateInfo = {
-        .pNext = nullptr,
-        .pQueueCreateInfos = &deviceQueueCreateInfo,
-        .queueCreateInfoCount = 1,
-        .enabledLayerCount = 0,
-        .ppEnabledLayerNames = nullptr,
-        .enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()),
-        .ppEnabledExtensionNames = deviceExtensions.data(),
-    };
-    auto device2 = physicalDevice.createDeviceUnique(deviceCreateInfo).value;
-    ASSERT_THAT(device2, IsValidHandle());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eSampled | vkhpp::ImageUsageFlagBits::eTransferDst |
-                 vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    ASSERT_THAT(device->bindImageMemory(*image, *imageMemory, 0), IsVkSuccess());
-
-    // No device lost on snapshot load.
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, ImageViewDependency) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eSampled | vkhpp::ImageUsageFlagBits::eTransferDst |
-                 vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-    ASSERT_THAT(image, IsValidHandle());
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    ASSERT_THAT(device->bindImageMemory(*image, *imageMemory, 0), IsVkSuccess());
-
-    // b/331677615
-    // Create and delete a buffer handle right before creating image view.
-    // Gfxstream recycle handles. We trick the VkImageView handle to collide with
-    // a destroyed buffer handle and verify there is no bug snapshotting recycled
-    // handles.
-    const vkhpp::BufferCreateInfo bufferCreateInfo = {
-        .size = 1024,
-        .usage = vkhpp::BufferUsageFlagBits::eTransferSrc,
-    };
-    auto buffer = device->createBufferUnique(bufferCreateInfo).value;
-    ASSERT_THAT(buffer, IsValidHandle());
-    buffer.reset();
-
-    const vkhpp::ImageViewCreateInfo imageViewCreateInfo = {
-        .image = *image,
-        .viewType = vkhpp::ImageViewType::e2D,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .baseMipLevel = 0,
-                .levelCount = 1,
-                .baseArrayLayer = 0,
-                .layerCount = 1,
-            },
-    };
-    auto imageView = device->createImageViewUnique(imageViewCreateInfo).value;
-    ASSERT_THAT(imageView, IsValidHandle());
-    // Make sure it doesn't crash on load
-    SnapshotSaveAndLoad();
-}
-
-// Use vkBindImageMemory2 instead of vkBindImageMemory
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, ImageViewDependency2) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eSampled | vkhpp::ImageUsageFlagBits::eTransferDst |
-                 vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-    ASSERT_THAT(image, IsValidHandle());
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    const vkhpp::BindImageMemoryInfo imageBindMemoryInfo = {
-        .pNext = nullptr,
-        .image = *image,
-        .memory = *imageMemory,
-        .memoryOffset = 0,
-    };
-
-    ASSERT_THAT(device->bindImageMemory2({imageBindMemoryInfo}), IsVkSuccess());
-
-    // b/331677615
-    // Create and delete a buffer handle right before creating image view.
-    // Gfxstream recycle handles. We trick the VkImageView handle to collide with
-    // a destroyed buffer handle and verify there is no bug snapshotting recycled
-    // handles.
-    const vkhpp::BufferCreateInfo bufferCreateInfo = {
-        .size = 1024,
-        .usage = vkhpp::BufferUsageFlagBits::eTransferSrc,
-    };
-    auto buffer = device->createBufferUnique(bufferCreateInfo).value;
-    ASSERT_THAT(buffer, IsValidHandle());
-    buffer.reset();
-
-    const vkhpp::ImageViewCreateInfo imageViewCreateInfo = {
-        .image = *image,
-        .viewType = vkhpp::ImageViewType::e2D,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .baseMipLevel = 0,
-                .levelCount = 1,
-                .baseArrayLayer = 0,
-                .layerCount = 1,
-            },
-    };
-    auto imageView = device->createImageViewUnique(imageViewCreateInfo).value;
-    ASSERT_THAT(imageView, IsValidHandle());
-    // Make sure it doesn't crash on load
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, MultiSampleImage) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eColorAttachment |
-                 vkhpp::ImageUsageFlagBits::eTransferDst | vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e8,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-    ASSERT_THAT(image, IsValidHandle());
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    // Make sure it doesn't crash on load
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, ImageViewDependencyWithDedicatedMemory) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-
-    const uint32_t width = 32;
-    const uint32_t height = 32;
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = width,
-        .extent.height = height,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eSampled | vkhpp::ImageUsageFlagBits::eTransferDst |
-                 vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-    ASSERT_THAT(image, IsValidHandle());
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryDedicatedAllocateInfo dedicatedAllocateInfo = {
-        .image = *image,
-    };
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .pNext = &dedicatedAllocateInfo,
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    ASSERT_THAT(device->bindImageMemory(*image, *imageMemory, 0), IsVkSuccess());
-
-    const vkhpp::ImageViewCreateInfo imageViewCreateInfo = {
-        .image = *image,
-        .viewType = vkhpp::ImageViewType::e2D,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .baseMipLevel = 0,
-                .levelCount = 1,
-                .baseArrayLayer = 0,
-                .layerCount = 1,
-            },
-    };
-    auto imageView = device->createImageViewUnique(imageViewCreateInfo).value;
-    ASSERT_THAT(imageView, IsValidHandle());
-    // Make sure it doesn't crash on load
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotImageTest, ImageContent) {
-    static constexpr int kWidth = 256;
-    static constexpr int kHeight = 256;
-    static constexpr vkhpp::DeviceSize kSize = 4 * kWidth * kHeight;
-
-    std::vector<uint8_t> srcBufferContent(kSize);
-    for (size_t i = 0; i < kSize; i++) {
-        srcBufferContent[i] = static_cast<uint8_t>(i & 0xff);
-    }
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& instance = testEnvironment.instance;
-    auto& physicalDevice = testEnvironment.physicalDevice;
-    auto& device = testEnvironment.device;
-    auto& queue = testEnvironment.queue;
-    auto queueFamilyIndex = testEnvironment.queueFamilyIndex;
-
-    // Staging buffer
-    const vkhpp::BufferCreateInfo bufferCreateInfo = {
-        .size = static_cast<VkDeviceSize>(kSize),
-        .usage = vkhpp::BufferUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto stagingBuffer = device->createBufferUnique(bufferCreateInfo).value;
-    ASSERT_THAT(stagingBuffer, IsValidHandle());
-
-    vkhpp::MemoryRequirements stagingBufferMemoryRequirements{};
-    device->getBufferMemoryRequirements(*stagingBuffer, &stagingBufferMemoryRequirements);
-
-    const auto stagingBufferMemoryType = utils::getMemoryType(
-        physicalDevice, stagingBufferMemoryRequirements,
-        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
-
-    // Staging memory
-    const vkhpp::MemoryAllocateInfo stagingBufferMemoryAllocateInfo = {
-        .allocationSize = stagingBufferMemoryRequirements.size,
-        .memoryTypeIndex = stagingBufferMemoryType,
-    };
-    auto stagingBufferMemory = device->allocateMemoryUnique(stagingBufferMemoryAllocateInfo).value;
-    ASSERT_THAT(stagingBufferMemory, IsValidHandle());
-    ASSERT_THAT(device->bindBufferMemory(*stagingBuffer, *stagingBufferMemory, 0), IsVkSuccess());
-
-    // Fill memory content
-    void* mapped = nullptr;
-    auto mapResult =
-        device->mapMemory(*stagingBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{}, &mapped);
-    ASSERT_THAT(mapResult, IsVkSuccess());
-    ASSERT_THAT(mapped, NotNull());
-
-    auto* bytes = reinterpret_cast<uint8_t*>(mapped);
-    std::memcpy(bytes, srcBufferContent.data(), kSize);
-
-    const vkhpp::MappedMemoryRange range = {
-        .memory = *stagingBufferMemory,
-        .offset = 0,
-        .size = kSize,
-    };
-    device->unmapMemory(*stagingBufferMemory);
-
-    // Image
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = kWidth,
-        .extent.height = kHeight,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::ePreinitialized,
-        .usage = vkhpp::ImageUsageFlagBits::eTransferDst | vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = vkhpp::SampleCountFlagBits::e1,
-    };
-    auto image = device->createImageUnique(imageCreateInfo).value;
-    ASSERT_THAT(image, IsValidHandle());
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device->getImageMemoryRequirements(*image, &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-    ASSERT_THAT(imageMemoryIndex, Not(Eq(-1)));
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    auto imageMemory = device->allocateMemoryUnique(imageMemoryAllocateInfo).value;
-    ASSERT_THAT(imageMemory, IsValidHandle());
-
-    ASSERT_THAT(device->bindImageMemory(*image, *imageMemory, 0), IsVkSuccess());
-
-    // Command buffer
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-    commandBuffer->begin(commandBufferBeginInfo);
-
-    const vkhpp::ImageMemoryBarrier barrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eTransferDstOptimal,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(vkhpp::PipelineStageFlagBits::eAllCommands,
-                                   vkhpp::PipelineStageFlagBits::eAllCommands,
-                                   vkhpp::DependencyFlags(), nullptr, nullptr, barrier);
-
-    const vkhpp::BufferImageCopy bufferImageCopy = {
-        .imageSubresource =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .layerCount = 1,
-            },
-        .imageExtent =
-            {
-                .width = kWidth,
-                .height = kHeight,
-                .depth = 1,
-            },
-    };
-    commandBuffer->copyBufferToImage(*stagingBuffer, *image,
-                                     vkhpp::ImageLayout::eTransferDstOptimal, 1, &bufferImageCopy);
-
-    commandBuffer->end();
-
-    auto transferFence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(transferFence, IsValidHandle());
-
-    // Execute the command to copy image
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer.get(),
-    };
-    queue.submit(submitInfo, *transferFence);
-
-    auto waitResult = device->waitForFences(*transferFence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-
-    // Snapshot
-    SnapshotSaveAndLoad();
-
-    std::vector<uint8_t> dst(kSize);
-    utils::readImageData(*image, kWidth, kHeight, vkhpp::ImageLayout::eTransferDstOptimal,
-                         dst.data(), kSize, testEnvironment);
-
-    for (uint32_t i = 0; i < kSize; ++i) {
-        ASSERT_THAT(dst[i], Eq(srcBufferContent[i]));
-    }
-}
-
-INSTANTIATE_TEST_CASE_P(GfxstreamEnd2EndTests, GfxstreamEnd2EndVkSnapshotImageTest,
-                        ::testing::ValuesIn({
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                        }),
-                        &GetTestName);
-
-}  // namespace
-}  // namespace tests
-}  // namespace gfxstream
diff --git a/common/end2end/GfxstreamEnd2EndVkSnapshotPipelineTests.cpp b/common/end2end/GfxstreamEnd2EndVkSnapshotPipelineTests.cpp
deleted file mode 100644
index c2774474c..000000000
--- a/common/end2end/GfxstreamEnd2EndVkSnapshotPipelineTests.cpp
+++ /dev/null
@@ -1,1290 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <string>
-
-#include "GfxstreamEnd2EndTestUtils.h"
-#include "GfxstreamEnd2EndTests.h"
-#include "shaders/simple_shader_frag.h"
-#include "shaders/simple_shader_vert.h"
-
-namespace gfxstream {
-namespace tests {
-namespace {
-
-using testing::Eq;
-using testing::Ge;
-using testing::IsEmpty;
-using testing::IsNull;
-using testing::Not;
-using testing::NotNull;
-
-struct PipelineInfo {
-    vkhpp::UniqueRenderPass renderPass;
-    vkhpp::UniqueDescriptorSetLayout descriptorSetLayout;
-    vkhpp::UniquePipelineLayout pipelineLayout;
-    vkhpp::UniqueShaderModule vertexShaderModule;
-    vkhpp::UniqueShaderModule fragmentShaderModule;
-    vkhpp::UniquePipeline pipeline;
-};
-
-struct ImageInfo {
-    vkhpp::UniqueImage image;
-    vkhpp::UniqueDeviceMemory memory;
-    vkhpp::UniqueImageView imageView;
-};
-
-struct BufferInfo {
-    vkhpp::UniqueBuffer buffer;
-    vkhpp::UniqueDeviceMemory memory;
-};
-
-class GfxstreamEnd2EndVkSnapshotPipelineTest : public GfxstreamEnd2EndTest {
-   protected:
-    vkhpp::UniqueRenderPass createRenderPass(vkhpp::Device device);
-    std::unique_ptr<ImageInfo> createColorAttachment(vkhpp::PhysicalDevice physicalDevice,
-                                                     vkhpp::Device device);
-    std::unique_ptr<PipelineInfo> createPipeline(vkhpp::Device device);
-    Result<BufferInfo> createAndPopulateBuffer(vkhpp::PhysicalDevice physicalDevice,
-                                               vkhpp::Device device, vkhpp::BufferUsageFlags usage,
-                                               const void* data, uint64_t dataSize);
-    static const uint32_t kFbWidth = 32;
-    static const uint32_t kFbHeight = 32;
-};
-
-class GfxstreamEnd2EndVkSnapshotPipelineWithMultiSamplingTest
-    : public GfxstreamEnd2EndVkSnapshotPipelineTest {};
-
-template <typename DurationType>
-constexpr uint64_t AsVkTimeout(DurationType duration) {
-    return static_cast<uint64_t>(
-        std::chrono::duration_cast<std::chrono::nanoseconds>(duration).count());
-}
-
-// Full screen blue rectangle
-const float kFullscreenBlueRectangleVertexData[] = {
-    // clang-format off
-    /*pos=*/ -1.0f, -1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    /*pos=*/  1.0f, -1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    /*pos=*/  1.0f,  1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    /*pos=*/  1.0f,  1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    /*pos=*/ -1.0f,  1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    /*pos=*/ -1.0f, -1.0f, 0.0f, 1.0f, /*color=*/ 0.0f,  0.0f,  1.0f, 1.0f,
-    // clang-format on
-};
-
-Result<BufferInfo> GfxstreamEnd2EndVkSnapshotPipelineTest::createAndPopulateBuffer(
-    vkhpp::PhysicalDevice physicalDevice, vkhpp::Device device, vkhpp::BufferUsageFlags usage,
-    const void* data, uint64_t dataSize) {
-    const vkhpp::BufferCreateInfo vertexBufferCreateInfo = {
-        .size = dataSize,
-        .usage = usage,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-    };
-    auto vertexBuffer =
-        GFXSTREAM_EXPECT_VKHPP_RV(device.createBufferUnique(vertexBufferCreateInfo));
-
-    vkhpp::MemoryRequirements vertexBufferMemoryRequirements{};
-    device.getBufferMemoryRequirements(*vertexBuffer, &vertexBufferMemoryRequirements);
-
-    const auto vertexBufferMemoryType = utils::getMemoryType(
-        physicalDevice, vertexBufferMemoryRequirements,
-        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
-    if (vertexBufferMemoryType == -1) {
-        return gfxstream::unexpected("Failed to allocate buffer memory.");
-    }
-    // Vertex memory
-    const vkhpp::MemoryAllocateInfo vertexBufferMemoryAllocateInfo = {
-        .allocationSize = vertexBufferMemoryRequirements.size,
-        .memoryTypeIndex = vertexBufferMemoryType,
-    };
-    auto vertexBufferMemory =
-        GFXSTREAM_EXPECT_VKHPP_RV(device.allocateMemoryUnique(vertexBufferMemoryAllocateInfo));
-    device.bindBufferMemory(*vertexBuffer, *vertexBufferMemory, 0);
-    void* mapped;
-    device.mapMemory(*vertexBufferMemory, 0, VK_WHOLE_SIZE, vkhpp::MemoryMapFlags{}, &mapped);
-    memcpy(mapped, data, dataSize);
-    device.unmapMemory(*vertexBufferMemory);
-
-    BufferInfo res;
-    res.buffer = std::move(vertexBuffer);
-    res.memory = std::move(vertexBufferMemory);
-    return res;
-}
-
-vkhpp::UniqueRenderPass GfxstreamEnd2EndVkSnapshotPipelineTest::createRenderPass(
-    vkhpp::Device device) {
-    vkhpp::AttachmentDescription colorAttachmentDescription = {
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .samples = static_cast<vkhpp::SampleCountFlagBits>(GetParam().samples),
-        .loadOp = vkhpp::AttachmentLoadOp::eLoad,
-        .storeOp = vkhpp::AttachmentStoreOp::eStore,
-        .initialLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .finalLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-    };
-    vkhpp::AttachmentReference attachmentReference = {
-        .attachment = 0,
-        .layout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-    };
-    vkhpp::SubpassDescription subpassDescription = {
-        .colorAttachmentCount = 1,
-        .pColorAttachments = &attachmentReference,
-    };
-    vkhpp::RenderPassCreateInfo renderPassCreateInfo = {
-        .attachmentCount = 1,
-        .pAttachments = &colorAttachmentDescription,
-        .subpassCount = 1,
-        .pSubpasses = &subpassDescription,
-    };
-    return device.createRenderPassUnique(renderPassCreateInfo).value;
-}
-
-std::unique_ptr<PipelineInfo> GfxstreamEnd2EndVkSnapshotPipelineTest::createPipeline(
-    vkhpp::Device device) {
-    std::unique_ptr<PipelineInfo> res(new PipelineInfo);
-    res->renderPass = createRenderPass(device);
-
-    vkhpp::DescriptorSetLayoutBinding bindings[1] = {
-        {
-            .binding = 0,
-            .descriptorType = vkhpp::DescriptorType::eUniformBuffer,
-            .descriptorCount = 1,
-            .stageFlags = vkhpp::ShaderStageFlagBits::eFragment,
-        },
-    };
-    vkhpp::DescriptorSetLayoutCreateInfo descriptorSetLayoutInfo = {
-        .bindingCount = 1,
-        .pBindings = bindings,
-    };
-    res->descriptorSetLayout =
-        device.createDescriptorSetLayoutUnique(descriptorSetLayoutInfo).value;
-    res->pipelineLayout = device
-                              .createPipelineLayoutUnique(vkhpp::PipelineLayoutCreateInfo{
-                                  .setLayoutCount = 1,
-                                  .pSetLayouts = &res->descriptorSetLayout.get(),
-                              })
-                              .value;
-
-    vkhpp::ShaderModuleCreateInfo vertexShaderModuleCreateInfo = {
-        .codeSize = kSimpleShaderVert.size() * sizeof(uint32_t),
-        .pCode = kSimpleShaderVert.data(),
-    };
-    vkhpp::ShaderModuleCreateInfo fragmentShaderModuleCreateInfo = {
-        .codeSize = kSimpleShaderFrag.size() * sizeof(uint32_t),
-        .pCode = kSimpleShaderFrag.data(),
-    };
-    res->vertexShaderModule = device.createShaderModuleUnique(vertexShaderModuleCreateInfo).value;
-    res->fragmentShaderModule =
-        device.createShaderModuleUnique(fragmentShaderModuleCreateInfo).value;
-
-    vkhpp::PipelineShaderStageCreateInfo pipelineShaderStageCreateInfos[2] = {
-        {
-            .stage = vkhpp::ShaderStageFlagBits::eVertex,
-            .module = *(res->vertexShaderModule),
-            .pName = "main",
-        },
-        {
-            .stage = vkhpp::ShaderStageFlagBits::eFragment,
-            .module = *(res->fragmentShaderModule),
-            .pName = "main",
-        },
-    };
-
-    const vkhpp::VertexInputBindingDescription vertexInputBindingDescription = {
-        .stride = 32,
-    };
-    vkhpp::VertexInputAttributeDescription vertexInputAttributeDescriptions[2] = {
-        {
-            .location = 0,
-            .format = vkhpp::Format::eR32G32B32A32Sfloat,
-            .offset = 0,
-        },
-        {
-            .location = 1,
-            .format = vkhpp::Format::eR32G32B32A32Sfloat,
-            .offset = 16,
-        },
-    };
-    const vkhpp::PipelineVertexInputStateCreateInfo pipelineVertexInputStateCreateInfo = {
-        .vertexBindingDescriptionCount = 1,
-        .pVertexBindingDescriptions = &vertexInputBindingDescription,
-        .vertexAttributeDescriptionCount = 2,
-        .pVertexAttributeDescriptions = vertexInputAttributeDescriptions,
-    };
-
-    const vkhpp::PipelineInputAssemblyStateCreateInfo pipelineInputAssemblyStateCreateInfo = {
-        .topology = vkhpp::PrimitiveTopology::eTriangleList,
-    };
-
-    const vkhpp::PipelineViewportStateCreateInfo pipelineViewportStateCreateInfo = {
-        .viewportCount = 1,
-        .scissorCount = 1,
-    };
-
-    const vkhpp::PipelineRasterizationStateCreateInfo pipelineRasterizationStateCreateInfo = {
-        .cullMode = vkhpp::CullModeFlagBits::eNone,
-        .lineWidth = 1.0f,
-    };
-
-    const vkhpp::PipelineMultisampleStateCreateInfo pipelineMultisampleStateCreateInfo = {
-        .rasterizationSamples = static_cast<vkhpp::SampleCountFlagBits>(GetParam().samples),
-    };
-    const vkhpp::PipelineDepthStencilStateCreateInfo pipelineDepthStencilStateCreateInfo = {};
-    const vkhpp::PipelineColorBlendAttachmentState pipelineColorBlendAttachmentState = {
-        .colorBlendOp = vkhpp::BlendOp::eAdd,
-        .srcAlphaBlendFactor = vkhpp::BlendFactor::eZero,
-        .dstAlphaBlendFactor = vkhpp::BlendFactor::eZero,
-        .alphaBlendOp = vkhpp::BlendOp::eAdd,
-        .colorWriteMask = vkhpp::ColorComponentFlagBits::eR | vkhpp::ColorComponentFlagBits::eG |
-                          vkhpp::ColorComponentFlagBits::eB | vkhpp::ColorComponentFlagBits::eA};
-    const vkhpp::PipelineColorBlendStateCreateInfo pipelineColorBlendStateCreateInfo = {
-        .attachmentCount = 1,
-        .pAttachments = &pipelineColorBlendAttachmentState,
-    };
-    const vkhpp::DynamicState dynamicStates[2] = {vkhpp::DynamicState::eViewport,
-                                                  vkhpp::DynamicState::eScissor};
-    const vkhpp::PipelineDynamicStateCreateInfo pipelineDynamicStateCreateInfo = {
-        .dynamicStateCount = 2,
-        .pDynamicStates = dynamicStates,
-    };
-
-    vkhpp::GraphicsPipelineCreateInfo graphicsPipelineCreateInfo = {
-        .stageCount = 2,
-        .pStages = pipelineShaderStageCreateInfos,
-        .pVertexInputState = &pipelineVertexInputStateCreateInfo,
-        .pInputAssemblyState = &pipelineInputAssemblyStateCreateInfo,
-        .pViewportState = &pipelineViewportStateCreateInfo,
-        .pRasterizationState = &pipelineRasterizationStateCreateInfo,
-        .pMultisampleState = &pipelineMultisampleStateCreateInfo,
-        .pDepthStencilState = &pipelineDepthStencilStateCreateInfo,
-        .pColorBlendState = &pipelineColorBlendStateCreateInfo,
-        .pDynamicState = &pipelineDynamicStateCreateInfo,
-        .layout = *(res->pipelineLayout),
-        .renderPass = *(res->renderPass),
-    };
-
-    res->pipeline = device.createGraphicsPipelineUnique(nullptr, graphicsPipelineCreateInfo).value;
-
-    return res;
-}
-
-std::unique_ptr<ImageInfo> GfxstreamEnd2EndVkSnapshotPipelineTest::createColorAttachment(
-    vkhpp::PhysicalDevice physicalDevice, vkhpp::Device device) {
-    std::unique_ptr<ImageInfo> res(new ImageInfo);
-
-    const vkhpp::ImageCreateInfo imageCreateInfo = {
-        .pNext = nullptr,
-        .imageType = vkhpp::ImageType::e2D,
-        .extent.width = kFbWidth,
-        .extent.height = kFbHeight,
-        .extent.depth = 1,
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .tiling = vkhpp::ImageTiling::eOptimal,
-        .initialLayout = vkhpp::ImageLayout::eUndefined,
-        .usage = vkhpp::ImageUsageFlagBits::eColorAttachment | vkhpp::ImageUsageFlagBits::eSampled |
-                 vkhpp::ImageUsageFlagBits::eTransferDst | vkhpp::ImageUsageFlagBits::eTransferSrc,
-        .sharingMode = vkhpp::SharingMode::eExclusive,
-        .samples = static_cast<vkhpp::SampleCountFlagBits>(GetParam().samples),
-    };
-    res->image = device.createImageUnique(imageCreateInfo).value;
-
-    vkhpp::MemoryRequirements imageMemoryRequirements{};
-    device.getImageMemoryRequirements(*(res->image), &imageMemoryRequirements);
-
-    const uint32_t imageMemoryIndex = utils::getMemoryType(
-        physicalDevice, imageMemoryRequirements, vkhpp::MemoryPropertyFlagBits::eDeviceLocal);
-
-    const vkhpp::MemoryAllocateInfo imageMemoryAllocateInfo = {
-        .allocationSize = imageMemoryRequirements.size,
-        .memoryTypeIndex = imageMemoryIndex,
-    };
-
-    res->memory = device.allocateMemoryUnique(imageMemoryAllocateInfo).value;
-
-    device.bindImageMemory(*(res->image), *(res->memory), 0);
-
-    const vkhpp::ImageViewCreateInfo imageViewCreateInfo = {
-        .image = *(res->image),
-        .viewType = vkhpp::ImageViewType::e2D,
-        .format = vkhpp::Format::eR8G8B8A8Unorm,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .baseMipLevel = 0,
-                .levelCount = 1,
-                .baseArrayLayer = 0,
-                .layerCount = 1,
-            },
-    };
-    res->imageView = device.createImageViewUnique(imageViewCreateInfo).value;
-    return res;
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, CanRecreateShaderModule) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto pipelineInfo = createPipeline(device.get());
-    ASSERT_THAT(pipelineInfo->renderPass, IsValidHandle());
-    ASSERT_THAT(pipelineInfo->descriptorSetLayout, IsValidHandle());
-    ASSERT_THAT(pipelineInfo->pipelineLayout, IsValidHandle());
-    ASSERT_THAT(pipelineInfo->vertexShaderModule, IsValidHandle());
-    ASSERT_THAT(pipelineInfo->fragmentShaderModule, IsValidHandle());
-    ASSERT_THAT(pipelineInfo->pipeline, IsValidHandle());
-
-    // Check if snapshot can restore the pipeline even after shaders are destroyed.
-    pipelineInfo->vertexShaderModule.reset();
-    pipelineInfo->fragmentShaderModule.reset();
-
-    SnapshotSaveAndLoad();
-    // Don't crash
-    // TODO(b/330763497): try to render something
-    // TODO(b/330766521): fix dangling shader modules after snapshot load
-}
-
-// vkCreateDescriptorPool injects extra handles into the internal handle map, thus add
-// a test for it.
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, CanSnapshotDescriptorPool) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    std::vector<vkhpp::DescriptorPoolSize> sizes = {
-        {
-            .descriptorCount = 10,
-        },
-    };
-    vkhpp::DescriptorPoolCreateInfo descriptorPoolCreateInfo = {
-        .maxSets = 10,
-        .poolSizeCount = static_cast<uint32_t>(sizes.size()),
-        .pPoolSizes = sizes.data(),
-    };
-    auto descriptorPool0 = device->createDescriptorPoolUnique(descriptorPoolCreateInfo).value;
-    ASSERT_THAT(descriptorPool0, IsValidHandle());
-    auto descriptorPool1 = device->createDescriptorPoolUnique(descriptorPoolCreateInfo).value;
-    ASSERT_THAT(descriptorPool1, IsValidHandle());
-
-    vkhpp::DescriptorSetLayoutCreateInfo descriptorSetLayoutInfo = {};
-    auto descriptorSetLayout =
-        device->createDescriptorSetLayoutUnique(descriptorSetLayoutInfo).value;
-    ASSERT_THAT(descriptorSetLayout, IsValidHandle());
-
-    SnapshotSaveAndLoad();
-
-    const std::vector<vkhpp::DescriptorSetLayout> descriptorSetLayouts(1, *descriptorSetLayout);
-
-    vkhpp::DescriptorSetAllocateInfo descriptorSetAllocateInfo0 = {
-        .descriptorPool = *descriptorPool0,
-        .descriptorSetCount = 1,
-        .pSetLayouts = descriptorSetLayouts.data(),
-    };
-    auto descriptorSets0 = device->allocateDescriptorSetsUnique(descriptorSetAllocateInfo0);
-    EXPECT_THAT(descriptorSets0.result, Eq(vkhpp::Result::eSuccess));
-
-    vkhpp::DescriptorSetAllocateInfo descriptorSetAllocateInfo1 = {
-        .descriptorPool = *descriptorPool1,
-        .descriptorSetCount = 1,
-        .pSetLayouts = descriptorSetLayouts.data(),
-    };
-    auto descriptorSets1 = device->allocateDescriptorSetsUnique(descriptorSetAllocateInfo1);
-    EXPECT_THAT(descriptorSets1.result, Eq(vkhpp::Result::eSuccess));
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, CanSnapshotFramebuffer) {
-    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
-        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto renderPass = createRenderPass(device.get());
-    ASSERT_THAT(renderPass, IsValidHandle());
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineWithMultiSamplingTest, CanSubmitQueue) {
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = testEnvironment;
-
-    auto pipelineInfo = createPipeline(device.get());
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *pipelineInfo->renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    auto fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(fence, IsValidHandle());
-
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .flags = vkhpp::CommandPoolCreateFlagBits::eResetCommandBuffer,
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    vkhpp::ClearColorValue clearColor(std::array<float, 4>{1.0f, 0.0f, 1.0f, 1.0f});
-    vkhpp::ClearValue clearValue{
-        .color = clearColor,
-    };
-    vkhpp::RenderPassBeginInfo renderPassBeginInfo{
-        .renderPass = *pipelineInfo->renderPass,
-        .framebuffer = *framebuffer,
-        .renderArea = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .clearValueCount = 1,
-        .pClearValues = &clearValue,
-    };
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::ImageMemoryBarrier colorAttachmentBarrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .dstAccessMask = vkhpp::AccessFlagBits::eColorAttachmentRead |
-                         vkhpp::AccessFlagBits::eColorAttachmentWrite,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *colorAttachmentInfo->image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(
-        vkhpp::PipelineStageFlagBits::eTopOfPipe | vkhpp::PipelineStageFlagBits::eTransfer,
-        vkhpp::PipelineStageFlagBits::eColorAttachmentOutput, vkhpp::DependencyFlags(), nullptr,
-        nullptr, colorAttachmentBarrier);
-
-    commandBuffer->end();
-
-    std::vector<vkhpp::CommandBuffer> commandBufferHandles;
-    commandBufferHandles.push_back(*commandBuffer);
-
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = static_cast<uint32_t>(commandBufferHandles.size()),
-        .pCommandBuffers = commandBufferHandles.data(),
-    };
-    queue.submit(submitInfo, *fence);
-
-    auto waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-    commandBuffer->reset();
-
-    SnapshotSaveAndLoad();
-    ASSERT_THAT(device->getFenceStatus(*fence), IsVkSuccess());
-    // TODO(b/332763326): fix validation layer complain about unreleased pipeline layout
-
-    // Try to draw something.
-    // Color attachment layout must be snapshotted, otherwise validation layer will complain.
-    commandBuffer->begin(commandBufferBeginInfo);
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-
-    vkhpp::ClearAttachment clearAttachment{
-        .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-        .colorAttachment = 0,
-        .clearValue = clearValue,
-    };
-    vkhpp::ClearRect clearRect{
-        .rect = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .baseArrayLayer = 0,
-        .layerCount = 1,
-    };
-
-    commandBuffer->clearAttachments(1, &clearAttachment, 1, &clearRect);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-    queue.submit(submitInfo, *fence);
-
-    waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-
-    if (GetParam().samples != 1) {
-        return;
-    }
-
-    std::vector<uint32_t> dst(kFbWidth * kFbHeight);
-    utils::readImageData(*colorAttachmentInfo->image, kFbWidth, kFbHeight,
-                         vkhpp::ImageLayout::eColorAttachmentOptimal, dst.data(),
-                         dst.size() * sizeof(uint32_t), testEnvironment);
-    for (int i = 0; i < dst.size(); i++) {
-        ASSERT_THAT(dst[i], Eq(0xffff00ff));
-    }
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, CanSnapshotCommandBuffer) {
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = testEnvironment;
-
-    auto pipelineInfo = createPipeline(device.get());
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *pipelineInfo->renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    auto fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(fence, IsValidHandle());
-
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .flags = vkhpp::CommandPoolCreateFlagBits::eResetCommandBuffer,
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    vkhpp::ClearColorValue clearColor(std::array<float, 4>{1.0f, 0.0f, 1.0f, 1.0f});
-    vkhpp::ClearValue clearValue{
-        .color = clearColor,
-    };
-    vkhpp::RenderPassBeginInfo renderPassBeginInfo{
-        .renderPass = *pipelineInfo->renderPass,
-        .framebuffer = *framebuffer,
-        .renderArea = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .clearValueCount = 1,
-        .pClearValues = &clearValue,
-    };
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::ImageMemoryBarrier colorAttachmentBarrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .dstAccessMask = vkhpp::AccessFlagBits::eColorAttachmentRead |
-                         vkhpp::AccessFlagBits::eColorAttachmentWrite,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *colorAttachmentInfo->image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(
-        vkhpp::PipelineStageFlagBits::eTopOfPipe | vkhpp::PipelineStageFlagBits::eTransfer,
-        vkhpp::PipelineStageFlagBits::eColorAttachmentOutput, vkhpp::DependencyFlags(), nullptr,
-        nullptr, colorAttachmentBarrier);
-
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-
-    vkhpp::ClearAttachment clearAttachment{
-        .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-        .colorAttachment = 0,
-        .clearValue = clearValue,
-    };
-    vkhpp::ClearRect clearRect{
-        .rect = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .baseArrayLayer = 0,
-        .layerCount = 1,
-    };
-
-    commandBuffer->clearAttachments(1, &clearAttachment, 1, &clearRect);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    std::vector<vkhpp::CommandBuffer> commandBufferHandles;
-    commandBufferHandles.push_back(*commandBuffer);
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = static_cast<uint32_t>(commandBufferHandles.size()),
-        .pCommandBuffers = commandBufferHandles.data(),
-    };
-
-    SnapshotSaveAndLoad();
-    // Command buffer should still work after snapshot.
-
-    queue.submit(submitInfo, *fence);
-
-    auto waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-
-    std::vector<uint32_t> dst(kFbWidth * kFbHeight);
-    utils::readImageData(*colorAttachmentInfo->image, kFbWidth, kFbHeight,
-                         vkhpp::ImageLayout::eColorAttachmentOptimal, dst.data(),
-                         dst.size() * sizeof(uint32_t), testEnvironment);
-    for (int i = 0; i < dst.size(); i++) {
-        ASSERT_THAT(dst[i], Eq(0xffff00ff));
-    }
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, CanSnapshotDescriptors) {
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = testEnvironment;
-
-    auto pipelineInfo = createPipeline(device.get());
-    auto vertexBufferInfo = createAndPopulateBuffer(
-        physicalDevice, device.get(), vkhpp::BufferUsageFlagBits::eVertexBuffer,
-        kFullscreenBlueRectangleVertexData, sizeof(kFullscreenBlueRectangleVertexData));
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    // Descriptor
-    std::vector<vkhpp::DescriptorPoolSize> sizes = {
-        {
-            .type = vkhpp::DescriptorType::eUniformBuffer,
-            .descriptorCount = 10,
-        },
-    };
-    vkhpp::DescriptorPoolCreateInfo descriptorPoolCreateInfo = {
-        .maxSets = 10,
-        .poolSizeCount = static_cast<uint32_t>(sizes.size()),
-        .pPoolSizes = sizes.data(),
-    };
-    auto descriptorPool = device->createDescriptorPoolUnique(descriptorPoolCreateInfo).value;
-    ASSERT_THAT(descriptorPool, IsValidHandle());
-
-    const std::vector<vkhpp::DescriptorSetLayout> descriptorSetLayouts(
-        1, *pipelineInfo->descriptorSetLayout);
-
-    vkhpp::DescriptorSetAllocateInfo descriptorSetAllocateInfo = {
-        .descriptorPool = *descriptorPool,
-        .descriptorSetCount = 1,
-        .pSetLayouts = descriptorSetLayouts.data(),
-    };
-    auto descriptorSets = device->allocateDescriptorSetsUnique(descriptorSetAllocateInfo);
-    EXPECT_THAT(descriptorSets.result, Eq(vkhpp::Result::eSuccess));
-    auto descriptorSet = *descriptorSets.value[0];
-
-    // A uniform for red color
-    float kColor1[] = {1.0f, 0.0f, 0.0f, 0.0f};
-    auto uniformBufferInfo = createAndPopulateBuffer(physicalDevice, device.get(),
-                                                     vkhpp::BufferUsageFlagBits::eUniformBuffer,
-                                                     kColor1, sizeof(kColor1));
-
-    std::vector<vkhpp::WriteDescriptorSet> writeDescriptorSets;
-    std::vector<vkhpp::DescriptorBufferInfo> bufferInfos;
-    bufferInfos.emplace_back(vkhpp::DescriptorBufferInfo{
-        .buffer = *uniformBufferInfo->buffer,
-        .offset = 0,
-        .range = VK_WHOLE_SIZE,
-    });
-    writeDescriptorSets.emplace_back(vkhpp::WriteDescriptorSet{
-        .dstSet = descriptorSet,
-        .dstBinding = 0,
-        .descriptorCount = 1,
-        .descriptorType = vkhpp::DescriptorType::eUniformBuffer,
-        .pBufferInfo = bufferInfos.data(),
-    });
-    device->updateDescriptorSets(writeDescriptorSets, nullptr);
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *pipelineInfo->renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    auto fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(fence, IsValidHandle());
-
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .flags = vkhpp::CommandPoolCreateFlagBits::eResetCommandBuffer,
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    vkhpp::ClearColorValue clearColor(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f});
-    vkhpp::ClearValue clearValue{
-        .color = clearColor,
-    };
-    vkhpp::RenderPassBeginInfo renderPassBeginInfo{
-        .renderPass = *pipelineInfo->renderPass,
-        .framebuffer = *framebuffer,
-        .renderArea = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .clearValueCount = 1,
-        .pClearValues = &clearValue,
-    };
-
-    // Descriptor updates are cached on the guest, for testing purpose we need to submit a queue to
-    // commit descriptor updates.
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::ImageMemoryBarrier colorAttachmentBarrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .dstAccessMask = vkhpp::AccessFlagBits::eColorAttachmentRead |
-                         vkhpp::AccessFlagBits::eColorAttachmentWrite,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *colorAttachmentInfo->image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(
-        vkhpp::PipelineStageFlagBits::eTopOfPipe | vkhpp::PipelineStageFlagBits::eTransfer,
-        vkhpp::PipelineStageFlagBits::eColorAttachmentOutput, vkhpp::DependencyFlags(), nullptr,
-        nullptr, colorAttachmentBarrier);
-
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-    commandBuffer->bindDescriptorSets(vkhpp::PipelineBindPoint::eGraphics,
-                                      *pipelineInfo->pipelineLayout, 0, descriptorSet, nullptr);
-    commandBuffer->bindVertexBuffers(0, {*vertexBufferInfo->buffer}, {0});
-    commandBuffer->setViewport(0, vkhpp::Viewport(0.0f, 0.0f, static_cast<float>(kFbWidth),
-                                                  static_cast<float>(kFbHeight), 0.0f, 1.0f));
-    commandBuffer->setScissor(
-        0, vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)));
-    commandBuffer->draw(6, 1, 0, 0);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    std::vector<vkhpp::CommandBuffer> commandBufferHandles;
-    commandBufferHandles.push_back(*commandBuffer);
-
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = static_cast<uint32_t>(commandBufferHandles.size()),
-        .pCommandBuffers = commandBufferHandles.data(),
-    };
-    queue.submit(submitInfo, *fence);
-    auto waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-    commandBuffer->reset();
-
-    // Clear the rendering
-    commandBuffer->begin(commandBufferBeginInfo);
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-    vkhpp::ClearAttachment clearAttachment{
-        .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-        .colorAttachment = 0,
-        .clearValue = clearValue,
-    };
-    vkhpp::ClearRect clearRect{
-        .rect = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .baseArrayLayer = 0,
-        .layerCount = 1,
-    };
-    commandBuffer->clearAttachments(1, &clearAttachment, 1, &clearRect);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    device->resetFences(1, &fence.get());
-    queue.submit(submitInfo, *fence);
-    waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-    commandBuffer->reset();
-
-    SnapshotSaveAndLoad();
-
-    // Redraw after snapshot, verify descriptors keep their value
-    // Command buffer snapshot is not implemented yet, so we need to re-make the command buffer.
-    commandBuffer->begin(commandBufferBeginInfo);
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-    commandBuffer->bindDescriptorSets(vkhpp::PipelineBindPoint::eGraphics,
-                                      *pipelineInfo->pipelineLayout, 0, descriptorSet, nullptr);
-    commandBuffer->bindVertexBuffers(0, {*vertexBufferInfo->buffer}, {0});
-    commandBuffer->setViewport(0, vkhpp::Viewport(0.0f, 0.0f, static_cast<float>(kFbWidth),
-                                                  static_cast<float>(kFbHeight), 0.0f, 1.0f));
-    commandBuffer->setScissor(
-        0, vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)));
-    commandBuffer->draw(6, 1, 0, 0);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    device->resetFences(1, &fence.get());
-    queue.submit(submitInfo, *fence);
-    waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-
-    std::vector<uint32_t> dst(kFbWidth * kFbHeight);
-    utils::readImageData(*colorAttachmentInfo->image, kFbWidth, kFbHeight,
-                         vkhpp::ImageLayout::eColorAttachmentOptimal, dst.data(),
-                         dst.size() * sizeof(uint32_t), testEnvironment);
-    for (int i = 0; i < dst.size(); i++) {
-        // The shader adds a blue color (from vertex buffer) with a red color (from uniform) and get
-        // purple.
-        ASSERT_THAT(dst[i], Eq(0xffff00ff));
-    }
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, DeleteBufferBeforeCommit) {
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = testEnvironment;
-
-    auto pipelineInfo = createPipeline(device.get());
-    auto vertexBufferInfo = createAndPopulateBuffer(
-        physicalDevice, device.get(), vkhpp::BufferUsageFlagBits::eVertexBuffer,
-        kFullscreenBlueRectangleVertexData, sizeof(kFullscreenBlueRectangleVertexData));
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    // Descriptor
-    std::vector<vkhpp::DescriptorPoolSize> sizes = {
-        {
-            .type = vkhpp::DescriptorType::eUniformBuffer,
-            .descriptorCount = 10,
-        },
-    };
-    vkhpp::DescriptorPoolCreateInfo descriptorPoolCreateInfo = {
-        .maxSets = 10,
-        .poolSizeCount = static_cast<uint32_t>(sizes.size()),
-        .pPoolSizes = sizes.data(),
-    };
-    auto descriptorPool = device->createDescriptorPoolUnique(descriptorPoolCreateInfo).value;
-    ASSERT_THAT(descriptorPool, IsValidHandle());
-
-    const std::vector<vkhpp::DescriptorSetLayout> descriptorSetLayouts(
-        1, *pipelineInfo->descriptorSetLayout);
-
-    vkhpp::DescriptorSetAllocateInfo descriptorSetAllocateInfo = {
-        .descriptorPool = *descriptorPool,
-        .descriptorSetCount = 1,
-        .pSetLayouts = descriptorSetLayouts.data(),
-    };
-    auto descriptorSets = device->allocateDescriptorSetsUnique(descriptorSetAllocateInfo);
-    EXPECT_THAT(descriptorSets.result, Eq(vkhpp::Result::eSuccess));
-    auto descriptorSet = *descriptorSets.value[0];
-
-    // A uniform for red color
-    float kColor1[] = {1.0f, 0.0f, 0.0f, 0.0f};
-    auto uniformBufferInfo = createAndPopulateBuffer(physicalDevice, device.get(),
-                                                     vkhpp::BufferUsageFlagBits::eUniformBuffer,
-                                                     kColor1, sizeof(kColor1));
-
-    std::vector<vkhpp::WriteDescriptorSet> writeDescriptorSets;
-    std::vector<vkhpp::DescriptorBufferInfo> bufferInfos;
-    bufferInfos.emplace_back(vkhpp::DescriptorBufferInfo{
-        .buffer = *uniformBufferInfo->buffer,
-        .offset = 0,
-        .range = VK_WHOLE_SIZE,
-    });
-    writeDescriptorSets.emplace_back(vkhpp::WriteDescriptorSet{
-        .dstSet = descriptorSet,
-        .dstBinding = 0,
-        .descriptorCount = 1,
-        .descriptorType = vkhpp::DescriptorType::eUniformBuffer,
-        .pBufferInfo = bufferInfos.data(),
-    });
-    device->updateDescriptorSets(writeDescriptorSets, nullptr);
-
-    // Delete the underlying buffer, should not crash.
-    uniformBufferInfo->buffer.reset();
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *pipelineInfo->renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    auto fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(fence, IsValidHandle());
-
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .flags = vkhpp::CommandPoolCreateFlagBits::eResetCommandBuffer,
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    vkhpp::ClearColorValue clearColor(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f});
-    vkhpp::ClearValue clearValue{
-        .color = clearColor,
-    };
-
-    // Descriptor updates are cached on the guest, for testing purpose we need to submit a queue to
-    // commit descriptor updates.
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::ImageMemoryBarrier colorAttachmentBarrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .dstAccessMask = vkhpp::AccessFlagBits::eColorAttachmentRead |
-                         vkhpp::AccessFlagBits::eColorAttachmentWrite,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *colorAttachmentInfo->image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(
-        vkhpp::PipelineStageFlagBits::eTopOfPipe | vkhpp::PipelineStageFlagBits::eTransfer,
-        vkhpp::PipelineStageFlagBits::eColorAttachmentOutput, vkhpp::DependencyFlags(), nullptr,
-        nullptr, colorAttachmentBarrier);
-
-    vkhpp::RenderPassBeginInfo renderPassBeginInfo{
-        .renderPass = *pipelineInfo->renderPass,
-        .framebuffer = *framebuffer,
-        .renderArea = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .clearValueCount = 1,
-        .pClearValues = &clearValue,
-    };
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    vkhpp::ClearAttachment clearAttachment{
-        .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-        .colorAttachment = 0,
-        .clearValue = clearValue,
-    };
-    vkhpp::ClearRect clearRect{
-        .rect = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .baseArrayLayer = 0,
-        .layerCount = 1,
-    };
-    commandBuffer->clearAttachments(1, &clearAttachment, 1, &clearRect);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    std::vector<vkhpp::CommandBuffer> commandBufferHandles;
-    commandBufferHandles.push_back(*commandBuffer);
-
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = static_cast<uint32_t>(commandBufferHandles.size()),
-        .pCommandBuffers = commandBufferHandles.data(),
-    };
-    // Submit will update the stale descriptor. Should not crash.
-    queue.submit(submitInfo, *fence);
-    auto waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-    commandBuffer->reset();
-    // Snapshot should not crash.
-    SnapshotSaveAndLoad();
-}
-
-TEST_P(GfxstreamEnd2EndVkSnapshotPipelineTest, DeleteBufferAfterWriteDescriptor) {
-    TypicalVkTestEnvironment testEnvironment = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
-    auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = testEnvironment;
-
-    auto pipelineInfo = createPipeline(device.get());
-    auto vertexBufferInfo = createAndPopulateBuffer(
-        physicalDevice, device.get(), vkhpp::BufferUsageFlagBits::eVertexBuffer,
-        kFullscreenBlueRectangleVertexData, sizeof(kFullscreenBlueRectangleVertexData));
-
-    auto colorAttachmentInfo = createColorAttachment(physicalDevice, device.get());
-    ASSERT_THAT(colorAttachmentInfo->image, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->memory, IsValidHandle());
-    ASSERT_THAT(colorAttachmentInfo->imageView, IsValidHandle());
-
-    // Descriptor
-    std::vector<vkhpp::DescriptorPoolSize> sizes = {
-        {
-            .type = vkhpp::DescriptorType::eUniformBuffer,
-            .descriptorCount = 10,
-        },
-    };
-    vkhpp::DescriptorPoolCreateInfo descriptorPoolCreateInfo = {
-        .maxSets = 10,
-        .poolSizeCount = static_cast<uint32_t>(sizes.size()),
-        .pPoolSizes = sizes.data(),
-    };
-    auto descriptorPool = device->createDescriptorPoolUnique(descriptorPoolCreateInfo).value;
-    ASSERT_THAT(descriptorPool, IsValidHandle());
-
-    const std::vector<vkhpp::DescriptorSetLayout> descriptorSetLayouts(
-        1, *pipelineInfo->descriptorSetLayout);
-
-    vkhpp::DescriptorSetAllocateInfo descriptorSetAllocateInfo = {
-        .descriptorPool = *descriptorPool,
-        .descriptorSetCount = 1,
-        .pSetLayouts = descriptorSetLayouts.data(),
-    };
-    auto descriptorSets = device->allocateDescriptorSetsUnique(descriptorSetAllocateInfo);
-    EXPECT_THAT(descriptorSets.result, Eq(vkhpp::Result::eSuccess));
-    auto descriptorSet = *descriptorSets.value[0];
-
-    // A uniform for red color
-    float kColor1[] = {1.0f, 0.0f, 0.0f, 0.0f};
-    auto uniformBufferInfo = createAndPopulateBuffer(physicalDevice, device.get(),
-                                                     vkhpp::BufferUsageFlagBits::eUniformBuffer,
-                                                     kColor1, sizeof(kColor1));
-
-    std::vector<vkhpp::WriteDescriptorSet> writeDescriptorSets;
-    std::vector<vkhpp::DescriptorBufferInfo> bufferInfos;
-    bufferInfos.emplace_back(vkhpp::DescriptorBufferInfo{
-        .buffer = *uniformBufferInfo->buffer,
-        .offset = 0,
-        .range = VK_WHOLE_SIZE,
-    });
-    writeDescriptorSets.emplace_back(vkhpp::WriteDescriptorSet{
-        .dstSet = descriptorSet,
-        .dstBinding = 0,
-        .descriptorCount = 1,
-        .descriptorType = vkhpp::DescriptorType::eUniformBuffer,
-        .pBufferInfo = bufferInfos.data(),
-    });
-    device->updateDescriptorSets(writeDescriptorSets, nullptr);
-
-    const std::vector<vkhpp::ImageView> attachments(1, *colorAttachmentInfo->imageView);
-    vkhpp::FramebufferCreateInfo framebufferCreateInfo = {
-        .renderPass = *pipelineInfo->renderPass,
-        .attachmentCount = 1,
-        .pAttachments = attachments.data(),
-        .width = kFbWidth,
-        .height = kFbHeight,
-        .layers = 1,
-    };
-    auto framebuffer = device->createFramebufferUnique(framebufferCreateInfo).value;
-    ASSERT_THAT(framebuffer, IsValidHandle());
-
-    auto fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
-    ASSERT_THAT(fence, IsValidHandle());
-
-    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
-        .flags = vkhpp::CommandPoolCreateFlagBits::eResetCommandBuffer,
-        .queueFamilyIndex = queueFamilyIndex,
-    };
-
-    auto commandPool = device->createCommandPoolUnique(commandPoolCreateInfo).value;
-    ASSERT_THAT(commandPool, IsValidHandle());
-
-    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
-        .level = vkhpp::CommandBufferLevel::ePrimary,
-        .commandPool = *commandPool,
-        .commandBufferCount = 1,
-    };
-
-    auto commandBuffers = device->allocateCommandBuffersUnique(commandBufferAllocateInfo).value;
-    ASSERT_THAT(commandBuffers, Not(IsEmpty()));
-    auto commandBuffer = std::move(commandBuffers[0]);
-    ASSERT_THAT(commandBuffer, IsValidHandle());
-
-    vkhpp::ClearColorValue clearColor(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f});
-    vkhpp::ClearValue clearValue{
-        .color = clearColor,
-    };
-    vkhpp::RenderPassBeginInfo renderPassBeginInfo{
-        .renderPass = *pipelineInfo->renderPass,
-        .framebuffer = *framebuffer,
-        .renderArea = vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)),
-        .clearValueCount = 1,
-        .pClearValues = &clearValue,
-    };
-
-    // Descriptor updates are cached on the guest, for testing purpose we need to submit a queue to
-    // commit descriptor updates.
-
-    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
-        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
-    };
-
-    commandBuffer->begin(commandBufferBeginInfo);
-    const vkhpp::ImageMemoryBarrier colorAttachmentBarrier{
-        .oldLayout = vkhpp::ImageLayout::eUndefined,
-        .newLayout = vkhpp::ImageLayout::eColorAttachmentOptimal,
-        .dstAccessMask = vkhpp::AccessFlagBits::eColorAttachmentRead |
-                         vkhpp::AccessFlagBits::eColorAttachmentWrite,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .image = *colorAttachmentInfo->image,
-        .subresourceRange =
-            {
-                .aspectMask = vkhpp::ImageAspectFlagBits::eColor,
-                .levelCount = 1,
-                .layerCount = 1,
-            },
-    };
-
-    commandBuffer->pipelineBarrier(
-        vkhpp::PipelineStageFlagBits::eTopOfPipe | vkhpp::PipelineStageFlagBits::eTransfer,
-        vkhpp::PipelineStageFlagBits::eColorAttachmentOutput, vkhpp::DependencyFlags(), nullptr,
-        nullptr, colorAttachmentBarrier);
-
-    commandBuffer->beginRenderPass(renderPassBeginInfo, vkhpp::SubpassContents::eInline);
-    commandBuffer->bindPipeline(vkhpp::PipelineBindPoint::eGraphics, *pipelineInfo->pipeline);
-    commandBuffer->bindDescriptorSets(vkhpp::PipelineBindPoint::eGraphics,
-                                      *pipelineInfo->pipelineLayout, 0, descriptorSet, nullptr);
-    commandBuffer->bindVertexBuffers(0, {*vertexBufferInfo->buffer}, {0});
-    commandBuffer->setViewport(0, vkhpp::Viewport(0.0f, 0.0f, static_cast<float>(kFbWidth),
-                                                  static_cast<float>(kFbHeight), 0.0f, 1.0f));
-    commandBuffer->setScissor(
-        0, vkhpp::Rect2D(vkhpp::Offset2D(0, 0), vkhpp::Extent2D(kFbWidth, kFbHeight)));
-    commandBuffer->draw(6, 1, 0, 0);
-    commandBuffer->endRenderPass();
-    commandBuffer->end();
-
-    std::vector<vkhpp::CommandBuffer> commandBufferHandles;
-    commandBufferHandles.push_back(*commandBuffer);
-
-    const vkhpp::SubmitInfo submitInfo = {
-        .commandBufferCount = static_cast<uint32_t>(commandBufferHandles.size()),
-        .pCommandBuffers = commandBufferHandles.data(),
-    };
-    queue.submit(submitInfo, *fence);
-    auto waitResult = device->waitForFences(*fence, VK_TRUE, 3000000000L);
-    ASSERT_THAT(waitResult, IsVkSuccess());
-    commandBuffer->reset();
-
-    vertexBufferInfo->buffer.reset();
-    // Descriptor snapshot should not crash after underlying buffer is deleted.
-    SnapshotSaveAndLoad();
-}
-
-INSTANTIATE_TEST_CASE_P(GfxstreamEnd2EndTests, GfxstreamEnd2EndVkSnapshotPipelineTest,
-                        ::testing::ValuesIn({
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .with_features = {"VulkanSnapshots", "VulkanBatchedDescriptorSetUpdate"},
-                            },
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                        }),
-                        &GetTestName);
-
-INSTANTIATE_TEST_CASE_P(GfxstreamEnd2EndTests,
-                        GfxstreamEnd2EndVkSnapshotPipelineWithMultiSamplingTest,
-                        ::testing::ValuesIn({
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .samples = 1,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                            TestParams{
-                                .with_gl = false,
-                                .with_vk = true,
-                                .samples = 4,
-                                .with_features = {"VulkanSnapshots"},
-                            },
-                        }),
-                        &GetTestName);
-
-}  // namespace
-}  // namespace tests
-}  // namespace gfxstream
diff --git a/common/end2end/GfxstreamEnd2EndVkTests.cpp b/common/end2end/GfxstreamEnd2EndVkTests.cpp
index cd43f1cc4..4624e4121 100644
--- a/common/end2end/GfxstreamEnd2EndVkTests.cpp
+++ b/common/end2end/GfxstreamEnd2EndVkTests.cpp
@@ -2211,6 +2211,131 @@ std::vector<TestParams> GenerateTestCases() {
     return cases;
 }
 
+TEST_P(GfxstreamEnd2EndVkTest, UseDoubleQueuesAndSynchronizeCorrectly) {
+    auto vk = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
+    auto& [instance, physicalDevice, device, queue_dont_use, graphicsQueueFamilyIndex] = vk;
+
+    const uint32_t graphicsQueueCount =
+        physicalDevice.getQueueFamilyProperties()[graphicsQueueFamilyIndex].queueCount;
+    if (graphicsQueueCount < 2) {
+        GTEST_SKIP() << "Device does not support at least 2 graphic_bit queues. Skipping test...";
+        return;
+    }
+
+    // Recreate logical device to get 2 queues
+    const float queuePriority = 1.0f;
+    const vkhpp::DeviceQueueCreateInfo deviceQueueCreateInfo = {
+        .queueFamilyIndex = graphicsQueueFamilyIndex,
+        .queueCount = 2,
+        .pQueuePriorities = &queuePriority,
+    };
+    std::vector<const char*> deviceExtensions = {
+        VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME,
+        VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,
+    };
+    const vkhpp::DeviceCreateInfo deviceCreateInfo = {
+        .pNext = nullptr,
+        .pQueueCreateInfos = &deviceQueueCreateInfo,
+        .queueCreateInfoCount = 1,
+        .enabledLayerCount = 0,
+        .ppEnabledLayerNames = nullptr,
+        .enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size()),
+        .ppEnabledExtensionNames = deviceExtensions.data(),
+    };
+
+    device = GFXSTREAM_ASSERT_VKHPP_RV(physicalDevice.createDeviceUnique(deviceCreateInfo));
+    auto queue1 = device->getQueue(graphicsQueueFamilyIndex, 0);
+    auto queue2 = device->getQueue(graphicsQueueFamilyIndex, 1);
+
+    const VkDeviceSize kBufferSize = 1024;
+    auto sourceBufferWithMemoryResult = CreateBuffer(
+        vk, kBufferSize, vkhpp::BufferUsageFlagBits::eTransferSrc,
+        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
+    if (!sourceBufferWithMemoryResult.ok()) {
+        GTEST_SKIP()
+            << "Couldn't create hostVisible, hostCoherent, TransferSrc buffer. Skipping test...";
+        return;
+    }
+    auto sourceBufferWithMemory = std::move(sourceBufferWithMemoryResult.value());
+    auto destBufferWithMemoryResult = CreateBuffer(
+        vk, kBufferSize, vkhpp::BufferUsageFlagBits::eTransferDst,
+        vkhpp::MemoryPropertyFlagBits::eHostVisible | vkhpp::MemoryPropertyFlagBits::eHostCoherent);
+    if (!destBufferWithMemoryResult.ok()) {
+        GTEST_SKIP()
+            << "Couldn't create hostVisible, hostCoherent, TransferDst buffer. Skipping test...";
+        return;
+    }
+    auto destBufferWithMemory = std::move(destBufferWithMemoryResult.value());
+    const vkhpp::CommandPoolCreateInfo commandPoolCreateInfo = {
+        .queueFamilyIndex = graphicsQueueFamilyIndex,
+    };
+
+    auto commandPool =
+        GFXSTREAM_ASSERT_VKHPP_RV(device->createCommandPoolUnique(commandPoolCreateInfo));
+
+    const vkhpp::CommandBufferAllocateInfo commandBufferAllocateInfo = {
+        .commandPool = *commandPool,
+        .level = vkhpp::CommandBufferLevel::ePrimary,
+        .commandBufferCount = 2,
+    };
+    auto commandBuffers =
+        GFXSTREAM_ASSERT_VKHPP_RV(device->allocateCommandBuffersUnique(commandBufferAllocateInfo));
+    auto commandBufferWriteInto = std::move(commandBuffers[0]);
+    auto commandBufferCopy = std::move(commandBuffers[1]);
+
+    vkhpp::UniqueSemaphore semaphore =
+        device->createSemaphoreUnique(vkhpp::SemaphoreCreateInfo()).value;
+
+    vkhpp::SubmitInfo submitInfoWrite = {.commandBufferCount = 1,
+                                         .pCommandBuffers = &*commandBufferWriteInto,
+                                         .signalSemaphoreCount = 1,
+                                         .pSignalSemaphores = &*semaphore};
+
+    const vkhpp::PipelineStageFlags waitStage = vkhpp::PipelineStageFlagBits::eTransfer;
+    vkhpp::SubmitInfo submitInfoCopy = {.commandBufferCount = 1,
+                                        .pCommandBuffers = &*commandBufferCopy,
+                                        .waitSemaphoreCount = 1,
+                                        .pWaitSemaphores = &*semaphore,
+                                        .pWaitDstStageMask = &waitStage};
+    const vkhpp::CommandBufferBeginInfo commandBufferBeginInfo = {
+        .flags = vkhpp::CommandBufferUsageFlagBits::eOneTimeSubmit,
+    };
+    commandBufferWriteInto->begin(commandBufferBeginInfo);
+    std::vector<uint8_t> dataToWrite = utils::getRandomNByteData(100);
+    commandBufferWriteInto->updateBuffer(sourceBufferWithMemory.buffer.get(), 0, dataToWrite.size(),
+                                         dataToWrite.data());
+    auto bufferBarrier = vkhpp::BufferMemoryBarrier()
+                             .setSrcAccessMask(vkhpp::AccessFlagBits::eTransferWrite)
+                             .setDstAccessMask(vkhpp::AccessFlagBits::eTransferRead)
+                             .setSrcQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
+                             .setDstQueueFamilyIndex(VK_QUEUE_FAMILY_IGNORED)
+                             .setBuffer(sourceBufferWithMemory.buffer.get())
+                             .setOffset(0)
+                             .setSize(kBufferSize);
+    commandBufferWriteInto->pipelineBarrier(vkhpp::PipelineStageFlagBits::eTransfer,
+                                            vkhpp::PipelineStageFlagBits::eTransfer,
+                                            vkhpp::DependencyFlags(), {}, bufferBarrier, {});
+    commandBufferWriteInto->end();
+
+    commandBufferCopy->begin(commandBufferBeginInfo);
+    vkhpp::BufferCopy copyRegion{};
+    copyRegion.srcOffset = 0;
+    copyRegion.dstOffset = 0;
+    copyRegion.size = kBufferSize;
+    vkhpp::ArrayProxy<const vkhpp::BufferCopy> copyRegions = copyRegion;
+    commandBufferCopy->copyBuffer(sourceBufferWithMemory.buffer.get(),
+                                  destBufferWithMemory.buffer.get(), copyRegions);
+    commandBufferCopy->end();
+    queue1.submit(submitInfoWrite, nullptr);
+    queue2.submit(submitInfoCopy, nullptr);
+    queue2.waitIdle();
+    void* mappedMemory = GFXSTREAM_ASSERT_VKHPP_RV(
+        device->mapMemory(*destBufferWithMemory.bufferMemory, 0, kBufferSize));
+    uint8_t* readData = static_cast<uint8_t*>(mappedMemory);
+    device->unmapMemory(*destBufferWithMemory.bufferMemory);
+    ASSERT_TRUE(std::memcmp(readData, dataToWrite.data(), dataToWrite.size()) == 0);
+}
+
 TEST_P(GfxstreamEnd2EndVkTest, GetFenceStatusOnExternalFence) {
     auto vk = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
     auto& [instance, physicalDevice, device, queue, queueFamilyIndex] = vk;
diff --git a/common/vulkan/include/vulkan/vulkan_core.h b/common/vulkan/include/vulkan/vulkan_core.h
index f181690b0..f4cd457af 100644
--- a/common/vulkan/include/vulkan/vulkan_core.h
+++ b/common/vulkan/include/vulkan/vulkan_core.h
@@ -803,9 +803,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
     VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
     VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
-    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = 1000259000,
+    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = 1000259001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = 1000259002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
@@ -1278,6 +1278,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
     VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
     VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR,
+    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
@@ -5039,6 +5042,7 @@ typedef enum VkExternalMemoryHandleTypeFlagBits {
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -13943,19 +13947,23 @@ VKAPI_ATTR VkResult VKAPI_CALL vkCreateHeadlessSurfaceEXT(
 #endif
 
 
-// VK_EXT_line_rasterization is a preprocessor guard. Do not pass it to API calls.
-#define VK_EXT_line_rasterization 1
-#define VK_EXT_LINE_RASTERIZATION_SPEC_VERSION 1
-#define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"
+// VK_KHR_line_rasterization is a preprocessor guard. Do not pass it to API calls.
+#define VK_KHR_line_rasterization 1
+#define VK_KHR_LINE_RASTERIZATION_SPEC_VERSION 1
+#define VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME "VK_KHR_line_rasterization"
 
-typedef enum VkLineRasterizationModeEXT {
-    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
-    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
-    VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
-} VkLineRasterizationModeEXT;
-typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
+typedef enum VkLineRasterizationModeKHR {
+    VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = 0,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = 1,
+    VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = 2,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = 3,
+    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR,
+    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR,
+    VK_LINE_RASTERIZATION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkLineRasterizationModeKHR;
+typedef struct VkPhysicalDeviceLineRasterizationFeaturesKHR {
     VkStructureType    sType;
     void*              pNext;
     VkBool32           rectangularLines;
@@ -13964,22 +13972,44 @@ typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
     VkBool32           stippledRectangularLines;
     VkBool32           stippledBresenhamLines;
     VkBool32           stippledSmoothLines;
-} VkPhysicalDeviceLineRasterizationFeaturesEXT;
+} VkPhysicalDeviceLineRasterizationFeaturesKHR;
 
-typedef struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
+typedef struct VkPhysicalDeviceLineRasterizationPropertiesKHR {
     VkStructureType    sType;
     void*              pNext;
     uint32_t           lineSubPixelPrecisionBits;
-} VkPhysicalDeviceLineRasterizationPropertiesEXT;
+} VkPhysicalDeviceLineRasterizationPropertiesKHR;
 
-typedef struct VkPipelineRasterizationLineStateCreateInfoEXT {
+typedef struct VkPipelineRasterizationLineStateCreateInfoKHR {
     VkStructureType               sType;
     const void*                   pNext;
-    VkLineRasterizationModeEXT    lineRasterizationMode;
+    VkLineRasterizationModeKHR    lineRasterizationMode;
     VkBool32                      stippledLineEnable;
     uint32_t                      lineStippleFactor;
     uint16_t                      lineStipplePattern;
-} VkPipelineRasterizationLineStateCreateInfoEXT;
+} VkPipelineRasterizationLineStateCreateInfoKHR;
+
+typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleKHR)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
+
+#ifndef VK_NO_PROTOTYPES
+VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStippleKHR(
+    VkCommandBuffer                             commandBuffer,
+    uint32_t                                    lineStippleFactor,
+    uint16_t                                    lineStipplePattern);
+#endif
+
+
+// VK_EXT_line_rasterization is a preprocessor guard. Do not pass it to API calls.
+#define VK_EXT_line_rasterization 1
+#define VK_EXT_LINE_RASTERIZATION_SPEC_VERSION 1
+#define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"
+typedef VkLineRasterizationModeKHR VkLineRasterizationModeEXT;
+
+typedef VkPhysicalDeviceLineRasterizationFeaturesKHR VkPhysicalDeviceLineRasterizationFeaturesEXT;
+
+typedef VkPhysicalDeviceLineRasterizationPropertiesKHR VkPhysicalDeviceLineRasterizationPropertiesEXT;
+
+typedef VkPipelineRasterizationLineStateCreateInfoKHR VkPipelineRasterizationLineStateCreateInfoEXT;
 
 typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleEXT)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
 
diff --git a/common/vulkan/include/vulkan/vulkan_metal.h b/common/vulkan/include/vulkan/vulkan_metal.h
index 1bc8780c5..1491cb014 100644
--- a/common/vulkan/include/vulkan/vulkan_metal.h
+++ b/common/vulkan/include/vulkan/vulkan_metal.h
@@ -191,12 +191,8 @@ VKAPI_ATTR void VKAPI_CALL vkExportMetalObjectsEXT(
 
 // VK_EXT_external_memory_metal is a preprocessor guard. Do not pass it to API calls.
 #define VK_EXT_external_memory_metal 1
-#ifdef __OBJC__
-@protocol MTLResource;
-typedef __unsafe_unretained id<MTLResource> MTLResource_id;
-#else
+
 typedef void* MTLResource_id;
-#endif
 
 #define VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION 1
 #define VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME "VK_EXT_external_memory_metal"
diff --git a/docs/deqp.md b/docs/deqp.md
deleted file mode 100644
index 024222331..000000000
--- a/docs/deqp.md
+++ /dev/null
@@ -1,54 +0,0 @@
-# Running dEQP with Gfxstream
-
-## dEQP-(EGL|GLES2|GLES3)
-
-TODO
-
-## dEQP-VK
-
-### Linux
-
-1. Build Gfxstream
-
-   ```
-   cd <YOUR aosp-main DIRECTORY>
-   source build/envsetup.sh
-   lunch aosp_cf_x86_64_phone-trunk_staging-userdebug
-   m libgfxstream_guest_vulkan_with_host
-
-   # Edit hardware/google/gfxstream/guest/vulkan/gfxstream_icd.json 's
-   # "library_path" value to point to
-   # "<YOUR aosp-main DIRECTORY>/out/host/linux-86/lib64/libgfxstream_guest_vulkan_with_host.so"
-   ```
-
-1. Build dEQP
-
-   ```
-   mkdir github-deqp
-   cd github-deqp
-   git clone https://github.com/KhronosGroup/VK-GL-CTS .
-   python3 external/fetch_sources.py
-   mkdir build
-   cd build
-   cmake -DCMAKE_BUILD_TYPE=Debug ..
-   make -j
-   ```
-
-1. Build Nested Vulkan Loader
-
-   ```
-   ./scripts/build-nested-vulkan-loader.sh
-
-   # Run the "export" command printed in the output of the above script.
-   ```
-
-1. Run dEQP with Gfxstream ICD
-
-   ```
-   VK_LOADER_DEBUG=all \
-   VK_ICD_FILENAMES=<YOUR aosp-main DIRECTORY>/hardware/google/gfxstream/guest/vulkan/gfxstream_icd.json \
-   GFXSTREAM_VK_LOADER_DEBUG=all \
-   GFXSTREAM_VK_ICD_FILENAMES=/etc/vulkan/icd.d/nvidia_icd.json \
-   <YOUR github-deqp DIRECTORY>/build/external/vulkancts/modules/vulkan/deqp-vk \
-       --deqp-case=dEQP-VK.api.smoke*
-   ```
\ No newline at end of file
diff --git a/guest/GLESv2_enc/GL2Encoder.cpp b/guest/GLESv2_enc/GL2Encoder.cpp
index 33f018c08..9bcd22113 100644
--- a/guest/GLESv2_enc/GL2Encoder.cpp
+++ b/guest/GLESv2_enc/GL2Encoder.cpp
@@ -3101,7 +3101,7 @@ void GL2Encoder::s_glGenRenderbuffers(void* self,
 
     SET_ERROR_IF(n < 0, GL_INVALID_VALUE);
 
-    ctx->m_glGenFramebuffers_enc(self, n, renderbuffers);
+    ctx->m_glGenRenderbuffers_enc(self, n, renderbuffers);
     state->addRenderbuffers(n, renderbuffers);
 }
 
diff --git a/guest/OpenglSystemCommon/Android.bp b/guest/OpenglSystemCommon/Android.bp
index a29556910..8ec4dad95 100644
--- a/guest/OpenglSystemCommon/Android.bp
+++ b/guest/OpenglSystemCommon/Android.bp
@@ -53,6 +53,7 @@ cc_defaults {
         "libgfxstream_guest_graphics_headers",
         "mesa_gfxstream_guest_iostream",
         "libhardware_headers",
+        "mesa_gfxstream_aemu_headers",
         "libnativebase_headers",
     ],
     export_header_lib_headers: [
diff --git a/guest/magma/Android.bp b/guest/magma/Android.bp
index 7bd825c71..d9a7bbba6 100644
--- a/guest/magma/Android.bp
+++ b/guest/magma/Android.bp
@@ -29,6 +29,7 @@ cc_library_static {
         "libmagma_enc_headers",
         "libmagma_headers",
         "mesa_gfxstream_guest_iostream",
+        "mesa_gfxstream_aemu_headers",
     ],
     shared_libs: [
         "libdrm",
@@ -38,7 +39,7 @@ cc_library_static {
     static_libs: [
         "mesa_gfxstream_guest_android",
         "mesa_goldfish_address_space",
-        "libgfxstream_androidemu_static",
+        "mesa_gfxstream_aemu",
     ],
     srcs: [
         "magma.cpp",
diff --git a/host/Android.bp b/host/Android.bp
index badffbd61..0c9dab2c0 100644
--- a/host/Android.bp
+++ b/host/Android.bp
@@ -17,6 +17,26 @@ package {
     default_applicable_licenses: ["hardware_google_gfxstream_license"],
 }
 
+cc_library_host_static {
+    name: "libgfxstream_backend_proto",
+    defaults: [
+        "gfxstream_defaults",
+        "gfxstream_host_cc_defaults",
+    ],
+    proto: {
+        canonical_path_from_root: false,
+        export_proto_headers: true,
+        type: "full",
+        static: true,
+    },
+    srcs: [
+        "VirtioGpuContextSnapshot.proto",
+        "VirtioGpuFrontendSnapshot.proto",
+        "VirtioGpuRingBlobSnapshot.proto",
+        "VirtioGpuResourceSnapshot.proto",
+    ],
+}
+
 gfxstream_backend_static_deps = [
     "gfxstream_base",
     "gfxstream_host_common",
@@ -44,6 +64,12 @@ gfxstream_backend_static_deps = [
     "libgfxstream_thirdparty_glm",
 ]
 
+gfxstream_backend_snapshot_static_deps = [
+    "libgfxstream_backend_proto",
+    "libprotobuf-cpp-full",
+    "libz",
+]
+
 gfxstream_backend_magma_static_deps = [
     "libgfxstream_host_magma_dec",
     "libgfxstream_host_magma_server",
@@ -116,6 +142,10 @@ cc_defaults {
         "GfxStreamAgents.cpp",
         "virtio-gpu-gfxstream-renderer.cpp",
         "virtio-gpu-gfxstream-renderer-goldfish.cpp",
+        "VirtioGpuContext.cpp",
+        "VirtioGpuFrontend.cpp",
+        "VirtioGpuResource.cpp",
+        "VirtioGpuRingBlob.cpp",
         "VirtioGpuTimelines.cpp",
         "VsyncThread.cpp",
     ],
@@ -125,6 +155,8 @@ cc_defaults {
     target: {
         host: {
             srcs: ["NativeSubWindow_x11.cpp"],
+            static_libs: gfxstream_backend_snapshot_static_deps,
+            whole_static_libs: gfxstream_backend_snapshot_static_deps,
         },
         android: {
             srcs: ["NativeSubWindow_android.cpp"],
diff --git a/host/BUILD.bazel b/host/BUILD.bazel
index 4dfc8252e..34d41ecb4 100644
--- a/host/BUILD.bazel
+++ b/host/BUILD.bazel
@@ -98,6 +98,10 @@ cc_library(
         "RendererImpl.cpp",
         "RingStream.cpp",
         "SyncThread.cpp",
+        "VirtioGpuContext.cpp",
+        "VirtioGpuFrontend.cpp",
+        "VirtioGpuResource.cpp",
+        "VirtioGpuRingBlob.cpp",
         "VirtioGpuTimelines.cpp",
         "VsyncThread.cpp",
     ] + select({
diff --git a/host/CMakeLists.txt b/host/CMakeLists.txt
index 027ef542d..3d2f7f8c9 100644
--- a/host/CMakeLists.txt
+++ b/host/CMakeLists.txt
@@ -19,7 +19,7 @@ add_subdirectory(renderControl_dec)
 add_subdirectory(magma)
 
 if(CONFIG_AEMU)
-    add_compile_definitions(GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT)
+    add_compile_definitions(GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT)
     add_compile_definitions(CONFIG_AEMU)
 endif()
 
@@ -29,6 +29,10 @@ set(stream-server-core-sources
     ExternalObjectManager.cpp
     ColorBuffer.cpp
     GfxStreamAgents.cpp
+    VirtioGpuContext.cpp
+    VirtioGpuFrontend.cpp
+    VirtioGpuResource.cpp
+    VirtioGpuRingBlob.cpp
     VirtioGpuTimelines.cpp
     VsyncThread.cpp
     ChannelStream.cpp
diff --git a/host/ColorBuffer.cpp b/host/ColorBuffer.cpp
index 96ae6541f..f0d783412 100644
--- a/host/ColorBuffer.cpp
+++ b/host/ColorBuffer.cpp
@@ -22,6 +22,7 @@
 #include "host-common/logging.h"
 #include "vulkan/ColorBufferVk.h"
 #include "vulkan/VkCommonOperations.h"
+#include "FrameBuffer.h"
 
 using android::base::ManagedDescriptor;
 using emugl::ABORT_REASON_OTHER;
@@ -164,7 +165,7 @@ void ColorBuffer::restore() {
 }
 
 void ColorBuffer::readToBytes(int x, int y, int width, int height, GLenum pixelsFormat,
-                              GLenum pixelsType, void* outPixels) {
+                              GLenum pixelsType, void* outPixels, uint64_t outPixelsSize) {
     touch();
 
 #if GFXSTREAM_ENABLE_HOST_GLES
@@ -175,7 +176,7 @@ void ColorBuffer::readToBytes(int x, int y, int width, int height, GLenum pixels
 #endif
 
     if (mColorBufferVk) {
-        mColorBufferVk->readToBytes(x, y, width, height, outPixels);
+        mColorBufferVk->readToBytes(x, y, width, height, outPixels, outPixelsSize);
         return;
     }
 
@@ -199,18 +200,18 @@ void ColorBuffer::readToBytesScaled(int pixelsWidth, int pixelsHeight, GLenum pi
 }
 
 void ColorBuffer::readYuvToBytes(int x, int y, int width, int height, void* outPixels,
-                                 uint32_t pixelsSize) {
+                                 uint32_t outPixelsSize) {
     touch();
 
 #if GFXSTREAM_ENABLE_HOST_GLES
     if (mColorBufferGl) {
-        mColorBufferGl->readPixelsYUVCached(x, y, width, height, outPixels, pixelsSize);
+        mColorBufferGl->readPixelsYUVCached(x, y, width, height, outPixels, outPixelsSize);
         return;
     }
 #endif
 
     if (mColorBufferVk) {
-        mColorBufferVk->readToBytes(x, y, width, height, outPixels);
+        mColorBufferVk->readToBytes(x, y, width, height, outPixels, outPixelsSize);
         return;
     }
 
diff --git a/host/ColorBuffer.h b/host/ColorBuffer.h
index b625829a8..c5cc53a42 100644
--- a/host/ColorBuffer.h
+++ b/host/ColorBuffer.h
@@ -68,10 +68,10 @@ class ColorBuffer : public android::snapshot::LazySnapshotObj<ColorBuffer> {
     FrameworkFormat getFrameworkFormat() const { return mFrameworkFormat; }
 
     void readToBytes(int x, int y, int width, int height, GLenum pixelsFormat, GLenum pixelsType,
-                     void* outPixels);
+                     void* outPixels, uint64_t outPixelsSize);
     void readToBytesScaled(int pixelsWidth, int pixelsHeight, GLenum pixelsFormat,
                            GLenum pixelsType, int pixelsRotation, Rect rect, void* outPixels);
-    void readYuvToBytes(int x, int y, int width, int height, void* outPixels, uint32_t pixelsSize);
+    void readYuvToBytes(int x, int y, int width, int height, void* outPixels, uint32_t outPixelsSize);
 
     bool updateFromBytes(int x, int y, int width, int height, GLenum pixelsFormat,
                          GLenum pixelsType, const void* pixels);
diff --git a/host/FrameBuffer.cpp b/host/FrameBuffer.cpp
index 74559d7a2..c320cef21 100644
--- a/host/FrameBuffer.cpp
+++ b/host/FrameBuffer.cpp
@@ -364,12 +364,10 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
             fb->m_vkInstance = vkEmu->instance;
         }
         if (vkEmu->instanceSupportsPhysicalDeviceIDProperties) {
-            GL_LOG("Supports id properties, got a vulkan device UUID");
-            fprintf(stderr, "%s: Supports id properties, got a vulkan device UUID\n", __func__);
+            INFO("Supports id properties, got a vulkan device UUID");
             memcpy(fb->m_vulkanUUID.data(), vkEmu->deviceInfo.idProps.deviceUUID, VK_UUID_SIZE);
         } else {
-            GL_LOG("Doesn't support id properties, no vulkan device UUID");
-            fprintf(stderr, "%s: Doesn't support id properties, no vulkan device UUID\n", __func__);
+            WARN("Doesn't support id properties, no vulkan device UUID");
         }
     }
 
@@ -612,7 +610,7 @@ FrameBuffer::FrameBuffer(int p_width, int p_height, gfxstream::host::FeatureSet
     mDisplayConfigs[0] = {p_width, p_height, 160, 160};
     uint32_t displayId = 0;
     if (createDisplay(&displayId) < 0) {
-        fprintf(stderr, "Failed to create default display\n");
+        ERR( "Failed to create default display");
     }
 
     setDisplayPose(displayId, 0, 0, getWidth(), getHeight(), 0);
@@ -1466,8 +1464,11 @@ void FrameBuffer::eraseDelayedCloseColorBufferLocked(
 }
 
 void FrameBuffer::createGraphicsProcessResources(uint64_t puid) {
-    AutoLock mutex(m_lock);
-    bool inserted = m_procOwnedResources.try_emplace(puid, ProcessResources::create()).second;
+    bool inserted = false;
+    {
+        AutoLock mutex(m_procOwnedResourcesLock);
+        inserted = m_procOwnedResources.try_emplace(puid, ProcessResources::create()).second;
+    }
     if (!inserted) {
         WARN("Failed to create process resource for puid %" PRIu64 ".", puid);
     }
@@ -1476,7 +1477,7 @@ void FrameBuffer::createGraphicsProcessResources(uint64_t puid) {
 std::unique_ptr<ProcessResources> FrameBuffer::removeGraphicsProcessResources(uint64_t puid) {
     std::unordered_map<uint64_t, std::unique_ptr<ProcessResources>>::node_type node;
     {
-        AutoLock mutex(m_lock);
+        AutoLock mutex(m_procOwnedResourcesLock);
         node = m_procOwnedResources.extract(puid);
     }
     if (node.empty()) {
@@ -1631,7 +1632,7 @@ void FrameBuffer::readBuffer(HandleType handle, uint64_t offset, uint64_t size,
 }
 
 void FrameBuffer::readColorBuffer(HandleType p_colorbuffer, int x, int y, int width, int height,
-                                  GLenum format, GLenum type, void* pixels) {
+                                  GLenum format, GLenum type, void* outPixels, uint64_t outPixelsSize) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DEFAULT_CATEGORY, "FrameBuffer::readColorBuffer()",
                           "ColorBuffer", p_colorbuffer);
 
@@ -1643,11 +1644,11 @@ void FrameBuffer::readColorBuffer(HandleType p_colorbuffer, int x, int y, int wi
         return;
     }
 
-    colorBuffer->readToBytes(x, y, width, height, format, type, pixels);
+    colorBuffer->readToBytes(x, y, width, height, format, type, outPixels, outPixelsSize);
 }
 
 void FrameBuffer::readColorBufferYUV(HandleType p_colorbuffer, int x, int y, int width, int height,
-                                     void* pixels, uint32_t pixels_size) {
+                                     void* outPixels, uint32_t outPixelsSize) {
     AutoLock mutex(m_lock);
 
     ColorBufferPtr colorBuffer = findColorBuffer(p_colorbuffer);
@@ -1656,7 +1657,7 @@ void FrameBuffer::readColorBufferYUV(HandleType p_colorbuffer, int x, int y, int
         return;
     }
 
-    colorBuffer->readYuvToBytes(x, y, width, height, pixels, pixels_size);
+    colorBuffer->readYuvToBytes(x, y, width, height, outPixels, outPixelsSize);
 }
 
 bool FrameBuffer::updateBuffer(HandleType p_buffer, uint64_t offset, uint64_t size, void* bytes) {
@@ -2367,6 +2368,7 @@ void FrameBuffer::onSave(Stream* stream, const android::snapshot::ITextureSaverP
 
     // TODO(b/309858017): remove if when ready to bump snapshot version
     if (m_features.VulkanSnapshots.enabled) {
+        AutoLock mutex(m_procOwnedResourcesLock);
         stream->putBe64(m_procOwnedResources.size());
         for (const auto& element : m_procOwnedResources) {
             stream->putBe64(element.first);
@@ -2482,7 +2484,10 @@ bool FrameBuffer::onLoad(Stream* stream,
                 }
             }
 
-            m_procOwnedResources.clear();
+            {
+                AutoLock mutex(m_procOwnedResourcesLock);
+                m_procOwnedResources.clear();
+            }
 
             performDelayedColorBufferCloseLocked(true);
 
@@ -2617,7 +2622,10 @@ bool FrameBuffer::onLoad(Stream* stream,
             uint32_t sequenceNumber = stream->getBe32();
             std::unique_ptr<ProcessResources> processResources = ProcessResources::create();
             processResources->getSequenceNumberPtr()->store(sequenceNumber);
-            m_procOwnedResources.emplace(puid, std::move(processResources));
+            {
+                AutoLock mutex(m_procOwnedResourcesLock);
+                m_procOwnedResources.emplace(puid, std::move(processResources));
+            }
         }
     }
 
@@ -2719,13 +2727,15 @@ void FrameBuffer::unregisterProcessCleanupCallback(void* key) {
 }
 
 const ProcessResources* FrameBuffer::getProcessResources(uint64_t puid) {
-    AutoLock mutex(m_lock);
-    auto i = m_procOwnedResources.find(puid);
-    if (i == m_procOwnedResources.end()) {
-        ERR("Failed to find process owned resources for puid %" PRIu64 ".", puid);
-        return nullptr;
+    {
+        AutoLock mutex(m_procOwnedResourcesLock);
+        auto i = m_procOwnedResources.find(puid);
+        if (i != m_procOwnedResources.end()) {
+            return i->second.get();
+        }
     }
-    return i->second.get();
+    ERR("Failed to find process owned resources for puid %" PRIu64 ".", puid);
+    return nullptr;
 }
 
 int FrameBuffer::createDisplay(uint32_t* displayId) {
@@ -2904,7 +2914,7 @@ void FrameBuffer::setVsyncHz(int vsyncHz) {
 
 void FrameBuffer::scheduleVsyncTask(VsyncThread::VsyncTask task) {
     if (!m_vsyncThread) {
-        fprintf(stderr, "%s: warning: no vsync thread exists\n", __func__);
+        ERR("%s: warning: no vsync thread exists", __func__);
         task(0);
         return;
     }
diff --git a/host/FrameBuffer.h b/host/FrameBuffer.h
index 53231cf23..536c1e063 100644
--- a/host/FrameBuffer.h
+++ b/host/FrameBuffer.h
@@ -87,6 +87,16 @@
 #include "utils/RenderDoc.h"
 #include "vulkan/vk_util.h"
 
+//// Import info types for FrameBuffer::platformImportResource
+// Platform resources and contexts support
+#define RESOURCE_TYPE_MASK 0x0F
+// types
+#define RESOURCE_TYPE_EGL_NATIVE_PIXMAP 0x01
+#define RESOURCE_TYPE_EGL_IMAGE 0x02
+#define RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE 0x03
+// uses
+#define RESOURCE_USE_PRESERVE 0x10
+
 namespace gfxstream {
 namespace vk {
 class DisplayVk;
@@ -264,8 +274,16 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     // |type| is the type of pixel data, e.g. GL_UNSIGNED_BYTE.
     // |pixels| is the address of a caller-provided buffer that will be filled
     // with the pixel data.
-    void readColorBuffer(HandleType p_colorbuffer, int x, int y, int width,
-                         int height, GLenum format, GLenum type, void* pixels);
+    // |outPixelsSize| is the size of buffer
+    void readColorBuffer(HandleType p_colorbuffer, int x, int y, int width, int height,
+                         GLenum format, GLenum type, void* pixels, uint64_t outPixelsSize);
+
+    // Old, unsafe version for backwards compatibility
+    void readColorBuffer(HandleType p_colorbuffer, int x, int y, int width, int height,
+                         GLenum format, GLenum type, void* pixels) {
+        return readColorBuffer(p_colorbuffer, x, y, width, height, format, type, pixels,
+                               std::numeric_limits<uint64_t>::max());
+    }
 
     // Read the content of a given YUV420_888 ColorBuffer into client memory.
     // |p_colorbuffer| is the ColorBuffer's handle value. Similar
@@ -274,9 +292,9 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     // a rectangle whose pixel values will be transfered to the host.
     // |pixels| is the address of a caller-provided buffer that will be filled
     // with the pixel data.
-    // |pixles_size| is the size of buffer
+    // |outPixelsSize| is the size of buffer
     void readColorBufferYUV(HandleType p_colorbuffer, int x, int y, int width,
-                            int height, void* pixels, uint32_t pixels_size);
+                            int height, void* pixels, uint32_t outPixelsSize);
 
     // Update the content of a given Buffer from client data.
     // |p_buffer| is the Buffer's handle value.
@@ -822,6 +840,7 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     std::string m_graphicsApiVersion;
     std::string m_graphicsApiExtensions;
     std::string m_graphicsDeviceExtensions;
+    android::base::Lock m_procOwnedResourcesLock;
     std::unordered_map<uint64_t, std::unique_ptr<ProcessResources>> m_procOwnedResources;
 
     // Flag set when emulator is shutting down.
diff --git a/host/GfxStreamAgents.cpp b/host/GfxStreamAgents.cpp
index 255a1986b..df2a10b63 100644
--- a/host/GfxStreamAgents.cpp
+++ b/host/GfxStreamAgents.cpp
@@ -147,11 +147,11 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
         .setGpuMode = [](bool isGuestMode, uint32_t w, uint32_t h) {},
         .createDisplay = [](uint32_t* displayId) -> int {
             if (displayId == nullptr) {
-                fprintf(stderr, "null displayId pointer\n");
+                ERR("cannot create display, null displayId pointer");
                 return -1;
             }
             if (mMultiDisplay.size() >= MultiDisplay::s_maxNumMultiDisplay) {
-                fprintf(stderr, "cannot create more displays, exceeding limits %d\n",
+                ERR("cannot create more displays, exceeding limits %d",
                         MultiDisplay::s_maxNumMultiDisplay);
                 return -1;
             }
@@ -168,7 +168,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
                 }
             }
             if (*displayId == MultiDisplay::s_invalidIdMultiDisplay) {
-                fprintf(stderr, "cannot create more internaldisplays, exceeding limits %d\n",
+                ERR("cannot create more internaldisplays, exceeding limits %d",
                         MultiDisplay::s_maxNumMultiDisplay - MultiDisplay::s_displayIdInternalBegin);
                 return -1;
             }
@@ -187,7 +187,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
                              uint32_t h,
                              uint32_t dpi) -> int {
             if (mMultiDisplay.find(displayId) == mMultiDisplay.end()) {
-                fprintf(stderr, "cannot find display %d\n", displayId);
+                ERR("cannot find display %d", displayId);
                 return -1;
             }
             mMultiDisplay[displayId].pos_x = x;
@@ -203,7 +203,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
                              uint32_t* w,
                              uint32_t* h) -> int {
             if (mMultiDisplay.find(displayId) == mMultiDisplay.end()) {
-                fprintf(stderr, "cannot find display %d\n", displayId);
+                ERR("cannot find display %d", displayId);
                 return -1;
             }
             if (x)
@@ -219,7 +219,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
         .getDisplayColorBuffer = [](uint32_t displayId,
                                     uint32_t* colorBuffer) -> int {
             if (mMultiDisplay.find(displayId) == mMultiDisplay.end()) {
-                fprintf(stderr, "cannot find display %d\n", displayId);
+                ERR("cannot find display %d", displayId);
                 return -1;
             }
             *colorBuffer = mMultiDisplay[displayId].cb;
@@ -238,7 +238,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
         .setDisplayColorBuffer = [](uint32_t displayId,
                                     uint32_t colorBuffer) -> int {
             if (mMultiDisplay.find(displayId) == mMultiDisplay.end()) {
-                fprintf(stderr, "cannot find display %d\n", displayId);
+                ERR("Unable to set display color buffer for non existing display: %d", displayId);
                 return -1;
             }
             mMultiDisplay[displayId].cb = colorBuffer;
@@ -433,7 +433,7 @@ static const QAndroidVmOperations sQAndroidVmOperations =
         .hostmemRegister = android_emulation_hostmem_register,
         .hostmemUnregister = android_emulation_hostmem_unregister,
         .hostmemGetInfo = android_emulation_hostmem_get_info,
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
         .setSkipSnapshotSaveReason =
             [](SnapshotSkipReason reason) {
                 DEBUG_LOG(stderr,
diff --git a/host/PostWorker.cpp b/host/PostWorker.cpp
index a06ec8d4f..800fb3219 100644
--- a/host/PostWorker.cpp
+++ b/host/PostWorker.cpp
@@ -28,21 +28,6 @@
 #include "host-common/misc.h"
 #include "vulkan/VkCommonOperations.h"
 
-#define POST_DEBUG 0
-#if POST_DEBUG >= 1
-#define DD(fmt, ...) \
-    fprintf(stderr, "%s:%d| " fmt, __func__, __LINE__, ##__VA_ARGS__)
-#else
-#define DD(fmt, ...) (void)0
-#endif
-
-#define POST_ERROR(fmt, ...)                                                  \
-    do {                                                                      \
-        fprintf(stderr, "%s(%s:%d): " fmt "\n", __func__, __FILE__, __LINE__, \
-                ##__VA_ARGS__);                                               \
-        fflush(stderr);                                                       \
-    } while (0)
-
 static void sDefaultRunOnUiThread(UiUpdateFunc f, void* data, bool wait) {
     (void)f;
     (void)data;
diff --git a/host/RenderControl.cpp b/host/RenderControl.cpp
index 0e03d28d8..686b03412 100644
--- a/host/RenderControl.cpp
+++ b/host/RenderControl.cpp
@@ -408,7 +408,7 @@ std::string replaceESVersionString(const std::string& prev,
     if (esStart == std::string::npos ||
         esEnd == std::string::npos) {
         // Account for out-of-spec version strings.
-        fprintf(stderr, "%s: Error: invalid OpenGL ES version string %s\n",
+        ERR("%s: Error: unexpected OpenGL ES version string %s",
                 __func__, prev.c_str());
         return prev;
     }
@@ -1506,7 +1506,7 @@ static int rcReadColorBufferDMA(uint32_t colorBuffer,
         return -1;
     }
 
-    fb->readColorBuffer(colorBuffer, x, y, width, height, format, type, pixels);
+    fb->readColorBuffer(colorBuffer, x, y, width, height, format, type, pixels, pixels_size);
     return 0;
 }
 
diff --git a/host/RenderThreadInfo.cpp b/host/RenderThreadInfo.cpp
index 983fc75af..f95eeb05b 100644
--- a/host/RenderThreadInfo.cpp
+++ b/host/RenderThreadInfo.cpp
@@ -74,8 +74,20 @@ void RenderThreadInfo::onSave(Stream* stream) {
     }
 
 #if GFXSTREAM_ENABLE_HOST_GLES
-    m_glInfo->onSave(stream);
+    if (m_glInfo) {
+        stream->putBe32(1);
+        m_glInfo->onSave(stream);
+    } else {
+        stream->putBe32(0);
+    }
 #endif
+
+    if (m_vkInfo) {
+        stream->putBe32(1);
+        m_vkInfo->onSave(stream);
+    } else {
+        stream->putBe32(0);
+    }
 }
 
 bool RenderThreadInfo::onLoad(Stream* stream) {
@@ -85,16 +97,35 @@ bool RenderThreadInfo::onLoad(Stream* stream) {
     }
 
 #if GFXSTREAM_ENABLE_HOST_GLES
-    return m_glInfo->onLoad(stream);
-#else
-    // Functions only work with GLES for now.
-    return false;
+    const bool loadGlInfo = stream->getBe32() == 1;
+    if (loadGlInfo) {
+        if (!m_glInfo) {
+            m_glInfo.emplace();
+        }
+        if (!m_glInfo->onLoad(stream)) {
+            return false;
+        }
+    }
 #endif
+
+    const bool loadVkInfo = stream->getBe32() == 1;
+    if (loadVkInfo) {
+        if (!m_vkInfo) {
+            m_vkInfo.emplace();
+        }
+        if (!m_vkInfo->onLoad(stream)) {
+            return false;
+        }
+    }
+
+    return true;
 }
 
 void RenderThreadInfo::postLoadRefreshCurrentContextSurfacePtrs() {
 #if GFXSTREAM_ENABLE_HOST_GLES
-    return m_glInfo->postLoadRefreshCurrentContextSurfacePtrs();
+    if (m_glInfo) {
+        m_glInfo->postLoadRefreshCurrentContextSurfacePtrs();
+    }
 #endif
 }
 
diff --git a/host/RendererImpl.cpp b/host/RendererImpl.cpp
index f6ae389b3..93707b3f0 100644
--- a/host/RendererImpl.cpp
+++ b/host/RendererImpl.cpp
@@ -394,15 +394,7 @@ bool RendererImpl::load(android::base::Stream* stream,
     }
     auto fb = FrameBuffer::getFB();
     assert(fb);
-
-    bool res = true;
-
-    res = fb->onLoad(stream, textureLoader);
-#if GFXSTREAM_ENABLE_HOST_GLES
-    gl::EmulatedEglFenceSync::onLoad(stream);
-#endif
-
-    return res;
+    return fb->onLoad(stream, textureLoader);
 }
 
 void RendererImpl::fillGLESUsages(android_studio::EmulatorGLESUsages* usages) {
@@ -590,6 +582,12 @@ static struct AndroidVirtioGpuOps sVirtioGpuOps = {
             FrameBuffer::getFB()->readColorBuffer(handle, x, y, width, height, format, type,
                                                   pixels);
         },
+    .read_color_buffer2 =
+        [](uint32_t handle, int x, int y, int width, int height, uint32_t format, uint32_t type,
+           void* pixels, uint64_t pixels_size) {
+            FrameBuffer::getFB()->readColorBuffer(handle, x, y, width, height, format, type,
+                                                  pixels, pixels_size);
+        },
     .read_color_buffer_yuv =
         [](uint32_t handle, int x, int y, int width, int height, void* pixels,
            uint32_t pixels_size) {
@@ -654,24 +652,6 @@ static struct AndroidVirtioGpuOps sVirtioGpuOps = {
                 handle, x, y, width, height, (FrameworkFormat)fwkFormat, format, type, pixels,
                 pMetadata);
         },
-    .platform_import_resource =
-        [](uint32_t handle, uint32_t info, void* resource) {
-            return FrameBuffer::getFB()->platformImportResource(handle, info, resource);
-        },
-    .platform_resource_info =
-        [](uint32_t handle, int32_t* width, int32_t* height, int32_t* internal_format) {
-            return FrameBuffer::getFB()->getColorBufferInfo(handle, width, height, internal_format);
-        },
-#if GFXSTREAM_ENABLE_HOST_GLES
-    .platform_create_shared_egl_context =
-        []() { return FrameBuffer::getFB()->platformCreateSharedEglContext(); },
-    .platform_destroy_shared_egl_context =
-        [](void* context) {
-            return FrameBuffer::getFB()->platformDestroySharedEglContext(context);
-        },
-#endif
-    .wait_sync_color_buffer =
-        [](uint32_t handle) { return FrameBuffer::getFB()->waitSyncColorBuffer(handle); },
 };
 
 struct AndroidVirtioGpuOps* RendererImpl::getVirtioGpuOps() {
diff --git a/host/RingStream.cpp b/host/RingStream.cpp
index 5f3018ab7..13dfba640 100644
--- a/host/RingStream.cpp
+++ b/host/RingStream.cpp
@@ -89,9 +89,9 @@ int RingStream::commitBuffer(size_t size) {
     }
 
     if (backedOffIters > 0) {
-        fprintf(stderr, "%s: warning: backed off %zu times due to guest slowness.\n",
-                __func__,
-                backedOffIters);
+        WARN("Backed off %zu times to avoid overloading the guest system. This "
+             "may indicate resource constraints or performance issues.",
+             backedOffIters);
     }
     return sent;
 }
diff --git a/host/VirtioGpu.h b/host/VirtioGpu.h
new file mode 100644
index 000000000..c12210279
--- /dev/null
+++ b/host/VirtioGpu.h
@@ -0,0 +1,26 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <stdint.h>
+
+namespace gfxstream {
+namespace host {
+
+using VirtioGpuContextId = uint32_t;
+using VirtioGpuResourceId = uint32_t;
+
+}  // namespace host
+}  // namespace gfxstream
diff --git a/host/VirtioGpuContext.cpp b/host/VirtioGpuContext.cpp
new file mode 100644
index 000000000..c2fcea69b
--- /dev/null
+++ b/host/VirtioGpuContext.cpp
@@ -0,0 +1,241 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VirtioGpuContext.h"
+
+#include "host-common/AddressSpaceService.h"
+#include "host-common/opengles.h"
+
+namespace gfxstream {
+namespace host {
+
+/*static*/
+std::optional<VirtioGpuContext> VirtioGpuContext::Create(const GoldfishPipeServiceOps* ops,
+                                                         VirtioGpuContextId contextId,
+                                                         const std::string& contextName,
+                                                         uint32_t capsetId) {
+    VirtioGpuContext context = {};
+    context.mId = contextId;
+    context.mName = contextName;
+    context.mCapsetId = capsetId;
+
+    auto hostPipe = ops->guest_open_with_flags(reinterpret_cast<GoldfishHwPipe*>(contextId),
+                                               0x1 /* is virtio */);
+    if (!hostPipe) {
+        stream_renderer_error("failed to create context %u: failed to create pipe.", contextId);
+        return std::nullopt;
+    }
+    stream_renderer_debug("created initial pipe for context %u: %p", contextId, hostPipe);
+    context.mHostPipe = hostPipe;
+
+    android_onGuestGraphicsProcessCreate(contextId);
+
+    return context;
+}
+
+int VirtioGpuContext::Destroy(const GoldfishPipeServiceOps* pipeOps,
+                              const struct address_space_device_control_ops* asgOps) {
+    for (const auto& [_, handle] : mAddressSpaceHandles) {
+        // Note: this can hang as is but this has only been observed to
+        // happen during shutdown. See b/329287602#comment8.
+        asgOps->destroy_handle(handle);
+    }
+
+    if (!mHostPipe) {
+        stream_renderer_error("failed to destroy context %u: missing pipe?", mId);
+        return -EINVAL;
+    }
+    pipeOps->guest_close(mHostPipe, GOLDFISH_PIPE_CLOSE_GRACEFUL);
+
+    android_cleanupProcGLObjects(mId);
+
+    return 0;
+}
+
+void VirtioGpuContext::AttachResource(VirtioGpuResource& resource) {
+    // Associate the host pipe of the resource entry with the host pipe of
+    // the context entry.  That is, the last context to call attachResource
+    // wins if there is any conflict.
+    resource.AttachToContext(mId);
+    resource.SetHostPipe(mHostPipe);
+
+    mAttachedResources.insert(resource.GetId());
+}
+
+void VirtioGpuContext::DetachResource(VirtioGpuResource& resource) {
+    mAttachedResources.erase(resource.GetId());
+    resource.DetachFromContext(mId);
+}
+
+const std::unordered_set<VirtioGpuResourceId>& VirtioGpuContext::GetAttachedResources() const {
+    return mAttachedResources;
+}
+
+void VirtioGpuContext::SetHostPipe(GoldfishHostPipe* pipe) { mHostPipe = pipe; }
+
+int VirtioGpuContext::AcquireSync(uint64_t syncId) {
+    if (mLatestSync) {
+        stream_renderer_error(
+            "failed to acquire sync %" PRIu64 " on context %u: sync already present?", syncId, mId);
+        return -EINVAL;
+    }
+
+    auto descriptorOpt = ExternalObjectManager::get()->removeSyncDescriptorInfo(mId, syncId);
+    if (!descriptorOpt) {
+        stream_renderer_error("failed to acquire sync %" PRIu64 " on context %u: sync not found.",
+                              syncId, mId);
+        return -EINVAL;
+    }
+
+    mLatestSync = std::move(*descriptorOpt);
+    return 0;
+}
+
+std::optional<SyncDescriptorInfo> VirtioGpuContext::TakeSync() {
+    if (!mLatestSync) {
+        return std::nullopt;
+    }
+
+    auto info = std::move(*mLatestSync);
+    mLatestSync.reset();
+    return std::move(info);
+}
+
+int VirtioGpuContext::CreateAddressSpaceGraphicsInstance(
+    const struct address_space_device_control_ops* asgOps, VirtioGpuResource& resource) {
+    const VirtioGpuResourceId resourceId = resource.GetId();
+
+    void* resourceHva = nullptr;
+    uint64_t resourceHvaSize = 0;
+    if (resource.Map(&resourceHva, &resourceHvaSize) != 0) {
+        stream_renderer_error(
+            "failed to create ASG instance on context %d: failed to map resource %u", mId,
+            resourceId);
+        return -EINVAL;
+    }
+
+    const std::string asgName = mName + "-" + std::to_string(resourceId);
+
+    // Note: resource ids can not be used as ASG handles because ASGs may outlive the
+    // containing resource due asynchronous ASG destruction.
+    const uint32_t asgId = asgOps->gen_handle();
+
+    struct AddressSpaceCreateInfo createInfo = {
+        .handle = asgId,
+        .type = android::emulation::VirtioGpuGraphics,
+        .createRenderThread = true,
+        .externalAddr = resourceHva,
+        .externalAddrSize = resourceHvaSize,
+        .virtioGpuContextId = mId,
+        .virtioGpuCapsetId = mCapsetId,
+        .contextName = asgName.c_str(),
+        .contextNameSize = static_cast<uint32_t>(asgName.size()),
+    };
+    asgOps->create_instance(createInfo);
+
+    mAddressSpaceHandles[resourceId] = asgId;
+    return 0;
+}
+
+const std::unordered_map<VirtioGpuResourceId, uint32_t>& VirtioGpuContext::AsgInstances() const {
+    return mAddressSpaceHandles;
+}
+
+std::optional<uint32_t> VirtioGpuContext::TakeAddressSpaceGraphicsHandle(
+    VirtioGpuResourceId resourceId) {
+    auto asgIt = mAddressSpaceHandles.find(resourceId);
+    if (asgIt == mAddressSpaceHandles.end()) {
+        return std::nullopt;
+    }
+
+    auto asgId = asgIt->second;
+    mAddressSpaceHandles.erase(asgIt);
+    return asgId;
+}
+
+int VirtioGpuContext::PingAddressSpaceGraphicsInstance(
+    const struct address_space_device_control_ops* asgOps, VirtioGpuResourceId resourceId) {
+    auto asgIt = mAddressSpaceHandles.find(resourceId);
+    if (asgIt == mAddressSpaceHandles.end()) {
+        stream_renderer_error(
+            "failed to ping ASG instance on context %u resource %d: ASG not found.", mId,
+            resourceId);
+        return -EINVAL;
+    }
+    auto asgId = asgIt->second;
+
+    struct android::emulation::AddressSpaceDevicePingInfo ping = {0};
+    ping.metadata = ASG_NOTIFY_AVAILABLE;
+    asgOps->ping_at_hva(asgId, &ping);
+
+    return 0;
+}
+
+int VirtioGpuContext::AddPendingBlob(uint32_t blobId,
+                                     struct stream_renderer_resource_create_args blobArgs) {
+    auto [_, inserted] = mPendingBlobs.try_emplace(blobId, blobArgs);
+    if (!inserted) {
+        stream_renderer_error(
+            "failed to add pending blob %u to context %u: blob ID already in use?", blobId, mId);
+        return -EINVAL;
+    }
+    return 0;
+}
+
+std::optional<struct stream_renderer_resource_create_args> VirtioGpuContext::TakePendingBlob(
+    uint32_t blobId) {
+    auto it = mPendingBlobs.find(blobId);
+    if (it == mPendingBlobs.end()) {
+        return std::nullopt;
+    }
+
+    auto args = it->second;
+    mPendingBlobs.erase(it);
+    return args;
+}
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+using gfxstream::host::snapshot::VirtioGpuContextSnapshot;
+
+std::optional<VirtioGpuContextSnapshot> VirtioGpuContext::Snapshot() const {
+    VirtioGpuContextSnapshot contextSnapshot;
+    contextSnapshot.set_id(mId);
+    contextSnapshot.set_name(mName);
+    contextSnapshot.set_capset(mCapsetId);
+    contextSnapshot.mutable_attached_resources()->Add(mAttachedResources.begin(),
+                                                      mAttachedResources.end());
+    contextSnapshot.mutable_resource_asgs()->insert(mAddressSpaceHandles.begin(),
+                                                    mAddressSpaceHandles.end());
+    return contextSnapshot;
+}
+
+/*static*/
+std::optional<VirtioGpuContext> VirtioGpuContext::Restore(
+    const VirtioGpuContextSnapshot& contextSnapshot) {
+    VirtioGpuContext context = {};
+    context.mId = contextSnapshot.id();
+    context.mName = contextSnapshot.name();
+    context.mCapsetId = contextSnapshot.capset();
+    context.mAttachedResources.insert(contextSnapshot.attached_resources().begin(),
+                                      contextSnapshot.attached_resources().end());
+    context.mAddressSpaceHandles.insert(contextSnapshot.resource_asgs().begin(),
+                                        contextSnapshot.resource_asgs().end());
+    return context;
+}
+
+#endif
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuContext.h b/host/VirtioGpuContext.h
new file mode 100644
index 000000000..23afa9a88
--- /dev/null
+++ b/host/VirtioGpuContext.h
@@ -0,0 +1,97 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <stdint.h>
+
+#include <memory>
+#include <optional>
+#include <string>
+#include <unordered_map>
+#include <unordered_set>
+
+#include "ExternalObjectManager.h"
+#include "VirtioGpu.h"
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+// X11 defines status as a preprocessor define which messes up
+// anyone with a `Status` type.
+#undef Status
+#include "VirtioGpuContextSnapshot.pb.h"
+#endif
+#include "VirtioGpuResource.h"
+#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
+#include "host-common/address_space_device_control_ops.h"
+extern "C" {
+#include "host-common/goldfish_pipe.h"
+}  // extern "C"
+
+namespace gfxstream {
+namespace host {
+
+class VirtioGpuContext {
+   public:
+    VirtioGpuContext() = default;
+
+    static std::optional<VirtioGpuContext> Create(const GoldfishPipeServiceOps* ops,
+                                                  VirtioGpuContextId contextId,
+                                                  const std::string& contextName,
+                                                  uint32_t capsetId);
+
+    int Destroy(const GoldfishPipeServiceOps* pipeOps,
+                const struct address_space_device_control_ops* asgOps);
+
+    void AttachResource(VirtioGpuResource& resource);
+    void DetachResource(VirtioGpuResource& resource);
+
+    const std::unordered_set<VirtioGpuResourceId>& GetAttachedResources() const;
+
+    void SetHostPipe(GoldfishHostPipe* pipe);
+
+    int AcquireSync(uint64_t syncId);
+    std::optional<SyncDescriptorInfo> TakeSync();
+
+    int CreateAddressSpaceGraphicsInstance(const struct address_space_device_control_ops* asgOps,
+                                           VirtioGpuResource& resource);
+    const std::unordered_map<VirtioGpuResourceId, uint32_t>& AsgInstances() const;
+    std::optional<uint32_t> TakeAddressSpaceGraphicsHandle(VirtioGpuResourceId resourceId);
+
+    int PingAddressSpaceGraphicsInstance(const struct address_space_device_control_ops* asgOps,
+                                         VirtioGpuResourceId resourceId);
+
+    int AddPendingBlob(uint32_t blobId, struct stream_renderer_resource_create_args args);
+    std::optional<struct stream_renderer_resource_create_args> TakePendingBlob(uint32_t args);
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    std::optional<gfxstream::host::snapshot::VirtioGpuContextSnapshot> Snapshot() const;
+
+    static std::optional<VirtioGpuContext> Restore(
+        const gfxstream::host::snapshot::VirtioGpuContextSnapshot& snapshot);
+#endif
+
+   private:
+    // LINT.IfChange(virtio_gpu_context)
+    VirtioGpuContextId mId;
+    std::string mName;
+    uint32_t mCapsetId;
+    GoldfishHostPipe* mHostPipe;
+    std::unordered_set<VirtioGpuResourceId> mAttachedResources;
+    std::unordered_map<VirtioGpuResourceId, uint32_t> mAddressSpaceHandles;
+    std::unordered_map<uint32_t, struct stream_renderer_resource_create_args> mPendingBlobs;
+    std::optional<SyncDescriptorInfo> mLatestSync;
+    // LINT.ThenChange(VirtioGpuContextSnapshot.proto:virtio_gpu_context)
+};
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuContextSnapshot.proto b/host/VirtioGpuContextSnapshot.proto
new file mode 100644
index 000000000..69913e474
--- /dev/null
+++ b/host/VirtioGpuContextSnapshot.proto
@@ -0,0 +1,27 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package gfxstream.host.snapshot;
+
+// LINT.IfChange(virtio_gpu_context)
+message VirtioGpuContextSnapshot {
+    optional uint32 id = 1;
+    optional string name = 2;
+    optional uint32 capset = 3;
+    repeated uint32 attached_resources = 4;
+    map<uint32, uint32> resource_asgs = 5;
+}
+// LINT.ThenChange(VirtioGpuContext.h:virtio_gpu_context)
diff --git a/host/VirtioGpuFormatUtils.h b/host/VirtioGpuFormatUtils.h
new file mode 100644
index 000000000..724f8e173
--- /dev/null
+++ b/host/VirtioGpuFormatUtils.h
@@ -0,0 +1,353 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+extern "C" {
+#include "drm_fourcc.h"
+#include "virgl_hw.h"
+}  // extern "C"
+
+namespace gfxstream {
+namespace host {
+
+#define VIRGL_FORMAT_NV12 166
+#define VIRGL_FORMAT_YV12 163
+#define VIRGL_FORMAT_P010 314
+
+const uint32_t kGlBgra = 0x80e1;
+const uint32_t kGlRgba = 0x1908;
+const uint32_t kGlRgba16f = 0x881A;
+const uint32_t kGlRgb565 = 0x8d62;
+const uint32_t kGlRgba1010102 = 0x8059;
+const uint32_t kGlR8 = 0x8229;
+const uint32_t kGlR16 = 0x822A;
+const uint32_t kGlRg8 = 0x822b;
+const uint32_t kGlRgb8 = 0x8051;
+const uint32_t kGlLuminance = 0x1909;
+const uint32_t kGlLuminanceAlpha = 0x190a;
+const uint32_t kGlUnsignedByte = 0x1401;
+const uint32_t kGlUnsignedShort = 0x1403;
+const uint32_t kGlUnsignedShort565 = 0x8363;
+const uint32_t kGlDepth16 = 0x81A5;
+const uint32_t kGlDepth24 = 0x81A6;
+const uint32_t kGlDepth24Stencil8 = 0x88F0;
+const uint32_t kGlDepth32f = 0x8CAC;
+const uint32_t kGlDepth32fStencil8 = 0x8CAD;
+
+constexpr uint32_t kFwkFormatGlCompat = 0;
+constexpr uint32_t kFwkFormatYV12 = 1;
+// constexpr uint32_t kFwkFormatYUV420888 = 2;
+constexpr uint32_t kFwkFormatNV12 = 3;
+constexpr uint32_t kFwkFormatP010 = 4;
+
+static inline bool virgl_format_is_yuv(uint32_t format) {
+    switch (format) {
+        case VIRGL_FORMAT_B8G8R8X8_UNORM:
+        case VIRGL_FORMAT_B5G6R5_UNORM:
+        case VIRGL_FORMAT_B8G8R8A8_UNORM:
+        case VIRGL_FORMAT_R10G10B10A2_UNORM:
+        case VIRGL_FORMAT_R16_UNORM:
+        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
+        case VIRGL_FORMAT_R8_UNORM:
+        case VIRGL_FORMAT_R8G8_UNORM:
+        case VIRGL_FORMAT_R8G8B8_UNORM:
+        case VIRGL_FORMAT_R8G8B8A8_UNORM:
+        case VIRGL_FORMAT_R8G8B8X8_UNORM:
+        case VIRGL_FORMAT_Z16_UNORM:
+        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
+        case VIRGL_FORMAT_Z24X8_UNORM:
+        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
+        case VIRGL_FORMAT_Z32_FLOAT:
+            return false;
+        case VIRGL_FORMAT_NV12:
+        case VIRGL_FORMAT_P010:
+        case VIRGL_FORMAT_YV12:
+            return true;
+        default:
+            stream_renderer_error("Unknown virgl format 0x%x", format);
+            return false;
+    }
+}
+
+static inline uint32_t virgl_format_to_gl(uint32_t virgl_format) {
+    switch (virgl_format) {
+        case VIRGL_FORMAT_B8G8R8X8_UNORM:
+        case VIRGL_FORMAT_B8G8R8A8_UNORM:
+            return kGlBgra;
+        case VIRGL_FORMAT_R8G8B8X8_UNORM:
+        case VIRGL_FORMAT_R8G8B8A8_UNORM:
+            return kGlRgba;
+        case VIRGL_FORMAT_B5G6R5_UNORM:
+            return kGlRgb565;
+        case VIRGL_FORMAT_R16_UNORM:
+            return kGlR16;
+        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
+            return kGlRgba16f;
+        case VIRGL_FORMAT_R8_UNORM:
+            return kGlR8;
+        case VIRGL_FORMAT_R8G8_UNORM:
+            return kGlRg8;
+        case VIRGL_FORMAT_R8G8B8_UNORM:
+            return kGlRgb8;
+        case VIRGL_FORMAT_NV12:
+        case VIRGL_FORMAT_P010:
+        case VIRGL_FORMAT_YV12:
+            // emulated as RGBA8888
+            return kGlRgba;
+        case VIRGL_FORMAT_R10G10B10A2_UNORM:
+            return kGlRgba1010102;
+        case VIRGL_FORMAT_Z16_UNORM:
+            return kGlDepth16;
+        case VIRGL_FORMAT_Z24X8_UNORM:
+            return kGlDepth24;
+        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
+            return kGlDepth24Stencil8;
+        case VIRGL_FORMAT_Z32_FLOAT:
+            return kGlDepth32f;
+        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
+            return kGlDepth32fStencil8;
+        default:
+            return kGlRgba;
+    }
+}
+
+static inline uint32_t virgl_format_to_fwk_format(uint32_t virgl_format) {
+    switch (virgl_format) {
+        case VIRGL_FORMAT_NV12:
+            return kFwkFormatNV12;
+        case VIRGL_FORMAT_P010:
+            return kFwkFormatP010;
+        case VIRGL_FORMAT_YV12:
+            return kFwkFormatYV12;
+        case VIRGL_FORMAT_R8_UNORM:
+        case VIRGL_FORMAT_R16_UNORM:
+        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
+        case VIRGL_FORMAT_R8G8_UNORM:
+        case VIRGL_FORMAT_R8G8B8_UNORM:
+        case VIRGL_FORMAT_B8G8R8X8_UNORM:
+        case VIRGL_FORMAT_B8G8R8A8_UNORM:
+        case VIRGL_FORMAT_R8G8B8X8_UNORM:
+        case VIRGL_FORMAT_R8G8B8A8_UNORM:
+        case VIRGL_FORMAT_B5G6R5_UNORM:
+        case VIRGL_FORMAT_R10G10B10A2_UNORM:
+        case VIRGL_FORMAT_Z16_UNORM:
+        case VIRGL_FORMAT_Z24X8_UNORM:
+        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
+        case VIRGL_FORMAT_Z32_FLOAT:
+        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
+        default:  // kFwkFormatGlCompat: No extra conversions needed
+            return kFwkFormatGlCompat;
+    }
+}
+
+static inline uint32_t gl_format_to_natural_type(uint32_t format) {
+    switch (format) {
+        case kGlBgra:
+        case kGlRgba:
+        case kGlLuminance:
+        case kGlLuminanceAlpha:
+            return kGlUnsignedByte;
+        case kGlRgb565:
+            return kGlUnsignedShort565;
+        case kGlDepth16:
+            return kGlUnsignedShort;
+        default:
+            return kGlUnsignedByte;
+    }
+}
+
+#ifndef DRM_FORMAT_DEPTH16
+#define DRM_FORMAT_DEPTH16 fourcc_code('D', '1', '6', ' ')
+#define DRM_FORMAT_DEPTH24 fourcc_code('D', '2', '4', 'X')
+#define DRM_FORMAT_DEPTH24_STENCIL8 fourcc_code('D', '2', '4', 'S')
+#define DRM_FORMAT_DEPTH32 fourcc_code('D', '3', '2', 'F')
+#define DRM_FORMAT_DEPTH32_STENCIL8 fourcc_code('D', 'F', 'S', '8')
+#endif
+
+static inline uint32_t drm_format_to_virgl_format(uint32_t format) {
+    switch (format) {
+        case DRM_FORMAT_DEPTH16:
+            return VIRGL_FORMAT_Z16_UNORM;
+        case DRM_FORMAT_DEPTH24:
+            return VIRGL_FORMAT_Z24X8_UNORM;
+        case DRM_FORMAT_DEPTH24_STENCIL8:
+            return VIRGL_FORMAT_Z24_UNORM_S8_UINT;
+        case DRM_FORMAT_DEPTH32:
+            return VIRGL_FORMAT_Z32_FLOAT;
+        case DRM_FORMAT_DEPTH32_STENCIL8:
+            return VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT;
+        default:
+            stream_renderer_error("Unknown drm format for virgl conversion 0x%x", format);
+            return 0;
+    }
+}
+
+static inline void set_virgl_format_supported(uint32_t* mask, uint32_t virgl_format,
+                                              bool supported) {
+    uint32_t index = virgl_format / 32;
+    uint32_t bit_offset = 1 << (virgl_format & 31);
+    if (supported) {
+        mask[index] |= bit_offset;
+    } else {
+        mask[index] &= ~bit_offset;
+    }
+}
+
+static inline void set_drm_format_supported(uint32_t* mask, uint32_t drm_format, bool supported) {
+    uint32_t virgl_format = drm_format_to_virgl_format(drm_format);
+    set_virgl_format_supported(mask, virgl_format, supported);
+}
+
+static inline bool is_drm_format_supported(uint32_t* mask, uint32_t drm_format) {
+    uint32_t virgl_format = drm_format_to_virgl_format(drm_format);
+    uint32_t index = virgl_format / 32;
+    uint32_t bit_offset = 1 << (virgl_format & 31);
+    return (mask[index] & bit_offset) ? true : false;
+}
+
+static inline size_t virgl_format_to_linear_base(uint32_t format, uint32_t totalWidth,
+                                                 uint32_t totalHeight, uint32_t x, uint32_t y,
+                                                 uint32_t w, uint32_t h) {
+    if (virgl_format_is_yuv(format)) {
+        return 0;
+    } else {
+        uint32_t bpp = 4;
+        switch (format) {
+            case VIRGL_FORMAT_R16G16B16A16_FLOAT:
+            case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
+                bpp = 8;
+                break;
+            case VIRGL_FORMAT_B8G8R8X8_UNORM:
+            case VIRGL_FORMAT_B8G8R8A8_UNORM:
+            case VIRGL_FORMAT_R8G8B8X8_UNORM:
+            case VIRGL_FORMAT_R8G8B8A8_UNORM:
+            case VIRGL_FORMAT_R10G10B10A2_UNORM:
+            case VIRGL_FORMAT_Z24X8_UNORM:
+            case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
+            case VIRGL_FORMAT_Z32_FLOAT:
+                bpp = 4;
+                break;
+            case VIRGL_FORMAT_R8G8B8_UNORM:
+                bpp = 3;
+                break;
+            case VIRGL_FORMAT_B5G6R5_UNORM:
+            case VIRGL_FORMAT_R8G8_UNORM:
+            case VIRGL_FORMAT_R16_UNORM:
+            case VIRGL_FORMAT_Z16_UNORM:
+                bpp = 2;
+                break;
+            case VIRGL_FORMAT_R8_UNORM:
+                bpp = 1;
+                break;
+            default:
+                stream_renderer_error("Unknown virgl format: 0x%x", format);
+                return 0;
+        }
+
+        uint32_t stride = totalWidth * bpp;
+        return y * stride + x * bpp;
+    }
+    return 0;
+}
+
+static inline uint32_t align_up_power_of_2(uint32_t n, uint32_t a) {
+    return (n + (a - 1)) & ~(a - 1);
+}
+
+static inline size_t virgl_format_to_total_xfer_len(uint32_t format, uint32_t totalWidth,
+                                                    uint32_t totalHeight, uint32_t x, uint32_t y,
+                                                    uint32_t w, uint32_t h) {
+    if (virgl_format_is_yuv(format)) {
+        uint32_t bpp = format == VIRGL_FORMAT_P010 ? 2 : 1;
+
+        uint32_t yWidth = totalWidth;
+        uint32_t yHeight = totalHeight;
+        uint32_t yStridePixels;
+        if (format == VIRGL_FORMAT_NV12) {
+            yStridePixels = yWidth;
+        } else if (format == VIRGL_FORMAT_P010) {
+            yStridePixels = yWidth;
+        } else if (format == VIRGL_FORMAT_YV12) {
+            yStridePixels = align_up_power_of_2(yWidth, 32);
+        } else {
+            stream_renderer_error("Unknown virgl format: 0x%x", format);
+            return 0;
+        }
+        uint32_t yStrideBytes = yStridePixels * bpp;
+        uint32_t ySize = yStrideBytes * yHeight;
+
+        uint32_t uvStridePixels;
+        uint32_t uvPlaneCount;
+        if (format == VIRGL_FORMAT_NV12) {
+            uvStridePixels = yStridePixels;
+            uvPlaneCount = 1;
+        } else if (format == VIRGL_FORMAT_P010) {
+            uvStridePixels = yStridePixels;
+            uvPlaneCount = 1;
+        } else if (format == VIRGL_FORMAT_YV12) {
+            uvStridePixels = yStridePixels / 2;
+            uvPlaneCount = 2;
+        } else {
+            stream_renderer_error("Unknown virgl yuv format: 0x%x", format);
+            return 0;
+        }
+        uint32_t uvStrideBytes = uvStridePixels * bpp;
+        uint32_t uvHeight = totalHeight / 2;
+        uint32_t uvSize = uvStrideBytes * uvHeight * uvPlaneCount;
+
+        uint32_t dataSize = ySize + uvSize;
+        return dataSize;
+    } else {
+        uint32_t bpp = 4;
+        switch (format) {
+            case VIRGL_FORMAT_R16G16B16A16_FLOAT:
+            case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
+                bpp = 8;
+                break;
+            case VIRGL_FORMAT_B8G8R8X8_UNORM:
+            case VIRGL_FORMAT_B8G8R8A8_UNORM:
+            case VIRGL_FORMAT_R8G8B8X8_UNORM:
+            case VIRGL_FORMAT_R8G8B8A8_UNORM:
+            case VIRGL_FORMAT_R10G10B10A2_UNORM:
+            case VIRGL_FORMAT_Z24X8_UNORM:
+            case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
+            case VIRGL_FORMAT_Z32_FLOAT:
+                bpp = 4;
+                break;
+            case VIRGL_FORMAT_R8G8B8_UNORM:
+                bpp = 3;
+                break;
+            case VIRGL_FORMAT_B5G6R5_UNORM:
+            case VIRGL_FORMAT_R16_UNORM:
+            case VIRGL_FORMAT_R8G8_UNORM:
+            case VIRGL_FORMAT_Z16_UNORM:
+                bpp = 2;
+                break;
+            case VIRGL_FORMAT_R8_UNORM:
+                bpp = 1;
+                break;
+            default:
+                stream_renderer_error("Unknown virgl format: 0x%x", format);
+                return 0;
+        }
+
+        uint32_t stride = totalWidth * bpp;
+        return (h - 1U) * stride + w * bpp;
+    }
+    return 0;
+}
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuFrontend.cpp b/host/VirtioGpuFrontend.cpp
new file mode 100644
index 000000000..664c13f69
--- /dev/null
+++ b/host/VirtioGpuFrontend.cpp
@@ -0,0 +1,1215 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VirtioGpuFrontend.h"
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include <filesystem>
+#include <fcntl.h>
+// X11 defines status as a preprocessor define which messes up
+// anyone with a `Status` type.
+#include <google/protobuf/io/zero_copy_stream_impl.h>
+#include <google/protobuf/text_format.h>
+#endif  // ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+#include <vulkan/vulkan.h>
+
+#include "FrameBuffer.h"
+#include "FrameworkFormats.h"
+#include "VkCommonOperations.h"
+#include "aemu/base/ManagedDescriptor.hpp"
+#include "aemu/base/files/StdioStream.h"
+#include "aemu/base/memory/SharedMemory.h"
+#include "aemu/base/threads/WorkerThread.h"
+#include "gfxstream/host/Tracing.h"
+#include "host-common/AddressSpaceService.h"
+#include "host-common/address_space_device.h"
+#include "host-common/address_space_device.hpp"
+#include "host-common/address_space_device_control_ops.h"
+#include "host-common/opengles.h"
+#include "virtgpu_gfxstream_protocol.h"
+
+namespace gfxstream {
+namespace host {
+namespace {
+
+using android::base::DescriptorType;
+using android::base::SharedMemory;
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+using gfxstream::host::snapshot::VirtioGpuContextSnapshot;
+using gfxstream::host::snapshot::VirtioGpuFrontendSnapshot;
+using gfxstream::host::snapshot::VirtioGpuResourceSnapshot;
+#endif  // ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+struct VirtioGpuCmd {
+    uint32_t op;
+    uint32_t cmdSize;
+    unsigned char buf[0];
+} __attribute__((packed));
+
+static uint64_t convert32to64(uint32_t lo, uint32_t hi) {
+    return ((uint64_t)lo) | (((uint64_t)hi) << 32);
+}
+
+}  // namespace
+
+class CleanupThread {
+   public:
+    using GenericCleanup = std::function<void()>;
+
+    CleanupThread()
+        : mWorker([](CleanupTask task) {
+              return std::visit(
+                  [](auto&& work) {
+                      using T = std::decay_t<decltype(work)>;
+                      if constexpr (std::is_same_v<T, GenericCleanup>) {
+                          work();
+                          return android::base::WorkerProcessingResult::Continue;
+                      } else if constexpr (std::is_same_v<T, Exit>) {
+                          return android::base::WorkerProcessingResult::Stop;
+                      }
+                  },
+                  std::move(task));
+          }) {
+        mWorker.start();
+    }
+
+    ~CleanupThread() { stop(); }
+
+    // CleanupThread is neither copyable nor movable.
+    CleanupThread(const CleanupThread& other) = delete;
+    CleanupThread& operator=(const CleanupThread& other) = delete;
+    CleanupThread(CleanupThread&& other) = delete;
+    CleanupThread& operator=(CleanupThread&& other) = delete;
+
+    void enqueueCleanup(GenericCleanup command) { mWorker.enqueue(std::move(command)); }
+
+    void waitForPendingCleanups() {
+        std::promise<void> pendingCleanupsCompletedSignal;
+        std::future<void> pendingCleanupsCompltedWaitable = pendingCleanupsCompletedSignal.get_future();
+        enqueueCleanup([&]() { pendingCleanupsCompletedSignal.set_value(); });
+        pendingCleanupsCompltedWaitable.wait();
+    }
+
+    void stop() {
+        mWorker.enqueue(Exit{});
+        mWorker.join();
+    }
+
+   private:
+    struct Exit {};
+    using CleanupTask = std::variant<GenericCleanup, Exit>;
+    android::base::WorkerThread<CleanupTask> mWorker;
+};
+
+VirtioGpuFrontend::VirtioGpuFrontend() = default;
+
+int VirtioGpuFrontend::init(void* cookie, gfxstream::host::FeatureSet features,
+                            stream_renderer_fence_callback fence_callback) {
+    stream_renderer_debug("cookie: %p", cookie);
+    mCookie = cookie;
+    mFeatures = features;
+    mFenceCallback = fence_callback;
+    mAddressSpaceDeviceControlOps = get_address_space_device_control_ops();
+    if (!mAddressSpaceDeviceControlOps) {
+        stream_renderer_error("Could not get address space device control ops!");
+        return -EINVAL;
+    }
+
+    // Forwards fence completions from VirtioGpuTimelines to the client (VMM).
+    auto fenceCompletionCallback = [this](const VirtioGpuTimelines::Ring& ring,
+                                          VirtioGpuTimelines::FenceId fenceId) {
+        struct stream_renderer_fence fence = {0};
+        fence.fence_id = fenceId;
+        fence.flags = STREAM_RENDERER_FLAG_FENCE;
+        if (const auto* contextSpecificRing = std::get_if<VirtioGpuRingContextSpecific>(&ring)) {
+            fence.flags |= STREAM_RENDERER_FLAG_FENCE_RING_IDX;
+            fence.ctx_id = contextSpecificRing->mCtxId;
+            fence.ring_idx = contextSpecificRing->mRingIdx;
+        }
+        mFenceCallback(mCookie, &fence);
+    };
+    mVirtioGpuTimelines = VirtioGpuTimelines::create(std::move(fenceCompletionCallback));
+
+#if !defined(_WIN32)
+    mPageSize = getpagesize();
+#endif
+
+    mCleanupThread.reset(new CleanupThread());
+
+    return 0;
+}
+
+void VirtioGpuFrontend::teardown() {
+    destroyVirtioGpuObjects();
+
+    mCleanupThread.reset();
+}
+
+int VirtioGpuFrontend::resetPipe(VirtioGpuContextId contextId, GoldfishHostPipe* hostPipe) {
+    stream_renderer_debug("reset pipe for context %u to hostpipe %p", contextId, hostPipe);
+
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to reset pipe: context %u not found.", contextId);
+        return -EINVAL;
+    }
+    auto& context = contextIt->second;
+    context.SetHostPipe(hostPipe);
+
+    // Also update any resources associated with it
+    for (auto resourceId : context.GetAttachedResources()) {
+        auto resourceIt = mResources.find(resourceId);
+        if (resourceIt == mResources.end()) {
+            stream_renderer_error("failed to reset pipe: resource %d not found.", resourceId);
+            return -EINVAL;
+        }
+        auto& resource = resourceIt->second;
+        resource.SetHostPipe(hostPipe);
+    }
+
+    return 0;
+}
+
+int VirtioGpuFrontend::createContext(VirtioGpuCtxId contextId, uint32_t nlen, const char* name,
+                                     uint32_t contextInit) {
+    std::string contextName(name, nlen);
+
+    stream_renderer_debug("ctxid: %u len: %u name: %s", contextId, nlen, contextName.c_str());
+    auto ops = ensureAndGetServiceOps();
+
+    auto contextOpt = VirtioGpuContext::Create(ops, contextId, contextName, contextInit);
+    if (!contextOpt) {
+        stream_renderer_error("Failed to create context %u.", contextId);
+        return -EINVAL;
+    }
+    mContexts[contextId] = std::move(*contextOpt);
+    return 0;
+}
+
+int VirtioGpuFrontend::destroyContext(VirtioGpuCtxId contextId) {
+    stream_renderer_debug("ctxid: %u", contextId);
+
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to destroy context %d: context not found", contextId);
+        return -EINVAL;
+    }
+    auto& context = contextIt->second;
+
+    context.Destroy(ensureAndGetServiceOps(), mAddressSpaceDeviceControlOps);
+
+    mContexts.erase(contextIt);
+    return 0;
+}
+
+#define DECODE(variable, type, input) \
+    type variable = {};               \
+    memcpy(&variable, input, sizeof(type));
+
+int VirtioGpuFrontend::addressSpaceProcessCmd(VirtioGpuCtxId ctxId, uint32_t* dwords) {
+    DECODE(header, gfxstream::gfxstreamHeader, dwords)
+
+    auto contextIt = mContexts.find(ctxId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("ctx id %u not found", ctxId);
+        return -EINVAL;
+    }
+    auto& context = contextIt->second;
+
+    switch (header.opCode) {
+        case GFXSTREAM_CONTEXT_CREATE: {
+            DECODE(contextCreate, gfxstream::gfxstreamContextCreate, dwords)
+
+            auto resourceIt = mResources.find(contextCreate.resourceId);
+            if (resourceIt == mResources.end()) {
+                stream_renderer_error("ASG coherent resource %u not found",
+                                      contextCreate.resourceId);
+                return -EINVAL;
+            }
+            auto& resource = resourceIt->second;
+
+            return context.CreateAddressSpaceGraphicsInstance(mAddressSpaceDeviceControlOps,
+                                                              resource);
+        }
+        case GFXSTREAM_CONTEXT_PING: {
+            DECODE(contextPing, gfxstream::gfxstreamContextPing, dwords)
+
+            return context.PingAddressSpaceGraphicsInstance(mAddressSpaceDeviceControlOps,
+                                                            contextPing.resourceId);
+        }
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+int VirtioGpuFrontend::submitCmd(struct stream_renderer_command* cmd) {
+    if (!cmd) return -EINVAL;
+
+    void* buffer = reinterpret_cast<void*>(cmd->cmd);
+
+    VirtioGpuRing ring = VirtioGpuRingGlobal{};
+    stream_renderer_debug("ctx: % u, ring: %s buffer: %p dwords: %d", cmd->ctx_id,
+                          to_string(ring).c_str(), buffer, cmd->cmd_size);
+
+    if (!buffer) {
+        stream_renderer_error("error: buffer null");
+        return -EINVAL;
+    }
+
+    if (cmd->cmd_size < 4) {
+        stream_renderer_error("error: not enough bytes (got %d)", cmd->cmd_size);
+        return -EINVAL;
+    }
+
+    DECODE(header, gfxstream::gfxstreamHeader, buffer);
+    switch (header.opCode) {
+        case GFXSTREAM_CONTEXT_CREATE:
+        case GFXSTREAM_CONTEXT_PING:
+        case GFXSTREAM_CONTEXT_PING_WITH_RESPONSE: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_CONTEXT_[CREATE|PING]");
+
+            if (addressSpaceProcessCmd(cmd->ctx_id, (uint32_t*)buffer)) {
+                return -EINVAL;
+            }
+            break;
+        }
+        case GFXSTREAM_CREATE_EXPORT_SYNC: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_CREATE_EXPORT_SYNC");
+
+            // Make sure the context-specific ring is used
+            ring = VirtioGpuRingContextSpecific{
+                .mCtxId = cmd->ctx_id,
+                .mRingIdx = 0,
+            };
+
+            DECODE(exportSync, gfxstream::gfxstreamCreateExportSync, buffer)
+
+            uint64_t sync_handle = convert32to64(exportSync.syncHandleLo, exportSync.syncHandleHi);
+
+            stream_renderer_debug("wait for gpu ring %s", to_string(ring).c_str());
+            auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
+#if GFXSTREAM_ENABLE_HOST_GLES
+            gfxstream::FrameBuffer::getFB()->asyncWaitForGpuWithCb(
+                sync_handle, [this, taskId] { mVirtioGpuTimelines->notifyTaskCompletion(taskId); });
+#endif
+            break;
+        }
+        case GFXSTREAM_CREATE_EXPORT_SYNC_VK:
+        case GFXSTREAM_CREATE_IMPORT_SYNC_VK: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_CREATE_[IMPORT|EXPORT]_SYNC_VK");
+
+            // The guest sync export assumes fence context support and always uses
+            // VIRTGPU_EXECBUF_RING_IDX. With this, the task created here must use
+            // the same ring as the fence created for the virtio gpu command or the
+            // fence may be signaled without properly waiting for the task to complete.
+            ring = VirtioGpuRingContextSpecific{
+                .mCtxId = cmd->ctx_id,
+                .mRingIdx = 0,
+            };
+
+            DECODE(exportSyncVK, gfxstream::gfxstreamCreateExportSyncVK, buffer)
+
+            uint64_t device_handle =
+                convert32to64(exportSyncVK.deviceHandleLo, exportSyncVK.deviceHandleHi);
+
+            uint64_t fence_handle =
+                convert32to64(exportSyncVK.fenceHandleLo, exportSyncVK.fenceHandleHi);
+
+            stream_renderer_debug("wait for gpu ring %s", to_string(ring).c_str());
+            auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
+            gfxstream::FrameBuffer::getFB()->asyncWaitForGpuVulkanWithCb(
+                device_handle, fence_handle,
+                [this, taskId] { mVirtioGpuTimelines->notifyTaskCompletion(taskId); });
+            break;
+        }
+        case GFXSTREAM_CREATE_QSRI_EXPORT_VK: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_CREATE_QSRI_EXPORT_VK");
+
+            // The guest QSRI export assumes fence context support and always uses
+            // VIRTGPU_EXECBUF_RING_IDX. With this, the task created here must use
+            // the same ring as the fence created for the virtio gpu command or the
+            // fence may be signaled without properly waiting for the task to complete.
+            ring = VirtioGpuRingContextSpecific{
+                .mCtxId = cmd->ctx_id,
+                .mRingIdx = 0,
+            };
+
+            DECODE(exportQSRI, gfxstream::gfxstreamCreateQSRIExportVK, buffer)
+
+            uint64_t image_handle =
+                convert32to64(exportQSRI.imageHandleLo, exportQSRI.imageHandleHi);
+
+            stream_renderer_debug("wait for gpu vk qsri ring %u image 0x%llx",
+                                  to_string(ring).c_str(), (unsigned long long)image_handle);
+            auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
+            gfxstream::FrameBuffer::getFB()->asyncWaitForGpuVulkanQsriWithCb(
+                image_handle,
+                [this, taskId] { mVirtioGpuTimelines->notifyTaskCompletion(taskId); });
+            break;
+        }
+        case GFXSTREAM_RESOURCE_CREATE_3D: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_RESOURCE_CREATE_3D");
+
+            DECODE(create3d, gfxstream::gfxstreamResourceCreate3d, buffer)
+            struct stream_renderer_resource_create_args rc3d = {0};
+
+            rc3d.target = create3d.target;
+            rc3d.format = create3d.format;
+            rc3d.bind = create3d.bind;
+            rc3d.width = create3d.width;
+            rc3d.height = create3d.height;
+            rc3d.depth = create3d.depth;
+            rc3d.array_size = create3d.arraySize;
+            rc3d.last_level = create3d.lastLevel;
+            rc3d.nr_samples = create3d.nrSamples;
+            rc3d.flags = create3d.flags;
+
+            auto contextIt = mContexts.find(cmd->ctx_id);
+            if (contextIt == mContexts.end()) {
+                stream_renderer_error("ctx id %u is not found", cmd->ctx_id);
+                return -EINVAL;
+            }
+            auto& context = contextIt->second;
+
+            return context.AddPendingBlob(create3d.blobId, rc3d);
+        }
+        case GFXSTREAM_ACQUIRE_SYNC: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_ACQUIRE_SYNC");
+
+            DECODE(acquireSync, gfxstream::gfxstreamAcquireSync, buffer);
+
+            auto contextIt = mContexts.find(cmd->ctx_id);
+            if (contextIt == mContexts.end()) {
+                stream_renderer_error("ctx id %u is not found", cmd->ctx_id);
+                return -EINVAL;
+            }
+            auto& context = contextIt->second;
+            return context.AcquireSync(acquireSync.syncId);
+        }
+        case GFXSTREAM_PLACEHOLDER_COMMAND_VK: {
+            GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                                  "GFXSTREAM_PLACEHOLDER_COMMAND_VK");
+
+            // Do nothing, this is a placeholder command
+            break;
+        }
+        default:
+            return -EINVAL;
+    }
+
+    return 0;
+}
+
+int VirtioGpuFrontend::createFence(uint64_t fence_id, const VirtioGpuRing& ring) {
+    stream_renderer_debug("fenceid: %llu ring: %s", (unsigned long long)fence_id,
+                          to_string(ring).c_str());
+
+    mVirtioGpuTimelines->enqueueFence(ring, fence_id);
+
+    return 0;
+}
+
+int VirtioGpuFrontend::acquireContextFence(uint32_t contextId, uint64_t fenceId) {
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to acquire context %u fence: context not found", contextId);
+        return -EINVAL;
+    }
+    auto& context = contextIt->second;
+
+    auto syncInfoOpt = context.TakeSync();
+    if (!syncInfoOpt) {
+        stream_renderer_error("failed to acquire context %u fence: no sync acquired", contextId);
+        return -EINVAL;
+    }
+
+    mSyncMap[fenceId] = std::make_shared<gfxstream::SyncDescriptorInfo>(std::move(*syncInfoOpt));
+
+    return 0;
+}
+
+void VirtioGpuFrontend::poll() { mVirtioGpuTimelines->poll(); }
+
+int VirtioGpuFrontend::createResource(struct stream_renderer_resource_create_args* args,
+                                      struct iovec* iov, uint32_t num_iovs) {
+    auto resourceOpt = VirtioGpuResource::Create(args, iov, num_iovs);
+    if (!resourceOpt) {
+        stream_renderer_error("Failed to create resource %u.", args->handle);
+        return -EINVAL;
+    }
+    mResources[args->handle] = std::move(*resourceOpt);
+    return 0;
+}
+
+void VirtioGpuFrontend::unrefResource(uint32_t resourceId) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) return;
+    auto& resource = resourceIt->second;
+
+    auto attachedContextIds = resource.GetAttachedContexts();
+    for (auto contextId : attachedContextIds) {
+        detachResource(contextId, resourceId);
+    }
+
+    resource.Destroy();
+
+    mResources.erase(resourceIt);
+}
+
+int VirtioGpuFrontend::attachIov(int resourceId, struct iovec* iov, int num_iovs) {
+    stream_renderer_debug("resource:%d numiovs: %d", resourceId, num_iovs);
+
+    auto it = mResources.find(resourceId);
+    if (it == mResources.end()) {
+        stream_renderer_error("failed to attach iov: resource %u not found.", resourceId);
+        return ENOENT;
+    }
+    auto& resource = it->second;
+    resource.AttachIov(iov, num_iovs);
+    return 0;
+}
+
+void VirtioGpuFrontend::detachIov(int resourceId) {
+    stream_renderer_debug("resource:%d", resourceId);
+
+    auto it = mResources.find(resourceId);
+    if (it == mResources.end()) {
+        stream_renderer_error("failed to detach iov: resource %u not found.", resourceId);
+        return;
+    }
+    auto& resource = it->second;
+    resource.DetachIov();
+}
+
+namespace {
+
+std::optional<std::vector<struct iovec>> AsVecOption(struct iovec* iov, int iovec_cnt) {
+    if (iovec_cnt > 0) {
+        std::vector<struct iovec> ret;
+        ret.reserve(iovec_cnt);
+        for (int i = 0; i < iovec_cnt; i++) {
+            ret.push_back(iov[i]);
+        }
+        return ret;
+    }
+    return std::nullopt;
+}
+
+}  // namespace
+
+int VirtioGpuFrontend::transferReadIov(int resId, uint64_t offset, stream_renderer_box* box,
+                                       struct iovec* iov, int iovec_cnt) {
+    auto it = mResources.find(resId);
+    if (it == mResources.end()) {
+        stream_renderer_error("Failed to transfer: failed to find resource %d.", resId);
+        return EINVAL;
+    }
+    auto& resource = it->second;
+
+    auto ops = ensureAndGetServiceOps();
+    return resource.TransferRead(ops, offset, box, AsVecOption(iov, iovec_cnt));
+}
+
+int VirtioGpuFrontend::transferWriteIov(int resId, uint64_t offset, stream_renderer_box* box,
+                                        struct iovec* iov, int iovec_cnt) {
+    auto it = mResources.find(resId);
+    if (it == mResources.end()) {
+        stream_renderer_error("Failed to transfer: failed to find resource %d.", resId);
+        return EINVAL;
+    }
+    auto& resource = it->second;
+
+    auto ops = ensureAndGetServiceOps();
+    auto result = resource.TransferWrite(ops, offset, box, AsVecOption(iov, iovec_cnt));
+    if (result.status != 0) return result.status;
+
+    if (result.contextPipe) {
+        resetPipe(result.contextId, result.contextPipe);
+    }
+    return 0;
+}
+
+void VirtioGpuFrontend::getCapset(uint32_t set, uint32_t* max_size) {
+    switch (set) {
+        case VIRTGPU_CAPSET_GFXSTREAM_VULKAN:
+            *max_size = sizeof(struct gfxstream::vulkanCapset);
+            break;
+        case VIRTGPU_CAPSET_GFXSTREAM_MAGMA:
+            *max_size = sizeof(struct gfxstream::magmaCapset);
+            break;
+        case VIRTGPU_CAPSET_GFXSTREAM_GLES:
+            *max_size = sizeof(struct gfxstream::glesCapset);
+            break;
+        case VIRTGPU_CAPSET_GFXSTREAM_COMPOSER:
+            *max_size = sizeof(struct gfxstream::composerCapset);
+            break;
+        default:
+            stream_renderer_error("Incorrect capability set specified (%u)", set);
+    }
+}
+
+void VirtioGpuFrontend::fillCaps(uint32_t set, void* caps) {
+    switch (set) {
+        case VIRTGPU_CAPSET_GFXSTREAM_VULKAN: {
+            struct gfxstream::vulkanCapset* capset =
+                reinterpret_cast<struct gfxstream::vulkanCapset*>(caps);
+
+            memset(capset, 0, sizeof(*capset));
+
+            capset->protocolVersion = 1;
+            capset->ringSize = 12288;
+            capset->bufferSize = 1048576;
+
+            auto vk_emu = gfxstream::vk::getGlobalVkEmulation();
+            if (vk_emu && vk_emu->live && vk_emu->representativeColorBufferMemoryTypeInfo) {
+                capset->colorBufferMemoryIndex =
+                    vk_emu->representativeColorBufferMemoryTypeInfo->guestMemoryTypeIndex;
+            }
+
+            if (mFeatures.VulkanBatchedDescriptorSetUpdate.enabled) {
+                capset->vulkanBatchedDescriptorSetUpdate=1;
+            }
+            capset->noRenderControlEnc = 1;
+            capset->blobAlignment = mPageSize;
+            if (vk_emu && vk_emu->live) {
+                capset->deferredMapping = 1;
+            }
+
+#if GFXSTREAM_UNSTABLE_VULKAN_DMABUF_WINSYS
+            capset->alwaysBlob = 1;
+#endif
+
+#if GFXSTREAM_UNSTABLE_VULKAN_EXTERNAL_SYNC
+            capset->externalSync = 1;
+#endif
+
+            memset(capset->virglSupportedFormats, 0, sizeof(capset->virglSupportedFormats));
+
+            struct FormatWithName {
+                uint32_t format;
+                const char* name;
+            };
+#define MAKE_FORMAT_AND_NAME(x) \
+    {                           \
+        x, #x                   \
+    }
+            static const FormatWithName kPossibleFormats[] = {
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B5G6R5_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B8G8R8A8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B8G8R8X8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_NV12),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_P010),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R10G10B10A2_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R16_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R16G16B16A16_FLOAT),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8A8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8X8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_YV12),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z16_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z24_UNORM_S8_UINT),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z24X8_UNORM),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT),
+                MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z32_FLOAT),
+            };
+#undef MAKE_FORMAT_AND_NAME
+
+            stream_renderer_info("Format support:");
+            for (std::size_t i = 0; i < std::size(kPossibleFormats); i++) {
+                const FormatWithName& possibleFormat = kPossibleFormats[i];
+
+                GLenum possibleFormatGl = virgl_format_to_gl(possibleFormat.format);
+                const bool supported =
+                    gfxstream::FrameBuffer::getFB()->isFormatSupported(possibleFormatGl);
+
+                stream_renderer_info(" %s: %s", possibleFormat.name,
+                                     (supported ? "supported" : "unsupported"));
+                set_virgl_format_supported(capset->virglSupportedFormats, possibleFormat.format,
+                                           supported);
+            }
+            break;
+        }
+        case VIRTGPU_CAPSET_GFXSTREAM_MAGMA: {
+            struct gfxstream::magmaCapset* capset =
+                reinterpret_cast<struct gfxstream::magmaCapset*>(caps);
+
+            capset->protocolVersion = 1;
+            capset->ringSize = 12288;
+            capset->bufferSize = 1048576;
+            capset->blobAlignment = mPageSize;
+            break;
+        }
+        case VIRTGPU_CAPSET_GFXSTREAM_GLES: {
+            struct gfxstream::glesCapset* capset =
+                reinterpret_cast<struct gfxstream::glesCapset*>(caps);
+
+            capset->protocolVersion = 1;
+            capset->ringSize = 12288;
+            capset->bufferSize = 1048576;
+            capset->blobAlignment = mPageSize;
+            break;
+        }
+        case VIRTGPU_CAPSET_GFXSTREAM_COMPOSER: {
+            struct gfxstream::composerCapset* capset =
+                reinterpret_cast<struct gfxstream::composerCapset*>(caps);
+
+            capset->protocolVersion = 1;
+            capset->ringSize = 12288;
+            capset->bufferSize = 1048576;
+            capset->blobAlignment = mPageSize;
+            break;
+        }
+        default:
+            stream_renderer_error("Incorrect capability set specified");
+    }
+}
+
+void VirtioGpuFrontend::attachResource(uint32_t contextId, uint32_t resourceId) {
+    stream_renderer_debug("ctxid: %u resid: %u", contextId, resourceId);
+
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to attach resource %u to context %u: context not found.",
+                              resourceId, contextId);
+        return;
+    }
+    auto& context = contextIt->second;
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("failed to attach resource %u to context %u: resource not found.",
+                              resourceId, contextId);
+        return;
+    }
+    auto& resource = resourceIt->second;
+
+    context.AttachResource(resource);
+}
+
+void VirtioGpuFrontend::detachResource(uint32_t contextId, uint32_t resourceId) {
+    stream_renderer_debug("ctxid: %u resid: %u", contextId, resourceId);
+
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to detach resource %u to context %u: context not found.",
+                              resourceId, contextId);
+        return;
+    }
+    auto& context = contextIt->second;
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("failed to attach resource %u to context %u: resource not found.",
+                              resourceId, contextId);
+        return;
+    }
+    auto& resource = resourceIt->second;
+
+    auto resourceAsgOpt = context.TakeAddressSpaceGraphicsHandle(resourceId);
+    if (resourceAsgOpt) {
+        mCleanupThread->enqueueCleanup(
+            [this, asgBlob = resource.ShareRingBlob(), asgHandle = *resourceAsgOpt]() {
+                mAddressSpaceDeviceControlOps->destroy_handle(asgHandle);
+            });
+    }
+
+    context.DetachResource(resource);
+}
+
+int VirtioGpuFrontend::getResourceInfo(uint32_t resourceId,
+                                       struct stream_renderer_resource_info* info) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    if (!info) {
+        stream_renderer_error("Failed to get info: invalid info struct.");
+        return EINVAL;
+    }
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("Failed to get info: failed to find resource %d.", resourceId);
+        return ENOENT;
+    }
+    auto& resource = resourceIt->second;
+    return resource.GetInfo(info);
+}
+
+void VirtioGpuFrontend::flushResource(uint32_t res_handle) {
+    auto taskId = mVirtioGpuTimelines->enqueueTask(VirtioGpuRingGlobal{});
+    gfxstream::FrameBuffer::getFB()->postWithCallback(
+        res_handle, [this, taskId](std::shared_future<void> waitForGpu) {
+            waitForGpu.wait();
+            mVirtioGpuTimelines->notifyTaskCompletion(taskId);
+        });
+}
+
+int VirtioGpuFrontend::createBlob(uint32_t contextId, uint32_t resourceId,
+                                  const struct stream_renderer_create_blob* createBlobArgs,
+                                  const struct stream_renderer_handle* handle) {
+    auto contextIt = mContexts.find(contextId);
+    if (contextIt == mContexts.end()) {
+        stream_renderer_error("failed to create blob resource %u: context %u missing.", resourceId,
+                              contextId);
+        return -EINVAL;
+    }
+    auto& context = contextIt->second;
+
+    auto createArgs = context.TakePendingBlob(createBlobArgs->blob_id);
+
+    auto resourceOpt =
+        VirtioGpuResource::Create(mFeatures, mPageSize, contextId, resourceId,
+                                  createArgs ? &*createArgs : nullptr, createBlobArgs, handle);
+    if (!resourceOpt) {
+        stream_renderer_error("failed to create blob resource %u.", resourceId);
+        return -EINVAL;
+    }
+    mResources[resourceId] = std::move(*resourceOpt);
+    return 0;
+}
+
+int VirtioGpuFrontend::resourceMap(uint32_t resourceId, void** hvaOut, uint64_t* sizeOut) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    if (mFeatures.ExternalBlob.enabled) {
+        stream_renderer_error("Failed to map resource: external blob enabled.");
+        return -EINVAL;
+    }
+
+    auto it = mResources.find(resourceId);
+    if (it == mResources.end()) {
+        if (hvaOut) *hvaOut = nullptr;
+        if (sizeOut) *sizeOut = 0;
+
+        stream_renderer_error("Failed to map resource: unknown resource id %d.", resourceId);
+        return -EINVAL;
+    }
+
+    auto& resource = it->second;
+    return resource.Map(hvaOut, sizeOut);
+}
+
+int VirtioGpuFrontend::resourceUnmap(uint32_t resourceId) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    auto it = mResources.find(resourceId);
+    if (it == mResources.end()) {
+        stream_renderer_error("Failed to map resource: unknown resource id %d.", resourceId);
+        return -EINVAL;
+    }
+
+    // TODO(lfy): Good place to run any registered cleanup callbacks.
+    // No-op for now.
+    return 0;
+}
+
+int VirtioGpuFrontend::platformImportResource(int res_handle, int res_info, void* resource) {
+    auto it = mResources.find(res_handle);
+    if (it == mResources.end()) return -EINVAL;
+    bool success =
+        gfxstream::FrameBuffer::getFB()->platformImportResource(res_handle, res_info, resource);
+    return success ? 0 : -1;
+}
+
+void* VirtioGpuFrontend::platformCreateSharedEglContext() {
+    void* ptr = nullptr;
+#if GFXSTREAM_ENABLE_HOST_GLES
+    ptr = gfxstream::FrameBuffer::getFB()->platformCreateSharedEglContext();
+#endif
+    return ptr;
+}
+
+int VirtioGpuFrontend::platformDestroySharedEglContext(void* context) {
+    bool success = false;
+#if GFXSTREAM_ENABLE_HOST_GLES
+    success = gfxstream::FrameBuffer::getFB()->platformDestroySharedEglContext(context);
+#endif
+    return success ? 0 : -1;
+}
+
+int VirtioGpuFrontend::waitSyncResource(uint32_t res_handle) {
+    auto resourceIt = mResources.find(res_handle);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("waitSyncResource could not find resource: %d", res_handle);
+        return -EINVAL;
+    }
+    auto& resource = resourceIt->second;
+    return resource.WaitSyncResource();
+}
+
+int VirtioGpuFrontend::resourceMapInfo(uint32_t resourceId, uint32_t* map_info) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("Failed to get resource map info: unknown resource %d.", resourceId);
+        return -EINVAL;
+    }
+
+    const auto& resource = resourceIt->second;
+    return resource.GetCaching(map_info);
+}
+
+int VirtioGpuFrontend::exportBlob(uint32_t resourceId, struct stream_renderer_handle* handle) {
+    stream_renderer_debug("resource: %u", resourceId);
+
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("Failed to export blob: unknown resource %d.", resourceId);
+        return -EINVAL;
+    }
+    auto& resource = resourceIt->second;
+    return resource.ExportBlob(handle);
+}
+
+int VirtioGpuFrontend::exportFence(uint64_t fenceId, struct stream_renderer_handle* handle) {
+    auto it = mSyncMap.find(fenceId);
+    if (it == mSyncMap.end()) {
+        return -EINVAL;
+    }
+
+    auto& entry = it->second;
+    DescriptorType rawDescriptor;
+    auto rawDescriptorOpt = entry->descriptor.release();
+    if (rawDescriptorOpt)
+        rawDescriptor = *rawDescriptorOpt;
+    else
+        return -EINVAL;
+
+    handle->handle_type = entry->handleType;
+
+#ifdef _WIN32
+    handle->os_handle = static_cast<int64_t>(reinterpret_cast<intptr_t>(rawDescriptor));
+#else
+    handle->os_handle = static_cast<int64_t>(rawDescriptor);
+#endif
+
+    return 0;
+}
+
+int VirtioGpuFrontend::vulkanInfo(uint32_t resourceId,
+                                  struct stream_renderer_vulkan_info* vulkanInfo) {
+    auto resourceIt = mResources.find(resourceId);
+    if (resourceIt == mResources.end()) {
+        stream_renderer_error("failed to get vulkan info: failed to find resource %d", resourceId);
+        return -EINVAL;
+    }
+    auto& resource = resourceIt->second;
+    return resource.GetVulkanInfo(vulkanInfo);
+}
+
+int VirtioGpuFrontend::destroyVirtioGpuObjects() {
+    {
+        std::vector<VirtioGpuResourceId> resourceIds;
+        resourceIds.reserve(mResources.size());
+        for (auto& [resourceId, resource] : mResources) {
+            const auto contextIds = resource.GetAttachedContexts();
+            for (const VirtioGpuContextId contextId : contextIds) {
+                detachResource(contextId, resourceId);
+            }
+            resourceIds.push_back(resourceId);
+        }
+        for (const VirtioGpuResourceId resourceId : resourceIds) {
+            unrefResource(resourceId);
+        }
+        mResources.clear();
+    }
+    {
+        std::vector<VirtioGpuContextId> contextIds;
+        contextIds.reserve(mContexts.size());
+        for (const auto& [contextId, _] : mContexts) {
+            contextIds.push_back(contextId);
+        }
+        for (const VirtioGpuContextId contextId : contextIds) {
+            destroyContext(contextId);
+        }
+        mContexts.clear();
+    }
+
+    if (mCleanupThread) {
+        mCleanupThread->waitForPendingCleanups();
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_AEMU
+void VirtioGpuFrontend::setServiceOps(const GoldfishPipeServiceOps* ops) { mServiceOps = ops; }
+#endif  // CONFIG_AEMU
+
+inline const GoldfishPipeServiceOps* VirtioGpuFrontend::ensureAndGetServiceOps() {
+    if (mServiceOps) return mServiceOps;
+    mServiceOps = goldfish_pipe_get_service_ops();
+    return mServiceOps;
+}
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+static constexpr const char kSnapshotBasenameAsg[] = "gfxstream_asg.bin";
+static constexpr const char kSnapshotBasenameFrontend[] = "gfxstream_frontend.txtproto";
+static constexpr const char kSnapshotBasenameRenderer[] = "gfxstream_renderer.bin";
+
+int VirtioGpuFrontend::snapshotRenderer(const char* directory) {
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameRenderer;
+
+    android::base::StdioStream stream(fopen(snapshotPath.c_str(), "wb"),
+                                      android::base::StdioStream::kOwner);
+    android::snapshot::SnapshotSaveStream saveStream{
+        .stream = &stream,
+    };
+
+    android_getOpenglesRenderer()->save(saveStream.stream, saveStream.textureSaver);
+    return 0;
+}
+
+int VirtioGpuFrontend::snapshotFrontend(const char* directory) {
+    gfxstream::host::snapshot::VirtioGpuFrontendSnapshot snapshot;
+
+    for (const auto& [contextId, context] : mContexts) {
+        auto contextSnapshotOpt = context.Snapshot();
+        if (!contextSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot context %d", contextId);
+            return -1;
+        }
+        (*snapshot.mutable_contexts())[contextId] = std::move(*contextSnapshotOpt);
+    }
+    for (const auto& [resourceId, resource] : mResources) {
+        auto resourceSnapshotOpt = resource.Snapshot();
+        if (!resourceSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot resource %d", resourceId);
+            return -1;
+        }
+        (*snapshot.mutable_resources())[resourceId] = std::move(*resourceSnapshotOpt);
+    }
+
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameFrontend;
+    int snapshotFd = open(snapshotPath.c_str(), O_CREAT | O_WRONLY | O_TRUNC, 0660);
+    if (snapshotFd < 0) {
+        stream_renderer_error("Failed to save snapshot: failed to open %s", snapshotPath.c_str());
+        return -1;
+    }
+    google::protobuf::io::FileOutputStream snapshotOutputStream(snapshotFd);
+    snapshotOutputStream.SetCloseOnDelete(true);
+    if (!google::protobuf::TextFormat::Print(snapshot, &snapshotOutputStream)) {
+        stream_renderer_error("Failed to save snapshot: failed to serialize to stream.");
+        return -1;
+    }
+
+    return 0;
+}
+
+int VirtioGpuFrontend::snapshotAsg(const char* directory) {
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameAsg;
+
+    android::base::StdioStream stream(fopen(snapshotPath.c_str(), "wb"),
+                                      android::base::StdioStream::kOwner);
+    android::snapshot::SnapshotLoadStream saveStream{
+        .stream = &stream,
+    };
+
+    int ret = android::emulation::goldfish_address_space_memory_state_save(saveStream.stream);
+    if (ret) {
+        stream_renderer_error("Failed to save snapshot: failed to save ASG state.");
+        return ret;
+    }
+    return 0;
+}
+
+int VirtioGpuFrontend::snapshot(const char* directory) {
+    stream_renderer_debug("directory:%s", directory);
+
+    android_getOpenglesRenderer()->pauseAllPreSave();
+
+    int ret = snapshotRenderer(directory);
+    if (ret) {
+        stream_renderer_error("Failed to save snapshot: failed to snapshot renderer.");
+        return ret;
+    }
+
+    ret = snapshotFrontend(directory);
+    if (ret) {
+        stream_renderer_error("Failed to save snapshot: failed to snapshot frontend.");
+        return ret;
+    }
+
+    ret = snapshotAsg(directory);
+    if (ret) {
+        stream_renderer_error("Failed to save snapshot: failed to snapshot ASG device.");
+        return ret;
+    }
+
+    stream_renderer_debug("directory:%s - done!", directory);
+    return 0;
+}
+
+int VirtioGpuFrontend::restoreRenderer(const char* directory) {
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameRenderer;
+
+    android::base::StdioStream stream(fopen(snapshotPath.c_str(), "rb"),
+                                      android::base::StdioStream::kOwner);
+    android::snapshot::SnapshotLoadStream loadStream{
+        .stream = &stream,
+    };
+
+    android_getOpenglesRenderer()->load(loadStream.stream, loadStream.textureLoader);
+    return 0;
+}
+
+int VirtioGpuFrontend::restoreFrontend(const char* directory) {
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameFrontend;
+
+    gfxstream::host::snapshot::VirtioGpuFrontendSnapshot snapshot;
+    {
+        int snapshotFd = open(snapshotPath.c_str(), O_RDONLY);
+        if (snapshotFd < 0) {
+            stream_renderer_error("Failed to restore snapshot: failed to open %s",
+                                snapshotPath.c_str());
+            return -1;
+        }
+        google::protobuf::io::FileInputStream snapshotInputStream(snapshotFd);
+        snapshotInputStream.SetCloseOnDelete(true);
+        if (!google::protobuf::TextFormat::Parse(&snapshotInputStream, &snapshot)) {
+            stream_renderer_error("Failed to restore snapshot: failed to parse from file.");
+            return -1;
+        }
+    }
+
+    mContexts.clear();
+    mResources.clear();
+
+    for (const auto& [contextId, contextSnapshot] : snapshot.contexts()) {
+        auto contextOpt = VirtioGpuContext::Restore(contextSnapshot);
+        if (!contextOpt) {
+            stream_renderer_error("Failed to restore context %d", contextId);
+            return -1;
+        }
+        mContexts.emplace(contextId, std::move(*contextOpt));
+    }
+    for (const auto& [resourceId, resourceSnapshot] : snapshot.resources()) {
+        auto resourceOpt = VirtioGpuResource::Restore(resourceSnapshot);
+        if (!resourceOpt) {
+            stream_renderer_error("Failed to restore resource %d", resourceId);
+            return -1;
+        }
+        mResources.emplace(resourceId, std::move(*resourceOpt));
+    }
+    return 0;
+}
+
+int VirtioGpuFrontend::restoreAsg(const char* directory) {
+    const std::filesystem::path snapshotDirectory = std::string(directory);
+    const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameAsg;
+
+    android::base::StdioStream stream(fopen(snapshotPath.c_str(), "rb"),
+                                      android::base::StdioStream::kOwner);
+    android::snapshot::SnapshotLoadStream loadStream{
+        .stream = &stream,
+    };
+
+    // Gather external memory info that the ASG device needs to reload.
+    android::emulation::AddressSpaceDeviceLoadResources asgLoadResources;
+    for (const auto& [contextId, context] : mContexts) {
+        for (const auto [resourceId, asgId] : context.AsgInstances()) {
+            auto resourceIt = mResources.find(resourceId);
+            if (resourceIt == mResources.end()) {
+                stream_renderer_error("Failed to restore ASG device: context %" PRIu32
+                                      " claims resource %" PRIu32 " is used for ASG %" PRIu32
+                                      " but resource not found.",
+                                      contextId, resourceId, asgId);
+                return -1;
+            }
+            auto& resource = resourceIt->second;
+
+            void* mappedAddr = nullptr;
+            uint64_t mappedSize = 0;
+
+            int ret = resource.Map(&mappedAddr, &mappedSize);
+            if (ret) {
+                stream_renderer_error("Failed to restore ASG device: failed to map resource %" PRIu32, resourceId);
+                return -1;
+            }
+
+            asgLoadResources.contextExternalMemoryMap[asgId] = {
+                .externalAddress = mappedAddr,
+                .externalAddressSize = mappedSize,
+            };
+        }
+    }
+
+    int ret = android::emulation::goldfish_address_space_memory_state_set_load_resources(asgLoadResources);
+    if (ret) {
+        stream_renderer_error("Failed to restore ASG device: failed to set ASG load resources.");
+        return ret;
+    }
+
+    ret = android::emulation::goldfish_address_space_memory_state_load(loadStream.stream);
+    if (ret) {
+        stream_renderer_error("Failed to restore ASG device: failed to restore ASG state.");
+        return ret;
+    }
+    return 0;
+}
+
+int VirtioGpuFrontend::restore(const char* directory) {
+    stream_renderer_debug("directory:%s", directory);
+
+    destroyVirtioGpuObjects();
+
+    int ret = restoreRenderer(directory);
+    if (ret) {
+        stream_renderer_error("Failed to load snapshot: failed to load renderer.");
+        return ret;
+    }
+
+    ret = restoreFrontend(directory);
+    if (ret) {
+        stream_renderer_error("Failed to load snapshot: failed to load frontend.");
+        return ret;
+    }
+
+    ret = restoreAsg(directory);
+    if (ret) {
+        stream_renderer_error("Failed to load snapshot: failed to load ASG device.");
+        return ret;
+    }
+
+    // In end2end tests, we don't really do snapshot save for render threads.
+    // We will need to resume all render threads without waiting for snapshot.
+    android_getOpenglesRenderer()->resumeAll(false);
+
+    stream_renderer_debug("directory:%s - done!", directory);
+    return 0;
+}
+
+#endif  // ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+}  // namespace host
+}  // namespace gfxstream
diff --git a/host/VirtioGpuFrontend.h b/host/VirtioGpuFrontend.h
new file mode 100644
index 000000000..9691d7a8f
--- /dev/null
+++ b/host/VirtioGpuFrontend.h
@@ -0,0 +1,166 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <stdint.h>
+
+#include <memory>
+#include <unordered_map>
+
+extern "C" {
+#include "gfxstream/virtio-gpu-gfxstream-renderer-unstable.h"
+#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
+#include "host-common/goldfish_pipe.h"
+}  // extern "C"
+
+#include "VirtioGpu.h"
+#include "VirtioGpuContext.h"
+#include "VirtioGpuFormatUtils.h"
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "VirtioGpuFrontendSnapshot.pb.h"
+#endif
+#include "VirtioGpuResource.h"
+#include "VirtioGpuTimelines.h"
+#include "gfxstream/host/Features.h"
+#include "host-common/address_space_device.h"
+
+namespace gfxstream {
+namespace host {
+
+class CleanupThread;
+
+class VirtioGpuFrontend {
+   public:
+    VirtioGpuFrontend();
+
+    int init(void* cookie, gfxstream::host::FeatureSet features,
+             stream_renderer_fence_callback fence_callback);
+
+    void teardown();
+
+    int createContext(VirtioGpuContextId ctx_id, uint32_t nlen, const char* name,
+                      uint32_t context_init);
+
+    int destroyContext(VirtioGpuContextId handle);
+
+    int addressSpaceProcessCmd(VirtioGpuContextId ctxId, uint32_t* dwords);
+
+    int submitCmd(struct stream_renderer_command* cmd);
+
+    int createFence(uint64_t fence_id, const VirtioGpuRing& ring);
+
+    int acquireContextFence(uint32_t ctx_id, uint64_t fenceId);
+
+    void poll();
+
+    int createResource(struct stream_renderer_resource_create_args* args, struct iovec* iov,
+                       uint32_t num_iovs);
+    void unrefResource(uint32_t toUnrefId);
+
+    int attachIov(int resId, iovec* iov, int num_iovs);
+    void detachIov(int resId);
+
+    int transferReadIov(int resId, uint64_t offset, stream_renderer_box* box, struct iovec* iov,
+                        int iovec_cnt);
+    int transferWriteIov(int resId, uint64_t offset, stream_renderer_box* box, struct iovec* iov,
+                         int iovec_cnt);
+
+    void getCapset(uint32_t set, uint32_t* max_size);
+    void fillCaps(uint32_t set, void* caps);
+
+    void attachResource(uint32_t ctxId, uint32_t resId);
+    void detachResource(uint32_t ctxId, uint32_t toUnrefId);
+
+    int getResourceInfo(uint32_t resId, struct stream_renderer_resource_info* info);
+
+    void flushResource(uint32_t res_handle);
+
+    int createRingBlob(VirtioGpuResource& entry, uint32_t res_handle,
+                       const struct stream_renderer_create_blob* create_blob,
+                       const struct stream_renderer_handle* handle);
+
+    int createBlob(uint32_t ctx_id, uint32_t res_handle,
+                   const struct stream_renderer_create_blob* create_blob,
+                   const struct stream_renderer_handle* handle);
+
+    int resourceMap(uint32_t resourceId, void** hvaOut, uint64_t* sizeOut);
+    int resourceUnmap(uint32_t res_handle);
+
+    int platformImportResource(int res_handle, int res_info, void* resource);
+
+    void* platformCreateSharedEglContext();
+
+    int platformDestroySharedEglContext(void* context);
+
+    int waitSyncResource(uint32_t res_handle);
+
+    int resourceMapInfo(uint32_t resourceId, uint32_t* map_info);
+
+    int exportBlob(uint32_t resourceId, struct stream_renderer_handle* handle);
+
+    int exportFence(uint64_t fenceId, struct stream_renderer_handle* handle);
+    int vulkanInfo(uint32_t res_handle, struct stream_renderer_vulkan_info* vulkan_info);
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    int snapshot(const char* directory);
+    int restore(const char* directory);
+#endif  // GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+#ifdef CONFIG_AEMU
+    void setServiceOps(const GoldfishPipeServiceOps* ops);
+#endif  // CONFIG_AEMU
+
+   private:
+    int destroyVirtioGpuObjects();
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    int snapshotRenderer(const char* directory);
+    int snapshotFrontend(const char* directory);
+    int snapshotAsg(const char* directory);
+
+    int restoreRenderer(const char* directory);
+    int restoreFrontend(const char* directory);
+    int restoreAsg(const char* directory);
+#endif  // GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+    int resetPipe(VirtioGpuContextId contextId, GoldfishHostPipe* hostPipe);
+
+    const GoldfishPipeServiceOps* ensureAndGetServiceOps();
+
+    void* mCookie = nullptr;
+    gfxstream::host::FeatureSet mFeatures;
+    stream_renderer_fence_callback mFenceCallback;
+    uint32_t mPageSize = 4096;
+    struct ::address_space_device_control_ops* mAddressSpaceDeviceControlOps = nullptr;
+
+    const GoldfishPipeServiceOps* mServiceOps = nullptr;
+
+    // State that is preserved across snapshots:
+    //
+    // LINT.IfChange(virtio_gpu_frontend)
+    std::unordered_map<VirtioGpuContextId, VirtioGpuContext> mContexts;
+    std::unordered_map<VirtioGpuResourceId, VirtioGpuResource> mResources;
+    std::unordered_map<uint64_t, std::shared_ptr<SyncDescriptorInfo>> mSyncMap;
+    // When we wait for gpu or wait for gpu vulkan, the next (and subsequent)
+    // fences created for that context should not be signaled immediately.
+    // Rather, they should get in line.
+    std::unique_ptr<VirtioGpuTimelines> mVirtioGpuTimelines = nullptr;
+    // LINT.ThenChange(VirtioGpuFrontend.h:virtio_gpu_frontend)
+
+    std::unique_ptr<CleanupThread> mCleanupThread;
+};
+
+}  // namespace host
+}  // namespace gfxstream
diff --git a/host/VirtioGpuFrontendSnapshot.proto b/host/VirtioGpuFrontendSnapshot.proto
new file mode 100644
index 000000000..9b5d90267
--- /dev/null
+++ b/host/VirtioGpuFrontendSnapshot.proto
@@ -0,0 +1,30 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+import "VirtioGpuContextSnapshot.proto";
+import "VirtioGpuResourceSnapshot.proto";
+
+package gfxstream.host.snapshot;
+
+// The state of Gfxstream's Virtio GPU frontend that serialized and
+// deserialized during snapshot and restore operations.
+//
+// LINT.IfChange(virtio_gpu_frontend)
+message VirtioGpuFrontendSnapshot {
+    map<uint32, VirtioGpuContextSnapshot> contexts = 1;
+    map<uint32, VirtioGpuResourceSnapshot> resources = 2;
+}
+// LINT.ThenChange(VirtioGpuFrontend.h:virtio_gpu_frontend)
\ No newline at end of file
diff --git a/host/VirtioGpuResource.cpp b/host/VirtioGpuResource.cpp
new file mode 100644
index 000000000..70eca6857
--- /dev/null
+++ b/host/VirtioGpuResource.cpp
@@ -0,0 +1,985 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VirtioGpuResource.h"
+
+#include "FrameBuffer.h"
+#include "VirtioGpuFormatUtils.h"
+
+namespace gfxstream {
+namespace host {
+
+using android::base::DescriptorType;
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+using gfxstream::host::snapshot::VirtioGpuResourceCreateArgs;
+using gfxstream::host::snapshot::VirtioGpuResourceCreateBlobArgs;
+using gfxstream::host::snapshot::VirtioGpuResourceSnapshot;
+#endif
+
+namespace {
+
+static constexpr int kPipeTryAgain = -2;
+
+enum pipe_texture_target {
+    PIPE_BUFFER,
+    PIPE_TEXTURE_1D,
+    PIPE_TEXTURE_2D,
+    PIPE_TEXTURE_3D,
+    PIPE_TEXTURE_CUBE,
+    PIPE_TEXTURE_RECT,
+    PIPE_TEXTURE_1D_ARRAY,
+    PIPE_TEXTURE_2D_ARRAY,
+    PIPE_TEXTURE_CUBE_ARRAY,
+    PIPE_MAX_TEXTURE_TYPES,
+};
+
+/**
+ *  Resource binding flags -- state tracker must specify in advance all
+ *  the ways a resource might be used.
+ */
+#define PIPE_BIND_DEPTH_STENCIL (1 << 0)        /* create_surface */
+#define PIPE_BIND_RENDER_TARGET (1 << 1)        /* create_surface */
+#define PIPE_BIND_BLENDABLE (1 << 2)            /* create_surface */
+#define PIPE_BIND_SAMPLER_VIEW (1 << 3)         /* create_sampler_view */
+#define PIPE_BIND_VERTEX_BUFFER (1 << 4)        /* set_vertex_buffers */
+#define PIPE_BIND_INDEX_BUFFER (1 << 5)         /* draw_elements */
+#define PIPE_BIND_CONSTANT_BUFFER (1 << 6)      /* set_constant_buffer */
+#define PIPE_BIND_DISPLAY_TARGET (1 << 7)       /* flush_front_buffer */
+#define PIPE_BIND_STREAM_OUTPUT (1 << 10)       /* set_stream_output_buffers */
+#define PIPE_BIND_CURSOR (1 << 11)              /* mouse cursor */
+#define PIPE_BIND_CUSTOM (1 << 12)              /* state-tracker/winsys usages */
+#define PIPE_BIND_GLOBAL (1 << 13)              /* set_global_binding */
+#define PIPE_BIND_SHADER_BUFFER (1 << 14)       /* set_shader_buffers */
+#define PIPE_BIND_SHADER_IMAGE (1 << 15)        /* set_shader_images */
+#define PIPE_BIND_COMPUTE_RESOURCE (1 << 16)    /* set_compute_resources */
+#define PIPE_BIND_COMMAND_ARGS_BUFFER (1 << 17) /* pipe_draw_info.indirect */
+#define PIPE_BIND_QUERY_BUFFER (1 << 18)        /* get_query_result_resource */
+
+static inline uint32_t AlignUp(uint32_t n, uint32_t a) { return ((n + a - 1) / a) * a; }
+
+VirtioGpuResourceType GetResourceType(const struct stream_renderer_resource_create_args& args) {
+    if (args.target == PIPE_BUFFER) {
+        return VirtioGpuResourceType::PIPE;
+    }
+
+    if (args.format != VIRGL_FORMAT_R8_UNORM) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+    if (args.bind & VIRGL_BIND_SAMPLER_VIEW) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+    if (args.bind & VIRGL_BIND_RENDER_TARGET) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+    if (args.bind & VIRGL_BIND_SCANOUT) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+    if (args.bind & VIRGL_BIND_CURSOR) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+    if (!(args.bind & VIRGL_BIND_LINEAR)) {
+        return VirtioGpuResourceType::COLOR_BUFFER;
+    }
+
+    return VirtioGpuResourceType::BUFFER;
+}
+
+}  // namespace
+
+/*static*/
+std::optional<VirtioGpuResource> VirtioGpuResource::Create(
+    const struct stream_renderer_resource_create_args* args, struct iovec* iov, uint32_t num_iovs) {
+    stream_renderer_debug("resource id: %u", args->handle);
+
+    const auto resourceType = GetResourceType(*args);
+    if (resourceType == VirtioGpuResourceType::BLOB) {
+        stream_renderer_error("Failed to create resource: encountered blob.");
+        return std::nullopt;
+    }
+
+    if (resourceType == VirtioGpuResourceType::PIPE) {
+        // Frontend only resource.
+    } else if (resourceType == VirtioGpuResourceType::BUFFER) {
+        FrameBuffer::getFB()->createBufferWithHandle(args->width * args->height, args->handle);
+    } else if (resourceType == VirtioGpuResourceType::COLOR_BUFFER) {
+        const uint32_t glformat = virgl_format_to_gl(args->format);
+        const auto fwkformat = (gfxstream::FrameworkFormat)virgl_format_to_fwk_format(args->format);
+        const bool linear =
+#ifdef GFXSTREAM_ENABLE_GUEST_VIRTIO_RESOURCE_TILING_CONTROL
+            !!(args->bind & VIRGL_BIND_LINEAR);
+#else
+            false;
+#endif
+        FrameBuffer::getFB()->createColorBufferWithHandle(args->width, args->height, glformat,
+                                                          fwkformat, args->handle, linear);
+        FrameBuffer::getFB()->setGuestManagedColorBufferLifetime(true /* guest manages lifetime */);
+        FrameBuffer::getFB()->openColorBuffer(args->handle);
+    } else {
+        stream_renderer_error("Failed to create resource: unhandled type.");
+        return std::nullopt;
+    }
+
+    VirtioGpuResource resource;
+    resource.mId = args->handle;
+    resource.mResourceType = resourceType;
+    resource.mCreateArgs = *args;
+
+    resource.AttachIov(iov, num_iovs);
+
+    return resource;
+}
+
+/*static*/ std::optional<VirtioGpuResource> VirtioGpuResource::Create(
+    const gfxstream::host::FeatureSet& features, uint32_t pageSize, uint32_t contextId,
+    uint32_t resourceId, const struct stream_renderer_resource_create_args* createArgs,
+    const struct stream_renderer_create_blob* createBlobArgs,
+    const struct stream_renderer_handle* handle) {
+    VirtioGpuResource resource;
+
+    std::optional<BlobDescriptorInfo> descriptorInfoOpt;
+
+    if (createArgs != nullptr) {
+        auto resourceType = GetResourceType(*createArgs);
+        if (resourceType != VirtioGpuResourceType::BUFFER &&
+            resourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+            stream_renderer_error("failed to create blob resource: unhandled type.");
+            return std::nullopt;
+        }
+
+        auto resourceOpt = Create(createArgs, nullptr, 0);
+        if (!resourceOpt) {
+            return std::nullopt;
+        }
+
+        if (resourceType == VirtioGpuResourceType::BUFFER) {
+            descriptorInfoOpt = FrameBuffer::getFB()->exportBuffer(resourceId);
+        } else if (resourceType == VirtioGpuResourceType::COLOR_BUFFER) {
+            descriptorInfoOpt = FrameBuffer::getFB()->exportColorBuffer(resourceId);
+        } else {
+            stream_renderer_error("failed to create blob resource: unhandled type.");
+            return std::nullopt;
+        }
+
+        resource = std::move(*resourceOpt);
+    } else {
+        resource.mResourceType = VirtioGpuResourceType::BLOB;
+    }
+
+    resource.mId = resourceId;
+    resource.mCreateBlobArgs = *createBlobArgs;
+
+    if (createBlobArgs->blob_id == 0) {
+        RingBlobMemory memory;
+        if (features.ExternalBlob.enabled) {
+            memory = RingBlob::CreateWithShmem(resourceId, createBlobArgs->size);
+        } else {
+            memory = RingBlob::CreateWithHostMemory(resourceId, createBlobArgs->size, pageSize);
+        }
+        if (!memory) {
+            stream_renderer_error("Failed to create blob: failed to create ring blob.");
+            return std::nullopt;
+        }
+        resource.mBlobMemory.emplace(std::move(memory));
+    } else if (features.ExternalBlob.enabled) {
+        if (createBlobArgs->blob_mem == STREAM_BLOB_MEM_GUEST &&
+            (createBlobArgs->blob_flags & STREAM_BLOB_FLAG_CREATE_GUEST_HANDLE)) {
+#if defined(__linux__) || defined(__QNX__)
+            ManagedDescriptor managedHandle(handle->os_handle);
+            ExternalObjectManager::get()->addBlobDescriptorInfo(
+                contextId, createBlobArgs->blob_id, std::move(managedHandle), handle->handle_type,
+                0, std::nullopt);
+#else
+            stream_renderer_error("Failed to create blob: unimplemented external blob.");
+            return std::nullopt;
+#endif
+        } else {
+            if (!descriptorInfoOpt) {
+                descriptorInfoOpt = ExternalObjectManager::get()->removeBlobDescriptorInfo(
+                    contextId, createBlobArgs->blob_id);
+            }
+            if (!descriptorInfoOpt) {
+                stream_renderer_error("Failed to create blob: no external blob descriptor.");
+                return std::nullopt;
+            }
+            resource.mBlobMemory.emplace(
+                std::make_shared<BlobDescriptorInfo>(std::move(*descriptorInfoOpt)));
+        }
+    } else {
+        auto memoryMappingOpt =
+            ExternalObjectManager::get()->removeMapping(contextId, createBlobArgs->blob_id);
+        if (!memoryMappingOpt) {
+            stream_renderer_error("Failed to create blob: no external blob mapping.");
+            return std::nullopt;
+        }
+        resource.mBlobMemory.emplace(std::move(*memoryMappingOpt));
+    }
+
+    return resource;
+}
+
+int VirtioGpuResource::Destroy() {
+    if (mResourceType == VirtioGpuResourceType::BUFFER) {
+        FrameBuffer::getFB()->closeBuffer(mId);
+    } else if (mResourceType == VirtioGpuResourceType::COLOR_BUFFER) {
+        FrameBuffer::getFB()->closeColorBuffer(mId);
+    }
+    return 0;
+}
+
+void VirtioGpuResource::AttachIov(struct iovec* iov, uint32_t num_iovs) {
+    mIovs.clear();
+    mLinear.clear();
+
+    size_t linearSize = 0;
+    if (num_iovs) {
+        mIovs.reserve(num_iovs);
+        for (int i = 0; i < num_iovs; ++i) {
+            mIovs.push_back(iov[i]);
+            linearSize += iov[i].iov_len;
+        }
+    }
+
+    if (linearSize > 0) {
+        mLinear.resize(linearSize, 0);
+    }
+}
+
+void VirtioGpuResource::AttachToContext(VirtioGpuContextId contextId) {
+    mAttachedToContexts.insert(contextId);
+    mLatestAttachedContext = contextId;
+}
+
+void VirtioGpuResource::DetachFromContext(VirtioGpuContextId contextId) {
+    mAttachedToContexts.erase(contextId);
+    mLatestAttachedContext.reset();
+    mHostPipe = nullptr;
+}
+
+std::unordered_set<VirtioGpuContextId> VirtioGpuResource::GetAttachedContexts() const {
+    return mAttachedToContexts;
+}
+
+void VirtioGpuResource::DetachIov() {
+    mIovs.clear();
+    mLinear.clear();
+}
+
+int VirtioGpuResource::Map(void** outAddress, uint64_t* outSize) {
+    if (!mBlobMemory) {
+        stream_renderer_error("Failed to map resource %d: no blob memory to map.", mId);
+        return -EINVAL;
+    }
+
+    void* hva = nullptr;
+    uint64_t hvaSize = 0;
+
+    if (std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+        auto& memory = std::get<RingBlobMemory>(*mBlobMemory);
+        hva = memory->map();
+        hvaSize = memory->size();
+    } else if (std::holds_alternative<ExternalMemoryMapping>(*mBlobMemory)) {
+        if (!mCreateBlobArgs) {
+            stream_renderer_error("failed to map resource %d: missing args.", mId);
+            return -EINVAL;
+        }
+        auto& memory = std::get<ExternalMemoryMapping>(*mBlobMemory);
+        hva = memory.addr;
+        hvaSize = mCreateBlobArgs->size;
+    } else {
+        stream_renderer_error("failed to map resource %d: no mappable memory.", mId);
+        return -EINVAL;
+    }
+
+    if (outAddress) {
+        *outAddress = hva;
+    }
+    if (outSize) {
+        *outSize = hvaSize;
+    }
+    return 0;
+}
+
+int VirtioGpuResource::GetInfo(struct stream_renderer_resource_info* outInfo) const {
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to get info: resource %d missing args.", mId);
+        return ENOENT;
+    }
+
+    uint32_t bpp = 4U;
+    switch (mCreateArgs->format) {
+        case VIRGL_FORMAT_B8G8R8A8_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_ARGB8888;
+            break;
+        case VIRGL_FORMAT_B8G8R8X8_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_XRGB8888;
+            break;
+        case VIRGL_FORMAT_B5G6R5_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_RGB565;
+            bpp = 2U;
+            break;
+        case VIRGL_FORMAT_R8G8B8A8_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_ABGR8888;
+            break;
+        case VIRGL_FORMAT_R8G8B8X8_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_XBGR8888;
+            break;
+        case VIRGL_FORMAT_R8_UNORM:
+            outInfo->drm_fourcc = DRM_FORMAT_R8;
+            bpp = 1U;
+            break;
+        default:
+            return EINVAL;
+    }
+
+    outInfo->stride = AlignUp(mCreateArgs->width * bpp, 16U);
+    outInfo->virgl_format = mCreateArgs->format;
+    outInfo->handle = mCreateArgs->handle;
+    outInfo->height = mCreateArgs->height;
+    outInfo->width = mCreateArgs->width;
+    outInfo->depth = mCreateArgs->depth;
+    outInfo->flags = mCreateArgs->flags;
+    outInfo->tex_id = 0;
+    return 0;
+}
+
+int VirtioGpuResource::GetVulkanInfo(struct stream_renderer_vulkan_info* outInfo) const {
+    if (!mBlobMemory) {
+        return -EINVAL;
+    }
+    if (!std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+        return -EINVAL;
+    }
+    auto& memory = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
+    if (!memory->vulkanInfoOpt) {
+        return -EINVAL;
+    }
+    auto& memoryVulkanInfo = *memory->vulkanInfoOpt;
+
+    outInfo->memory_index = memoryVulkanInfo.memoryIndex;
+    memcpy(outInfo->device_id.device_uuid, memoryVulkanInfo.deviceUUID,
+           sizeof(outInfo->device_id.device_uuid));
+    memcpy(outInfo->device_id.driver_uuid, memoryVulkanInfo.driverUUID,
+           sizeof(outInfo->device_id.driver_uuid));
+    return 0;
+}
+
+int VirtioGpuResource::GetCaching(uint32_t* outCaching) const {
+    if (!mBlobMemory) {
+        stream_renderer_error("failed to get caching for resource %d: no blob memory", mId);
+        return -EINVAL;
+    }
+
+    if (std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+        *outCaching = STREAM_RENDERER_MAP_CACHE_CACHED;
+        return 0;
+    } else if (std::holds_alternative<ExternalMemoryMapping>(*mBlobMemory)) {
+        auto& memory = std::get<ExternalMemoryMapping>(*mBlobMemory);
+        *outCaching = memory.caching;
+        return 0;
+    } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+        auto& descriptor = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
+        *outCaching = descriptor->caching;
+        return 0;
+    }
+
+    stream_renderer_error("failed to get caching for resource %d: unhandled type?", mId);
+    return -EINVAL;
+}
+
+int VirtioGpuResource::WaitSyncResource() {
+    if (mResourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+        stream_renderer_error("waitSyncResource is undefined for non-ColorBuffer resource.");
+        return -EINVAL;
+    }
+
+    return FrameBuffer::getFB()->waitSyncColorBuffer(mId);
+}
+
+// Corresponds to Virtio GPU "TransferFromHost" commands and VMM requests to
+// copy into display buffers.
+int VirtioGpuResource::TransferRead(const GoldfishPipeServiceOps* ops, uint64_t offset,
+                                    stream_renderer_box* box,
+                                    std::optional<std::vector<struct iovec>> iovs) {
+    // First, copy from the underlying backend resource to this resource's linear buffer:
+    int ret = 0;
+    if (mResourceType == VirtioGpuResourceType::BLOB) {
+        stream_renderer_error("Failed to transfer: unexpected blob.");
+        return -EINVAL;
+    } else if (mResourceType == VirtioGpuResourceType::PIPE) {
+        ret = ReadFromPipeToLinear(ops, offset, box);
+    } else if (mResourceType == VirtioGpuResourceType::BUFFER) {
+        ret = ReadFromBufferToLinear(offset, box);
+    } else if (mResourceType == VirtioGpuResourceType::COLOR_BUFFER) {
+        ret = ReadFromColorBufferToLinear(offset, box);
+    } else {
+        stream_renderer_error("Failed to transfer: unhandled resource type.");
+        return -EINVAL;
+    }
+    if (ret != 0) {
+        stream_renderer_error("Failed to transfer: failed to sync with backend resource.");
+        return ret;
+    }
+
+    // Second, copy from this resource's linear buffer to the desired iov:
+    if (iovs) {
+        ret = TransferToIov(offset, box, *iovs);
+    } else {
+        ret = TransferToIov(offset, box, mIovs);
+    }
+    if (ret != 0) {
+        stream_renderer_error("Failed to transfer: failed to copy to iov.");
+    }
+    return ret;
+}
+
+// Corresponds to Virtio GPU "TransferToHost" commands.
+VirtioGpuResource::TransferWriteResult VirtioGpuResource::TransferWrite(
+    const GoldfishPipeServiceOps* ops, uint64_t offset, stream_renderer_box* box,
+    std::optional<std::vector<struct iovec>> iovs) {
+    // First, copy from the desired iov to this resource's linear buffer:
+    int ret = 0;
+    if (iovs) {
+        ret = TransferFromIov(offset, box, *iovs);
+    } else {
+        ret = TransferFromIov(offset, box, mIovs);
+    }
+    if (ret != 0) {
+        stream_renderer_error("Failed to transfer: failed to copy from iov.");
+        return TransferWriteResult{
+            .status = ret,
+        };
+    }
+
+    // Second, copy from this resource's linear buffer to the underlying backend resource:
+    if (mResourceType == VirtioGpuResourceType::BLOB) {
+        stream_renderer_error("Failed to transfer: unexpected blob.");
+        return TransferWriteResult{
+            .status = -EINVAL,
+        };
+    } else if (mResourceType == VirtioGpuResourceType::PIPE) {
+        return WriteToPipeFromLinear(ops, offset, box);
+    } else if (mResourceType == VirtioGpuResourceType::BUFFER) {
+        ret = WriteToBufferFromLinear(offset, box);
+    } else if (mResourceType == VirtioGpuResourceType::COLOR_BUFFER) {
+        ret = WriteToColorBufferFromLinear(offset, box);
+    } else {
+        stream_renderer_error("Failed to transfer: unhandled resource type.");
+        return TransferWriteResult{
+            .status = -EINVAL,
+        };
+    }
+    if (ret != 0) {
+        stream_renderer_error("Failed to transfer: failed to sync with backend resource.");
+    }
+    return TransferWriteResult{
+        .status = ret,
+    };
+}
+
+int VirtioGpuResource::ReadFromPipeToLinear(const GoldfishPipeServiceOps* ops, uint64_t offset,
+                                            stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::PIPE) {
+        stream_renderer_error("Failed to transfer: resource %d is not PIPE.", mId);
+        return -EINVAL;
+    }
+
+    // Do the pipe service op here, if there is an associated hostpipe.
+    auto hostPipe = mHostPipe;
+    if (!hostPipe) {
+        stream_renderer_error("Failed to transfer: resource %d missing PIPE.", mId);
+        return -EINVAL;
+    }
+
+    size_t readBytes = 0;
+    size_t wantedBytes = readBytes + (size_t)box->w;
+
+    while (readBytes < wantedBytes) {
+        GoldfishPipeBuffer buf = {
+            ((char*)mLinear.data()) + box->x + readBytes,
+            wantedBytes - readBytes,
+        };
+        auto status = ops->guest_recv(hostPipe, &buf, 1);
+
+        if (status > 0) {
+            readBytes += status;
+        } else if (status == kPipeTryAgain) {
+            ops->wait_guest_recv(hostPipe);
+        } else {
+            return EIO;
+        }
+    }
+
+    return 0;
+}
+
+VirtioGpuResource::TransferWriteResult VirtioGpuResource::WriteToPipeFromLinear(
+    const GoldfishPipeServiceOps* ops, uint64_t offset, stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::PIPE) {
+        stream_renderer_error("Failed to transfer: resource %d is not PIPE.", mId);
+        return TransferWriteResult{
+            .status = -EINVAL,
+        };
+    }
+
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to transfer: resource %d missing args.", mId);
+        return TransferWriteResult{
+            .status = -EINVAL,
+        };
+    }
+
+    // Do the pipe service op here, if there is an associated hostpipe.
+    auto hostPipe = mHostPipe;
+    if (!hostPipe) {
+        stream_renderer_error("No hostPipe");
+        return TransferWriteResult{
+            .status = -EINVAL,
+        };
+    }
+
+    stream_renderer_debug("resid: %d offset: 0x%llx hostpipe: %p", mCreateArgs->handle,
+                          (unsigned long long)offset, hostPipe);
+
+    size_t writtenBytes = 0;
+    size_t wantedBytes = (size_t)box->w;
+
+    GoldfishHostPipe* updatedHostPipe = nullptr;
+
+    while (writtenBytes < wantedBytes) {
+        GoldfishPipeBuffer buf = {
+            ((char*)mLinear.data()) + box->x + writtenBytes,
+            wantedBytes - writtenBytes,
+        };
+
+        // guest_send can now reallocate the pipe.
+        void* hostPipeBefore = hostPipe;
+        auto status = ops->guest_send(&hostPipe, &buf, 1);
+
+        if (hostPipe != hostPipeBefore) {
+            updatedHostPipe = hostPipe;
+        }
+
+        if (status > 0) {
+            writtenBytes += status;
+        } else if (status == kPipeTryAgain) {
+            ops->wait_guest_send(hostPipe);
+        } else {
+            return TransferWriteResult{
+                .status = EIO,
+            };
+        }
+    }
+
+    TransferWriteResult result = {
+        .status = 0,
+    };
+    if (updatedHostPipe != nullptr) {
+        result.contextId = mLatestAttachedContext.value_or(-1);
+        result.contextPipe = updatedHostPipe;
+    }
+    return result;
+}
+
+int VirtioGpuResource::ReadFromBufferToLinear(uint64_t offset, stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::BUFFER) {
+        stream_renderer_error("Failed to transfer: resource %d is not BUFFER.", mId);
+        return -EINVAL;
+    }
+
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to transfer: resource %d missing args.", mId);
+        return -EINVAL;
+    }
+
+    FrameBuffer::getFB()->readBuffer(mCreateArgs->handle, 0,
+                                     mCreateArgs->width * mCreateArgs->height, mLinear.data());
+    return 0;
+}
+
+int VirtioGpuResource::WriteToBufferFromLinear(uint64_t offset, stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::BUFFER) {
+        stream_renderer_error("Failed to transfer: resource %d is not BUFFER.", mId);
+        return -EINVAL;
+    }
+
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to transfer: resource %d missing args.", mId);
+        return -EINVAL;
+    }
+
+    FrameBuffer::getFB()->updateBuffer(mCreateArgs->handle, 0,
+                                       mCreateArgs->width * mCreateArgs->height, mLinear.data());
+    return 0;
+}
+
+int VirtioGpuResource::ReadFromColorBufferToLinear(uint64_t offset, stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+        stream_renderer_error("Failed to transfer: resource %d is not COLOR_BUFFER.", mId);
+        return -EINVAL;
+    }
+
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to transfer: resource %d missing args.", mId);
+        return -EINVAL;
+    }
+
+    auto glformat = virgl_format_to_gl(mCreateArgs->format);
+    auto gltype = gl_format_to_natural_type(glformat);
+
+    // We always xfer the whole thing again from GL
+    // since it's fiddly to calc / copy-out subregions
+    if (virgl_format_is_yuv(mCreateArgs->format)) {
+        FrameBuffer::getFB()->readColorBufferYUV(mCreateArgs->handle, 0, 0, mCreateArgs->width,
+                                                 mCreateArgs->height, mLinear.data(),
+                                                 mLinear.size());
+    } else {
+        FrameBuffer::getFB()->readColorBuffer(mCreateArgs->handle, 0, 0, mCreateArgs->width,
+                                              mCreateArgs->height, glformat, gltype,
+                                              mLinear.data());
+    }
+
+    return 0;
+}
+
+int VirtioGpuResource::WriteToColorBufferFromLinear(uint64_t offset, stream_renderer_box* box) {
+    if (mResourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+        stream_renderer_error("Failed to transfer: resource %d is not COLOR_BUFFER.", mId);
+        return -EINVAL;
+    }
+
+    if (!mCreateArgs) {
+        stream_renderer_error("Failed to transfer: resource %d missing args.", mId);
+        return -EINVAL;
+    }
+
+    auto glformat = virgl_format_to_gl(mCreateArgs->format);
+    auto gltype = gl_format_to_natural_type(glformat);
+
+    // We always xfer the whole thing again to GL
+    // since it's fiddly to calc / copy-out subregions
+    FrameBuffer::getFB()->updateColorBuffer(mCreateArgs->handle, 0, 0, mCreateArgs->width,
+                                            mCreateArgs->height, glformat, gltype, mLinear.data());
+    return 0;
+}
+
+int VirtioGpuResource::TransferToIov(uint64_t offset, const stream_renderer_box* box,
+                                     std::optional<std::vector<struct iovec>> iovs) {
+    if (iovs) {
+        return TransferWithIov(offset, box, *iovs, TransferDirection::LINEAR_TO_IOV);
+    } else {
+        return TransferWithIov(offset, box, mIovs, TransferDirection::LINEAR_TO_IOV);
+    }
+}
+
+int VirtioGpuResource::TransferFromIov(uint64_t offset, const stream_renderer_box* box,
+                                       std::optional<std::vector<struct iovec>> iovs) {
+    if (iovs) {
+        return TransferWithIov(offset, box, *iovs, TransferDirection::IOV_TO_LINEAR);
+    } else {
+        return TransferWithIov(offset, box, mIovs, TransferDirection::IOV_TO_LINEAR);
+    }
+}
+
+int VirtioGpuResource::TransferWithIov(uint64_t offset, const stream_renderer_box* box,
+                                       const std::vector<struct iovec>& iovs,
+                                       TransferDirection direction) {
+    if (!mCreateArgs) {
+        stream_renderer_error("failed to transfer: missing resource args.");
+        return -EINVAL;
+    }
+    if (box->x > mCreateArgs->width || box->y > mCreateArgs->height) {
+        stream_renderer_error("failed to transfer: box out of range of resource");
+        return -EINVAL;
+    }
+    if (box->w == 0U || box->h == 0U) {
+        stream_renderer_error("failed to transfer: empty transfer");
+        return -EINVAL;
+    }
+    if (box->x + box->w > mCreateArgs->width) {
+        stream_renderer_error("failed to transfer: box overflows resource width");
+        return -EINVAL;
+    }
+
+    size_t linearBase =
+        virgl_format_to_linear_base(mCreateArgs->format, mCreateArgs->width, mCreateArgs->height,
+                                    box->x, box->y, box->w, box->h);
+    size_t start = linearBase;
+    // height - 1 in order to treat the (w * bpp) row specially
+    // (i.e., the last row does not occupy the full stride)
+    size_t length =
+        virgl_format_to_total_xfer_len(mCreateArgs->format, mCreateArgs->width, mCreateArgs->height,
+                                       box->x, box->y, box->w, box->h);
+    size_t end = start + length;
+
+    if (start == end) {
+        stream_renderer_error("failed to transfer: nothing to transfer");
+        return -EINVAL;
+    }
+
+    if (end > mLinear.size()) {
+        stream_renderer_error("failed to transfer: start + length overflows!");
+        return -EINVAL;
+    }
+
+    uint32_t iovIndex = 0;
+    size_t iovOffset = 0;
+    size_t written = 0;
+    char* linear = static_cast<char*>(mLinear.data());
+
+    while (written < length) {
+        if (iovIndex >= iovs.size()) {
+            stream_renderer_error("failed to transfer: write request overflowed iovs");
+            return -EINVAL;
+        }
+
+        const char* iovBase_const = static_cast<const char*>(iovs[iovIndex].iov_base);
+        char* iovBase = static_cast<char*>(iovs[iovIndex].iov_base);
+        size_t iovLen = iovs[iovIndex].iov_len;
+        size_t iovOffsetEnd = iovOffset + iovLen;
+
+        auto lower_intersect = std::max(iovOffset, start);
+        auto upper_intersect = std::min(iovOffsetEnd, end);
+        if (lower_intersect < upper_intersect) {
+            size_t toWrite = upper_intersect - lower_intersect;
+            switch (direction) {
+                case TransferDirection::IOV_TO_LINEAR:
+                    memcpy(linear + lower_intersect, iovBase_const + lower_intersect - iovOffset,
+                           toWrite);
+                    break;
+                case TransferDirection::LINEAR_TO_IOV:
+                    memcpy(iovBase + lower_intersect - iovOffset, linear + lower_intersect,
+                           toWrite);
+                    break;
+                default:
+                    stream_renderer_error("failed to transfer: invalid synchronization dir");
+                    return -EINVAL;
+            }
+            written += toWrite;
+        }
+        ++iovIndex;
+        iovOffset += iovLen;
+    }
+
+    return 0;
+}
+
+int VirtioGpuResource::ExportBlob(struct stream_renderer_handle* outHandle) {
+    if (!mBlobMemory) {
+        return -EINVAL;
+    }
+
+    if (std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+        auto& memory = std::get<RingBlobMemory>(*mBlobMemory);
+        if (!memory->isExportable()) {
+            return -EINVAL;
+        }
+
+        // Handle ownership transferred to VMM, Gfxstream keeps the mapping.
+#ifdef _WIN32
+        outHandle->os_handle =
+            static_cast<int64_t>(reinterpret_cast<intptr_t>(memory->releaseHandle()));
+#else
+        outHandle->os_handle = static_cast<int64_t>(memory->releaseHandle());
+#endif
+        outHandle->handle_type = STREAM_MEM_HANDLE_TYPE_SHM;
+        return 0;
+    } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+        auto& memory = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
+
+        auto rawDescriptorOpt = memory->descriptor.release();
+        if (!rawDescriptorOpt) {
+            stream_renderer_error(
+                "failed to export blob for resource %u: failed to get raw handle.", mId);
+            return -EINVAL;
+        }
+        auto rawDescriptor = *rawDescriptorOpt;
+
+#ifdef _WIN32
+        outHandle->os_handle = static_cast<int64_t>(reinterpret_cast<intptr_t>(rawDescriptor));
+#else
+        outHandle->os_handle = static_cast<int64_t>(rawDescriptor);
+#endif
+        outHandle->handle_type = memory->handleType;
+        return 0;
+    }
+
+    return -EINVAL;
+}
+
+std::shared_ptr<RingBlob> VirtioGpuResource::ShareRingBlob() {
+    if (!mBlobMemory) {
+        return nullptr;
+    }
+    if (!std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+        return nullptr;
+    }
+    return std::get<RingBlobMemory>(*mBlobMemory);
+}
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+std::optional<VirtioGpuResourceSnapshot> VirtioGpuResource::Snapshot() const {
+    VirtioGpuResourceSnapshot resourceSnapshot;
+    resourceSnapshot.set_id(mId);
+    resourceSnapshot.set_type(static_cast<::gfxstream::host::snapshot::VirtioGpuResourceType>(mResourceType));
+
+    if (mCreateArgs) {
+        VirtioGpuResourceCreateArgs* snapshotCreateArgs = resourceSnapshot.mutable_create_args();
+        snapshotCreateArgs->set_id(mCreateArgs->handle);
+        snapshotCreateArgs->set_target(mCreateArgs->target);
+        snapshotCreateArgs->set_format(mCreateArgs->format);
+        snapshotCreateArgs->set_bind(mCreateArgs->bind);
+        snapshotCreateArgs->set_width(mCreateArgs->width);
+        snapshotCreateArgs->set_height(mCreateArgs->height);
+        snapshotCreateArgs->set_depth(mCreateArgs->depth);
+        snapshotCreateArgs->set_array_size(mCreateArgs->array_size);
+        snapshotCreateArgs->set_last_level(mCreateArgs->last_level);
+        snapshotCreateArgs->set_nr_samples(mCreateArgs->nr_samples);
+        snapshotCreateArgs->set_flags(mCreateArgs->flags);
+    }
+
+    if (mCreateBlobArgs) {
+        auto* snapshotCreateArgs = resourceSnapshot.mutable_create_blob_args();
+        snapshotCreateArgs->set_mem(mCreateBlobArgs->blob_mem);
+        snapshotCreateArgs->set_flags(mCreateBlobArgs->blob_flags);
+        snapshotCreateArgs->set_id(mCreateBlobArgs->blob_id);
+        snapshotCreateArgs->set_size(mCreateBlobArgs->size);
+    }
+
+    if (mBlobMemory) {
+        if (std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+            auto& memory = std::get<RingBlobMemory>(*mBlobMemory);
+
+            auto snapshotRingBlobOpt = memory->Snapshot();
+            if (!snapshotRingBlobOpt) {
+                stream_renderer_error("Failed to snapshot ring blob for resource %d.", mId);
+                return std::nullopt;
+            }
+            resourceSnapshot.mutable_ring_blob()->Swap(&*snapshotRingBlobOpt);
+        } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+            if (!mLatestAttachedContext) {
+                stream_renderer_error("Failed to snapshot resource %d: missing blob context?", mId);
+                return std::nullopt;
+            }
+            if (!mCreateBlobArgs) {
+                stream_renderer_error("Failed to snapshot resource %d: missing blob args?", mId);
+                return std::nullopt;
+            }
+            auto snapshotDescriptorInfo = resourceSnapshot.mutable_external_memory_descriptor();
+            snapshotDescriptorInfo->set_context_id(*mLatestAttachedContext);
+            snapshotDescriptorInfo->set_blob_id(mCreateBlobArgs->blob_id);
+        } else if (std::holds_alternative<ExternalMemoryMapping>(*mBlobMemory)) {
+            if (!mLatestAttachedContext) {
+                stream_renderer_error("Failed to snapshot resource %d: missing blob context?", mId);
+                return std::nullopt;
+            }
+            if (!mCreateBlobArgs) {
+                stream_renderer_error("Failed to snapshot resource %d: missing blob args?", mId);
+                return std::nullopt;
+            }
+            auto snapshotDescriptorInfo = resourceSnapshot.mutable_external_memory_mapping();
+            snapshotDescriptorInfo->set_context_id(*mLatestAttachedContext);
+            snapshotDescriptorInfo->set_blob_id(mCreateBlobArgs->blob_id);
+        }
+    }
+
+    if (mLatestAttachedContext) {
+        resourceSnapshot.set_latest_attached_context(*mLatestAttachedContext);
+    }
+
+    resourceSnapshot.mutable_attached_contexts()->Add(mAttachedToContexts.begin(),
+                                                      mAttachedToContexts.end());
+
+    return resourceSnapshot;
+}
+
+/*static*/ std::optional<VirtioGpuResource> VirtioGpuResource::Restore(
+    const VirtioGpuResourceSnapshot& resourceSnapshot) {
+    VirtioGpuResource resource = {};
+    resource.mId = resourceSnapshot.id();
+    resource.mResourceType = static_cast<VirtioGpuResourceType>(resourceSnapshot.type());
+
+    if (resourceSnapshot.has_create_args()) {
+        const auto& createArgsSnapshot = resourceSnapshot.create_args();
+        resource.mCreateArgs = {
+            .handle = createArgsSnapshot.id(),
+            .target = createArgsSnapshot.target(),
+            .format = createArgsSnapshot.format(),
+            .bind = createArgsSnapshot.bind(),
+            .width = createArgsSnapshot.width(),
+            .height = createArgsSnapshot.height(),
+            .depth = createArgsSnapshot.depth(),
+            .array_size = createArgsSnapshot.array_size(),
+            .last_level = createArgsSnapshot.last_level(),
+            .nr_samples = createArgsSnapshot.nr_samples(),
+            .flags = createArgsSnapshot.flags(),
+        };
+    }
+
+    if (resourceSnapshot.has_create_blob_args()) {
+        const auto& createArgsSnapshot = resourceSnapshot.create_blob_args();
+        resource.mCreateBlobArgs = {
+            .blob_mem = createArgsSnapshot.mem(),
+            .blob_flags = createArgsSnapshot.flags(),
+            .blob_id = createArgsSnapshot.id(),
+            .size = createArgsSnapshot.size(),
+        };
+    }
+
+    if (resourceSnapshot.has_ring_blob()) {
+        auto resourceRingBlobOpt = RingBlob::Restore(resourceSnapshot.ring_blob());
+        if (!resourceRingBlobOpt) {
+            stream_renderer_error("Failed to restore ring blob for resource %d", resource.mId);
+            return std::nullopt;
+        }
+        resource.mBlobMemory.emplace(std::move(*resourceRingBlobOpt));
+    } else if (resourceSnapshot.has_external_memory_descriptor()) {
+        const auto& snapshotDescriptorInfo = resourceSnapshot.external_memory_descriptor();
+
+        auto descriptorInfoOpt = ExternalObjectManager::get()->removeBlobDescriptorInfo(
+            snapshotDescriptorInfo.context_id(), snapshotDescriptorInfo.blob_id());
+        if (!descriptorInfoOpt) {
+            stream_renderer_error(
+                "Failed to restore resource: failed to find blob descriptor info.");
+            return std::nullopt;
+        }
+
+        resource.mBlobMemory.emplace(
+            std::make_shared<BlobDescriptorInfo>(std::move(*descriptorInfoOpt)));
+    } else if (resourceSnapshot.has_external_memory_mapping()) {
+        const auto& snapshotDescriptorInfo = resourceSnapshot.external_memory_mapping();
+
+        auto memoryMappingOpt = ExternalObjectManager::get()->removeMapping(
+            snapshotDescriptorInfo.context_id(), snapshotDescriptorInfo.blob_id());
+        if (!memoryMappingOpt) {
+            stream_renderer_error("Failed to restore resource: failed to find mapping info.");
+            return std::nullopt;
+        }
+        resource.mBlobMemory.emplace(std::move(*memoryMappingOpt));
+    }
+
+    if (resourceSnapshot.has_latest_attached_context()) {
+        resource.mLatestAttachedContext = resourceSnapshot.latest_attached_context();
+    }
+
+    resource.mAttachedToContexts.insert(resourceSnapshot.attached_contexts().begin(),
+                                        resourceSnapshot.attached_contexts().end());
+
+    return resource;
+}
+
+#endif  // #ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuResource.h b/host/VirtioGpuResource.h
new file mode 100644
index 000000000..93002c2aa
--- /dev/null
+++ b/host/VirtioGpuResource.h
@@ -0,0 +1,183 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <stdint.h>
+
+#include <memory>
+#include <optional>
+#include <unordered_set>
+
+extern "C" {
+#include "host-common/goldfish_pipe.h"
+}  // extern "C"
+
+#include "ExternalObjectManager.h"
+#include "VirtioGpu.h"
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "VirtioGpuResourceSnapshot.pb.h"
+#endif  // GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "VirtioGpuRingBlob.h"
+#include "gfxstream/host/Features.h"
+#include "gfxstream/virtio-gpu-gfxstream-renderer-unstable.h"
+#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
+
+namespace gfxstream {
+namespace host {
+
+// LINT.IfChange(virtio_gpu_resource_type)
+enum class VirtioGpuResourceType {
+    UNKNOWN = 0,
+    // Used as a communication channel between the guest and the host
+    // which does not need an allocation on the host GPU.
+    PIPE = 1,
+    // Used as a GPU data buffer.
+    BUFFER = 2,
+    // Used as a GPU texture.
+    COLOR_BUFFER = 3,
+    // Used as a blob and not known to FrameBuffer.
+    BLOB = 4,
+};
+// LINT.ThenChange(VirtioGpuResourceSnapshot.proto:virtio_gpu_resource_type)
+
+class VirtioGpuResource {
+   public:
+    VirtioGpuResource() {}
+
+    static std::optional<VirtioGpuResource> Create(
+        const struct stream_renderer_resource_create_args* args, struct iovec* iov,
+        uint32_t num_iovs);
+
+    static std::optional<VirtioGpuResource> Create(
+        const gfxstream::host::FeatureSet& features, uint32_t pageSize, uint32_t contextId,
+        uint32_t resourceId, const struct stream_renderer_resource_create_args* createArgs,
+        const struct stream_renderer_create_blob* createBlobArgs,
+        const struct stream_renderer_handle* handle);
+
+    int Destroy();
+
+    VirtioGpuResourceId GetId() const { return mId; }
+
+    void AttachIov(struct iovec* iov, uint32_t num_iovs);
+    void DetachIov();
+
+    void AttachToContext(VirtioGpuContextId contextId);
+    void DetachFromContext(VirtioGpuContextId contextId);
+    std::unordered_set<VirtioGpuContextId> GetAttachedContexts() const;
+
+    int Map(void** outAddress, uint64_t* outSize);
+
+    int GetInfo(struct stream_renderer_resource_info* outInfo) const;
+
+    int GetVulkanInfo(struct stream_renderer_vulkan_info* outInfo) const;
+
+    int GetCaching(uint32_t* outHvaCaching) const;
+
+    void SetHostPipe(GoldfishHostPipe* pipe) { mHostPipe = pipe; }
+
+    int WaitSyncResource();
+
+    // Corresponds to Virtio GPU "TransferFromHost" commands and VMM requests to
+    // copy into display buffers.
+    int TransferRead(const GoldfishPipeServiceOps* ops, uint64_t offset, stream_renderer_box* box,
+                     std::optional<std::vector<struct iovec>> iovs = std::nullopt);
+
+    struct TransferWriteResult {
+        int status = 0;
+
+        // If, while processing the first guest to host transfer for a PIPE resource
+        // which contains the pipe service name, the returned pipe service to replace
+        // the generic pipe.
+        VirtioGpuContextId contextId = -1;
+        GoldfishHostPipe* contextPipe = nullptr;
+    };
+    // Corresponds to Virtio GPU "TransferToHost" commands.
+    TransferWriteResult TransferWrite(const GoldfishPipeServiceOps* ops, uint64_t offset,
+                                      stream_renderer_box* box,
+                                      std::optional<std::vector<struct iovec>> iovs = std::nullopt);
+
+    int ExportBlob(struct stream_renderer_handle* outHandle);
+
+    std::shared_ptr<RingBlob> ShareRingBlob();
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    std::optional<gfxstream::host::snapshot::VirtioGpuResourceSnapshot> Snapshot() const;
+
+    static std::optional<VirtioGpuResource> Restore(
+        const gfxstream::host::snapshot::VirtioGpuResourceSnapshot& snapshot);
+#endif
+
+   private:
+    int ReadFromPipeToLinear(const GoldfishPipeServiceOps* ops, uint64_t offset,
+                             stream_renderer_box* box);
+    TransferWriteResult WriteToPipeFromLinear(const GoldfishPipeServiceOps* ops, uint64_t offset,
+                                              stream_renderer_box* box);
+
+    int ReadFromBufferToLinear(uint64_t offset, stream_renderer_box* box);
+    int WriteToBufferFromLinear(uint64_t offset, stream_renderer_box* box);
+
+    int ReadFromColorBufferToLinear(uint64_t offset, stream_renderer_box* box);
+    int WriteToColorBufferFromLinear(uint64_t offset, stream_renderer_box* box);
+
+    // If `iovs` provided, copy from this resource's linear buffer to the given `iovs`.
+    // Otherwise, copy from this resource's linear buffer into its previously attached
+    // iovs.
+    int TransferToIov(uint64_t offset, const stream_renderer_box* box,
+                      std::optional<std::vector<struct iovec>> iovs = std::nullopt);
+
+    // If `iovs` provided, copy from the given `iovs` to this resources linear buffer.
+    // Otherwise, copy from this resource's previously attached iovs into its linear
+    // buffer.
+    int TransferFromIov(uint64_t offset, const stream_renderer_box* box,
+                        std::optional<std::vector<struct iovec>> iovs = std::nullopt);
+
+    enum TransferDirection {
+        IOV_TO_LINEAR = 0,
+        LINEAR_TO_IOV = 1,
+    };
+    int TransferWithIov(uint64_t offset, const stream_renderer_box* box,
+                        const std::vector<struct iovec>& iovs, TransferDirection direction);
+
+    // LINT.IfChange(virtio_gpu_resource)
+    VirtioGpuResourceId mId = -1;
+    VirtioGpuResourceType mResourceType = VirtioGpuResourceType::UNKNOWN;
+    std::optional<struct stream_renderer_resource_create_args> mCreateArgs;
+    std::optional<struct stream_renderer_create_blob> mCreateBlobArgs;
+    std::vector<struct iovec> mIovs;
+    std::vector<char> mLinear;
+    GoldfishHostPipe* mHostPipe = nullptr;
+    std::optional<VirtioGpuContextId> mLatestAttachedContext;
+    std::unordered_set<VirtioGpuContextId> mAttachedToContexts;
+
+    // If this resource is a blob resource, the source of the external memory.
+    //
+    //   * For ring blobs, blobs that are used soley for guest and host
+    //     communication, the external memory is allocated by this resource
+    //     in the frontend.
+    //
+    //   * For non ring blobs, the memory from the backend as either an external
+    //     memory handle (`BlobDescriptorInfo`) or a raw mapping.
+    using RingBlobMemory = std::shared_ptr<RingBlob>;
+    using ExternalMemoryDescriptor = std::shared_ptr<BlobDescriptorInfo>;
+    using ExternalMemoryMapping = HostMemInfo;
+
+    using BlobMemory =
+        std::variant<RingBlobMemory, ExternalMemoryDescriptor, ExternalMemoryMapping>;
+    std::optional<BlobMemory> mBlobMemory;
+    // LINT.ThenChange(VirtioGpuResourceSnapshot.proto:virtio_gpu_resource)
+};
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuResourceSnapshot.proto b/host/VirtioGpuResourceSnapshot.proto
new file mode 100644
index 000000000..654a53cdb
--- /dev/null
+++ b/host/VirtioGpuResourceSnapshot.proto
@@ -0,0 +1,79 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+import "VirtioGpuRingBlobSnapshot.proto";
+
+package gfxstream.host.snapshot;
+
+// LINT.IfChange(virtio_gpu_resource_type)
+enum VirtioGpuResourceType {
+    UNKNOWN = 0;
+    PIPE = 1;
+    BUFFER = 2;
+    COLOR_BUFFER = 3;
+    BLOB = 4;
+}
+// LINT.ThenChange(VirtioGpuResource.h:virtio_gpu_resource_type)
+
+message VirtioGpuResourceCreateArgs {
+    optional uint32 id = 1;
+    optional uint32 target = 2;
+    optional uint32 format = 3;
+    optional uint32 bind = 4;
+    optional uint32 width = 5;
+    optional uint32 height = 6;
+    optional uint32 depth = 7;
+    optional uint32 array_size = 8;
+    optional uint32 last_level = 9;
+    optional uint32 nr_samples = 10;
+    optional uint32 flags = 11;
+}
+
+message VirtioGpuResourceCreateBlobArgs {
+    optional uint32 mem = 1;
+    optional uint32 flags = 2;
+    optional uint32 id = 3;
+    optional uint64 size = 4;
+}
+
+// NOTE: This does not actually save the blob's external memory because the handle
+// or mapping may not be the same across snapshot and restore. This instead saves
+// the info needed to refetch either the descriptor or mapping from
+// `ExternalObjectManager` after a restore.
+message VirtioGpuBlobExternalMemoryInfo {
+    optional uint32 context_id = 1;
+    optional uint32 blob_id = 2;
+}
+
+// LINT.IfChange(virtio_gpu_resource)
+message VirtioGpuResourceSnapshot {
+    optional uint32 id = 1;
+    optional VirtioGpuResourceType type = 2;
+    optional VirtioGpuResourceCreateArgs create_args = 3;
+    optional VirtioGpuResourceCreateBlobArgs create_blob_args = 4;
+    // NOTE: `VirtioGpuResource::iovs` is not saved because the host virtual address
+    // may not be the same across snapshot and restore. VMMs are expected to re-call
+    // `stream_renderer_resource_attach_iov()` for resources with the new guest-memory
+    // host virtual addresses.
+    oneof blob_memory {
+        VirtioGpuRingBlobSnapshot ring_blob = 5;
+        VirtioGpuBlobExternalMemoryInfo external_memory_descriptor = 6;
+        VirtioGpuBlobExternalMemoryInfo external_memory_mapping = 7;
+    }
+    optional uint32 latest_attached_context = 8;
+    repeated uint32 attached_contexts = 9;
+}
+// LINT.ThenChange(VirtioGpuResource.h:virtio_gpu_resource)
diff --git a/host/VirtioGpuRingBlob.cpp b/host/VirtioGpuRingBlob.cpp
new file mode 100644
index 000000000..dd9f6c6df
--- /dev/null
+++ b/host/VirtioGpuRingBlob.cpp
@@ -0,0 +1,129 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VirtioGpuRingBlob.h"
+
+#include <string>
+
+#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
+
+namespace gfxstream {
+namespace host {
+
+using android::base::SharedMemory;
+
+RingBlob::RingBlob(uint32_t id,
+                   uint64_t size,
+                   uint64_t alignment,
+                   std::variant<std::unique_ptr<AlignedMemory>, std::unique_ptr<SharedMemory>> memory) :
+    mId(id), mSize(size), mAlignment(alignment), mMemory(std::move(memory)) {}
+
+bool RingBlob::isExportable() const {
+    return std::holds_alternative<std::unique_ptr<SharedMemory>>(mMemory);
+}
+
+android::base::SharedMemory::handle_type RingBlob::releaseHandle() {
+    if (!isExportable()) {
+        return SharedMemory::invalidHandle();
+    }
+    return std::get<std::unique_ptr<SharedMemory>>(mMemory)->releaseHandle();
+}
+
+void* RingBlob::map() {
+    if (std::holds_alternative<std::unique_ptr<AlignedMemory>>(mMemory)) {
+        return std::get<std::unique_ptr<AlignedMemory>>(mMemory)->addr;
+    } else {
+        return std::get<std::unique_ptr<SharedMemory>>(mMemory)->get();
+    }
+}
+
+/*static*/
+std::unique_ptr<RingBlob> RingBlob::CreateWithShmem(uint32_t id, uint64_t size) {
+    const std::string name = "gfxstream-ringblob-shmem-" + std::to_string(id);
+
+    auto shmem = std::make_unique<SharedMemory>(name, size);
+    int ret = shmem->create(0600);
+    if (ret) {
+        stream_renderer_error("Failed to allocate ring blob shared memory.");
+        return nullptr;
+    }
+
+    return std::unique_ptr<RingBlob>(new RingBlob(id, size, 1, std::move(shmem)));
+}
+
+/*static*/
+std::unique_ptr<RingBlob> RingBlob::CreateWithHostMemory(uint32_t id, uint64_t size, uint64_t alignment) {
+    auto memory = std::make_unique<AlignedMemory>(alignment, size);
+    if (memory->addr == nullptr) {
+        stream_renderer_error("Failed to allocate ring blob host memory.");
+        return nullptr;
+    }
+
+    return std::unique_ptr<RingBlob>(new RingBlob(id, size, alignment, std::move(memory)));
+}
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+using gfxstream::host::snapshot::VirtioGpuRingBlobSnapshot;
+
+std::optional<VirtioGpuRingBlobSnapshot> RingBlob::Snapshot() {
+    VirtioGpuRingBlobSnapshot snapshot;
+
+    snapshot.set_id(mId);
+    snapshot.set_size(mSize);
+    snapshot.set_alignment(mAlignment);
+    if (std::holds_alternative<std::unique_ptr<SharedMemory>>(mMemory)) {
+        snapshot.set_type(VirtioGpuRingBlobSnapshot::TYPE_SHARED_MEMORY);
+    } else {
+        snapshot.set_type(VirtioGpuRingBlobSnapshot::TYPE_HOST_MEMORY);
+    }
+
+    void* mapped = map();
+    if (!mapped) {
+        stream_renderer_error("Failed to map ring blob memory for snapshot.");
+        return std::nullopt;
+    }
+    snapshot.set_memory(mapped, mSize);
+
+    return snapshot;
+}
+
+/*static*/ std::optional<std::unique_ptr<RingBlob>> RingBlob::Restore(
+        const VirtioGpuRingBlobSnapshot& snapshot) {
+
+    std::unique_ptr<RingBlob> resource;
+    if (snapshot.type() == VirtioGpuRingBlobSnapshot::TYPE_SHARED_MEMORY) {
+        resource = RingBlob::CreateWithShmem(snapshot.id(), snapshot.size());
+    } else {
+        resource = RingBlob::CreateWithHostMemory(snapshot.id(), snapshot.size(), snapshot.alignment());
+    }
+    if (!resource) {
+        return std::nullopt;
+    }
+
+    void* mapped = resource->map();
+    if (!mapped) {
+        stream_renderer_error("Failed to map ring blob memory for restore.");
+        return std::nullopt;
+    }
+
+    std::memcpy(mapped, snapshot.memory().c_str(), snapshot.memory().size());
+
+    return resource;
+}
+
+#endif
+
+}  // namespace host
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/VirtioGpuRingBlob.h b/host/VirtioGpuRingBlob.h
new file mode 100644
index 000000000..4debd74f4
--- /dev/null
+++ b/host/VirtioGpuRingBlob.h
@@ -0,0 +1,88 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <memory>
+#include <variant>
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "VirtioGpuResourceSnapshot.pb.h"
+#endif
+#include "aemu/base/AlignedBuf.h"
+#include "aemu/base/memory/SharedMemory.h"
+
+namespace gfxstream {
+namespace host {
+
+// LINT.IfChange(virtio_gpu_ring_blob)
+
+struct AlignedMemory {
+    void* addr = nullptr;
+
+    AlignedMemory(size_t align, size_t size) : addr(android::aligned_buf_alloc(align, size)) {}
+
+    ~AlignedMemory() {
+        if (addr != nullptr) {
+            android::aligned_buf_free(addr);
+        }
+    }
+
+    // AlignedMemory is neither copyable nor movable.
+    AlignedMemory(const AlignedMemory& other) = delete;
+    AlignedMemory& operator=(const AlignedMemory& other) = delete;
+    AlignedMemory(AlignedMemory&& other) = delete;
+    AlignedMemory& operator=(AlignedMemory&& other) = delete;
+};
+
+// Memory used as a ring buffer for communication between the guest and host.
+class RingBlob {
+   public:
+    static std::unique_ptr<RingBlob> CreateWithShmem(uint32_t id, uint64_t size);
+    static std::unique_ptr<RingBlob> CreateWithHostMemory(uint32_t, uint64_t size, uint64_t alignment);
+
+    bool isExportable() const;
+
+    // Only valid if `isExportable()` returns `true`.
+    android::base::SharedMemory::handle_type releaseHandle();
+
+    void* map();
+
+    uint64_t size() const { return mSize; }
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    std::optional<gfxstream::host::snapshot::VirtioGpuRingBlobSnapshot> Snapshot();
+
+    static std::optional<std::unique_ptr<RingBlob>> Restore(
+        const gfxstream::host::snapshot::VirtioGpuRingBlobSnapshot& snapshot);
+#endif
+
+  private:
+    RingBlob(uint32_t id,
+             uint64_t size,
+             uint64_t alignment,
+             std::variant<std::unique_ptr<AlignedMemory>,
+                          std::unique_ptr<android::base::SharedMemory>> memory);
+
+    const uint64_t mId;
+    const uint64_t mSize;
+    const uint64_t mAlignment;
+    std::variant<std::unique_ptr<AlignedMemory>,
+                 std::unique_ptr<android::base::SharedMemory>> mMemory;
+};
+
+// LINT.ThenChange(VirtioGpuRingBlobSnapshot.h:virtio_gpu_ring_blob)
+
+}  // namespace host
+}  // namespace gfxstream
diff --git a/host/VirtioGpuRingBlobSnapshot.proto b/host/VirtioGpuRingBlobSnapshot.proto
new file mode 100644
index 000000000..78c91d4ff
--- /dev/null
+++ b/host/VirtioGpuRingBlobSnapshot.proto
@@ -0,0 +1,31 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package gfxstream.host.snapshot;
+
+// LINT.IfChange(virtio_gpu_ring_blob)
+message VirtioGpuRingBlobSnapshot {
+    uint32 id = 1;
+    uint64 size = 2;
+    uint64 alignment = 3;
+    enum Type {
+        TYPE_HOST_MEMORY = 0;
+        TYPE_SHARED_MEMORY = 1;
+    }
+    Type type = 4;
+    bytes memory = 5;
+}
+// LINT.ThenChange(VirtioGpuRingBlob.h:virtio_gpu_ring_blob)
diff --git a/host/VirtioGpuTimelines.cpp b/host/VirtioGpuTimelines.cpp
index 657edb569..12c74b430 100644
--- a/host/VirtioGpuTimelines.cpp
+++ b/host/VirtioGpuTimelines.cpp
@@ -22,19 +22,18 @@
 using TaskId = VirtioGpuTimelines::TaskId;
 using Ring = VirtioGpuTimelines::Ring;
 using FenceId = VirtioGpuTimelines::FenceId;
-using AutoLock = android::base::AutoLock;
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
-std::unique_ptr<VirtioGpuTimelines> VirtioGpuTimelines::create(bool withAsyncCallback) {
-    return std::unique_ptr<VirtioGpuTimelines>(new VirtioGpuTimelines(withAsyncCallback));
+std::unique_ptr<VirtioGpuTimelines> VirtioGpuTimelines::create(FenceCompletionCallback callback) {
+    return std::unique_ptr<VirtioGpuTimelines>(new VirtioGpuTimelines(std::move(callback)));
 }
 
-VirtioGpuTimelines::VirtioGpuTimelines(bool withAsyncCallback)
-    : mNextId(0), mWithAsyncCallback(withAsyncCallback) {}
+VirtioGpuTimelines::VirtioGpuTimelines(FenceCompletionCallback callback)
+    : mNextId(0), mFenceCompletionCallback(std::move(callback)) {}
 
 TaskId VirtioGpuTimelines::enqueueTask(const Ring& ring) {
-    AutoLock lock(mLock);
+    std::lock_guard<std::mutex> lock(mTimelinesMutex);
 
     TaskId id = mNextId++;
 
@@ -54,21 +53,17 @@ TaskId VirtioGpuTimelines::enqueueTask(const Ring& ring) {
     return id;
 }
 
-void VirtioGpuTimelines::enqueueFence(const Ring& ring, FenceId fenceId,
-                                      FenceCompletionCallback fenceCompletionCallback) {
-    AutoLock lock(mLock);
-
-    auto fence = std::make_unique<Fence>(fenceId, std::move(fenceCompletionCallback));
+void VirtioGpuTimelines::enqueueFence(const Ring& ring, FenceId fenceId) {
+    std::lock_guard<std::mutex> lock(mTimelinesMutex);
 
     Timeline& timeline = GetOrCreateTimelineLocked(ring);
-    timeline.mQueue.emplace_back(std::move(fence));
-    if (mWithAsyncCallback) {
-        poll_locked(ring);
-    }
+    timeline.mQueue.emplace_back(fenceId);
+
+    poll_locked(ring);
 }
 
 void VirtioGpuTimelines::notifyTaskCompletion(TaskId taskId) {
-    AutoLock lock(mLock);
+    std::lock_guard<std::mutex> lock(mTimelinesMutex);
     auto iTask = mTaskIdToTask.find(taskId);
     if (iTask == mTaskIdToTask.end()) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
@@ -94,9 +89,8 @@ void VirtioGpuTimelines::notifyTaskCompletion(TaskId taskId) {
                                   GFXSTREAM_TRACE_FLOW(task->mTraceId), "Task ID", task->mId);
 
     task->mHasCompleted = true;
-    if (mWithAsyncCallback) {
-        poll_locked(task->mRing);
-    }
+
+    poll_locked(task->mRing);
 }
 
 VirtioGpuTimelines::Timeline& VirtioGpuTimelines::GetOrCreateTimelineLocked(const Ring& ring) {
@@ -118,11 +112,7 @@ VirtioGpuTimelines::Timeline& VirtioGpuTimelines::GetOrCreateTimelineLocked(cons
 }
 
 void VirtioGpuTimelines::poll() {
-    if (mWithAsyncCallback) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-            << "Can't call poll with async callback enabled.";
-    }
-    AutoLock lock(mLock);
+    std::lock_guard<std::mutex> lock(mTimelinesMutex);
     for (const auto& [ring, timeline] : mTimelineQueues) {
         poll_locked(ring);
     }
@@ -141,14 +131,14 @@ void VirtioGpuTimelines::poll_locked(const Ring& ring) {
         bool shouldStop = std::visit(
             [&](auto& arg) {
                 using T = std::decay_t<decltype(arg)>;
-                if constexpr (std::is_same_v<T, std::unique_ptr<Fence>>) {
-                    auto& fence = arg;
+                if constexpr (std::is_same_v<T, FenceId>) {
+                    auto& fenceId = arg;
 
                     GFXSTREAM_TRACE_EVENT_INSTANT(
                         GFXSTREAM_TRACE_VIRTIO_GPU_TIMELINE_CATEGORY, "Signal Virtio Gpu Fence",
-                        GFXSTREAM_TRACE_TRACK(timeline.mTraceTrackId), "Fence", fence->mId);
+                        GFXSTREAM_TRACE_TRACK(timeline.mTraceTrackId), "Fence", fenceId);
 
-                    fence->mCompletionCallback();
+                    mFenceCompletionCallback(ring, fenceId);
 
                     return false;
                 } else if constexpr (std::is_same_v<T, std::shared_ptr<Task>>) {
diff --git a/host/VirtioGpuTimelines.h b/host/VirtioGpuTimelines.h
index dbc25b6a3..fc0f2bb53 100644
--- a/host/VirtioGpuTimelines.h
+++ b/host/VirtioGpuTimelines.h
@@ -18,14 +18,13 @@
 #include <functional>
 #include <list>
 #include <memory>
+#include <mutex>
 #include <sstream>
 #include <string>
 #include <unordered_map>
 #include <variant>
 
-#include "aemu/base/synchronization/Lock.h"
 #include "gfxstream/virtio-gpu-gfxstream-renderer.h"
-#include "render-utils/virtio_gpu_ops.h"
 
 typedef uint32_t VirtioGpuCtxId;
 typedef uint8_t VirtioGpuRingIdx;
@@ -80,22 +79,17 @@ class VirtioGpuTimelines {
     using FenceId = uint64_t;
     using Ring = VirtioGpuRing;
     using TaskId = uint64_t;
+    using FenceCompletionCallback = std::function<void(const Ring&, FenceId)>;
+
+    static std::unique_ptr<VirtioGpuTimelines> create(FenceCompletionCallback callback);
 
     TaskId enqueueTask(const Ring&);
-    void enqueueFence(const Ring&, FenceId, FenceCompletionCallback);
+    void enqueueFence(const Ring&, FenceId);
     void notifyTaskCompletion(TaskId);
     void poll();
-    static std::unique_ptr<VirtioGpuTimelines> create(bool withAsyncCallback);
 
    private:
-    VirtioGpuTimelines(bool withAsyncCallback);
-
-    struct Fence {
-        FenceId mId;
-        FenceCompletionCallback mCompletionCallback;
-        Fence(FenceId id, FenceCompletionCallback completionCallback)
-            : mId(id), mCompletionCallback(std::move(completionCallback)) {}
-    };
+    VirtioGpuTimelines(FenceCompletionCallback callback);
 
     struct Task {
         TaskId mId;
@@ -106,8 +100,7 @@ class VirtioGpuTimelines {
             : mId(id), mRing(ring), mTraceId(traceId), mHasCompleted(false) {}
     };
 
-    using TimelineItem =
-        std::variant<std::unique_ptr<Fence>, std::shared_ptr<Task>>;
+    using TimelineItem = std::variant<FenceId, std::shared_ptr<Task>>;
     struct Timeline {
         uint64_t mTraceTrackId;
         std::list<TimelineItem> mQueue;
@@ -115,17 +108,18 @@ class VirtioGpuTimelines {
 
     Timeline& GetOrCreateTimelineLocked(const Ring& ring);
 
-    android::base::Lock mLock;
+    // Go over the timeline, signal any fences without pending tasks, and remove
+    // timeline items that are no longer needed.
+    void poll_locked(const Ring&);
+
     std::atomic<TaskId> mNextId;
+    FenceCompletionCallback mFenceCompletionCallback;
+    std::mutex mTimelinesMutex;
     // The mTaskIdToTask cache must be destroyed after the actual owner of Task,
     // mTimelineQueues, is destroyed, because the deleter of Task will
     // automatically remove the entry in mTaskIdToTask.
     std::unordered_map<TaskId, std::weak_ptr<Task>> mTaskIdToTask;
     std::unordered_map<Ring, Timeline> mTimelineQueues;
-    const bool mWithAsyncCallback;
-    // Go over the timeline, signal any fences without pending tasks, and remove
-    // timeline items that are no longer needed.
-    void poll_locked(const Ring&);
 };
 
 #endif  // VIRTIO_GPU_TIMELINES_H
diff --git a/host/features/Features.cpp b/host/features/Features.cpp
index 524211356..0e126aaea 100644
--- a/host/features/Features.cpp
+++ b/host/features/Features.cpp
@@ -13,7 +13,8 @@
 // limitations under the License.
 
 #include "gfxstream/host/Features.h"
-
+#include <sstream>
+#include <vector>
 namespace gfxstream {
 namespace host {
 
@@ -21,6 +22,23 @@ FeatureSet::FeatureSet(const FeatureSet& rhs) : FeatureSet() {
     *this = rhs;
 }
 
+FeatureResult FeatureDependencyHandler::checkAllDependentFeaturesAreEnabled() {
+    // Only check for direct dependencies. Since we're verifying all enabled features, this should cover the whole span.
+    bool allDependenciesAreEnabled = true;
+    std::stringstream ss;
+    for (auto const&[feature, dependentFeatures] : VK_FEATURE_DEPENDENCY_MAP) {
+        if (feature->enabled && !dependentFeatures.empty()) {
+            for (auto const& dep : dependentFeatures) {
+                if (!dep->enabled) {
+                    ss << "Feature: " << feature->name << " requests missing dependency: " << dep->name << "\n";
+                    allDependenciesAreEnabled = false;
+                }
+            }
+        }
+    }
+    return {allDependenciesAreEnabled, ss.str()};
+};
+
 FeatureSet& FeatureSet::operator=(const FeatureSet& rhs) {
     for (const auto& [featureName, featureInfo] : rhs.map) {
         *map[featureName] = *featureInfo;
diff --git a/host/features/include/gfxstream/host/Features.h b/host/features/include/gfxstream/host/Features.h
index 38e034c4a..6c03a703c 100644
--- a/host/features/include/gfxstream/host/Features.h
+++ b/host/features/include/gfxstream/host/Features.h
@@ -16,6 +16,7 @@
 
 #include <string>
 #include <map>
+#include <vector>
 
 namespace gfxstream {
 namespace host {
@@ -23,6 +24,8 @@ namespace host {
 struct FeatureInfo;
 
 using FeatureMap = std::map<std::string, FeatureInfo*>;
+//type used for returning success or a string with the concatenated errors (missing features)
+using FeatureResult = std::pair<bool, std::string>;
 
 struct FeatureInfo {
     FeatureInfo(const FeatureInfo& rhs) = default;
@@ -216,6 +219,12 @@ struct FeatureSet {
         "called on a virtio-gpu-next branch in upstream kernel?).",
         &map,
     };
+    FeatureInfo BypassVulkanDeviceFeatureOverrides = {
+        "BypassVulkanDeviceFeatureOverrides",
+        "We are force disabling (overriding) some vulkan features (private data, uniform inline block etc) which the device may naturally support."
+        "If toggled ON, this flag will cause the host side to not force disable anything and let the device fully advertise supported features.",
+        &map,
+    };
     FeatureInfo VulkanAllocateDeviceMemoryOnly = {
         "VulkanAllocateDeviceMemoryOnly",
         "If enabled, prevents the guest from allocating Vulkan memory that does "
@@ -306,6 +315,23 @@ struct FeatureSet {
         "buffers on device lost. (TODO: VK_AMD_buffer_marker)",
         &map,
     };
+    FeatureInfo VulkanVirtualQueue = {
+        "VulkanVirtualQueue",
+        "(Experimental) If enabled, a virtual graphics queue will be added into physical Vulkan "
+        "device properties for the guest queries.",
+        &map,
+    };
+};
+struct FeatureDependencyHandler {
+    FeatureDependencyHandler(const FeatureSet& set) : featureSetView(set){}
+    const FeatureSet& featureSetView;
+    const std::map<const FeatureInfo*, std::vector<const FeatureInfo*>> VK_FEATURE_DEPENDENCY_MAP= {
+        // List other dependencies here in the shape of:
+        // {FEATURE_X, {DEPENDENT_FEATURE_A, DEPENDENT_FEATURE_B}}
+        {&featureSetView.VulkanSnapshots, {&featureSetView.VulkanBatchedDescriptorSetUpdate, &featureSetView.Vulkan}},
+    };
+
+    FeatureResult checkAllDependentFeaturesAreEnabled();
 };
 
 #define GFXSTREAM_SET_FEATURE_ON_CONDITION(set, feature, condition) \
diff --git a/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h b/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
index 612830641..5316a6fe9 100644
--- a/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
+++ b/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
@@ -14,11 +14,11 @@
 
 #pragma once
 
+#include <stdbool.h>
+#include <stdint.h>
+
 #include "aemu/base/c_header.h"
 #include "aemu/base/export.h"
-// #include "android/skin/winsys.h"
-
-#include <stdbool.h>
 
 ANDROID_BEGIN_HEADER
 
@@ -112,8 +112,8 @@ SelectedRenderer emuglConfig_get_current_renderer();
 // the hw.gpu.mode hardware property.
 const char* emuglConfig_get_user_gpu_option();
 
-void emuglConfig_get_vulkan_hardware_gpu(char** vendor, int* major, int* minor,
-        int* patch);
+void emuglConfig_get_vulkan_hardware_gpu(char** vendor, int* major, int* minor, int* patch,
+                                         uint64_t* deviceMemBytes, uint32_t* driverVersion);
 
 // Returns a string representation of the renderer enum. Return value is a
 // static constant string, it is NOT heap-allocated.
diff --git a/host/gl/gl-host-common/opengles.cpp b/host/gl/gl-host-common/opengles.cpp
index 1cc8c8636..b83e95974 100644
--- a/host/gl/gl-host-common/opengles.cpp
+++ b/host/gl/gl-host-common/opengles.cpp
@@ -90,7 +90,8 @@ static gfxstream::RendererPtr sRenderer = nullptr;
 int android_prepareOpenglesEmulation() {
     android_init_opengl_logger();
 
-    bool glFineLogging = android::base::getEnvironmentVariable("ANDROID_EMUGL_FINE_LOG") == "1";
+    bool glFineLogging = (android::base::getEnvironmentVariable("ANDROID_EMUGL_FINE_LOG") == "1") ||
+                         (android::base::getEnvironmentVariable("ANDROID_EMUGL_VERBOSE") == "1");
     bool glLogPrinting = android::base::getEnvironmentVariable("ANDROID_EMUGL_LOG_PRINT") == "1";
 
     AndroidOpenglLoggerFlags loggerFlags =
@@ -364,7 +365,6 @@ android_finishOpenglesRenderer()
     }
 }
 
-static gfxstream::RenderOpt sOpt;
 static int sWidth, sHeight;
 static int sNewWidth, sNewHeight;
 
diff --git a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
index f913f07d9..eadee8d67 100644
--- a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
+++ b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
@@ -86,8 +86,6 @@ VG_EXPORT void stream_renderer_flush(uint32_t res_handle);
 
 VG_EXPORT int stream_renderer_platform_import_resource(int res_handle, int res_info,
                                                        void* resource);
-VG_EXPORT int stream_renderer_platform_resource_info(int res_handle, int* width, int* height,
-                                                     int* internal_format);
 VG_EXPORT void* stream_renderer_platform_create_shared_egl_context(void);
 VG_EXPORT int stream_renderer_platform_destroy_shared_egl_context(void*);
 
@@ -106,10 +104,16 @@ struct stream_renderer_resource_info {
 VG_EXPORT int stream_renderer_resource_get_info(int res_handle,
                                                 struct stream_renderer_resource_info* info);
 
+VG_EXPORT int stream_renderer_suspend();
+
 VG_EXPORT int stream_renderer_snapshot(const char* dir);
 
 VG_EXPORT int stream_renderer_restore(const char* dir);
 
+VG_EXPORT int stream_renderer_resume();
+
+VG_EXPORT int stream_renderer_wait_sync_resource(uint32_t res_handle);
+
 #ifdef __cplusplus
 }  // extern "C"
 #endif
diff --git a/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h b/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
index 4f5fa23ea..4f6000d6e 100644
--- a/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
+++ b/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
@@ -21,7 +21,12 @@
 #include <stdint.h>
 
 #if defined(_WIN32)
-struct iovec;
+#if !defined(GFXSTREAM_NO_IOVEC)
+struct iovec {
+    void* iov_base; /* Starting address */
+    size_t iov_len; /* Length in bytes */
+};
+#endif
 #else
 #include <sys/uio.h>
 #endif
@@ -96,8 +101,6 @@ struct stream_renderer_handle {
 struct stream_renderer_debug {
     uint32_t debug_type;
     const char* message;
-    const char* file;
-    int line;
 };
 
 // Log level of gfxstream
@@ -105,6 +108,49 @@ struct stream_renderer_debug {
 #define STREAM_RENDERER_LOG_LEVEL STREAM_RENDERER_DEBUG_INFO
 #endif
 
+void stream_renderer_log(uint32_t type, const char* file, int line, const char* pretty_function,
+                         const char* format, ...);
+
+#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_ERROR
+#define stream_renderer_error(format, ...)                                                        \
+    do {                                                                                          \
+        stream_renderer_log(STREAM_RENDERER_DEBUG_ERROR, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
+                            format, ##__VA_ARGS__);                                               \
+    } while (0)
+#else
+#define stream_renderer_error(format, ...)
+#endif
+
+#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_WARN
+#define stream_renderer_warn(format, ...)                                                        \
+    do {                                                                                         \
+        stream_renderer_log(STREAM_RENDERER_DEBUG_WARN, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
+                            format, ##__VA_ARGS__);                                              \
+    } while (0)
+#else
+#define stream_renderer_warn(format, ...)
+#endif
+
+#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_INFO
+#define stream_renderer_info(format, ...)                                                         \
+    do {                                                                                          \
+        stream_renderer_log(STREAM_RENDERER_DEBUG_INFO, __FILE__, __LINE__, __FUNCTION__, format, \
+                            ##__VA_ARGS__);                                                       \
+    } while (0)
+#else
+#define stream_renderer_info(format, ...)
+#endif
+
+#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_DEBUG
+#define stream_renderer_debug(format, ...)                                                        \
+    do {                                                                                          \
+        stream_renderer_log(STREAM_RENDERER_DEBUG_DEBUG, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
+                            format, ##__VA_ARGS__);                                               \
+    } while (0)
+#else
+#define stream_renderer_debug(format, ...)
+#endif
+
 // Callback for writing a fence.
 typedef void (*stream_renderer_fence_callback)(void* user_data,
                                                struct stream_renderer_fence* fence_data);
@@ -155,6 +201,7 @@ VG_EXPORT void stream_renderer_teardown(void);
 
 VG_EXPORT int stream_renderer_resource_create(struct stream_renderer_resource_create_args* args,
                                               struct iovec* iov, uint32_t num_iovs);
+
 VG_EXPORT void stream_renderer_resource_unref(uint32_t res_handle);
 VG_EXPORT void stream_renderer_context_destroy(uint32_t handle);
 
@@ -240,8 +287,6 @@ struct stream_renderer_vulkan_info {
 VG_EXPORT int stream_renderer_vulkan_info(uint32_t res_handle,
                                           struct stream_renderer_vulkan_info* vulkan_info);
 
-VG_EXPORT int stream_renderer_wait_sync_resource(uint32_t res_handle);
-
 #ifdef __cplusplus
 }  // extern "C"
 #endif
diff --git a/host/meson.build b/host/meson.build
index 1592fce12..0abe13b80 100644
--- a/host/meson.build
+++ b/host/meson.build
@@ -119,7 +119,6 @@ gfxstream_headers = files(
 
 inc_root = include_directories('../')
 inc_gfxstream_include = include_directories('../include')
-inc_include = include_directories('../guest/mesa/include')
 # Included by all host component builds. Leave empty for future build updates.
 inc_include = include_directories()
 inc_utils = include_directories('../utils/include')
@@ -188,6 +187,10 @@ files_lib_gfxstream_backend = files(
   'FrameBuffer.cpp',
   'GfxStreamAgents.cpp',
   'virtio-gpu-gfxstream-renderer.cpp',
+  'VirtioGpuContext.cpp',
+  'VirtioGpuFrontend.cpp',
+  'VirtioGpuResource.cpp',
+  'VirtioGpuRingBlob.cpp',
   'VirtioGpuTimelines.cpp',
   'VsyncThread.cpp',
 )
diff --git a/host/tests/FrameBuffer_unittest.cpp b/host/tests/FrameBuffer_unittest.cpp
index c3a6a8176..83f3d9b45 100644
--- a/host/tests/FrameBuffer_unittest.cpp
+++ b/host/tests/FrameBuffer_unittest.cpp
@@ -212,8 +212,10 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer) {
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
     mFb->updateColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forUpdate.data());
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
+                         forRead.size());
 
     EXPECT_TRUE(ImageMatches(mWidth, mHeight, 4, mWidth, forUpdate.data(), forRead.data()));
 
@@ -368,8 +370,10 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_FormatChange) {
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
     mFb->updateColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forUpdate.data());
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
+                         forRead.size());
 
     EXPECT_TRUE(ImageMatches(mWidth, mHeight, 4, mWidth, forUpdate.data(),
                              forRead.data()));
@@ -441,9 +445,8 @@ TEST_F(FrameBufferTest, BasicBlit) {
             createTestTextureRGBA8888SingleColor(
                 mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
 
-        mFb->readColorBuffer(
-            colorBuffer, 0, 0, mWidth, mHeight,
-            GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+        mFb->readColorBuffer(colorBuffer, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE,
+                             forRead.data(), forRead.size());
 
         EXPECT_TRUE(
             ImageMatches(
@@ -506,8 +509,10 @@ TEST_F(FrameBufferTest, SnapshotSingleColorBuffer) {
     saveSnapshot();
     loadSnapshot();
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
+                         forRead.size());
 
     EXPECT_TRUE(ImageMatches(mWidth, mHeight, 4, mWidth, forUpdate.data(), forRead.data()));
 
@@ -528,8 +533,10 @@ TEST_F(FrameBufferTest, SnapshotColorBufferSubUpdateRestore) {
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
     mFb->updateColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forUpdate.data());
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
+                         forRead.size());
 
     EXPECT_TRUE(ImageMatches(mWidth, mHeight, 4, mWidth, forUpdate.data(), forRead.data()));
 
@@ -753,9 +760,11 @@ TEST_F(FrameBufferTest, DISABLED_ReadColorBufferSwitchRedBlue) {
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
     mFb->updateColorBuffer(handle, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, forUpdate.data());
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
     // Switch red and blue
-    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_BGRA_EXT, GL_UNSIGNED_BYTE, forRead.data());
+    mFb->readColorBuffer(handle, 0, 0, mWidth, mHeight, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
+                         forRead.data(), forRead.size());
 
     // Switch them back, so we get the original image
     uint8_t* forReadBytes = forRead.data();
@@ -905,8 +914,10 @@ TEST_F(FrameBufferTest, PixmapImport_Basic) {
 
     EXPECT_TRUE(mFb->platformImportResource(cb, RESOURCE_TYPE_EGL_NATIVE_PIXMAP|RESOURCE_USE_PRESERVE, pixmap));
 
-    TestTexture forRead = createTestTextureRGBA8888SingleColor(kWidth, kHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(cb, 0, 0, kWidth, kHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+    TestTexture forRead =
+        createTestTextureRGBA8888SingleColor(kWidth, kHeight, 0.0f, 0.0f, 0.0f, 0.0f);
+    mFb->readColorBuffer(cb, 0, 0, kWidth, kHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
+                         forRead.size());
 
     EXPECT_TRUE(ImageMatches(kWidth, kHeight, 4, kWidth, forUpdate.data(), forRead.data()));
 
@@ -963,9 +974,8 @@ TEST_F(FrameBufferTest, PixmapImport_Blit) {
             createTestTextureRGBA8888SingleColor(
                 mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
 
-        mFb->readColorBuffer(
-            colorBuffer, 0, 0, mWidth, mHeight,
-            GL_RGBA, GL_UNSIGNED_BYTE, forRead.data());
+        mFb->readColorBuffer(colorBuffer, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE,
+                             forRead.data(), forRead.size());
 
         EXPECT_TRUE(
             ImageMatches(
diff --git a/host/tests/VirtioGpuTimelines_unittest.cpp b/host/tests/VirtioGpuTimelines_unittest.cpp
index 5e7dbc0f3..f75e7df96 100644
--- a/host/tests/VirtioGpuTimelines_unittest.cpp
+++ b/host/tests/VirtioGpuTimelines_unittest.cpp
@@ -21,226 +21,274 @@
 namespace gfxstream {
 namespace {
 
+using testing::ElementsAreArray;
+using testing::Eq;
+using testing::ElementsAreArray;
+using testing::IsEmpty;
+using testing::Pair;
+
+using Ring = VirtioGpuTimelines::Ring;
+using FenceId = VirtioGpuTimelines::FenceId;
 using RingGlobal = VirtioGpuRingGlobal;
 using RingContextSpecific = VirtioGpuRingContextSpecific;
 
+const auto kGlobalRing = Ring{VirtioGpuRingGlobal{}};
+const auto kContext2Ring = Ring{RingContextSpecific{
+    .mCtxId = 2,
+    .mRingIdx = 0,
+}};
+const auto kContext3Ring = Ring{RingContextSpecific{
+    .mCtxId = 3,
+    .mRingIdx = 0,
+}};
+
 TEST(VirtioGpuTimelinesTest, Init) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    virtioGpuTimelines = VirtioGpuTimelines::create(false);
+    auto noopCallback = [](const Ring&, FenceId) {};
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines;
+    virtioGpuTimelines = VirtioGpuTimelines::create(noopCallback);
+    virtioGpuTimelines = VirtioGpuTimelines::create(noopCallback);
 }
 
 TEST(VirtioGpuTimelinesTest, TasksShouldHaveDifferentIds) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    auto taskId1 = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    auto taskId2 = virtioGpuTimelines->enqueueTask(RingGlobal{});
+    auto noopCallback = [](const Ring&, FenceId) {};
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(noopCallback);
+    auto taskId1 = virtioGpuTimelines->enqueueTask(kGlobalRing);
+    auto taskId2 = virtioGpuTimelines->enqueueTask(kGlobalRing);
     ASSERT_NE(taskId1, taskId2);
 }
 
-TEST(VirtioGpuTimelinesTest, CantPollWithAsyncCallbackEnabled) {
-    EXPECT_DEATH(
-        {
-            std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
-                VirtioGpuTimelines::create(true);
-            virtioGpuTimelines->poll();
-        },
-        ".*");
-}
+TEST(VirtioGpuTimelinesTest, MultipleTasksAndFencesWithAsyncCallback) {
+    std::vector<std::pair<Ring, FenceId>> signaledFences;
 
-TEST(VirtioGpuTimelinesTest, MultipleTasksAndFencesWithSyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(false);
-    using namespace testing;
-    MockFunction<void()> check;
-    MockFunction<void()> fence1Callback;
-    MockFunction<void()> fence2Callback;
-    MockFunction<void()> fence3Callback;
-    VirtioGpuTimelines::FenceId fenceId = 0;
-    {
-        InSequence s;
-
-        EXPECT_CALL(check, Call());
-        EXPECT_CALL(fence1Callback, Call());
-        EXPECT_CALL(fence2Callback, Call());
-        EXPECT_CALL(fence3Callback, Call());
-    }
-
-    auto task1Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence1Callback.AsStdFunction());
-    auto task2Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence2Callback.AsStdFunction());
-    virtioGpuTimelines->notifyTaskCompletion(task1Id);
-    auto task3Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence3Callback.AsStdFunction());
-    virtioGpuTimelines->notifyTaskCompletion(task2Id);
-    virtioGpuTimelines->notifyTaskCompletion(task3Id);
-    check.Call();
-    virtioGpuTimelines->poll();
-}
+    auto fenceCallback =
+        [&](const Ring& ring, FenceId fenceId) {
+            signaledFences.push_back(std::make_pair(ring, fenceId));
+        };
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(fenceCallback);
+
+    FenceId fenceId = 0;
+
+    auto task1Id = virtioGpuTimelines->enqueueTask(kGlobalRing);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto fence1Id = fenceId++;
+
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence1Id);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto task2Id = virtioGpuTimelines->enqueueTask(kGlobalRing);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto fence2Id = fenceId++;
+
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence2Id);
+    EXPECT_THAT(signaledFences, IsEmpty());
 
-TEST(VirtioGpuTimelinesTest, MultipleTasksAndFencesWithAsyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    using namespace testing;
-    MockFunction<void(int)> check;
-    MockFunction<void()> fence1Callback;
-    MockFunction<void()> fence2Callback;
-    MockFunction<void()> fence3Callback;
-    VirtioGpuTimelines::FenceId fenceId = 0;
-    {
-        InSequence s;
-
-        EXPECT_CALL(check, Call(1));
-        EXPECT_CALL(fence1Callback, Call());
-        EXPECT_CALL(check, Call(2));
-        EXPECT_CALL(check, Call(3));
-        EXPECT_CALL(fence2Callback, Call());
-        EXPECT_CALL(check, Call(4));
-        EXPECT_CALL(fence3Callback, Call());
-    }
-
-    auto task1Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence1Callback.AsStdFunction());
-    auto task2Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence2Callback.AsStdFunction());
-    check.Call(1);
     virtioGpuTimelines->notifyTaskCompletion(task1Id);
-    check.Call(2);
-    auto task3Id = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fence3Callback.AsStdFunction());
-    check.Call(3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                }));
+
+    auto task3Id = virtioGpuTimelines->enqueueTask(kGlobalRing);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                }));
+
+    auto fence3Id = fenceId++;
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence3Id);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(task2Id);
-    check.Call(4);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                    Pair(Eq(kGlobalRing), Eq(fence2Id)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(task3Id);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                    Pair(Eq(kGlobalRing), Eq(fence2Id)),
+                    Pair(Eq(kGlobalRing), Eq(fence3Id)),
+                }));
 }
 
 TEST(VirtioGpuTimelinesTest, FencesWithoutPendingTasksWithAsyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    using namespace testing;
-    MockFunction<void()> fenceCallback1;
-    MockFunction<void()> fenceCallback2;
-    VirtioGpuTimelines::FenceId fenceId = 0;
-    {
-        InSequence s;
-        EXPECT_CALL(fenceCallback1, Call());
-        EXPECT_CALL(fenceCallback2, Call());
-    }
-
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fenceCallback1.AsStdFunction());
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fenceCallback2.AsStdFunction());
+    std::vector<std::pair<Ring, FenceId>> signaledFences;
+
+    auto fenceCallback =
+        [&](const Ring& ring, FenceId fenceId) {
+            signaledFences.push_back(std::make_pair(ring, fenceId));
+        };
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(fenceCallback);
+
+    FenceId fenceId = 0;
+
+    auto fence1Id = fenceId++;
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence1Id);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                }));
+
+    auto fence2Id = fenceId++;
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence2Id);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                    Pair(Eq(kGlobalRing), Eq(fence2Id)),
+                }));
 }
 
 TEST(VirtioGpuTimelinesTest, FencesSharingSamePendingTasksWithAsyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    using namespace testing;
-    MockFunction<void()> fenceCallback1;
-    MockFunction<void()> fenceCallback2;
-    MockFunction<void(int)> check;
-    VirtioGpuTimelines::FenceId fenceId = 0;
-    {
-        InSequence s;
-        EXPECT_CALL(check, Call(1));
-        EXPECT_CALL(fenceCallback1, Call());
-        EXPECT_CALL(fenceCallback2, Call());
-    }
-
-    auto taskId = virtioGpuTimelines->enqueueTask(RingGlobal{});
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fenceCallback1.AsStdFunction());
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, fenceId++, fenceCallback2.AsStdFunction());
-    check.Call(1);
+   std::vector<std::pair<Ring, FenceId>> signaledFences;
+
+    auto fenceCallback =
+        [&](const Ring& ring, FenceId fenceId) {
+            signaledFences.push_back(std::make_pair(ring, fenceId));
+        };
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(fenceCallback);
+
+    FenceId fenceId = 0;
+
+    auto taskId = virtioGpuTimelines->enqueueTask(kGlobalRing);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto fence1Id = fenceId++;
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence1Id);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto fence2Id = fenceId++;
+    virtioGpuTimelines->enqueueFence(kGlobalRing, fence2Id);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
     virtioGpuTimelines->notifyTaskCompletion(taskId);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(fence1Id)),
+                    Pair(Eq(kGlobalRing), Eq(fence2Id)),
+                }));
 }
 
 TEST(VirtioGpuTimelinesTest, TasksAndFencesOnMultipleContextsWithAsyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    using namespace testing;
-    MockFunction<void()> fence1Callback;
-    MockFunction<void()> fence2Callback;
-    MockFunction<void()> fence3Callback;
-    MockFunction<void(int)> check;
-    {
-        InSequence s;
-
-        EXPECT_CALL(check, Call(1));
-        EXPECT_CALL(fence1Callback, Call());
-        EXPECT_CALL(check, Call(2));
-        EXPECT_CALL(fence2Callback, Call());
-        EXPECT_CALL(check, Call(3));
-        EXPECT_CALL(fence3Callback, Call());
-    }
-    auto taskId2 = virtioGpuTimelines->enqueueTask(RingContextSpecific{
-        .mCtxId = 2,
-        .mRingIdx = 0,
-    });
-    auto taskId3 = virtioGpuTimelines->enqueueTask(RingContextSpecific{
-        .mCtxId = 3,
-        .mRingIdx = 0,
-    });
-    check.Call(1);
-    virtioGpuTimelines->enqueueFence(RingGlobal{}, 1, fence1Callback.AsStdFunction());
-    check.Call(2);
-    virtioGpuTimelines->enqueueFence(
-        RingContextSpecific{
-            .mCtxId = 2,
-            .mRingIdx = 0,
-        },
-        2, fence2Callback.AsStdFunction());
-    virtioGpuTimelines->enqueueFence(
-        RingContextSpecific{
-            .mCtxId = 3,
-            .mRingIdx = 0,
-        },
-        3, fence3Callback.AsStdFunction());
+    std::vector<std::pair<Ring, FenceId>> signaledFences;
+
+    auto fenceCallback =
+        [&](const Ring& ring, FenceId fenceId) {
+            signaledFences.push_back(std::make_pair(ring, fenceId));
+        };
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(fenceCallback);
+
+    auto taskId2 = virtioGpuTimelines->enqueueTask(kContext2Ring);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    auto taskId3 = virtioGpuTimelines->enqueueTask(kContext3Ring);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    virtioGpuTimelines->enqueueFence(kGlobalRing, 1);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(1)),
+                }));
+
+    virtioGpuTimelines->enqueueFence(kContext2Ring, 2);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(1)),
+                }));
+
+    virtioGpuTimelines->enqueueFence(kContext3Ring, 3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(1)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(taskId2);
-    check.Call(3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(1)),
+                    Pair(Eq(kContext2Ring), Eq(2)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(taskId3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kGlobalRing), Eq(1)),
+                    Pair(Eq(kContext2Ring), Eq(2)),
+                    Pair(Eq(kContext3Ring), Eq(3)),
+                }));
 }
 
 TEST(VirtioGpuTimelinesTest, TasksAndFencesOnMultipleRingsWithAsyncCallback) {
-    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines = VirtioGpuTimelines::create(true);
-    using namespace testing;
-    MockFunction<void()> fence1Callback;
-    MockFunction<void()> fence2Callback;
-    MockFunction<void()> fence3Callback;
-    MockFunction<void(int)> check;
-    {
-        InSequence s;
-
-        EXPECT_CALL(check, Call(1));
-        EXPECT_CALL(fence1Callback, Call());
-        EXPECT_CALL(check, Call(2));
-        EXPECT_CALL(fence2Callback, Call());
-        EXPECT_CALL(check, Call(3));
-        EXPECT_CALL(fence3Callback, Call());
-    }
-    auto taskId2 = virtioGpuTimelines->enqueueTask(RingContextSpecific{
+    std::vector<std::pair<Ring, FenceId>> signaledFences;
+
+    auto fenceCallback =
+        [&](const Ring& ring, FenceId fenceId) {
+            signaledFences.push_back(std::make_pair(ring, fenceId));
+        };
+    std::unique_ptr<VirtioGpuTimelines> virtioGpuTimelines =
+        VirtioGpuTimelines::create(fenceCallback);
+
+    const auto kContext1Ring1 = Ring{RingContextSpecific{
+        .mCtxId = 1,
+        .mRingIdx = 1,
+    }};
+    const auto kContext1Ring2 = Ring{RingContextSpecific{
         .mCtxId = 1,
         .mRingIdx = 2,
-    });
-    auto taskId3 = virtioGpuTimelines->enqueueTask(RingContextSpecific{
+    }};
+    const auto kContext1Ring3 = Ring{RingContextSpecific{
         .mCtxId = 1,
         .mRingIdx = 3,
-    });
-    check.Call(1);
-    virtioGpuTimelines->enqueueFence(
-        RingContextSpecific{
-            .mCtxId = 1,
-            .mRingIdx = 1,
-        },
-        1, fence1Callback.AsStdFunction());
-    check.Call(2);
-    virtioGpuTimelines->enqueueFence(
-        RingContextSpecific{
-            .mCtxId = 1,
-            .mRingIdx = 2,
-        },
-        2, fence2Callback.AsStdFunction());
-    virtioGpuTimelines->enqueueFence(
-        RingContextSpecific{
-            .mCtxId = 1,
-            .mRingIdx = 3,
-        },
-        3, fence3Callback.AsStdFunction());
+    }};
+
+    auto taskId2 = virtioGpuTimelines->enqueueTask(kContext1Ring2);
+    auto taskId3 = virtioGpuTimelines->enqueueTask(kContext1Ring3);
+    EXPECT_THAT(signaledFences, IsEmpty());
+
+    virtioGpuTimelines->enqueueFence(kContext1Ring1, 1);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kContext1Ring1), Eq(1)),
+                }));
+
+    virtioGpuTimelines->enqueueFence(kContext1Ring2, 2);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kContext1Ring1), Eq(1)),
+                }));
+
+    virtioGpuTimelines->enqueueFence(kContext1Ring3, 3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kContext1Ring1), Eq(1)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(taskId2);
-    check.Call(3);
+    EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kContext1Ring1), Eq(1)),
+                    Pair(Eq(kContext1Ring2), Eq(2)),
+                }));
+
     virtioGpuTimelines->notifyTaskCompletion(taskId3);
+        EXPECT_THAT(signaledFences,
+                ElementsAreArray({
+                    Pair(Eq(kContext1Ring1), Eq(1)),
+                    Pair(Eq(kContext1Ring2), Eq(2)),
+                    Pair(Eq(kContext1Ring3), Eq(3)),
+                }));
 }
 
 }  // namespace
diff --git a/host/tracing/Android.bp b/host/tracing/Android.bp
index 50c35614a..02ad3199a 100644
--- a/host/tracing/Android.bp
+++ b/host/tracing/Android.bp
@@ -15,6 +15,9 @@ cc_library_static {
     whole_static_libs: [
         "libperfetto_client_experimental",
     ],
+    shared_libs: [
+        "liblog",
+    ],
     srcs: [
         "Tracing.cpp",
     ],
diff --git a/host/virtgpu_gfxstream_protocol.h b/host/virtgpu_gfxstream_protocol.h
index cb7e5920c..39a75c7ad 100644
--- a/host/virtgpu_gfxstream_protocol.h
+++ b/host/virtgpu_gfxstream_protocol.h
@@ -128,6 +128,7 @@ struct vulkanCapset {
     uint32_t alwaysBlob;
     uint32_t externalSync;
     uint32_t virglSupportedFormats[16];
+    uint32_t vulkanBatchedDescriptorSetUpdate;
 };
 
 struct magmaCapset {
diff --git a/host/virtio-gpu-gfxstream-renderer.cpp b/host/virtio-gpu-gfxstream-renderer.cpp
index a5c43fcee..9f105497a 100644
--- a/host/virtio-gpu-gfxstream-renderer.cpp
+++ b/host/virtio-gpu-gfxstream-renderer.cpp
@@ -11,2441 +11,194 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-#include <vulkan/vulkan.h>
 
 #include <cstdarg>
-#include <cstdio>
-#include <deque>
-#include <type_traits>
-#include <unordered_map>
-#include <variant>
+#include <cstdint>
 
-#include "ExternalObjectManager.h"
 #include "FrameBuffer.h"
 #include "GfxStreamAgents.h"
-#include "VirtioGpuTimelines.h"
-#include "VkCommonOperations.h"
-#include "aemu/base/AlignedBuf.h"
-#include "aemu/base/ManagedDescriptor.hpp"
+#include "VirtioGpuFrontend.h"
 #include "aemu/base/Metrics.h"
-#include "aemu/base/Tracing.h"
-#include "aemu/base/memory/SharedMemory.h"
-#include "aemu/base/synchronization/Lock.h"
-#include "aemu/base/threads/WorkerThread.h"
+#include "aemu/base/system/System.h"
 #include "gfxstream/Strings.h"
 #include "gfxstream/host/Features.h"
 #include "gfxstream/host/Tracing.h"
-#include "host-common/AddressSpaceService.h"
-#include "host-common/GfxstreamFatalError.h"
-#include "host-common/address_space_device.h"
+#include "host-common/FeatureControl.h"
+#include "host-common/GraphicsAgentFactory.h"
 #include "host-common/android_pipe_common.h"
 #include "host-common/android_pipe_device.h"
-#include "host-common/feature_control.h"
 #include "host-common/globals.h"
-#include "host-common/logging.h"
 #include "host-common/opengles-pipe.h"
 #include "host-common/opengles.h"
 #include "host-common/refcount-pipe.h"
 #include "host-common/vm_operations.h"
-#include "virgl_hw.h"
-#include "virtgpu_gfxstream_protocol.h"
+#include "vulkan/VulkanDispatch.h"
+#include "render-utils/RenderLib.h"
 #include "vk_util.h"
 
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
-#include "aemu/base/files/StdioStream.h"
-#endif
-
-extern "C" {
-#include "drm_fourcc.h"
-#include "gfxstream/virtio-gpu-gfxstream-renderer-unstable.h"
-#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
-#include "host-common/goldfish_pipe.h"
-#include "virgl_hw.h"
-}  // extern "C"
-
-#if defined(_WIN32)
-struct iovec {
-    void* iov_base; /* Starting address */
-    size_t iov_len; /* Length in bytes */
-};
-#else
-#include <unistd.h>
-#endif  // _WIN32
-
-#define MAX_DEBUG_BUFFER_SIZE 512
-#define ELLIPSIS "...\0"
-#define ELLIPSIS_LEN 4
-
-// Define the typedef for emulogger
-typedef void (*emulogger)(char severity, const char* file, unsigned int line,
-                          int64_t timestamp_us, const char* message);
-
-// Template to enable the method call if gfxstream_logger_t equals emulogger
-template<typename T>
-typename std::enable_if<std::is_same<T, emulogger>::value, bool>::type
-call_logger_if_valid(T logger, char severity, const char* file, unsigned int line, int64_t timestamp_us, const char* message) {
-    // Call the logger and return true if the type matches
-    if (!logger) { return false; }
-    logger(severity, file, line, timestamp_us, message);
-    return true;
-}
-
-// Template for invalid logger types (returns false if types don't match)
-template<typename T>
-typename std::enable_if<!std::is_same<T, emulogger>::value, bool>::type
-call_logger_if_valid(T, char, const char*, unsigned int, int64_t, const char*) {
-    // Return false if the type doesn't match
-    return false;
-}
-
-
-void* globalUserData = nullptr;
-stream_renderer_debug_callback globalDebugCallback = nullptr;
-
-static void append_truncation_marker(char* buf, int remaining_size) {
-    // Safely append truncation marker "..." if buffer has enough space
-    if (remaining_size >= ELLIPSIS_LEN) {
-        strncpy(buf + remaining_size - ELLIPSIS_LEN, ELLIPSIS, ELLIPSIS_LEN);
-    } else if (remaining_size >= 1) {
-        buf[remaining_size - 1] = '\0';
-    } else {
-        // Oh oh.. In theory this shouldn't happen.
-        assert(false);
-    }
-}
-
-static void log_with_prefix(char*& buf, int& remaining_size, const char* file, int line,
-                            const char* pretty_function) {
-    // Add logging prefix if necessary
-    int formatted_len = snprintf(buf, remaining_size, "[%s(%d)] %s ", file, line, pretty_function);
-
-    // Handle potential truncation
-    if (formatted_len >= remaining_size) {
-        append_truncation_marker(buf, remaining_size);
-        remaining_size = 0;
-    } else {
-        buf += formatted_len;             // Adjust buf
-        remaining_size -= formatted_len;  // Reduce remaining buffer size
-    }
-}
-
-static char translate_severity(uint32_t type) {
-    switch (type) {
-        case STREAM_RENDERER_DEBUG_ERROR:
-            return 'E';
-        case STREAM_RENDERER_DEBUG_WARN:
-            return 'W';
-        case STREAM_RENDERER_DEBUG_INFO:
-            return 'I';
-        case STREAM_RENDERER_DEBUG_DEBUG:
-            return 'D';
-        default:
-            return 'D';
-    }
-}
-
-void stream_renderer_log(uint32_t type, const char* file, int line, const char* pretty_function,
-                         const char* format, ...) {
-
-    static gfxstream_logger_t gfx_logger = get_gfx_stream_logger();
-    char printbuf[MAX_DEBUG_BUFFER_SIZE];
-    char* buf = printbuf;
-    int remaining_size = MAX_DEBUG_BUFFER_SIZE;
-    static_assert(MAX_DEBUG_BUFFER_SIZE > 4);
-
-    // Add the logging prefix if needed
-    if (!gfx_logger) {
-        log_with_prefix(buf, remaining_size, file, line, pretty_function);
-    }
-
-    // Format the message with variable arguments
-    va_list args;
-    va_start(args, format);
-    int formatted_len = vsnprintf(buf, remaining_size, format, args);
-    va_end(args);
-
-    // Handle potential truncation
-    if (formatted_len >= remaining_size) {
-        append_truncation_marker(buf, remaining_size);
-    }
-
-    // Forward to emulator?
-    if (call_logger_if_valid(gfx_logger, translate_severity(type), file, line, 0, printbuf)) {
-        return;
-    }
-
-    // To a gfxstream debugger?
-    if (globalUserData && globalDebugCallback) {
-        struct stream_renderer_debug debug = {0};
-        debug.debug_type = type;
-        debug.message = &printbuf[0];
-        globalDebugCallback(globalUserData, &debug);
-    } else {
-        fprintf(stderr, "%s\n", printbuf);
-    }
-}
-
-#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_ERROR
-#define stream_renderer_error(format, ...)                                                        \
-    do {                                                                                          \
-        stream_renderer_log(STREAM_RENDERER_DEBUG_ERROR, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
-                            format, ##__VA_ARGS__);                                               \
-    } while (0)
-#else
-#define stream_renderer_error(format, ...)
-#endif
-
-#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_WARN
-#define stream_renderer_warn(format, ...)                                                        \
-    do {                                                                                         \
-        stream_renderer_log(STREAM_RENDERER_DEBUG_WARN, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
-                            format, ##__VA_ARGS__);                                              \
-    } while (0)
-#else
-#define stream_renderer_warn(format, ...)
-#endif
-
-#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_INFO
-#define stream_renderer_info(format, ...)                                                         \
-    do {                                                                                          \
-        stream_renderer_log(STREAM_RENDERER_DEBUG_INFO, __FILE__, __LINE__, __FUNCTION__, format, \
-                            ##__VA_ARGS__);                                                       \
-    } while (0)
-#else
-#define stream_renderer_info(format, ...)
-#endif
-
-#if STREAM_RENDERER_LOG_LEVEL >= STREAM_RENDERER_DEBUG_DEBUG
-#define stream_renderer_debug(format, ...)                                                        \
-    do {                                                                                          \
-        stream_renderer_log(STREAM_RENDERER_DEBUG_DEBUG, __FILE__, __LINE__, __PRETTY_FUNCTION__, \
-                            format, ##__VA_ARGS__);                                               \
-    } while (0)
-#else
-#define stream_renderer_debug(format, ...)
-#endif
-
-// Virtio Goldfish Pipe: Overview-----------------------------------------------
-//
-// Virtio Goldfish Pipe is meant for running goldfish pipe services with a
-// stock Linux kernel that is already capable of virtio-gpu. It runs DRM
-// VIRTGPU ioctls on top of a custom implementation of virglrenderer on the
-// host side that doesn't (directly) do any rendering, but instead talks to
-// host-side pipe services.
-//
-// This is mainly used for graphics at the moment, though it's possible to run
-// other pipe services over virtio-gpu as well. virtio-gpu is selected over
-// other devices primarily because of the existence of an API (virglrenderer)
-// that is already somewhat separate from virtio-gpu, and not needing to create
-// a new virtio device to handle goldfish pipe.
-//
-// How it works is, existing virglrenderer API are remapped to perform pipe
-// operations. First of all, pipe operations consist of the following:
-//
-// - open() / close(): Starts or stops an instance of a pipe service.
-//
-// - write(const void* buf, size_t len) / read(const void* buf, size_t len):
-// Sends or receives data over the pipe. The first write() is the name of the
-// pipe service. After the pipe service is determined, the host calls
-// resetPipe() to replace the host-side pipe instance with an instance of the
-// pipe service.
-//
-// - reset(void* initialPipe, void* actualPipe): the operation that replaces an
-// initial pipe with an instance of a pipe service.
-//
-// Next, here's how the pipe operations map to virglrenderer commands:
-//
-// - open() -> virgl_renderer_context_create(),
-//             virgl_renderer_resource_create(),
-//             virgl_renderer_resource_attach_iov()
-//
-// The open() corresponds to a guest-side open of a rendernode, which triggers
-// context creation. Each pipe corresponds 1:1 with a drm virtgpu context id.
-// We also associate an R8 resource with each pipe as the backing data for
-// write/read.
-//
-// - close() -> virgl_rendrerer_resource_unref(),
-//              virgl_renderer_context_destroy()
-//
-// The close() corresponds to undoing the operations of open().
-//
-// - write() -> virgl_renderer_transfer_write_iov() OR
-//              virgl_renderer_submit_cmd()
-//
-// Pipe write() operation corresponds to performing a TRANSFER_TO_HOST ioctl on
-// the resource created alongside open(), OR an EXECBUFFER ioctl.
-//
-// - read() -> virgl_renderer_transfer_read_iov()
-//
-// Pipe read() operation corresponds to performing a TRANSFER_FROM_HOST ioctl on
-// the resource created alongside open().
-//
-// Details on transfer mechanism: mapping 2D transfer to 1D ones----------------
-//
-// Resource objects are typically 2D textures, while we're wanting to transmit
-// 1D buffers to the pipe services on the host.  DRM VIRTGPU uses the concept
-// of a 'box' to represent transfers that do not involve an entire resource
-// object.  Each box has a x, y, width and height parameter to define the
-// extent of the transfer for a 2D texture.  In our use case, we only use the x
-// and width parameters. We've also created the resource with R8 format
-// (byte-by-byte) with width equal to the total size of the transfer buffer we
-// want (around 1 MB).
-//
-// The resource object itself is currently backed via plain guest RAM, which
-// can be physically not-contiguous from the guest POV, and therefore
-// corresponds to a possibly-long list of pointers and sizes (iov) on the host
-// side. The sync_iov helper function converts convert the list of pointers
-// to one contiguous buffer on the host (or vice versa), at the cost of a copy.
-// (TODO: see if we can use host coherent memory to do away with the copy).
-//
-// We can see this abstraction in use via the implementation of
-// transferWriteIov and transferReadIov below, which sync the iovec to/from a
-// linear buffer if necessary, and then perform a corresponding pip operation
-// based on the box parameter's x and width values.
-
-using android::AndroidPipe;
-using android::base::AutoLock;
-using android::base::DescriptorType;
-using android::base::Lock;
-using android::base::ManagedDescriptor;
-using android::base::MetricsLogger;
-using android::base::SharedMemory;
-
-using emugl::FatalError;
-using gfxstream::BlobDescriptorInfo;
-using gfxstream::ExternalObjectManager;
-using gfxstream::SyncDescriptorInfo;
-
-using VirtioGpuResId = uint32_t;
-
-static constexpr int kPipeTryAgain = -2;
-
-struct VirtioGpuCmd {
-    uint32_t op;
-    uint32_t cmdSize;
-    unsigned char buf[0];
-} __attribute__((packed));
-
-struct PipeCtxEntry {
-    std::string name;
-    uint32_t capsetId;
-    VirtioGpuCtxId ctxId;
-    GoldfishHostPipe* hostPipe;
-    int fence;
-    uint32_t addressSpaceHandle;
-    bool hasAddressSpaceHandle;
-    std::unordered_map<VirtioGpuResId, uint32_t> addressSpaceHandles;
-    std::unordered_map<uint32_t, struct stream_renderer_resource_create_args> blobMap;
-    std::shared_ptr<gfxstream::SyncDescriptorInfo> latestFence;
-};
-
-enum class ResType {
-    // Used as a communication channel between the guest and the host
-    // which does not need an allocation on the host GPU.
-    PIPE,
-    // Used as a GPU data buffer.
-    BUFFER,
-    // Used as a GPU texture.
-    COLOR_BUFFER,
-    // Used as a blob and not known to FrameBuffer.
-    BLOB,
-};
-
-struct AlignedMemory {
-    void* addr = nullptr;
-
-    AlignedMemory(size_t align, size_t size)
-        : addr(android::aligned_buf_alloc(align, size)) {}
-
-    ~AlignedMemory() {
-        if (addr != nullptr) {
-            android::aligned_buf_free(addr);
-        }
-    }
-
-    // AlignedMemory is neither copyable nor movable.
-    AlignedMemory(const AlignedMemory& other) = delete;
-    AlignedMemory& operator=(const AlignedMemory& other) = delete;
-    AlignedMemory(AlignedMemory&& other) = delete;
-    AlignedMemory& operator=(AlignedMemory&& other) = delete;
-};
-
-// Memory used as a ring buffer for communication between the guest and host.
-class RingBlob : public std::variant<std::unique_ptr<AlignedMemory>,
-                                     std::unique_ptr<SharedMemory>> {
-  public:
-    using BaseType = std::variant<std::unique_ptr<AlignedMemory>,
-                                  std::unique_ptr<SharedMemory>>;
-    // Inherit constructors.
-    using BaseType::BaseType;
-
-    bool isExportable() const {
-        return std::holds_alternative<std::unique_ptr<SharedMemory>>(*this);
-    }
-
-    SharedMemory::handle_type releaseHandle() {
-        if (!isExportable()) {
-            return SharedMemory::invalidHandle();
-        }
-        return std::get<std::unique_ptr<SharedMemory>>(*this)->releaseHandle();
-    }
-};
-
-struct PipeResEntry {
-    stream_renderer_resource_create_args args;
-    iovec* iov;
-    uint32_t numIovs;
-    void* linear;
-    size_t linearSize;
-    GoldfishHostPipe* hostPipe;
-    VirtioGpuCtxId ctxId;
-    void* hva;
-    uint64_t hvaSize;
-    uint64_t blobId;
-    uint32_t blobMem;
-    uint32_t blobFlags;
-    uint32_t caching;
-    ResType type;
-    std::shared_ptr<RingBlob> ringBlob;
-    bool externalAddr = false;
-    std::shared_ptr<BlobDescriptorInfo> descriptorInfo = nullptr;
-};
-
-static inline uint32_t align_up(uint32_t n, uint32_t a) { return ((n + a - 1) / a) * a; }
-
-static inline uint32_t align_up_power_of_2(uint32_t n, uint32_t a) {
-    return (n + (a - 1)) & ~(a - 1);
-}
-
-#define VIRGL_FORMAT_NV12 166
-#define VIRGL_FORMAT_YV12 163
-#define VIRGL_FORMAT_P010 314
-
-const uint32_t kGlBgra = 0x80e1;
-const uint32_t kGlRgba = 0x1908;
-const uint32_t kGlRgba16f = 0x881A;
-const uint32_t kGlRgb565 = 0x8d62;
-const uint32_t kGlRgba1010102 = 0x8059;
-const uint32_t kGlR8 = 0x8229;
-const uint32_t kGlR16 = 0x822A;
-const uint32_t kGlRg8 = 0x822b;
-const uint32_t kGlRgb8 = 0x8051;
-const uint32_t kGlLuminance = 0x1909;
-const uint32_t kGlLuminanceAlpha = 0x190a;
-const uint32_t kGlUnsignedByte = 0x1401;
-const uint32_t kGlUnsignedShort = 0x1403;
-const uint32_t kGlUnsignedShort565 = 0x8363;
-const uint32_t kGlDepth16 = 0x81A5;
-const uint32_t kGlDepth24 = 0x81A6;
-const uint32_t kGlDepth24Stencil8 = 0x88F0;
-const uint32_t kGlDepth32f = 0x8CAC;
-const uint32_t kGlDepth32fStencil8 = 0x8CAD;
-
-constexpr uint32_t kFwkFormatGlCompat = 0;
-constexpr uint32_t kFwkFormatYV12 = 1;
-// constexpr uint32_t kFwkFormatYUV420888 = 2;
-constexpr uint32_t kFwkFormatNV12 = 3;
-constexpr uint32_t kFwkFormatP010 = 4;
-
-static inline bool virgl_format_is_yuv(uint32_t format) {
-    switch (format) {
-        case VIRGL_FORMAT_B8G8R8X8_UNORM:
-        case VIRGL_FORMAT_B5G6R5_UNORM:
-        case VIRGL_FORMAT_B8G8R8A8_UNORM:
-        case VIRGL_FORMAT_R10G10B10A2_UNORM:
-        case VIRGL_FORMAT_R16_UNORM:
-        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
-        case VIRGL_FORMAT_R8_UNORM:
-        case VIRGL_FORMAT_R8G8_UNORM:
-        case VIRGL_FORMAT_R8G8B8_UNORM:
-        case VIRGL_FORMAT_R8G8B8A8_UNORM:
-        case VIRGL_FORMAT_R8G8B8X8_UNORM:
-        case VIRGL_FORMAT_Z16_UNORM:
-        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
-        case VIRGL_FORMAT_Z24X8_UNORM:
-        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
-        case VIRGL_FORMAT_Z32_FLOAT:
-            return false;
-        case VIRGL_FORMAT_NV12:
-        case VIRGL_FORMAT_P010:
-        case VIRGL_FORMAT_YV12:
-            return true;
-        default:
-            stream_renderer_error("Unknown virgl format 0x%x", format);
-            return false;
-    }
-}
-
-static inline uint32_t virgl_format_to_gl(uint32_t virgl_format) {
-    switch (virgl_format) {
-        case VIRGL_FORMAT_B8G8R8X8_UNORM:
-        case VIRGL_FORMAT_B8G8R8A8_UNORM:
-            return kGlBgra;
-        case VIRGL_FORMAT_R8G8B8X8_UNORM:
-        case VIRGL_FORMAT_R8G8B8A8_UNORM:
-            return kGlRgba;
-        case VIRGL_FORMAT_B5G6R5_UNORM:
-            return kGlRgb565;
-        case VIRGL_FORMAT_R16_UNORM:
-            return kGlR16;
-        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
-            return kGlRgba16f;
-        case VIRGL_FORMAT_R8_UNORM:
-            return kGlR8;
-        case VIRGL_FORMAT_R8G8_UNORM:
-            return kGlRg8;
-        case VIRGL_FORMAT_R8G8B8_UNORM:
-            return kGlRgb8;
-        case VIRGL_FORMAT_NV12:
-        case VIRGL_FORMAT_P010:
-        case VIRGL_FORMAT_YV12:
-            // emulated as RGBA8888
-            return kGlRgba;
-        case VIRGL_FORMAT_R10G10B10A2_UNORM:
-            return kGlRgba1010102;
-        case VIRGL_FORMAT_Z16_UNORM:
-            return kGlDepth16;
-        case VIRGL_FORMAT_Z24X8_UNORM:
-            return kGlDepth24;
-        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
-            return kGlDepth24Stencil8;
-        case VIRGL_FORMAT_Z32_FLOAT:
-            return kGlDepth32f;
-        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
-            return kGlDepth32fStencil8;
-        default:
-            return kGlRgba;
-    }
-}
-
-static inline uint32_t virgl_format_to_fwk_format(uint32_t virgl_format) {
-    switch (virgl_format) {
-        case VIRGL_FORMAT_NV12:
-            return kFwkFormatNV12;
-        case VIRGL_FORMAT_P010:
-            return kFwkFormatP010;
-        case VIRGL_FORMAT_YV12:
-            return kFwkFormatYV12;
-        case VIRGL_FORMAT_R8_UNORM:
-        case VIRGL_FORMAT_R16_UNORM:
-        case VIRGL_FORMAT_R16G16B16A16_FLOAT:
-        case VIRGL_FORMAT_R8G8_UNORM:
-        case VIRGL_FORMAT_R8G8B8_UNORM:
-        case VIRGL_FORMAT_B8G8R8X8_UNORM:
-        case VIRGL_FORMAT_B8G8R8A8_UNORM:
-        case VIRGL_FORMAT_R8G8B8X8_UNORM:
-        case VIRGL_FORMAT_R8G8B8A8_UNORM:
-        case VIRGL_FORMAT_B5G6R5_UNORM:
-        case VIRGL_FORMAT_R10G10B10A2_UNORM:
-        case VIRGL_FORMAT_Z16_UNORM:
-        case VIRGL_FORMAT_Z24X8_UNORM:
-        case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
-        case VIRGL_FORMAT_Z32_FLOAT:
-        case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
-        default:  // kFwkFormatGlCompat: No extra conversions needed
-            return kFwkFormatGlCompat;
-    }
-}
-
-static inline uint32_t gl_format_to_natural_type(uint32_t format) {
-    switch (format) {
-        case kGlBgra:
-        case kGlRgba:
-        case kGlLuminance:
-        case kGlLuminanceAlpha:
-            return kGlUnsignedByte;
-        case kGlRgb565:
-            return kGlUnsignedShort565;
-        case kGlDepth16:
-            return kGlUnsignedShort;
-        default:
-            return kGlUnsignedByte;
-    }
-}
-
-#ifndef DRM_FORMAT_DEPTH16
-#define DRM_FORMAT_DEPTH16 fourcc_code('D', '1', '6', ' ')
-#define DRM_FORMAT_DEPTH24 fourcc_code('D', '2', '4', 'X')
-#define DRM_FORMAT_DEPTH24_STENCIL8 fourcc_code('D', '2', '4', 'S')
-#define DRM_FORMAT_DEPTH32 fourcc_code('D', '3', '2', 'F')
-#define DRM_FORMAT_DEPTH32_STENCIL8 fourcc_code('D', 'F', 'S', '8')
-#endif
-
-static uint32_t drm_format_to_virgl_format(uint32_t format) {
-    switch (format) {
-        case DRM_FORMAT_DEPTH16:
-            return VIRGL_FORMAT_Z16_UNORM;
-        case DRM_FORMAT_DEPTH24:
-            return VIRGL_FORMAT_Z24X8_UNORM;
-        case DRM_FORMAT_DEPTH24_STENCIL8:
-            return VIRGL_FORMAT_Z24_UNORM_S8_UINT;
-        case DRM_FORMAT_DEPTH32:
-            return VIRGL_FORMAT_Z32_FLOAT;
-        case DRM_FORMAT_DEPTH32_STENCIL8:
-            return VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT;
-        default:
-            stream_renderer_error("Unknown drm format for virgl conversion 0x%x", format);
-            return 0;
-    }
-}
-
-static void set_virgl_format_supported(uint32_t* mask, uint32_t virgl_format, bool supported) {
-    uint32_t index = virgl_format / 32;
-    uint32_t bit_offset = 1 << (virgl_format & 31);
-    if (supported) {
-        mask[index] |= bit_offset;
-    } else {
-        mask[index] &= ~bit_offset;
-    }
-}
-
-static void set_drm_format_supported(uint32_t* mask, uint32_t drm_format, bool supported) {
-    uint32_t virgl_format = drm_format_to_virgl_format(drm_format);
-    set_virgl_format_supported(mask, virgl_format, supported);
-}
-
-static bool is_drm_format_supported(uint32_t* mask, uint32_t drm_format) {
-    uint32_t virgl_format = drm_format_to_virgl_format(drm_format);
-    uint32_t index = virgl_format / 32;
-    uint32_t bit_offset = 1 << (virgl_format & 31);
-    return (mask[index] & bit_offset) ? true : false;
-}
-
-static inline size_t virgl_format_to_linear_base(uint32_t format, uint32_t totalWidth,
-                                                 uint32_t totalHeight, uint32_t x, uint32_t y,
-                                                 uint32_t w, uint32_t h) {
-    if (virgl_format_is_yuv(format)) {
-        return 0;
-    } else {
-        uint32_t bpp = 4;
-        switch (format) {
-            case VIRGL_FORMAT_R16G16B16A16_FLOAT:
-            case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
-                bpp = 8;
-                break;
-            case VIRGL_FORMAT_B8G8R8X8_UNORM:
-            case VIRGL_FORMAT_B8G8R8A8_UNORM:
-            case VIRGL_FORMAT_R8G8B8X8_UNORM:
-            case VIRGL_FORMAT_R8G8B8A8_UNORM:
-            case VIRGL_FORMAT_R10G10B10A2_UNORM:
-            case VIRGL_FORMAT_Z24X8_UNORM:
-            case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
-            case VIRGL_FORMAT_Z32_FLOAT:
-                bpp = 4;
-                break;
-            case VIRGL_FORMAT_R8G8B8_UNORM:
-                bpp = 3;
-                break;
-            case VIRGL_FORMAT_B5G6R5_UNORM:
-            case VIRGL_FORMAT_R8G8_UNORM:
-            case VIRGL_FORMAT_R16_UNORM:
-            case VIRGL_FORMAT_Z16_UNORM:
-                bpp = 2;
-                break;
-            case VIRGL_FORMAT_R8_UNORM:
-                bpp = 1;
-                break;
-            default:
-                stream_renderer_error("Unknown virgl format: 0x%x", format);
-                return 0;
-        }
-
-        uint32_t stride = totalWidth * bpp;
-        return y * stride + x * bpp;
-    }
-    return 0;
-}
-
-static inline size_t virgl_format_to_total_xfer_len(uint32_t format, uint32_t totalWidth,
-                                                    uint32_t totalHeight, uint32_t x, uint32_t y,
-                                                    uint32_t w, uint32_t h) {
-    if (virgl_format_is_yuv(format)) {
-        uint32_t bpp = format == VIRGL_FORMAT_P010 ? 2 : 1;
-
-        uint32_t yWidth = totalWidth;
-        uint32_t yHeight = totalHeight;
-        uint32_t yStridePixels;
-        if (format == VIRGL_FORMAT_NV12) {
-            yStridePixels = yWidth;
-        } else if (format == VIRGL_FORMAT_P010) {
-            yStridePixels = yWidth;
-        } else if (format == VIRGL_FORMAT_YV12) {
-            yStridePixels = align_up_power_of_2(yWidth, 32);
-        } else {
-            stream_renderer_error("Unknown virgl format: 0x%x", format);
-            return 0;
-        }
-        uint32_t yStrideBytes = yStridePixels * bpp;
-        uint32_t ySize = yStrideBytes * yHeight;
-
-        uint32_t uvStridePixels;
-        uint32_t uvPlaneCount;
-        if (format == VIRGL_FORMAT_NV12) {
-            uvStridePixels = yStridePixels;
-            uvPlaneCount = 1;
-        } else if (format == VIRGL_FORMAT_P010) {
-            uvStridePixels = yStridePixels;
-            uvPlaneCount = 1;
-        } else if (format == VIRGL_FORMAT_YV12) {
-            uvStridePixels = yStridePixels / 2;
-            uvPlaneCount = 2;
-        } else {
-            stream_renderer_error("Unknown virgl yuv format: 0x%x", format);
-            return 0;
-        }
-        uint32_t uvStrideBytes = uvStridePixels * bpp;
-        uint32_t uvHeight = totalHeight / 2;
-        uint32_t uvSize = uvStrideBytes * uvHeight * uvPlaneCount;
-
-        uint32_t dataSize = ySize + uvSize;
-        return dataSize;
-    } else {
-        uint32_t bpp = 4;
-        switch (format) {
-            case VIRGL_FORMAT_R16G16B16A16_FLOAT:
-            case VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT:
-                bpp = 8;
-                break;
-            case VIRGL_FORMAT_B8G8R8X8_UNORM:
-            case VIRGL_FORMAT_B8G8R8A8_UNORM:
-            case VIRGL_FORMAT_R8G8B8X8_UNORM:
-            case VIRGL_FORMAT_R8G8B8A8_UNORM:
-            case VIRGL_FORMAT_R10G10B10A2_UNORM:
-            case VIRGL_FORMAT_Z24X8_UNORM:
-            case VIRGL_FORMAT_Z24_UNORM_S8_UINT:
-            case VIRGL_FORMAT_Z32_FLOAT:
-                bpp = 4;
-                break;
-            case VIRGL_FORMAT_R8G8B8_UNORM:
-                bpp = 3;
-                break;
-            case VIRGL_FORMAT_B5G6R5_UNORM:
-            case VIRGL_FORMAT_R16_UNORM:
-            case VIRGL_FORMAT_R8G8_UNORM:
-            case VIRGL_FORMAT_Z16_UNORM:
-                bpp = 2;
-                break;
-            case VIRGL_FORMAT_R8_UNORM:
-                bpp = 1;
-                break;
-            default:
-                stream_renderer_error("Unknown virgl format: 0x%x", format);
-                return 0;
-        }
-
-        uint32_t stride = totalWidth * bpp;
-        return (h - 1U) * stride + w * bpp;
-    }
-    return 0;
-}
-
-enum IovSyncDir {
-    IOV_TO_LINEAR = 0,
-    LINEAR_TO_IOV = 1,
-};
-
-static int sync_iov(PipeResEntry* res, uint64_t offset, const stream_renderer_box* box,
-                    IovSyncDir dir) {
-    stream_renderer_debug("offset: 0x%llx box: %u %u %u %u size %u x %u iovs %u linearSize %zu",
-                          (unsigned long long)offset, box->x, box->y, box->w, box->h,
-                          res->args.width, res->args.height, res->numIovs, res->linearSize);
-
-    if (box->x > res->args.width || box->y > res->args.height) {
-        stream_renderer_error("Box out of range of resource");
-        return -EINVAL;
-    }
-    if (box->w == 0U || box->h == 0U) {
-        stream_renderer_error("Empty transfer");
-        return -EINVAL;
-    }
-    if (box->x + box->w > res->args.width) {
-        stream_renderer_error("Box overflows resource width");
-        return -EINVAL;
-    }
-
-    size_t linearBase = virgl_format_to_linear_base(
-        res->args.format, res->args.width, res->args.height, box->x, box->y, box->w, box->h);
-    size_t start = linearBase;
-    // height - 1 in order to treat the (w * bpp) row specially
-    // (i.e., the last row does not occupy the full stride)
-    size_t length = virgl_format_to_total_xfer_len(
-        res->args.format, res->args.width, res->args.height, box->x, box->y, box->w, box->h);
-    size_t end = start + length;
-
-    if (start == end) {
-        stream_renderer_error("nothing to transfer");
-        return -EINVAL;
-    }
-
-    if (end > res->linearSize) {
-        stream_renderer_error("start + length overflows!");
-        return -EINVAL;
-    }
-
-    uint32_t iovIndex = 0;
-    size_t iovOffset = 0;
-    size_t written = 0;
-    char* linear = static_cast<char*>(res->linear);
-
-    while (written < length) {
-        if (iovIndex >= res->numIovs) {
-            stream_renderer_error("write request overflowed numIovs");
-            return -EINVAL;
-        }
-
-        const char* iovBase_const = static_cast<const char*>(res->iov[iovIndex].iov_base);
-        char* iovBase = static_cast<char*>(res->iov[iovIndex].iov_base);
-        size_t iovLen = res->iov[iovIndex].iov_len;
-        size_t iovOffsetEnd = iovOffset + iovLen;
-
-        auto lower_intersect = std::max(iovOffset, start);
-        auto upper_intersect = std::min(iovOffsetEnd, end);
-        if (lower_intersect < upper_intersect) {
-            size_t toWrite = upper_intersect - lower_intersect;
-            switch (dir) {
-                case IOV_TO_LINEAR:
-                    memcpy(linear + lower_intersect, iovBase_const + lower_intersect - iovOffset,
-                           toWrite);
-                    break;
-                case LINEAR_TO_IOV:
-                    memcpy(iovBase + lower_intersect - iovOffset, linear + lower_intersect,
-                           toWrite);
-                    break;
-                default:
-                    stream_renderer_error("Invalid synchronization dir");
-                    return -EINVAL;
-            }
-            written += toWrite;
-        }
-        ++iovIndex;
-        iovOffset += iovLen;
-    }
-
-    return 0;
-}
-
-static uint64_t convert32to64(uint32_t lo, uint32_t hi) {
-    return ((uint64_t)lo) | (((uint64_t)hi) << 32);
-}
-
-class CleanupThread {
-  public:
-    using GenericCleanup = std::function<void()>;
-
-    CleanupThread() : mWorker([](CleanupTask task) {
-            return std::visit([](auto&& work) {
-                using T = std::decay_t<decltype(work)>;
-                if constexpr (std::is_same_v<T, GenericCleanup>) {
-                    work();
-                    return android::base::WorkerProcessingResult::Continue;
-                } else if constexpr (std::is_same_v<T, Exit>) {
-                    return android::base::WorkerProcessingResult::Stop;
-                }
-            }, std::move(task));
-          }) {
-        mWorker.start();
-    }
-
-    ~CleanupThread() { stop(); }
-
-    // CleanupThread is neither copyable nor movable.
-    CleanupThread(const CleanupThread& other) = delete;
-    CleanupThread& operator=(const CleanupThread& other) = delete;
-    CleanupThread(CleanupThread&& other) = delete;
-    CleanupThread& operator=(CleanupThread&& other) = delete;
-
-    void enqueueCleanup(GenericCleanup command) { mWorker.enqueue(std::move(command)); }
-
-    void stop() {
-        mWorker.enqueue(Exit{});
-        mWorker.join();
-    }
-
-  private:
-    struct Exit {};
-    using CleanupTask = std::variant<GenericCleanup, Exit>;
-    android::base::WorkerThread<CleanupTask> mWorker;
-};
-
-class PipeVirglRenderer {
-   public:
-    PipeVirglRenderer() = default;
-
-    int init(void* cookie, gfxstream::host::FeatureSet features,
-             stream_renderer_fence_callback fence_callback) {
-        stream_renderer_debug("cookie: %p", cookie);
-        mCookie = cookie;
-        mFeatures = features;
-        mFenceCallback = fence_callback;
-        mAddressSpaceDeviceControlOps = get_address_space_device_control_ops();
-        if (!mAddressSpaceDeviceControlOps) {
-            stream_renderer_error("Could not get address space device control ops!");
-            return -EINVAL;
-        }
-        mVirtioGpuTimelines = VirtioGpuTimelines::create(true);
-        mVirtioGpuTimelines = VirtioGpuTimelines::create(true);
-
-#if !defined(_WIN32)
-        mPageSize = getpagesize();
-#endif
-
-        mCleanupThread.reset(new CleanupThread());
-
-        return 0;
-    }
-
-    void teardown() { mCleanupThread.reset(); }
-
-    int resetPipe(GoldfishHwPipe* hwPipe, GoldfishHostPipe* hostPipe) {
-        stream_renderer_debug("Want to reset hwpipe %p to hostpipe %p", hwPipe, hostPipe);
-        VirtioGpuCtxId asCtxId = (VirtioGpuCtxId)(uintptr_t)hwPipe;
-        auto it = mContexts.find(asCtxId);
-        if (it == mContexts.end()) {
-            stream_renderer_error("fatal: pipe id %u", asCtxId);
-            return -EINVAL;
-        }
-
-        auto& entry = it->second;
-        stream_renderer_debug("ctxid: %u prev hostpipe: %p", asCtxId, entry.hostPipe);
-        entry.hostPipe = hostPipe;
-        stream_renderer_debug("ctxid: %u next hostpipe: %p", asCtxId, entry.hostPipe);
-
-        // Also update any resources associated with it
-        auto resourcesIt = mContextResources.find(asCtxId);
-
-        if (resourcesIt == mContextResources.end()) {
-            return 0;
-        }
-
-        const auto& resIds = resourcesIt->second;
-
-        for (auto resId : resIds) {
-            auto resEntryIt = mResources.find(resId);
-            if (resEntryIt == mResources.end()) {
-                stream_renderer_error("entry with res id %u not found", resId);
-                return -EINVAL;
-            }
-
-            auto& resEntry = resEntryIt->second;
-            resEntry.hostPipe = hostPipe;
-        }
-
-        return 0;
-    }
-
-    int createContext(VirtioGpuCtxId ctx_id, uint32_t nlen, const char* name,
-                      uint32_t context_init) {
-        std::string contextName(name, nlen);
-
-        stream_renderer_debug("ctxid: %u len: %u name: %s", ctx_id, nlen, contextName.c_str());
-        auto ops = ensureAndGetServiceOps();
-        auto hostPipe = ops->guest_open_with_flags(reinterpret_cast<GoldfishHwPipe*>(ctx_id),
-                                                   0x1 /* is virtio */);
-
-        if (!hostPipe) {
-            stream_renderer_error("failed to create hw pipe!");
-            return -EINVAL;
-        }
-        std::unordered_map<uint32_t, uint32_t> map;
-        std::unordered_map<uint32_t, struct stream_renderer_resource_create_args> blobMap;
-
-        PipeCtxEntry res = {
-            std::move(contextName),  // contextName
-            context_init,            // capsetId
-            ctx_id,                  // ctxId
-            hostPipe,                // hostPipe
-            0,                       // fence
-            0,                       // AS handle
-            false,                   // does not have an AS handle
-            map,                     // resourceId --> ASG handle map
-            blobMap,                 // blobId -> resource create args
-        };
-
-        stream_renderer_debug("initial host pipe for ctxid %u: %p", ctx_id, hostPipe);
-        mContexts[ctx_id] = res;
-        android_onGuestGraphicsProcessCreate(ctx_id);
-        return 0;
-    }
-
-    int destroyContext(VirtioGpuCtxId handle) {
-        stream_renderer_debug("ctxid: %u", handle);
-
-        auto it = mContexts.find(handle);
-        if (it == mContexts.end()) {
-            stream_renderer_error("could not find context handle %u", handle);
-            return -EINVAL;
-        }
-
-        if (it->second.hasAddressSpaceHandle) {
-            for (auto const& [resourceId, handle] : it->second.addressSpaceHandles) {
-                // Note: this can hang as is but this has only been observed to
-                // happen during shutdown. See b/329287602#comment8.
-                mAddressSpaceDeviceControlOps->destroy_handle(handle);
-            }
-        }
-
-        auto hostPipe = it->second.hostPipe;
-        if (!hostPipe) {
-            stream_renderer_error("0 is not a valid hostpipe");
-            return -EINVAL;
-        }
-
-        auto ops = ensureAndGetServiceOps();
-        ops->guest_close(hostPipe, GOLDFISH_PIPE_CLOSE_GRACEFUL);
-
-        android_cleanupProcGLObjects(handle);
-        mContexts.erase(it);
-        return 0;
-    }
-
-    int setContextAddressSpaceHandleLocked(VirtioGpuCtxId ctxId, uint32_t handle,
-                                           uint32_t resourceId) {
-        auto ctxIt = mContexts.find(ctxId);
-        if (ctxIt == mContexts.end()) {
-            stream_renderer_error("ctx id %u is not found", ctxId);
-            return -EINVAL;
-        }
-
-        auto& ctxEntry = ctxIt->second;
-        ctxEntry.addressSpaceHandle = handle;
-        ctxEntry.hasAddressSpaceHandle = true;
-        ctxEntry.addressSpaceHandles[resourceId] = handle;
-        return 0;
-    }
-
-    uint32_t getAddressSpaceHandleLocked(VirtioGpuCtxId ctxId, uint32_t resourceId) {
-        auto ctxIt = mContexts.find(ctxId);
-        if (ctxIt == mContexts.end()) {
-            stream_renderer_error("ctx id %u is not found", ctxId);
-            return -EINVAL;
-        }
-
-        auto& ctxEntry = ctxIt->second;
-
-        if (!ctxEntry.addressSpaceHandles.count(resourceId)) {
-            stream_renderer_error("ASG context with resource id %u", resourceId);
-            return -EINVAL;
-        }
-
-        return ctxEntry.addressSpaceHandles[resourceId];
-    }
-
-#define DECODE(variable, type, input) \
-    type variable = {};               \
-    memcpy(&variable, input, sizeof(type));
-
-    int addressSpaceProcessCmd(VirtioGpuCtxId ctxId, uint32_t* dwords) {
-        DECODE(header, gfxstream::gfxstreamHeader, dwords)
-
-        switch (header.opCode) {
-            case GFXSTREAM_CONTEXT_CREATE: {
-                DECODE(contextCreate, gfxstream::gfxstreamContextCreate, dwords)
-
-                auto resEntryIt = mResources.find(contextCreate.resourceId);
-                if (resEntryIt == mResources.end()) {
-                    stream_renderer_error("ASG coherent resource %u not found",
-                                          contextCreate.resourceId);
-                    return -EINVAL;
-                }
-
-                auto ctxIt = mContexts.find(ctxId);
-                if (ctxIt == mContexts.end()) {
-                    stream_renderer_error("ctx id %u not found", ctxId);
-                    return -EINVAL;
-                }
-
-                auto& ctxEntry = ctxIt->second;
-                auto& resEntry = resEntryIt->second;
-
-                std::string name = ctxEntry.name + "-" + std::to_string(contextCreate.resourceId);
-
-                // Note: resource ids can not be used as ASG handles because ASGs may outlive the
-                // containing resource due asynchronous ASG destruction.
-                uint32_t handle = mAddressSpaceDeviceControlOps->gen_handle();
-
-                struct AddressSpaceCreateInfo createInfo = {
-                    .handle = handle,
-                    .type = android::emulation::VirtioGpuGraphics,
-                    .createRenderThread = true,
-                    .externalAddr = resEntry.hva,
-                    .externalAddrSize = resEntry.hvaSize,
-                    .virtioGpuContextId = ctxId,
-                    .virtioGpuCapsetId = ctxEntry.capsetId,
-                    .contextName = name.c_str(),
-                    .contextNameSize = static_cast<uint32_t>(ctxEntry.name.size()),
-                };
-
-                mAddressSpaceDeviceControlOps->create_instance(createInfo);
-                if (setContextAddressSpaceHandleLocked(ctxId, handle, contextCreate.resourceId)) {
-                    return -EINVAL;
-                }
-                break;
-            }
-            case GFXSTREAM_CONTEXT_PING: {
-                DECODE(contextPing, gfxstream::gfxstreamContextPing, dwords)
-
-                struct android::emulation::AddressSpaceDevicePingInfo ping = {0};
-                ping.metadata = ASG_NOTIFY_AVAILABLE;
-
-                mAddressSpaceDeviceControlOps->ping_at_hva(
-                    getAddressSpaceHandleLocked(ctxId, contextPing.resourceId), &ping);
-                break;
-            }
-            default:
-                break;
-        }
-
-        return 0;
-    }
-
-    int submitCmd(struct stream_renderer_command* cmd) {
-        if (!cmd) return -EINVAL;
-
-        void* buffer = reinterpret_cast<void*>(cmd->cmd);
-
-        VirtioGpuRing ring = VirtioGpuRingGlobal{};
-        stream_renderer_debug("ctx: % u, ring: %s buffer: %p dwords: %d", cmd->ctx_id,
-                              to_string(ring).c_str(), buffer, cmd->cmd_size);
-
-        if (!buffer) {
-            stream_renderer_error("error: buffer null");
-            return -EINVAL;
-        }
-
-        if (cmd->cmd_size < 4) {
-            stream_renderer_error("error: not enough bytes (got %d)", cmd->cmd_size);
-            return -EINVAL;
-        }
-
-        DECODE(header, gfxstream::gfxstreamHeader, buffer);
-        switch (header.opCode) {
-            case GFXSTREAM_CONTEXT_CREATE:
-            case GFXSTREAM_CONTEXT_PING:
-            case GFXSTREAM_CONTEXT_PING_WITH_RESPONSE: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_CONTEXT_[CREATE|PING]");
-
-                if (addressSpaceProcessCmd(cmd->ctx_id, (uint32_t*)buffer)) {
-                    return -EINVAL;
-                }
-                break;
-            }
-            case GFXSTREAM_CREATE_EXPORT_SYNC: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_CREATE_EXPORT_SYNC");
-
-                DECODE(exportSync, gfxstream::gfxstreamCreateExportSync, buffer)
-
-                uint64_t sync_handle =
-                    convert32to64(exportSync.syncHandleLo, exportSync.syncHandleHi);
-
-                stream_renderer_debug("wait for gpu ring %s", to_string(ring).c_str());
-                auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
-#if GFXSTREAM_ENABLE_HOST_GLES
-                gfxstream::FrameBuffer::getFB()->asyncWaitForGpuWithCb(sync_handle, [this, taskId] {
-                    mVirtioGpuTimelines->notifyTaskCompletion(taskId);
-                });
-#endif
-                break;
-            }
-            case GFXSTREAM_CREATE_EXPORT_SYNC_VK:
-            case GFXSTREAM_CREATE_IMPORT_SYNC_VK: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_CREATE_[IMPORT|EXPORT]_SYNC_VK");
-
-                // The guest sync export assumes fence context support and always uses
-                // VIRTGPU_EXECBUF_RING_IDX. With this, the task created here must use
-                // the same ring as the fence created for the virtio gpu command or the
-                // fence may be signaled without properly waiting for the task to complete.
-                ring = VirtioGpuRingContextSpecific{
-                    .mCtxId = cmd->ctx_id,
-                    .mRingIdx = 0,
-                };
-
-                DECODE(exportSyncVK, gfxstream::gfxstreamCreateExportSyncVK, buffer)
-
-                uint64_t device_handle =
-                    convert32to64(exportSyncVK.deviceHandleLo, exportSyncVK.deviceHandleHi);
-
-                uint64_t fence_handle =
-                    convert32to64(exportSyncVK.fenceHandleLo, exportSyncVK.fenceHandleHi);
-
-                stream_renderer_debug("wait for gpu ring %s", to_string(ring).c_str());
-                auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
-                gfxstream::FrameBuffer::getFB()->asyncWaitForGpuVulkanWithCb(
-                    device_handle, fence_handle,
-                    [this, taskId] { mVirtioGpuTimelines->notifyTaskCompletion(taskId); });
-                break;
-            }
-            case GFXSTREAM_CREATE_QSRI_EXPORT_VK: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_CREATE_QSRI_EXPORT_VK");
-
-                // The guest QSRI export assumes fence context support and always uses
-                // VIRTGPU_EXECBUF_RING_IDX. With this, the task created here must use
-                // the same ring as the fence created for the virtio gpu command or the
-                // fence may be signaled without properly waiting for the task to complete.
-                ring = VirtioGpuRingContextSpecific{
-                    .mCtxId = cmd->ctx_id,
-                    .mRingIdx = 0,
-                };
-
-                DECODE(exportQSRI, gfxstream::gfxstreamCreateQSRIExportVK, buffer)
-
-                uint64_t image_handle =
-                    convert32to64(exportQSRI.imageHandleLo, exportQSRI.imageHandleHi);
-
-                stream_renderer_debug("wait for gpu vk qsri ring %u image 0x%llx",
-                                      to_string(ring).c_str(), (unsigned long long)image_handle);
-                auto taskId = mVirtioGpuTimelines->enqueueTask(ring);
-                gfxstream::FrameBuffer::getFB()->asyncWaitForGpuVulkanQsriWithCb(
-                    image_handle,
-                    [this, taskId] { mVirtioGpuTimelines->notifyTaskCompletion(taskId); });
-                break;
-            }
-            case GFXSTREAM_RESOURCE_CREATE_3D: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_RESOURCE_CREATE_3D");
-
-                DECODE(create3d, gfxstream::gfxstreamResourceCreate3d, buffer)
-                struct stream_renderer_resource_create_args rc3d = {0};
-
-                rc3d.target = create3d.target;
-                rc3d.format = create3d.format;
-                rc3d.bind = create3d.bind;
-                rc3d.width = create3d.width;
-                rc3d.height = create3d.height;
-                rc3d.depth = create3d.depth;
-                rc3d.array_size = create3d.arraySize;
-                rc3d.last_level = create3d.lastLevel;
-                rc3d.nr_samples = create3d.nrSamples;
-                rc3d.flags = create3d.flags;
-
-                auto ctxIt = mContexts.find(cmd->ctx_id);
-                if (ctxIt == mContexts.end()) {
-                    stream_renderer_error("ctx id %u is not found", cmd->ctx_id);
-                    return -EINVAL;
-                }
-
-                auto& ctxEntry = ctxIt->second;
-                if (ctxEntry.blobMap.count(create3d.blobId)) {
-                    stream_renderer_error("blob ID already in use");
-                    return -EINVAL;
-                }
-
-                ctxEntry.blobMap[create3d.blobId] = rc3d;
-                break;
-            }
-            case GFXSTREAM_ACQUIRE_SYNC: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_ACQUIRE_SYNC");
-
-                DECODE(acquireSync, gfxstream::gfxstreamAcquireSync, buffer);
-
-                auto ctxIt = mContexts.find(cmd->ctx_id);
-                if (ctxIt == mContexts.end()) {
-                    stream_renderer_error("ctx id %u is not found", cmd->ctx_id);
-                    return -EINVAL;
-                }
-
-                auto& ctxEntry = ctxIt->second;
-                if (ctxEntry.latestFence) {
-                    stream_renderer_error("expected latest fence to empty");
-                    return -EINVAL;
-                }
-
-                auto syncDescriptorInfoOpt = ExternalObjectManager::get()->removeSyncDescriptorInfo(
-                    cmd->ctx_id, acquireSync.syncId);
-                if (syncDescriptorInfoOpt) {
-                    ctxEntry.latestFence = std::make_shared<gfxstream::SyncDescriptorInfo>(
-                        std::move(*syncDescriptorInfoOpt));
-                } else {
-                    stream_renderer_error("failed to get sync descriptor info");
-                    return -EINVAL;
-                }
-
-                break;
-            }
-            case GFXSTREAM_PLACEHOLDER_COMMAND_VK: {
-                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                                      "GFXSTREAM_PLACEHOLDER_COMMAND_VK");
-
-                // Do nothing, this is a placeholder command
-                break;
-            }
-            default:
-                return -EINVAL;
-        }
-
-        return 0;
-    }
-
-    int createFence(uint64_t fence_id, const VirtioGpuRing& ring) {
-        stream_renderer_debug("fenceid: %llu ring: %s", (unsigned long long)fence_id,
-                              to_string(ring).c_str());
-
-        struct {
-            FenceCompletionCallback operator()(const VirtioGpuRingGlobal&) {
-                return [renderer = mRenderer, fenceId = mFenceId] {
-                    struct stream_renderer_fence fence = {0};
-                    fence.fence_id = fenceId;
-                    fence.flags = STREAM_RENDERER_FLAG_FENCE;
-                    renderer->mFenceCallback(renderer->mCookie, &fence);
-                };
-            }
-            FenceCompletionCallback operator()(const VirtioGpuRingContextSpecific& ring) {
-                return [renderer = mRenderer, fenceId = mFenceId, ring] {
-                    struct stream_renderer_fence fence = {0};
-                    fence.fence_id = fenceId;
-                    fence.flags = STREAM_RENDERER_FLAG_FENCE | STREAM_RENDERER_FLAG_FENCE_RING_IDX;
-                    fence.ctx_id = ring.mCtxId;
-                    fence.ring_idx = ring.mRingIdx;
-                    renderer->mFenceCallback(renderer->mCookie, &fence);
-                };
-            }
-
-            PipeVirglRenderer* mRenderer;
-            VirtioGpuTimelines::FenceId mFenceId;
-        } visitor{
-            .mRenderer = this,
-            .mFenceId = fence_id,
-        };
-        FenceCompletionCallback callback = std::visit(visitor, ring);
-        if (!callback) {
-            return -EINVAL;
-        }
-        mVirtioGpuTimelines->enqueueFence(ring, fence_id, std::move(callback));
-
-        return 0;
-    }
-
-    int acquireContextFence(uint32_t ctx_id, uint64_t fenceId) {
-        auto ctxIt = mContexts.find(ctx_id);
-        if (ctxIt == mContexts.end()) {
-            stream_renderer_error("ctx id %u is not found", ctx_id);
-            return -EINVAL;
-        }
-
-        auto& ctxEntry = ctxIt->second;
-        if (ctxEntry.latestFence) {
-            mSyncMap[fenceId] = ctxEntry.latestFence;
-            ctxEntry.latestFence = nullptr;
-        } else {
-            stream_renderer_error("Failed to acquire sync descriptor");
-            return -EINVAL;
-        }
-
-        return 0;
-    }
-
-    void poll() { mVirtioGpuTimelines->poll(); }
-
-    enum pipe_texture_target {
-        PIPE_BUFFER,
-        PIPE_TEXTURE_1D,
-        PIPE_TEXTURE_2D,
-        PIPE_TEXTURE_3D,
-        PIPE_TEXTURE_CUBE,
-        PIPE_TEXTURE_RECT,
-        PIPE_TEXTURE_1D_ARRAY,
-        PIPE_TEXTURE_2D_ARRAY,
-        PIPE_TEXTURE_CUBE_ARRAY,
-        PIPE_MAX_TEXTURE_TYPES,
-    };
-
-    /**
-     *  * Resource binding flags -- state tracker must specify in advance all
-     *   * the ways a resource might be used.
-     *    */
-#define PIPE_BIND_DEPTH_STENCIL (1 << 0)   /* create_surface */
-#define PIPE_BIND_RENDER_TARGET (1 << 1)   /* create_surface */
-#define PIPE_BIND_BLENDABLE (1 << 2)       /* create_surface */
-#define PIPE_BIND_SAMPLER_VIEW (1 << 3)    /* create_sampler_view */
-#define PIPE_BIND_VERTEX_BUFFER (1 << 4)   /* set_vertex_buffers */
-#define PIPE_BIND_INDEX_BUFFER (1 << 5)    /* draw_elements */
-#define PIPE_BIND_CONSTANT_BUFFER (1 << 6) /* set_constant_buffer */
-#define PIPE_BIND_DISPLAY_TARGET (1 << 7)  /* flush_front_buffer */
-    /* gap */
-#define PIPE_BIND_STREAM_OUTPUT (1 << 10)       /* set_stream_output_buffers */
-#define PIPE_BIND_CURSOR (1 << 11)              /* mouse cursor */
-#define PIPE_BIND_CUSTOM (1 << 12)              /* state-tracker/winsys usages */
-#define PIPE_BIND_GLOBAL (1 << 13)              /* set_global_binding */
-#define PIPE_BIND_SHADER_BUFFER (1 << 14)       /* set_shader_buffers */
-#define PIPE_BIND_SHADER_IMAGE (1 << 15)        /* set_shader_images */
-#define PIPE_BIND_COMPUTE_RESOURCE (1 << 16)    /* set_compute_resources */
-#define PIPE_BIND_COMMAND_ARGS_BUFFER (1 << 17) /* pipe_draw_info.indirect */
-#define PIPE_BIND_QUERY_BUFFER (1 << 18)        /* get_query_result_resource */
-
-    ResType getResourceType(const struct stream_renderer_resource_create_args& args) const {
-        if (args.target == PIPE_BUFFER) {
-            return ResType::PIPE;
-        }
-
-        if (args.format != VIRGL_FORMAT_R8_UNORM) {
-            return ResType::COLOR_BUFFER;
-        }
-        if (args.bind & VIRGL_BIND_SAMPLER_VIEW) {
-            return ResType::COLOR_BUFFER;
-        }
-        if (args.bind & VIRGL_BIND_RENDER_TARGET) {
-            return ResType::COLOR_BUFFER;
-        }
-        if (args.bind & VIRGL_BIND_SCANOUT) {
-            return ResType::COLOR_BUFFER;
-        }
-        if (args.bind & VIRGL_BIND_CURSOR) {
-            return ResType::COLOR_BUFFER;
-        }
-        if (!(args.bind & VIRGL_BIND_LINEAR)) {
-            return ResType::COLOR_BUFFER;
-        }
-
-        return ResType::BUFFER;
-    }
-
-    void handleCreateResourceBuffer(struct stream_renderer_resource_create_args* args) {
-        stream_renderer_debug("w:%u h:%u handle:%u", args->handle, args->width, args->height);
-        gfxstream::FrameBuffer::getFB()->createBufferWithHandle(args->width * args->height,
-                                                                args->handle);
-    }
-
-    void handleCreateResourceColorBuffer(struct stream_renderer_resource_create_args* args) {
-        stream_renderer_debug("w h %u %u resid %u -> CreateColorBufferWithHandle", args->width,
-                              args->height, args->handle);
-
-        const uint32_t glformat = virgl_format_to_gl(args->format);
-        const uint32_t fwkformat = virgl_format_to_fwk_format(args->format);
-
-        const bool linear =
-#ifdef GFXSTREAM_ENABLE_GUEST_VIRTIO_RESOURCE_TILING_CONTROL
-            !!(args->bind & VIRGL_BIND_LINEAR);
-#else
-            false;
-#endif
-        gfxstream::FrameBuffer::getFB()->createColorBufferWithHandle(
-            args->width, args->height, glformat, (gfxstream::FrameworkFormat)fwkformat,
-            args->handle, linear);
-        gfxstream::FrameBuffer::getFB()->setGuestManagedColorBufferLifetime(
-            true /* guest manages lifetime */);
-        gfxstream::FrameBuffer::getFB()->openColorBuffer(args->handle);
-    }
-
-    int createResource(struct stream_renderer_resource_create_args* args, struct iovec* iov,
-                       uint32_t num_iovs) {
-        stream_renderer_debug("handle: %u. num iovs: %u", args->handle, num_iovs);
-
-        const auto resType = getResourceType(*args);
-        switch (resType) {
-            case ResType::BLOB:
-                return -EINVAL;
-            case ResType::PIPE:
-                break;
-            case ResType::BUFFER:
-                handleCreateResourceBuffer(args);
-                break;
-            case ResType::COLOR_BUFFER:
-                handleCreateResourceColorBuffer(args);
-                break;
-        }
-
-        PipeResEntry e;
-        e.args = *args;
-        e.linear = 0;
-        e.hostPipe = 0;
-        e.hva = nullptr;
-        e.hvaSize = 0;
-        e.blobId = 0;
-        e.blobMem = 0;
-        e.type = resType;
-        allocResource(e, iov, num_iovs);
-
-        mResources[args->handle] = e;
-        return 0;
-    }
-
-    void unrefResource(uint32_t toUnrefId) {
-        stream_renderer_debug("handle: %u", toUnrefId);
-
-        auto it = mResources.find(toUnrefId);
-        if (it == mResources.end()) return;
-
-        auto contextsIt = mResourceContexts.find(toUnrefId);
-        if (contextsIt != mResourceContexts.end()) {
-            mResourceContexts.erase(contextsIt->first);
-        }
-
-        for (auto& ctxIdResources : mContextResources) {
-            detachResourceLocked(ctxIdResources.first, toUnrefId);
-        }
-
-        auto& entry = it->second;
-        switch (entry.type) {
-            case ResType::BLOB:
-            case ResType::PIPE:
-                break;
-            case ResType::BUFFER:
-                gfxstream::FrameBuffer::getFB()->closeBuffer(toUnrefId);
-                break;
-            case ResType::COLOR_BUFFER:
-                gfxstream::FrameBuffer::getFB()->closeColorBuffer(toUnrefId);
-                break;
-        }
-
-        if (entry.linear) {
-            free(entry.linear);
-            entry.linear = nullptr;
-        }
-
-        if (entry.iov) {
-            free(entry.iov);
-            entry.iov = nullptr;
-            entry.numIovs = 0;
-        }
-
-        entry.hva = nullptr;
-        entry.hvaSize = 0;
-        entry.blobId = 0;
-
-        mResources.erase(it);
-    }
-
-    int attachIov(int resId, iovec* iov, int num_iovs) {
-        stream_renderer_debug("resid: %d numiovs: %d", resId, num_iovs);
-
-        auto it = mResources.find(resId);
-        if (it == mResources.end()) return ENOENT;
-
-        auto& entry = it->second;
-        stream_renderer_debug("res linear: %p", entry.linear);
-        if (!entry.linear) allocResource(entry, iov, num_iovs);
-
-        stream_renderer_debug("done");
-        return 0;
-    }
-
-    void detachIov(int resId, iovec** iov, int* num_iovs) {
-        auto it = mResources.find(resId);
-        if (it == mResources.end()) return;
-
-        auto& entry = it->second;
-
-        if (num_iovs) {
-            *num_iovs = entry.numIovs;
-            stream_renderer_debug("resid: %d numIovs: %d", resId, *num_iovs);
-        } else {
-            stream_renderer_debug("resid: %d numIovs: 0", resId);
-        }
-
-        entry.numIovs = 0;
-
-        if (entry.iov) free(entry.iov);
-        entry.iov = nullptr;
-
-        if (iov) {
-            *iov = entry.iov;
-        }
-
-        allocResource(entry, entry.iov, entry.numIovs);
-        stream_renderer_debug("done");
-    }
-
-    int handleTransferReadPipe(PipeResEntry* res, uint64_t offset, stream_renderer_box* box) {
-        if (res->type != ResType::PIPE) {
-            stream_renderer_error("resid: %d not a PIPE resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        // Do the pipe service op here, if there is an associated hostpipe.
-        auto hostPipe = res->hostPipe;
-        if (!hostPipe) return -EINVAL;
-
-        auto ops = ensureAndGetServiceOps();
-
-        size_t readBytes = 0;
-        size_t wantedBytes = readBytes + (size_t)box->w;
-
-        while (readBytes < wantedBytes) {
-            GoldfishPipeBuffer buf = {
-                ((char*)res->linear) + box->x + readBytes,
-                wantedBytes - readBytes,
-            };
-            auto status = ops->guest_recv(hostPipe, &buf, 1);
-
-            if (status > 0) {
-                readBytes += status;
-            } else if (status == kPipeTryAgain) {
-                ops->wait_guest_recv(hostPipe);
-            } else {
-                return EIO;
-            }
-        }
-
-        return 0;
-    }
-
-    int handleTransferWritePipe(PipeResEntry* res, uint64_t offset, stream_renderer_box* box) {
-        if (res->type != ResType::PIPE) {
-            stream_renderer_error("resid: %d not a PIPE resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        // Do the pipe service op here, if there is an associated hostpipe.
-        auto hostPipe = res->hostPipe;
-        if (!hostPipe) {
-            stream_renderer_error("No hostPipe");
-            return -EINVAL;
-        }
-
-        stream_renderer_debug("resid: %d offset: 0x%llx hostpipe: %p", res->args.handle,
-                              (unsigned long long)offset, hostPipe);
-
-        auto ops = ensureAndGetServiceOps();
-
-        size_t writtenBytes = 0;
-        size_t wantedBytes = (size_t)box->w;
-
-        while (writtenBytes < wantedBytes) {
-            GoldfishPipeBuffer buf = {
-                ((char*)res->linear) + box->x + writtenBytes,
-                wantedBytes - writtenBytes,
-            };
-
-            // guest_send can now reallocate the pipe.
-            void* hostPipeBefore = hostPipe;
-            auto status = ops->guest_send(&hostPipe, &buf, 1);
-            if (hostPipe != hostPipeBefore) {
-                if (resetPipe((GoldfishHwPipe*)(uintptr_t)(res->ctxId), hostPipe)) {
-                    return -EINVAL;
-                }
-
-                auto it = mResources.find(res->args.handle);
-                res = &it->second;
-            }
-
-            if (status > 0) {
-                writtenBytes += status;
-            } else if (status == kPipeTryAgain) {
-                ops->wait_guest_send(hostPipe);
-            } else {
-                return EIO;
-            }
-        }
-
-        return 0;
-    }
-
-    int handleTransferReadBuffer(PipeResEntry* res, uint64_t offset, stream_renderer_box* box) {
-        if (res->type != ResType::BUFFER) {
-            stream_renderer_error("resid: %d not a BUFFER resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        gfxstream::FrameBuffer::getFB()->readBuffer(
-            res->args.handle, 0, res->args.width * res->args.height, res->linear);
-        return 0;
-    }
-
-    int handleTransferWriteBuffer(PipeResEntry* res, uint64_t offset, stream_renderer_box* box) {
-        if (res->type != ResType::BUFFER) {
-            stream_renderer_error("resid: %d not a BUFFER resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        gfxstream::FrameBuffer::getFB()->updateBuffer(
-            res->args.handle, 0, res->args.width * res->args.height, res->linear);
-        return 0;
-    }
-
-    int handleTransferReadColorBuffer(PipeResEntry* res, uint64_t offset,
-                                      stream_renderer_box* box) {
-        if (res->type != ResType::COLOR_BUFFER) {
-            stream_renderer_error("resid: %d not a COLOR_BUFFER resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        auto glformat = virgl_format_to_gl(res->args.format);
-        auto gltype = gl_format_to_natural_type(glformat);
-
-        // We always xfer the whole thing again from GL
-        // since it's fiddly to calc / copy-out subregions
-        if (virgl_format_is_yuv(res->args.format)) {
-            gfxstream::FrameBuffer::getFB()->readColorBufferYUV(res->args.handle, 0, 0,
-                                                                res->args.width, res->args.height,
-                                                                res->linear, res->linearSize);
-        } else {
-            gfxstream::FrameBuffer::getFB()->readColorBuffer(res->args.handle, 0, 0,
-                                                             res->args.width, res->args.height,
-                                                             glformat, gltype, res->linear);
-        }
-
-        return 0;
-    }
-
-    int handleTransferWriteColorBuffer(PipeResEntry* res, uint64_t offset,
-                                       stream_renderer_box* box) {
-        if (res->type != ResType::COLOR_BUFFER) {
-            stream_renderer_error("resid: %d not a COLOR_BUFFER resource", res->args.handle);
-            return -EINVAL;
-        }
-
-        auto glformat = virgl_format_to_gl(res->args.format);
-        auto gltype = gl_format_to_natural_type(glformat);
-
-        // We always xfer the whole thing again to GL
-        // since it's fiddly to calc / copy-out subregions
-        gfxstream::FrameBuffer::getFB()->updateColorBuffer(res->args.handle, 0, 0, res->args.width,
-                                                           res->args.height, glformat, gltype,
-                                                           res->linear);
-        return 0;
-    }
-
-    int transferReadIov(int resId, uint64_t offset, stream_renderer_box* box, struct iovec* iov,
-                        int iovec_cnt) {
-        auto it = mResources.find(resId);
-        if (it == mResources.end()) return EINVAL;
-
-        int ret = 0;
-
-        auto& entry = it->second;
-        switch (entry.type) {
-            case ResType::BLOB:
-                return -EINVAL;
-            case ResType::PIPE:
-                ret = handleTransferReadPipe(&entry, offset, box);
-                break;
-            case ResType::BUFFER:
-                ret = handleTransferReadBuffer(&entry, offset, box);
-                break;
-            case ResType::COLOR_BUFFER:
-                ret = handleTransferReadColorBuffer(&entry, offset, box);
-                break;
-        }
-
-        if (ret != 0) {
-            return ret;
-        }
-
-        if (iovec_cnt) {
-            PipeResEntry e = {
-                entry.args, iov, (uint32_t)iovec_cnt, entry.linear, entry.linearSize,
-            };
-            ret = sync_iov(&e, offset, box, LINEAR_TO_IOV);
-        } else {
-            ret = sync_iov(&entry, offset, box, LINEAR_TO_IOV);
-        }
-
-        return ret;
-    }
-
-    int transferWriteIov(int resId, uint64_t offset, stream_renderer_box* box, struct iovec* iov,
-                         int iovec_cnt) {
-        auto it = mResources.find(resId);
-        if (it == mResources.end()) return EINVAL;
-
-        auto& entry = it->second;
-
-        int ret = 0;
-        if (iovec_cnt) {
-            PipeResEntry e = {
-                entry.args, iov, (uint32_t)iovec_cnt, entry.linear, entry.linearSize,
-            };
-            ret = sync_iov(&e, offset, box, IOV_TO_LINEAR);
-        } else {
-            ret = sync_iov(&entry, offset, box, IOV_TO_LINEAR);
-        }
-
-        if (ret != 0) {
-            return ret;
-        }
-
-        switch (entry.type) {
-            case ResType::BLOB:
-                return -EINVAL;
-            case ResType::PIPE:
-                ret = handleTransferWritePipe(&entry, offset, box);
-                break;
-            case ResType::BUFFER:
-                ret = handleTransferWriteBuffer(&entry, offset, box);
-                break;
-            case ResType::COLOR_BUFFER:
-                ret = handleTransferWriteColorBuffer(&entry, offset, box);
-                break;
-        }
-
-        return ret;
-    }
-
-    void getCapset(uint32_t set, uint32_t* max_size) {
-        switch (set) {
-            case VIRTGPU_CAPSET_GFXSTREAM_VULKAN:
-                *max_size = sizeof(struct gfxstream::vulkanCapset);
-                break;
-            case VIRTGPU_CAPSET_GFXSTREAM_MAGMA:
-                *max_size = sizeof(struct gfxstream::magmaCapset);
-                break;
-            case VIRTGPU_CAPSET_GFXSTREAM_GLES:
-                *max_size = sizeof(struct gfxstream::glesCapset);
-                break;
-            case VIRTGPU_CAPSET_GFXSTREAM_COMPOSER:
-                *max_size = sizeof(struct gfxstream::composerCapset);
-                break;
-            default:
-                stream_renderer_error("Incorrect capability set specified (%u)", set);
-        }
-    }
-
-    void fillCaps(uint32_t set, void* caps) {
-        switch (set) {
-            case VIRTGPU_CAPSET_GFXSTREAM_VULKAN: {
-                struct gfxstream::vulkanCapset* capset =
-                    reinterpret_cast<struct gfxstream::vulkanCapset*>(caps);
-
-                memset(capset, 0, sizeof(*capset));
-
-                capset->protocolVersion = 1;
-                capset->ringSize = 12288;
-                capset->bufferSize = 1048576;
-
-                auto vk_emu = gfxstream::vk::getGlobalVkEmulation();
-                if (vk_emu && vk_emu->live && vk_emu->representativeColorBufferMemoryTypeInfo) {
-                    capset->colorBufferMemoryIndex =
-                        vk_emu->representativeColorBufferMemoryTypeInfo->guestMemoryTypeIndex;
-                }
-
-                capset->noRenderControlEnc = 1;
-                capset->blobAlignment = mPageSize;
-                if (vk_emu && vk_emu->live) {
-                    capset->deferredMapping = 1;
-                }
-
-#if GFXSTREAM_UNSTABLE_VULKAN_DMABUF_WINSYS
-                capset->alwaysBlob = 1;
-#endif
-
-#if GFXSTREAM_UNSTABLE_VULKAN_EXTERNAL_SYNC
-                capset->externalSync = 1;
-#endif
-
-                memset(capset->virglSupportedFormats, 0, sizeof(capset->virglSupportedFormats));
-
-                struct FormatWithName {
-                    uint32_t format;
-                    const char* name;
-                };
-#define MAKE_FORMAT_AND_NAME(x) \
-    { x, #x }
-                static const FormatWithName kPossibleFormats[] = {
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B5G6R5_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B8G8R8A8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_B8G8R8X8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_NV12),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_P010),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R10G10B10A2_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R16_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R16G16B16A16_FLOAT),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8A8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_R8G8B8X8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_YV12),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z16_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z24_UNORM_S8_UINT),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z24X8_UNORM),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z32_FLOAT_S8X24_UINT),
-                    MAKE_FORMAT_AND_NAME(VIRGL_FORMAT_Z32_FLOAT),
-                };
-#undef MAKE_FORMAT_AND_NAME
-
-                stream_renderer_info("Format support:");
-                for (std::size_t i = 0; i < std::size(kPossibleFormats); i++) {
-                    const FormatWithName& possibleFormat = kPossibleFormats[i];
-
-                    GLenum possibleFormatGl = virgl_format_to_gl(possibleFormat.format);
-                    const bool supported =  gfxstream::FrameBuffer::getFB()->isFormatSupported(possibleFormatGl);
-
-                    stream_renderer_info(" %s: %s", possibleFormat.name,
-                                         (supported ? "supported" : "unsupported"));
-                    set_virgl_format_supported(capset->virglSupportedFormats, possibleFormat.format,
-                                               supported);
-                }
-                break;
-            }
-            case VIRTGPU_CAPSET_GFXSTREAM_MAGMA: {
-                struct gfxstream::magmaCapset* capset =
-                    reinterpret_cast<struct gfxstream::magmaCapset*>(caps);
-
-                capset->protocolVersion = 1;
-                capset->ringSize = 12288;
-                capset->bufferSize = 1048576;
-                capset->blobAlignment = mPageSize;
-                break;
-            }
-            case VIRTGPU_CAPSET_GFXSTREAM_GLES: {
-                struct gfxstream::glesCapset* capset =
-                    reinterpret_cast<struct gfxstream::glesCapset*>(caps);
-
-                capset->protocolVersion = 1;
-                capset->ringSize = 12288;
-                capset->bufferSize = 1048576;
-                capset->blobAlignment = mPageSize;
-                break;
-            }
-            case VIRTGPU_CAPSET_GFXSTREAM_COMPOSER: {
-                struct gfxstream::composerCapset* capset =
-                    reinterpret_cast<struct gfxstream::composerCapset*>(caps);
-
-                capset->protocolVersion = 1;
-                capset->ringSize = 12288;
-                capset->bufferSize = 1048576;
-                capset->blobAlignment = mPageSize;
-                break;
-            }
-            default:
-                stream_renderer_error("Incorrect capability set specified");
-        }
-    }
-
-    void attachResource(uint32_t ctxId, uint32_t resId) {
-        stream_renderer_debug("ctxid: %u resid: %u", ctxId, resId);
-
-        auto resourcesIt = mContextResources.find(ctxId);
-
-        if (resourcesIt == mContextResources.end()) {
-            std::vector<VirtioGpuResId> ids;
-            ids.push_back(resId);
-            mContextResources[ctxId] = ids;
-        } else {
-            auto& ids = resourcesIt->second;
-            auto idIt = std::find(ids.begin(), ids.end(), resId);
-            if (idIt == ids.end()) ids.push_back(resId);
-        }
-
-        auto contextsIt = mResourceContexts.find(resId);
-
-        if (contextsIt == mResourceContexts.end()) {
-            std::vector<VirtioGpuCtxId> ids;
-            ids.push_back(ctxId);
-            mResourceContexts[resId] = ids;
-        } else {
-            auto& ids = contextsIt->second;
-            auto idIt = std::find(ids.begin(), ids.end(), ctxId);
-            if (idIt == ids.end()) ids.push_back(ctxId);
-        }
-
-        // Associate the host pipe of the resource entry with the host pipe of
-        // the context entry.  That is, the last context to call attachResource
-        // wins if there is any conflict.
-        auto ctxEntryIt = mContexts.find(ctxId);
-        auto resEntryIt = mResources.find(resId);
-
-        if (ctxEntryIt == mContexts.end() || resEntryIt == mResources.end()) return;
-
-        stream_renderer_debug("hostPipe: %p", ctxEntryIt->second.hostPipe);
-        resEntryIt->second.hostPipe = ctxEntryIt->second.hostPipe;
-        resEntryIt->second.ctxId = ctxId;
-    }
-
-    void detachResource(uint32_t ctxId, uint32_t toUnrefId) {
-        stream_renderer_debug("ctxid: %u resid: %u", ctxId, toUnrefId);
-        detachResourceLocked(ctxId, toUnrefId);
-    }
-
-    int getResourceInfo(uint32_t resId, struct stream_renderer_resource_info* info) {
-        stream_renderer_debug("resid: %u", resId);
-        if (!info) return EINVAL;
-
-        auto it = mResources.find(resId);
-        if (it == mResources.end()) return ENOENT;
-
-        auto& entry = it->second;
-
-        uint32_t bpp = 4U;
-        switch (entry.args.format) {
-            case VIRGL_FORMAT_B8G8R8A8_UNORM:
-                info->drm_fourcc = DRM_FORMAT_ARGB8888;
-                break;
-            case VIRGL_FORMAT_B8G8R8X8_UNORM:
-                info->drm_fourcc = DRM_FORMAT_XRGB8888;
-                break;
-            case VIRGL_FORMAT_B5G6R5_UNORM:
-                info->drm_fourcc = DRM_FORMAT_RGB565;
-                bpp = 2U;
-                break;
-            case VIRGL_FORMAT_R8G8B8A8_UNORM:
-                info->drm_fourcc = DRM_FORMAT_ABGR8888;
-                break;
-            case VIRGL_FORMAT_R8G8B8X8_UNORM:
-                info->drm_fourcc = DRM_FORMAT_XBGR8888;
-                break;
-            case VIRGL_FORMAT_R8_UNORM:
-                info->drm_fourcc = DRM_FORMAT_R8;
-                bpp = 1U;
-                break;
-            default:
-                return EINVAL;
-        }
-
-        info->stride = align_up(entry.args.width * bpp, 16U);
-        info->virgl_format = entry.args.format;
-        info->handle = entry.args.handle;
-        info->height = entry.args.height;
-        info->width = entry.args.width;
-        info->depth = entry.args.depth;
-        info->flags = entry.args.flags;
-        info->tex_id = 0;
-        return 0;
-    }
-
-    void flushResource(uint32_t res_handle) {
-        auto taskId = mVirtioGpuTimelines->enqueueTask(VirtioGpuRingGlobal{});
-        gfxstream::FrameBuffer::getFB()->postWithCallback(
-            res_handle, [this, taskId](std::shared_future<void> waitForGpu) {
-                waitForGpu.wait();
-                mVirtioGpuTimelines->notifyTaskCompletion(taskId);
-            });
-    }
-
-    int createRingBlob(PipeResEntry& entry, uint32_t res_handle,
-                       const struct stream_renderer_create_blob* create_blob,
-                       const struct stream_renderer_handle* handle) {
-        if (mFeatures.ExternalBlob.enabled) {
-            std::string name = "shared-memory-" + std::to_string(res_handle);
-            auto shmem = std::make_unique<SharedMemory>(name, create_blob->size);
-            int ret = shmem->create(0600);
-            if (ret) {
-                stream_renderer_error("Failed to create shared memory blob");
-                return ret;
-            }
-
-            entry.hva = shmem->get();
-            entry.ringBlob = std::make_shared<RingBlob>(std::move(shmem));
-
-        } else {
-            auto mem = std::make_unique<AlignedMemory>(mPageSize, create_blob->size);
-            if (mem->addr == nullptr) {
-                stream_renderer_error("Failed to allocate ring blob");
-                return -ENOMEM;
-            }
-
-            entry.hva = mem->addr;
-            entry.ringBlob = std::make_shared<RingBlob>(std::move(mem));
-        }
-
-        entry.hvaSize = create_blob->size;
-        entry.externalAddr = true;
-        entry.caching = STREAM_RENDERER_MAP_CACHE_CACHED;
-
-        return 0;
-    }
-
-    int createBlob(uint32_t ctx_id, uint32_t res_handle,
-                   const struct stream_renderer_create_blob* create_blob,
-                   const struct stream_renderer_handle* handle) {
-        stream_renderer_debug("ctx:%u res:%u blob-id:%u blob-size:%u", ctx_id, res_handle,
-                              create_blob->blob_id, create_blob->size);
-
-        PipeResEntry e;
-        struct stream_renderer_resource_create_args args = {0};
-        std::optional<BlobDescriptorInfo> descriptorInfoOpt = std::nullopt;
-        e.args = args;
-        e.hostPipe = 0;
-
-        auto ctxIt = mContexts.find(ctx_id);
-        if (ctxIt == mContexts.end()) {
-            stream_renderer_error("ctx id %u is not found", ctx_id);
-            return -EINVAL;
-        }
-
-        auto& ctxEntry = ctxIt->second;
-
-        ResType blobType = ResType::BLOB;
-
-        auto blobIt = ctxEntry.blobMap.find(create_blob->blob_id);
-        if (blobIt != ctxEntry.blobMap.end()) {
-            auto& create3d = blobIt->second;
-            create3d.handle = res_handle;
-
-            const auto resType = getResourceType(create3d);
-            switch (resType) {
-                case ResType::BLOB:
-                    return -EINVAL;
-                case ResType::PIPE:
-                    // Fallthrough for pipe is intended for blob buffers.
-                case ResType::BUFFER:
-                    blobType = ResType::BUFFER;
-                    handleCreateResourceBuffer(&create3d);
-                    descriptorInfoOpt = gfxstream::FrameBuffer::getFB()->exportBuffer(res_handle);
-                    break;
-                case ResType::COLOR_BUFFER:
-                    blobType = ResType::COLOR_BUFFER;
-                    handleCreateResourceColorBuffer(&create3d);
-                    descriptorInfoOpt =
-                        gfxstream::FrameBuffer::getFB()->exportColorBuffer(res_handle);
-                    break;
-            }
-
-            e.args = create3d;
-            ctxEntry.blobMap.erase(create_blob->blob_id);
-        }
-
-        if (create_blob->blob_id == 0) {
-            int ret = createRingBlob(e, res_handle, create_blob, handle);
-            if (ret) {
-                return ret;
-            }
-        } else if (mFeatures.ExternalBlob.enabled) {
-            if (create_blob->blob_mem == STREAM_BLOB_MEM_GUEST &&
-                (create_blob->blob_flags & STREAM_BLOB_FLAG_CREATE_GUEST_HANDLE)) {
-#if defined(__linux__) || defined(__QNX__)
-                ManagedDescriptor managedHandle(handle->os_handle);
-                ExternalObjectManager::get()->addBlobDescriptorInfo(
-                    ctx_id, create_blob->blob_id, std::move(managedHandle), handle->handle_type, 0,
-                    std::nullopt);
-
-                e.caching = STREAM_RENDERER_MAP_CACHE_CACHED;
-#else
-                return -EINVAL;
-#endif
-            } else {
-                if (!descriptorInfoOpt) {
-                    descriptorInfoOpt = ExternalObjectManager::get()->removeBlobDescriptorInfo(
-                        ctx_id, create_blob->blob_id);
-                }
-
-                if (descriptorInfoOpt) {
-                    e.descriptorInfo =
-                        std::make_shared<BlobDescriptorInfo>(std::move(*descriptorInfoOpt));
-                } else {
-                    return -EINVAL;
-                }
-
-                e.caching = e.descriptorInfo->caching;
-            }
-        } else {
-            auto entryOpt =
-                ExternalObjectManager::get()->removeMapping(ctx_id, create_blob->blob_id);
-            if (entryOpt) {
-                e.hva = entryOpt->addr;
-                e.caching = entryOpt->caching;
-                e.hvaSize = create_blob->size;
-            } else {
-                return -EINVAL;
-            }
-        }
-
-        e.blobId = create_blob->blob_id;
-        e.blobMem = create_blob->blob_mem;
-        e.blobFlags = create_blob->blob_flags;
-        e.type = blobType;
-        e.iov = nullptr;
-        e.numIovs = 0;
-        e.linear = 0;
-        e.linearSize = 0;
-
-        mResources[res_handle] = e;
-        return 0;
-    }
-
-    int resourceMap(uint32_t res_handle, void** hvaOut, uint64_t* sizeOut) {
-        if (mFeatures.ExternalBlob.enabled) return -EINVAL;
-
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) {
-            if (hvaOut) *hvaOut = nullptr;
-            if (sizeOut) *sizeOut = 0;
-            return -EINVAL;
-        }
-
-        const auto& entry = it->second;
-
-        if (hvaOut) *hvaOut = entry.hva;
-        if (sizeOut) *sizeOut = entry.hvaSize;
-        return 0;
-    }
+extern "C" {
+#include "gfxstream/virtio-gpu-gfxstream-renderer-unstable.h"
+#include "gfxstream/virtio-gpu-gfxstream-renderer.h"
+#include "host-common/goldfish_pipe.h"
+}  // extern "C"
 
-    int resourceUnmap(uint32_t res_handle) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) {
-            return -EINVAL;
-        }
+#define MAX_DEBUG_BUFFER_SIZE 512
+#define ELLIPSIS "...\0"
+#define ELLIPSIS_LEN 4
 
-        // TODO(lfy): Good place to run any registered cleanup callbacks.
-        // No-op for now.
-        return 0;
-    }
+// Define the typedef for emulogger
+typedef void (*emulogger)(char severity, const char* file, unsigned int line,
+                          int64_t timestamp_us, const char* message);
 
-    int platformImportResource(int res_handle, int res_info, void* resource) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) return -EINVAL;
-        bool success =
-            gfxstream::FrameBuffer::getFB()->platformImportResource(res_handle, res_info, resource);
-        return success ? 0 : -1;
-    }
+// Template to enable the method call if gfxstream_logger_t equals emulogger
+template<typename T>
+typename std::enable_if<std::is_same<T, emulogger>::value, bool>::type
+call_logger_if_valid(T logger, char severity, const char* file, unsigned int line, int64_t timestamp_us, const char* message) {
+    // Call the logger and return true if the type matches
+    if (!logger) { return false; }
+    logger(severity, file, line, timestamp_us, message);
+    return true;
+}
 
-    int platformResourceInfo(int res_handle, int* width, int* height, int* internal_format) {
-        bool success = false;
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) return -EINVAL;
-#if GFXSTREAM_ENABLE_HOST_GLES
-        success = gfxstream::FrameBuffer::getFB()->getColorBufferInfo(res_handle, width, height,
-                                                                      internal_format);
-#endif
-        return success ? 0 : -1;
-    }
+// Template for invalid logger types (returns false if types don't match)
+template<typename T>
+typename std::enable_if<!std::is_same<T, emulogger>::value, bool>::type
+call_logger_if_valid(T, char, const char*, unsigned int, int64_t, const char*) {
+    // Return false if the type doesn't match
+    return false;
+}
 
-    void* platformCreateSharedEglContext() {
-        void* ptr = nullptr;
-#if GFXSTREAM_ENABLE_HOST_GLES
-        ptr = gfxstream::FrameBuffer::getFB()->platformCreateSharedEglContext();
-#endif
-        return ptr;
-    }
+void* globalUserData = nullptr;
+stream_renderer_debug_callback globalDebugCallback = nullptr;
 
-    int platformDestroySharedEglContext(void* context) {
-        bool success = false;
-#if GFXSTREAM_ENABLE_HOST_GLES
-        success = gfxstream::FrameBuffer::getFB()->platformDestroySharedEglContext(context);
-#endif
-        return success ? 0 : -1;
+static void append_truncation_marker(char* buf, int remaining_size) {
+    // Safely append truncation marker "..." if buffer has enough space
+    if (remaining_size >= ELLIPSIS_LEN) {
+        strncpy(buf + remaining_size - ELLIPSIS_LEN, ELLIPSIS, ELLIPSIS_LEN);
+    } else if (remaining_size >= 1) {
+        buf[remaining_size - 1] = '\0';
+    } else {
+        // Oh oh.. In theory this shouldn't happen.
+        assert(false);
     }
+}
 
-    int waitSyncResource(uint32_t res_handle) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) {
-            stream_renderer_error("waitSyncResource could not find resource: %d", res_handle);
-            return -EINVAL;
-        }
-        auto& entry = it->second;
-        if (ResType::COLOR_BUFFER != entry.type) {
-            stream_renderer_error("waitSyncResource is undefined for non-ColorBuffer resource.");
-            return -EINVAL;
-        }
+static void log_with_prefix(char*& buf, int& remaining_size, const char* file, int line,
+                            const char* pretty_function) {
+    // Add logging prefix if necessary
+    int formatted_len = snprintf(buf, remaining_size, "[%s(%d)] %s ", file, line, pretty_function);
 
-        return gfxstream::FrameBuffer::getFB()->waitSyncColorBuffer(res_handle);
+    // Handle potential truncation
+    if (formatted_len >= remaining_size) {
+        append_truncation_marker(buf, remaining_size);
+        remaining_size = 0;
+    } else {
+        buf += formatted_len;             // Adjust buf
+        remaining_size -= formatted_len;  // Reduce remaining buffer size
     }
+}
 
-    int resourceMapInfo(uint32_t res_handle, uint32_t* map_info) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) return -EINVAL;
-
-        const auto& entry = it->second;
-        *map_info = entry.caching;
-        return 0;
+static char translate_severity(uint32_t type) {
+    switch (type) {
+        case STREAM_RENDERER_DEBUG_ERROR:
+            return 'E';
+        case STREAM_RENDERER_DEBUG_WARN:
+            return 'W';
+        case STREAM_RENDERER_DEBUG_INFO:
+            return 'I';
+        case STREAM_RENDERER_DEBUG_DEBUG:
+            return 'D';
+        default:
+            return 'D';
     }
+}
 
-    int exportBlob(uint32_t res_handle, struct stream_renderer_handle* handle) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) {
-            return -EINVAL;
-        }
-
-        auto& entry = it->second;
-        if (entry.ringBlob && entry.ringBlob->isExportable()) {
-            // Handle ownership transferred to VMM, gfxstream keeps the mapping.
-#ifdef _WIN32
-            handle->os_handle =
-                static_cast<int64_t>(reinterpret_cast<intptr_t>(entry.ringBlob->releaseHandle()));
-#else
-            handle->os_handle = static_cast<int64_t>(entry.ringBlob->releaseHandle());
-#endif
-            handle->handle_type = STREAM_MEM_HANDLE_TYPE_SHM;
-            return 0;
-        }
+using android::AndroidPipe;
+using android::base::ManagedDescriptor;
+using android::base::MetricsLogger;
+using gfxstream::host::VirtioGpuFrontend;
 
-        if (entry.descriptorInfo) {
-            DescriptorType rawDescriptor;
-            auto rawDescriptorOpt = entry.descriptorInfo->descriptor.release();
-            if (rawDescriptorOpt)
-                rawDescriptor = *rawDescriptorOpt;
-            else
-                return -EINVAL;
+static VirtioGpuFrontend* sFrontend() {
+    static VirtioGpuFrontend* p = new VirtioGpuFrontend;
+    return p;
+}
 
-            handle->handle_type = entry.descriptorInfo->handleType;
+extern "C" {
 
-#ifdef _WIN32
-            handle->os_handle = static_cast<int64_t>(reinterpret_cast<intptr_t>(rawDescriptor));
-#else
-            handle->os_handle = static_cast<int64_t>(rawDescriptor);
-#endif
+void stream_renderer_log(uint32_t type, const char* file, int line, const char* pretty_function,
+                         const char* format, ...) {
 
-            return 0;
-        }
+    char printbuf[MAX_DEBUG_BUFFER_SIZE];
+    char* buf = printbuf;
+    int remaining_size = MAX_DEBUG_BUFFER_SIZE;
+    static_assert(MAX_DEBUG_BUFFER_SIZE > 4);
 
-        return -EINVAL;
+    // Add the logging prefix if needed
+#ifdef CONFIG_AEMU
+    static gfxstream_logger_t gfx_logger = get_gfx_stream_logger();
+    if (!gfx_logger) {
+        log_with_prefix(buf, remaining_size, file, line, pretty_function);
     }
-
-    int exportFence(uint64_t fenceId, struct stream_renderer_handle* handle) {
-        auto it = mSyncMap.find(fenceId);
-        if (it == mSyncMap.end()) {
-            return -EINVAL;
-        }
-
-        auto& entry = it->second;
-        DescriptorType rawDescriptor;
-        auto rawDescriptorOpt = entry->descriptor.release();
-        if (rawDescriptorOpt)
-            rawDescriptor = *rawDescriptorOpt;
-        else
-            return -EINVAL;
-
-        handle->handle_type = entry->handleType;
-
-#ifdef _WIN32
-        handle->os_handle = static_cast<int64_t>(reinterpret_cast<intptr_t>(rawDescriptor));
 #else
-        handle->os_handle = static_cast<int64_t>(rawDescriptor);
+    log_with_prefix(buf, remaining_size, file, line, pretty_function);
 #endif
 
-        return 0;
-    }
-
-    int vulkanInfo(uint32_t res_handle, struct stream_renderer_vulkan_info* vulkan_info) {
-        auto it = mResources.find(res_handle);
-        if (it == mResources.end()) return -EINVAL;
-
-        const auto& entry = it->second;
-        if (entry.descriptorInfo && entry.descriptorInfo->vulkanInfoOpt) {
-            vulkan_info->memory_index = (*entry.descriptorInfo->vulkanInfoOpt).memoryIndex;
-            memcpy(vulkan_info->device_id.device_uuid,
-                   (*entry.descriptorInfo->vulkanInfoOpt).deviceUUID,
-                   sizeof(vulkan_info->device_id.device_uuid));
-            memcpy(vulkan_info->device_id.driver_uuid,
-                   (*entry.descriptorInfo->vulkanInfoOpt).driverUUID,
-                   sizeof(vulkan_info->device_id.driver_uuid));
-            return 0;
-        }
+    // Format the message with variable arguments
+    va_list args;
+    va_start(args, format);
+    int formatted_len = vsnprintf(buf, remaining_size, format, args);
+    va_end(args);
 
-        return -EINVAL;
+    // Handle potential truncation
+    if (formatted_len >= remaining_size) {
+        append_truncation_marker(buf, remaining_size);
     }
 
 #ifdef CONFIG_AEMU
-    void setServiceOps(const GoldfishPipeServiceOps* ops) { mServiceOps = ops; }
-#endif  // CONFIG_AEMU
-   private:
-    void allocResource(PipeResEntry& entry, iovec* iov, int num_iovs) {
-        stream_renderer_debug("entry linear: %p", entry.linear);
-        if (entry.linear) free(entry.linear);
-
-        size_t linearSize = 0;
-        for (uint32_t i = 0; i < num_iovs; ++i) {
-            stream_renderer_debug("iov base: %p", iov[i].iov_base);
-            linearSize += iov[i].iov_len;
-            stream_renderer_debug("has iov of %zu. linearSize current: %zu", iov[i].iov_len,
-                                  linearSize);
-        }
-        stream_renderer_debug("final linearSize: %zu", linearSize);
-
-        void* linear = nullptr;
-
-        if (linearSize) linear = malloc(linearSize);
-
-        entry.numIovs = num_iovs;
-        entry.iov = (iovec*)malloc(sizeof(*iov) * num_iovs);
-        if (entry.numIovs > 0) {
-            memcpy(entry.iov, iov, num_iovs * sizeof(*iov));
-        }
-        entry.linear = linear;
-        entry.linearSize = linearSize;
-    }
-
-    void detachResourceLocked(uint32_t ctxId, uint32_t toUnrefId) {
-        stream_renderer_debug("ctxid: %u resid: %u", ctxId, toUnrefId);
-
-        auto it = mContextResources.find(ctxId);
-        if (it == mContextResources.end()) return;
-
-        std::vector<VirtioGpuResId> withoutRes;
-        for (auto resId : it->second) {
-            if (resId != toUnrefId) {
-                withoutRes.push_back(resId);
-            }
-        }
-        mContextResources[ctxId] = withoutRes;
-
-        auto resourceIt = mResources.find(toUnrefId);
-        if (resourceIt == mResources.end()) return;
-        auto& resource = resourceIt->second;
-
-        resource.hostPipe = 0;
-        resource.ctxId = 0;
-
-        auto ctxIt = mContexts.find(ctxId);
-        if (ctxIt != mContexts.end()) {
-            auto& ctxEntry = ctxIt->second;
-            if (ctxEntry.addressSpaceHandles.count(toUnrefId)) {
-                uint32_t asgHandle = ctxEntry.addressSpaceHandles[toUnrefId];
-
-                mCleanupThread->enqueueCleanup([this, asgBlob = resource.ringBlob, asgHandle]() {
-                    mAddressSpaceDeviceControlOps->destroy_handle(asgHandle);
-                });
-
-                ctxEntry.addressSpaceHandles.erase(toUnrefId);
-            }
-        }
+    // Forward to emulator?
+    if (call_logger_if_valid(gfx_logger, translate_severity(type), file, line, 0, printbuf)) {
+        return;
     }
+#endif
 
-    inline const GoldfishPipeServiceOps* ensureAndGetServiceOps() {
-        if (mServiceOps) return mServiceOps;
-        mServiceOps = goldfish_pipe_get_service_ops();
-        return mServiceOps;
+    // To a gfxstream debugger?
+    if (globalUserData && globalDebugCallback) {
+        struct stream_renderer_debug debug = {0};
+        debug.debug_type = type;
+        debug.message = &printbuf[0];
+        globalDebugCallback(globalUserData, &debug);
+    } else {
+        // Cannot use logging routines, fallback to stderr
+        fprintf(stderr, "stream_renderer_log error: %s\n", printbuf);
     }
-
-    void* mCookie = nullptr;
-    gfxstream::host::FeatureSet mFeatures;
-    stream_renderer_fence_callback mFenceCallback;
-    uint32_t mPageSize = 4096;
-    struct address_space_device_control_ops* mAddressSpaceDeviceControlOps = nullptr;
-
-    const GoldfishPipeServiceOps* mServiceOps = nullptr;
-
-    std::unordered_map<VirtioGpuCtxId, PipeCtxEntry> mContexts;
-    std::unordered_map<VirtioGpuResId, PipeResEntry> mResources;
-    std::unordered_map<VirtioGpuCtxId, std::vector<VirtioGpuResId>> mContextResources;
-    std::unordered_map<VirtioGpuResId, std::vector<VirtioGpuCtxId>> mResourceContexts;
-    std::unordered_map<uint64_t, std::shared_ptr<SyncDescriptorInfo>> mSyncMap;
-
-    // When we wait for gpu or wait for gpu vulkan, the next (and subsequent)
-    // fences created for that context should not be signaled immediately.
-    // Rather, they should get in line.
-    std::unique_ptr<VirtioGpuTimelines> mVirtioGpuTimelines = nullptr;
-
-    std::unique_ptr<CleanupThread> mCleanupThread;
-};
-
-static PipeVirglRenderer* sRenderer() {
-    static PipeVirglRenderer* p = new PipeVirglRenderer;
-    return p;
 }
 
-extern "C" {
-
 VG_EXPORT int stream_renderer_resource_create(struct stream_renderer_resource_create_args* args,
                                               struct iovec* iov, uint32_t num_iovs) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_create()");
 
-    return sRenderer()->createResource(args, iov, num_iovs);
+    return sFrontend()->createResource(args, iov, num_iovs);
 }
 
 VG_EXPORT void stream_renderer_resource_unref(uint32_t res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_unref()");
 
-    sRenderer()->unrefResource(res_handle);
+    sFrontend()->unrefResource(res_handle);
 }
 
 VG_EXPORT void stream_renderer_context_destroy(uint32_t handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_context_destroy()");
 
-    sRenderer()->destroyContext(handle);
+    sFrontend()->destroyContext(handle);
 }
 
 VG_EXPORT int stream_renderer_submit_cmd(struct stream_renderer_command* cmd) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_submit_cmd()");
 
-    return sRenderer()->submitCmd(cmd);
+    return sFrontend()->submitCmd(cmd);
 }
 
 VG_EXPORT int stream_renderer_transfer_read_iov(uint32_t handle, uint32_t ctx_id, uint32_t level,
@@ -2455,7 +208,7 @@ VG_EXPORT int stream_renderer_transfer_read_iov(uint32_t handle, uint32_t ctx_id
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_transfer_read_iov()");
 
-    return sRenderer()->transferReadIov(handle, offset, box, iov, iovec_cnt);
+    return sFrontend()->transferReadIov(handle, offset, box, iov, iovec_cnt);
 }
 
 VG_EXPORT int stream_renderer_transfer_write_iov(uint32_t handle, uint32_t ctx_id, int level,
@@ -2465,7 +218,7 @@ VG_EXPORT int stream_renderer_transfer_write_iov(uint32_t handle, uint32_t ctx_i
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_transfer_write_iov()");
 
-    return sRenderer()->transferWriteIov(handle, offset, box, iovec, iovec_cnt);
+    return sFrontend()->transferWriteIov(handle, offset, box, iovec, iovec_cnt);
 }
 
 VG_EXPORT void stream_renderer_get_cap_set(uint32_t set, uint32_t* max_ver, uint32_t* max_size) {
@@ -2476,21 +229,21 @@ VG_EXPORT void stream_renderer_get_cap_set(uint32_t set, uint32_t* max_ver, uint
                                "Main Virtio Gpu Thread");
 
     // `max_ver` not useful
-    return sRenderer()->getCapset(set, max_size);
+    return sFrontend()->getCapset(set, max_size);
 }
 
 VG_EXPORT void stream_renderer_fill_caps(uint32_t set, uint32_t version, void* caps) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_fill_caps()");
 
     // `version` not useful
-    return sRenderer()->fillCaps(set, caps);
+    return sFrontend()->fillCaps(set, caps);
 }
 
 VG_EXPORT int stream_renderer_resource_attach_iov(int res_handle, struct iovec* iov, int num_iovs) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_attach_iov()");
 
-    return sRenderer()->attachIov(res_handle, iov, num_iovs);
+    return sFrontend()->attachIov(res_handle, iov, num_iovs);
 }
 
 VG_EXPORT void stream_renderer_resource_detach_iov(int res_handle, struct iovec** iov,
@@ -2498,21 +251,21 @@ VG_EXPORT void stream_renderer_resource_detach_iov(int res_handle, struct iovec*
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_detach_iov()");
 
-    return sRenderer()->detachIov(res_handle, iov, num_iovs);
+    return sFrontend()->detachIov(res_handle);
 }
 
 VG_EXPORT void stream_renderer_ctx_attach_resource(int ctx_id, int res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_ctx_attach_resource()");
 
-    sRenderer()->attachResource(ctx_id, res_handle);
+    sFrontend()->attachResource(ctx_id, res_handle);
 }
 
 VG_EXPORT void stream_renderer_ctx_detach_resource(int ctx_id, int res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_ctx_detach_resource()");
 
-    sRenderer()->detachResource(ctx_id, res_handle);
+    sFrontend()->detachResource(ctx_id, res_handle);
 }
 
 VG_EXPORT int stream_renderer_resource_get_info(int res_handle,
@@ -2520,13 +273,13 @@ VG_EXPORT int stream_renderer_resource_get_info(int res_handle,
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_get_info()");
 
-    return sRenderer()->getResourceInfo(res_handle, info);
+    return sFrontend()->getResourceInfo(res_handle, info);
 }
 
 VG_EXPORT void stream_renderer_flush(uint32_t res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_flush()");
 
-    sRenderer()->flushResource(res_handle);
+    sFrontend()->flushResource(res_handle);
 }
 
 VG_EXPORT int stream_renderer_create_blob(uint32_t ctx_id, uint32_t res_handle,
@@ -2536,7 +289,7 @@ VG_EXPORT int stream_renderer_create_blob(uint32_t ctx_id, uint32_t res_handle,
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_create_blob()");
 
-    sRenderer()->createBlob(ctx_id, res_handle, create_blob, handle);
+    sFrontend()->createBlob(ctx_id, res_handle, create_blob, handle);
     return 0;
 }
 
@@ -2545,21 +298,21 @@ VG_EXPORT int stream_renderer_export_blob(uint32_t res_handle,
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_export_blob()");
 
-    return sRenderer()->exportBlob(res_handle, handle);
+    return sFrontend()->exportBlob(res_handle, handle);
 }
 
 VG_EXPORT int stream_renderer_resource_map(uint32_t res_handle, void** hvaOut, uint64_t* sizeOut) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_map()");
 
-    return sRenderer()->resourceMap(res_handle, hvaOut, sizeOut);
+    return sFrontend()->resourceMap(res_handle, hvaOut, sizeOut);
 }
 
 VG_EXPORT int stream_renderer_resource_unmap(uint32_t res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_unmap()");
 
-    return sRenderer()->resourceUnmap(res_handle);
+    return sFrontend()->resourceUnmap(res_handle);
 }
 
 VG_EXPORT int stream_renderer_context_create(uint32_t ctx_id, uint32_t nlen, const char* name,
@@ -2567,7 +320,7 @@ VG_EXPORT int stream_renderer_context_create(uint32_t ctx_id, uint32_t nlen, con
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_context_create()");
 
-    return sRenderer()->createContext(ctx_id, nlen, name, context_init);
+    return sFrontend()->createContext(ctx_id, nlen, name, context_init);
 }
 
 VG_EXPORT int stream_renderer_create_fence(const struct stream_renderer_fence* fence) {
@@ -2575,19 +328,19 @@ VG_EXPORT int stream_renderer_create_fence(const struct stream_renderer_fence* f
                           "stream_renderer_create_fence()");
 
     if (fence->flags & STREAM_RENDERER_FLAG_FENCE_SHAREABLE) {
-        int ret = sRenderer()->acquireContextFence(fence->ctx_id, fence->fence_id);
+        int ret = sFrontend()->acquireContextFence(fence->ctx_id, fence->fence_id);
         if (ret) {
             return ret;
         }
     }
 
     if (fence->flags & STREAM_RENDERER_FLAG_FENCE_RING_IDX) {
-        sRenderer()->createFence(fence->fence_id, VirtioGpuRingContextSpecific{
+        sFrontend()->createFence(fence->fence_id, VirtioGpuRingContextSpecific{
                                                       .mCtxId = fence->ctx_id,
                                                       .mRingIdx = fence->ring_idx,
                                                   });
     } else {
-        sRenderer()->createFence(fence->fence_id, VirtioGpuRingGlobal{});
+        sFrontend()->createFence(fence->fence_id, VirtioGpuRingGlobal{});
     }
 
     return 0;
@@ -2598,7 +351,7 @@ VG_EXPORT int stream_renderer_export_fence(uint64_t fence_id,
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_export_fence()");
 
-    return sRenderer()->exportFence(fence_id, handle);
+    return sFrontend()->exportFence(fence_id, handle);
 }
 
 VG_EXPORT int stream_renderer_platform_import_resource(int res_handle, int res_info,
@@ -2606,43 +359,35 @@ VG_EXPORT int stream_renderer_platform_import_resource(int res_handle, int res_i
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_platform_import_resource()");
 
-    return sRenderer()->platformImportResource(res_handle, res_info, resource);
-}
-
-VG_EXPORT int stream_renderer_platform_resource_info(int res_handle, int* width, int* height,
-                                                     int* internal_format) {
-    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                          "stream_renderer_platform_resource_info()");
-
-    return sRenderer()->platformResourceInfo(res_handle, width, height, internal_format);
+    return sFrontend()->platformImportResource(res_handle, res_info, resource);
 }
 
 VG_EXPORT void* stream_renderer_platform_create_shared_egl_context() {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_platform_create_shared_egl_context()");
 
-    return sRenderer()->platformCreateSharedEglContext();
+    return sFrontend()->platformCreateSharedEglContext();
 }
 
 VG_EXPORT int stream_renderer_platform_destroy_shared_egl_context(void* context) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_platform_destroy_shared_egl_context()");
 
-    return sRenderer()->platformDestroySharedEglContext(context);
+    return sFrontend()->platformDestroySharedEglContext(context);
 }
 
 VG_EXPORT int stream_renderer_wait_sync_resource(uint32_t res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_wait_sync_resource()");
 
-    return sRenderer()->waitSyncResource(res_handle);
+    return sFrontend()->waitSyncResource(res_handle);
 }
 
 VG_EXPORT int stream_renderer_resource_map_info(uint32_t res_handle, uint32_t* map_info) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_map_info()");
 
-    return sRenderer()->resourceMapInfo(res_handle, map_info);
+    return sFrontend()->resourceMapInfo(res_handle, map_info);
 }
 
 VG_EXPORT int stream_renderer_vulkan_info(uint32_t res_handle,
@@ -2650,27 +395,22 @@ VG_EXPORT int stream_renderer_vulkan_info(uint32_t res_handle,
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_vulkan_info()");
 
-    return sRenderer()->vulkanInfo(res_handle, vulkan_info);
+    return sFrontend()->vulkanInfo(res_handle, vulkan_info);
 }
 
-VG_EXPORT int stream_renderer_snapshot(const char* dir) {
-    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_snapshot()");
-
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
-    std::string dirString(dir);
+VG_EXPORT int stream_renderer_suspend() {
+    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_suspend()");
 
-    std::string snapshotFileName = dirString + "snapshot.bin";
+    // TODO: move pauseAllPreSave() here after kumquat updated.
 
-    std::unique_ptr<android::base::StdioStream> stream(new android::base::StdioStream(
-        fopen(snapshotFileName.c_str(), "wb"), android::base::StdioStream::kOwner));
+    return 0;
+}
 
-    android_getOpenglesRenderer()->pauseAllPreSave();
-    android::snapshot::SnapshotSaveStream saveStream{
-        .stream = stream.get(),
-    };
+VG_EXPORT int stream_renderer_snapshot(const char* dir) {
+    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_snapshot()");
 
-    android_getOpenglesRenderer()->save(saveStream.stream, saveStream.textureSaver);
-    return 0;
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    return sFrontend()->snapshot(dir);
 #else
     stream_renderer_error("Snapshot save requested without support.");
     return -EINVAL;
@@ -2680,29 +420,22 @@ VG_EXPORT int stream_renderer_snapshot(const char* dir) {
 VG_EXPORT int stream_renderer_restore(const char* dir) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_restore()");
 
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
-    std::string dirString(dir);
-    std::string snapshotFileName = dirString + "snapshot.bin";
-
-    std::unique_ptr<android::base::StdioStream> stream(new android::base::StdioStream(
-        fopen(snapshotFileName.c_str(), "rb"), android::base::StdioStream::kOwner));
-
-    android::snapshot::SnapshotLoadStream loadStream{
-        .stream = stream.get(),
-    };
-
-    android_getOpenglesRenderer()->load(loadStream.stream, loadStream.textureLoader);
-
-    // In end2end tests, we don't really do snapshot save for render threads.
-    // We will need to resume all render threads without waiting for snapshot.
-    android_getOpenglesRenderer()->resumeAll(false);
-    return 0;
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    return sFrontend()->restore(dir);
 #else
     stream_renderer_error("Snapshot save requested without support.");
     return -EINVAL;
 #endif
 }
 
+VG_EXPORT int stream_renderer_resume() {
+    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_resume()");
+
+    // TODO: move resumeAll() here after kumquat updated.
+
+    return 0;
+}
+
 static const GoldfishPipeServiceOps goldfish_pipe_service_ops = {
     // guest_open()
     [](GoldfishHwPipe* hwPipe) -> GoldfishHostPipe* {
@@ -3254,7 +987,7 @@ VG_EXPORT int stream_renderer_init(struct stream_renderer_param* stream_renderer
 
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY, "stream_renderer_init()");
 
-    sRenderer()->init(renderer_cookie, features, fence_callback);
+    sFrontend()->init(renderer_cookie, features, fence_callback);
     gfxstream::FrameBuffer::waitUntilInitialized();
 
     stream_renderer_info("Gfxstream initialized successfully!");
@@ -3270,11 +1003,12 @@ VG_EXPORT void gfxstream_backend_setup_window(void* native_window_handle, int32_
 }
 
 VG_EXPORT void stream_renderer_teardown() {
+    sFrontend()->teardown();
+
     android_finishOpenglesRenderer();
     android_hideOpenglesWindow();
     android_stopOpenglesRenderer(true);
 
-    sRenderer()->teardown();
     stream_renderer_info("Gfxstream shut down completed!");
 }
 
@@ -3323,7 +1057,7 @@ static_assert(offsetof(struct stream_renderer_param, value) == 8,
 #ifdef CONFIG_AEMU
 
 VG_EXPORT void stream_renderer_set_service_ops(const GoldfishPipeServiceOps* ops) {
-    sRenderer()->setServiceOps(ops);
+    sFrontend()->setServiceOps(ops);
 }
 
 #endif  // CONFIG_AEMU
diff --git a/host/vulkan/Android.bp b/host/vulkan/Android.bp
index 2042e74f1..a9364228d 100644
--- a/host/vulkan/Android.bp
+++ b/host/vulkan/Android.bp
@@ -23,6 +23,9 @@ cc_library_static {
     whole_static_libs: [
         "libgfxstream_host_tracing",
     ],
+    shared_libs: [
+        "liblog",
+    ],
     static_libs: [
         "gfxstream_base",
         "gfxstream_host_common",
diff --git a/host/vulkan/CMakeLists.txt b/host/vulkan/CMakeLists.txt
index dfa1a0004..a3151b0b2 100644
--- a/host/vulkan/CMakeLists.txt
+++ b/host/vulkan/CMakeLists.txt
@@ -2,7 +2,7 @@ add_subdirectory(cereal)
 add_subdirectory(emulated_textures)
 
 if(CONFIG_AEMU)
-    add_compile_definitions(GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT)
+    add_compile_definitions(GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT)
     add_compile_definitions(CONFIG_AEMU)
 endif()
 
diff --git a/host/vulkan/ColorBufferVk.cpp b/host/vulkan/ColorBufferVk.cpp
index d432fd22c..786d856f1 100644
--- a/host/vulkan/ColorBufferVk.cpp
+++ b/host/vulkan/ColorBufferVk.cpp
@@ -56,8 +56,9 @@ bool ColorBufferVk::readToBytes(std::vector<uint8_t>* outBytes) {
     return readColorBufferToBytes(mHandle, outBytes);
 }
 
-bool ColorBufferVk::readToBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, void* outBytes) {
-    return readColorBufferToBytes(mHandle, x, y, w, h, outBytes);
+bool ColorBufferVk::readToBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, void* outBytes,
+                                uint64_t outBytesSize) {
+    return readColorBufferToBytes(mHandle, x, y, w, h, outBytes, outBytesSize);
 }
 
 bool ColorBufferVk::updateFromBytes(const std::vector<uint8_t>& bytes) {
diff --git a/host/vulkan/ColorBufferVk.h b/host/vulkan/ColorBufferVk.h
index fec92842f..a54e785b3 100644
--- a/host/vulkan/ColorBufferVk.h
+++ b/host/vulkan/ColorBufferVk.h
@@ -34,7 +34,8 @@ class ColorBufferVk {
     ~ColorBufferVk();
 
     bool readToBytes(std::vector<uint8_t>* outBytes);
-    bool readToBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, void* outBytes);
+    bool readToBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, void* outBytes,
+                     uint64_t outBytesSize);
 
     bool updateFromBytes(const std::vector<uint8_t>& bytes);
     bool updateFromBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, const void* bytes);
diff --git a/host/vulkan/DeviceOpTracker.cpp b/host/vulkan/DeviceOpTracker.cpp
index bc365546f..1f376994e 100644
--- a/host/vulkan/DeviceOpTracker.cpp
+++ b/host/vulkan/DeviceOpTracker.cpp
@@ -28,8 +28,9 @@ using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
 constexpr const size_t kSizeLoggingThreshold = 20;
+constexpr const auto kSizeLoggingTimeThreshold = std::chrono::seconds(1);
 
-constexpr const auto kTimeThreshold = std::chrono::seconds(5);
+constexpr const auto kAutoDeleteTimeThreshold = std::chrono::seconds(5);
 
 template <typename T>
 inline constexpr bool always_false_v = false;
@@ -42,7 +43,7 @@ DeviceOpTracker::DeviceOpTracker(VkDevice device, VulkanDispatch* deviceDispatch
 void DeviceOpTracker::AddPendingGarbage(DeviceOpWaitable waitable, VkFence fence) {
     std::lock_guard<std::mutex> lock(mPendingGarbageMutex);
 
-    mPendingGarbage.push_back(PendingGarabage{
+    mPendingGarbage.push_back(PendingGarbage{
         .waitable = std::move(waitable),
         .obj = fence,
         .timepoint = std::chrono::system_clock::now(),
@@ -56,7 +57,7 @@ void DeviceOpTracker::AddPendingGarbage(DeviceOpWaitable waitable, VkFence fence
 void DeviceOpTracker::AddPendingGarbage(DeviceOpWaitable waitable, VkSemaphore semaphore) {
     std::lock_guard<std::mutex> lock(mPendingGarbageMutex);
 
-    mPendingGarbage.push_back(PendingGarabage{
+    mPendingGarbage.push_back(PendingGarbage{
         .waitable = std::move(waitable),
         .obj = semaphore,
         .timepoint = std::chrono::system_clock::now(),
@@ -69,22 +70,27 @@ void DeviceOpTracker::AddPendingGarbage(DeviceOpWaitable waitable, VkSemaphore s
 
 void DeviceOpTracker::Poll() {
     std::lock_guard<std::mutex> lock(mPollFunctionsMutex);
-
-    // Assuming that polling functions are added to the queue in the roughly the order
-    // they are used, encountering an unsignaled/pending polling functions likely means
-    // that all polling functions after are also still pending. This might not necessarily
-    // always be the case but it is a simple heuristic to try to minimize the amount of
-    // work performed here as it is expected that this function will be called while
-    // processing other guest vulkan functions.
-    auto firstPendingIt = std::find_if(mPollFunctions.begin(), mPollFunctions.end(),
-                                       [](const OpPollingFunction& pollingFunc) {
-                                           DeviceOpStatus status = pollingFunc();
-                                           return status == DeviceOpStatus::kPending;
-                                       });
-    mPollFunctions.erase(mPollFunctions.begin(), firstPendingIt);
+    mPollFunctions.erase(std::remove_if(mPollFunctions.begin(), mPollFunctions.end(),
+                                        [](const PollFunction& pollingFunc) {
+                                            DeviceOpStatus status = pollingFunc.func();
+                                            return status != DeviceOpStatus::kPending;
+                                        }),
+                         mPollFunctions.end());
 
     if (mPollFunctions.size() > kSizeLoggingThreshold) {
-        WARN("VkDevice:%p has %d pending waitables.", mDevice, mPollFunctions.size());
+        // Only report old-enough objects to avoid reporting lots of pending waitables
+        // when many requests have been done in a small amount of time.
+        const auto now = std::chrono::system_clock::now();
+        const auto old = now - kSizeLoggingTimeThreshold;
+        int numOldFuncs = std::count_if(
+            mPollFunctions.begin(), mPollFunctions.end(), [old](const PollFunction& pollingFunc) {
+                return (pollingFunc.timepoint < old);
+            });
+        if (numOldFuncs > kSizeLoggingThreshold) {
+            WARN("VkDevice:%p has %d pending waitables, %d taking more than %d milliseconds.",
+                 mDevice, mPollFunctions.size(), numOldFuncs,
+                 std::chrono::duration_cast<std::chrono::milliseconds>(kSizeLoggingTimeThreshold));
+        }
     }
 }
 
@@ -92,7 +98,7 @@ void DeviceOpTracker::PollAndProcessGarbage() {
     Poll();
 
     const auto now = std::chrono::system_clock::now();
-    const auto old = now - kTimeThreshold;
+    const auto old = now - kAutoDeleteTimeThreshold;
     {
         std::lock_guard<std::mutex> lock(mPendingGarbageMutex);
 
@@ -103,7 +109,7 @@ void DeviceOpTracker::PollAndProcessGarbage() {
         // of work performed here as it is expected that this function will be called
         // while processing other guest vulkan functions.
         auto firstPendingIt = std::find_if(mPendingGarbage.begin(), mPendingGarbage.end(),
-                                           [&](const PendingGarabage& pendingGarbage) {
+                                           [old](const PendingGarbage& pendingGarbage) {
                                                if (pendingGarbage.timepoint < old) {
                                                    return /*still pending=*/false;
                                                }
@@ -111,7 +117,7 @@ void DeviceOpTracker::PollAndProcessGarbage() {
                                            });
 
         for (auto it = mPendingGarbage.begin(); it != firstPendingIt; it++) {
-            PendingGarabage& pendingGarbage = *it;
+            PendingGarbage& pendingGarbage = *it;
 
             if (pendingGarbage.timepoint < old) {
                 const auto difference = std::chrono::duration_cast<std::chrono::milliseconds>(
@@ -159,7 +165,10 @@ void DeviceOpTracker::OnDestroyDevice() {
 
 void DeviceOpTracker::AddPendingDeviceOp(std::function<DeviceOpStatus()> pollFunction) {
     std::lock_guard<std::mutex> lock(mPollFunctionsMutex);
-    mPollFunctions.push_back(std::move(pollFunction));
+    mPollFunctions.push_back(PollFunction{
+        .func = std::move(pollFunction),
+        .timepoint = std::chrono::system_clock::now(),
+    });
 }
 
 DeviceOpBuilder::DeviceOpBuilder(DeviceOpTracker& tracker) : mTracker(tracker) {}
@@ -209,9 +218,8 @@ DeviceOpWaitable DeviceOpBuilder::OnQueueSubmittedWithFence(VkFence fence) {
             return DeviceOpStatus::kDone;
         }
 
-        VkResult result =
-            deviceDispatch->vkWaitForFences(device, 1, &fence, /*waitAll=*/VK_TRUE, /*timeout=*/0);
-        if (result == VK_TIMEOUT) {
+        VkResult result = deviceDispatch->vkGetFenceStatus(device, fence);
+        if (result == VK_NOT_READY) {
             return DeviceOpStatus::kPending;
         }
 
@@ -227,4 +235,4 @@ DeviceOpWaitable DeviceOpBuilder::OnQueueSubmittedWithFence(VkFence fence) {
 }
 
 }  // namespace vk
-}  // namespace gfxstream
\ No newline at end of file
+}  // namespace gfxstream
diff --git a/host/vulkan/DeviceOpTracker.h b/host/vulkan/DeviceOpTracker.h
index acd7782be..eb91c66f5 100644
--- a/host/vulkan/DeviceOpTracker.h
+++ b/host/vulkan/DeviceOpTracker.h
@@ -77,17 +77,20 @@ class DeviceOpTracker {
     using OpPollingFunction = std::function<DeviceOpStatus()>;
 
     void AddPendingDeviceOp(OpPollingFunction pollFunction);
-
+    struct PollFunction {
+        OpPollingFunction func;
+        std::chrono::time_point<std::chrono::system_clock> timepoint;
+    };
     std::mutex mPollFunctionsMutex;
-    std::deque<OpPollingFunction> mPollFunctions;
+    std::deque<PollFunction> mPollFunctions;
 
-    struct PendingGarabage {
+    struct PendingGarbage {
         DeviceOpWaitable waitable;
         std::variant<VkFence, VkSemaphore> obj;
         std::chrono::time_point<std::chrono::system_clock> timepoint;
     };
     std::mutex mPendingGarbageMutex;
-    std::deque<PendingGarabage> mPendingGarbage;
+    std::deque<PendingGarbage> mPendingGarbage;
 };
 
 class DeviceOpBuilder {
diff --git a/host/vulkan/DisplayVk.cpp b/host/vulkan/DisplayVk.cpp
index fbf1b42fd..1f98a55ea 100644
--- a/host/vulkan/DisplayVk.cpp
+++ b/host/vulkan/DisplayVk.cpp
@@ -19,17 +19,11 @@ using gfxstream::vk::formatIsSInt;
 using gfxstream::vk::formatIsUInt;
 using gfxstream::vk::formatRequiresSamplerYcbcrConversion;
 
-#define DISPLAY_VK_ERROR(fmt, ...)                                                            \
-    do {                                                                                      \
-        fprintf(stderr, "%s(%s:%d): " fmt "\n", __func__, __FILE__, __LINE__, ##__VA_ARGS__); \
-        fflush(stderr);                                                                       \
-    } while (0)
-
-#define DISPLAY_VK_ERROR_ONCE(fmt, ...)              \
+#define ERR_ONCE(fmt, ...)              \
     do {                                             \
         static bool displayVkInternalLogged = false; \
         if (!displayVkInternalLogged) {              \
-            DISPLAY_VK_ERROR(fmt, ##__VA_ARGS__);    \
+            ERR(fmt, ##__VA_ARGS__);                 \
             displayVkInternalLogged = true;          \
         }                                            \
     } while (0)
@@ -352,12 +346,12 @@ DisplayVk::PostResult DisplayVk::postImpl(const BorrowedImageInfo* sourceImageIn
 
     const auto* surface = getBoundSurface();
     if (!m_swapChainStateVk || !surface) {
-        DISPLAY_VK_ERROR("Haven't bound to a surface, can't post ColorBuffer.");
+        ERR("Cannot post ColorBuffer: No surface bound.");
         return PostResult{true, std::move(completedFuture)};
     }
 
     if (!canPost(sourceImageInfoVk->imageCreateInfo)) {
-        DISPLAY_VK_ERROR("Can't post ColorBuffer.");
+        ERR("Can't post ColorBuffer.");
         return PostResult{true, std::move(completedFuture)};
     }
 
@@ -464,13 +458,13 @@ DisplayVk::PostResult DisplayVk::postImpl(const BorrowedImageInfo* sourceImageIn
     VkFormatFeatureFlags displayBufferFormatFeatures =
         getFormatFeatures(displayBufferFormat, displayBufferTiling);
     if (formatIsDepthOrStencil(displayBufferFormat)) {
-        DISPLAY_VK_ERROR_ONCE(
+        ERR_ONCE(
             "The format of the display buffer, %s, is a depth/stencil format, we can only use the "
             "VK_FILTER_NEAREST filter according to VUID-vkCmdBlitImage-srcImage-00232.",
             string_VkFormat(displayBufferFormat));
         filter = VK_FILTER_NEAREST;
     } else if (!(displayBufferFormatFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) {
-        DISPLAY_VK_ERROR_ONCE(
+        ERR_ONCE(
             "The format of the display buffer, %s, with the tiling, %s, doesn't support "
             "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT, so we can only use the "
             "VK_FILTER_NEAREST filter according VUID-vkCmdBlitImage-filter-02001. The supported "
@@ -583,7 +577,7 @@ VkFormatFeatureFlags DisplayVk::getFormatFeatures(VkFormat format, VkImageTiling
     } else if (tiling == VK_IMAGE_TILING_OPTIMAL) {
         formatFeatures = formatProperties.optimalTilingFeatures;
     } else {
-        DISPLAY_VK_ERROR("Unknown tiling %#" PRIx64 ".", static_cast<uint64_t>(tiling));
+        ERR("Unknown tiling %#" PRIx64 ".", static_cast<uint64_t>(tiling));
     }
     return formatFeatures;
 }
@@ -593,7 +587,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
     // VK_FORMAT_FEATURE_BLIT_SRC_BIT.
     VkFormatFeatureFlags formatFeatures = getFormatFeatures(postImageCi.format, postImageCi.tiling);
     if (!(formatFeatures & VK_FORMAT_FEATURE_BLIT_SRC_BIT)) {
-        DISPLAY_VK_ERROR(
+        ERR(
             "VK_FORMAT_FEATURE_BLIT_SRC_BLIT is not supported for VkImage with format %s, tilling "
             "%s. Supported features are %s.",
             string_VkFormat(postImageCi.format), string_VkImageTiling(postImageCi.tiling),
@@ -604,7 +598,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
     // According to VUID-vkCmdBlitImage-srcImage-06421, srcImage must not use a format that requires
     // a sampler YCBCR conversion.
     if (formatRequiresSamplerYcbcrConversion(postImageCi.format)) {
-        DISPLAY_VK_ERROR("Format %s requires a sampler Y'CbCr conversion. Can't be used to post.",
+        ERR("Format %s requires a sampler Y'CbCr conversion. Can't be used to post.",
                          string_VkFormat(postImageCi.format));
         return false;
     }
@@ -612,7 +606,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
     if (!(postImageCi.usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT)) {
         // According to VUID-vkCmdBlitImage-srcImage-00219, srcImage must have been created with
         // VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag.
-        DISPLAY_VK_ERROR(
+        ERR(
             "The VkImage is not created with the VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag. The "
             "usage flags are %s.",
             string_VkImageUsageFlags(postImageCi.usage).c_str());
@@ -625,7 +619,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
         // created with a signed integer VkFormat, the other must also have been created with a
         // signed integer VkFormat.
         if (!(formatIsSInt(postImageCi.format) && formatIsSInt(m_swapChainStateVk->getFormat()))) {
-            DISPLAY_VK_ERROR(
+            ERR(
                 "The format(%s) doesn't match with the format of the presentable image(%s): either "
                 "of the formats is a signed integer VkFormat, but the other is not.",
                 string_VkFormat(postImageCi.format), string_VkFormat(swapChainFormat));
@@ -638,7 +632,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
         // created with an unsigned integer VkFormat, the other must also have been created with an
         // unsigned integer VkFormat.
         if (!(formatIsUInt(postImageCi.format) && formatIsUInt(swapChainFormat))) {
-            DISPLAY_VK_ERROR(
+            ERR(
                 "The format(%s) doesn't match with the format of the presentable image(%s): either "
                 "of the formats is an unsigned integer VkFormat, but the other is not.",
                 string_VkFormat(postImageCi.format), string_VkFormat(swapChainFormat));
@@ -650,7 +644,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
         // According to VUID-vkCmdBlitImage-srcImage-00231, if either of srcImage or dstImage was
         // created with a depth/stencil format, the other must have exactly the same format.
         if (postImageCi.format != swapChainFormat) {
-            DISPLAY_VK_ERROR(
+            ERR(
                 "The format(%s) doesn't match with the format of the presentable image(%s): either "
                 "of the formats is a depth/stencil VkFormat, but the other is not the same format.",
                 string_VkFormat(postImageCi.format), string_VkFormat(swapChainFormat));
@@ -661,7 +655,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
     if (postImageCi.samples != VK_SAMPLE_COUNT_1_BIT) {
         // According to VUID-vkCmdBlitImage-srcImage-00233, srcImage must have been created with a
         // samples value of VK_SAMPLE_COUNT_1_BIT.
-        DISPLAY_VK_ERROR(
+        ERR(
             "The VkImage is not created with the VK_SAMPLE_COUNT_1_BIT samples value. The samples "
             "value is %s.",
             string_VkSampleCountFlagBits(postImageCi.samples));
@@ -670,7 +664,7 @@ bool DisplayVk::canPost(const VkImageCreateInfo& postImageCi) {
     if (postImageCi.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT) {
         // According to VUID-vkCmdBlitImage-dstImage-02545, dstImage and srcImage must not have been
         // created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.
-        DISPLAY_VK_ERROR(
+        ERR(
             "The VkImage can't be created with flags containing "
             "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT. The flags are %s.",
             string_VkImageCreateFlags(postImageCi.flags).c_str());
diff --git a/host/vulkan/RenderThreadInfoVk.cpp b/host/vulkan/RenderThreadInfoVk.cpp
index 08fa4e365..307018032 100644
--- a/host/vulkan/RenderThreadInfoVk.cpp
+++ b/host/vulkan/RenderThreadInfoVk.cpp
@@ -33,5 +33,14 @@ RenderThreadInfoVk::~RenderThreadInfoVk() { tlThreadInfo = nullptr; }
 
 RenderThreadInfoVk* RenderThreadInfoVk::get() { return tlThreadInfo; }
 
+void RenderThreadInfoVk::onSave(android::base::Stream* stream) {
+    stream->putBe32(ctx_id);
+}
+
+bool RenderThreadInfoVk::onLoad(android::base::Stream* stream) {
+    ctx_id = stream->getBe32();
+    return true;
+}
+
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/RenderThreadInfoVk.h b/host/vulkan/RenderThreadInfoVk.h
index 63d8f6a9c..74cad622a 100644
--- a/host/vulkan/RenderThreadInfoVk.h
+++ b/host/vulkan/RenderThreadInfoVk.h
@@ -18,6 +18,7 @@
 #include <string>
 
 #include "VkDecoder.h"
+#include "aemu/base/files/Stream.h"
 
 namespace gfxstream {
 namespace vk {
@@ -34,7 +35,10 @@ struct RenderThreadInfoVk {
     // Return the current thread's instance, if any, or NULL.
     static RenderThreadInfoVk* get();
 
-    uint32_t ctx_id;
+    void onSave(android::base::Stream* stream);
+    bool onLoad(android::base::Stream* stream);
+
+    uint32_t ctx_id = 0;
     VkDecoder m_vkDec;
 };
 
diff --git a/host/vulkan/SwapChainStateVk.cpp b/host/vulkan/SwapChainStateVk.cpp
index 875cdaf23..405c5c387 100644
--- a/host/vulkan/SwapChainStateVk.cpp
+++ b/host/vulkan/SwapChainStateVk.cpp
@@ -14,12 +14,6 @@ namespace vk {
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
-#define SWAPCHAINSTATE_VK_ERROR(fmt, ...)                                                     \
-    do {                                                                                      \
-        fprintf(stderr, "%s(%s:%d): " fmt "\n", __func__, __FILE__, __LINE__, ##__VA_ARGS__); \
-        fflush(stderr);                                                                       \
-    } while (0)
-
 namespace {
 
 void swap(SwapchainCreateInfoWrapper& a, SwapchainCreateInfoWrapper& b) {
@@ -198,7 +192,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
             return format.format == k_vkFormat && format.colorSpace == k_vkColorSpace;
         });
     if (iSurfaceFormat == formats.end()) {
-        SWAPCHAINSTATE_VK_ERROR("Fail to create swapchain: the format(%#" PRIx64
+        ERR("Failed to create swapchain: the format(%#" PRIx64
                                 ") with color space(%#" PRIx64 ") not supported.",
                                 static_cast<uint64_t>(k_vkFormat),
                                 static_cast<uint64_t>(k_vkColorSpace));
@@ -214,7 +208,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
     std::unordered_set<VkPresentModeKHR> presentModes(presentModes_.begin(), presentModes_.end());
     VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR;
     if (!presentModes.count(VK_PRESENT_MODE_FIFO_KHR)) {
-        SWAPCHAINSTATE_VK_ERROR("Fail to create swapchain: FIFO present mode not supported.");
+        ERR("Failed to create swapchain: FIFO present mode not supported.");
         return std::nullopt;
     }
     VkFormatProperties formatProperties = {};
@@ -225,7 +219,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
     if (!(formatFeatures & VK_FORMAT_FEATURE_BLIT_DST_BIT)) {
         // According to VUID-vkCmdBlitImage-dstImage-02000, the format features of dstImage must
         // contain VK_FORMAT_FEATURE_BLIT_DST_BIT.
-        SWAPCHAINSTATE_VK_ERROR(
+        ERR(
             "The format %s with the optimal tiling doesn't support VK_FORMAT_FEATURE_BLIT_DST_BIT. "
             "The supported features are %s.",
             string_VkFormat(k_vkFormat), string_VkFormatFeatureFlags(formatFeatures).c_str());
@@ -234,7 +228,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
     VkSurfaceCapabilitiesKHR surfaceCaps;
     VK_CHECK(vk.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &surfaceCaps));
     if (!(surfaceCaps.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT)) {
-        SWAPCHAINSTATE_VK_ERROR(
+        ERR(
             "The supported usage flags of the presentable images is %s, and don't contain "
             "VK_IMAGE_USAGE_TRANSFER_DST_BIT.",
             string_VkImageUsageFlags(surfaceCaps.supportedUsageFlags).c_str());
@@ -251,7 +245,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
         maybeExtent = VkExtent2D({width, height});
     }
     if (!maybeExtent.has_value()) {
-        SWAPCHAINSTATE_VK_ERROR("Fail to create swapchain: extent(%" PRIu64 "x%" PRIu64
+        ERR("Failed to create swapchain: extent(%" PRIu64 "x%" PRIu64
                                 ") not supported.",
                                 static_cast<uint64_t>(width), static_cast<uint64_t>(height));
         return std::nullopt;
@@ -281,7 +275,7 @@ std::optional<SwapchainCreateInfoWrapper> SwapChainStateVk::createSwapChainCi(
         .clipped = VK_TRUE,
         .oldSwapchain = VK_NULL_HANDLE});
     if (queueFamilyIndices.empty()) {
-        SWAPCHAINSTATE_VK_ERROR("Fail to create swapchain: no Vulkan queue family specified.");
+        ERR("Failed to create swapchain: no Vulkan queue family specified.");
         return std::nullopt;
     }
     if (queueFamilyIndices.size() == 1) {
diff --git a/host/vulkan/VkAndroidNativeBuffer.cpp b/host/vulkan/VkAndroidNativeBuffer.cpp
index 9832fb620..05de21d07 100644
--- a/host/vulkan/VkAndroidNativeBuffer.cpp
+++ b/host/vulkan/VkAndroidNativeBuffer.cpp
@@ -32,15 +32,15 @@
 namespace gfxstream {
 namespace vk {
 
-#define VK_ANB_ERR(fmt, ...) fprintf(stderr, "%s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+#define VK_ANB_ERR(fmt, ...) INFO(fmt, ##__VA_ARGS__);
 
 #define ENABLE_VK_ANB_DEBUG 0
 
 #if ENABLE_VK_ANB_DEBUG
 #define VK_ANB_DEBUG(fmt, ...) \
-    fprintf(stderr, "vk-anb-debug: %s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+    INFO("vk-anb-debug: " fmt, ##__VA_ARGS__);
 #define VK_ANB_DEBUG_OBJ(obj, fmt, ...) \
-    fprintf(stderr, "vk-anb-debug: %s:%d:%p " fmt "\n", __func__, __LINE__, obj, ##__VA_ARGS__);
+    INFO("vk-anb-debug: %p " fmt, obj, ##__VA_ARGS__);
 #else
 #define VK_ANB_DEBUG(fmt, ...)
 #define VK_ANB_DEBUG_OBJ(obj, fmt, ...)
@@ -185,22 +185,9 @@ VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
         };
 
 #if defined(__APPLE__)
-        VkImportMetalTextureInfoEXT metalImageImport = {
-            VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT};
-
         if (emu->instanceSupportsMoltenVK) {
-            // Change handle type requested to mtltexture
-            extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
-
-            if (out->colorBufferHandle) {
-                // TODO(b/333460957): External memory is not properly supported on MoltenVK
-                // and although this works fine, it's not valid and causing validation layer issues
-                metalImageImport.plane = VK_IMAGE_ASPECT_PLANE_0_BIT;
-                metalImageImport.mtlTexture = getColorBufferMTLTexture(out->colorBufferHandle);
-
-                // Insert metalImageImport to the chain
-                vk_insert_struct(createImageCi, metalImageImport);
-            }
+            // Change handle type requested to metal handle
+            extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
         }
 #endif
 
@@ -396,12 +383,6 @@ void teardownAndroidNativeBufferImage(VulkanDispatch* vk, AndroidNativeBufferInf
     auto mappedPtr = anbInfo->mappedStagingPtr;
     auto stagingMemory = anbInfo->stagingMemory;
 
-    if (image) vk->vkDestroyImage(device, image, nullptr);
-    if (imageMemory) vk->vkFreeMemory(device, imageMemory, nullptr);
-    if (stagingBuffer) vk->vkDestroyBuffer(device, stagingBuffer, nullptr);
-    if (mappedPtr) vk->vkUnmapMemory(device, stagingMemory);
-    if (stagingMemory) vk->vkFreeMemory(device, stagingMemory, nullptr);
-
     for (auto queueState : anbInfo->queueStates) {
         queueState.teardown(vk, device);
     }
@@ -410,6 +391,12 @@ void teardownAndroidNativeBufferImage(VulkanDispatch* vk, AndroidNativeBufferInf
 
     anbInfo->acquireQueueState.teardown(vk, device);
 
+    if (image) vk->vkDestroyImage(device, image, nullptr);
+    if (imageMemory) vk->vkFreeMemory(device, imageMemory, nullptr);
+    if (stagingBuffer) vk->vkDestroyBuffer(device, stagingBuffer, nullptr);
+    if (mappedPtr) vk->vkUnmapMemory(device, stagingMemory);
+    if (stagingMemory) vk->vkFreeMemory(device, stagingMemory, nullptr);
+
     anbInfo->vk = nullptr;
     anbInfo->device = VK_NULL_HANDLE;
     anbInfo->image = VK_NULL_HANDLE;
diff --git a/host/vulkan/VkCommonOperations.cpp b/host/vulkan/VkCommonOperations.cpp
index 2c477a521..717a2130a 100644
--- a/host/vulkan/VkCommonOperations.cpp
+++ b/host/vulkan/VkCommonOperations.cpp
@@ -67,9 +67,10 @@ using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
 #ifndef VERBOSE
-#define VERBOSE(fmt, ...)        \
-    if (android::base::isVerboseLogging()) \
-        fprintf(stderr, "%s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+#define VERBOSE(fmt, ...)                    \
+    if (android::base::isVerboseLogging()) { \
+        INFO(fmt, ##__VA_ARGS__);            \
+    }
 #endif
 
 constexpr size_t kPageBits = 12;
@@ -242,6 +243,50 @@ static bool extensionsSupported(const std::vector<VkExtensionProperties>& curren
     return true;
 }
 
+// Return true if format requires sampler YCBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image
+// views. Table found in spec
+static bool formatRequiresYcbcrConversion(VkFormat format) {
+    switch (format) {
+        case VK_FORMAT_G8B8G8R8_422_UNORM:
+        case VK_FORMAT_B8G8R8G8_422_UNORM:
+        case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
+        case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
+        case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
+        case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
+        case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
+        case VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
+        case VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
+        case VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
+        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
+        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
+        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
+        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
+        case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
+        case VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
+        case VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
+        case VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
+        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
+        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
+        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
+        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
+        case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
+        case VK_FORMAT_G16B16G16R16_422_UNORM:
+        case VK_FORMAT_B16G16R16G16_422_UNORM:
+        case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
+        case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
+        case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
+        case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
+        case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
+        case VK_FORMAT_G8_B8R8_2PLANE_444_UNORM:
+        case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
+        case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
+        case VK_FORMAT_G16_B16R16_2PLANE_444_UNORM:
+            return true;
+        default:
+            return false;
+    }
+}
+
 // For a given ImageSupportInfo, populates usageWithExternalHandles and
 // requiresDedicatedAllocation. memoryTypeBits are populated later once the
 // device is created, because that needs a test image to be created.
@@ -309,7 +354,7 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
 #if defined(__APPLE__)
     if (sVkEmulation->instanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
-        extInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
+        extInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
 #endif
 
@@ -377,11 +422,11 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
     VkExternalMemoryHandleTypeFlags compatibleHandleTypes =
         outExternalProps.externalMemoryProperties.compatibleHandleTypes;
 
-    VkExternalMemoryHandleTypeFlagBits handleTypeNeeded = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
+    VkExternalMemoryHandleTypeFlags handleTypeNeeded = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
 #if defined(__APPLE__)
     if (sVkEmulation->instanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
-        handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
+        handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
 #endif
 
@@ -732,6 +777,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     std::vector<const char*> moltenVkDeviceExtNames = {
         VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME,
         VK_EXT_METAL_OBJECTS_EXTENSION_NAME,
+        VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME,
     };
 #endif
 
@@ -753,8 +799,13 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 #if defined(__APPLE__)
     const std::string vulkanIcd = android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD");
     const bool moltenVKEnabled = (vulkanIcd == "moltenvk");
-    bool moltenVKSupported = moltenVKEnabled &&
-                             extensionsSupported(instanceExts, moltenVkInstanceExtNames);
+    const bool moltenVKSupported = extensionsSupported(instanceExts, moltenVkInstanceExtNames);
+    if (moltenVKEnabled && !moltenVKSupported) {
+        // This might happen if the user manually changes moltenvk ICD library
+        ERR("MoltenVK requested, but the required extensions are not supported.");
+        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "MoltenVK requested, but the required extensions are not supported.";
+    }
+    const bool useMoltenVK = moltenVKEnabled && moltenVKSupported;
 #endif
 
     VkInstanceCreateInfo instCi = {
@@ -811,7 +862,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
 #if defined(__APPLE__)
-    if (moltenVKSupported) {
+    if (useMoltenVK) {
         INFO("MoltenVK is supported, enabling Vulkan portability.");
         instCi.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
         for (auto extension : moltenVkInstanceExtNames) {
@@ -914,7 +965,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     sVkEmulation->instanceSupportsExternalFenceCapabilities = externalFenceCapabilitiesSupported;
     sVkEmulation->instanceSupportsSurface = surfaceSupported;
 #if defined(__APPLE__)
-    sVkEmulation->instanceSupportsMoltenVK = moltenVKSupported;
+    sVkEmulation->instanceSupportsMoltenVK = useMoltenVK;
 #endif
 
     if (sVkEmulation->instanceSupportsGetPhysicalDeviceProperties2) {
@@ -936,8 +987,9 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
 #if defined(__APPLE__)
     if (sVkEmulation->instanceSupportsMoltenVK) {
-        // Using metal_objects extension on MacOS when moltenVK is used.
+        // Enable some specific extensions on MacOS when moltenVK is used.
         externalMemoryDeviceExtNames.push_back(VK_EXT_METAL_OBJECTS_EXTENSION_NAME);
+        externalMemoryDeviceExtNames.push_back(VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME);
     } else {
         // When MoltenVK is not used(e.g. SwiftShader), use memory fd extension for external memory.
         externalMemoryDeviceExtNames.push_back(VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);
@@ -980,7 +1032,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         deviceInfos[i].glInteropSupported = 0;  // set later
 
 #if defined(__APPLE__)
-        if (moltenVKSupported && !extensionsSupported(deviceExts, moltenVkDeviceExtNames)) {
+        if (useMoltenVK && !extensionsSupported(deviceExts, moltenVkDeviceExtNames)) {
             VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(
                 ABORT_REASON_OTHER,
                 "MoltenVK enabled but necessary device extensions are not supported.");
@@ -1095,6 +1147,13 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
                 vk_append_struct(&features2Chain, &deviceDiagnosticsConfigFeatures);
             }
 
+            VkPhysicalDevicePrivateDataFeatures privateDataFeatures = {
+                .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
+                .privateData = VK_FALSE};
+            if (extensionsSupported(deviceExts, {VK_EXT_PRIVATE_DATA_EXTENSION_NAME})) {
+                vk_append_struct(&features2Chain, &privateDataFeatures);
+            }
+
             sVkEmulation->getPhysicalDeviceFeatures2Func(physdevs[i], &features2);
 
             deviceInfos[i].supportsSamplerYcbcrConversion =
@@ -1103,6 +1162,8 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             deviceInfos[i].supportsNvidiaDeviceDiagnosticCheckpoints =
                 deviceDiagnosticsConfigFeatures.diagnosticsConfig == VK_TRUE;
 
+            deviceInfos[i].supportsPrivateData = (privateDataFeatures.privateData == VK_TRUE);
+
 #if defined(__QNX__)
             deviceInfos[i].supportsExternalMemoryImport =
                 extMemScreenBufferFeatures.screenBufferImport == VK_TRUE;
@@ -1164,7 +1225,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
     auto deviceVersion = sVkEmulation->deviceInfo.physdevProps.apiVersion;
-    WARN("Selecting Vulkan device: %s, Version: %d.%d.%d",
+    INFO("Selecting Vulkan device: %s, Version: %d.%d.%d",
          sVkEmulation->deviceInfo.physdevProps.deviceName, VK_VERSION_MAJOR(deviceVersion),
          VK_VERSION_MINOR(deviceVersion), VK_VERSION_PATCH(deviceVersion));
 
@@ -1228,7 +1289,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
 #if defined(__APPLE__)
-    if (moltenVKSupported) {
+    if (useMoltenVK) {
         for (auto extension : moltenVkDeviceExtNames) {
             selectedDeviceExtensionNames_.emplace(extension);
         }
@@ -1350,11 +1411,11 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
 #else
         if (sVkEmulation->instanceSupportsMoltenVK) {
-            // vkExportMetalObjectsEXT will be used directly
+            // We'll use vkGetMemoryMetalHandleEXT, no need to save into getMemoryHandleFunc
             sVkEmulation->deviceInfo.getMemoryHandleFunc = nullptr;
-            if (!dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkExportMetalObjectsEXT")) {
+            if (!dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkGetMemoryMetalHandleEXT")) {
                 VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
-                                                     "Cannot find vkExportMetalObjectsEXT");
+                                                     "Cannot find vkGetMemoryMetalHandleEXT");
             }
         } else {
             // Use vkGetMemoryFdKHR
@@ -1640,30 +1701,25 @@ std::unique_ptr<gfxstream::DisplaySurface> createDisplaySurface(FBNativeWindowTy
 }
 
 #ifdef __APPLE__
-static MTLBufferRef getMtlBufferFromVkDeviceMemory(VulkanDispatch* vk, VkDeviceMemory memory) {
-    VkExportMetalBufferInfoEXT exportMetalBufferInfo = {
-        VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT, nullptr, memory, VK_NULL_HANDLE};
-    VkExportMetalObjectsInfoEXT metalObjectsInfo = {VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
-                                                    &exportMetalBufferInfo};
-    vk->vkExportMetalObjectsEXT(sVkEmulation->device, &metalObjectsInfo);
-
-    return exportMetalBufferInfo.mtlBuffer;
-}
+static MTLResource_id getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk, VkDeviceMemory memory) {
+    if (memory == VK_NULL_HANDLE) {
+        WARN("Requested metal resource handle for null memory!");
+        return nullptr;
+    }
 
-static MTLTextureRef getMtlTextureFromVkImage(VulkanDispatch* vk, VkImage image) {
-    VkExportMetalTextureInfoEXT exportMetalTextureInfo = {
-        VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
+    VkMemoryGetMetalHandleInfoEXT getMetalHandleInfo = {
+        VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT,
         nullptr,
-        image,
-        VK_NULL_HANDLE,
-        VK_NULL_HANDLE,
-        VK_IMAGE_ASPECT_PLANE_0_BIT,
-        VK_NULL_HANDLE};
-    VkExportMetalObjectsInfoEXT metalObjectsInfo = {VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
-                                                    &exportMetalTextureInfo};
-    vk->vkExportMetalObjectsEXT(sVkEmulation->device, &metalObjectsInfo);
+        memory,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT
+    };
 
-    return exportMetalTextureInfo.mtlTexture;
+    MTLResource_id outputHandle = nullptr;
+    vk->vkGetMemoryMetalHandleEXT(sVkEmulation->device, &getMetalHandleInfo, &outputHandle);
+    if (outputHandle == nullptr) {
+        ERR("vkGetMemoryMetalHandleEXT returned null");
+    }
+    return outputHandle;
 }
 #endif
 
@@ -1694,24 +1750,15 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
 
     auto allocInfoChain = vk_make_chain_iterator(&allocInfo);
 
-#ifdef __APPLE__
-    // On MoltenVK, use metal objects to export metal handles
-    VkExportMetalObjectCreateInfoEXT metalBufferExport = {
-        VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, nullptr,
-        VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT};
-#endif
 
     if (sVkEmulation->deviceInfo.supportsExternalMemoryExport && actuallyExternal) {
 #ifdef __APPLE__
         if (sVkEmulation->instanceSupportsMoltenVK) {
-            // Change handle type to metal buffers
-            exportAi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_KHR;
-
-            // Append metal buffer export for getting metal handles for the allocation
-            vk_append_struct(&allocInfoChain, &metalBufferExport);
+            // Change handle type for metal resources
+            exportAi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
         }
 #endif
-        if (sVkEmulation->deviceInfo.supportsDmaBuf && actuallyExternal) {
+        if (sVkEmulation->deviceInfo.supportsDmaBuf) {
             exportAi.handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
         }
 
@@ -1815,11 +1862,12 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
     validHandle = (VK_EXT_MEMORY_HANDLE_INVALID != info->externalHandle);
     info->streamHandleType = STREAM_MEM_HANDLE_TYPE_OPAQUE_WIN32;
 #elif !defined(__QNX__)
-    bool opaque_fd = true;
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        opaque_fd = false;
+
+    bool opaqueFd = true;
 #if defined(__APPLE__)
-        info->externalMetalHandle = getMtlBufferFromVkDeviceMemory(vk, info->memory);
+    if (sVkEmulation->instanceSupportsMoltenVK) {
+        opaqueFd = false;
+        info->externalMetalHandle = getMtlResourceFromVkDeviceMemory(vk, info->memory);
         validHandle = (nullptr != info->externalMetalHandle);
         if (validHandle) {
             CFRetain(info->externalMetalHandle);
@@ -1827,9 +1875,10 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
         } else {
             exportRes = VK_ERROR_INVALID_EXTERNAL_HANDLE;
         }
-#endif
     }
-    if (opaque_fd) {
+#endif
+
+    if (opaqueFd) {
         if (sVkEmulation->deviceInfo.supportsDmaBuf) {
             vkHandleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
             info->streamHandleType = STREAM_MEM_HANDLE_TYPE_DMABUF;
@@ -1916,25 +1965,29 @@ bool importExternalMemory(VulkanDispatch* vk, VkDevice targetDevice,
     };
     importInfoPtr = &importInfo;
 #else
-    VkImportMemoryFdInfoKHR importInfoFd = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
-        0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-        VK_EXT_MEMORY_HANDLE_INVALID,
-    };
 
+    bool opaqueFd = true;
 #ifdef __APPLE__
-    VkImportMetalBufferInfoEXT importInfoMetalBuffer = {
-        VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
+    VkImportMemoryMetalHandleInfoEXT importInfoMetalInfo = {
+        VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
         0,
-        nullptr,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
+        nullptr
     };
     if (sVkEmulation->instanceSupportsMoltenVK) {
-        importInfoMetalBuffer.mtlBuffer = info->externalMetalHandle;
-        importInfoPtr = &importInfoMetalBuffer;
-    } else
+        opaqueFd = false;
+        importInfoMetalInfo.handle = info->externalMetalHandle;
+        importInfoPtr = &importInfoMetalInfo;
+    }
 #endif
-    {
+
+    VkImportMemoryFdInfoKHR importInfoFd = {
+        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
+        0,
+        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        VK_EXT_MEMORY_HANDLE_INVALID,
+    };
+    if (opaqueFd) {
         importInfoFd.fd = dupExternalMemory(info->externalHandle);
         importInfoPtr = &importInfoFd;
     }
@@ -1984,25 +2037,29 @@ bool importExternalMemoryDedicatedImage(VulkanDispatch* vk, VkDevice targetDevic
     };
     importInfoPtr = &importInfo;
 #else
-    VkImportMemoryFdInfoKHR importInfoFd = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
-        &dedicatedInfo,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-        -1,
-    };
 
+    bool opaqueFd = true;
 #ifdef __APPLE__
-    VkImportMetalBufferInfoEXT importInfoMetalBuffer = {
-        VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
+    VkImportMemoryMetalHandleInfoEXT importInfoMetalInfo = {
+        VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
         &dedicatedInfo,
-        nullptr,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
+        nullptr
     };
     if (sVkEmulation->instanceSupportsMoltenVK) {
-        importInfoMetalBuffer.mtlBuffer = info->externalMetalHandle;
-        importInfoPtr = &importInfoMetalBuffer;
-    } else
+        importInfoMetalInfo.handle = info->externalMetalHandle;
+        importInfoPtr = &importInfoMetalInfo;
+        opaqueFd = false;
+    }
 #endif
-    {
+
+    VkImportMemoryFdInfoKHR importInfoFd = {
+        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
+        &dedicatedInfo,
+        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        -1,
+    };
+    if (opaqueFd) {
         importInfoFd.fd = dupExternalMemory(info->externalHandle);
         importInfoPtr = &importInfoFd;
     }
@@ -2302,6 +2359,14 @@ static bool updateExternalMemoryInfo(VK_EXT_MEMORY_HANDLE extMemHandle,
     pInfo->size = screenBufferProps.allocationSize;
 #endif
 
+#ifdef __APPLE__
+    // importExtMemoryHandleToVkColorBuffer is not supported with MoltenVK
+    if (sVkEmulation->instanceSupportsMoltenVK) {
+        WARN("Unexpected call to updateExternalMemoryInfo!");
+        pInfo->externalMetalHandle = nullptr;
+    }
+#endif
+
     return true;
 }
 
@@ -2390,15 +2455,9 @@ bool initializeVkColorBufferLocked(
         VK_EXT_MEMORY_HANDLE_TYPE_BIT,
     };
 #if defined(__APPLE__)
-    VkExportMetalObjectCreateInfoEXT metalImageExportCI = {
-        VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, nullptr,
-        VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT};
-
     if (sVkEmulation->instanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
-        extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
-
-        extImageCi.pNext = &metalImageExportCI;
+        extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
 #endif
 
@@ -2451,12 +2510,15 @@ bool initializeVkColorBufferLocked(
     infoPtr->memory.typeIndex =
         getValidMemoryTypeIndex(infoPtr->memReqs.memoryTypeBits, infoPtr->memoryProperty);
 
+    const VkFormat imageVkFormat = infoPtr->imageCreateInfoShallow.format;
     VERBOSE(
-        "ColorBuffer %d, "
+        "ColorBuffer %d, dimensions: %dx%d, format: %s, "
         "allocation size and type index: %lu, %d, "
         "allocated memory property: %d, "
         "requested memory property: %d",
-        colorBufferHandle, infoPtr->memory.size, infoPtr->memory.typeIndex,
+        colorBufferHandle, infoPtr->width, infoPtr->height,
+        string_VkFormat(imageVkFormat),
+        infoPtr->memory.size, infoPtr->memory.typeIndex,
         sVkEmulation->deviceInfo.memProps.memoryTypes[infoPtr->memory.typeIndex].propertyFlags,
         infoPtr->memoryProperty);
 
@@ -2506,13 +2568,43 @@ bool initializeVkColorBufferLocked(
         return false;
     }
 
+    VkSamplerYcbcrConversionInfo ycbcrInfo = {VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
+                                              nullptr, VK_NULL_HANDLE};
+    const bool addConversion = formatRequiresYcbcrConversion(imageVkFormat);
+    if (addConversion) {
+        VkSamplerYcbcrConversionCreateInfo ycbcrCreateInfo = {
+            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
+            nullptr,
+            imageVkFormat,
+            VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
+            VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
+            {VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY,
+             VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY},
+            VK_CHROMA_LOCATION_MIDPOINT,
+            VK_CHROMA_LOCATION_MIDPOINT,
+            VK_FILTER_NEAREST,
+            VK_FALSE};
+
+        createRes = vk->vkCreateSamplerYcbcrConversion(sVkEmulation->device, &ycbcrCreateInfo,
+                                                       nullptr, &infoPtr->ycbcrConversion);
+        if (createRes != VK_SUCCESS) {
+            VERBOSE(
+                "Failed to create Vulkan ycbcrConversion for ColorBuffer %d with format %s [%d], "
+                "Error: %s",
+                colorBufferHandle, string_VkFormat(imageVkFormat), imageVkFormat,
+                string_VkResult(createRes));
+            return false;
+        }
+        ycbcrInfo.conversion = infoPtr->ycbcrConversion;
+    }
+
     const VkImageViewCreateInfo imageViewCi = {
         .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
-        .pNext = nullptr,
+        .pNext = addConversion ? &ycbcrInfo : nullptr,
         .flags = 0,
         .image = infoPtr->image,
         .viewType = VK_IMAGE_VIEW_TYPE_2D,
-        .format = infoPtr->imageCreateInfoShallow.format,
+        .format = imageVkFormat,
         .components =
             {
                 .r = VK_COMPONENT_SWIZZLE_IDENTITY,
@@ -2537,14 +2629,6 @@ bool initializeVkColorBufferLocked(
         return false;
     }
 
-#if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        // Retrieve metal texture for this image
-        infoPtr->mtlTexture = getMtlTextureFromVkImage(vk, infoPtr->image);
-        CFRetain(infoPtr->mtlTexture);
-    }
-#endif
-
     sVkEmulation->debugUtilsHelper.addDebugLabel(infoPtr->image, "ColorBuffer:%d",
                                                  colorBufferHandle);
     sVkEmulation->debugUtilsHelper.addDebugLabel(infoPtr->imageView, "ColorBuffer:%d",
@@ -2690,14 +2774,9 @@ bool teardownVkColorBufferLocked(uint32_t colorBufferHandle) {
             VK_CHECK(vk->vkQueueWaitIdle(sVkEmulation->queue));
         }
         vk->vkDestroyImageView(sVkEmulation->device, info.imageView, nullptr);
+        vk->vkDestroySamplerYcbcrConversion(sVkEmulation->device, info.ycbcrConversion, nullptr);
         vk->vkDestroyImage(sVkEmulation->device, info.image, nullptr);
         freeExternalMemoryLocked(vk, &info.memory);
-
-#ifdef __APPLE__
-        if (info.mtlTexture) {
-            CFRelease(info.mtlTexture);
-        }
-#endif
     }
 
     sVkEmulation->colorBuffers.erase(colorBufferHandle);
@@ -2803,7 +2882,7 @@ bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* by
 
     result = readColorBufferToBytesLocked(
         colorBufferHandle, 0, 0, colorBufferInfo->imageCreateInfoShallow.extent.width,
-        colorBufferInfo->imageCreateInfoShallow.extent.height, bytes->data());
+        colorBufferInfo->imageCreateInfoShallow.extent.height, bytes->data(), bytes->size());
     if (!result) {
         ERR("Failed to read from ColorBuffer:%d, failed to get read size.", colorBufferHandle);
         return false;
@@ -2813,18 +2892,18 @@ bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* by
 }
 
 bool readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                            uint32_t h, void* outPixels) {
+                            uint32_t h, void* outPixels, uint64_t outPixelsSize) {
     if (!sVkEmulation || !sVkEmulation->live) {
         ERR("VkEmulation not available.");
         return false;
     }
 
     AutoLock lock(sVkEmulationLock);
-    return readColorBufferToBytesLocked(colorBufferHandle, x, y, w, h, outPixels);
+    return readColorBufferToBytesLocked(colorBufferHandle, x, y, w, h, outPixels, outPixelsSize);
 }
 
 bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                  uint32_t h, void* outPixels) {
+                                  uint32_t h, void* outPixels, uint64_t outPixelsSize) {
     if (!sVkEmulation || !sVkEmulation->live) {
         ERR("VkEmulation not available.");
         return false;
@@ -2967,9 +3046,18 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
+    VkResult waitRes = vk->vkWaitForFences(
+        sVkEmulation->device, 1, &sVkEmulation->commandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS);
+    if (waitRes == VK_TIMEOUT) {
+        // Give a warning and try once more on a timeout error
+        ERR("readColorBufferToBytesLocked vkWaitForFences failed with timeout error "
+            "(cb:%d, x:%d, y:%d, w:%d, h:%d, bufferCopySize:%llu), retrying...",
+            colorBufferHandle, x, y, w, h, bufferCopySize);
+        waitRes = vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
+                                      VK_TRUE, ANB_MAX_WAIT_NS*2);
+    }
 
-    VK_CHECK(vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
-                                 VK_TRUE, ANB_MAX_WAIT_NS));
+    VK_CHECK(waitRes);
 
     VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence));
 
@@ -2984,6 +3072,12 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
     VK_CHECK(vk->vkInvalidateMappedMemoryRanges(sVkEmulation->device, 1, &toInvalidate));
 
     const auto* stagingBufferPtr = sVkEmulation->staging.memory.mappedPtr;
+    if (bufferCopySize > outPixelsSize) {
+        ERR("Invalid buffer size for readColorBufferToBytes operation."
+            "Required: %llu, Actual: %llu",
+            bufferCopySize, outPixelsSize);
+        bufferCopySize = outPixelsSize;
+    }
     std::memcpy(outPixels, stagingBufferPtr, bufferCopySize);
 
     return true;
@@ -3241,7 +3335,7 @@ VK_EXT_MEMORY_HANDLE getColorBufferExtMemoryHandle(uint32_t colorBuffer) {
 }
 
 #ifdef __APPLE__
-MTLBufferRef getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
+MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
     if (!sVkEmulation || !sVkEmulation->live) return nullptr;
 
     AutoLock lock(sVkEmulationLock);
@@ -3256,23 +3350,7 @@ MTLBufferRef getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
     return infoPtr->memory.externalMetalHandle;
 }
 
-MTLTextureRef getColorBufferMTLTexture(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return nullptr;
-
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-
-    if (!infoPtr) {
-        // Color buffer not found; this is usually OK.
-        return nullptr;
-    }
-
-    CFRetain(infoPtr->mtlTexture);
-    return infoPtr->mtlTexture;
-}
-
-// TODO(b/333460957): Temporary function for MoltenVK
+// TODO0(b/351765838): Temporary function for MoltenVK
 VkImage getColorBufferVkImage(uint32_t colorBufferHandle) {
     if (!sVkEmulation || !sVkEmulation->live) return nullptr;
 
@@ -3422,6 +3500,12 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
         0,
         VK_EXT_MEMORY_HANDLE_TYPE_BIT,
     };
+#if defined(__APPLE__)
+    if (sVkEmulation->instanceSupportsMoltenVK) {
+        // Using a different handle type when in MoltenVK mode
+        extBufferCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
+    }
+#endif
     void* extBufferCiPtr = nullptr;
     if (sVkEmulation->deviceInfo.supportsExternalMemoryImport ||
         sVkEmulation->deviceInfo.supportsExternalMemoryExport) {
@@ -3563,7 +3647,7 @@ VK_EXT_MEMORY_HANDLE getBufferExtMemoryHandle(uint32_t bufferHandle,
 }
 
 #ifdef __APPLE__
-MTLBufferRef getBufferMetalMemoryHandle(uint32_t bufferHandle) {
+MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle) {
     if (!sVkEmulation || !sVkEmulation->live) return nullptr;
 
     AutoLock lock(sVkEmulationLock);
@@ -3781,7 +3865,7 @@ VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_tohost(
 #if defined(__APPLE__)
         if (sVkEmulation->instanceSupportsMoltenVK) {
             // Using a different handle type when in MoltenVK mode
-            handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
+            handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
         }
 #endif
         res |= handleTypeNeeded;
@@ -3812,7 +3896,7 @@ VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_fromhost(
 #if defined(__APPLE__)
     if (sVkEmulation->instanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
-        handleTypeUsed = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR;
+        handleTypeUsed = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
 #endif
     if ((res & handleTypeUsed) == handleTypeUsed) {
diff --git a/host/vulkan/VkCommonOperations.h b/host/vulkan/VkCommonOperations.h
index 3f7b3d0b9..389182745 100644
--- a/host/vulkan/VkCommonOperations.h
+++ b/host/vulkan/VkCommonOperations.h
@@ -216,6 +216,7 @@ struct VkEmulation {
         bool glInteropSupported = false;
         bool hasNvidiaDeviceDiagnosticCheckpointsExtension = false;
         bool supportsNvidiaDeviceDiagnosticCheckpoints = false;
+        bool supportsPrivateData = false;
 
         std::vector<VkExtensionProperties> extensions;
 
@@ -266,7 +267,7 @@ struct VkEmulation {
         VK_EXT_MEMORY_HANDLE externalHandle = VK_EXT_MEMORY_HANDLE_INVALID;
 #ifdef __APPLE__
         // This is used as an external handle when MoltenVK is enabled
-        MTLBufferRef externalMetalHandle = nullptr;
+        MTLResource_id externalMetalHandle = nullptr;
 #endif
         uint32_t streamHandleType;
 
@@ -339,6 +340,7 @@ struct VkEmulation {
 
         VkImage image = VK_NULL_HANDLE;
         VkImageView imageView = VK_NULL_HANDLE;
+        VkSamplerYcbcrConversion ycbcrConversion = VK_NULL_HANDLE;
         VkImageCreateInfo imageCreateInfoShallow = {};
         VkMemoryRequirements memReqs;
 
@@ -350,10 +352,6 @@ struct VkEmulation {
 
         VulkanMode vulkanMode = VulkanMode::Default;
 
-#if defined(__APPLE__)
-        MTLTextureRef mtlTexture = nullptr;
-#endif
-
         std::optional<DeviceOpWaitable> latestUse;
         DeviceOpTrackerPtr latestUseTracker = nullptr;
     };
@@ -514,8 +512,7 @@ bool importExtMemoryHandleToVkColorBuffer(uint32_t colorBufferHandle, uint32_t t
 VkEmulation::ColorBufferInfo getColorBufferInfo(uint32_t colorBufferHandle);
 VK_EXT_MEMORY_HANDLE getColorBufferExtMemoryHandle(uint32_t colorBufferHandle);
 #ifdef __APPLE__
-MTLBufferRef getColorBufferMetalMemoryHandle(uint32_t colorBufferHandle);
-MTLTextureRef getColorBufferMTLTexture(uint32_t colorBufferHandle);
+MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBufferHandle);
 VkImage getColorBufferVkImage(uint32_t colorBufferHandle);
 #endif
 
@@ -535,9 +532,9 @@ bool colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle);
 
 bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* bytes);
 bool readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                            uint32_t h, void* outPixels);
+                            uint32_t h, void* outPixels, uint64_t outPixelsSize);
 bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                  uint32_t h, void* outPixels);
+                                  uint32_t h, void* outPixels, uint64_t outPixelsSize);
 
 bool updateColorBufferFromBytes(uint32_t colorBufferHandle, const std::vector<uint8_t>& bytes);
 bool updateColorBufferFromBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
@@ -553,7 +550,7 @@ bool teardownVkBuffer(uint32_t bufferHandle);
 
 VK_EXT_MEMORY_HANDLE getBufferExtMemoryHandle(uint32_t bufferHandle, uint32_t* outStreamHandleType);
 #ifdef __APPLE__
-MTLBufferRef getBufferMetalMemoryHandle(uint32_t bufferHandle);
+MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle);
 #endif
 
 bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, void* outBytes);
diff --git a/host/vulkan/VkDecoder.cpp b/host/vulkan/VkDecoder.cpp
index 5b99c8db3..ccc354a70 100644
--- a/host/vulkan/VkDecoder.cpp
+++ b/host/vulkan/VkDecoder.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module VkDecoder
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -667,15 +668,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 VkPhysicalDevice physicalDevice;
                 uint32_t* pQueueFamilyPropertyCount;
                 VkQueueFamilyProperties* pQueueFamilyProperties;
-                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
+                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
-                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
-                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
-                // End manual dispatchable handle unboxing for physicalDevice;
                 // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -721,8 +719,8 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pQueueFamilyPropertyCount,
                             (unsigned long long)pQueueFamilyProperties);
                 }
-                vk->vkGetPhysicalDeviceQueueFamilyProperties(
-                    unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                m_state->on_vkGetPhysicalDeviceQueueFamilyProperties(
+                    &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
@@ -1724,7 +1722,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkDeviceMemory*)&memory =
                     (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_1));
                 boxed_memory_preserve = memory;
-                memory = unbox_VkDeviceMemory(memory);
+                memory = try_unbox_VkDeviceMemory(memory);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -2683,7 +2681,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkFence*)&fence = (VkFence)(VkFence)((VkFence)(*&cgen_var_1));
                 boxed_fence_preserve = fence;
-                fence = unbox_VkFence(fence);
+                fence = try_unbox_VkFence(fence);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -2971,7 +2969,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkSemaphore*)&semaphore = (VkSemaphore)(VkSemaphore)((VkSemaphore)(*&cgen_var_1));
                 boxed_semaphore_preserve = semaphore;
-                semaphore = unbox_VkSemaphore(semaphore);
+                semaphore = try_unbox_VkSemaphore(semaphore);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -3106,7 +3104,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkEvent*)&event = (VkEvent)(VkEvent)((VkEvent)(*&cgen_var_1));
                 boxed_event_preserve = event;
-                event = unbox_VkEvent(event);
+                event = try_unbox_VkEvent(event);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -3368,7 +3366,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueryPool*)&queryPool = (VkQueryPool)(VkQueryPool)((VkQueryPool)(*&cgen_var_1));
                 boxed_queryPool_preserve = queryPool;
-                queryPool = unbox_VkQueryPool(queryPool);
+                queryPool = try_unbox_VkQueryPool(queryPool);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -3573,7 +3571,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkBuffer*)&buffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_1));
                 boxed_buffer_preserve = buffer;
-                buffer = unbox_VkBuffer(buffer);
+                buffer = try_unbox_VkBuffer(buffer);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -3713,7 +3711,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkBufferView*)&bufferView =
                     (VkBufferView)(VkBufferView)((VkBufferView)(*&cgen_var_1));
                 boxed_bufferView_preserve = bufferView;
-                bufferView = unbox_VkBufferView(bufferView);
+                bufferView = try_unbox_VkBufferView(bufferView);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -3842,7 +3840,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkImage*)&image = (VkImage)(VkImage)((VkImage)(*&cgen_var_1));
                 boxed_image_preserve = image;
-                image = unbox_VkImage(image);
+                image = try_unbox_VkImage(image);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -4039,7 +4037,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkImageView*)&imageView = (VkImageView)(VkImageView)((VkImageView)(*&cgen_var_1));
                 boxed_imageView_preserve = imageView;
-                imageView = unbox_VkImageView(imageView);
+                imageView = try_unbox_VkImageView(imageView);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -4178,7 +4176,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkShaderModule*)&shaderModule =
                     (VkShaderModule)(VkShaderModule)((VkShaderModule)(*&cgen_var_1));
                 boxed_shaderModule_preserve = shaderModule;
-                shaderModule = unbox_VkShaderModule(shaderModule);
+                shaderModule = try_unbox_VkShaderModule(shaderModule);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -4315,7 +4313,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkPipelineCache*)&pipelineCache =
                     (VkPipelineCache)(VkPipelineCache)((VkPipelineCache)(*&cgen_var_1));
                 boxed_pipelineCache_preserve = pipelineCache;
-                pipelineCache = unbox_VkPipelineCache(pipelineCache);
+                pipelineCache = try_unbox_VkPipelineCache(pipelineCache);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -4620,14 +4618,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 const VkComputePipelineCreateInfo* pCreateInfos;
                 const VkAllocationCallbacks* pAllocator;
                 VkPipeline* pPipelines;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
-                auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -4685,17 +4680,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                 }
                 VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
-                vkCreateComputePipelines_VkResult_return =
-                    vk->vkCreateComputePipelines(unboxed_device, pipelineCache, createInfoCount,
-                                                 pCreateInfos, pAllocator, pPipelines);
+                vkCreateComputePipelines_VkResult_return = m_state->on_vkCreateComputePipelines(
+                    &m_pool, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
+                    pPipelines);
                 if ((vkCreateComputePipelines_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateComputePipelines_VkResult_return, opcode,
                                              context);
                 vkStream->unsetHandleMapping();
-                // Begin auto non dispatchable handle create for pPipelines;
-                if (vkCreateComputePipelines_VkResult_return == VK_SUCCESS)
-                    vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
+                // Begin manual non dispatchable handle create for pPipelines;
+                vkStream->unsetHandleMapping();
                 if (((createInfoCount))) {
                     uint64_t* cgen_var_4;
                     vkStream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
@@ -4705,7 +4699,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                                                                      ((createInfoCount)));
                     vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                 }
-                // Begin auto non dispatchable handle create for pPipelines;
+                // Begin manual non dispatchable handle create for pPipelines;
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
@@ -4741,7 +4735,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPipeline*)&pipeline = (VkPipeline)(VkPipeline)((VkPipeline)(*&cgen_var_1));
                 boxed_pipeline_preserve = pipeline;
-                pipeline = unbox_VkPipeline(pipeline);
+                pipeline = try_unbox_VkPipeline(pipeline);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -4887,7 +4881,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkPipelineLayout*)&pipelineLayout =
                     (VkPipelineLayout)(VkPipelineLayout)((VkPipelineLayout)(*&cgen_var_1));
                 boxed_pipelineLayout_preserve = pipelineLayout;
-                pipelineLayout = unbox_VkPipelineLayout(pipelineLayout);
+                pipelineLayout = try_unbox_VkPipelineLayout(pipelineLayout);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -5026,7 +5020,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkSampler*)&sampler = (VkSampler)(VkSampler)((VkSampler)(*&cgen_var_1));
                 boxed_sampler_preserve = sampler;
-                sampler = unbox_VkSampler(sampler);
+                sampler = try_unbox_VkSampler(sampler);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -5169,7 +5163,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     (VkDescriptorSetLayout)(VkDescriptorSetLayout)((
                         VkDescriptorSetLayout)(*&cgen_var_1));
                 boxed_descriptorSetLayout_preserve = descriptorSetLayout;
-                descriptorSetLayout = unbox_VkDescriptorSetLayout(descriptorSetLayout);
+                descriptorSetLayout = try_unbox_VkDescriptorSetLayout(descriptorSetLayout);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -5309,7 +5303,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkDescriptorPool*)&descriptorPool =
                     (VkDescriptorPool)(VkDescriptorPool)((VkDescriptorPool)(*&cgen_var_1));
                 boxed_descriptorPool_preserve = descriptorPool;
-                descriptorPool = unbox_VkDescriptorPool(descriptorPool);
+                descriptorPool = try_unbox_VkDescriptorPool(descriptorPool);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -5518,7 +5512,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 for (uint32_t i = 0; i < ((descriptorSetCount)); ++i) {
                     boxed_pDescriptorSets_preserve[i] = pDescriptorSets[i];
                     ((VkDescriptorSet*)(pDescriptorSets))[i] =
-                        unbox_VkDescriptorSet(pDescriptorSets[i]);
+                        try_unbox_VkDescriptorSet(pDescriptorSets[i]);
                 }
                 if (m_logCalls) {
                     fprintf(stderr,
@@ -5723,7 +5717,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkFramebuffer*)&framebuffer =
                     (VkFramebuffer)(VkFramebuffer)((VkFramebuffer)(*&cgen_var_1));
                 boxed_framebuffer_preserve = framebuffer;
-                framebuffer = unbox_VkFramebuffer(framebuffer);
+                framebuffer = try_unbox_VkFramebuffer(framebuffer);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -5858,7 +5852,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkRenderPass*)&renderPass =
                     (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_1));
                 boxed_renderPass_preserve = renderPass;
-                renderPass = unbox_VkRenderPass(renderPass);
+                renderPass = try_unbox_VkRenderPass(renderPass);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -6048,7 +6042,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkCommandPool*)&commandPool =
                     (VkCommandPool)(VkCommandPool)((VkCommandPool)(*&cgen_var_1));
                 boxed_commandPool_preserve = commandPool;
-                commandPool = unbox_VkCommandPool(commandPool);
+                commandPool = try_unbox_VkCommandPool(commandPool);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -6251,7 +6245,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 for (uint32_t i = 0; i < ((commandBufferCount)); ++i) {
                     boxed_pCommandBuffers_preserve[i] = pCommandBuffers[i];
                     ((VkCommandBuffer*)(pCommandBuffers))[i] =
-                        unbox_VkCommandBuffer(pCommandBuffers[i]);
+                        try_unbox_VkCommandBuffer(pCommandBuffers[i]);
                 }
                 if (m_logCalls) {
                     fprintf(stderr,
@@ -9643,15 +9637,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 VkPhysicalDevice physicalDevice;
                 uint32_t* pQueueFamilyPropertyCount;
                 VkQueueFamilyProperties2* pQueueFamilyProperties;
-                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
+                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
-                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
-                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
-                // End manual dispatchable handle unboxing for physicalDevice;
                 // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -9697,8 +9688,8 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pQueueFamilyPropertyCount,
                             (unsigned long long)pQueueFamilyProperties);
                 }
-                vk->vkGetPhysicalDeviceQueueFamilyProperties2(
-                    unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                m_state->on_vkGetPhysicalDeviceQueueFamilyProperties2(
+                    &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
@@ -10101,7 +10092,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((
                         VkSamplerYcbcrConversion)(*&cgen_var_1));
                 boxed_ycbcrConversion_preserve = ycbcrConversion;
-                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
+                ycbcrConversion = try_unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -10252,7 +10243,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         VkDescriptorUpdateTemplate)(*&cgen_var_1));
                 boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                 descriptorUpdateTemplate =
-                    unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
+                    try_unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -11523,7 +11514,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkPrivateDataSlot*)&privateDataSlot =
                     (VkPrivateDataSlot)(VkPrivateDataSlot)((VkPrivateDataSlot)(*&cgen_var_1));
                 boxed_privateDataSlot_preserve = privateDataSlot;
-                privateDataSlot = unbox_VkPrivateDataSlot(privateDataSlot);
+                privateDataSlot = try_unbox_VkPrivateDataSlot(privateDataSlot);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -13266,7 +13257,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkSwapchainKHR*)&swapchain =
                     (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)(*&cgen_var_1));
                 boxed_swapchain_preserve = swapchain;
-                swapchain = unbox_VkSwapchainKHR(swapchain);
+                swapchain = try_unbox_VkSwapchainKHR(swapchain);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -13481,14 +13472,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                                       "VkDecoder vkQueuePresentKHR");
                 VkQueue queue;
                 const VkPresentInfoKHR* pPresentInfo;
-                // Begin non wrapped dispatchable handle unboxing for queue;
+                // Begin global wrapped dispatchable handle unboxing for queue;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
-                auto unboxed_queue = unbox_VkQueue(queue);
-                auto vk = dispatch_VkQueue(queue);
-                // End manual dispatchable handle unboxing for queue;
                 vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                 reservedunmarshal_VkPresentInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkPresentInfoKHR*)(pPresentInfo),
@@ -13502,7 +13490,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                 vkQueuePresentKHR_VkResult_return =
-                    vk->vkQueuePresentKHR(unboxed_queue, pPresentInfo);
+                    m_state->on_vkQueuePresentKHR(&m_pool, queue, pPresentInfo);
                 if ((vkQueuePresentKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueuePresentKHR_VkResult_return, opcode, context);
@@ -14801,7 +14789,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         VkDescriptorUpdateTemplate)(*&cgen_var_1));
                 boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                 descriptorUpdateTemplate =
-                    unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
+                    try_unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -15651,7 +15639,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((
                         VkSamplerYcbcrConversion)(*&cgen_var_1));
                 boxed_ycbcrConversion_preserve = ycbcrConversion;
-                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
+                ycbcrConversion = try_unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -17564,6 +17552,50 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 break;
             }
 #endif
+#ifdef VK_KHR_line_rasterization
+            case OP_vkCmdSetLineStippleKHR: {
+                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
+                                      "VkDecoder vkCmdSetLineStippleKHR");
+                VkCommandBuffer commandBuffer;
+                uint32_t lineStippleFactor;
+                uint16_t lineStipplePattern;
+                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
+                uint64_t cgen_var_0;
+                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
+                *readStreamPtrPtr += 1 * 8;
+                *(VkCommandBuffer*)&commandBuffer =
+                    (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
+                // End manual dispatchable handle unboxing for commandBuffer;
+                memcpy((uint32_t*)&lineStippleFactor, *readStreamPtrPtr, sizeof(uint32_t));
+                *readStreamPtrPtr += sizeof(uint32_t);
+                memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
+                *readStreamPtrPtr += sizeof(uint16_t);
+                if (m_logCalls) {
+                    fprintf(stderr,
+                            "stream %p: call vkCmdSetLineStippleKHR 0x%llx 0x%llx 0x%llx \n",
+                            ioStream, (unsigned long long)commandBuffer,
+                            (unsigned long long)lineStippleFactor,
+                            (unsigned long long)lineStipplePattern);
+                }
+                vk->vkCmdSetLineStippleKHR(unboxed_commandBuffer, lineStippleFactor,
+                                           lineStipplePattern);
+                vkStream->unsetHandleMapping();
+                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
+                                         (uintptr_t)snapshotTraceBegin);
+                size_t snapshotTraceBytes = vkReadStream->endTrace();
+                if (m_state->snapshotsEnabled()) {
+                    m_state->snapshot()->vkCmdSetLineStippleKHR(
+                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        lineStippleFactor, lineStipplePattern);
+                }
+                vkReadStream->clearPool();
+                if (m_queueSubmitWithCommandsEnabled)
+                    seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
+                break;
+            }
+#endif
 #ifdef VK_ANDROID_native_buffer
             case OP_vkGetSwapchainGrallocUsageANDROID: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
@@ -17946,7 +17978,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     (VkDebugReportCallbackEXT)(VkDebugReportCallbackEXT)((
                         VkDebugReportCallbackEXT)(*&cgen_var_1));
                 boxed_callback_preserve = callback;
-                callback = unbox_VkDebugReportCallbackEXT(callback);
+                callback = try_unbox_VkDebugReportCallbackEXT(callback);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -18876,7 +18908,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     (VkDebugUtilsMessengerEXT)(VkDebugUtilsMessengerEXT)((
                         VkDebugUtilsMessengerEXT)(*&cgen_var_1));
                 boxed_messenger_preserve = messenger;
-                messenger = unbox_VkDebugUtilsMessengerEXT(messenger);
+                messenger = try_unbox_VkDebugUtilsMessengerEXT(messenger);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -21312,7 +21344,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *(VkDeviceMemory*)&memory =
                     (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_1));
                 boxed_memory_preserve = memory;
-                memory = unbox_VkDeviceMemory(memory);
+                memory = try_unbox_VkDeviceMemory(memory);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -22767,6 +22799,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
             }
         }
         ptr += packetLen;
+        vkStream->clearPool();
     }
     if (m_forSnapshotLoad) {
         m_state->clearCreatedHandlesForSnapshotLoad();
diff --git a/host/vulkan/VkDecoder.h b/host/vulkan/VkDecoder.h
index 602fe101b..528159b4c 100644
--- a/host/vulkan/VkDecoder.h
+++ b/host/vulkan/VkDecoder.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module VkDecoder
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
diff --git a/host/vulkan/VkDecoderGlobalState.cpp b/host/vulkan/VkDecoderGlobalState.cpp
index 0211ee1d0..9a4c1a363 100644
--- a/host/vulkan/VkDecoderGlobalState.cpp
+++ b/host/vulkan/VkDecoderGlobalState.cpp
@@ -71,9 +71,10 @@
 #endif
 
 #ifndef VERBOSE
-#define VERBOSE(fmt, ...)        \
-    if (android::base::isVerboseLogging()) \
-        fprintf(stderr, "%s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+#define VERBOSE(fmt, ...)                    \
+    if (android::base::isVerboseLogging()) { \
+        INFO(fmt, ##__VA_ARGS__);            \
+    }
 #endif
 
 #include <climits>
@@ -102,13 +103,10 @@ using gfxstream::VulkanInfo;
 #define __ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
 #define __ALIGN(x, a) __ALIGN_MASK(x, (__typeof__(x))(a)-1)
 
-// TODO: Asserts build
-#define DCHECK(condition) (void)(condition);
-
 #define VKDGS_DEBUG 0
 
 #if VKDGS_DEBUG
-#define VKDGS_LOG(fmt, ...) fprintf(stderr, "%s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+#define VKDGS_LOG(fmt, ...) INFO
 #else
 #define VKDGS_LOG(fmt, ...)
 #endif
@@ -134,6 +132,17 @@ void validateRequiredHandle(const char* api_name, const char* parameter_name, T
     }
 }
 
+#define VALIDATE_NEW_HANDLE_INFO_ENTRY(objectMap, newEntry) \
+    validateNewHandleInfoEntry(objectMap, newEntry, #objectMap)
+
+template <typename T, typename K>
+void validateNewHandleInfoEntry(const std::unordered_map<T, K>& vkObjectMap, const T& newEntry,
+                                const char* typeName) {
+    if (vkObjectMap.find(newEntry) != vkObjectMap.end()) {
+        ERR("Found duplicate in %s (%p)!", typeName, newEntry);
+    }
+}
+
 VK_EXT_SYNC_HANDLE dupExternalSync(VK_EXT_SYNC_HANDLE h) {
 #ifdef _WIN32
     auto myProcessHandle = GetCurrentProcess();
@@ -193,13 +202,16 @@ static uint64_t hostBlobId = 0;
 static uint32_t kTemporaryContextIdForSnapshotLoading = 1;
 
 static std::unordered_set<std::string> kSnapshotAppAllowList = {"Chromium"};
-static std::unordered_set<std::string> kSnapshotEngineAllowList = {"ANGLE"};
+static std::unordered_set<std::string> kSnapshotEngineAllowList = {"ANGLE", "ace"};
 
 #define DEFINE_BOXED_HANDLE_TYPE_TAG(type) Tag_##type,
 
 enum BoxedHandleTypeTag {
     Tag_Invalid = 0,
     GOLDFISH_VK_LIST_HANDLE_TYPES_BY_STAGE(DEFINE_BOXED_HANDLE_TYPE_TAG)
+
+    // additional generic tag
+    Tag_VkGeneric = 1001,
 };
 
 template <class T>
@@ -361,10 +373,14 @@ class VkDecoderGlobalState::Impl {
           m_emu(getGlobalVkEmulation()),
           mRenderDocWithMultipleVkInstances(m_emu->guestRenderDoc.get()) {
         mSnapshotsEnabled = m_emu->features.VulkanSnapshots.enabled;
+        mBatchedDescriptorSetUpdateEnabled =
+            m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled;
         mVkCleanupEnabled =
             android::base::getEnvironmentVariable("ANDROID_EMU_VK_NO_CLEANUP") != "1";
         mLogging = android::base::getEnvironmentVariable("ANDROID_EMU_VK_LOG_CALLS") == "1";
         mVerbosePrints = android::base::getEnvironmentVariable("ANDROID_EMUGL_VERBOSE") == "1";
+        mEnableVirtualVkQueue = m_emu->features.VulkanVirtualQueue.enabled;
+
         if (get_emugl_address_space_device_control_ops().control_get_hw_funcs &&
             get_emugl_address_space_device_control_ops().control_get_hw_funcs()) {
             mUseOldMemoryCleanupPath = 0 == get_emugl_address_space_device_control_ops()
@@ -413,6 +429,8 @@ class VkDecoderGlobalState::Impl {
 
     bool snapshotsEnabled() const { return mSnapshotsEnabled; }
 
+    bool batchedDescriptorSetUpdateEnabled() const { return mBatchedDescriptorSetUpdateEnabled; }
+
     bool vkCleanupEnabled() const { return mVkCleanupEnabled; }
 
     const gfxstream::host::FeatureSet& getFeatures() const { return m_emu->features; }
@@ -470,13 +488,30 @@ class VkDecoderGlobalState::Impl {
     void save(android::base::Stream* stream) {
         mSnapshotState = SnapshotState::Saving;
 
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
         if (!mInstanceInfo.empty()) {
             get_emugl_vm_operations().setStatSnapshotUseVulkan();
         }
 #endif
 
+        {
+            std::unordered_map<VkDevice, uint32_t> deviceToContextId;
+            for (const auto& [device, deviceInfo] : mDeviceInfo) {
+                if (!deviceInfo.virtioGpuContextId) {
+                    GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                        << "VkDevice" << device << " missing context id.";
+                }
+                deviceToContextId[deviceInfo.boxed] = *deviceInfo.virtioGpuContextId;
+            }
+            stream->putBe64(static_cast<uint64_t>(deviceToContextId.size()));
+            for (const auto [device, contextId] : deviceToContextId) {
+                stream->putBe64(reinterpret_cast<uint64_t>(device));
+                stream->putBe32(contextId);
+            }
+        }
+
         snapshot()->save(stream);
+
         // Save mapped memory
         uint32_t memoryCount = 0;
         for (const auto& it : mMemoryInfo) {
@@ -506,7 +541,11 @@ class VkDecoderGlobalState::Impl {
         // So sort them (by boxed handles) first.
         std::sort(sortedBoxedImages.begin(), sortedBoxedImages.end());
         for (const auto& boxedImage : sortedBoxedImages) {
-            auto unboxedImage = unbox_VkImage(boxedImage);
+            auto unboxedImage = try_unbox_VkImage(boxedImage);
+            if (unboxedImage == VK_NULL_HANDLE) {
+                //TODO(b/294277842): should return an error here.
+                continue;
+            }
             const ImageInfo& imageInfo = mImageInfo[unboxedImage];
             if (imageInfo.memory == VK_NULL_HANDLE) {
                 continue;
@@ -528,7 +567,11 @@ class VkDecoderGlobalState::Impl {
         }
         sort(sortedBoxedBuffers.begin(), sortedBoxedBuffers.end());
         for (const auto& boxedBuffer : sortedBoxedBuffers) {
-            auto unboxedBuffer = unbox_VkBuffer(boxedBuffer);
+            auto unboxedBuffer = try_unbox_VkBuffer(boxedBuffer);
+            if (unboxedBuffer == VK_NULL_HANDLE) {
+                //TODO(b/294277842): should return an error here.
+                continue;
+            }
             const BufferInfo& bufferInfo = mBufferInfo[unboxedBuffer];
             if (bufferInfo.memory == VK_NULL_HANDLE) {
                 continue;
@@ -703,6 +746,20 @@ class VkDecoderGlobalState::Impl {
         // destroy all current internal data structures
         clear();
         mSnapshotState = SnapshotState::Loading;
+
+        // This needs to happen before the replay in the decoder so that virtio gpu context ids
+        // are available for operations involving `ExternalObjectManager`.
+        {
+            mSnapshotLoadVkDeviceToVirtioCpuContextId.emplace();
+            const uint64_t count = stream->getBe64();
+            for (uint64_t i = 0; i < count; i++) {
+                const uint64_t device = stream->getBe64();
+                const uint32_t contextId = stream->getBe32();
+                (*mSnapshotLoadVkDeviceToVirtioCpuContextId)[reinterpret_cast<VkDevice>(device)] =
+                    contextId;
+            }
+        }
+
         android::base::BumpPool bumpPool;
         // this part will replay in the decoder
         snapshot()->load(stream, gfxLogger, healthMonitor);
@@ -889,7 +946,7 @@ class VkDecoderGlobalState::Impl {
             VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
             dvk->vkResetFences(device, 1, &unboxedFence);
         }
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
         if (!mInstanceInfo.empty()) {
             get_emugl_vm_operations().setStatSnapshotUseVulkan();
         }
@@ -933,6 +990,18 @@ class VkDecoderGlobalState::Impl {
         mCreatedHandlesForSnapshotLoadIndex = 0;
     }
 
+    std::optional<uint32_t> getContextIdForDeviceLocked(VkDevice device) {
+        auto deviceInfoIt = mDeviceInfo.find(device);
+        if (deviceInfoIt == mDeviceInfo.end()) {
+            return std::nullopt;
+        }
+        auto& deviceInfo = deviceInfoIt->second;
+        if (!deviceInfo.virtioGpuContextId) {
+            return std::nullopt;
+        }
+        return *deviceInfo.virtioGpuContextId;
+    }
+
     VkResult on_vkEnumerateInstanceVersion(android::base::BumpPool* pool, uint32_t* pApiVersion) {
         if (m_vk->vkEnumerateInstanceVersion) {
             VkResult res = m_vk->vkEnumerateInstanceVersion(pApiVersion);
@@ -1005,7 +1074,7 @@ class VkDecoderGlobalState::Impl {
 
         if (swiftshader) {
             if (mLogging) {
-                fprintf(stderr, "%s: acquire lock\n", __func__);
+                INFO("%s: acquire lock", __func__);
             }
             lock = std::make_unique<std::lock_guard<std::recursive_mutex>>(mLock);
         }
@@ -1038,7 +1107,7 @@ class VkDecoderGlobalState::Impl {
         INFO("Created VkInstance:%p for application:%s engine:%s.", *pInstance,
              info.applicationName.c_str(), info.engineName.c_str());
 
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
         // TODO: bug 129484301
         if (!m_emu->features.VulkanSnapshots.enabled ||
             (kSnapshotAppAllowList.find(info.applicationName) == kSnapshotAppAllowList.end() &&
@@ -1055,6 +1124,7 @@ class VkDecoderGlobalState::Impl {
         std::string_view engineName = appInfo.pEngineName ? appInfo.pEngineName : "";
         info.isAngle = (engineName == "ANGLE");
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mInstanceInfo, *pInstance);
         mInstanceInfo[*pInstance] = info;
 
         *pInstance = (VkInstance)info.boxed;
@@ -1107,7 +1177,10 @@ class VkDecoderGlobalState::Impl {
 
     void on_vkDestroyInstance(android::base::BumpPool* pool, VkInstance boxed_instance,
                               const VkAllocationCallbacks* pAllocator) {
-        auto instance = unbox_VkInstance(boxed_instance);
+        auto instance = try_unbox_VkInstance(boxed_instance);
+        if (instance == VK_NULL_HANDLE) {
+            return;
+        }
 
         vkDestroyInstanceImpl(instance, pAllocator);
 
@@ -1208,8 +1281,9 @@ class VkDecoderGlobalState::Impl {
         if (pPhysicalDeviceCount && pPhysicalDevices) {
             // Box them up
             for (uint32_t i = 0; i < std::min(requestedCount, availableCount); ++i) {
+                VALIDATE_NEW_HANDLE_INFO_ENTRY(mPhysicalDeviceToInstance, physicalDevices[i]);
                 mPhysicalDeviceToInstance[physicalDevices[i]] = instance;
-
+                VALIDATE_NEW_HANDLE_INFO_ENTRY(mPhysdevInfo, physicalDevices[i]);
                 auto& physdevInfo = mPhysdevInfo[physicalDevices[i]];
                 physdevInfo.instance = instance;
                 physdevInfo.boxed = new_boxed_VkPhysicalDevice(physicalDevices[i], vk,
@@ -1241,6 +1315,18 @@ class VkDecoderGlobalState::Impl {
                     physicalDevices[i], &queueFamilyPropCount,
                     physdevInfo.queueFamilyProperties.data());
 
+                // Override queueCount for the virtual queue to be provided with device creations
+                if (mEnableVirtualVkQueue) {
+                    for (VkQueueFamilyProperties& qfp : physdevInfo.queueFamilyProperties) {
+                        // Check if the queue requires a virtualized version. For Android, we need
+                        // 2 graphics queues on the same queue family.
+                        if ( (qfp.queueFlags & VK_QUEUE_GRAPHICS_BIT) && qfp.queueCount == 1 ) {
+                            qfp.queueCount = 2;
+                            physdevInfo.hasVirtualGraphicsQueues = true;
+                        }
+                    }
+                }
+
                 pPhysicalDevices[i] = (VkPhysicalDevice)physdevInfo.boxed;
             }
             if (requestedCount < availableCount) {
@@ -1306,20 +1392,44 @@ class VkDecoderGlobalState::Impl {
         if (ycbcrFeatures != nullptr) {
             ycbcrFeatures->samplerYcbcrConversion |= m_emu->enableYcbcrEmulation;
         }
-        VkPhysicalDeviceProtectedMemoryFeatures* protectedMemoryFeatures =
-            vk_find_struct<VkPhysicalDeviceProtectedMemoryFeatures>(pFeatures);
-        if (protectedMemoryFeatures != nullptr) {
-            // Protected memory is not supported on emulators. Override feature
-            // information to mark as unsupported (see b/329845987).
-            protectedMemoryFeatures->protectedMemory = VK_FALSE;
-        }
 
-        VkPhysicalDevicePrivateDataFeatures* privateDataFeatures =
-            vk_find_struct<VkPhysicalDevicePrivateDataFeatures>(pFeatures);
-        if (privateDataFeatures != nullptr) {
-            // Private data from the guest side is not currently supported and causes emulator
-            // crashes with the dEQP-VK.api.object_management.private_data tests (b/368009403).
-            privateDataFeatures->privateData = VK_FALSE;
+        // Disable a set of Vulkan features if BypassVulkanDeviceFeatureOverrides is NOT enabled.
+        if (!m_emu->features.BypassVulkanDeviceFeatureOverrides.enabled) {
+            VkPhysicalDeviceProtectedMemoryFeatures* protectedMemoryFeatures =
+                vk_find_struct<VkPhysicalDeviceProtectedMemoryFeatures>(pFeatures);
+            if (protectedMemoryFeatures != nullptr) {
+                // Protected memory is not supported on emulators. Override feature
+                // information to mark as unsupported (see b/329845987).
+                protectedMemoryFeatures->protectedMemory = VK_FALSE;
+            }
+
+            VkPhysicalDevicePrivateDataFeatures* privateDataFeatures =
+                vk_find_struct<VkPhysicalDevicePrivateDataFeatures>(pFeatures);
+            if (privateDataFeatures != nullptr) {
+                // Private data from the guest side is not currently supported and causes emulator
+                // crashes with the dEQP-VK.api.object_management.private_data tests (b/368009403).
+                privateDataFeatures->privateData = VK_FALSE;
+            }
+
+            VkPhysicalDeviceVulkan13Features* vulkan13Features =
+                vk_find_struct<VkPhysicalDeviceVulkan13Features>(pFeatures);
+            if (vulkan13Features != nullptr) {
+                vulkan13Features->privateData = VK_FALSE;
+            }
+
+            if (m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+                // Currently not supporting iub due to descriptor set optimization.
+                // TODO: fix the non-optimized descriptor set path and re-enable the features afterwads.
+                // b/372217918
+                VkPhysicalDeviceInlineUniformBlockFeatures* iubFeatures =
+                    vk_find_struct<VkPhysicalDeviceInlineUniformBlockFeatures>(pFeatures);
+                if (iubFeatures != nullptr) {
+                    iubFeatures->inlineUniformBlock = VK_FALSE;
+                }
+                if (vulkan13Features != nullptr) {
+                    vulkan13Features->inlineUniformBlock = VK_FALSE;
+                }
+            }
         }
     }
 
@@ -1563,6 +1673,72 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
+    void on_vkGetPhysicalDeviceQueueFamilyProperties(
+        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
+        auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
+        auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
+
+        const bool requiresPropertyOverrides = mEnableVirtualVkQueue && pQueueFamilyProperties;
+        if (!requiresPropertyOverrides) {
+            // Can just use results from the driver
+            return vk->vkGetPhysicalDeviceQueueFamilyProperties(
+                physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+        }
+
+        // Use cached queue family properties to accommodate for any property overrides/emulation
+        std::lock_guard<std::recursive_mutex> lock(mLock);
+        const PhysicalDeviceInfo* physicalDeviceInfo =
+            android::base::find(mPhysdevInfo, physicalDevice);
+        if (!physicalDeviceInfo) {
+            ERR("Failed to find physical device info.");
+            return;
+        }
+
+        const auto& properties = physicalDeviceInfo->queueFamilyProperties;
+        *pQueueFamilyPropertyCount =
+            std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
+        for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
+            pQueueFamilyProperties[i] = properties[i];
+        }
+    }
+
+    void on_vkGetPhysicalDeviceQueueFamilyProperties2(
+        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
+        auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
+        auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
+
+        const bool requiresPropertyOverrides = mEnableVirtualVkQueue && pQueueFamilyProperties;
+        if (!requiresPropertyOverrides) {
+            // Can just use results from the driver
+            return vk->vkGetPhysicalDeviceQueueFamilyProperties2(
+                physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+        }
+
+        if (pQueueFamilyProperties->pNext) {
+            // We still need to call the driver version to fill in any pNext values
+            vk->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount,
+                                                          pQueueFamilyProperties);
+        }
+
+        // Use cached queue family properties to accommodate for any property overrides/emulation
+        std::lock_guard<std::recursive_mutex> lock(mLock);
+        const PhysicalDeviceInfo* physicalDeviceInfo =
+            android::base::find(mPhysdevInfo, physicalDevice);
+        if (!physicalDeviceInfo) {
+            ERR("Failed to find physical device info.");
+            return;
+        }
+
+        const auto& properties = physicalDeviceInfo->queueFamilyProperties;
+        *pQueueFamilyPropertyCount =
+            std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
+        for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
+            pQueueFamilyProperties[i].queueFamilyProperties = properties[i];
+        }
+    }
+
     void on_vkGetPhysicalDeviceMemoryProperties(
         android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
         VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
@@ -1709,11 +1885,41 @@ class VkDecoderGlobalState::Impl {
             featuresToFilter.emplace_back(&featuresFiltered);
         }
 
+        // TODO(b/378686769): Force enable private data feature when available to
+        //  mitigate the issues with duplicated vulkan handles. This should be
+        //  removed once the issue is properly fixed.
+        VkPhysicalDevicePrivateDataFeatures forceEnablePrivateData = {
+            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
+            nullptr,
+            VK_TRUE,
+        };
+        if (m_emu->deviceInfo.supportsPrivateData) {
+            VkPhysicalDevicePrivateDataFeatures* privateDataFeatures =
+                vk_find_struct<VkPhysicalDevicePrivateDataFeatures>(&createInfoFiltered);
+            if (privateDataFeatures != nullptr) {
+                privateDataFeatures->privateData = VK_TRUE;
+            } else {
+                // Insert into device create info chain
+                forceEnablePrivateData.pNext = const_cast<void*>(createInfoFiltered.pNext);
+                createInfoFiltered.pNext = &forceEnablePrivateData;
+                privateDataFeatures = &forceEnablePrivateData;
+            }
+        }
+
         if (VkPhysicalDeviceFeatures2* features2 =
                 vk_find_struct<VkPhysicalDeviceFeatures2>(&createInfoFiltered)) {
             featuresToFilter.emplace_back(&features2->features);
         }
 
+        VkPhysicalDeviceDiagnosticsConfigFeaturesNV deviceDiagnosticsConfigFeatures = {
+            .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
+            .diagnosticsConfig = VK_TRUE,
+        };
+        if (m_emu->commandBufferCheckpointsSupportedAndRequested) {
+            deviceDiagnosticsConfigFeatures.pNext = const_cast<void*>(createInfoFiltered.pNext);
+            createInfoFiltered.pNext = &deviceDiagnosticsConfigFeatures;
+        }
+
         for (VkPhysicalDeviceFeatures* feature : featuresToFilter) {
             if (emulateTextureEtc2) {
                 feature->textureCompressionETC2 = VK_FALSE;
@@ -1836,6 +2042,7 @@ class VkDecoderGlobalState::Impl {
         auto& instanceInfo = instanceInfoIt->second;
 
         // Fill out information about the logical device here.
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mDeviceInfo, *pDevice);
         auto& deviceInfo = mDeviceInfo[*pDevice];
         deviceInfo.physicalDevice = physicalDevice;
         deviceInfo.emulateTextureEtc2 = emulateTextureEtc2;
@@ -1864,13 +2071,13 @@ class VkDecoderGlobalState::Impl {
         }
 
         // First, get the dispatch table.
-        VkDevice boxed = new_boxed_VkDevice(*pDevice, nullptr, true /* own dispatch */);
+        VkDevice boxedDevice = new_boxed_VkDevice(*pDevice, nullptr, true /* own dispatch */);
 
         if (mLogging) {
-            fprintf(stderr, "%s: init vulkan dispatch from device\n", __func__);
+            INFO("%s: init vulkan dispatch from device", __func__);
         }
 
-        VulkanDispatch* dispatch = dispatch_VkDevice(boxed);
+        VulkanDispatch* dispatch = dispatch_VkDevice(boxedDevice);
         init_vulkan_dispatch_from_device(vk, *pDevice, dispatch);
         if (m_emu->debugUtilsAvailableAndRequested) {
             deviceInfo.debugUtilsHelper = DebugUtilsHelper::withUtilsEnabled(*pDevice, dispatch);
@@ -1882,10 +2089,26 @@ class VkDecoderGlobalState::Impl {
         deviceInfo.deviceOpTracker = std::make_shared<DeviceOpTracker>(*pDevice, dispatch);
 
         if (mLogging) {
-            fprintf(stderr, "%s: init vulkan dispatch from device (end)\n", __func__);
+            INFO("%s: init vulkan dispatch from device (end)", __func__);
         }
 
-        deviceInfo.boxed = boxed;
+        deviceInfo.boxed = boxedDevice;
+
+        if (mSnapshotState == SnapshotState::Loading) {
+            if (!mSnapshotLoadVkDeviceToVirtioCpuContextId) {
+                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                    << "Missing device to context id map during snapshot load.";
+            }
+            auto contextIdIt = mSnapshotLoadVkDeviceToVirtioCpuContextId->find(boxedDevice);
+            if (contextIdIt == mSnapshotLoadVkDeviceToVirtioCpuContextId->end()) {
+                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                    << "Missing context id for VkDevice:" << boxedDevice;
+            }
+            deviceInfo.virtioGpuContextId = contextIdIt->second;
+        } else {
+            auto* renderThreadInfo = RenderThreadInfoVk::get();
+            deviceInfo.virtioGpuContextId = renderThreadInfo->ctx_id;
+        }
 
         // Next, get information about the queue families used by this device.
         std::unordered_map<uint32_t, uint32_t> queueFamilyIndexCounts;
@@ -1903,28 +2126,65 @@ class VkDecoderGlobalState::Impl {
         for (auto it : queueFamilyIndexCounts) {
             auto index = it.first;
             auto count = it.second;
+            auto addVirtualQueue = (count == 2) && physicalDeviceInfo.hasVirtualGraphicsQueues;
             auto& queues = deviceInfo.queues[index];
             for (uint32_t i = 0; i < count; ++i) {
-                VkQueue queueOut;
+                VkQueue physicalQueue;
 
                 if (mLogging) {
-                    fprintf(stderr, "%s: get device queue (begin)\n", __func__);
+                    INFO("%s: get device queue (begin)", __func__);
                 }
 
-                vk->vkGetDeviceQueue(*pDevice, index, i, &queueOut);
+                assert(i == 0 || !physicalDeviceInfo.hasVirtualGraphicsQueues);
+                vk->vkGetDeviceQueue(*pDevice, index, i, &physicalQueue);
 
                 if (mLogging) {
-                    fprintf(stderr, "%s: get device queue (end)\n", __func__);
+                    INFO("%s: get device queue (end)", __func__);
+                }
+                auto boxedQueue =
+                    new_boxed_VkQueue(physicalQueue, dispatch, false /* does not own dispatch */);
+                extraHandles.push_back((uint64_t)boxedQueue);
+
+                VALIDATE_NEW_HANDLE_INFO_ENTRY(mQueueInfo, physicalQueue);
+                QueueInfo& physicalQueueInfo = mQueueInfo[physicalQueue];
+                physicalQueueInfo.device = *pDevice;
+                physicalQueueInfo.queueFamilyIndex = index;
+                physicalQueueInfo.boxed = boxedQueue;
+                physicalQueueInfo.physicalQueueLock = std::make_shared<android::base::Lock>();
+                queues.push_back(physicalQueue);
+
+                if (addVirtualQueue) {
+                    VERBOSE("Creating virtual device queue for physical VkQueue %p", physicalQueue);
+                    const uint64_t physicalQueue64 = reinterpret_cast<uint64_t>(physicalQueue);
+
+                    if ((physicalQueue64 & QueueInfo::kVirtualQueueBit) != 0) {
+                        // Cannot use queue virtualization on this GPU, where the pysical handle
+                        // values generated are not 2-byte aligned. This is very unusual, but the
+                        // spec is not enforcing handle values to be aligned and the driver is free
+                        // to use a similar logic to use the last bit for other purposes.
+                        // In this case, we disable the virtual queue support and unboxing will not
+                        // remove the last bit coming from the actual driver.
+                        ERR("Cannot create virtual queue for handle %p", physicalQueue);
+                        mEnableVirtualVkQueue = false;
+                    } else {
+                        uint64_t virtualQueue64 = (physicalQueue64 | QueueInfo::kVirtualQueueBit);
+                        VkQueue virtualQueue = reinterpret_cast<VkQueue>(virtualQueue64);
+
+                        auto boxedVirtualQueue = new_boxed_VkQueue(
+                            virtualQueue, dispatch, false /* does not own dispatch */);
+                        extraHandles.push_back((uint64_t)boxedVirtualQueue);
+
+                        VALIDATE_NEW_HANDLE_INFO_ENTRY(mQueueInfo, virtualQueue);
+                        QueueInfo& virtualQueueInfo = mQueueInfo[virtualQueue];
+                        virtualQueueInfo.device = physicalQueueInfo.device;
+                        virtualQueueInfo.queueFamilyIndex = physicalQueueInfo.queueFamilyIndex;
+                        virtualQueueInfo.boxed = boxedVirtualQueue;
+                        virtualQueueInfo.physicalQueueLock =
+                            physicalQueueInfo.physicalQueueLock;  // Shares the same lock!
+                        queues.push_back(virtualQueue);
+                    }
+                    i++;
                 }
-                queues.push_back(queueOut);
-                mQueueInfo[queueOut].device = *pDevice;
-                mQueueInfo[queueOut].queueFamilyIndex = index;
-
-                auto boxed = new_boxed_VkQueue(queueOut, dispatch_VkDevice(deviceInfo.boxed),
-                                               false /* does not own dispatch */);
-                extraHandles.push_back((uint64_t)boxed);
-                mQueueInfo[queueOut].boxed = boxed;
-                mQueueInfo[queueOut].lock = new Lock;
             }
         }
         if (snapshotsEnabled()) {
@@ -1935,7 +2195,7 @@ class VkDecoderGlobalState::Impl {
         *pDevice = (VkDevice)deviceInfo.boxed;
 
         if (mLogging) {
-            fprintf(stderr, "%s: (end)\n", __func__);
+            INFO("%s: (end)", __func__);
         }
 
         return VK_SUCCESS;
@@ -1961,9 +2221,12 @@ class VkDecoderGlobalState::Impl {
         VkQueue unboxedQueue = (*queueList)[queueIndex];
 
         auto* queueInfo = android::base::find(mQueueInfo, unboxedQueue);
-        if (!queueInfo) return;
+        if (!queueInfo) {
+            ERR("vkGetDeviceQueue failed on queue: %p", unboxedQueue);
+            return;
+        }
 
-        *pQueue = (VkQueue)queueInfo->boxed;
+        *pQueue = queueInfo->boxed;
     }
 
     void on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkDevice boxed_device,
@@ -1973,7 +2236,7 @@ class VkDecoderGlobalState::Impl {
         // queue. See b/328436383.
         if (pQueueInfo->flags & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT) {
             *pQueue = VK_NULL_HANDLE;
-            fprintf(stderr, "%s: Cannot get protected Vulkan device queue\n", __func__);
+            INFO("%s: Cannot get protected Vulkan device queue", __func__);
             return;
         }
         uint32_t queueFamilyIndex = pQueueInfo->queueFamilyIndex;
@@ -1990,7 +2253,7 @@ class VkDecoderGlobalState::Impl {
         auto eraseIt = queueInfos.begin();
         for (; eraseIt != queueInfos.end();) {
             if (eraseIt->second.device == device) {
-                delete eraseIt->second.lock;
+                eraseIt->second.physicalQueueLock.reset();
                 delete_VkQueue(eraseIt->second.boxed);
                 eraseIt = queueInfos.erase(eraseIt);
             } else {
@@ -2093,6 +2356,7 @@ class VkDecoderGlobalState::Impl {
 
         if (result == VK_SUCCESS) {
             std::lock_guard<std::recursive_mutex> lock(mLock);
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mBufferInfo, *pBuffer);
             auto& bufInfo = mBufferInfo[*pBuffer];
             bufInfo.device = device;
             bufInfo.usage = pCreateInfo->usage;
@@ -2213,6 +2477,20 @@ class VkDecoderGlobalState::Impl {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
+        if (pCreateInfo->format == VK_FORMAT_UNDEFINED) {
+            // VUID-VkImageCreateInfo-pNext-01975:
+            // If the pNext chain does not include a VkExternalFormatANDROID structure, or does
+            // and its externalFormat member is 0, the format must not be VK_FORMAT_UNDEFINED.
+            //
+            // VkExternalFormatANDROID usages should be replaced with Vulkan formats on the guest
+            // side during image creation. We don't support external formats on the host side and
+            // format should be valid at this stage. This error indicates usage of an unsupported
+            // external format, or an old system image.
+            // We handle this here to better report the error and avoid crashes in the driver.
+            ERR("vkCreateImage called with VK_FORMAT_UNDEFINED, external format is not supported.");
+            return VK_ERROR_INITIALIZATION_FAILED;
+        }
+
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
@@ -2240,24 +2518,6 @@ class VkDecoderGlobalState::Impl {
         const VkNativeBufferANDROID* nativeBufferANDROID =
             vk_find_struct<VkNativeBufferANDROID>(pCreateInfo);
 
-#if defined(__APPLE__)
-        VkExportMetalObjectCreateInfoEXT metalImageExportCI = {
-            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, nullptr,
-            VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT};
-
-        // Add VkExportMetalObjectCreateInfoEXT on MoltenVK
-        if (m_emu->instanceSupportsMoltenVK) {
-            const VkExternalMemoryImageCreateInfo* externalMemCI =
-                vk_find_struct<VkExternalMemoryImageCreateInfo>(pCreateInfo);
-            if (externalMemCI) {
-                // Insert metalImageExportCI to the chain
-                metalImageExportCI.pNext = externalMemCI->pNext;
-                const_cast<VkExternalMemoryImageCreateInfo*>(externalMemCI)->pNext =
-                    &metalImageExportCI;
-            }
-        }
-#endif
-
         VkResult createRes = VK_SUCCESS;
 
         if (nativeBufferANDROID) {
@@ -2298,6 +2558,7 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mImageInfo, *pImage);
         auto& imageInfo = mImageInfo[*pImage];
         imageInfo.device = device;
         imageInfo.cmpInfo = std::move(cmpInfo);
@@ -2456,7 +2717,7 @@ class VkDecoderGlobalState::Impl {
     VkResult on_vkBindImageMemory2(android::base::BumpPool* pool, VkDevice boxed_device,
                                    uint32_t bindInfoCount,
                                    const VkBindImageMemoryInfo* pBindInfos) {
-#ifdef GFXSTREAM_ENABLE_HOST_VK_SNAPSHOT
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
         if (bindInfoCount > 1 && snapshotsEnabled()) {
             if (mVerbosePrints) {
                 fprintf(stderr,
@@ -2565,6 +2826,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mImageViewInfo, *pView);
         auto& imageViewInfo = mImageViewInfo[*pView];
         imageViewInfo.device = device;
         imageViewInfo.needEmulatedAlpha = needEmulatedAlpha;
@@ -2615,6 +2877,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
         std::lock_guard<std::recursive_mutex> lock(mLock);
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mSamplerInfo, *pSampler);
         auto& samplerInfo = mSamplerInfo[*pSampler];
         samplerInfo.device = device;
         deepcopy_VkSamplerCreateInfo(pool, VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
@@ -2777,6 +3040,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mSemaphoreInfo, *pSemaphore);
         auto& semaphoreInfo = mSemaphoreInfo[*pSemaphore];
         semaphoreInfo.device = device;
 
@@ -2835,8 +3099,10 @@ class VkDecoderGlobalState::Impl {
         {
             std::lock_guard<std::recursive_mutex> lock(mLock);
 
-            DCHECK(fenceReused || mFenceInfo.find(*pFence) == mFenceInfo.end());
             // Create FenceInfo for *pFence.
+            if (!fenceReused) {
+                VALIDATE_NEW_HANDLE_INFO_ENTRY(mFenceInfo, *pFence);
+            }
             auto& fenceInfo = mFenceInfo[*pFence];
             fenceInfo.device = device;
             fenceInfo.vk = vk;
@@ -2863,13 +3129,16 @@ class VkDecoderGlobalState::Impl {
             for (uint32_t i = 0; i < fenceCount; i++) {
                 if (pFences[i] == VK_NULL_HANDLE) continue;
 
-                DCHECK(mFenceInfo.find(pFences[i]) != mFenceInfo.end());
-                if (mFenceInfo[pFences[i]].external) {
-                    externalFences.push_back(pFences[i]);
+                if (mFenceInfo.find(pFences[i]) == mFenceInfo.end()) {
+                    ERR("Invalid fence handle: %p!", pFences[i]);
                 } else {
-                    // Reset all fences' states to kNotWaitable.
-                    cleanedFences.push_back(pFences[i]);
-                    mFenceInfo[pFences[i]].state = FenceInfo::State::kNotWaitable;
+                    if (mFenceInfo[pFences[i]].external) {
+                        externalFences.push_back(pFences[i]);
+                    } else {
+                        // Reset all fences' states to kNotWaitable.
+                        cleanedFences.push_back(pFences[i]);
+                        mFenceInfo[pFences[i]].state = FenceInfo::State::kNotWaitable;
+                    }
                 }
             }
         }
@@ -2979,18 +3248,16 @@ class VkDecoderGlobalState::Impl {
 
     VkResult on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
                                      VkSemaphore semaphore, uint64_t syncId) {
-        VK_EXT_SYNC_HANDLE handle;
-        uint32_t streamHandleType = 0;
-        auto* tInfo = RenderThreadInfoVk::get();
-        auto vk = dispatch_VkDevice(boxed_device);
-        auto device = unbox_VkDevice(boxed_device);
-        VkExternalSemaphoreHandleTypeFlagBits flagBits =
-            static_cast<VkExternalSemaphoreHandleTypeFlagBits>(0);
-
         if (!m_emu->features.VulkanExternalSync.enabled) {
             return VK_ERROR_FEATURE_NOT_PRESENT;
         }
 
+        auto vk = dispatch_VkDevice(boxed_device);
+        auto device = unbox_VkDevice(boxed_device);
+
+        uint32_t virtioGpuContextId = 0;
+        VkExternalSemaphoreHandleTypeFlagBits flagBits =
+            static_cast<VkExternalSemaphoreHandleTypeFlagBits>(0);
         {
             std::lock_guard<std::recursive_mutex> lock(mLock);
             auto* deviceInfo = android::base::find(mDeviceInfo, device);
@@ -3009,8 +3276,15 @@ class VkDecoderGlobalState::Impl {
                        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT) {
                 flagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
             }
+
+            if (!deviceInfo->virtioGpuContextId) {
+                ERR("VkDevice:%p is missing virtio gpu context id.", device);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+            virtioGpuContextId = *deviceInfo->virtioGpuContextId;
         }
 
+        VK_EXT_SYNC_HANDLE handle;
         VkResult result =
             exportSemaphore(vk, device, semaphore, &handle,
                             std::make_optional<VkExternalSemaphoreHandleTypeFlagBits>(flagBits));
@@ -3020,7 +3294,7 @@ class VkDecoderGlobalState::Impl {
 
         ManagedDescriptor descriptor(handle);
         ExternalObjectManager::get()->addSyncDescriptorInfo(
-            tInfo->ctx_id, syncId, std::move(descriptor), streamHandleType);
+            virtioGpuContextId, syncId, std::move(descriptor), /*streamHandleType*/ 0);
         return VK_SUCCESS;
     }
 
@@ -3143,6 +3417,7 @@ class VkDecoderGlobalState::Impl {
 
         if (res == VK_SUCCESS) {
             std::lock_guard<std::recursive_mutex> lock(mLock);
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorSetLayoutInfo, *pSetLayout);
             auto& info = mDescriptorSetLayoutInfo[*pSetLayout];
             info.device = device;
             *pSetLayout = new_boxed_non_dispatchable_VkDescriptorSetLayout(*pSetLayout);
@@ -3197,6 +3472,7 @@ class VkDecoderGlobalState::Impl {
 
         if (res == VK_SUCCESS) {
             std::lock_guard<std::recursive_mutex> lock(mLock);
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorPoolInfo, *pDescriptorPool);
             auto& info = mDescriptorPoolInfo[*pDescriptorPool];
             info.device = device;
             *pDescriptorPool = new_boxed_non_dispatchable_VkDescriptorPool(*pDescriptorPool);
@@ -3333,6 +3609,7 @@ class VkDecoderGlobalState::Impl {
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Cannot find setLayout";
         }
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorSetInfo, descriptorSet);
         auto& setInfo = mDescriptorSetInfo[descriptorSet];
 
         setInfo.pool = pool;
@@ -3519,8 +3796,10 @@ class VkDecoderGlobalState::Impl {
                     entry.bufferView = descriptorWrite.pTexelBufferView[writeElemIdx];
                     entry.writeType = DescriptorSetInfo::DescriptorWriteType::BufferView;
                     entry.descriptorType = descType;
-                    // TODO: check alive
-                    ERR("%s: Snapshot for texel buffer view is incomplete.\n", __func__);
+                    if (snapshotsEnabled()) {
+                        // TODO: check alive
+                        ERR("%s: Snapshot for texel buffer view is incomplete.\n", __func__);
+                    }
                 }
             } else if (isDescriptorTypeInlineUniformBlock(descType)) {
                 const VkWriteDescriptorSetInlineUniformBlock* descInlineUniformBlock =
@@ -3551,8 +3830,10 @@ class VkDecoderGlobalState::Impl {
                 // TODO
                 // Look for pNext inline uniform block or acceleration structure.
                 // Append new DescriptorWrite entry that holds the buffer
-                ERR("%s: Ignoring Snapshot for emulated write for descriptor type 0x%x\n", __func__,
-                    descType);
+                if (snapshotsEnabled()) {
+                    ERR("%s: Ignoring Snapshot for emulated write for descriptor type 0x%x\n",
+                        __func__, descType);
+                }
             }
         }
         // TODO: bookkeep pDescriptorCopies
@@ -3683,6 +3964,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mShaderModuleInfo, *pShaderModule);
         auto& shaderModuleInfo = mShaderModuleInfo[*pShaderModule];
         shaderModuleInfo.device = device;
 
@@ -3735,6 +4017,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mPipelineCacheInfo, *pPipelineCache);
         auto& pipelineCacheInfo = mPipelineCacheInfo[*pPipelineCache];
         pipelineCacheInfo.device = device;
 
@@ -3793,6 +4076,37 @@ class VkDecoderGlobalState::Impl {
             if (!pPipelines[i]) {
                 continue;
             }
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mPipelineInfo, pPipelines[i]);
+            auto& pipelineInfo = mPipelineInfo[pPipelines[i]];
+            pipelineInfo.device = device;
+
+            pPipelines[i] = new_boxed_non_dispatchable_VkPipeline(pPipelines[i]);
+        }
+
+        return result;
+    }
+
+    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool, VkDevice boxed_device,
+                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
+                                          const VkComputePipelineCreateInfo* pCreateInfos,
+                                          const VkAllocationCallbacks* pAllocator,
+                                          VkPipeline* pPipelines) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto deviceDispatch = dispatch_VkDevice(boxed_device);
+
+        VkResult result = deviceDispatch->vkCreateComputePipelines(
+            device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
+        if (result != VK_SUCCESS && result != VK_PIPELINE_COMPILE_REQUIRED) {
+            return result;
+        }
+
+        std::lock_guard<std::recursive_mutex> lock(mLock);
+
+        for (uint32_t i = 0; i < createInfoCount; i++) {
+            if (!pPipelines[i]) {
+                continue;
+            }
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mPipelineInfo, pPipelines[i]);
             auto& pipelineInfo = mPipelineInfo[pPipelines[i]];
             pipelineInfo.device = device;
 
@@ -4536,8 +4850,8 @@ class VkDecoderGlobalState::Impl {
                                                           uint64_t physAddr) {
         if (!m_emu->features.GlDirectMem.enabled &&
             !m_emu->features.VirtioGpuNext.enabled) {
-            // fprintf(stderr, "%s: Tried to use direct mapping "
-            // "while GlDirectMem is not enabled!\n");
+            // INFO("%s: Tried to use direct mapping "
+            // "while GlDirectMem is not enabled!");
         }
 
         auto* info = android::base::find(mMemoryInfo, memory);
@@ -4556,7 +4870,7 @@ class VkDecoderGlobalState::Impl {
         info->sizeToPage = ((info->size + pageOffset + kPageSize - 1) >> kPageBits) << kPageBits;
 
         if (mLogging) {
-            fprintf(stderr, "%s: map: %p, %p -> [0x%llx 0x%llx]\n", __func__, info->ptr,
+            INFO("%s: map: %p, %p -> [0x%llx 0x%llx]", __func__, info->ptr,
                     info->pageAlignedHva, (unsigned long long)info->guestPhysAddr,
                     (unsigned long long)info->guestPhysAddr + info->sizeToPage);
         }
@@ -4570,7 +4884,7 @@ class VkDecoderGlobalState::Impl {
 
         auto* existingMemoryInfo = android::base::find(mOccupiedGpas, gpa);
         if (existingMemoryInfo) {
-            fprintf(stderr, "%s: WARNING: already mapped gpa 0x%llx, replacing", __func__,
+            INFO("%s: WARNING: already mapped gpa 0x%llx, replacing", __func__,
                     (unsigned long long)gpa);
 
             get_emugl_vm_operations().unmapUserBackedRam(existingMemoryInfo->gpa,
@@ -4582,7 +4896,7 @@ class VkDecoderGlobalState::Impl {
         get_emugl_vm_operations().mapUserBackedRam(gpa, hva, sizeToPage);
 
         if (mVerbosePrints) {
-            fprintf(stderr, "VERBOSE:%s: registering gpa 0x%llx to mOccupiedGpas\n", __func__,
+            INFO("VERBOSE:%s: registering gpa 0x%llx to mOccupiedGpas", __func__,
                     (unsigned long long)gpa);
         }
 
@@ -4608,7 +4922,7 @@ class VkDecoderGlobalState::Impl {
         AutoLock lock(mOccupiedGpasLock);
 
         if (mVerbosePrints) {
-            fprintf(stderr, "VERBOSE:%s: deallocation callback for gpa 0x%llx\n", __func__,
+            INFO("VERBOSE:%s: deallocation callback for gpa 0x%llx", __func__,
                     (unsigned long long)gpa);
         }
 
@@ -4651,7 +4965,7 @@ class VkDecoderGlobalState::Impl {
 
         const VkMemoryDedicatedAllocateInfo* dedicatedAllocInfoPtr =
             vk_find_struct<VkMemoryDedicatedAllocateInfo>(pAllocateInfo);
-        VkMemoryDedicatedAllocateInfo localDedicatedAllocInfo;
+        VkMemoryDedicatedAllocateInfo localDedicatedAllocInfo = {};
 
         if (dedicatedAllocInfoPtr) {
             localDedicatedAllocInfo = vk_make_orphan_copy(*dedicatedAllocInfoPtr);
@@ -4715,14 +5029,16 @@ class VkDecoderGlobalState::Impl {
             VK_EXT_MEMORY_HANDLE_TYPE_BIT,
             VK_EXT_MEMORY_HANDLE_INVALID,
         };
-#endif
 
 #if defined(__APPLE__)
-        VkImportMetalBufferInfoEXT importInfoMetalBuffer = {
-            VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
+        VkImportMemoryMetalHandleInfoEXT importInfoMetalHandle = {
+            VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
             0,
+            VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
             nullptr,
         };
+#endif
+
 #endif
 
         void* mappedPtr = nullptr;
@@ -4750,23 +5066,28 @@ class VkDecoderGlobalState::Impl {
                     m_emu->callbacks.invalidateColorBuffer(importCbInfoPtr->colorBuffer);
                 }
 
+                bool opaqueFd = true;
+
 #if defined(__APPLE__)
                 // Use metal object extension on MoltenVK mode for color buffer import,
                 // non-moltenVK path on MacOS will use FD handles
                 if (m_emu->instanceSupportsMoltenVK) {
-                    // TODO(b/333460957): This is a temporary fix to get MoltenVK image memory
-                    // binding checks working as expected  based on dedicated memory checks. It's
-                    // not a valid usage of Vulkan as the device of the image is different than
-                    // what's being used here
-                    localDedicatedAllocInfo = {
+
+                    extern VkImage getColorBufferVkImage(uint32_t colorBufferHandle);
+                    if (dedicatedAllocInfoPtr == nullptr || localDedicatedAllocInfo.image == VK_NULL_HANDLE) {
+                        // TODO(b/351765838): This should not happen, but somehow the guest
+                        // is not providing us the necessary information for video rendering.
+                        localDedicatedAllocInfo = {
                         .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
                         .pNext = nullptr,
                         .image = getColorBufferVkImage(importCbInfoPtr->colorBuffer),
                         .buffer = VK_NULL_HANDLE,
-                    };
-                    shouldUseDedicatedAllocInfo = true;
+                        };
 
-                    MTLBufferRef cbExtMemoryHandle =
+                        shouldUseDedicatedAllocInfo = true;
+                    }
+
+                    MTLResource_id cbExtMemoryHandle =
                         getColorBufferMetalMemoryHandle(importCbInfoPtr->colorBuffer);
 
                     if (cbExtMemoryHandle == nullptr) {
@@ -4776,12 +5097,15 @@ class VkDecoderGlobalState::Impl {
                                 __func__, importCbInfoPtr->colorBuffer);
                         return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                     }
+                    importInfoMetalHandle.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
+                    importInfoMetalHandle.handle = cbExtMemoryHandle;
 
-                    importInfoMetalBuffer.mtlBuffer = cbExtMemoryHandle;
-                    vk_append_struct(&structChainIter, &importInfoMetalBuffer);
-                } else
+                    vk_append_struct(&structChainIter, &importInfoMetalHandle);
+                    opaqueFd = false;
+                }
 #endif
-                if (m_emu->deviceInfo.supportsExternalMemoryImport) {
+
+                if (opaqueFd && m_emu->deviceInfo.supportsExternalMemoryImport) {
                     VK_EXT_MEMORY_HANDLE cbExtMemoryHandle =
                         getColorBufferExtMemoryHandle(importCbInfoPtr->colorBuffer);
 
@@ -4819,9 +5143,10 @@ class VkDecoderGlobalState::Impl {
 
             shouldUseDedicatedAllocInfo &= bufferMemoryUsesDedicatedAlloc;
 
+            bool opaqueFd = true;
 #ifdef __APPLE__
             if (m_emu->instanceSupportsMoltenVK) {
-                MTLBufferRef bufferMetalMemoryHandle =
+                MTLResource_id bufferMetalMemoryHandle =
                     getBufferMetalMemoryHandle(importBufferInfoPtr->buffer);
 
                 if (bufferMetalMemoryHandle == nullptr) {
@@ -4833,11 +5158,16 @@ class VkDecoderGlobalState::Impl {
                     return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                 }
 
-                importInfoMetalBuffer.mtlBuffer = bufferMetalMemoryHandle;
-                vk_append_struct(&structChainIter, &importInfoMetalBuffer);
-            } else
+                importInfoMetalHandle.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
+                importInfoMetalHandle.handle = bufferMetalMemoryHandle;
+
+                vk_append_struct(&structChainIter, &importInfoMetalHandle);
+
+                opaqueFd = false;
+            }
 #endif
-            if (m_emu->deviceInfo.supportsExternalMemoryImport) {
+
+            if (opaqueFd && m_emu->deviceInfo.supportsExternalMemoryImport) {
                 uint32_t outStreamHandleType;
                 VK_EXT_MEMORY_HANDLE bufferExtMemoryHandle =
                     getBufferExtMemoryHandle(importBufferInfoPtr->buffer, &outStreamHandleType);
@@ -4866,6 +5196,7 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
+        uint32_t virtioGpuContextId = 0;
         VkMemoryPropertyFlags memoryPropertyFlags;
 
         // Map guest memory index to host memory index and lookup memory properties:
@@ -4894,6 +5225,13 @@ class VkDecoderGlobalState::Impl {
 
             localAllocInfo.memoryTypeIndex = hostMemoryInfo.index;
             memoryPropertyFlags = hostMemoryInfo.memoryType.propertyFlags;
+
+            auto virtioGpuContextIdOpt = getContextIdForDeviceLocked(device);
+            if (!virtioGpuContextIdOpt) {
+                ERR("VkDevice:%p missing context id for vkAllocateMemory().");
+                return VK_ERROR_DEVICE_LOST;
+            }
+            virtioGpuContextId = *virtioGpuContextIdOpt;
         }
 
         if (shouldUseDedicatedAllocInfo) {
@@ -4905,11 +5243,8 @@ class VkDecoderGlobalState::Impl {
         if (createBlobInfoPtr && createBlobInfoPtr->blobMem == STREAM_BLOB_MEM_GUEST &&
             (createBlobInfoPtr->blobFlags & STREAM_BLOB_FLAG_CREATE_GUEST_HANDLE)) {
             DescriptorType rawDescriptor;
-            uint32_t ctx_id = mSnapshotState == SnapshotState::Loading
-                                  ? kTemporaryContextIdForSnapshotLoading
-                                  : tInfo->ctx_id;
             auto descriptorInfoOpt = ExternalObjectManager::get()->removeBlobDescriptorInfo(
-                ctx_id, createBlobInfoPtr->blobId);
+                virtioGpuContextId, createBlobInfoPtr->blobId);
             if (descriptorInfoOpt) {
                 auto rawDescriptorOpt = (*descriptorInfoOpt).descriptor.release();
                 if (rawDescriptorOpt) {
@@ -4984,7 +5319,10 @@ class VkDecoderGlobalState::Impl {
 #if defined(__APPLE__)
                 if (m_emu->instanceSupportsMoltenVK) {
                     // Using a different handle type when in MoltenVK mode
-                    handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_KHR;
+                    handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT|VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT;
+                }
+                else {
+                    handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
                 }
 #elif defined(_WIN32)
                 handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
@@ -5089,6 +5427,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mMemoryInfo, *pMemory);
         mMemoryInfo[*pMemory] = MemoryInfo();
         auto& memoryInfo = mMemoryInfo[*pMemory];
         memoryInfo.size = localAllocInfo.allocationSize;
@@ -5351,7 +5690,7 @@ class VkDecoderGlobalState::Impl {
         Lock* defaultQueueLock;
         if (!getDefaultQueueForDeviceLocked(device, &defaultQueue, &defaultQueueFamilyIndex,
                                             &defaultQueueLock)) {
-            fprintf(stderr, "%s: cant get the default q\n", __func__);
+            INFO("%s: can't get the default q", __func__);
             return VK_ERROR_INITIALIZATION_FAILED;
         }
 
@@ -5425,7 +5764,7 @@ class VkDecoderGlobalState::Impl {
         }
 
         return syncImageToColorBuffer(m_emu->callbacks, vk, queueInfo->queueFamilyIndex, queue,
-                                      queueInfo->lock, waitSemaphoreCount, pWaitSemaphores,
+                                      queueInfo->physicalQueueLock.get(), waitSemaphoreCount, pWaitSemaphores,
                                       pNativeFenceFd, anbInfo);
     }
 
@@ -5444,7 +5783,7 @@ class VkDecoderGlobalState::Impl {
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
         if (mLogging) {
-            fprintf(stderr, "%s: deviceMemory: 0x%llx pAddress: 0x%llx\n", __func__,
+            INFO("%s: deviceMemory: 0x%llx pAddress: 0x%llx", __func__,
                     (unsigned long long)memory, (unsigned long long)(*pAddress));
         }
 
@@ -5461,11 +5800,17 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult vkGetBlobInternal(VkDevice boxed_device, VkDeviceMemory memory, uint64_t hostBlobId) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto vk = dispatch_VkDevice(boxed_device);
+
         std::lock_guard<std::recursive_mutex> lock(mLock);
-        auto* tInfo = RenderThreadInfoVk::get();
-        uint32_t ctx_id = mSnapshotState == SnapshotState::Loading
-                              ? kTemporaryContextIdForSnapshotLoading
-                              : tInfo->ctx_id;
+
+        auto virtioGpuContextIdOpt = getContextIdForDeviceLocked(device);
+        if (!virtioGpuContextIdOpt) {
+            ERR("VkDevice:%p missing context id for vkAllocateMemory().");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+        const uint32_t virtioGpuContextId = *virtioGpuContextIdOpt;
 
         auto* info = android::base::find(mMemoryInfo, memory);
         if (!info) return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -5478,12 +5823,11 @@ class VkDecoderGlobalState::Impl {
             // The memory itself is destroyed only when all processes unmap / release their
             // handles.
             ExternalObjectManager::get()->addBlobDescriptorInfo(
-                ctx_id, hostBlobId, info->sharedMemory->releaseHandle(), handleType, info->caching,
-                std::nullopt);
+                virtioGpuContextId, hostBlobId, info->sharedMemory->releaseHandle(), handleType,
+                info->caching, std::nullopt);
         } else if (m_emu->features.ExternalBlob.enabled) {
             VkResult result;
-            auto device = unbox_VkDevice(boxed_device);
-            auto vk = dispatch_VkDevice(boxed_device);
+
             DescriptorType handle;
             uint32_t handleType;
             struct VulkanInfo vulkanInfo = {
@@ -5554,7 +5898,7 @@ class VkDecoderGlobalState::Impl {
 
             ManagedDescriptor managedHandle(handle);
             ExternalObjectManager::get()->addBlobDescriptorInfo(
-                ctx_id, hostBlobId, std::move(managedHandle), handleType, info->caching,
+                virtioGpuContextId, hostBlobId, std::move(managedHandle), handleType, info->caching,
                 std::optional<VulkanInfo>(vulkanInfo));
         } else if (!info->needUnmap) {
             auto device = unbox_VkDevice(boxed_device);
@@ -5578,7 +5922,7 @@ class VkDecoderGlobalState::Impl {
                     "using this blob may be corrupted/offset.",
                     kPageSizeforBlob, hva, alignedHva);
             }
-            ExternalObjectManager::get()->addMapping(ctx_id, hostBlobId,
+            ExternalObjectManager::get()->addMapping(virtioGpuContextId, hostBlobId,
                                                      (void*)(uintptr_t)alignedHva, info->caching);
             info->virtioGpuMapped = true;
             info->hostmemId = hostBlobId;
@@ -5624,9 +5968,15 @@ class VkDecoderGlobalState::Impl {
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
-        if (!deviceInfo) return VK_ERROR_UNKNOWN;
+        auto* commandPoolInfo = android::base::find(mCommandPoolInfo, pAllocateInfo->commandPool);
+        if (!deviceInfo || !commandPoolInfo) {
+            ERR("Cannot allocate command buffers, dependency not found! (%p, %p)", deviceInfo,
+                commandPoolInfo);
+            return VK_ERROR_UNKNOWN;
+        }
 
         for (uint32_t i = 0; i < pAllocateInfo->commandBufferCount; i++) {
+            VALIDATE_NEW_HANDLE_INFO_ENTRY(mCommandBufferInfo, pCommandBuffers[i]);
             mCommandBufferInfo[pCommandBuffers[i]] = CommandBufferInfo();
             mCommandBufferInfo[pCommandBuffers[i]].device = device;
             mCommandBufferInfo[pCommandBuffers[i]].debugUtilsHelper = deviceInfo->debugUtilsHelper;
@@ -5634,6 +5984,9 @@ class VkDecoderGlobalState::Impl {
             auto boxed = new_boxed_VkCommandBuffer(pCommandBuffers[i], vk,
                                                    false /* does not own dispatch */);
             mCommandBufferInfo[pCommandBuffers[i]].boxed = boxed;
+
+            commandPoolInfo->cmdBuffers.insert(pCommandBuffers[i]);
+
             pCommandBuffers[i] = (VkCommandBuffer)boxed;
         }
         return result;
@@ -5651,6 +6004,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
         std::lock_guard<std::recursive_mutex> lock(mLock);
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mCommandPoolInfo, *pCommandPool);
         mCommandPoolInfo[*pCommandPool] = CommandPoolInfo();
         auto& cmdPoolInfo = mCommandPoolInfo[*pCommandPool];
         cmdPoolInfo.device = device;
@@ -5667,7 +6021,13 @@ class VkDecoderGlobalState::Impl {
         std::unordered_map<VkCommandBuffer, CommandBufferInfo>& commandBufferInfos,
         const VkAllocationCallbacks* pAllocator) {
         for (const VkCommandBuffer commandBuffer : commandPoolInfo.cmdBuffers) {
-            commandBufferInfos.erase(commandBuffer);
+            auto iterInInfos = commandBufferInfos.find(commandBuffer);
+            if (iterInInfos != commandBufferInfos.end()) {
+                commandBufferInfos.erase(iterInInfos);
+            } else {
+                ERR("Cannot find command buffer reference (%p).",
+                    commandBuffer);
+            }
         }
 
         deviceDispatch->vkDestroyCommandPool(device, commandPool, pAllocator);
@@ -5827,38 +6187,37 @@ class VkDecoderGlobalState::Impl {
         }
 
         VkDevice device = VK_NULL_HANDLE;
-        Lock* ql;
+        Lock* ql = nullptr;
+        DeviceOpTrackerPtr opTracker = nullptr;
+        VkFence usedFence = fence;
+        DeviceOpWaitable queueCompletedWaitable;
         {
             std::lock_guard<std::recursive_mutex> lock(mLock);
+            auto* queueInfo = android::base::find(mQueueInfo, queue);
+            if (!queueInfo) {
+                ERR("vkQueueSubmit cannot find queue info for %p", queue);
+                return VK_ERROR_INITIALIZATION_FAILED;
+            }
+            device = queueInfo->device;
+            ql = queueInfo->physicalQueueLock.get();
 
-            {
-                auto* queueInfo = android::base::find(mQueueInfo, queue);
-                if (queueInfo) {
-                    device = queueInfo->device;
-                    // Unsafe to release when snapshot enabled.
-                    // Snapshot load might fail to find the shader modules if we release them here.
-                    if (!snapshotsEnabled()) {
-                        sBoxedHandleManager.processDelayedRemovesGlobalStateLocked(device);
-                    }
-                }
+            auto* deviceInfo = android::base::find(mDeviceInfo, device);
+            if (!deviceInfo) {
+                ERR("vkQueueSubmit cannot find device info for %p", device);
+                return VK_ERROR_INITIALIZATION_FAILED;
+            }
+            opTracker = deviceInfo->deviceOpTracker;
+
+            // Unsafe to release when snapshot enabled.
+            // Snapshot load might fail to find the shader modules if we release them here.
+            if (!snapshotsEnabled()) {
+                sBoxedHandleManager.processDelayedRemovesGlobalStateLocked(device);
             }
 
             for (uint32_t i = 0; i < submitCount; i++) {
                 executePreprocessRecursive(pSubmits[i]);
             }
-
-            auto* queueInfo = android::base::find(mQueueInfo, queue);
-            if (!queueInfo) return VK_SUCCESS;
-            ql = queueInfo->lock;
-        }
-
-        VkFence usedFence = fence;
-        DeviceOpWaitable queueCompletedWaitable;
-        {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            auto* deviceInfo = android::base::find(mDeviceInfo, device);
-            if (!deviceInfo) return VK_ERROR_INITIALIZATION_FAILED;
-            DeviceOpBuilder builder(*deviceInfo->deviceOpTracker);
+            DeviceOpBuilder builder = DeviceOpBuilder(*opTracker);
             if (VK_NULL_HANDLE == usedFence) {
                 // Note: This fence will be managed by the DeviceOpTracker after the
                 // OnQueueSubmittedWithFence call, so it does not need to be destroyed in the scope
@@ -5866,29 +6225,6 @@ class VkDecoderGlobalState::Impl {
                 usedFence = builder.CreateFenceForOp();
             }
             queueCompletedWaitable = builder.OnQueueSubmittedWithFence(usedFence);
-
-            deviceInfo->deviceOpTracker->PollAndProcessGarbage();
-        }
-
-        {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            std::unordered_set<HandleType> imageBarrierColorBuffers;
-            for (int i = 0; i < submitCount; i++) {
-                for (int j = 0; j < getCommandBufferCount(pSubmits[i]); j++) {
-                    VkCommandBuffer cmdBuffer = getCommandBuffer(pSubmits[i], j);
-                    CommandBufferInfo* cmdBufferInfo =
-                        android::base::find(mCommandBufferInfo, cmdBuffer);
-                    if (cmdBufferInfo) {
-                        imageBarrierColorBuffers.merge(cmdBufferInfo->imageBarrierColorBuffers);
-                    }
-                }
-            }
-            auto* deviceInfo = android::base::find(mDeviceInfo, device);
-            if (!deviceInfo) return VK_ERROR_INITIALIZATION_FAILED;
-            for (const auto& colorBuffer : imageBarrierColorBuffers) {
-                setColorBufferLatestUse(colorBuffer, queueCompletedWaitable,
-                                        deviceInfo->deviceOpTracker);
-            }
         }
 
         AutoLock qlock(*ql);
@@ -5898,46 +6234,55 @@ class VkDecoderGlobalState::Impl {
             WARN("dispatchVkQueueSubmit failed: %s [%d]", string_VkResult(result), result);
             return result;
         }
+
         {
             std::lock_guard<std::recursive_mutex> lock(mLock);
-            // Update image layouts
+
+            std::unordered_set<HandleType> imageBarrierColorBuffers;
             for (int i = 0; i < submitCount; i++) {
                 for (int j = 0; j < getCommandBufferCount(pSubmits[i]); j++) {
                     VkCommandBuffer cmdBuffer = getCommandBuffer(pSubmits[i], j);
                     CommandBufferInfo* cmdBufferInfo =
                         android::base::find(mCommandBufferInfo, cmdBuffer);
-                    if (!cmdBufferInfo) {
-                        continue;
-                    }
-                    for (const auto& ite : cmdBufferInfo->imageLayouts) {
-                        auto imageIte = mImageInfo.find(ite.first);
-                        if (imageIte == mImageInfo.end()) {
-                            continue;
+
+                    if (cmdBufferInfo) {
+                        imageBarrierColorBuffers.merge(cmdBufferInfo->imageBarrierColorBuffers);
+
+                        // Update image layouts
+                        for (const auto& ite : cmdBufferInfo->imageLayouts) {
+                            auto imageIte = mImageInfo.find(ite.first);
+                            if (imageIte == mImageInfo.end()) {
+                                continue;
+                            }
+                            imageIte->second.layout = ite.second;
                         }
-                        imageIte->second.layout = ite.second;
                     }
-                }
-            }
-            // Update latestUse for all wait/signal semaphores, to ensure that they
-            // are never asynchronously destroyed before the queue submissions referencing
-            // them have completed
-            for (int i = 0; i < submitCount; i++) {
-                for (int j = 0; j < getWaitSemaphoreCount(pSubmits[i]); j++) {
-                    SemaphoreInfo* semaphoreInfo =
-                        android::base::find(mSemaphoreInfo, getWaitSemaphore(pSubmits[i], j));
-                    if (semaphoreInfo) {
-                        semaphoreInfo->latestUse = queueCompletedWaitable;
+
+                    // Update latestUse for all wait/signal semaphores, to ensure that they
+                    // are never asynchronously destroyed before the queue submissions referencing
+                    // them have completed
+                    for (int j = 0; j < getWaitSemaphoreCount(pSubmits[i]); j++) {
+                        SemaphoreInfo* semaphoreInfo =
+                            android::base::find(mSemaphoreInfo, getWaitSemaphore(pSubmits[i], j));
+                        if (semaphoreInfo) {
+                            semaphoreInfo->latestUse = queueCompletedWaitable;
+                        }
                     }
-                }
-                for (int j = 0; j < getSignalSemaphoreCount(pSubmits[i]); j++) {
-                    SemaphoreInfo* semaphoreInfo =
-                        android::base::find(mSemaphoreInfo, getSignalSemaphore(pSubmits[i], j));
-                    if (semaphoreInfo) {
-                        semaphoreInfo->latestUse = queueCompletedWaitable;
+                    for (int j = 0; j < getSignalSemaphoreCount(pSubmits[i]); j++) {
+                        SemaphoreInfo* semaphoreInfo =
+                            android::base::find(mSemaphoreInfo, getSignalSemaphore(pSubmits[i], j));
+                        if (semaphoreInfo) {
+                            semaphoreInfo->latestUse = queueCompletedWaitable;
+                        }
                     }
                 }
             }
 
+            // Update latest use for color buffers
+            for (const auto& colorBuffer : imageBarrierColorBuffers) {
+                setColorBufferLatestUse(colorBuffer, queueCompletedWaitable, opTracker);
+            }
+
             // After vkQueueSubmit is called, we can signal the conditional variable
             // in FenceInfo, so that other threads (e.g. SyncThread) can call
             // waitForFence() on this fence.
@@ -5951,9 +6296,16 @@ class VkDecoderGlobalState::Impl {
                 // referencing it
                 fenceInfo->latestUse = queueCompletedWaitable;
             }
+
+            opTracker->PollAndProcessGarbage();
         }
+
         if (!releasedColorBuffers.empty()) {
-            vk->vkWaitForFences(device, 1, &usedFence, VK_TRUE, /* 1 sec */ 1000000000L);
+            result = vk->vkWaitForFences(device, 1, &usedFence, VK_TRUE, /* 1 sec */ 1000000000L);
+            if (result != VK_SUCCESS) {
+                ERR("vkWaitForFences failed: %s [%d]", string_VkResult(result), result);
+                return result;
+            }
 
             for (HandleType cb : releasedColorBuffers) {
                 m_emu->callbacks.flushColorBuffer(cb);
@@ -5974,7 +6326,13 @@ class VkDecoderGlobalState::Impl {
             std::lock_guard<std::recursive_mutex> lock(mLock);
             auto* queueInfo = android::base::find(mQueueInfo, queue);
             if (!queueInfo) return VK_SUCCESS;
-            ql = queueInfo->lock;
+            ql = queueInfo->physicalQueueLock.get();
+        }
+
+        if (mEnableVirtualVkQueue) {
+            // TODO(b/379862480): register and track gpu workload to wait only for them here, ie.
+            // not any other fences/work. It should not hold the queue lock/ql while waiting to
+            // allow submissions and other operations on the virtualized queue
         }
 
         AutoLock qlock(*ql);
@@ -5998,31 +6356,39 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    void destroyCommandBufferWithExclusiveInfos(
+    void freeCommandBufferWithExclusiveInfos(
         VkDevice device, VulkanDispatch* deviceDispatch, VkCommandBuffer commandBuffer,
         CommandBufferInfo& commandBufferInfo,
-        std::unordered_map<VkCommandPool, CommandPoolInfo> commandPoolInfos) {
+        std::unordered_map<VkCommandPool, CommandPoolInfo>& commandPoolInfos) {
         auto commandPool = commandBufferInfo.cmdPool;
 
         auto commandPoolInfoIt = commandPoolInfos.find(commandPool);
         if (commandPoolInfoIt == commandPoolInfos.end()) return;
         auto& commandPoolInfo = commandPoolInfoIt->second;
 
-        commandPoolInfo.cmdBuffers.erase(commandBuffer);
+        auto iterInPool = commandPoolInfo.cmdBuffers.find(commandBuffer);
+        if (iterInPool != commandPoolInfo.cmdBuffers.end()) {
+            commandPoolInfo.cmdBuffers.erase(iterInPool);
+        } else {
+            ERR("Cannot find command buffer reference (%p) in the pool.", commandBuffer);
+        }
 
         // Note delete_VkCommandBuffer(cmdBufferInfoIt->second.boxed); currently done in decoder.
 
         deviceDispatch->vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
     }
 
-    void destroyCommandBufferLocked(VkDevice device, VulkanDispatch* deviceDispatch,
-                                    VkCommandPool commandPool, VkCommandBuffer commandBuffer) {
+    void freeCommandBufferLocked(VkDevice device, VulkanDispatch* deviceDispatch,
+                                 VkCommandPool commandPool, VkCommandBuffer commandBuffer) {
         auto commandBufferInfoIt = mCommandBufferInfo.find(commandBuffer);
-        if (commandBufferInfoIt == mCommandBufferInfo.end()) return;
+        if (commandBufferInfoIt == mCommandBufferInfo.end()) {
+            WARN("freeCommandBufferLocked cannot find %p", commandBuffer);
+            return;
+        }
         auto& commandBufferInfo = commandBufferInfoIt->second;
 
-        destroyCommandBufferWithExclusiveInfos(device, deviceDispatch, commandBuffer,
-                                               commandBufferInfo, mCommandPoolInfo);
+        freeCommandBufferWithExclusiveInfos(device, deviceDispatch, commandBuffer,
+                                            commandBufferInfo, mCommandPoolInfo);
 
         mCommandBufferInfo.erase(commandBufferInfoIt);
     }
@@ -6040,7 +6406,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
         for (uint32_t i = 0; i < commandBufferCount; i++) {
-            destroyCommandBufferLocked(device, deviceDispatch, commandPool, pCommandBuffers[i]);
+            freeCommandBufferLocked(device, deviceDispatch, commandPool, pCommandBuffers[i]);
         }
     }
 
@@ -6471,6 +6837,7 @@ class VkDecoderGlobalState::Impl {
             return res;
         }
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mRenderPassInfo, *pRenderPass);
         auto& renderPassInfo = mRenderPassInfo[*pRenderPass];
         renderPassInfo.device = device;
 
@@ -6492,6 +6859,7 @@ class VkDecoderGlobalState::Impl {
             return res;
         }
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mRenderPassInfo, *pRenderPass);
         auto& renderPassInfo = mRenderPassInfo[*pRenderPass];
         renderPassInfo.device = device;
 
@@ -6527,13 +6895,31 @@ class VkDecoderGlobalState::Impl {
         destroyRenderPassLocked(device, deviceDispatch, renderPass, pAllocator);
     }
 
-    void registerRenderPassBeginInfo(VkCommandBuffer commandBuffer,
+    bool registerRenderPassBeginInfo(VkCommandBuffer commandBuffer,
                                      const VkRenderPassBeginInfo* pRenderPassBegin) {
+        if (!pRenderPassBegin) {
+            ERR("pRenderPassBegin is null");
+            return false;
+        }
+
+        std::lock_guard<std::recursive_mutex> lock(mLock);
         CommandBufferInfo* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
+        if (!cmdBufferInfo) {
+            ERR("VkCommandBuffer=%p not found in mCommandBufferInfo", commandBuffer);
+            return false;
+        }
+
         FramebufferInfo* fbInfo =
             android::base::find(mFramebufferInfo, pRenderPassBegin->framebuffer);
+        if (!fbInfo) {
+            ERR("pRenderPassBegin->framebuffer=%p not found in mFbInfo",
+                pRenderPassBegin->framebuffer);
+            return false;
+        }
+
         cmdBufferInfo->releasedColorBuffers.insert(fbInfo->attachedColorBuffers.begin(),
                                                    fbInfo->attachedColorBuffers.end());
+        return true;
     }
 
     void on_vkCmdBeginRenderPass(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
@@ -6541,8 +6927,9 @@ class VkDecoderGlobalState::Impl {
                                  VkSubpassContents contents) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
-        registerRenderPassBeginInfo(commandBuffer, pRenderPassBegin);
-        vk->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
+        if (registerRenderPassBeginInfo(commandBuffer, pRenderPassBegin)) {
+            vk->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
+        }
     }
 
     void on_vkCmdBeginRenderPass2(android::base::BumpPool* pool,
@@ -6551,8 +6938,9 @@ class VkDecoderGlobalState::Impl {
                                   const VkSubpassBeginInfo* pSubpassBeginInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
-        registerRenderPassBeginInfo(commandBuffer, pRenderPassBegin);
-        vk->vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
+        if (registerRenderPassBeginInfo(commandBuffer, pRenderPassBegin)) {
+            vk->vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
+        }
     }
 
     void on_vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool,
@@ -6594,6 +6982,7 @@ class VkDecoderGlobalState::Impl {
 
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mFramebufferInfo, *pFramebuffer);
         auto& framebufferInfo = mFramebufferInfo[*pFramebuffer];
         framebufferInfo.device = device;
 
@@ -6757,6 +7146,16 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
+    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue boxed_queue,
+                                  const VkPresentInfoKHR* pPresentInfo) {
+        // Note that on Android guests, this call will actually be handled
+        // with vkQueueSignalReleaseImageANDROID
+        auto queue = unbox_VkQueue(boxed_queue);
+        auto vk = dispatch_VkQueue(boxed_queue);
+
+        return vk->vkQueuePresentKHR(queue, pPresentInfo);
+    }
+
     void on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
                                          VkFormat format, VkDeviceSize* pOffset,
                                          VkDeviceSize* pRowPitchAlignment) {
@@ -6824,7 +7223,7 @@ class VkDecoderGlobalState::Impl {
             VkImageCreateInfo defaultVkImageCreateInfo = linearImageCreateInfo.toDefaultVk();
             VkResult result = vk->vkCreateImage(device, &defaultVkImageCreateInfo, nullptr, &image);
             if (result != VK_SUCCESS) {
-                fprintf(stderr, "vkCreateImage failed. size: (%u x %u) result: %d\n",
+                INFO("vkCreateImage failed. size: (%u x %u) result: %d",
                         linearImageCreateInfo.extent.width, linearImageCreateInfo.extent.height,
                         result);
                 return;
@@ -7197,7 +7596,7 @@ class VkDecoderGlobalState::Impl {
     AsyncResult registerQsriCallback(VkImage boxed_image, VkQsriTimeline::Callback callback) {
         std::lock_guard<std::recursive_mutex> lock(mLock);
 
-        VkImage image = unbox_VkImage(boxed_image);
+        VkImage image = try_unbox_VkImage(boxed_image);
         if (image == VK_NULL_HANDLE) return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
 
         auto imageInfoIt = mImageInfo.find(image);
@@ -7275,7 +7674,7 @@ class VkDecoderGlobalState::Impl {
             // written to one alias can be read by the other alias. Otherwise, the aliases interpret
             // the contents of the memory differently, ...
             std::unique_ptr<VkImageCreateInfo> colorBufferVkImageCi = nullptr;
-            std::string importSource;
+            const char* importSourceDebug = "";
             VkFormat resolvedFormat = VK_FORMAT_UNDEFINED;
             // Use UNORM formats for SRGB format requests.
             switch (imageCreateInfo.format) {
@@ -7301,7 +7700,7 @@ class VkDecoderGlobalState::Impl {
                 colorBufferVkImageCi = generateColorBufferVkImageCreateInfo(
                     resolvedFormat, imageCreateInfo.extent.width, imageCreateInfo.extent.height,
                     imageCreateInfo.tiling);
-                importSource = "AHardwareBuffer";
+                importSourceDebug = "AHardwareBuffer";
             } else if (pNativeBufferANDROID) {
                 // For native buffer binding, we can query the creation parameters from handle.
                 uint32_t cbHandle = *static_cast<const uint32_t*>(pNativeBufferANDROID->handle);
@@ -7312,7 +7711,7 @@ class VkDecoderGlobalState::Impl {
                 } else {
                     ERR("Unknown ColorBuffer handle: %" PRIu32 ".", cbHandle);
                 }
-                importSource = "NativeBufferANDROID";
+                importSourceDebug = "NativeBufferANDROID";
             }
             if (!colorBufferVkImageCi) {
                 continue;
@@ -7322,7 +7721,7 @@ class VkDecoderGlobalState::Impl {
                 ERR("The VkImageCreateInfo to import %s contains unsupported VkImageCreateFlags. "
                     "All supported VkImageCreateFlags are %s, the input VkImageCreateInfo requires "
                     "support for %s.",
-                    importSource.c_str()?:"",
+                    importSourceDebug,
                     string_VkImageCreateFlags(colorBufferVkImageCi->flags).c_str()?:"",
                     string_VkImageCreateFlags(imageCreateInfo.flags).c_str()?:"");
             }
@@ -7330,38 +7729,38 @@ class VkDecoderGlobalState::Impl {
             if (imageCreateInfo.imageType != colorBufferVkImageCi->imageType) {
                 ERR("The VkImageCreateInfo to import %s has an unexpected VkImageType: %s, %s "
                     "expected.",
-                    importSource.c_str()?:"", string_VkImageType(imageCreateInfo.imageType),
+                    importSourceDebug, string_VkImageType(imageCreateInfo.imageType),
                     string_VkImageType(colorBufferVkImageCi->imageType));
             }
             if (imageCreateInfo.extent.depth != colorBufferVkImageCi->extent.depth) {
                 ERR("The VkImageCreateInfo to import %s has an unexpected VkExtent::depth: %" PRIu32
                     ", %" PRIu32 " expected.",
-                    importSource.c_str()?:"", imageCreateInfo.extent.depth,
+                    importSourceDebug, imageCreateInfo.extent.depth,
                     colorBufferVkImageCi->extent.depth);
             }
             if (imageCreateInfo.mipLevels != colorBufferVkImageCi->mipLevels) {
                 ERR("The VkImageCreateInfo to import %s has an unexpected mipLevels: %" PRIu32
                     ", %" PRIu32 " expected.",
-                    importSource.c_str()?:"", imageCreateInfo.mipLevels,
+                    importSourceDebug, imageCreateInfo.mipLevels,
                     colorBufferVkImageCi->mipLevels);
             }
             if (imageCreateInfo.arrayLayers != colorBufferVkImageCi->arrayLayers) {
                 ERR("The VkImageCreateInfo to import %s has an unexpected arrayLayers: %" PRIu32
                     ", %" PRIu32 " expected.",
-                    importSource.c_str()?:"", imageCreateInfo.arrayLayers,
+                    importSourceDebug, imageCreateInfo.arrayLayers,
                     colorBufferVkImageCi->arrayLayers);
             }
             if (imageCreateInfo.samples != colorBufferVkImageCi->samples) {
                 ERR("The VkImageCreateInfo to import %s has an unexpected VkSampleCountFlagBits: "
                     "%s, %s expected.",
-                    importSource.c_str()?:"", string_VkSampleCountFlagBits(imageCreateInfo.samples),
+                    importSourceDebug, string_VkSampleCountFlagBits(imageCreateInfo.samples),
                     string_VkSampleCountFlagBits(colorBufferVkImageCi->samples));
             }
             if (imageCreateInfo.usage & (~colorBufferVkImageCi->usage)) {
                 ERR("The VkImageCreateInfo to import %s contains unsupported VkImageUsageFlags. "
                     "All supported VkImageUsageFlags are %s, the input VkImageCreateInfo requires "
                     "support for %s.",
-                    importSource.c_str()?:"",
+                    importSourceDebug,
                     string_VkImageUsageFlags(colorBufferVkImageCi->usage).c_str()?:"",
                     string_VkImageUsageFlags(imageCreateInfo.usage).c_str()?:"");
             }
@@ -7375,32 +7774,32 @@ class VkDecoderGlobalState::Impl {
             if (resolvedFormat != colorBufferVkImageCi->format) {
                 ERR("The VkImageCreateInfo to import %s contains unexpected VkFormat:"
                     "%s [%d]. %s [%d] expected.",
-                    importSource.c_str() ?: "", string_VkFormat(imageCreateInfo.format),
+                    importSourceDebug, string_VkFormat(imageCreateInfo.format),
                     imageCreateInfo.format, string_VkFormat(colorBufferVkImageCi->format),
                     colorBufferVkImageCi->format);
             }
             if (imageCreateInfo.extent.width != colorBufferVkImageCi->extent.width) {
                 ERR("The VkImageCreateInfo to import %s contains unexpected VkExtent::width: "
                     "%" PRIu32 ". %" PRIu32 " expected.",
-                    importSource.c_str()?:"", imageCreateInfo.extent.width,
+                    importSourceDebug, imageCreateInfo.extent.width,
                     colorBufferVkImageCi->extent.width);
             }
             if (imageCreateInfo.extent.height != colorBufferVkImageCi->extent.height) {
                 ERR("The VkImageCreateInfo to import %s contains unexpected VkExtent::height: "
                     "%" PRIu32 ". %" PRIu32 " expected.",
-                    importSource.c_str()?:"", imageCreateInfo.extent.height,
+                    importSourceDebug, imageCreateInfo.extent.height,
                     colorBufferVkImageCi->extent.height);
             }
             if (imageCreateInfo.tiling != colorBufferVkImageCi->tiling) {
                 ERR("The VkImageCreateInfo to import %s contains unexpected VkImageTiling: %s. %s "
                     "expected.",
-                    importSource.c_str()?:"", string_VkImageTiling(imageCreateInfo.tiling),
+                    importSourceDebug, string_VkImageTiling(imageCreateInfo.tiling),
                     string_VkImageTiling(colorBufferVkImageCi->tiling));
             }
             if (imageCreateInfo.sharingMode != colorBufferVkImageCi->sharingMode) {
                 ERR("The VkImageCreateInfo to import %s contains unexpected VkSharingMode: %s. %s "
                     "expected.",
-                    importSource.c_str()?:"", string_VkSharingMode(imageCreateInfo.sharingMode),
+                    importSourceDebug, string_VkSharingMode(imageCreateInfo.sharingMode),
                     string_VkSharingMode(colorBufferVkImageCi->sharingMode));
             }
         }
@@ -7489,11 +7888,6 @@ class VkDecoderGlobalState::Impl {
         }                                                                                         \
         sBoxedHandleManager.remove((uint64_t)boxed);                                              \
     }                                                                                             \
-    type unbox_##type(type boxed) {                                                               \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return VK_NULL_HANDLE;                                                          \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
     OrderMaintenanceInfo* ordmaint_##type(type boxed) {                                           \
         auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
         if (!elt) return 0;                                                                       \
@@ -7512,14 +7906,10 @@ class VkDecoderGlobalState::Impl {
         }                                                                                         \
         return stream;                                                                            \
     }                                                                                             \
-    type unboxed_to_boxed_##type(type unboxed) {                                                  \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
-    }                                                                                             \
     VulkanDispatch* dispatch_##type(type boxed) {                                                 \
         auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
         if (!elt) {                                                                               \
-            fprintf(stderr, "%s: err not found boxed %p\n", __func__, boxed);                     \
+            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
             return nullptr;                                                                       \
         }                                                                                         \
         return elt->dispatch;                                                                     \
@@ -7556,11 +7946,74 @@ class VkDecoderGlobalState::Impl {
             return VK_NULL_HANDLE;                                                                \
         }                                                                                         \
         return (type)elt->underlying;                                                             \
+    }                                                                                             \
+    type try_unbox_##type(type boxed) {                                                           \
+        AutoLock lock(sBoxedHandleManager.lock);                                                  \
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
+        if (!elt) {                                                                               \
+            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
+            return VK_NULL_HANDLE;                                                                \
+        }                                                                                         \
+        return (type)elt->underlying;                                                             \
     }
 
     GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_IMPL)
     GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_IMPL)
 
+#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_REGULAR_UNBOX_IMPL(type)                             \
+    type unbox_##type(type boxed) {                                                               \
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
+        if (!elt){                                                                                \
+            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
+            return VK_NULL_HANDLE;                                                                \
+        }                                                                                         \
+        return (type)elt->underlying;                                                             \
+    }                                                                                             \
+    type try_unbox_##type(type boxed) {                                                           \
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
+        if (!elt){                                                                                \
+            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
+            return VK_NULL_HANDLE;                                                                \
+        }                                                                                         \
+        return (type)elt->underlying;                                                             \
+    }                                                                                             \
+    type unboxed_to_boxed_##type(type unboxed) {                                                  \
+        AutoLock lock(sBoxedHandleManager.lock);                                                  \
+        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
+    }
+
+    GOLDFISH_VK_LIST_DISPATCHABLE_REGULAR_UNBOX_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_REGULAR_UNBOX_IMPL)
+
+    // Custom unbox_* functions or GOLDFISH_VK_LIST_DISPATCHABLE_CUSTOM_UNBOX_HANDLE_TYPES
+    // VkQueue objects can be virtual, meaning that multiple boxed queues can map into a single
+    // physical queue on the host GPU. Some conversion is needed for unboxing to physical.
+    VkQueue unbox_VkQueueImp(VkQueue boxed) {
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+        if (!elt) {
+            return VK_NULL_HANDLE;
+        }
+        const uint64_t unboxedQueue64 = elt->underlying;
+        if (mEnableVirtualVkQueue) {
+            // Clear virtual bit and unbox into the actual physical queue handle
+            return (VkQueue)(unboxedQueue64 & ~QueueInfo::kVirtualQueueBit);
+        }
+        return (VkQueue)(unboxedQueue64);
+    }
+    VkQueue unbox_VkQueue(VkQueue boxed) {
+        VkQueue unboxed = unbox_VkQueueImp(boxed);
+        if (unboxed == VK_NULL_HANDLE) {
+            ERR("%s: Failed to unbox %p", __func__, boxed);
+        }
+        return unboxed;
+    }
+    VkQueue try_unbox_VkQueue(VkQueue boxed) {
+        VkQueue unboxed = unbox_VkQueueImp(boxed);
+        if (unboxed == VK_NULL_HANDLE) {
+            WARN("%s: Failed to unbox %p", __func__, boxed);
+        }
+        return unboxed;
+    }
+
     VkDecoderSnapshot* snapshot() { return &mSnapshot; }
     SnapshotState getSnapshotState() { return mSnapshotState; }
 
@@ -7666,6 +8119,9 @@ class VkDecoderGlobalState::Impl {
             if (hasDeviceExtension(properties, VK_EXT_METAL_OBJECTS_EXTENSION_NAME)) {
                 res.push_back(VK_EXT_METAL_OBJECTS_EXTENSION_NAME);
             }
+            if (hasDeviceExtension(properties, VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME)) {
+                res.push_back(VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME);
+            }
         } else {
             // Non-MoltenVK path, use memory_fd
             if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME)) {
@@ -7693,6 +8149,14 @@ class VkDecoderGlobalState::Impl {
         }
 
 #endif
+
+        if (hasDeviceExtension(properties, VK_EXT_PRIVATE_DATA_EXTENSION_NAME)) {
+            //TODO(b/378686769): Enable private data extension where available to
+            // mitigate the issues with duplicated vulkan handles. This should be
+            // removed once the issue is properly resolved.
+            res.push_back(VK_EXT_PRIVATE_DATA_EXTENSION_NAME);
+        }
+
         return res;
     }
 
@@ -7750,7 +8214,7 @@ class VkDecoderGlobalState::Impl {
                 for (auto& deviceQueue : it.second) {
                     *queue = deviceQueue;
                     *queueFamilyIndex = index;
-                    *queueLock = mQueueInfo.at(deviceQueue).lock;
+                    *queueLock = mQueueInfo.at(deviceQueue).physicalQueueLock.get();
                     return true;
                 }
             }
@@ -7760,7 +8224,7 @@ class VkDecoderGlobalState::Impl {
             // Use queue family index 0.
             *queue = zeroIt->second[0];
             *queueFamilyIndex = 0;
-            *queueLock = mQueueInfo.at(zeroIt->second[0]).lock;
+            *queueLock = mQueueInfo.at(zeroIt->second[0]).physicalQueueLock.get();
             return true;
         }
 
@@ -8051,6 +8515,8 @@ class VkDecoderGlobalState::Impl {
             if (physicalDeviceInstance != instance) continue;
             mPhysicalDeviceToInstance.erase(physicalDeviceInstanceIt);
 
+            mPhysdevInfo.erase(physicalDevice);
+
             auto deviceInfoIt = mDeviceInfo.find(device);
             if (deviceInfoIt == mDeviceInfo.end()) continue;
 
@@ -8063,11 +8529,13 @@ class VkDecoderGlobalState::Impl {
             extractInfosWithDeviceInto(device, mDescriptorPoolInfo, deviceObjects.descriptorPools);
             extractInfosWithDeviceInto(device, mDescriptorSetLayoutInfo,
                                        deviceObjects.descriptorSetLayouts);
+            extractInfosWithDeviceInto(device, mFenceInfo, deviceObjects.fences);
             extractInfosWithDeviceInto(device, mFramebufferInfo, deviceObjects.framebuffers);
             extractInfosWithDeviceInto(device, mImageInfo, deviceObjects.images);
             extractInfosWithDeviceInto(device, mImageViewInfo, deviceObjects.imageViews);
             extractInfosWithDeviceInto(device, mMemoryInfo, deviceObjects.memories);
             extractInfosWithDeviceInto(device, mPipelineCacheInfo, deviceObjects.pipelineCaches);
+            extractInfosWithDeviceInto(device, mQueueInfo, deviceObjects.queues);
             extractInfosWithDeviceInto(device, mPipelineInfo, deviceObjects.pipelines);
             extractInfosWithDeviceInto(device, mRenderPassInfo, deviceObjects.renderPasses);
             extractInfosWithDeviceInto(device, mSemaphoreInfo, deviceObjects.semaphores);
@@ -8077,6 +8545,15 @@ class VkDecoderGlobalState::Impl {
         for (InstanceObjects::DeviceObjects& deviceObjects : objects.devices) {
             mDeviceToPhysicalDevice.erase(deviceObjects.device.key());
         }
+
+        for (auto it = mPhysicalDeviceToInstance.begin(); it != mPhysicalDeviceToInstance.end();) {
+            auto current = it++;
+            auto physicalDevice = current->first;
+            auto& physicalDeviceInstance = current->second;
+            if (physicalDeviceInstance != instance) continue;
+            mPhysicalDeviceToInstance.erase(current);
+            mPhysdevInfo.erase(physicalDevice);
+        }
     }
 
     void destroyInstanceObjects(InstanceObjects& objects) {
@@ -8120,7 +8597,7 @@ class VkDecoderGlobalState::Impl {
             }
 
             for (auto& [commandBuffer, commandBufferInfo] : deviceObjects.commandBuffers) {
-                destroyCommandBufferWithExclusiveInfos(device, deviceDispatch, commandBuffer,
+                freeCommandBufferWithExclusiveInfos(device, deviceDispatch, commandBuffer,
                                                        commandBufferInfo,
                                                        deviceObjects.commandPools);
             }
@@ -8351,10 +8828,12 @@ class VkDecoderGlobalState::Impl {
     VkEmulation* m_emu;
     emugl::RenderDocWithMultipleVkInstances* mRenderDocWithMultipleVkInstances = nullptr;
     bool mSnapshotsEnabled = false;
+    bool mBatchedDescriptorSetUpdateEnabled = false;
     bool mVkCleanupEnabled = true;
     bool mLogging = false;
     bool mVerbosePrints = false;
     bool mUseOldMemoryCleanupPath = false;
+    bool mEnableVirtualVkQueue = false;
 
     std::recursive_mutex mLock;
 
@@ -8452,12 +8931,6 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    template <class T>
-    class NonDispatchableHandleInfo {
-       public:
-        T underlying;
-    };
-
     std::unordered_map<VkInstance, InstanceInfo> mInstanceInfo;
     std::unordered_map<VkPhysicalDevice, PhysicalDeviceInfo> mPhysdevInfo;
     std::unordered_map<VkDevice, DeviceInfo> mDeviceInfo;
@@ -8506,6 +8979,12 @@ class VkDecoderGlobalState::Impl {
     std::vector<uint64_t> mCreatedHandlesForSnapshotLoad;
     size_t mCreatedHandlesForSnapshotLoadIndex = 0;
 
+    // NOTE: Only present during snapshot loading. This is needed to associate
+    // `VkDevice`s with Virtio GPU context ids because API calls are not currently
+    // replayed on the "same" RenderThread which originally made the API call so
+    // RenderThreadInfoVk::ctx_id is not available.
+    std::optional<std::unordered_map<VkDevice, uint32_t>> mSnapshotLoadVkDeviceToVirtioCpuContextId;
+
     Lock mOccupiedGpasLock;
     // Back-reference to the VkDeviceMemory that is occupying a particular
     // guest physical address
@@ -8598,6 +9077,12 @@ void VkDecoderGlobalState::reset() {
 
 // Snapshots
 bool VkDecoderGlobalState::snapshotsEnabled() const { return mImpl->snapshotsEnabled(); }
+bool VkDecoderGlobalState::batchedDescriptorSetUpdateEnabled() const { return mImpl->batchedDescriptorSetUpdateEnabled(); }
+
+uint64_t VkDecoderGlobalState::newGlobalVkGenericHandle() {
+    DispatchableHandleInfo<uint64_t> item;                                                    \
+    return mImpl->newGlobalHandle(item, Tag_VkGeneric);
+}
 
 VkDecoderGlobalState::SnapshotState VkDecoderGlobalState::getSnapshotState() const {
     return mImpl->getSnapshotState();
@@ -8721,6 +9206,25 @@ void VkDecoderGlobalState::on_vkGetPhysicalDeviceProperties2(
     mImpl->on_vkGetPhysicalDeviceProperties2(pool, physicalDevice, pProperties);
 }
 
+void VkDecoderGlobalState::on_vkGetPhysicalDeviceQueueFamilyProperties(
+    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
+    mImpl->on_vkGetPhysicalDeviceQueueFamilyProperties(
+        pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+}
+
+void VkDecoderGlobalState::on_vkGetPhysicalDeviceQueueFamilyProperties2(
+    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
+    mImpl->on_vkGetPhysicalDeviceQueueFamilyProperties2(
+        pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+}
+
+VkResult VkDecoderGlobalState::on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue queue,
+                                                 const VkPresentInfoKHR* pPresentInfo) {
+    return mImpl->on_vkQueuePresentKHR(pool, queue, pPresentInfo);
+}
+
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceProperties2KHR(
     android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
     VkPhysicalDeviceProperties2* pProperties) {
@@ -9011,6 +9515,14 @@ VkResult VkDecoderGlobalState::on_vkCreateGraphicsPipelines(
                                                pCreateInfos, pAllocator, pPipelines);
 }
 
+VkResult VkDecoderGlobalState::on_vkCreateComputePipelines(
+    android::base::BumpPool* pool, VkDevice boxed_device, VkPipelineCache pipelineCache,
+    uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos,
+    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
+    return mImpl->on_vkCreateComputePipelines(pool, boxed_device, pipelineCache, createInfoCount,
+                                               pCreateInfos, pAllocator, pPipelines);
+}
+
 void VkDecoderGlobalState::on_vkDestroyPipeline(android::base::BumpPool* pool,
                                                 VkDevice boxed_device, VkPipeline pipeline,
                                                 const VkAllocationCallbacks* pAllocator) {
@@ -9547,7 +10059,12 @@ void VkDecoderGlobalState::on_vkQueueBindSparseAsyncGOOGLE(android::base::BumpPo
                                                            VkQueue queue, uint32_t bindInfoCount,
                                                            const VkBindSparseInfo* pBindInfo,
                                                            VkFence fence) {
-    mImpl->on_vkQueueBindSparse(pool, queue, bindInfoCount, pBindInfo, fence);
+    VkResult res = mImpl->on_vkQueueBindSparse(pool, queue, bindInfoCount, pBindInfo, fence);
+    if (res != VK_SUCCESS) {
+        // Report an error here as we don't use the result after this call
+        ERR("vkQueueBindSparse failed with: %s [%d], bindInfoCount=%d, fence=%p",
+            string_VkResult(res), res, bindInfoCount, fence);
+    }
 }
 
 void VkDecoderGlobalState::on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
@@ -9737,36 +10254,54 @@ LIST_TRANSFORMED_TYPES(DEFINE_TRANSFORMED_TYPE_IMPL)
     }                                                                                          \
     void VkDecoderGlobalState::delete_##type(type boxed) { mImpl->delete_##type(boxed); }      \
     type VkDecoderGlobalState::unbox_##type(type boxed) { return mImpl->unbox_##type(boxed); } \
-    type VkDecoderGlobalState::unboxed_to_boxed_##type(type unboxed) {                         \
-        return mImpl->unboxed_to_boxed_##type(unboxed);                                        \
+    type VkDecoderGlobalState::try_unbox_##type(type boxed) {                                  \
+        return mImpl->try_unbox_##type(boxed);                                                 \
     }                                                                                          \
     VulkanDispatch* VkDecoderGlobalState::dispatch_##type(type boxed) {                        \
         return mImpl->dispatch_##type(boxed);                                                  \
     }
 
+#define DEFINE_UNBOXED_TO_BOXED_DISPATCHABLE_HANDLE_API_DEF(type)                              \
+    type VkDecoderGlobalState::unboxed_to_boxed_##type(type unboxed) {                         \
+        return mImpl->unboxed_to_boxed_##type(unboxed);                                        \
+    }
+
 #define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DEF(type)                                     \
     type VkDecoderGlobalState::new_boxed_non_dispatchable_##type(type underlying) {            \
         return mImpl->new_boxed_non_dispatchable_##type(underlying);                           \
     }                                                                                          \
     void VkDecoderGlobalState::delete_##type(type boxed) { mImpl->delete_##type(boxed); }      \
     type VkDecoderGlobalState::unbox_##type(type boxed) { return mImpl->unbox_##type(boxed); } \
-    type VkDecoderGlobalState::unboxed_to_boxed_non_dispatchable_##type(type unboxed) {        \
-        return mImpl->unboxed_to_boxed_non_dispatchable_##type(unboxed);                       \
+    type VkDecoderGlobalState::try_unbox_##type(type boxed) {                                  \
+        return mImpl->try_unbox_##type(boxed);                                                 \
     }
 
 GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DEF)
 GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DEF)
 
+// Custom unbox and non dispatchable handles should not use unboxed_to_boxed as there is no 1-1
+// mapping
+GOLDFISH_VK_LIST_DISPATCHABLE_REGULAR_UNBOX_HANDLE_TYPES(
+    DEFINE_UNBOXED_TO_BOXED_DISPATCHABLE_HANDLE_API_DEF)
+
 #define DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DEF(type)                                     \
     type unbox_##type(type boxed) {                                                               \
         auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
         if (!elt) return VK_NULL_HANDLE;                                                          \
         return (type)elt->underlying;                                                             \
     }                                                                                             \
+    type try_unbox_##type(type boxed) {                                                           \
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
+        if (!elt) {                                                                               \
+            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
+            return VK_NULL_HANDLE;                                                                \
+        }                                                                                         \
+        return (type)elt->underlying;                                                             \
+    }                                                                                             \
     VulkanDispatch* dispatch_##type(type boxed) {                                                 \
         auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
         if (!elt) {                                                                               \
-            fprintf(stderr, "%s: err not found boxed %p\n", __func__, boxed);                     \
+            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
             return nullptr;                                                                       \
         }                                                                                         \
         return elt->dispatch;                                                                     \
@@ -9808,6 +10343,15 @@ GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HAN
         }                                                                                         \
         return (type)elt->underlying;                                                             \
     }                                                                                             \
+    type try_unbox_##type(type boxed) {                                                           \
+        if (!boxed) return boxed;                                                                 \
+        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
+        if (!elt) {                                                                               \
+            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
+            return VK_NULL_HANDLE;                                                                \
+        }                                                                                         \
+        return (type)elt->underlying;                                                             \
+    }                                                                                             \
     type unboxed_to_boxed_non_dispatchable_##type(type unboxed) {                                 \
         if (!unboxed) {                                                                           \
             return nullptr;                                                                       \
diff --git a/host/vulkan/VkDecoderGlobalState.h b/host/vulkan/VkDecoderGlobalState.h
index dcb24c526..eb455a399 100644
--- a/host/vulkan/VkDecoderGlobalState.h
+++ b/host/vulkan/VkDecoderGlobalState.h
@@ -83,6 +83,8 @@ class VkDecoderGlobalState {
     // Snapshot save/load
     bool snapshotsEnabled() const;
 
+    bool batchedDescriptorSetUpdateEnabled() const;
+
     SnapshotState getSnapshotState() const;
 
     const gfxstream::host::FeatureSet& getFeatures() const;
@@ -175,6 +177,14 @@ class VkDecoderGlobalState {
                                               VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceProperties2* pProperties);
 
+    // Override queue properties
+    void on_vkGetPhysicalDeviceQueueFamilyProperties(
+        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
+    void on_vkGetPhysicalDeviceQueueFamilyProperties2(
+        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
+
     // Override memory types advertised from host
     //
     void on_vkGetPhysicalDeviceMemoryProperties(
@@ -314,6 +324,12 @@ class VkDecoderGlobalState {
                                           const VkAllocationCallbacks* pAllocator,
                                           VkPipeline* pPipelines);
 
+    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool, VkDevice device,
+                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
+                                          const VkComputePipelineCreateInfo* pCreateInfos,
+                                          const VkAllocationCallbacks* pAllocator,
+                                          VkPipeline* pPipelines);
+
     void on_vkDestroyPipeline(android::base::BumpPool* pool, VkDevice device, VkPipeline pipeline,
                               const VkAllocationCallbacks* pAllocator);
 
@@ -689,6 +705,8 @@ class VkDecoderGlobalState {
                                                         VkQueue queue, uint32_t waitSemaphoreCount,
                                                         const VkSemaphore* pWaitSemaphores,
                                                         VkImage image);
+    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue queue,
+                                  const VkPresentInfoKHR* pPresentInfo);
 
     VkResult on_vkCreateSamplerYcbcrConversion(
         android::base::BumpPool* pool, VkDevice device,
@@ -744,6 +762,26 @@ class VkDecoderGlobalState {
     // Snapshot access
     VkDecoderSnapshot* snapshot();
 
+    // get a generic handle, this handle
+    // currently is used to represent some
+    // action related api call, such as
+    // vkUpdateDescriptorSets, vkBeginCommandBuffer,
+    // vkCmd***
+    // this generic handle differs from other
+    // cration handles (such as vkAllocate***,
+    // vkCreate***); but important for snapshoter
+    // to use this generic handle to represent some
+    // actions and their dependency. with this,
+    // the action apis will naturally fit into
+    // the dependency graph to ensure correct
+    // ordering of api calls during snapshot save and during
+    // snapshot load; this will deprecate the current
+    // approach of appending "modifying api's"
+    // near the end of snapshot save and loading; the reason
+    // to deprecate the modifying api approach is that it
+    // cannot handle dependencies properly.
+    uint64_t newGlobalVkGenericHandle();
+
 #define DEFINE_TRANSFORMED_TYPE_PROTOTYPE(type)                \
     void transformImpl_##type##_tohost(const type*, uint32_t); \
     void transformImpl_##type##_fromhost(const type*, uint32_t);
@@ -755,6 +793,7 @@ class VkDecoderGlobalState {
     type new_boxed_##type(type underlying, VulkanDispatch* dispatch, bool ownDispatch); \
     void delete_##type(type boxed);                                                     \
     type unbox_##type(type boxed);                                                      \
+    type try_unbox_##type(type boxed);                                                  \
     type unboxed_to_boxed_##type(type boxed);                                           \
     VulkanDispatch* dispatch_##type(type boxed);
 
@@ -762,6 +801,7 @@ class VkDecoderGlobalState {
     type new_boxed_non_dispatchable_##type(type underlying); \
     void delete_##type(type boxed);                          \
     type unbox_##type(type boxed);                           \
+    type try_unbox_##type(type boxed);                       \
     type unboxed_to_boxed_non_dispatchable_##type(type boxed);
 
     GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DECL)
diff --git a/host/vulkan/VkDecoderInternalStructs.h b/host/vulkan/VkDecoderInternalStructs.h
index 481d18768..0b90d6d5d 100644
--- a/host/vulkan/VkDecoderInternalStructs.h
+++ b/host/vulkan/VkDecoderInternalStructs.h
@@ -22,6 +22,7 @@
 
 #include <stdlib.h>
 
+#include <optional>
 #include <set>
 #include <string>
 #include <unordered_map>
@@ -187,6 +188,10 @@ struct PhysicalDeviceInfo {
     std::unique_ptr<EmulatedPhysicalDeviceMemoryProperties> memoryPropertiesHelper;
     std::vector<VkQueueFamilyProperties> queueFamilyProperties;
     VkPhysicalDevice boxed = nullptr;
+
+    // Indicates that if the graphics queue family properties are overridden for
+    // this physical device to include a virtual queue.
+    bool hasVirtualGraphicsQueues = false;
 };
 
 struct ExternalFenceInfo {
@@ -209,6 +214,7 @@ struct DeviceInfo {
     std::set<VkFormat> imageFormats = {};  // image formats used on this device
     std::unique_ptr<GpuDecompressionPipelineManager> decompPipelines = nullptr;
     DeviceOpTrackerPtr deviceOpTracker = nullptr;
+    std::optional<uint32_t> virtioGpuContextId;
 
     // True if this is a compressed image that needs to be decompressed on the GPU (with our
     // compute shader)
@@ -227,11 +233,19 @@ struct DeviceInfo {
 };
 
 struct QueueInfo {
-    android::base::Lock* lock = nullptr;
+    std::shared_ptr<android::base::Lock> physicalQueueLock;
     VkDevice device;
     uint32_t queueFamilyIndex;
     VkQueue boxed = nullptr;
-    uint32_t sequenceNumber = 0;
+
+    // In order to create a virtual queue handle, we use an offset to the physical
+    // queue handle value. This assumes the new generated virtual handle value will
+    // be unique and won't be generated by the actual GPU. This is expected to be
+    // true since most implementations will use a pointer for the handle value and
+    // they will be at least 4-byte aligned. Using a small value allows us to check
+    // if a given 'unboxed' queue handle value is virtual and convert into the actual
+    // physical one easily, without locking for mQueueInfo.
+    static const uint64_t kVirtualQueueBit = 0x1;
 };
 
 struct BufferInfo {
diff --git a/host/vulkan/VkDecoderSnapshot.cpp b/host/vulkan/VkDecoderSnapshot.cpp
index 494c2feda..490501230 100644
--- a/host/vulkan/VkDecoderSnapshot.cpp
+++ b/host/vulkan/VkDecoderSnapshot.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module VkDecoderSnapshot
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -785,7 +786,29 @@ class VkDecoderSnapshot::Impl {
     void vkAllocateDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
                                   android::base::BumpPool* pool, VkResult input_result,
                                   VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo,
-                                  VkDescriptorSet* pDescriptorSets) {}
+                                  VkDescriptorSet* pDescriptorSets) {
+        if (!pDescriptorSets) return;
+        android::base::AutoLock lock(mLock);
+        // pDescriptorSets create
+        mReconstruction.addHandles((const uint64_t*)pDescriptorSets,
+                                   pAllocateInfo->descriptorSetCount);
+        mReconstruction.addHandleDependency((const uint64_t*)pDescriptorSets,
+                                            pAllocateInfo->descriptorSetCount,
+                                            (uint64_t)(uintptr_t)device);
+        mReconstruction.addHandleDependency(
+            (const uint64_t*)pDescriptorSets, pAllocateInfo->descriptorSetCount,
+            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDescriptorPool(
+                pAllocateInfo->descriptorPool));
+        auto apiHandle = mReconstruction.createApiInfo();
+        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
+        mReconstruction.setApiTrace(apiInfo, OP_vkAllocateDescriptorSets, snapshotTraceBegin,
+                                    snapshotTraceBytes);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorSets,
+                                            pAllocateInfo->descriptorSetCount, apiHandle,
+                                            VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pDescriptorSets,
+                                                pAllocateInfo->descriptorSetCount);
+    }
     void vkFreeDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
                               android::base::BumpPool* pool, VkResult input_result, VkDevice device,
                               VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
@@ -800,7 +823,58 @@ class VkDecoderSnapshot::Impl {
                                 uint32_t descriptorWriteCount,
                                 const VkWriteDescriptorSet* pDescriptorWrites,
                                 uint32_t descriptorCopyCount,
-                                const VkCopyDescriptorSet* pDescriptorCopies) {}
+                                const VkCopyDescriptorSet* pDescriptorCopies) {
+        android::base::AutoLock lock(mLock);
+        // pDescriptorWrites action
+        VkDecoderGlobalState* m_state = VkDecoderGlobalState::get();
+        if (m_state->batchedDescriptorSetUpdateEnabled()) {
+            return;
+        }
+        uint64_t handle = m_state->newGlobalVkGenericHandle();
+        mReconstruction.addHandles((const uint64_t*)(&handle), 1);
+        auto apiHandle = mReconstruction.createApiInfo();
+        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
+        mReconstruction.setApiTrace(apiInfo, OP_vkUpdateDescriptorSets, snapshotTraceBegin,
+                                    snapshotTraceBytes);
+        for (uint32_t i = 0; i < descriptorWriteCount; ++i) {
+            mReconstruction.addHandleDependency(
+                (const uint64_t*)(&handle), 1,
+                (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDescriptorSet(
+                    pDescriptorWrites[i].dstSet));
+            for (uint32_t j = 0; j < pDescriptorWrites[i].descriptorCount; ++j) {
+                if ((pDescriptorWrites[i].pImageInfo)) {
+                    if (pDescriptorWrites[i].descriptorType ==
+                        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) {
+                        mReconstruction.addHandleDependency(
+                            (const uint64_t*)(&handle), 1,
+                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkSampler(
+                                pDescriptorWrites[i].pImageInfo[j].sampler));
+                        mReconstruction.addHandleDependency(
+                            (const uint64_t*)(&handle), 1,
+                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImageView(
+                                pDescriptorWrites[i].pImageInfo[j].imageView));
+                    }
+                    if (pDescriptorWrites[i].descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) {
+                        mReconstruction.addHandleDependency(
+                            (const uint64_t*)(&handle), 1,
+                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkSampler(
+                                pDescriptorWrites[i].pImageInfo[j].sampler));
+                    }
+                }
+                if (pDescriptorWrites[i].pBufferInfo) {
+                    if (pDescriptorWrites[i].descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) {
+                        mReconstruction.addHandleDependency(
+                            (const uint64_t*)(&handle), 1,
+                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkBuffer(
+                                pDescriptorWrites[i].pBufferInfo[j].buffer));
+                    }
+                }
+            }
+        }
+        mReconstruction.forEachHandleAddApi((const uint64_t*)(&handle), 1, apiHandle,
+                                            VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)(&handle), 1);
+    }
     void vkCreateFramebuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
                              const VkFramebufferCreateInfo* pCreateInfo,
@@ -935,7 +1009,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkBeginCommandBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -949,7 +1024,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkEndCommandBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -963,7 +1039,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkResetCommandBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleClearModifyApi((const uint64_t*)(&boxed), 1);
         }
     }
@@ -977,7 +1054,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindPipeline, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -992,7 +1070,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewport, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1006,7 +1085,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissor, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1020,7 +1100,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineWidth, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1035,7 +1116,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBias, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1049,7 +1131,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetBlendConstants, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1063,7 +1146,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBounds, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1077,7 +1161,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilCompareMask, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1091,7 +1176,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilWriteMask, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1105,7 +1191,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilReference, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1122,7 +1209,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindDescriptorSets, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1136,7 +1224,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindIndexBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1151,7 +1240,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1165,7 +1255,8 @@ class VkDecoderSnapshot::Impl {
         auto apiInfo = mReconstruction.getApiInfo(apiHandle);
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDraw, snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1180,7 +1271,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexed, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1195,7 +1287,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirect, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1210,7 +1303,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexedIndirect, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1224,7 +1318,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatch, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1238,7 +1333,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatchIndirect, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1253,7 +1349,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1269,7 +1366,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1285,7 +1383,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1300,7 +1399,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1315,7 +1415,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1330,7 +1431,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdUpdateBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1345,7 +1447,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdFillBuffer, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1361,7 +1464,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearColorImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1377,7 +1481,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearDepthStencilImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1392,7 +1497,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearAttachments, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1408,7 +1514,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1422,7 +1529,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1436,7 +1544,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1456,7 +1565,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1476,7 +1586,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1490,7 +1601,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginQuery, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1504,7 +1616,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndQuery, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1518,7 +1631,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetQueryPool, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1533,7 +1647,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1549,7 +1664,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyQueryPoolResults, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1564,7 +1680,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdPushConstants, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1579,7 +1696,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1593,7 +1711,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1606,7 +1725,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1620,7 +1740,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdExecuteCommands, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1674,7 +1795,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDeviceMask, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1689,7 +1811,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatchBase, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1843,7 +1966,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirectCount, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1859,7 +1983,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexedIndirectCount, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1892,7 +2017,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1907,7 +2033,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -1921,7 +2048,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2000,7 +2128,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2014,7 +2143,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2029,7 +2159,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2043,7 +2174,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2057,7 +2189,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2074,7 +2207,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2088,7 +2222,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2102,7 +2237,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2116,7 +2252,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2130,7 +2267,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2144,7 +2282,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2158,7 +2297,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRendering, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2171,7 +2311,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRendering, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2185,7 +2326,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetCullMode, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2199,7 +2341,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetFrontFace, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2213,7 +2356,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveTopology, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2227,7 +2371,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewportWithCount, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2241,7 +2386,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissorWithCount, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2257,7 +2403,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers2, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2271,7 +2418,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthTestEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2285,7 +2433,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthWriteEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2299,7 +2448,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthCompareOp, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2313,7 +2463,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBoundsTestEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2327,7 +2478,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilTestEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2342,7 +2494,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilOp, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2357,7 +2510,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRasterizerDiscardEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2371,7 +2525,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBiasEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2386,7 +2541,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveRestartEnable, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2473,7 +2629,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderingKHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2486,7 +2643,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderingKHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2619,7 +2777,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2634,7 +2793,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2648,7 +2808,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2796,7 +2957,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2810,7 +2972,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2825,7 +2988,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2839,7 +3003,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2854,7 +3019,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2872,7 +3038,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteBufferMarker2AMD, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2892,7 +3059,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2906,7 +3074,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2920,7 +3089,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2934,7 +3104,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2948,7 +3119,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2962,7 +3134,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -2996,7 +3169,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindIndexBuffer2KHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3016,6 +3190,23 @@ class VkDecoderSnapshot::Impl {
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout) {}
 #endif
+#ifdef VK_KHR_line_rasterization
+    void vkCmdSetLineStippleKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
+                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+                                uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
+        android::base::AutoLock lock(mLock);
+        // commandBuffer modify
+        auto apiHandle = mReconstruction.createApiInfo();
+        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
+        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineStippleKHR, snapshotTraceBegin,
+                                    snapshotTraceBytes);
+        for (uint32_t i = 0; i < 1; ++i) {
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+        }
+    }
+#endif
 #ifdef VK_ANDROID_native_buffer
     void vkGetSwapchainGrallocUsageANDROID(const uint8_t* snapshotTraceBegin,
                                            size_t snapshotTraceBytes, android::base::BumpPool* pool,
@@ -3082,7 +3273,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindTransformFeedbackBuffersEXT,
                                     snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3099,7 +3291,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginTransformFeedbackEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3115,7 +3308,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndTransformFeedbackEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3130,7 +3324,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginQueryIndexedEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3144,7 +3339,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndQueryIndexedEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3160,7 +3356,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirectByteCountEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3192,7 +3389,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginDebugUtilsLabelEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3205,7 +3403,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndDebugUtilsLabelEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3219,7 +3418,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdInsertDebugUtilsLabelEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3285,7 +3485,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineStippleEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3301,7 +3502,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetCullModeEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3315,7 +3517,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetFrontFaceEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3329,7 +3532,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveTopologyEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3343,7 +3547,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewportWithCountEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3357,7 +3562,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissorWithCountEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3373,7 +3579,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers2EXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3387,7 +3594,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthTestEnableEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3401,7 +3609,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthWriteEnableEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3415,7 +3624,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthCompareOpEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3430,7 +3640,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBoundsTestEnableEXT,
                                     snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3444,7 +3655,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilTestEnableEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3459,7 +3671,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilOpEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3523,7 +3736,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPatchControlPointsEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3539,7 +3753,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRasterizerDiscardEnableEXT,
                                     snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3553,7 +3768,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBiasEnableEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3567,7 +3783,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLogicOpEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3582,7 +3799,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveRestartEnableEXT,
                                     snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3598,7 +3816,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetColorWriteEnableEXT, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3789,7 +4008,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdTraceRaysKHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3820,7 +4040,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdTraceRaysIndirectKHR, snapshotTraceBegin,
                                     snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -3842,7 +4063,8 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRayTracingPipelineStackSizeKHR,
                                     snapshotTraceBegin, snapshotTraceBytes);
         for (uint32_t i = 0; i < 1; ++i) {
-            VkCommandBuffer boxed = unboxed_to_boxed_VkCommandBuffer((&commandBuffer)[i]);
+            // commandBuffer is already boxed, no need to box again
+            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
         }
     }
@@ -6595,6 +6817,14 @@ void VkDecoderSnapshot::vkGetImageSubresourceLayout2KHR(const uint8_t* snapshotT
                                            image, pSubresource, pLayout);
 }
 #endif
+#ifdef VK_KHR_line_rasterization
+void VkDecoderSnapshot::vkCmdSetLineStippleKHR(
+    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
+    mImpl->vkCmdSetLineStippleKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+                                  lineStippleFactor, lineStipplePattern);
+}
+#endif
 #ifdef VK_ANDROID_native_buffer
 void VkDecoderSnapshot::vkGetSwapchainGrallocUsageANDROID(
     const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
diff --git a/host/vulkan/VkDecoderSnapshot.h b/host/vulkan/VkDecoderSnapshot.h
index 8f6170d4a..2018b1093 100644
--- a/host/vulkan/VkDecoderSnapshot.h
+++ b/host/vulkan/VkDecoderSnapshot.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module VkDecoderSnapshot
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -1214,6 +1215,11 @@ class VkDecoderSnapshot {
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout);
 #endif
+#ifdef VK_KHR_line_rasterization
+    void vkCmdSetLineStippleKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
+                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+                                uint32_t lineStippleFactor, uint16_t lineStipplePattern);
+#endif
 #ifdef VK_ANDROID_native_buffer
     void vkGetSwapchainGrallocUsageANDROID(const uint8_t* snapshotTraceBegin,
                                            size_t snapshotTraceBytes, android::base::BumpPool* pool,
diff --git a/host/vulkan/VkReconstruction.cpp b/host/vulkan/VkReconstruction.cpp
index 88c2a04e9..b8bf3fb51 100644
--- a/host/vulkan/VkReconstruction.cpp
+++ b/host/vulkan/VkReconstruction.cpp
@@ -29,7 +29,7 @@ namespace vk {
 
 #if DEBUG_RECONSTRUCTION
 
-#define DEBUG_RECON(fmt, ...) fprintf(stderr, "%s:%d " fmt "\n", __func__, __LINE__, ##__VA_ARGS__);
+#define DEBUG_RECON(fmt, ...) INFO(fmt, ##__VA_ARGS__);
 
 #else
 
@@ -65,6 +65,8 @@ void VkReconstruction::save(android::base::Stream* stream) {
     dump();
 #endif
 
+    std::unordered_set<uint64_t> savedApis;
+
     std::unordered_map<HandleWithState, int, HandleWithStateHash> totalParents;
     std::vector<HandleWithState> next;
 
@@ -104,9 +106,12 @@ void VkReconstruction::save(android::base::Stream* stream) {
         for (const auto& handle : handles) {
             auto item = mHandleReconstructions.get(handle.first)->states[handle.second];
             for (uint64_t apiRef : item.apiRefs) {
-#if DEBUG_RECONSTRUCTION
                 auto apiItem = mApiTrace.get(apiRef);
-                DEBUG_RECON("adding handle 0x%lx API 0x%lx op code %d\n", handle.first, apiRef,
+                if (!apiItem) continue;
+                if (savedApis.find(apiRef) != savedApis.end()) continue;
+                savedApis.insert(apiRef);
+#if DEBUG_RECONSTRUCTION
+                DEBUG_RECON("adding handle 0x%lx API 0x%lx op code %d", handle.first, apiRef,
                             apiItem->opCode);
 #endif
                 nextApis.push_back(apiRef);
@@ -136,7 +141,7 @@ void VkReconstruction::save(android::base::Stream* stream) {
         for (auto apiHandle : uniqApiRefsByTopoOrder[i]) {
             auto item = mApiTrace.get(apiHandle);
             for (auto createdHandle : item->createdHandles) {
-                DEBUG_RECON("save handle: 0x%lx\n", createdHandle);
+                DEBUG_RECON("save handle: 0x%lx", createdHandle);
                 createdHandleBuffer.push_back(createdHandle);
             }
         }
@@ -151,7 +156,7 @@ void VkReconstruction::save(android::base::Stream* stream) {
         for (auto apiHandle : uniqApiRefsByTopoOrder[i]) {
             auto item = mApiTrace.get(apiHandle);
             // 4 bytes for opcode, and 4 bytes for saveBufferRaw's size field
-            DEBUG_RECON("saving api handle 0x%lx op code %d\n", apiHandle, item->opCode);
+            DEBUG_RECON("saving api handle 0x%lx op code %d", apiHandle, item->opCode);
             memcpy(apiTracePtr, &item->opCode, sizeof(uint32_t));
             apiTracePtr += 4;
             uint32_t traceBytesForSnapshot = item->traceBytes + 8;
@@ -187,7 +192,7 @@ class TrivialStream : public IOStream {
                 m_buf = p;
                 m_bufsize = allocSize;
             } else {
-                ERR("realloc (%zu) failed\n", allocSize);
+                ERR("realloc (%zu) failed", allocSize);
                 free(m_buf);
                 m_buf = NULL;
                 m_bufsize = 0;
@@ -267,11 +272,29 @@ VkReconstruction::ApiHandle VkReconstruction::createApiInfo() {
     return handle;
 }
 
+void VkReconstruction::removeHandleFromApiInfo(VkReconstruction::ApiHandle h, uint64_t toRemove) {
+    auto vk_item = mHandleReconstructions.get(toRemove);
+    if (!vk_item) return;
+    auto apiInfo = mApiTrace.get(h);
+    if (!apiInfo) return;
+
+    auto& handles = apiInfo->createdHandles;
+    auto it = std::find(handles.begin(), handles.end(), toRemove);
+
+    if (it != handles.end()) {
+        handles.erase(it);
+    }
+    DEBUG_RECON("removed 1 vk handle  0x%llx from apiInfo  0x%llx, now it has %d left",
+                (unsigned long long)toRemove, (unsigned long long)h, (int)handles.size());
+}
+
 void VkReconstruction::destroyApiInfo(VkReconstruction::ApiHandle h) {
     auto item = mApiTrace.get(h);
 
     if (!item) return;
 
+    if (!item->createdHandles.empty()) return;
+
     item->traceBytes = 0;
     item->createdHandles.clear();
 
@@ -291,13 +314,13 @@ void VkReconstruction::setApiTrace(VkReconstruction::ApiInfo* apiInfo, uint32_t
 }
 
 void VkReconstruction::dump() {
-    fprintf(stderr, "%s: api trace dump\n", __func__);
+    INFO("%s: api trace dump", __func__);
 
     size_t traceBytesTotal = 0;
 
     mApiTrace.forEachLiveEntry_const(
         [&traceBytesTotal](bool live, uint64_t handle, const ApiInfo& info) {
-            fprintf(stderr, "VkReconstruction::%s: api handle 0x%llx: %s\n", __func__,
+            INFO("VkReconstruction::%s: api handle 0x%llx: %s", __func__,
                     (unsigned long long)handle, api_opcode_to_string(info.opCode));
             traceBytesTotal += info.traceBytes;
         });
@@ -305,17 +328,17 @@ void VkReconstruction::dump() {
     mHandleReconstructions.forEachLiveComponent_const(
         [this](bool live, uint64_t componentHandle, uint64_t entityHandle,
                const HandleWithStateReconstruction& reconstruction) {
-            fprintf(stderr, "VkReconstruction::%s: %p handle 0x%llx api refs:\n", __func__, this,
+            INFO("VkReconstruction::%s: %p handle 0x%llx api refs:", __func__, this,
                     (unsigned long long)entityHandle);
             for (const auto& state : reconstruction.states) {
                 for (auto apiHandle : state.apiRefs) {
                     auto apiInfo = mApiTrace.get(apiHandle);
                     const char* apiName =
                         apiInfo ? api_opcode_to_string(apiInfo->opCode) : "unalloced";
-                    fprintf(stderr, "VkReconstruction::%s:     0x%llx: %s\n", __func__,
+                    INFO("VkReconstruction::%s:     0x%llx: %s", __func__,
                             (unsigned long long)apiHandle, apiName);
                     for (auto createdHandle : apiInfo->createdHandles) {
-                        fprintf(stderr, "VkReconstruction::%s:         created 0x%llx\n", __func__,
+                        INFO("VkReconstruction::%s:         created 0x%llx", __func__,
                                 (unsigned long long)createdHandle);
                     }
                 }
@@ -325,17 +348,17 @@ void VkReconstruction::dump() {
     mHandleModifications.forEachLiveComponent_const([this](bool live, uint64_t componentHandle,
                                                            uint64_t entityHandle,
                                                            const HandleModification& modification) {
-        fprintf(stderr, "VkReconstruction::%s: mod: %p handle 0x%llx api refs:\n", __func__, this,
+        INFO("VkReconstruction::%s: mod: %p handle 0x%llx api refs:", __func__, this,
                 (unsigned long long)entityHandle);
         for (auto apiHandle : modification.apiRefs) {
             auto apiInfo = mApiTrace.get(apiHandle);
             const char* apiName = apiInfo ? api_opcode_to_string(apiInfo->opCode) : "unalloced";
-            fprintf(stderr, "VkReconstruction::%s: mod:     0x%llx: %s\n", __func__,
+            INFO("VkReconstruction::%s: mod:     0x%llx: %s", __func__,
                     (unsigned long long)apiHandle, apiName);
         }
     });
 
-    fprintf(stderr, "%s: total trace bytes: %zu\n", __func__, traceBytesTotal);
+    INFO("%s: total trace bytes: %zu", __func__, traceBytesTotal);
 }
 
 void VkReconstruction::addHandles(const uint64_t* toAdd, uint32_t count) {
@@ -421,13 +444,14 @@ void VkReconstruction::forEachHandleDeleteApi(const uint64_t* toProcess, uint32_
     if (!toProcess) return;
 
     for (uint32_t i = 0; i < count; ++i) {
-        DEBUG_RECON("deleting api for 0x%lx\n", toProcess[i]);
+        DEBUG_RECON("deleting api for 0x%lx", toProcess[i]);
         auto item = mHandleReconstructions.get(toProcess[i]);
 
         if (!item) continue;
 
         for (auto& state : item->states) {
             for (auto handle : state.apiRefs) {
+                removeHandleFromApiInfo(handle, toProcess[i]);
                 destroyApiInfo(handle);
             }
             state.apiRefs.clear();
@@ -451,7 +475,7 @@ void VkReconstruction::addHandleDependency(const uint64_t* handles, uint32_t cou
     auto parentItem = mHandleReconstructions.get(parentHandle);
 
     if (!parentItem) {
-        DEBUG_RECON("WARN: adding null parent item: 0x%lx\n", parentHandle);
+        DEBUG_RECON("WARN: adding null parent item: 0x%lx", parentHandle);
         return;
     }
     auto& parentItemState = parentItem->states[parentState];
@@ -492,9 +516,11 @@ void VkReconstruction::forEachHandleAddModifyApi(const uint64_t* toProcess, uint
     if (!toProcess) return;
 
     for (uint32_t i = 0; i < count; ++i) {
-        mHandleModifications.add(toProcess[i], HandleModification());
-
         auto item = mHandleModifications.get(toProcess[i]);
+        if (!item) {
+            mHandleModifications.add(toProcess[i], HandleModification());
+            item = mHandleModifications.get(toProcess[i]);
+        }
 
         if (!item) continue;
 
@@ -506,8 +532,6 @@ void VkReconstruction::forEachHandleClearModifyApi(const uint64_t* toProcess, ui
     if (!toProcess) return;
 
     for (uint32_t i = 0; i < count; ++i) {
-        mHandleModifications.add(toProcess[i], HandleModification());
-
         auto item = mHandleModifications.get(toProcess[i]);
 
         if (!item) continue;
diff --git a/host/vulkan/VkReconstruction.h b/host/vulkan/VkReconstruction.h
index a30d4bc97..28f7cad11 100644
--- a/host/vulkan/VkReconstruction.h
+++ b/host/vulkan/VkReconstruction.h
@@ -83,6 +83,8 @@ class VkReconstruction {
     ApiHandle createApiInfo();
     void destroyApiInfo(ApiHandle h);
 
+    void removeHandleFromApiInfo(ApiHandle h, uint64_t toRemove);
+
     ApiInfo* getApiInfo(ApiHandle h);
 
     void setApiTrace(ApiInfo* apiInfo, uint32_t opcode, const uint8_t* traceBegin,
diff --git a/host/vulkan/VkSubDecoder.cpp b/host/vulkan/VkSubDecoder.cpp
index e137a4677..d06dfb36c 100644
--- a/host/vulkan/VkSubDecoder.cpp
+++ b/host/vulkan/VkSubDecoder.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module VkSubDecoder
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -2404,6 +2405,21 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 break;
             }
 #endif
+#ifdef VK_KHR_line_rasterization
+            case OP_vkCmdSetLineStippleKHR: {
+                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
+                                      "VkSubDecoder vkCmdSetLineStippleKHR");
+                uint32_t lineStippleFactor;
+                uint16_t lineStipplePattern;
+                memcpy((uint32_t*)&lineStippleFactor, *readStreamPtrPtr, sizeof(uint32_t));
+                *readStreamPtrPtr += sizeof(uint32_t);
+                memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
+                *readStreamPtrPtr += sizeof(uint16_t);
+                vk->vkCmdSetLineStippleKHR((VkCommandBuffer)dispatchHandle, lineStippleFactor,
+                                           lineStipplePattern);
+                break;
+            }
+#endif
 #ifdef VK_EXT_transform_feedback
             case OP_vkCmdBindTransformFeedbackBuffersEXT: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
diff --git a/host/vulkan/VulkanDispatch.cpp b/host/vulkan/VulkanDispatch.cpp
index 0d379bb97..fd3048888 100644
--- a/host/vulkan/VulkanDispatch.cpp
+++ b/host/vulkan/VulkanDispatch.cpp
@@ -109,6 +109,9 @@ static void initIcdPaths(bool forTesting) {
         // MVK_CONFIG_USE_METAL_ARGUMENT_BUFFERS is not working correctly
         android::base::setEnvironmentVariable("MVK_CONFIG_USE_METAL_ARGUMENT_BUFFERS", "0");
 
+        // MVK_CONFIG_USE_MTLHEAP is required for VK_EXT_external_memory_metal
+        android::base::setEnvironmentVariable("MVK_CONFIG_USE_MTLHEAP", "1");
+
         // TODO(b/351765838): VVL won't work with MoltenVK due to the current
         //  way of external memory handling, add it into disable list to
         //  avoid users enabling it implicitly (i.e. via vkconfig).
@@ -187,48 +190,10 @@ class VulkanDispatchImpl {
 #if defined(__APPLE__)
         return std::vector<std::string>{"libvulkan.dylib"};
 #elif defined(__linux__)
-        // When running applications with Gfxstream as the Vulkan ICD, i.e. with
-        //
-        //   App -> Vulkan Loader -> Gfxstream ICD -> Vulkan Loader -> Driver ICD
-        //
-        // Gfxstream needs to use a different nested loader library to avoid issues with
-        // conflating/deadlock with the first level loader. Detect that here and look for
-        // a "libvulkan_gfxstream" which can be generated with the provided
-        // scripts/build-nested-vulkan-loader.sh script.
-        const std::vector<std::string> nestedVulkanLoaderVars = {
-            "GFXSTREAM_VK_ADD_DRIVER_FILES",
-            "GFXSTREAM_VK_ADD_LAYER_PATH",
-            "GFXSTREAM_VK_DRIVER_FILES",
-            "GFXSTREAM_VK_ICD_FILENAMES",
-            "GFXSTREAM_VK_INSTANCE_LAYERS",
-            "GFXSTREAM_VK_LAYER_PATH",
-            "GFXSTREAM_VK_LAYER_PATH",
-            "GFXSTREAM_VK_LOADER_DEBUG",
-            "GFXSTREAM_VK_LOADER_DRIVERS_DISABLE",
-            "GFXSTREAM_VK_LOADER_DRIVERS_SELECT",
-            "GFXSTREAM_VK_LOADER_LAYERS_ALLOW",
-            "GFXSTREAM_VK_LOADER_LAYERS_DISABLE",
-            "GFXSTREAM_VK_LOADER_LAYERS_ENABLE",
+        return std::vector<std::string>{
+            "libvulkan.so",
+            "libvulkan.so.1",
         };
-        bool usesNestedVulkanLoader = false;
-        for (const std::string& var : nestedVulkanLoaderVars) {
-            if (android::base::getEnvironmentVariable(var) != "") {
-                usesNestedVulkanLoader = true;
-                break;
-            }
-        }
-        if (usesNestedVulkanLoader) {
-            return std::vector<std::string>{
-                "libvulkan_gfxstream.so",
-                "libvulkan_gfxstream.so.1",
-            };
-        } else {
-            return std::vector<std::string>{
-                "libvulkan.so",
-                "libvulkan.so.1",
-            };
-        }
-
 #elif defined(_WIN32)
         return std::vector<std::string>{"vulkan-1.dll"};
 #elif defined(__QNX__)
diff --git a/host/vulkan/VulkanHandleMapping.h b/host/vulkan/VulkanHandleMapping.h
index 2ea379f8b..aa6baf7dd 100644
--- a/host/vulkan/VulkanHandleMapping.h
+++ b/host/vulkan/VulkanHandleMapping.h
@@ -59,6 +59,7 @@ class DefaultHandleMapping : public VulkanHandleMapping {
 
 #define DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DECL(type) \
     type unbox_##type(type boxed);                             \
+    type try_unbox_##type(type boxed);                         \
     type unboxed_to_boxed_##type(type boxed);                  \
     void delete_##type(type boxed);                            \
     VulkanDispatch* dispatch_##type(type boxed);
@@ -71,6 +72,7 @@ GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOB
     void delayed_delete_##type(type boxed, VkDevice device, std::function<void()> callback); \
     void set_boxed_non_dispatchable_##type(type boxed, type underlying);                     \
     type unbox_##type(type boxed);                                                           \
+    type try_unbox_##type(type boxed);                                                       \
     type unboxed_to_boxed_non_dispatchable_##type(type boxed);
 
 GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_GLOBAL_API_DECL)
diff --git a/host/vulkan/VulkanHandles.h b/host/vulkan/VulkanHandles.h
index a6d096361..902146b48 100644
--- a/host/vulkan/VulkanHandles.h
+++ b/host/vulkan/VulkanHandles.h
@@ -23,6 +23,22 @@
     f(VkQueue)                                        \
     f(VkCommandBuffer)
 
+// Unboxing can be overridden for some handles, this would mean the actual
+// unboxed handle to be used for the GPU can be different than the 'unboxed'
+// handle used for tracking its properties (e.g. via mQueueInfo).
+// Queues can be virtualized by using made up 'unboxed' handles for tracking,
+// whichwill then needs translation when used for the driver operations.
+#define GOLDFISH_VK_LIST_DISPATCHABLE_REGULAR_UNBOX_HANDLE_TYPES(f) \
+    f(VkInstance)                                                   \
+    f(VkPhysicalDevice)                                             \
+    f(VkDevice)                                                     \
+    f(VkCommandBuffer)
+
+// VkQueues can be virtualized to provide multiple queues when only a single
+// queue is supported. Custom unbox will ensure that the unboxed handle can
+// be used by the GPU correctly.
+#define GOLDFISH_VK_LIST_DISPATCHABLE_CUSTOM_UNBOX_HANDLE_TYPES(f) f(VkQueue)
+
 #define GOLDFISH_VK_LIST_TRIVIAL_NON_DISPATCHABLE_HANDLE_TYPES(f) \
     f(VkBuffer)                                                   \
     f(VkBufferView)                                               \
diff --git a/host/vulkan/VulkanStream.cpp b/host/vulkan/VulkanStream.cpp
index 39d8af40e..36fb8ae68 100644
--- a/host/vulkan/VulkanStream.cpp
+++ b/host/vulkan/VulkanStream.cpp
@@ -25,8 +25,6 @@
 namespace gfxstream {
 namespace vk {
 
-#define E(fmt, ...) fprintf(stderr, fmt "\n", ##__VA_ARGS__)
-
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
diff --git a/host/vulkan/VulkanStream.h b/host/vulkan/VulkanStream.h
index 076af479a..13892ee6e 100644
--- a/host/vulkan/VulkanStream.h
+++ b/host/vulkan/VulkanStream.h
@@ -25,8 +25,6 @@
 #include "gfxstream/host/Features.h"
 #include "goldfish_vk_private_defs.h"
 
-#define E(fmt, ...) fprintf(stderr, fmt "\n", ##__VA_ARGS__)
-
 namespace android {
 namespace base {
 class BumpPool;
diff --git a/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp b/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
index 988913c5e..bb0c4a063 100644
--- a/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_deepcopy
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -7399,6 +7400,77 @@ void deepcopy_VkBufferUsageFlags2CreateInfoKHR(Allocator* alloc, VkStructureType
     }
 }
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void deepcopy_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationFeaturesKHR* from,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+}
+
+void deepcopy_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationPropertiesKHR* from,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+}
+
+void deepcopy_VkPipelineRasterizationLineStateCreateInfoKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPipelineRasterizationLineStateCreateInfoKHR* from,
+    VkPipelineRasterizationLineStateCreateInfoKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+}
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void deepcopy_VkNativeBufferUsage2ANDROID(Allocator* alloc, VkStructureType rootType,
@@ -8353,77 +8425,6 @@ void deepcopy_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
     }
 }
 
-#endif
-#ifdef VK_EXT_line_rasterization
-void deepcopy_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationFeaturesEXT* from,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* to) {
-    (void)alloc;
-    (void)rootType;
-    *to = *from;
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = from->sType;
-    }
-    const void* from_pNext = from;
-    size_t pNext_size = 0u;
-    while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
-        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
-    }
-    to->pNext = nullptr;
-    if (pNext_size) {
-        to->pNext = (void*)alloc->alloc(pNext_size);
-        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
-    }
-}
-
-void deepcopy_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationPropertiesEXT* from,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* to) {
-    (void)alloc;
-    (void)rootType;
-    *to = *from;
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = from->sType;
-    }
-    const void* from_pNext = from;
-    size_t pNext_size = 0u;
-    while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
-        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
-    }
-    to->pNext = nullptr;
-    if (pNext_size) {
-        to->pNext = (void*)alloc->alloc(pNext_size);
-        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
-    }
-}
-
-void deepcopy_VkPipelineRasterizationLineStateCreateInfoEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPipelineRasterizationLineStateCreateInfoEXT* from,
-    VkPipelineRasterizationLineStateCreateInfoEXT* to) {
-    (void)alloc;
-    (void)rootType;
-    *to = *from;
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = from->sType;
-    }
-    const void* from_pNext = from;
-    size_t pNext_size = 0u;
-    while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
-        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
-    }
-    to->pNext = nullptr;
-    if (pNext_size) {
-        to->pNext = (void*)alloc->alloc(pNext_size);
-        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
-    }
-}
-
 #endif
 #ifdef VK_EXT_index_type_uint8
 void deepcopy_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -10662,6 +10663,35 @@ void deepcopy_extension_struct(Allocator* alloc, VkStructureType rootType,
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            deepcopy_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                    structExtension),
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            deepcopy_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                    structExtension),
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            deepcopy_VkPipelineRasterizationLineStateCreateInfoKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                    structExtension),
+                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                    structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             deepcopy_VkNativeBufferANDROID(
@@ -10977,35 +11007,6 @@ void deepcopy_extension_struct(Allocator* alloc, VkStructureType rootType,
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            deepcopy_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                alloc, rootType,
-                reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                    structExtension),
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                    structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            deepcopy_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                alloc, rootType,
-                reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                    structExtension),
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                    structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            deepcopy_VkPipelineRasterizationLineStateCreateInfoEXT(
-                alloc, rootType,
-                reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                    structExtension),
-                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                    structExtension_out));
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             deepcopy_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
diff --git a/host/vulkan/cereal/common/goldfish_vk_deepcopy.h b/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
index 5b0ca7008..26f32e0a2 100644
--- a/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
+++ b/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_deepcopy
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -1620,6 +1621,23 @@ void deepcopy_VkBufferUsageFlags2CreateInfoKHR(Allocator* alloc, VkStructureType
                                                const VkBufferUsageFlags2CreateInfoKHR* from,
                                                VkBufferUsageFlags2CreateInfoKHR* to);
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void deepcopy_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationFeaturesKHR* from,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* to);
+
+void deepcopy_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationPropertiesKHR* from,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* to);
+
+void deepcopy_VkPipelineRasterizationLineStateCreateInfoKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPipelineRasterizationLineStateCreateInfoKHR* from,
+    VkPipelineRasterizationLineStateCreateInfoKHR* to);
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void deepcopy_VkNativeBufferUsage2ANDROID(Allocator* alloc, VkStructureType rootType,
@@ -1857,20 +1875,14 @@ void deepcopy_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
 
 #endif
 #ifdef VK_EXT_line_rasterization
-void deepcopy_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationFeaturesEXT* from,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* to);
+DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      deepcopy_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void deepcopy_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationPropertiesEXT* from,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* to);
+DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      deepcopy_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void deepcopy_VkPipelineRasterizationLineStateCreateInfoEXT(
-    Allocator* alloc, VkStructureType rootType,
-    const VkPipelineRasterizationLineStateCreateInfoEXT* from,
-    VkPipelineRasterizationLineStateCreateInfoEXT* to);
+DEFINE_ALIAS_FUNCTION(deepcopy_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      deepcopy_VkPipelineRasterizationLineStateCreateInfoEXT)
 
 #endif
 #ifdef VK_EXT_index_type_uint8
diff --git a/host/vulkan/cereal/common/goldfish_vk_dispatch.cpp b/host/vulkan/cereal/common/goldfish_vk_dispatch.cpp
index 352a9fc58..0e4b69056 100644
--- a/host/vulkan/cereal/common/goldfish_vk_dispatch.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_dispatch.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_dispatch
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -618,6 +619,10 @@ void init_vulkan_dispatch_from_system_loader(DlOpenFunc dlOpenFunc, DlSymFunc dl
     out->vkGetImageSubresourceLayout2KHR =
         (PFN_vkGetImageSubresourceLayout2KHR)dlSymFunc(lib, "vkGetImageSubresourceLayout2KHR");
 #endif
+#ifdef VK_KHR_line_rasterization
+    out->vkCmdSetLineStippleKHR =
+        (PFN_vkCmdSetLineStippleKHR)dlSymFunc(lib, "vkCmdSetLineStippleKHR");
+#endif
 #ifdef VK_ANDROID_native_buffer
     out->vkGetSwapchainGrallocUsageANDROID =
         (PFN_vkGetSwapchainGrallocUsageANDROID)dlSymFunc(lib, "vkGetSwapchainGrallocUsageANDROID");
@@ -1582,6 +1587,10 @@ void init_vulkan_dispatch_from_instance(VulkanDispatch* vk, VkInstance instance,
         (PFN_vkGetImageSubresourceLayout2KHR)vk->vkGetInstanceProcAddr(
             instance, "vkGetImageSubresourceLayout2KHR");
 #endif
+#ifdef VK_KHR_line_rasterization
+    out->vkCmdSetLineStippleKHR =
+        (PFN_vkCmdSetLineStippleKHR)vk->vkGetInstanceProcAddr(instance, "vkCmdSetLineStippleKHR");
+#endif
 #ifdef VK_ANDROID_native_buffer
     out->vkGetSwapchainGrallocUsageANDROID =
         (PFN_vkGetSwapchainGrallocUsageANDROID)vk->vkGetInstanceProcAddr(
@@ -2568,6 +2577,10 @@ void init_vulkan_dispatch_from_device(VulkanDispatch* vk, VkDevice device, Vulka
         (PFN_vkGetImageSubresourceLayout2KHR)vk->vkGetDeviceProcAddr(
             device, "vkGetImageSubresourceLayout2KHR");
 #endif
+#ifdef VK_KHR_line_rasterization
+    out->vkCmdSetLineStippleKHR =
+        (PFN_vkCmdSetLineStippleKHR)vk->vkGetDeviceProcAddr(device, "vkCmdSetLineStippleKHR");
+#endif
 #ifdef VK_ANDROID_native_buffer
     out->vkGetSwapchainGrallocUsageANDROID =
         (PFN_vkGetSwapchainGrallocUsageANDROID)vk->vkGetDeviceProcAddr(
diff --git a/host/vulkan/cereal/common/goldfish_vk_dispatch.h b/host/vulkan/cereal/common/goldfish_vk_dispatch.h
index 7b9f85b35..5aec47f4d 100644
--- a/host/vulkan/cereal/common/goldfish_vk_dispatch.h
+++ b/host/vulkan/cereal/common/goldfish_vk_dispatch.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_dispatch
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -434,6 +435,9 @@ struct VulkanDispatch {
     PFN_vkGetDeviceImageSubresourceLayoutKHR vkGetDeviceImageSubresourceLayoutKHR;
     PFN_vkGetImageSubresourceLayout2KHR vkGetImageSubresourceLayout2KHR;
 #endif
+#ifdef VK_KHR_line_rasterization
+    PFN_vkCmdSetLineStippleKHR vkCmdSetLineStippleKHR;
+#endif
 #ifdef VK_ANDROID_native_buffer
     PFN_vkGetSwapchainGrallocUsageANDROID vkGetSwapchainGrallocUsageANDROID;
     PFN_vkAcquireImageANDROID vkAcquireImageANDROID;
diff --git a/host/vulkan/cereal/common/goldfish_vk_extension_structs.cpp b/host/vulkan/cereal/common/goldfish_vk_extension_structs.cpp
index 61c2754f5..ffbf6bd7d 100644
--- a/host/vulkan/cereal/common/goldfish_vk_extension_structs.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_extension_structs.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_extension_structs
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -660,6 +661,17 @@ size_t goldfish_vk_extension_struct_size(VkStructureType rootType, const void* s
             return sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR);
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            return sizeof(VkPhysicalDeviceLineRasterizationFeaturesKHR);
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            return sizeof(VkPhysicalDeviceLineRasterizationPropertiesKHR);
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            return sizeof(VkPipelineRasterizationLineStateCreateInfoKHR);
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             return sizeof(VkNativeBufferANDROID);
@@ -1311,17 +1323,6 @@ size_t goldfish_vk_extension_struct_size(VkStructureType rootType, const void* s
             return sizeof(VkSurfaceFullScreenExclusiveWin32InfoEXT);
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            return sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT);
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            return sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT);
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            return sizeof(VkPipelineRasterizationLineStateCreateInfoEXT);
-        }
-#endif
 #ifdef VK_EXT_shader_atomic_float
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
             return sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
@@ -2142,7 +2143,7 @@ size_t goldfish_vk_extension_struct_size(VkStructureType rootType, const void* s
             fprintf(stderr, "Unhandled Vulkan structure type %s [%d], aborting.\n",
                     string_VkStructureType(VkStructureType(structType)), structType);
             GFXSTREAM_ABORT(::emugl::FatalError(::emugl::ABORT_REASON_OTHER));
-            return (size_t)0;
+            return static_cast<size_t>(0);
         }
     }
 }
@@ -2774,6 +2775,17 @@ size_t goldfish_vk_extension_struct_size_with_stream_features(uint32_t streamFea
             return sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR);
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            return sizeof(VkPhysicalDeviceLineRasterizationFeaturesKHR);
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            return sizeof(VkPhysicalDeviceLineRasterizationPropertiesKHR);
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            return sizeof(VkPipelineRasterizationLineStateCreateInfoKHR);
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             return sizeof(VkNativeBufferANDROID);
@@ -3425,17 +3437,6 @@ size_t goldfish_vk_extension_struct_size_with_stream_features(uint32_t streamFea
             return sizeof(VkSurfaceFullScreenExclusiveWin32InfoEXT);
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            return sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT);
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            return sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT);
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            return sizeof(VkPipelineRasterizationLineStateCreateInfoEXT);
-        }
-#endif
 #ifdef VK_EXT_shader_atomic_float
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
             return sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
@@ -4256,7 +4257,7 @@ size_t goldfish_vk_extension_struct_size_with_stream_features(uint32_t streamFea
             fprintf(stderr, "Unhandled Vulkan structure type %s [%d], aborting.\n",
                     string_VkStructureType(VkStructureType(structType)), structType);
             GFXSTREAM_ABORT(::emugl::FatalError(::emugl::ABORT_REASON_OTHER));
-            return (size_t)0;
+            return static_cast<size_t>(0);
         }
     }
 }
diff --git a/host/vulkan/cereal/common/goldfish_vk_extension_structs.h b/host/vulkan/cereal/common/goldfish_vk_extension_structs.h
index ff3121bb8..2caf495d3 100644
--- a/host/vulkan/cereal/common/goldfish_vk_extension_structs.h
+++ b/host/vulkan/cereal/common/goldfish_vk_extension_structs.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_extension_structs
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
diff --git a/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp b/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
index 11af64502..7e8873b17 100644
--- a/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_marshaling
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -15115,6 +15116,134 @@ void unmarshal_VkBufferUsageFlags2CreateInfoKHR(VulkanStream* vkStream, VkStruct
                    sizeof(VkBufferUsageFlags2KHR));
 }
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void marshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationFeaturesKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((VkBool32*)&forMarshaling->rectangularLines, sizeof(VkBool32));
+    vkStream->write((VkBool32*)&forMarshaling->bresenhamLines, sizeof(VkBool32));
+    vkStream->write((VkBool32*)&forMarshaling->smoothLines, sizeof(VkBool32));
+    vkStream->write((VkBool32*)&forMarshaling->stippledRectangularLines, sizeof(VkBool32));
+    vkStream->write((VkBool32*)&forMarshaling->stippledBresenhamLines, sizeof(VkBool32));
+    vkStream->write((VkBool32*)&forMarshaling->stippledSmoothLines, sizeof(VkBool32));
+}
+
+void unmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((VkBool32*)&forUnmarshaling->rectangularLines, sizeof(VkBool32));
+    vkStream->read((VkBool32*)&forUnmarshaling->bresenhamLines, sizeof(VkBool32));
+    vkStream->read((VkBool32*)&forUnmarshaling->smoothLines, sizeof(VkBool32));
+    vkStream->read((VkBool32*)&forUnmarshaling->stippledRectangularLines, sizeof(VkBool32));
+    vkStream->read((VkBool32*)&forUnmarshaling->stippledBresenhamLines, sizeof(VkBool32));
+    vkStream->read((VkBool32*)&forUnmarshaling->stippledSmoothLines, sizeof(VkBool32));
+}
+
+void marshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationPropertiesKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((uint32_t*)&forMarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
+}
+
+void unmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
+}
+
+void marshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPipelineRasterizationLineStateCreateInfoKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((VkLineRasterizationModeKHR*)&forMarshaling->lineRasterizationMode,
+                    sizeof(VkLineRasterizationModeKHR));
+    vkStream->write((VkBool32*)&forMarshaling->stippledLineEnable, sizeof(VkBool32));
+    vkStream->write((uint32_t*)&forMarshaling->lineStippleFactor, sizeof(uint32_t));
+    vkStream->write((uint16_t*)&forMarshaling->lineStipplePattern, sizeof(uint16_t));
+}
+
+void unmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPipelineRasterizationLineStateCreateInfoKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((VkLineRasterizationModeKHR*)&forUnmarshaling->lineRasterizationMode,
+                   sizeof(VkLineRasterizationModeKHR));
+    vkStream->read((VkBool32*)&forUnmarshaling->stippledLineEnable, sizeof(VkBool32));
+    vkStream->read((uint32_t*)&forUnmarshaling->lineStippleFactor, sizeof(uint32_t));
+    vkStream->read((uint16_t*)&forUnmarshaling->lineStipplePattern, sizeof(uint16_t));
+}
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void marshal_VkNativeBufferUsage2ANDROID(VulkanStream* vkStream, VkStructureType rootType,
@@ -16785,134 +16914,6 @@ void unmarshal_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
                    sizeof(VkProvokingVertexModeEXT));
 }
 
-#endif
-#ifdef VK_EXT_line_rasterization
-void marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationFeaturesEXT* forMarshaling) {
-    (void)rootType;
-    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forMarshaling->sType;
-    }
-    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
-    vkStream->write((VkBool32*)&forMarshaling->rectangularLines, sizeof(VkBool32));
-    vkStream->write((VkBool32*)&forMarshaling->bresenhamLines, sizeof(VkBool32));
-    vkStream->write((VkBool32*)&forMarshaling->smoothLines, sizeof(VkBool32));
-    vkStream->write((VkBool32*)&forMarshaling->stippledRectangularLines, sizeof(VkBool32));
-    vkStream->write((VkBool32*)&forMarshaling->stippledBresenhamLines, sizeof(VkBool32));
-    vkStream->write((VkBool32*)&forMarshaling->stippledSmoothLines, sizeof(VkBool32));
-}
-
-void unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling) {
-    (void)rootType;
-    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    size_t pNext_size;
-    pNext_size = vkStream->getBe32();
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
-    }
-    vkStream->read((VkBool32*)&forUnmarshaling->rectangularLines, sizeof(VkBool32));
-    vkStream->read((VkBool32*)&forUnmarshaling->bresenhamLines, sizeof(VkBool32));
-    vkStream->read((VkBool32*)&forUnmarshaling->smoothLines, sizeof(VkBool32));
-    vkStream->read((VkBool32*)&forUnmarshaling->stippledRectangularLines, sizeof(VkBool32));
-    vkStream->read((VkBool32*)&forUnmarshaling->stippledBresenhamLines, sizeof(VkBool32));
-    vkStream->read((VkBool32*)&forUnmarshaling->stippledSmoothLines, sizeof(VkBool32));
-}
-
-void marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationPropertiesEXT* forMarshaling) {
-    (void)rootType;
-    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forMarshaling->sType;
-    }
-    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
-    vkStream->write((uint32_t*)&forMarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
-}
-
-void unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling) {
-    (void)rootType;
-    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    size_t pNext_size;
-    pNext_size = vkStream->getBe32();
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
-    }
-    vkStream->read((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
-}
-
-void marshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPipelineRasterizationLineStateCreateInfoEXT* forMarshaling) {
-    (void)rootType;
-    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forMarshaling->sType;
-    }
-    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
-    vkStream->write((VkLineRasterizationModeEXT*)&forMarshaling->lineRasterizationMode,
-                    sizeof(VkLineRasterizationModeEXT));
-    vkStream->write((VkBool32*)&forMarshaling->stippledLineEnable, sizeof(VkBool32));
-    vkStream->write((uint32_t*)&forMarshaling->lineStippleFactor, sizeof(uint32_t));
-    vkStream->write((uint16_t*)&forMarshaling->lineStipplePattern, sizeof(uint16_t));
-}
-
-void unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling) {
-    (void)rootType;
-    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    size_t pNext_size;
-    pNext_size = vkStream->getBe32();
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
-    }
-    vkStream->read((VkLineRasterizationModeEXT*)&forUnmarshaling->lineRasterizationMode,
-                   sizeof(VkLineRasterizationModeEXT));
-    vkStream->read((VkBool32*)&forUnmarshaling->stippledLineEnable, sizeof(VkBool32));
-    vkStream->read((uint32_t*)&forUnmarshaling->lineStippleFactor, sizeof(uint32_t));
-    vkStream->read((uint16_t*)&forUnmarshaling->lineStipplePattern, sizeof(uint16_t));
-}
-
 #endif
 #ifdef VK_EXT_index_type_uint8
 void marshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -19999,6 +20000,29 @@ void marshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType,
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            marshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                    structExtension));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            marshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                    structExtension));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            marshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                    structExtension));
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             marshal_VkNativeBufferANDROID(
@@ -20263,29 +20287,6 @@ void marshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType,
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                vkStream, rootType,
-                reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                    structExtension));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                vkStream, rootType,
-                reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                    structExtension));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            marshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-                vkStream, rootType,
-                reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                    structExtension));
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             marshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -21380,6 +21381,29 @@ void unmarshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            unmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            unmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            unmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                    structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             unmarshal_VkNativeBufferANDROID(
@@ -21640,29 +21664,6 @@ void unmarshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                    structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                    structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                    structExtension_out));
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             unmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -22807,6 +22808,13 @@ const char* api_opcode_to_string(const uint32_t opcode) {
         case OP_vkCmdSetDepthBoundsTestEnable: {
             return "OP_vkCmdSetDepthBoundsTestEnable";
         }
+#endif
+#ifdef VK_KHR_line_rasterization
+        case OP_vkCmdSetLineStippleKHR: {
+            return "OP_vkCmdSetLineStippleKHR";
+        }
+#endif
+#ifdef VK_VERSION_1_3
         case OP_vkCmdSetScissorWithCount: {
             return "OP_vkCmdSetScissorWithCount";
         }
diff --git a/host/vulkan/cereal/common/goldfish_vk_marshaling.h b/host/vulkan/cereal/common/goldfish_vk_marshaling.h
index 43e016b7f..2b2453f3a 100644
--- a/host/vulkan/cereal/common/goldfish_vk_marshaling.h
+++ b/host/vulkan/cereal/common/goldfish_vk_marshaling.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_marshaling
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -3084,6 +3085,33 @@ void marshal_VkBufferUsageFlags2CreateInfoKHR(
 void unmarshal_VkBufferUsageFlags2CreateInfoKHR(VulkanStream* vkStream, VkStructureType rootType,
                                                 VkBufferUsageFlags2CreateInfoKHR* forUnmarshaling);
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void marshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationFeaturesKHR* forMarshaling);
+
+void unmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* forUnmarshaling);
+
+void marshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceLineRasterizationPropertiesKHR* forMarshaling);
+
+void unmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* forUnmarshaling);
+
+void marshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPipelineRasterizationLineStateCreateInfoKHR* forMarshaling);
+
+void unmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPipelineRasterizationLineStateCreateInfoKHR* forUnmarshaling);
+
+#define OP_vkCmdSetLineStippleKHR 219923286
 #endif
 #ifdef VK_ANDROID_native_buffer
 void marshal_VkNativeBufferUsage2ANDROID(VulkanStream* vkStream, VkStructureType rootType,
@@ -3498,29 +3526,23 @@ void unmarshal_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
 
 #endif
 #ifdef VK_EXT_line_rasterization
-void marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationFeaturesEXT* forMarshaling);
+DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling);
+DEFINE_ALIAS_FUNCTION(unmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPhysicalDeviceLineRasterizationPropertiesEXT* forMarshaling);
+DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling);
+DEFINE_ALIAS_FUNCTION(unmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void marshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    const VkPipelineRasterizationLineStateCreateInfoEXT* forMarshaling);
+DEFINE_ALIAS_FUNCTION(marshal_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      marshal_VkPipelineRasterizationLineStateCreateInfoEXT)
 
-void unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling);
+DEFINE_ALIAS_FUNCTION(unmarshal_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT)
 
 #define OP_vkCmdSetLineStippleEXT 263855692
 #endif
diff --git a/host/vulkan/cereal/common/goldfish_vk_private_defs.h b/host/vulkan/cereal/common/goldfish_vk_private_defs.h
index 34b6597d0..e0204b3d3 100644
--- a/host/vulkan/cereal/common/goldfish_vk_private_defs.h
+++ b/host/vulkan/cereal/common/goldfish_vk_private_defs.h
@@ -20,22 +20,14 @@
 #include <algorithm>
 #endif
 
-// TODO(b/349066492): this is used as a placeholder extension to inform guest side
-// that host is using MoltenVK, it should be removed after external_memory_metal
-// extension is implemented.
+// We keep advertising VK_MVK_moltenvk on MacOS for backwards compatibility, since in the older
+// guest images the checks for the external memory support is done via this extension.
 #ifndef VK_MVK_moltenvk
 #define VK_MVK_moltenvk 1
 #define VK_MVK_MOLTENVK_SPEC_VERSION 3
 #define VK_MVK_MOLTENVK_EXTENSION_NAME "VK_MVK_moltenvk"
 #endif  // VK_MVK_moltenvk
 
-// These are internally defined MoltenVK flags for external memory usage
-// TODO(b/349066492): They should be removed after being ratified and put under the headers
-static const VkExternalMemoryHandleTypeFlagBits VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_KHR =
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
-static const VkExternalMemoryHandleTypeFlagBits VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR =
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
-
 // VulkanStream features
 #define VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT (1 << 0)
 #define VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT (1 << 1)
@@ -46,16 +38,16 @@ static const VkExternalMemoryHandleTypeFlagBits VK_EXTERNAL_MEMORY_HANDLE_TYPE_M
 
 #ifdef __cplusplus
 
-template<class T, typename F>
+template <class T, typename F>
 bool arrayany(const T* arr, uint32_t begin, uint32_t end, const F& func) {
     const T* e = arr + end;
     return std::find_if(arr + begin, e, func) != e;
 }
 
-#define DEFINE_ALIAS_FUNCTION(ORIGINAL_FN, ALIAS_FN) \
-template <typename... Args> \
-inline auto ALIAS_FN(Args&&... args) -> decltype(ORIGINAL_FN(std::forward<Args>(args)...)) { \
-  return ORIGINAL_FN(std::forward<Args>(args)...); \
-}
+#define DEFINE_ALIAS_FUNCTION(ORIGINAL_FN, ALIAS_FN)                                             \
+    template <typename... Args>                                                                  \
+    inline auto ALIAS_FN(Args&&... args) -> decltype(ORIGINAL_FN(std::forward<Args>(args)...)) { \
+        return ORIGINAL_FN(std::forward<Args>(args)...);                                         \
+    }
 
 #endif
diff --git a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
index ec3c954d7..bd76867c1 100644
--- a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_reserved_marshaling
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -2832,7 +2833,7 @@ void reservedunmarshal_VkDescriptorBufferInfo(VulkanStream* vkStream, VkStructur
     uint64_t cgen_var_0;
     memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
     *ptr += 1 * 8;
-    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
+    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)try_unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
     memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
     *ptr += sizeof(VkDeviceSize);
     memcpy((VkDeviceSize*)&forUnmarshaling->range, *ptr, sizeof(VkDeviceSize));
@@ -11648,6 +11649,112 @@ void reservedunmarshal_VkBufferUsageFlags2CreateInfoKHR(
     *ptr += sizeof(VkBufferUsageFlags2KHR);
 }
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((VkBool32*)&forUnmarshaling->rectangularLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((VkBool32*)&forUnmarshaling->bresenhamLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((VkBool32*)&forUnmarshaling->smoothLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((VkBool32*)&forUnmarshaling->stippledRectangularLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((VkBool32*)&forUnmarshaling->stippledBresenhamLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((VkBool32*)&forUnmarshaling->stippledSmoothLines, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+}
+
+void reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, *ptr, sizeof(uint32_t));
+    *ptr += sizeof(uint32_t);
+}
+
+void reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPipelineRasterizationLineStateCreateInfoKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((VkLineRasterizationModeKHR*)&forUnmarshaling->lineRasterizationMode, *ptr,
+           sizeof(VkLineRasterizationModeKHR));
+    *ptr += sizeof(VkLineRasterizationModeKHR);
+    memcpy((VkBool32*)&forUnmarshaling->stippledLineEnable, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+    memcpy((uint32_t*)&forUnmarshaling->lineStippleFactor, *ptr, sizeof(uint32_t));
+    *ptr += sizeof(uint32_t);
+    memcpy((uint16_t*)&forUnmarshaling->lineStipplePattern, *ptr, sizeof(uint16_t));
+    *ptr += sizeof(uint16_t);
+}
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void reservedunmarshal_VkNativeBufferUsage2ANDROID(VulkanStream* vkStream, VkStructureType rootType,
@@ -12931,112 +13038,6 @@ void reservedunmarshal_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
     *ptr += sizeof(VkProvokingVertexModeEXT);
 }
 
-#endif
-#ifdef VK_EXT_line_rasterization
-void reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling, uint8_t** ptr) {
-    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
-    *ptr += sizeof(VkStructureType);
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    uint32_t pNext_size;
-    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
-    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
-    *ptr += sizeof(uint32_t);
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
-        *ptr += sizeof(VkStructureType);
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
-                                           ptr);
-    }
-    memcpy((VkBool32*)&forUnmarshaling->rectangularLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((VkBool32*)&forUnmarshaling->bresenhamLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((VkBool32*)&forUnmarshaling->smoothLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((VkBool32*)&forUnmarshaling->stippledRectangularLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((VkBool32*)&forUnmarshaling->stippledBresenhamLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((VkBool32*)&forUnmarshaling->stippledSmoothLines, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-}
-
-void reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling, uint8_t** ptr) {
-    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
-    *ptr += sizeof(VkStructureType);
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    uint32_t pNext_size;
-    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
-    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
-    *ptr += sizeof(uint32_t);
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
-        *ptr += sizeof(VkStructureType);
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
-                                           ptr);
-    }
-    memcpy((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, *ptr, sizeof(uint32_t));
-    *ptr += sizeof(uint32_t);
-}
-
-void reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling, uint8_t** ptr) {
-    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
-    *ptr += sizeof(VkStructureType);
-    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
-        rootType = forUnmarshaling->sType;
-    }
-    uint32_t pNext_size;
-    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
-    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
-    *ptr += sizeof(uint32_t);
-    forUnmarshaling->pNext = nullptr;
-    if (pNext_size) {
-        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
-        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
-        *ptr += sizeof(VkStructureType);
-        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
-        vkStream->alloc((void**)&forUnmarshaling->pNext,
-                        goldfish_vk_extension_struct_size_with_stream_features(
-                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
-        *(VkStructureType*)forUnmarshaling->pNext = extType;
-        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
-                                           ptr);
-    }
-    memcpy((VkLineRasterizationModeEXT*)&forUnmarshaling->lineRasterizationMode, *ptr,
-           sizeof(VkLineRasterizationModeEXT));
-    *ptr += sizeof(VkLineRasterizationModeEXT);
-    memcpy((VkBool32*)&forUnmarshaling->stippledLineEnable, *ptr, sizeof(VkBool32));
-    *ptr += sizeof(VkBool32);
-    memcpy((uint32_t*)&forUnmarshaling->lineStippleFactor, *ptr, sizeof(uint32_t));
-    *ptr += sizeof(uint32_t);
-    memcpy((uint16_t*)&forUnmarshaling->lineStipplePattern, *ptr, sizeof(uint16_t));
-    *ptr += sizeof(uint16_t);
-}
-
 #endif
 #ifdef VK_EXT_index_type_uint8
 void reservedunmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -15702,6 +15703,32 @@ void reservedunmarshal_extension_struct(VulkanStream* vkStream, VkStructureType
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                    structExtension_out),
+                ptr);
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                    structExtension_out),
+                ptr);
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                    structExtension_out),
+                ptr);
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             reservedunmarshal_VkNativeBufferANDROID(
@@ -15986,32 +16013,6 @@ void reservedunmarshal_extension_struct(VulkanStream* vkStream, VkStructureType
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                    structExtension_out),
-                ptr);
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                    structExtension_out),
-                ptr);
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-                vkStream, rootType,
-                reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                    structExtension_out),
-                ptr);
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             reservedunmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
diff --git a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
index ddb8801ee..184670ec0 100644
--- a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
+++ b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_reserved_marshaling
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -1621,6 +1622,20 @@ void reservedunmarshal_VkBufferUsageFlags2CreateInfoKHR(
     VulkanStream* vkStream, VkStructureType rootType,
     VkBufferUsageFlags2CreateInfoKHR* forUnmarshaling, uint8_t** ptr);
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* forUnmarshaling, uint8_t** ptr);
+
+void reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* forUnmarshaling, uint8_t** ptr);
+
+void reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPipelineRasterizationLineStateCreateInfoKHR* forUnmarshaling, uint8_t** ptr);
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void reservedunmarshal_VkNativeBufferUsage2ANDROID(VulkanStream* vkStream, VkStructureType rootType,
@@ -1841,17 +1856,14 @@ void reservedunmarshal_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
 
 #endif
 #ifdef VK_EXT_line_rasterization
-void reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling, uint8_t** ptr);
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling, uint8_t** ptr);
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VulkanStream* vkStream, VkStructureType rootType,
-    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling, uint8_t** ptr);
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT)
 
 #endif
 #ifdef VK_EXT_index_type_uint8
diff --git a/host/vulkan/cereal/common/goldfish_vk_transform.cpp b/host/vulkan/cereal/common/goldfish_vk_transform.cpp
index 28ed4b6a8..2648c5b67 100644
--- a/host/vulkan/cereal/common/goldfish_vk_transform.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_transform.cpp
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_transform
 //
-// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (impl) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -6883,6 +6884,68 @@ void transform_fromhost_VkBufferUsageFlags2CreateInfoKHR(
     }
 }
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_tohost_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPipelineRasterizationLineStateCreateInfoKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPipelineRasterizationLineStateCreateInfoKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void transform_tohost_VkNativeBufferUsage2ANDROID(VkDecoderGlobalState* resourceTracker,
@@ -7731,68 +7794,6 @@ void transform_fromhost_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
     }
 }
 
-#endif
-#ifdef VK_EXT_line_rasterization
-void transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
-void transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
-void transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
-void transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
-void transform_tohost_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPipelineRasterizationLineStateCreateInfoEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
-void transform_fromhost_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPipelineRasterizationLineStateCreateInfoEXT* toTransform) {
-    (void)resourceTracker;
-    (void)toTransform;
-    if (toTransform->pNext) {
-        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
-    }
-}
-
 #endif
 #ifdef VK_EXT_index_type_uint8
 void transform_tohost_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -9667,6 +9668,26 @@ void transform_tohost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            transform_tohost_VkPipelineRasterizationLineStateCreateInfoKHR(
+                resourceTracker, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                                     structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             transform_tohost_VkNativeBufferANDROID(
@@ -9847,26 +9868,6 @@ void transform_tohost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                                     structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                                     structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            transform_tohost_VkPipelineRasterizationLineStateCreateInfoEXT(
-                resourceTracker, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                                     structExtension_out));
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             transform_tohost_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
@@ -10917,6 +10918,26 @@ void transform_fromhost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
+#ifdef VK_KHR_line_rasterization
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {
+            transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: {
+            transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {
+            transform_fromhost_VkPipelineRasterizationLineStateCreateInfoKHR(
+                resourceTracker, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
+                                     structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_ANDROID_native_buffer
         case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
             transform_fromhost_VkNativeBufferANDROID(
@@ -11097,26 +11118,6 @@ void transform_fromhost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
-#ifdef VK_EXT_line_rasterization
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
-            transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
-                                     structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
-            transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-                resourceTracker, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
-                                     structExtension_out));
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
-            transform_fromhost_VkPipelineRasterizationLineStateCreateInfoEXT(
-                resourceTracker, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
-                                     structExtension_out));
-            break;
-        }
-#endif
 #ifdef VK_EXT_index_type_uint8
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
             transform_fromhost_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
diff --git a/host/vulkan/cereal/common/goldfish_vk_transform.h b/host/vulkan/cereal/common/goldfish_vk_transform.h
index ddabb7712..6b4f90f51 100644
--- a/host/vulkan/cereal/common/goldfish_vk_transform.h
+++ b/host/vulkan/cereal/common/goldfish_vk_transform.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module goldfish_vk_transform
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
@@ -2705,6 +2706,32 @@ void transform_tohost_VkBufferUsageFlags2CreateInfoKHR(
 void transform_fromhost_VkBufferUsageFlags2CreateInfoKHR(
     VkDecoderGlobalState* resourceTracker, VkBufferUsageFlags2CreateInfoKHR* toTransform);
 
+#endif
+#ifdef VK_KHR_line_rasterization
+void transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* toTransform);
+
+void transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR* toTransform);
+
+void transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* toTransform);
+
+void transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR* toTransform);
+
+void transform_tohost_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPipelineRasterizationLineStateCreateInfoKHR* toTransform);
+
+void transform_fromhost_VkPipelineRasterizationLineStateCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPipelineRasterizationLineStateCreateInfoKHR* toTransform);
+
 #endif
 #ifdef VK_ANDROID_native_buffer
 void transform_tohost_VkNativeBufferUsage2ANDROID(VkDecoderGlobalState* resourceTracker,
@@ -3067,29 +3094,23 @@ void transform_fromhost_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
 
 #endif
 #ifdef VK_EXT_line_rasterization
-void transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      transform_tohost_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationFeaturesEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesKHR,
+                      transform_fromhost_VkPhysicalDeviceLineRasterizationFeaturesEXT)
 
-void transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      transform_tohost_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPhysicalDeviceLineRasterizationPropertiesEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesKHR,
+                      transform_fromhost_VkPhysicalDeviceLineRasterizationPropertiesEXT)
 
-void transform_tohost_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPipelineRasterizationLineStateCreateInfoEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      transform_tohost_VkPipelineRasterizationLineStateCreateInfoEXT)
 
-void transform_fromhost_VkPipelineRasterizationLineStateCreateInfoEXT(
-    VkDecoderGlobalState* resourceTracker,
-    VkPipelineRasterizationLineStateCreateInfoEXT* toTransform);
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPipelineRasterizationLineStateCreateInfoKHR,
+                      transform_fromhost_VkPipelineRasterizationLineStateCreateInfoEXT)
 
 #endif
 #ifdef VK_EXT_index_type_uint8
diff --git a/host/vulkan/cereal/common/vk_struct_id.h b/host/vulkan/cereal/common/vk_struct_id.h
index 52e7132ea..081d6795f 100644
--- a/host/vulkan/cereal/common/vk_struct_id.h
+++ b/host/vulkan/cereal/common/vk_struct_id.h
@@ -29,7 +29,7 @@ struct vk_get_vk_struct_id;
     };
 
 REGISTER_VK_STRUCT_ID(VkBufferCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO);
-REGISTER_VK_STRUCT_ID(VkImageCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO);
+REGISTER_VK_STRUCT_ID(VkImageCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO);
 REGISTER_VK_STRUCT_ID(VkImageFormatProperties2, VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2);
 REGISTER_VK_STRUCT_ID(VkNativeBufferANDROID, VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID);
 REGISTER_VK_STRUCT_ID(VkExternalMemoryBufferCreateInfo,
@@ -103,6 +103,8 @@ REGISTER_VK_STRUCT_ID(VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT);
 REGISTER_VK_STRUCT_ID(VkPhysicalDevicePrivateDataFeatures,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES);
+REGISTER_VK_STRUCT_ID(VkPhysicalDeviceInlineUniformBlockFeatures,
+                      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES);
 
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
 REGISTER_VK_STRUCT_ID(VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX,
@@ -124,11 +126,20 @@ REGISTER_VK_STRUCT_ID(VkExportMetalBufferInfoEXT, VK_STRUCTURE_TYPE_EXPORT_METAL
 
 REGISTER_VK_STRUCT_ID(VkExportMetalObjectCreateInfoEXT,
                       VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT);
+
+REGISTER_VK_STRUCT_ID(VkImportMemoryMetalHandleInfoEXT,
+                      VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT);
+REGISTER_VK_STRUCT_ID(VkMemoryMetalHandlePropertiesEXT,
+                      VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT);
+REGISTER_VK_STRUCT_ID(VkMemoryGetMetalHandleInfoEXT,
+                      VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT);
 #endif
 
 REGISTER_VK_STRUCT_ID(VkPhysicalDeviceDiagnosticsConfigFeaturesNV,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV);
 REGISTER_VK_STRUCT_ID(VkDeviceGroupDeviceCreateInfo,
                       VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO);
+REGISTER_VK_STRUCT_ID(VkPhysicalDeviceVulkan13Features,
+                      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES);
 
 #undef REGISTER_VK_STRUCT_ID
diff --git a/host/vulkan/vk_android_native_buffer_structure_type.h b/host/vulkan/vk_android_native_buffer_structure_type.h
index caa7ec6e1..a2d526f13 100644
--- a/host/vulkan/vk_android_native_buffer_structure_type.h
+++ b/host/vulkan/vk_android_native_buffer_structure_type.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module vk_android_native_buffer_structure_type
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
diff --git a/host/vulkan/vk_util.h b/host/vulkan/vk_util.h
index 281544940..2a44cf7f8 100644
--- a/host/vulkan/vk_util.h
+++ b/host/vulkan/vk_util.h
@@ -47,6 +47,7 @@
 #include "host-common/logging.h"
 #include "vk_fn_info.h"
 #include "vk_struct_id.h"
+#include "vulkan/vk_enum_string_helper.h"
 
 namespace gfxstream {
 namespace vk {
@@ -303,7 +304,9 @@ void vk_struct_chain_filter(H* head) {
                 vk_util::getVkCheckCallbacks().callIfExists(                                    \
                     &vk_util::VkCheckCallbacks::onVkErrorOutOfMemory, err, __func__, __LINE__); \
             }                                                                                   \
-            GFXSTREAM_ABORT(::emugl::FatalError(err));                                          \
+            GFXSTREAM_ABORT(::emugl::FatalError(err))                                           \
+                << " VK_CHECK(" << #x << ") failed with " << string_VkResult(err) << " at "     \
+                << __FILE__ << ":" << __LINE__;                                                 \
         }                                                                                       \
     } while (0)
 
diff --git a/host/vulkan/vulkan_gfxstream_structure_type.h b/host/vulkan/vulkan_gfxstream_structure_type.h
index 7ef8ed8cb..39bfcb0fb 100644
--- a/host/vulkan/vulkan_gfxstream_structure_type.h
+++ b/host/vulkan/vulkan_gfxstream_structure_type.h
@@ -15,12 +15,13 @@
 
 // Autogenerated module vulkan_gfxstream_structure_type
 //
-// (header) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
-// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
-// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
+// (header) generated by scripts/genvk.py -registry
+// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
+// -registryGfxstream xml/vk_gfxstream.xml cereal -o
+// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
 //
 // Please do not modify directly;
-// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
+// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
 // or directly from Python by defining:
 // VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
 // VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
diff --git a/include/render-utils/virtio_gpu_ops.h b/include/render-utils/virtio_gpu_ops.h
index aec536ce6..fedfa8614 100644
--- a/include/render-utils/virtio_gpu_ops.h
+++ b/include/render-utils/virtio_gpu_ops.h
@@ -80,6 +80,9 @@ typedef void (*read_buffer_t)(uint32_t handle, uint64_t offset, uint64_t sizeToR
 typedef void (*read_color_buffer_t)(
     uint32_t handle, int x, int y, int width, int height,
     uint32_t format, uint32_t type, void* pixels);
+typedef void (*read_color_buffer2_t)(
+    uint32_t handle, int x, int y, int width, int height,
+    uint32_t format, uint32_t type, void* pixels, uint64_t pixels_size);
 typedef void (*read_color_buffer_yuv_t)(
     uint32_t handle, int x, int y, int width, int height,
     void* pixels, uint32_t pixels_size);
@@ -117,25 +120,6 @@ typedef void* async_wait_for_gpu_vulkan_with_cb_t;
 typedef void* async_wait_for_gpu_vulkan_qsri_with_cb_t;
 #endif
 
-
-// Platform resources and contexts support
-#define RESOURCE_TYPE_MASK 0x0F
-#define RESOURCE_USE_MASK  0xF0
-
-// types
-#define RESOURCE_TYPE_EGL_NATIVE_PIXMAP 0x01
-#define RESOURCE_TYPE_EGL_IMAGE 0x02
-#define RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE 0x03
-
-// uses
-#define RESOURCE_USE_PRESERVE 0x10
-
-typedef bool (*platform_import_resource_t)(uint32_t handle, uint32_t info, void* resource);
-typedef bool (*platform_resource_info_t)(uint32_t handle, int32_t* width, int32_t* height, int32_t* internal_format);
-typedef void* (*platform_create_shared_egl_context_t)(void);
-typedef bool (*platform_destroy_shared_egl_context_t)(void* context);
-typedef int (*wait_sync_color_buffer_t)(uint32_t handle);
-
 struct AndroidVirtioGpuOps {
     create_buffer_with_handle_t create_buffer_with_handle;
     create_color_buffer_with_handle_t create_color_buffer_with_handle;
@@ -146,6 +130,7 @@ struct AndroidVirtioGpuOps {
     update_color_buffer_t update_color_buffer;
     read_buffer_t read_buffer;
     read_color_buffer_t read_color_buffer;
+    read_color_buffer2_t read_color_buffer2;
     read_color_buffer_yuv_t read_color_buffer_yuv;
     post_color_buffer_t post_color_buffer;
     async_post_color_buffer_t async_post_color_buffer;
@@ -167,11 +152,4 @@ struct AndroidVirtioGpuOps {
     async_wait_for_gpu_vulkan_qsri_with_cb_t async_wait_for_gpu_vulkan_qsri_with_cb;
 
     update_color_buffer_from_framework_format_t update_color_buffer_from_framework_format;
-
-    platform_import_resource_t platform_import_resource;
-    platform_resource_info_t platform_resource_info;
-    platform_create_shared_egl_context_t platform_create_shared_egl_context;
-    platform_destroy_shared_egl_context_t platform_destroy_shared_egl_context;
-
-    wait_sync_color_buffer_t wait_sync_color_buffer;
 };
diff --git a/scripts/generate-gfxstream-vulkan.sh b/scripts/generate-gfxstream-vulkan.sh
index eea57f914..2623d4caf 100755
--- a/scripts/generate-gfxstream-vulkan.sh
+++ b/scripts/generate-gfxstream-vulkan.sh
@@ -13,33 +13,38 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-
 export GFXSTREAM_DIR=$(pwd)
-
 if [ -z "$1" ];
 then
-    export GFXSTREAM_GUEST_DIR=$GFXSTREAM_DIR/guest
+    export MESA_DIR=$(pwd)/../../../external/mesa3d
 else
-    export GFXSTREAM_GUEST_DIR=$1
+    export MESA_DIR=$1
 fi
 
-# Detect clang-format
-#if ! $WHICH clang-format > /dev/null; then
-#    echo "Failed to find clang-format." 1>&2
-#    exit 1
-#fi
+export PREFIX_DIR=src/gfxstream
+
+# We should use just use one vk.xml eventually..
+export VK_MESA_XML=$MESA_DIR/src/vulkan/registry/vk.xml
+export VK_XML=$GFXSTREAM_DIR/codegen/vulkan/vulkan-docs-next/xml/vk.xml
 
-export GFXSTREAM_GUEST_ENCODER_DIR=$GFXSTREAM_GUEST_DIR/vulkan_enc
+export GFXSTREAM_GUEST_ENCODER_DIR=/tmp/
 export GFXSTREAM_HOST_DECODER_DIR=$GFXSTREAM_DIR/host/vulkan
 export GFXSTREAM_OUTPUT_DIR=$GFXSTREAM_HOST_DECODER_DIR/cereal
 export GFXSTREAM_SCRIPTS_DIR=$GFXSTREAM_DIR/scripts
 
-export GEN_VK=$GFXSTREAM_DIR/codegen/vulkan/vulkan-docs-next/scripts/genvk.py
-export VK_XML=$GFXSTREAM_DIR/codegen/vulkan/vulkan-docs-next/xml/vk.xml
-export CUSTOM_XML=$GFXSTREAM_DIR/codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml
+export GEN_VK=$GFXSTREAM_DIR/$PREFIX_DIR/codegen/scripts/genvk.py
+export CUSTOM_XML=$GFXSTREAM_DIR/$PREFIX_DIR/codegen/xml/vk_gfxstream.xml
+
+# For testing Mesa codegen copy only
+#export GEN_VK=$MESA_DIR/$PREFIX_DIR/codegen/scripts/genvk.py
+#export CUSTOM_XML=$MESA_DIR/$PREFIX_DIR/codegen/xml/vk_gfxstream.xml
 
 python3 $GEN_VK -registry $VK_XML -registryGfxstream $CUSTOM_XML cereal -o $GFXSTREAM_OUTPUT_DIR
 
+export CEREAL_VARIANT=guest
+export GFXSTREAM_GUEST_ENCODER_DIR=$GFXSTREAM_DIR/guest/vulkan_enc
+python3 $GEN_VK -registry $VK_MESA_XML -registryGfxstream $CUSTOM_XML cereal -o /tmp/
+
 # Should have a unified headers dir here:
 python3 $GEN_VK -registry $CUSTOM_XML vulkan_gfxstream.h -o $GFXSTREAM_GUEST_ENCODER_DIR
 python3 $GEN_VK -registry $CUSTOM_XML vulkan_gfxstream.h -o $GFXSTREAM_HOST_DECODER_DIR
diff --git a/scripts/print_gfx_logs/vulkan_printer.py b/scripts/print_gfx_logs/vulkan_printer.py
index 9ed95375e..b7a35713f 100644
--- a/scripts/print_gfx_logs/vulkan_printer.py
+++ b/scripts/print_gfx_logs/vulkan_printer.py
@@ -1345,12 +1345,10 @@ VkDynamicState = {
     1000205000: "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV",
     1000205001: "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV",
     1000226000: "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR",
-    1000259000: "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT",
     1000352000: "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT",
     1000377000: "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT",
     1000377003: "VK_DYNAMIC_STATE_LOGIC_OP_EXT",
     1000381000: "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT",
-    1000455002: "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT",
     1000455003: "VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT",
     1000455004: "VK_DYNAMIC_STATE_POLYGON_MODE_EXT",
     1000455005: "VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT",
@@ -1361,6 +1359,7 @@ VkDynamicState = {
     1000455010: "VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT",
     1000455011: "VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT",
     1000455012: "VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT",
+    1000455002: "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT",
     1000455013: "VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT",
     1000455014: "VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT",
     1000455015: "VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT",
@@ -1382,6 +1381,7 @@ VkDynamicState = {
     1000455031: "VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV",
     1000455032: "VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV",
     1000524000: "VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT",
+    1000259000: "VK_DYNAMIC_STATE_LINE_STIPPLE_KHR",
 }
 
 VkFilter = {
@@ -2410,9 +2410,6 @@ VkStructureType = {
     1000255002: "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT",
     1000255001: "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT",
     1000256000: "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT",
-    1000259000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT",
-    1000259001: "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT",
-    1000259002: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT",
     1000260000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT",
     1000265000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT",
     1000267000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT",
@@ -2754,6 +2751,9 @@ VkStructureType = {
     1000529003: "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX",
     1000529004: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX",
     1000530000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT",
+    1000259000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR",
+    1000259001: "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR",
+    1000259002: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR",
     1000546000: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV",
     1000601000: "VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT",
     1000601001: "VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT",
```

