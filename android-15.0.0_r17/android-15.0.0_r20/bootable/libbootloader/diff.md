```diff
diff --git a/BUILD b/BUILD
index badeb83..f9c9199 100644
--- a/BUILD
+++ b/BUILD
@@ -12,11 +12,18 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("//build/bazel_common_rules/dist:dist.bzl", "copy_to_dist_dir")
+load("@rules_pkg//pkg:install.bzl", "pkg_install")
+load("@rules_pkg//pkg:mappings.bzl", "pkg_files", "strip_prefix")
 
-copy_to_dist_dir(
+pkg_files(
+    name = "gbl_efi_dist_files",
+    srcs = ["@gbl//efi:all_platforms"],
+    strip_prefix = strip_prefix.files_only(),
+    visibility = ["//visibility:private"],
+)
+
+pkg_install(
     name = "gbl_efi_dist",
-    data = ["@gbl//efi:all_platforms"],
-    dist_dir = "out/gbl_efi/",
-    flat = True,
+    srcs = [":gbl_efi_dist_files"],
+    destdir = "out/gbl_efi/",
 )
diff --git a/gbl/BUILD b/gbl/BUILD
index 341da2e..0848b74 100644
--- a/gbl/BUILD
+++ b/gbl/BUILD
@@ -24,8 +24,8 @@ readme_test(
         "@gbl//efi:libgbl_efi",
         "@gbl//libavb:sysdeps",
         "@gbl//libboot",
-        "@gbl//libbootconfig",
         "@gbl//libbootimg",
+        "@gbl//libbootparams",
         "@gbl//libc",
         "@gbl//libefi",
         "@gbl//libefi_types",
diff --git a/gbl/README.md b/gbl/README.md
index c20f0bf..e0fe1d0 100644
--- a/gbl/README.md
+++ b/gbl/README.md
@@ -6,7 +6,7 @@ can be loaded directly from the firmware.
 
 ## Get source tree and build
 
-To succesfully get and build the tree your machine must have the following dependencies installed:
+To successfully get and build the tree your machine must have the following dependencies installed:
 
 ```
 # repo to work with android repositories (https://source.android.com/docs/setup/reference/repo)
@@ -28,6 +28,7 @@ To build the EFI application:
 ```
 ./tools/bazel run //bootable/libbootloader:gbl_efi_dist --extra_toolchains=@gbl//toolchain:all
 ```
+
 The above builds the EFI application for all of `x86_64`, `x86_32`, `aarch64`
 and `riscv64` platforms.
 
@@ -37,6 +38,36 @@ To run the set of unit tests:
 ./tools/bazel test @gbl//tests --extra_toolchains=@gbl//toolchain:all
 ```
 
+## IDE Setup
+
+For rust development, we recommend use VSCode + rust-analyzer plugin.
+
+rust-analyzer requires `rust-project.json` to work properly. Luckily, bazel has
+support for generating `rust-project.json`:
+
+```
+./tools/bazel run @rules_rust//tools/rust_analyzer:gen_rust_project --norepository_disable_download -- --bazel ./tools/bazel @gbl//efi/...
+```
+
+`@gbl//efi/...` is the target to generate rust project for, here it means
+"everything under @gbl//efi/ directory" . Omitting the target specifier would
+result in analyzing "@/..." , which would most likely fail due to some obscure
+reason. Should targets get moved around in the future, this path spec also need
+to be updated.
+
+After generating `rust-project.json`, you would notice that your IDE still
+doesn't offer auto completion. This is because some source file paths pointing
+to bazel-output dir, and you are most likely editing source files in
+`bootable/libbootloader/gbl`. In addition, the generated rust-project.json sets
+"cfg=test" for all targets, which causes certain dependency graph to resolve
+incorrectly. To fix this, run
+
+```
+python3 bootable/libbootloader/gbl/rewrite_rust_project_path.py rust-project.json
+```
+
+And reload your IDE.
+
 ## Run the EFI application
 
 ### Boot Android on Cuttlefish
@@ -50,7 +81,7 @@ cvd start --android_efi_loader=<path to the EFI image> ...
 ```
 
 The above uses the same setting as a normal `cvd start` run, except that
-insted of booting Android directly, the emulator first hands off to the EFI
+instead of booting Android directly, the emulator first hands off to the EFI
 application, which will take over booting android.
 
 Note: For x86 platform, use the EFI image built for `x86_32`.
@@ -80,7 +111,7 @@ configurations:
    sudo apt-get install qemu-system ovmf u-boot-qemu
    ```
 
-1. Depending on the target achitecture you want to run:
+1. Depending on the target architecture you want to run:
 
    For `x86_64`:
    ```
@@ -110,6 +141,37 @@ configurations:
        -device virtio-blk-device,drive=blk0
    ```
 
+### Boot Fuchsia on emulator
+
+1. Make sure Fuchsia target pass control to GBL.
+
+   Set path to GBL binary here: [fuchsia/src/firmware/gigaboot/cpp/backends.gni : gigaboot_gbl_efi_app](https://cs.opensource.google/fuchsia/fuchsia/+/main:src/firmware/gigaboot/cpp/backends.gni;l=25?q=gigaboot_gbl_efi_app)
+
+   E.g. in `fuchsia/src/firmware/gigaboot/cpp/backends.gni`:
+   ```
+   $ cat ./fuchsia/src/firmware/gigaboot/cpp/backends.gni
+   ...
+   declare_args() {
+      ...
+      gigaboot_gbl_efi_app = "<path to EFI image>/gbl_x86_64.efi"
+   }
+   ```
+
+   Or in `fx set`:
+   ```
+   fx set core.x64 --args=gigaboot_gbl_efi_app='"<path to EFI image>/gbl_x86_64.efi"'
+   ```
+
+2. Build: (this has to be done every time if EFI app changes)
+
+   `fx build`
+
+3. Run emulator in UEFI mode with raw disk
+
+   ```
+   fx qemu -a x64 --uefi --disktype=nvme -D ./out/default/obj/build/images/disk.raw
+   ```
+
 ## EFI Protocols
 
 List of EFI protocols used by GBL and a brief description of each [here](./docs/efi_protocols.md).
diff --git a/gbl/bazel.MODULE.bazel b/gbl/bazel.MODULE.bazel
index 4231fd0..114ddbc 100644
--- a/gbl/bazel.MODULE.bazel
+++ b/gbl/bazel.MODULE.bazel
@@ -24,7 +24,6 @@ module(
 )
 
 register_toolchains(
-    "//prebuilts/build-tools:py_toolchain_musl",
     "//prebuilts/build-tools:py_toolchain",
 )
 
diff --git a/gbl/bazel.WORKSPACE b/gbl/bazel.WORKSPACE
index cfa327a..1cc0747 100644
--- a/gbl/bazel.WORKSPACE
+++ b/gbl/bazel.WORKSPACE
@@ -20,6 +20,18 @@ local_repository(
 )
 
 # buildifier: disable=load-on-top
-load("@gbl//integration/aosp_u-boot-mainline:workspace.bzl", "define_gbl_workspace")
+load("@gbl//integration/aosp_uefi-gbl-mainline:workspace.bzl", "define_gbl_workspace")
 
 define_gbl_workspace()
+
+load("@rules_rust//tools/rust_analyzer:deps.bzl", "rust_analyzer_dependencies")
+
+rust_analyzer_dependencies()
+
+load("@gbl//toolchain:gbl_workspace_util.bzl", "GBL_RUST_VERSION")
+load("@rules_rust//rust:repositories.bzl", "rust_analyzer_toolchain_repository")
+
+register_toolchains(rust_analyzer_toolchain_repository(
+    name = "rust_analyzer_toolchain",
+    version = GBL_RUST_VERSION,
+))
diff --git a/gbl/bazel.bazelrc b/gbl/bazel.bazelrc
index 2ebe563..39f898f 100644
--- a/gbl/bazel.bazelrc
+++ b/gbl/bazel.bazelrc
@@ -1,3 +1,65 @@
+# Lock down the PATH variable in actions to /usr/bin and /usr/local/bin.
+build --incompatible_strict_action_env
+
+# By default, output all the logs to stdout/stderr by disabling the console limit
+build --experimental_ui_max_stdouterr_bytes=-1
+
+# Make output directories writable so `rm -rf out/` works.
+build --experimental_writable_outputs
+
+# NOTE: To ensure a strict no external access policy, the following three flags
+#   need to be set/unset, see https://github.com/bazelbuild/bazel/discussions/18281
+#   for more details about this.
+# An empty string as argument requests the cache to be disabled.
+common --repository_cache=
+# Additional places to search for archives before accessing the network to download them.
+common --distdir=
+# If set, downloading using ctx.download{,_and_extract} is not allowed during repository fetching.
+common --repository_disable_download
+
+# bzlmod
+common --enable_bzlmod
+common --registry=file://%workspace%/external/bazelbuild-bazel-central-registry
+# Set --lockfile_mode=off to prevent generation of MODULE.bazel.lock
+# and caching of source declarations in the registry.
+# See https://github.com/bazelbuild/bazel/issues/20477
+# Note: If the registry files are modified, one needs to run `bazel shutdown`
+#   as well as setting this flag. Usually, files are only added to the registry.
+common --lockfile_mode=off
+
+# CC toolchain
+# Use --platforms to select toolchains, not the legacy --cpu --cross_top --compiler.
+# See https://bazel.build/concepts/platforms#cxx
+build --incompatible_enable_cc_toolchain_resolution
+
+# Do not use host toolchain
+build --action_env=BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN=1
+
 build --@rules_rust//rust/settings:experimental_toolchain_generated_sysroot=false
-common --config=bzlmod
 common --extra_toolchains=@gbl//toolchain:all
+test  --test_output=errors
+
+# Set up remote caching
+# https://developers.google.com/remote-build-execution/docs/set-up/set-up-caching
+test:ants --remote_cache=grpcs://remotebuildexecution.googleapis.com
+test:ants --google_default_credentials=true
+test:ants --remote_instance_name=projects/android-build-farm/instances/default_instance
+test:ants --noremote_upload_local_results
+
+# Upload results to BES backend.
+# Refer to go/bazel-ants-docs
+test:ants --bes_backend=buildeventservice-pa.googleapis.com
+test:ants --bes_keywords=android-test-storage
+test:ants --bes_instance_name=android-build-farm
+test:ants --build_metadata=run_type=critical
+
+# Show URI to test results
+test:ants --build_metadata=generate_test_uri=fusion
+
+# These need to be set in the command line
+# test:ants --build_metadata="ab_build_id=${BUILD_ID}"
+# test:ants --build_metadata="ab_target=???",
+# test:ants --build_metadata="test_definition_name=kernel/kleaf/???"
+
+common:android_ci --noshow_progress
+test:android_ci --config=ants
diff --git a/gbl/bazel.py b/gbl/bazel.py
new file mode 100644
index 0000000..a27f4be
--- /dev/null
+++ b/gbl/bazel.py
@@ -0,0 +1,191 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import os
+import pathlib
+import sys
+from typing import Tuple, Optional
+
+_BAZEL_REL_PATH = "prebuilts/kernel-build-tools/bazel/linux-x86_64/bazel"
+
+
+def _partition(lst: list[str], index: Optional[int]) \
+        -> Tuple[list[str], Optional[str], list[str]]:
+    """Returns the triple split by index.
+
+    That is, return a tuple:
+    (everything before index, the element at index, everything after index)
+
+    If index is None, return (the list, None, empty list)
+    """
+    if index is None:
+        return lst[:], None, []
+    return lst[:index], lst[index], lst[index + 1:]
+
+
+class BazelWrapper(object):
+    def __init__(self, workspace_dir: pathlib.Path, bazel_args: list[str]):
+        """Splits arguments to the bazel binary based on the functionality.
+
+        bazel [startup_options] command         [command_args] --               [target_patterns]
+                                 ^- command_idx                ^- dash_dash_idx
+
+        See https://bazel.build/reference/command-line-reference
+
+        Args:
+            workspace_dir: root of workspace.
+            bazel_args: The list of arguments the user provides through command line
+            env: existing environment
+        """
+
+        self.workspace_dir = workspace_dir
+
+        self.bazel_path = self.workspace_dir / _BAZEL_REL_PATH
+
+        command_idx = None
+        for idx, arg in enumerate(bazel_args):
+            if not arg.startswith("-"):
+                command_idx = idx
+                break
+
+        self.startup_options, self.command, remaining_args = _partition(bazel_args,
+                                                                        command_idx)
+
+        # Split command_args into `command_args -- target_patterns`
+        dash_dash_idx = None
+        try:
+            dash_dash_idx = remaining_args.index("--")
+        except ValueError:
+            # If -- is not found, put everything in command_args. These arguments
+            # are not provided to the Bazel executable target.
+            pass
+
+        self.command_args, self.dash_dash, self.target_patterns = _partition(remaining_args,
+                                                                             dash_dash_idx)
+
+        self._parse_startup_options()
+        self._parse_command_args()
+        self._add_extra_startup_options()
+
+    def add_startup_option_to_parser(self, parser):
+        parser.add_argument(
+            "-h", "--help", action="store_true",
+            help="show this help message and exit"
+        )
+
+    def _parse_startup_options(self):
+        """Parses the given list of startup_options.
+
+        After calling this function, the following attributes are set:
+        - absolute_user_root: A path holding bazel build output location
+        - transformed_startup_options: The transformed list of startup_options to replace
+          existing startup_options to be fed to the Bazel binary
+        """
+
+        parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
+        self.add_startup_option_to_parser(parser)
+
+        self.known_startup_options, self.user_startup_options = \
+            parser.parse_known_args(self.startup_options)
+
+        self.absolute_out_dir = self.workspace_dir / "out"
+        self.absolute_user_root = \
+            self.absolute_out_dir / "bazel/output_user_root"
+
+        if self.known_startup_options.help:
+            self.transformed_startup_options = [
+                "--help"
+            ]
+
+        if not self.known_startup_options.help:
+            javatmp = self.absolute_out_dir / "bazel/javatmp"
+            self.transformed_startup_options = [
+                f"--host_jvm_args=-Djava.io.tmpdir={javatmp}",
+            ]
+
+        # See _add_extra_startup_options for extra startup options
+
+    def _parse_command_args(self):
+        """Parses the given list of command_args.
+
+        After calling this function, the following attributes are set:
+        - known_args: A namespace holding options known by this Bazel wrapper script
+        - transformed_command_args: The transformed list of command_args to replace
+          existing command_args to be fed to the Bazel binary
+        - env: A dictionary containing the new environment variables for the subprocess.
+        """
+
+        parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
+
+        # TODO: Delete these args once build bots no longer specify them
+        parser.add_argument(
+            "--make_jobs", metavar="JOBS", type=int, default=None,
+            help="unused")
+        parser.add_argument(
+            "--make_keep_going", action="store_true", default=False,
+            help="unused")
+        parser.add_argument(
+            "--repo_manifest", metavar="<repo_root>:<manifest.xml>",
+            help="unused")
+
+        # Skip startup options (before command) and target_patterns (after --)
+        _, self.transformed_command_args = parser.parse_known_args(
+            self.command_args)
+
+    def _add_extra_startup_options(self):
+        """Adds extra startup options after command args are parsed."""
+
+        self.transformed_startup_options += self.user_startup_options
+
+        if not self.known_startup_options.help:
+            self.transformed_startup_options.append(
+                f"--output_user_root={self.absolute_user_root}")
+
+    def _build_final_args(self) -> list[str]:
+        """Builds the final arguments for the subprocess."""
+        # final_args:
+        # bazel [startup_options] [additional_startup_options] command [transformed_command_args] -- [target_patterns]
+
+        final_args = [self.bazel_path] + self.transformed_startup_options
+
+        if self.command is not None:
+            final_args.append(self.command)
+        final_args += self.transformed_command_args
+        if self.dash_dash is not None:
+            final_args.append(self.dash_dash)
+        final_args += self.target_patterns
+
+        return final_args
+
+    def run(self) -> int:
+        """Runs the wrapper.
+
+        Returns:
+            doesn't return"""
+        final_args = self._build_final_args()
+
+        os.execve(path=self.bazel_path, argv=final_args, env=os.environ)
+
+
+def _bazel_wrapper_main():
+    # <workspace_dir>/bootable/libbootloader/gbl/bazel.py
+    workspace_dir = (
+        pathlib.Path(__file__).resolve().parent.parent.parent.parent)
+    return BazelWrapper(workspace_dir=workspace_dir,
+                        bazel_args=sys.argv[1:]).run()
+
+
+if __name__ == "__main__":
+    sys.exit(_bazel_wrapper_main())
diff --git a/gbl/bazel.sh b/gbl/bazel.sh
new file mode 100755
index 0000000..59975bd
--- /dev/null
+++ b/gbl/bazel.sh
@@ -0,0 +1,22 @@
+#!/bin/bash -e
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Use host readlink. b/348003050
+MYPATH=$(readlink -f "$0")
+MYDIR=${MYPATH%/*}
+WORKSPACE_DIR=${MYDIR%bootable/libbootloader/gbl}
+WORKSPACE_DIR=${WORKSPACE_DIR%/}
+
+exec "$WORKSPACE_DIR"/prebuilts/build-tools/path/linux-x86/python3 "$MYDIR"/bazel.py "$@"
diff --git a/gbl/docs/efi_protocols.md b/gbl/docs/efi_protocols.md
index e73b648..36fb493 100644
--- a/gbl/docs/efi_protocols.md
+++ b/gbl/docs/efi_protocols.md
@@ -121,14 +121,36 @@ to specify their own custom fastboot triggers.
 Used for logging and debugging. Implementations must provide this protocol, but
 the functions may be no-ops.
 
+## Community Protocols
+
+Protocols defined by a community and used across the ecosystem, but not officially
+part of the UEFI specification. None of these protocols are required.
+
+### DtFixupProtocol
+
+* original [proposal](https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL)
+* [upstream](https://github.com/u-boot/u-boot/blob/master/include/efi_dt_fixup.h)
+* optional: allows FW to modify the final device tree
+
+This protocol allows the firmware (FW) to inspect the final device tree and apply
+necessary fixups.
+
+GBL will validate the applied changes and prevent booting if any of the security
+limitations (listed below) are violated. Any errors will be reported through the
+UEFI log.
+
+TODO (b/353272981): Add limitations
+
+This protocol was proposed by U-Boot and is currently used by the Kernel UEFI stub.
+
 ## GBL Custom Protocols
 
 These protocols are defined by GBL to provide specific functionality that is
 not available elsewhere.
 
-None of these custom protocols are required, with the intention that dev boards
-that support a typical set of UEFI protocols should be able to use GBL without
-any firmware modifications and still get some basic booting functionality.
+Majority of these custom protocols aren't required, with the intention that dev
+boards that support a typical set of UEFI protocols should be able to use GBL
+with a minimal firmware modifications and still get some basic booting functionality.
 
 However, without these protocols GBL will be missing key features such as
 USB fastboot and verified boot, so production targets and more full-featured dev
@@ -191,3 +213,13 @@ Used to provide buffers to load the images for verification and boot process.
 In addition this protocol provides a list of additional custom partitions to be
 verified before booting, for boards that want to verify data in addition to the
 standard boot partitions.
+
+### GblAvbProtocol
+
+* [`GBL_EFI_AVB_PROTOCOL`](./gbl_avb_protocol.md)
+* required for production devices: enables AVB-related firmware callbacks.
+
+This protocol delegates some of AVB-related logic to the firmware, including
+tasks such as verifying public keys, handling verification results, and
+managing the device’s secure state (e.g., ROT, lock state, rollback indexes,
+etc.).
diff --git a/gbl/docs/gbl_ab_boot_flow.md b/gbl/docs/gbl_ab_boot_flow.md
new file mode 100644
index 0000000..d4cc402
--- /dev/null
+++ b/gbl/docs/gbl_ab_boot_flow.md
@@ -0,0 +1,83 @@
+# A/B Boot Flow in GBL
+
+This document explains the A/B boot flows implemented by GBL and its
+interaction with EFI protocol
+[GBL_EFI_AB_SLOT_PROTOCOL](./gbl_efi_ab_slot_protocol.md).
+
+| **Status**  | Work in progress |
+|:------------|-----------------:|
+| **Created** |        2024-12-3 |
+
+## Android
+
+For Android, GBL supports the following two configurations of A/B boot:
+
+1. Slotless bootloader + A/B Android.
+1. A/B bootloader + A/B Android.
+
+At run time, GBL detects the configuration by checking the return value of
+[GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolgetcurrentslot).
+If the return is error `EFI_UNSUPPORTED`, GBL considers bootloader to be
+slotless and proceeds with the
+[Slotless bootloader + A/B Android](#slotless-bootloader--ab-android) boot
+flow. Otherwise it proceeds with the
+[A/B/ bootloader + A/B Android](#ab-bootloader--ab-android) boot flow.
+
+Note: The boot flow supports >2 slots. We use A/B simply as an example for
+illustration.
+
+### Slotless Bootloader + A/B Android
+
+#### Platform Setup
+
+This configuration corresponds to the following platform setup.
+
+![slotless-bootloader-ab-android](./resources/slotless-bl-ab-android.png)
+
+Device has a single slot GBL bootloader and A/B slot Android OS. Vendor
+firmware hands off to the single GBL slot which then make A/B decision for
+Android OS.
+
+#### Boot Flow
+
+The boot flow is summarized in the following diagram
+
+![slotless-bootloader-ab-android](./resources/slotless-bl-ab-android-flow.png)
+
+GBL will make exactly one call to
+[GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()](./gbl_efi_ab_slot_protocol.md)
+with boolean argument `mark_boot_attempt` set to true for getting the target
+slot to boot. When Vendor UEFI firmware sees `mark_boot_attempt=true`, it
+should update slot metadata such as derementing retry counter. If the slot is
+loaded and verified successfully, GBL proceeds to boot the slot. Otherwise it
+triggers a reboot.
+
+### A/B Bootloader + A/B Android
+
+#### Platform Setup
+
+This configuration corresponds to the following platform setup.
+
+![slotless-bootloader-ab-android](./resources/ab-bl-ab-android.png)
+
+Device has A/B GBL bootloader and A/B Android OS. Vendor firmware makes A/B
+slot decision and boots to the correponding GBL slot. GBL simply continues to
+boot the same Android OS slot.
+
+#### Boot Flow
+
+The boot flow is summarized in the following diagram.
+
+![slotless-bootloader-ab-android](./resources/ab-bl-ab-android-flow.png)
+
+GBL queries the current bootloader slot by calling
+[GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolgetcurrentslot).
+It also tracks whether
+[GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()](./gbl_efi_ab_slot_protocol.md#gbl_efi_ab_slot_protocolsetactiveslot)
+has been called to change the next active slot to a different slot, i.e. by
+`fastboot set_active`. If it has, GBL considers that the user intends to boot
+to a different slot than the current one and will trigger a reboot. If not, GBL
+proceeds to load and verify the same slot Android OS. If all operations are
+successful, GBL boots from it. Otherwise it triggers a reboot. Note that in
+this flow, vendor firmware is responsible for updating slot metadata such as
+decrementing retry counters before booting GBL.
diff --git a/gbl/docs/gbl_efi_ab_slot_protocol.md b/gbl/docs/gbl_efi_ab_slot_protocol.md
index 36cfdc6..8e4b8b3 100644
--- a/gbl/docs/gbl_efi_ab_slot_protocol.md
+++ b/gbl/docs/gbl_efi_ab_slot_protocol.md
@@ -4,6 +4,9 @@ This document describes the GBL AB Slot protocol.
 The protocol defines interfaces that can be used by EFI applications
 to query and manipulate boot slots.
 
+See this [document](./gbl_ab_boot_flow.md) For details on how GBL uses this
+protocol to implement A/B flows.
+
 | **Status**  | Work in progress |
 |:------------|-----------------:|
 | **Created** |        2024-9-17 |
@@ -16,24 +19,6 @@ This protocol provides interfaces for platform specific boot slot operations,
 such as determining the number of slots and the current target slot,
 changing the current target boot slot, marking boot attempts, and more.
 
-### Boot Slot Coherency Warning
-
-**Warning:** a boot slot may contain multiple artifacts, e.g. firmware images,
-kernel images, RAM disks, partitions, and so forth. It is **NOT** guaranteed
-that arbitrary artifacts from different slots interoperate correctly.
-For example, the bootloader in slot A may pass command line arguments that are
-invalid for the kernel in slot B. The **ONLY** safe way to boot a slot
-different from the active boot slot is to
-
-1. Change the slot by calling
-[`SetActiveSlot()`](#gbl_efi_ab_slot_protocolsetactiveslot).
-2. Reboot the device.
-   1. Optionally enter fastboot mode.
-3. Continue the boot process.
-
-It is the EFI application's responsibility to track whether `SetActiveSlot()`
-has been called and whether the current target slot and the active slot differ.
-
 ### GUID
 
 ```c
@@ -60,6 +45,7 @@ typedef struct GBL_EFI_AB_SLOT_PROTOCOL {
   GBL_EFI_AB_SLOT_LOAD_BOOT_DATA      LoadBootData;
   GBL_EFI_AB_SLOT_GET_SLOT_INFO       GetSlotInfo;
   GBL_EFI_AB_SLOT_GET_CURRENT_SLOT    GetCurrentSlot;
+  GBL_EFI_AB_SLOT_GET_ACTIVE_SLOT     GetActiveSlot;
   GBL_EFI_AB_SLOT_SET_ACTIVE_SLOT     SetActiveSlot;
   GBL_EFI_AB_SLOT_SET_SLOT_UNBOOTABLE SetSlotUnbootable;
   GBL_EFI_AB_SLOT_MARK_BOOT_ATTEMPT   MarkBootAttempt;
@@ -91,9 +77,14 @@ See [`GBL_EFI_AB_SLOT_PROTOCOL.GetSlotInfo()`](#gbl_efi_ab_slot_protocolgetsloti
 
 **GetCurrentSlot**
 
-Returns information about the current slot.
+Returns the slot information of the currently booted bootloader.
 See [`GBL_EFI_AB_SLOT_PROTOCOL.GetCurrentSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot).
 
+**GetNextSlot**
+
+Returns the slot information of the next slot decision.
+See [`GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot).
+
 **SetActiveSlot**
 
 Marks the specified slot as the active boot target.
@@ -104,11 +95,6 @@ See [`GBL_EFI_AB_SLOT_PROTOCOL.SetActiveSlot()`](#gbl_efi_ab_slot_protocolsetact
 Marks the specified slot as unbootable.
 See [`GBL_EFI_AB_SLOT_PROTOCOL.SetSlotUnbootable()`](#gbl_efi_ab_slot_protocolsetslotunbootable).
 
-**MarkBootAttempt**
-
-Marks the boot attempt and modifies tries remaining for the active slot.
-See [`GBL_EFI_AB_SLOT_PROTOCOL.MarkBootAttempt()`](#gbl_efi_ab_slot_protocolmarkbootattempt).
-
 **Reinitialize**
 
 Resets slot metadata to a default, initial state.
@@ -281,17 +267,7 @@ slots as part of debugging or logging.
 
 ### Summary
 
-Returns the slot information of the current slot.
-
-### Definitions
-
-The *current target* slot is defined as the highest priority bootable slot with
-ties broken by inverse lexicographical ordering of slot suffixes. E.g. if slot A
-and slot B are both bootable and have priority 15, slot A is the current slot.
-The *active* slot is the slot that owns the running bootloader firmware.
-Depending on whether `SetActiveSlot()` has been called, the current and active
-slots may be the same or they may differ. See the
-[Boot Slot Coherency Warning](#boot-slot-coherency-warning) for details.
+Returns the slot information of the currently booted bootloader.
 
 ### Prototype
 
@@ -319,18 +295,75 @@ for the structure definition.
 
 ### Description
 
+Returns the slot of the currently booted bootloader. If bootloader is not
+slotted, i.e. the device only has a single slot bootloader instead of A/B, the
+function returns `EFI_UNSUPPORTED`.
+
 This is identical to knowing the index of the current slot and calling
 `GetSlotInfo()` with that index.
 
-**Note:** the current slot is returned by value and not by index.
-This simplifies interactions for the caller, who is usually more interested in
-the suffix and associated metadata for a slot than its index.
+### Status Codes Returned
+
+| Return Code             | Semantics                          |
+|:------------------------|:---------------------------------- |
+| `EFI_SUCCESS`           | The call completed successfully.   |
+| `EFI_UNSUPPORTED`       | Bootloader is not slotted.         |
+| `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL`. |
+
+## `GBL_EFI_AB_SLOT_PROTOCOL.GetNextSlot()`
+
+### Summary
+
+Returns the slot information of the next slot decision.
+
+### Prototype
+
+```c
+typedef
+EFI_STATUS
+(EFIAPI * GBL_EFI_AB_SLOT_GET_NEXT_SLOT)(
+    IN GBL_EFI_AB_SLOT_PROTOCOL* This,
+    IN BOOL                      MarkBootAttempt,
+    OUT GBL_EFI_SLOT_INFO*       Info,
+);
+```
+
+### Parameters
+
+*This*
+
+A pointer to the [`GBL_EFI_AB_SLOT_PROTOCOL`](#protcol-interface-structure)
+instance.
+
+*MarkBootAttempt*
+
+The parameter is set to true if caller attempts to load, verify and boot the
+returned slot. If the caller only wants to query the next slot decision and
+does not intend to cause any state change, it is set to false.
+
+*Info*
+
+On exit contains the metadata for the next slot.
+See the definition for [`GBL_EFI_SLOT_INFO`](#related-definitions-1)
+for the structure definition.
+
+### Description
+
+The function returns the highest priority bootable slot according to current
+slot state.
+
+If parameter `MarkBootAttempt` is true, implementation should updates internal
+metadata for the slot such as decrementing retry counters if slot has not been
+successful.
+
+If there are no bootable slots, the function **MUST** returns `EFI_NOT_FOUND`.
 
 ### Status Codes Returned
 
 | Return Code             | Semantics                                                                                                     |
 |:------------------------|:--------------------------------------------------------------------------------------------------------------|
 | `EFI_SUCCESS`           | The call completed successfully.                                                                              |
+| `EFI_NOT_FOUND`         | There are no bootable slots for the next decision.                                                            |
 | `EFI_INVALID_PARAMETER` | One of *This* or *Info* is `NULL` or improperly aligned.                                                      |
 | `EFI_DEVICE_ERROR`      | There was an error reading metadata from persistent storage.                                                  |
 | `EFI_VOLUME_CORRUPTED`  | The metadata loaded is invalid or corrupt. The caller should call `Reinitialize` before taking other actions. |
@@ -339,9 +372,7 @@ the suffix and associated metadata for a slot than its index.
 
 ### Summary
 
-Sets the active slot by index, reinitializes its tries remaining and priority,
-and clears any unbootable reasons.
-Sets the priority for all other slots to be lower than the new active slot's.
+Sets the active slot by index. Makes it the highest priority bootable slot.
 
 ### Prototype
 
@@ -376,12 +407,6 @@ All these changes **MUST** be visible in subsequent calls to `GetSlotInfo()`.
 Depending on device policy, e.g. lock state, changing the target boot slot
 explicitly may be prohibited.
 
-**Warning:** See the description for
-[`GetCurrentSlot()`](#gbl_efi_ab_slot_protocolgetcurrentslot) for the
-distinction between the *current target* boot slot and the *active* boot slot,
-and see the [Boot Slot Coherency Warning](#boot-slot-coherency-warning) for
-details about safely changing the *current target* slot.
-
 ### Status Codes Returned
 
 | Return Code             | Semantics                                                                                                     |
@@ -532,8 +557,7 @@ and have the following fields set to `0`:
 * *UnbootableReason*
 * *Successful*
 
-This may change the current target boot slot.
-See the [Boot Slot Coherency Warning](#boot-slot-coherency-warning) for details.
+This may change the next target boot slot.
 
 ### Status Codes Returned
 
@@ -577,6 +601,7 @@ typedef enum _GBL_EFI_AB_SLOT_BOOT_REASON {
     WARM = 58,
     SHUTDOWN = 59,
     REBOOT = 18,
+    FASTBOOTD = 196,
 } GBL_EFI_AB_SLOT_BOOT_REASON;
 ```
 
diff --git a/gbl/docs/gbl_efi_avb_protocol.md b/gbl/docs/gbl_efi_avb_protocol.md
new file mode 100644
index 0000000..9d73de9
--- /dev/null
+++ b/gbl/docs/gbl_efi_avb_protocol.md
@@ -0,0 +1,97 @@
+# GBL AVB EFI Protocol
+
+This protocol delegates some of AVB-related logic to the firmware, including
+tasks such as verifying public keys, handling verification results, and
+managing the device’s secure state (e.g., ROT, lock state, rollback indexes,
+etc.).
+
+## GBL_EFI_AVB_PROTOCOL
+
+### GUID
+```c
+// {6bc66b9a-d5c9-4c02-9da9-50af198d912c}
+#define GBL_EFI_AVB_PROTOCOL_UUID                    \
+  {                                                  \
+    0x6bc66b9a, 0xd5c9, 0x4c02, {                    \
+      0x9d, 0xa9, 0x50, 0xaf, 0x19, 0x8d, 0x91, 0x2c \
+    }                                                \
+  }
+```
+
+### Revision Number
+
+Note: revision 0 means the protocol is not yet stable and may change in
+backwards-incompatible ways.
+
+```c
+#define GBL_EFI_AVB_PROTOCOL_REVISION 0x00010000
+```
+
+### Protocol Interface Structure
+
+```c
+typedef struct _GBL_EFI_AVB_PROTOCOL {
+  UINT64 Revision;
+  GBL_EFI_AVB_VALIDATE_VBMETA_PUBLIC_KEY ValidateVbmetaPublicKey;
+  GBL_EFI_AVB_READ_IS_DEVICE_UNLOCKED ReadIsDeviceUnlocked;
+  GBL_EFI_AVB_READ_ROLLBACK_INDEX ReadRollbackIndex;
+  GBL_EFI_AVB_WRITE_ROLLBACK_INDEX WriteRollbackIndex;
+  GBL_EFI_AVB_READ_PERSISTENT_VALUE ReadPersistentValue;
+  GBL_EFI_AVB_WRITE_PERSISTENT_VALUE WritePersistentValue;
+  GBL_EFI_AVB_HANDLE_VERIFICATION_RESULT HandleVerificationResult;
+} GBL_EFI_AVB_PROTOCOL;
+```
+
+### Parameters
+
+#### Revision
+The revision to which the `GBL_EFI_AVB_PROTOCOL` adheres. All
+future revisions must be backwards compatible. If a future version is not
+backwards compatible, a different GUID must be used.
+
+#### ValidateVbmetaPublicKey
+Validate proper public key is used to sign HLOS artifacts.
+[`ValidateVbmetaPublicKey()`](#ValidateVbmetaPublicKey).
+
+#### ReadIsDeviceUnlocked
+Gets whether the device is unlocked.
+[`ReadIsDeviceUnlocked()`](#ReadIsDeviceUnlocked).
+
+#### ReadRollbackIndex
+Gets the rollback index corresponding to the location given by `index_location`.
+[`ReadRollbackIndex()`](#ReadRollbackIndex).
+
+#### WriteRollbackIndex
+Sets the rollback index corresponding to the location given by `index_location` to `rollback_index`.
+[`WriteRollbackIndex()`](#WriteRollbackIndex).
+
+#### ReadPersistentValue
+Gets the persistent value for the corresponding `name`.
+[`ReadPersistentValue()`](#ReadPersistentValue).
+
+#### WritePersistentValue
+Sets or erases the persistent value for the corresponding `name`.
+[`WritePersistentValue()`](#WritePersistentValue).
+
+#### HandleVerificationResult
+Handle AVB verification result (i.e update ROT, set device state, display UI
+warnings/errors, handle anti-tampering, etc).
+[`HandleVerificationResult()`](#HandleVerificationResult).
+
+TODO(b/337846185): Cover more AVB functionality such as rollback indexes, open dice, etc.
+TODO(b/337846185): Detailed (per-method) doc once protocol is finalized.
+
+### Status Codes Returned
+
+The following EFI error types are used to communicate result to GBL and libavb in particular:
+
+|                                |                                                                                                                                                         |
+| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `EFI_SUCCESS`                  | Requested operation was successful `libavb::AvbIOResult::AVB_IO_RESULT_OK`                                                                              |
+| `EFI_STATUS_OUT_OF_RESOURCES`  | Unable to allocate memory `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_OOM`                                                                                |
+| `EFI_STATUS_DEVICE_ERROR`      | Underlying hardware (disk or other subsystem) encountered an I/O error `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_IO`                                    |
+| `EFI_STATUS_NOT_FOUND`         | Named persistent value does not exist `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_NO_SUCH_VALUE`                                                          |
+| `EFI_STATUS_END_OF_FILE`       | Range of bytes requested to be read or written is outside the range of the partition `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION` |
+| `EFI_STATUS_INVALID_PARAMETER` | Named persistent value size is not supported or does not match the expected size `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_INVALID_VALUE_SIZE`          |
+| `EFI_STATUS_BUFFER_TOO_SMALL`  | Buffer is too small for the requested operation `libavb::AvbIOResult::AVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE`                                           |
+| `EFI_STATUS_UNSUPPORTED`       | Operation isn't implemented / supported                                                                                                                 |
diff --git a/gbl/docs/gbl_efi_fastboot_protocol.md b/gbl/docs/gbl_efi_fastboot_protocol.md
index 3d21040..c0c94a5 100644
--- a/gbl/docs/gbl_efi_fastboot_protocol.md
+++ b/gbl/docs/gbl_efi_fastboot_protocol.md
@@ -43,8 +43,7 @@ typedef struct _GBL_EFI_FASTBOOT_PROTOCOL {
   UINT32                                        Revision
   CHAR8                                         SerialNumber[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
   GBL_EFI_FASTBOOT_GET_VAR                      GetVar;
-  GBL_EFI_FASTBOOT_START_VAR_ITERATOR           StartVarIterator;
-  GBL_EFI_FASTBOOT_GET_NEXT_VAR_ARGS            GetNextVarArgs;
+  GBL_EFI_FASTBOOT_GET_VAR_ALL                  GetVarAll;
   GBL_EFI_FASTBOOT_RUN_OEM_FUNCTION             RunOemFunction;
   GBL_EFI_FASTBOOT_GET_POLICY                   GetPolicy;
   GBL_EFI_FASTBOOT_SET_LOCK                     SetLock;
@@ -73,16 +72,10 @@ If the device serial number is longer than 32 bytes, it must be truncated.
 Gets the value for the given fastboot variable.
 See [`GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`](#gbl_efi_fastboot_protocolgetvar).
 
-**StartVarIterator**
+**GetVarAll**
 
-Creates an iterator at the beginning of all valid fastboot variables
-tracked by the protocol driver.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`](#gbl_efi_fastboot_protocolstartvariterator).
-
-**GetNextVarArgs**
-
-Gets the next variable and sub-arguments in the iterator.
-See [`GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs).
+Iterates all combinations of arguments and values for all fastboot variables.
+See [`GBL_EFI_FASTBOOT_PROTOCOL.GetVarAll()`](#gbl_efi_fastboot_protocolgetvarall).
 
 **RunOemFunction**
 
@@ -129,62 +122,24 @@ typedef
 EFI_STATUS
 (EFIAPI * GBL_EFI_FASTBOOT_GET_VAR)(
     IN GBL_EFI_FASTBOOT_PROTOCOL*         This,
-    IN GBL_EFI_FASTBOOT_ARG*              Args,
+    IN CONST CHAR8* CONST*                Args,
     IN UINTN                              NumArgs,
     OUT CHAR8*                            Buf,
     IN OUT UINTN*                         BufSize,
-    OPTIONAL IN GBL_EFI_FASTBOOT_TOKEN    Hint,
 );
 ```
 
-### Related Definitions
-
-```c
-typedef struct _GBL_EFI_FASTBOOT_ARG {
-    // Pointer to a Null-terminated, UTF-8 encoded string.
-    const CHAR8* StrUtf8;
-    // Length of StrUtf8 excluding the Null terminator.
-    UINTN        Length;
-} GBL_EFI_FASTBOOT_ARG;
-
-typedef VOID* GBL_EFI_FASTBOOT_TOKEN;
-```
-
-### String Encoding
-
-All strings provided to protocol methods, returned from protocol methods,
-or defined as protocol fields are UTF-8 encoded and Null terminated.
-
-Additionally, with the exception of `GBL_EFI_FASTBOOT_PROTOCOL.SerialNumber`,
-all strings are either passed as pointer/length paired parameters or
-are described by a `GBL_EFI_FASTBOOT_ARG`, which has pointer and length fields.
-No length ever includes any Null-terminator characters.
-
-The protocol requires both explicit length and Null-termination because GBL is
-written in Rust. The Rust primitive `str` type is defined as a pointer and
-length and is **NOT** Null-terminated.
-Requiring protocol strings to provide an explicit length facilitates Rust
-wrapping returned strings more easily.
-
-Additionally, in-out length fields allow protocol methods to return
-`EFI_BUFFER_TOO_SMALL` and provide the required buffer size to the caller
-if necessary.
-
-Null-terminators are required when passing strings to protocol methods because
-Null-terminated strings are the standard in C, and protocol implementations
-written in C must be supported.
-
 ### Parameters
 
 *This*
 
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure)
+instance.
 
 *Args*
 
-A pointer to an array of string fragments that describe a fastboot variable.
-The caller splits an input string delimited with `:` to generate the fragments
-and replaces the `:` characters with `\0`.
+A pointer to an array of NULL-terminated strings that contains the name of the
+variable followed by additional arguments.
 
 *NumArgs*
 
@@ -201,76 +156,49 @@ On entry, the size in bytes of *Buf*.
 On exit, the size in bytes of the UTF-8 encoded string describing the value,
 excluding any Null-terminator.
 
-*Hint*
-
-If not `NULL` provides the driver with a user-opaque hint
-in order to optimize variable lookup.
-The only way to provide a valid hint is to use the tokens generated by
-[`GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`](#gbl_efi_fastboot_protocolstartvariterator) and
-[`GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs).
-
 ### Description
 
-`GetVar()` queries internal data structures and devices
-to determine the value of the given variable.
-Variables may have zero or more subfields with arbitrarily many variants per subfield.
-These subfields are parsed by the caller and passed to `GetVar()`
-as an array of UTF-8 encoded string slices.
-The string slices are defined by a pointer and length structure,
-and each string slice is also guaranteed to have a Null terminator.
-See [Related Definitions](#related-definitions-1) for the definition of `GBL_EFI_FASTBOOT_ARG`.
-
-The *Hint* parameter is an optional token generated
-as part of iterating over the fastboot variables.
-The method implementation can use a non-`NULL` *Hint*
-to bypass a more expensive variable lookup.
+`GetVar()` queries internal data structures and drivers to determine the value
+of the given variable. Variables may have zero or more additional arguments.
+These arguments are parsed by the caller and passed to `GetVar()` as an array
+of NULL-terminated UTF-8 encoded string.
 
 An example client interaction:
 ```bash
-# A variable with no subfields
+# A variable with no argument.
 $ fastboot getvar max-download-size
 OKAY0x20000000
 
-# A variable with two subfields
+# A variable with two arguments.
 $ fastboot getvar block-device:0:total-blocks
 OKAY0x800000000000
 ```
 
-If *Hint* is `NULL`, invalid, or wrong, the lookup should proceed
-as if the hint was not provided at all.
-
-**Note:** even if the *Hint* parameter is *valid*,
-i.e. it correctly points to a fastboot variable entry,
-it may disagree with the variable description in *Args*.
-The method implementation should check that the variable entry
-described by *Hint* matches with *Args*.
-If there is a discrepancy, *Args* should provide the authoritative lookup parameters
-and *Hint* should be ignored.
-
 ### Status Codes Returned
 
 | Return Code             | Semantics                                                                                                                                                                |
 |:------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | `EFI_SUCCESS`           | The variable was found and its value successfully serialized.                                                                                                            |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *Buf*, or *BufSize* is `NULL` or improperly aligned.                                                                                              |
+| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *Buf*, or *BufSize* is `NULL`                                                                                                                     |
 | `EFI_NOT_FOUND`         | The first element of *Args* does not contain a known variable.                                                                                                           |
 | `EFI_UNSUPPORTED`       | The contents of *Args* do not contain a known variable with valid aruments. Any of the subarguments may be unknown, or too many or too few subarguments may be provided. |
 | `EFI_BUFFER_TOO_SMALL`  | *Buf* is too small to store the serialized variable string. The value of *BufSize* is modified to contain the minimum necessary buffer size.                             |
 
-## `GBL_EFI_FASTBOOT_PROTOCOL.StartVarIterator()`
+## `GBL_EFI_FASTBOOT_PROTOCOL.GetVarAll()`
 
 ### Summary
 
-Creates an iterator at the beginning of the fastboot variables.
+Iterates all combinations of variables and values.
 
 ### Prototype
 
 ```c
 typedef
 EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_START_VAR_ITERATOR)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL*  This,
-    OUT GBL_EFI_FASTBOOT_TOKEN*    Token,
+(EFIAPI * GBL_EFI_FASTBOOT_GET_VAR_ALL)(
+    IN GBL_EFI_FASTBOOT_PROTOCOL*         This,
+    IN VOID*                              Context
+    IN GBL_EFI_GET_VAR_ALL_CALLBACK       GetVarAllCallback,
 );
 ```
 
@@ -278,128 +206,60 @@ EFI_STATUS
 
 *This*
 
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
-
-*Token*
-
-On exit contains a caller-opaque token describing an iterator
-at the beginning of the fastboot variables defined by the driver.
-
-### Description
-`StartVarIterator()` is used in conjunction with
-[`GetNextVarArgs()`](#gbl_efi_fastboot_protocolgetnextvarargs) and
-[`GetVar()`](#gbl_efi_fastboot_protocolgetvar) to
-iterate over all variants of all driver defined fastboot variables and retrieve their values.
-This faculty is used when a client requests the special `all` variable as in the following example.
-The value of *Token* returned by `StartVarIterator()` **MUST** be a valid value for *Hint*
-when passed to `GetVar()` along with the *Args* array returned by the first call to
-`GetNextVarArgs()`.
-
-Example client running `getvar all`:
-```bash
-$ fastboot getvar all
-(bootloader) max-download-size: 0x20000000
-(bootloader) version-bootloader: 1.0
-(bootloader) max-fetch-size: 0xffffffffffffffff
-(bootloader) partition-size:vbmeta:0: 0x8000000
-(bootloader) partition-type:vbmeta:0: raw
-(bootloader) partition-size:misc:0: 0x100000
-(bootloader) partition-type:misc:0: raw
-...
-```
-
-**Note:** `StartVarIterator()` **SHOULD** be idempotent,
-i.e. the same token should be returned each time.
-This makes comparing iterator values more stable,
-which is helpful for detecting and exiting loops due to bugs.
-
-**Note:** between the first call to `StartVarIterator()` and the final call to `GetNextVarArgs()`,
-the iterator **MUST** remain valid.
-The GBL is expected to invoke the following protocol methods during variable iteration;
-these methods **MUST NOT** invalidate the iterator.
-
-* `GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`
-* `GBL_EFI_FASTBOOT_PROTOCOL.GetVar()`
-* `GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbReceive()`
-* `GBL_EFI_FASTBOOT_USB_PROTOCOL.FastbootUsbSend()`
-* `EFI_SIMPLE_NETWORK_PROTOCOL.Receive()`
-* `EFI_SIMPLE_NETWORK_PROTOCOL.Transmit()`
-* `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.OutputString()`
+A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure)
+instance.
 
-### Status Codes Returned
-
-| Return Code             | Semantics                                                                          |
-|:------------------------|:-----------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The value of *Token* has been updated to reference the starting iterator position. |
-| `EFI_INVALID_PARAMETER` | One of *This* or *Token* is `NULL` or improperly aligned.                          |
+*Context*
 
-## `GBL_EFI_FASTBOOT_PROTOCOL.GetNextVarArgs()`
+A pointer to the context data for `GetVarAllCallback`.
 
-### Summary
+*GetVarAllCallback*
 
-Gets the fastboot variable arguments at the current iterator position and advances the iterator.
+A pointer to a function of type `GBL_EFI_GET_VAR_ALL_CALLBACK`. It receives as
+parameter the `Context` pointer passed to this function, an array of
+NULL-terminated UTF8 strings containing variable name and additional arguments,
+the array length, and a NULL-terminated string representing the value.
 
-### Prototype
+### Related Definitions
 
 ```c
 typedef
-EFI_STATUS
-(EFIAPI * GBL_EFI_FASTBOOT_GET_NEXT_VAR_ARGS)(
-    IN GBL_EFI_FASTBOOT_PROTOCOL*     This,
-    OUT GBL_EFI_FASTBOOT_ARG*         Args,
-    IN OUT UINTN*                     NumArgs,
-    IN OUT GBL_EFI_FASTBOOT_TOKEN*    Token,
+VOID (*GBL_EFI_GET_VAR_ALL_CALLBACK) (
+    IN VOID*                              Context
+    IN CONST CHAR8* CONST*                Args,
+    IN UINTN                              NumArgs,
+    IN CONST CHAR8*                       Value,
 );
 ```
+*Context*
 
-### Parameters
-
-*This*
-
-A pointer to the [`GBL_EFI_FASTBOOT_PROTOCOL`](#protocol-interface-structure) instance.
+The pointer to the context passed to `GetVarAll()`.
 
 *Args*
 
-A pointer to an uninitialized, caller-owned array of `GBL_EFI_FASTBOOT_ARG`.
-On return defines the fastboot variable and subvariable variant
-at the position indicated by the input value of *Token*.
+A pointer to an array of NULL-terminated strings that contains the name of the
+variable followed by additional arguments.
 
 *NumArgs*
 
-On entry contains the maximum length of *Args*.
-On exit contains the length of *Args* in elements defining the current variable.
+The number of elements in the *Args* array.
 
-*Token*
+*Value*
 
-On entry contains the current iterator position.
-On exit contains the next iterator position.
+A NULL-terminated string representing the value.
 
 ### Description
 
-`GetNextVarArgs()` is used in conjunction with `GetVar()` and `StartVarIterator()`
-to iterate over all fastboot variables and corresponding values provided by the protocol driver.
-This functionality is used when handling the special `all` fastboot variable.
-
-The position of the iterator is tracked by *Token*.
-All values of *Token* are opaque handles used by the protocol driver.
-Users **MUST NOT** assume that they are pointers, indices, references,
-or have any user-accessible semantics of any kind.
-
-When the iterator has reached the final fastboot variable entry,
-the *next* call to `GetNextVarArgs()` **MUST** do **ALL** of the following:
-
-* Return `EFI_SUCCESS`
-* Set *NumArgs* to `0`
-* Leave the value of *Token* unchanged
+`GetVarAll()` iterates all combinations of arguments and values for all fastboot
+variables. For each combination, the function invokes the caller provided
+callback `GetVarAllCallback()` and passes the context, arguments and value.
 
 ### Status Codes Returned
 
-| Return Code             | Semantics                                                                                                                                        |
-|:------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|
-| `EFI_SUCCESS`           | The call completed successfully.                                                                                                                 |
-| `EFI_INVALID_PARAMETER` | One of *This*, *Args*, *NumArgs*, or *Token* is `NULL` or improperly aligned.                                                                    |
-| `EFI_INVALID_PARAMETER` | The input value of *Token* is nonsensical.                                                                                                       |
-| `EFI_BUFFER_TOO_SMALL`  | The entry value of *NumArgs* is too small to store the variable arguments. Its value is updated to contain the minimum necessary size of *Args*. |
+| Return Code             | Semantics                                       |
+|:------------------------|:------------------------------------------------|
+| `EFI_SUCCESS`           | Operation is successful.                        |
+| `EFI_INVALID_PARAMETER` | One of *This* or *GetVarAllCallback* is `NULL`. |
 
 ## `GBL_EFI_FASTBOOT_PROTOCOL.RunOemFunction()`
 
@@ -457,12 +317,11 @@ excluding any Null-terminator.
 
 ### Description
 
-`RunOemFunction()` runs a vendor defined Oem function.
-These functions can take arbitrary arguments or subcommands;
-the caller does no parsing or verification.
-All parsing and verification is the responsibility of the method implementation.
-Oem functions can display power or battery information, print or iterate over UEFI variables,
-or conduct arbitrary other operations.
+`RunOemFunction()` runs a vendor defined Oem function. These functions can take
+arbitrary arguments or subcommands. The caller does no parsing or verification.
+All parsing and verification is the responsibility of the method
+implementation. Oem functions can display power or battery information, print
+or iterate over UEFI variables, or conduct arbitrary other operations.
 
 ### Status Codes Returned
 
diff --git a/gbl/docs/gbl_fastboot.md b/gbl/docs/gbl_fastboot.md
index 4407248..cfe4924 100644
--- a/gbl/docs/gbl_fastboot.md
+++ b/gbl/docs/gbl_fastboot.md
@@ -16,17 +16,17 @@ the needed protocol is available.
 Fastboot commands such as `fastboot flash`, `fastboot fetch` and
 `fastboot getvar partition-size` operate on partitions and requires a partition
 name argument. See this [doc](./partitions.md) for how GBL defines and handles
-partitions on storage devices. GBL fastboot additionaly supports accessing
-sub ranges of partitions and disambiguating betweeen same name partitions on
+partitions on storage devices. GBL fastboot additionaly supports accessing sub
+ranges of partitions and disambiguating betweeen same name partitions on
 multiple storage devices (i.e. in the presence of external or removable boot
-storage). The following summarizes the supported semantics for partition
-name argument in fastboot.
+storage). The following summarizes the supported syntaxes for partition name
+argument in fastboot.
 
 * Partition
   ```sh
-  <part>[:<storage_id>]
-  <part>:[<storage_id>][:<offset>]
-  <part>:[<storage_id>]:[<offset>][:<size>]
+  <part>[/<storage_id>]
+  <part>/[<storage_id>][/<offset>]
+  <part>/[<storage_id>]/[<offset>][/<size>]
   ```
 
   This specifies range `[offset, offset+size)` in partition `part` on the
@@ -43,26 +43,26 @@ name argument in fastboot.
   defaults to the rest of the partition after `offset` if not given.
 
   Examples:
-  * `fastboot flash boot_a` -- If a default storage ID is set via
-    `fastboot oem gbl-set-default-block <default ID>`, flashes in the entire
-    range of partition `boot_a` on storage device `<default ID>`. If not,
-    checks that `boot_a` can match to a unique partition among all storage
-    devices and flashes to it.
-  * `fastboot flash boot_a:0x0` or `boot_a:0` -- Flashes in the entire range of
+  * `fastboot flash boot_a` -- If there is only one storage or a default
+    storage ID is set via `fastboot oem gbl-set-default-block <default ID>`,
+    flashes in the entire range of the storage. If not, checks that `boot_a`
+    can match to a unique partition among all storage devices and flashes to
+    it.
+  * `fastboot flash boot_a/0x0` or `boot_a/0` -- Flashes in the entire range of
     partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a:0:200` -- Flashes only in range `[512, end)` of
+  * `fastboot flash boot_a/0/200` -- Flashes only in range `[512, end)` of
     partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a:0:200:200` -- Flashes only in range `[512, 1024)` of
+  * `fastboot flash boot_a/0/200/200` -- Flashes only in range `[512, 1024)` of
     partition "boot_a" on storage device 0.
-  * `fastboot flash boot_a:::` -- Same as `"fastboot flash boot_a"`.
-  * `fastboot flash boot_a::200:200` -- Same as `"fastboot flash boot_a:::"`,
+  * `fastboot flash boot_a///` -- Same as `"fastboot flash boot_a"`.
+  * `fastboot flash boot_a//200/200` -- Same as `"fastboot flash boot_a///"`,
     except that it only flashes in range `[512, 1024)`
 
 * Raw storage devices by ID
   ```
-  :[<storage_id>]
-  :[<storage_id>][:<offset>]
-  :[<storage_id>][:<offset>][:<size>]
+  /[<storage_id>]
+  /[<storage_id>][/<offset>]
+  /[<storage_id>][/<offset>][/<size>]
   ```
 
   This is similar to the case of partition except that `part` is an empty
@@ -76,19 +76,72 @@ name argument in fastboot.
   a raw storage partition or GPT device.
 
   Examples:
-  * `fastboot flash :` -- If a default storage ID is set via
-    `fastboot oem gbl-set-default-block <default ID>`, flashes in the entire
-    range of storage device `<default ID>`.
-  * `fastboot flash :0x0` or `:0` -- Flashes in the entire range of storage
+  * `fastboot flash /` -- If there is only one storage or a default storage ID
+    is set via `fastboot oem gbl-set-default-block <default ID>`, flashes in
+    the entire range of the storage.
+  * `fastboot flash /0x0` or `/0` -- Flashes in the entire range of storage
     device 0.
-  * `fastboot flash :0:200` -- Flashes only in range `[512, end)` of storage
+  * `fastboot flash /0/200` -- Flashes only in range `[512, end)` of storage
     device 0.
-  * `fastboot flash :0:200:200` -- Flashes only in range `[512, 1024)` of
+  * `fastboot flash /0/200/200` -- Flashes only in range `[512, 1024)` of
     storage device 0.
-  * `fastboot flash :::` -- Same as `"fastboot flash :"`.
-  * `fastboot flash ::200:200` -- Same as `"fastboot flash :::"`, except that
+  * `fastboot flash ///` -- Same as `"fastboot flash /"`.
+  * `fastboot flash //200/200` -- Same as `"fastboot flash ///"`, except that
     it only flashes in range `[512, 1024)`
 
+Note: AOSP fastboot client tool introduces a special flash command syntax
+`fastboot flash vendor_boot_a:<part_size>` for performing vendor ramdisk
+repacking and flashing. This however, does not work with GBL's `'/'` syntax
+discussed above, i.e. `fastboot flash vendor_boot_a/0:<part_size>` will not
+trigger the repack and flash flow for the vendor_boot_a partition on storage 0
+as might be expected. Instead, in this case, user should run
+`fastboot oem gbl-set-default-block 0` to set the default block to 0 first and
+then use `fastboot flash vendor_boot_a:<part size>` normally.
+
+### Updating GPT Partition Table
+
+GBL supports the following syntaxes for updating GPT partition table on a
+storage device:
+
+```
+fastboot flash gpt <path to MBR+primary GPT blob file>
+fastboot flash gpt/<storage_id> <path to MBR+primary GPT blob file>
+fastboot flash gpt/[<storage_id>][/resize] <path to MBR+primary GPT blob file>
+```
+
+User must provide an image file that contains a MBR block and the primary GPT
+header and entries. The above command will verify the given GPT and update it
+to the specified storage device. If the `resize` option is given, GBL will
+adjust the ending block of the last partition entry to cover the rest of the
+storage. This is useful for sharing one single GPT blob file for different
+devices with varying size of storage.
+
+Examples:
+  * `fastboot flash gpt` -- If there is only one storage or a default storage
+    ID is set via `fastboot oem gbl-set-default-block <default ID>`, updates
+    the GPT of that storage.
+  * `fastboot flash gpt//resize` -- Same as `fastboot flash gpt` but also
+    performs resizing.
+  * `fastboot flash gpt/0` -- Update GPT to storage device 0.
+  * `fastboot flash gpt/0/resize` -- Same as `fastboot flash gpt/0` but also
+    performs resizing.
+
+To erase existing GPT partition table on a storage device, use:
+
+```
+fastboot erase gpt
+fastboot erase gpt/<storage_id>
+```
+
+Note: The above only erases GPT partition table. Partition content remains
+unchanged.
+
+Examples:
+  * `fastboot erase gpt` -- If there is only one storage or a default storage
+    ID is set via `fastboot oem gbl-set-default-block <default ID>`, erase
+    the GPT of that storage.
+  * `fastboot flash gpt/0` -- Erase GPT to storage device 0.
+
 ## Non-blocking `fastboot flash`.
 
 If the UEFI firmware supports `EFI_BLOCK_IO2_PROTOCOL` for the storage devices,
@@ -101,13 +154,13 @@ between downloading and flashing when the host is flashing multiple images.
 Example:
 
 ```
-fastboot oem gbl-enable-async-block-io
+fastboot oem gbl-enable-async-task
 fastboot flash boot_a <image>
 fastboot flash boot_b <image>
 fastboot flash vendor_boot_a <image>
 ...
 fastboot oem gbl-sync-blocks
-fastboot oem gbl-disable-async-block-io
+fastboot oem gbl-disable-async-task
 ```
 
 If a storage device is busy processing a previous flash when a new image is
diff --git a/gbl/docs/gbl_os_configuration_protocol.md b/gbl/docs/gbl_os_configuration_protocol.md
index d0593aa..2cd4935 100644
--- a/gbl/docs/gbl_os_configuration_protocol.md
+++ b/gbl/docs/gbl_os_configuration_protocol.md
@@ -7,16 +7,16 @@ apply runtime fixups to data passed into the OS.
 
 ### Summary
 
-This protocol provides a mechanism for the EFI firmware to modify OS
+This protocol provides a mechanism for the EFI firmware to build and update OS
 configuration data:
 
-* kernel commandline
-* bootconfig
-* devicetree
+* device tree (select components to build the final one)
+* kernel commandline (append fixups)
+* bootconfig (append fixups)
 
 GBL will load and verify the base data from disk, and then call these protocol
-functions to give the firmware a chance to adjust the data as needed for the
-particular device.
+functions to give the firmware a chance to construct and adjust the data as needed
+for the particular device. Device tree fixup is handled by `EFI_DT_FIXUP` protocol.
 
 If no runtime modifications are necessary, this protocol may be left
 unimplemented.
@@ -45,12 +45,12 @@ backwards-incompatible ways.
 ### Protocol Interface Structure
 
 ```c
-typedef struct GBL_EFI_OS_CONFIGURATION_PROTOCOL {
-  UINT64                              Revision;
-  GBL_FIXUP_ASCII_DATA                FixupKernelCommandline;
-  GBL_FIXUP_ASCII_DATA                FixupBootconfig;
-  GBL_FIXUP_DEVICETREE                FixupDevicetree;
-  GBL_FIXUP_ZBI                       FixupZbi;
+typedef struct _GBL_EFI_OS_CONFIGURATION_PROTOCOL {
+  UINT64                            Revision;
+  GBL_EFI_FIXUP_KERNEL_COMMAND_LINE FixupKernelCommandline;
+  GBL_EFI_FIXUP_BOOTCONFIG          FixupBootConfig;
+  GBL_EFI_SELECT_DEVICE_TREES       SelectDeviceTrees;
+  GBL_EFI_FIXUP_ZBI                 FixupZbi;
 } GBL_EFI_OS_CONFIGURATION_PROTOCOL;
 ```
 
@@ -65,11 +65,12 @@ backwards compatible, a different GUID must be used.
 Applies kernel commandline fixups. See
 [`FixupKernelCommandline()`](#FixupKernelCommandline).
 
-#### FixupBootconfig
-Applies bootconfig fixups. See [`FixupBootconfig()`](#FixupBootconfig).
+#### FixupBootConfig
+Applies bootconfig fixups. See [`FixupBootConfig()`](#FixupBootConfig).
 
-#### FixupDevicetree
-Applies devicetree fixups. See [`FixupDevicetree()`](#FixupDevicetree).
+#### SelectDeviceTrees
+Select components such as base device tree, overlays to build the final device tree.
+See [`SelectDeviceTrees()`](#SelectDeviceTrees).
 
 #### FixupZbi
 Applies ZBI fixups (Fuchsia kernels only). See [`FixupZbi()`](#FixupZbi).
@@ -78,61 +79,67 @@ Applies ZBI fixups (Fuchsia kernels only). See [`FixupZbi()`](#FixupZbi).
 
 ### Summary
 
-Applies runtime fixups to the kernel command line.
+Provides runtime fixups to the kernel command line.
 
 ### Prototype
 
 ```c
-typedef EFI_STATUS (EFIAPI *GBL_FIXUP_ASCII_DATA)(
-  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL     *This,
-  IN OUT CHAR8                             *Data,
-  IN OUT UINTN                             *BufferSize
-);
+typedef EFI_STATUS (EFIAPI *GBL_EFI_FIXUP_KERNEL_COMMAND_LINE)(
+  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
+  IN CONST CHAR8                       *CommandLine,
+  OUT CHAR8                            *Fixup,
+  IN OUT UINTN                         *FixupBufferSize
+  );
 ```
 
 ### Parameters
 
+Ownership of all the parameters is loaned only for the duration of the function call, and
+must not be retained by the protocol after returning.
+
 #### This
 A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
 
-#### Data
-A pointer to the ASCII nul-terminated data.
+#### CommandLine [in]
+A pointer to the ASCII nul-terminated command line built by GBL.
 
-The protocol can modify this data directly, with the following restrictions:
-* on return, the data must be valid ASCII encoding with nul termination
-* the data and termination byte must never exceed the provided `BufferSize`
-* no libavb arguments may be added, deleted, or modified (see Security below)
+#### Fixup [out]
+Pointer to a pre-allocated buffer to store the generated command line fixup.
+GBL verifies and appends provided data into the final command line. FW may
+leave this unchanged if no fixup is required.
 
-Ownership of this data is loaned only for the duration of the function call, and
-must not be retained by the protocol after returning.
+The FW implementation can generate a fixup with the following restrictions:
+* on return, the data must be valid ASCII encoding with nul termination
+* the data and termination byte must never exceed the provided `FixupBufferSize`
+* no libavb arguments may be provided (see Security below)
 
-#### BufferSize
-On function call, this contains the size of the command line buffer, which may
-be larger than the current command line contents. The implementation is free to
-grow the command line contents up to this size, including the termination byte.
+#### FixupBufferSize [in, out]
+On function call, this points to the fixup buffer size provided by `Fixup`. The
+implementation is free to provide fixup data up to this size, including the
+termination byte.
 
 If the buffer is not large enough to fit the fixups, the function should update
-`BufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`; GBL will
-then allocate a larger buffer and re-call this function with the original
-un-modified command line.
+`FixupBufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`;
+GBL will then allocate a larger buffer, discard all modifications and repeat
+the `FixupKernelCommandline` call.
 
-`BufferSize` does not need to be updated on success, GBL will determine the
-command line data size via the nul terminator.
+`FixupBufferSize` does not need to be updated on success, GBL will determine the
+fixup command line data size via the nul terminator.
 
 ### Description
 
 GBL will call this function after loading and verifying the base kernel command
-line, to give the device an opportunity to supply any runtime fixups.
+line, to give the device an opportunity to supply some of the runtime fixups.
 
-Since the devicetree selection affects the base kernel command line, GBL will
-call `FixupDevicetree` first before calling `FixupKernelCommandline`.
+Since the device tree selection affects the base kernel command line, GBL will
+call `SelectDeviceTrees` first before calling `FixupKernelCommandline`.
 
 #### Security
 
 To ensure the integrity of verified boot data, this protocol will not be
-allowed to add, delete, or modify any command line parameters provided by
+allowed to append any command line parameters provided by
 [libavb](https://source.android.com/docs/security/features/verifiedboot/avb).
-If any of these parameters are modified, GBL will treat this as a failed boot
+If any of these parameters are provided, GBL will treat this as a failed boot
 attempt:
 * `androidboot.veritymode*`
 * `androidboot.vbmeta*`
@@ -143,21 +150,68 @@ Additionally, all data used to apply fixups to the command line must be trusted.
 In particular, if the protocol loads any data from non-secure storage, it should
 verify that data before use.
 
-### Status Codes Returned
+#### Status Codes Returned
 
-|||
-| ----------- | ----------- |
-| `EFI_SUCCESS` | Command line fixup completed. |
-| `EFI_INVALID_PARAMETER` | A parameter is invalid. |
-| `EFI_BUFFER_TOO_SMALL` | The buffer is too small; `BufferSize` has been updated with the required size. |
-| `EFI_DEVICE_ERROR` | Internal error while updating the command line. |
+|                         |                                                                                     |
+| ----------------------- | ----------------------------------------------------------------------------------- |
+| `EFI_SUCCESS`           | Command line fixup provided.                                                        |
+| `EFI_INVALID_PARAMETER` | A parameter is invalid.                                                             |
+| `EFI_BUFFER_TOO_SMALL`  | The buffer is too small; `FixupBufferSize` has been updated with the required size. |
+| `EFI_DEVICE_ERROR`      | Internal error while providing the command line fixup.                              |
 
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootconfig() {#FixupBootconfig}
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootConfig() {#FixupBootConfig}
 
 ### Summary
 
-GBL will call this function after loading and verifying the base bootconfig, to
-give the device an opportunity to supply any runtime modifications.
+Provides runtime fixups to the bootconfig.
+
+### Prototype
+
+```c
+typedef EFI_STATUS (EFIAPI *GBL_EFI_FIXUP_BOOTCONFIG)(
+  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
+  IN CONST CHAR8                       *BootConfig,
+  IN UINTN                             BootConfigSize,
+  OUT CHAR8                            *Fixup,
+  IN OUT UINTN                         *FixupBufferSize
+  );
+```
+
+### Parameters
+
+Ownership of all the parameters is loaned only for the duration of the function call, and
+must not be retained by the protocol after returning.
+
+#### This
+A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
+
+#### BootConfig [in]
+Pointer to the bootconfig built by GBL. Trailing data isn't provided.
+
+#### BootConfigSize [in]
+Size of the bootconfig built by GBL.
+
+#### Fixup [out]
+Pointer to a pre-allocated buffer to store the generated bootconfig fixup.
+GBL verifies and appends provided data into the final bootconfig. FW may
+leave this unchanged if no fixup is required. `FixupBufferSize` must be
+updated to `0` in this case.
+
+The FW implementation can generate a fixup with the following restrictions:
+* on return, the data must be valid bootconfig (trailer is optional)
+* the data must never exceed the provided `FixupBufferSize`
+* no libavb arguments may be provided (see Security below)
+
+#### FixupBufferSize [in, out]
+On function call, this points to the fixup buffer size provided by `Fixup`. The
+implementation is free to provide fixup data up to this size.
+
+If the buffer is not large enough to fit the fixups, the function should update
+`FixupBufferSize` with the required size and return `EFI_BUFFER_TOO_SMALL`;
+GBL will then allocate a larger buffer, discard all modifications and repeat
+the `FixupBootConfig` call.
+
+`FixupBufferSize` must be updated on success to let GBL determine the fixup command line data size.
 
 ### Description
 
@@ -166,15 +220,102 @@ is very similar to the kernel command line, but the format is slightly
 different, and the contents are intended for user space consumption rather than
 kernel.
 
-This implementation only needs to update the bootconfig parameters, GBL will automatically update
+This protocol only needs to provide the bootconfig parameters, GBL will automatically update
 the bootconfig trailer metadata afterwards.
 
-This function's API, usage, and security guidelines are exactly identical to
+#### Security
+
+This function's security guidelines are exactly identical to
 [`FixupKernelCommandline`](#FixupKernelCommandline); see those docs for details.
 
-## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupDevicetree() {#FixupDevicetree}
+#### Status Codes Returned
 
-TODO(b/353272981)
+This function's status return codes are exactly identical to
+[`FixupKernelCommandline`](#FixupKernelCommandline); see those docs for details.
+
+## GBL_EFI_OS_CONFIGURATION_PROTOCOL.SelectDeviceTrees() {#SelectDeviceTrees}
+
+### Summary
+
+Inspects device trees and overlays loaded by GBL to determine which ones to use.
+
+### Prototype
+
+```c
+typedef enum {
+  BOOT,
+  VENDOR_BOOT,
+  DTBO,
+  DTB
+} GBL_EFI_DEVICE_TREE_SOURCE;
+
+typedef struct {
+  // GBL_EFI_DEVICE_TREE_SOURCE
+  UINT32 Source;
+  // values are zeroed and must not be used in case of BOOT / VENDOR_BOOT source
+  UINT32 Id;
+  UINT32 Rev;
+  UINT32 Custom[4];
+  // make sure GblDeviceTreeMetadata size is 8-bytes aligned. Also reserved for
+  // the future cases
+  UINT32 Reserved;
+} GBL_EFI_DEVICE_TREE_METADATA;
+
+typedef struct {
+  GBL_EFI_DEVICE_TREE_METADATA Metadata;
+  // base device tree / overlay buffer (guaranteed to be 8-bytes aligned),
+  // cannot be NULL. Device tree size can be identified by the header totalsize field.
+  CONST VOID *DeviceTree;
+  // Indicates whether this device tree (or overlay) must be included in the
+  // final device tree. Set to true by a FW if this component must be used
+  BOOLEAN Selected;
+} GBL_EFI_VERIFIED_DEVICE_TREE;
+
+typedef EFI_STATUS (EFIAPI *GBL_EFI_SELECT_DEVICE_TREES)(
+  IN GBL_EFI_OS_CONFIGURATION_PROTOCOL *This,
+  IN OUT GBL_EFI_VERIFIED_DEVICE_TREE  *DeviceTrees,
+  IN UINTN                             NumDeviceTrees
+  );
+```
+
+### Parameters
+
+Ownership of all the parameters is loaned only for the duration of the function call, and
+must not be retained by the protocol after returning.
+
+#### This
+A pointer to the `GBL_EFI_OS_CONFIGURATION_PROTOCOL` instance.
+
+#### DeviceTrees [in, out]
+
+Pointer to an array of base device trees and overlays for selection. Base device trees and
+overlays are differentiated by the `GBL_EFI_DEVICE_TREE_METADATA.Source` field (`BOOT`,
+`VENDOR_BOOT`, `DTB` for base device trees, and `DTBO` for overlays).
+
+Selection is made by setting `GBL_EFI_VERIFIED_DEVICE_TREE.Selected` to `TRUE`. Selecting
+multiple or zero base device trees will cause GBL to fail to boot. Selecting multiple or
+zero overlays are supported.
+
+#### NumDeviceTrees [in]
+
+The number of base device trees and overlays in the `DeviceTrees` array.
+
+### Description
+
+Android build artifacts provide multiple base device trees and overlays from the `boot`,
+`vendor_boot`, `dtb`, and `dtbo` partitions. These artifacts are reused across multiple SoCs,
+so the firmware typically selects a base device tree and overlays to construct the final tree.
+This method enables selection based on the loaded content.
+
+Only one base device tree and multiple overlays (no overlays is also allowed) can be selected.
+If more than one or no base device trees are selected, GBL will fail to boot.
+
+### Status Codes Returned
+
+|                         |                                                                         |
+| ----------------------- | ----------------------------------------------------------------------- |
+| `EFI_SUCCESS`           | Base device tree, overlays has been selected.                           |
+| `EFI_INVALID_PARAMETER` | A parameter is invalid. For example, incorrect device trees, alignment. |
 
 ## GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupZbi() {#FixupZbi}
 
diff --git a/gbl/docs/partitions.md b/gbl/docs/partitions.md
index cc3e174..fea722b 100644
--- a/gbl/docs/partitions.md
+++ b/gbl/docs/partitions.md
@@ -47,5 +47,9 @@ two schemes of partition:
    using its corresponding GPT partition name in the context of booting and
    fastboot.
 
-Because partitions are identified by their names in fastboot. They cannot
-contain character `":"`.
+GBL fastboot implementation introduces a special syntax
+`<part>/<storage id>/<offset>/<size>` for specifying arbitrary subranges of a
+partition on one of the potentially multiple storage devices. Thus the
+partition name cannot contain character `'/'`. The name `gpt` is reserved for
+flashing GPT partition table and thus should not be used as partition name.
+See this [doc](./gbl_fastboot.md) for more details.
diff --git a/gbl/docs/resources/ab-bl-ab-android-flow.png b/gbl/docs/resources/ab-bl-ab-android-flow.png
new file mode 100644
index 0000000..f69b0b6
Binary files /dev/null and b/gbl/docs/resources/ab-bl-ab-android-flow.png differ
diff --git a/gbl/docs/resources/ab-bl-ab-android.png b/gbl/docs/resources/ab-bl-ab-android.png
new file mode 100644
index 0000000..e6aebd5
Binary files /dev/null and b/gbl/docs/resources/ab-bl-ab-android.png differ
diff --git a/gbl/docs/resources/slotless-bl-ab-android-flow.png b/gbl/docs/resources/slotless-bl-ab-android-flow.png
new file mode 100644
index 0000000..f49d16d
Binary files /dev/null and b/gbl/docs/resources/slotless-bl-ab-android-flow.png differ
diff --git a/gbl/docs/resources/slotless-bl-ab-android.png b/gbl/docs/resources/slotless-bl-ab-android.png
new file mode 100644
index 0000000..c150122
Binary files /dev/null and b/gbl/docs/resources/slotless-bl-ab-android.png differ
diff --git a/gbl/efi/BUILD b/gbl/efi/BUILD
index 51d7dba..2607b4e 100644
--- a/gbl/efi/BUILD
+++ b/gbl/efi/BUILD
@@ -27,37 +27,25 @@ rust_library(
     crate_name = "gbl_efi",
     rustc_flags = ANDROID_RUST_LINTS,
     deps = [
+        "@arrayvec",
         "@avb",
-        "@avb//:avb_crypto_ops_sha_impl_staticlib",
         "@gbl//libasync",
         "@gbl//libasync:cyclic_executor",
-        "@gbl//libavb:sysdeps",
         "@gbl//libboot",
-        "@gbl//libbootconfig",
-        "@gbl//libbootimg",
-        "@gbl//libdttable",
         "@gbl//libefi",
         "@gbl//libefi_types",
         "@gbl//liberror",
         "@gbl//libfastboot",
         "@gbl//libfdt",
         "@gbl//libgbl",
-        "@gbl//libmisc",
         "@gbl//libsafemath",
         "@gbl//libstorage",
-        "@gbl//third_party/libzbi",
         "@smoltcp",
         "@spin",
         "@uuid",
+        "@zbi",
         "@zerocopy",
-    ] + select(
-        {
-            "@gbl//toolchain:gbl_rust_uefi_aarch64": [
-                "@gbl//efi/arch/aarch64",
-            ],
-            "//conditions:default": [],
-        },
-    ),
+    ],
 )
 
 rust_test(
@@ -97,6 +85,8 @@ rust_binary(
     ],
     deps = [
         ":libgbl_efi",
+        "@avb//:avb_crypto_ops_sha_impl_staticlib",
+        "@gbl//libavb:sysdeps",
         "@gbl//libefi",
         "@gbl//libefi_types",
     ] + select(
diff --git a/gbl/efi/app/main.rs b/gbl/efi/app/main.rs
index 00ee301..e607f5f 100644
--- a/gbl/efi/app/main.rs
+++ b/gbl/efi/app/main.rs
@@ -36,7 +36,10 @@ fn handle_panic(p_info: &PanicInfo) -> ! {
 
 #[no_mangle]
 #[global_allocator]
-static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::Uninitialized;
+static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::new();
+
+/// Pull in the sysdeps required by libavb so the linker can find them.
+extern crate avb_sysdeps;
 
 /// EFI application entry point. Does not return.
 ///
diff --git a/gbl/efi/src/android_boot.rs b/gbl/efi/src/android_boot.rs
index c8f023f..5a02b95 100644
--- a/gbl/efi/src/android_boot.rs
+++ b/gbl/efi/src/android_boot.rs
@@ -12,485 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::{
-    avb::GblEfiAvbOps,
-    efi_blocks::find_block_devices,
-    ops::Ops,
-    utils::{aligned_subslice, cstr_bytes_to_str},
-};
-use avb::{slot_verify, HashtreeErrorMode, Ops as _, SlotVerifyFlags};
-use bootconfig::BootConfigBuilder;
-use bootimg::{BootImage, VendorImageHeader};
-use core::cmp::max;
-use core::{ffi::CStr, fmt::Write, str::from_utf8};
+use crate::{efi_blocks::find_block_devices, fastboot::fastboot, ops::Ops, ops::RambootOps};
 use efi::{exit_boot_services, EfiEntry};
-use fdt::Fdt;
-use liberror::Error;
-use libgbl::{gbl_print, gbl_println, GblOps, IntegrationError, Result};
-use misc::{AndroidBootMode, BootloaderMessage};
-use safemath::SafeNum;
-use zerocopy::{AsBytes, ByteSlice};
-
-#[cfg(target_arch = "aarch64")]
-use gbl_efi_aarch64::decompress_kernel;
-
-// Linux kernel requires 2MB alignment.
-const KERNEL_ALIGNMENT: usize = 2 * 1024 * 1024;
-// libfdt requires FDT buffer to be 8-byte aligned.
-const FDT_ALIGNMENT: usize = 8;
-
-/// Helper function for performing libavb verification.
-///
-/// Currently this requires the caller to preload all relevant images from disk; in its final
-/// state `ops` will provide the necessary callbacks for where the images should go in RAM and
-/// which ones are preloaded.
-///
-/// # Arguments
-/// * `ops`: [GblOps] providing device-specific backend.
-/// * `kernel`: buffer containing the `boot` image loaded from disk.
-/// * `vendor_boot`: buffer containing the `vendor_boot` image loaded from disk.
-/// * `init_boot`: buffer containing the `init_boot` image loaded from disk.
-/// * `dtbo`: buffer containing the `dtbo` image loaded from disk, if it exists.
-/// * `bootconfig_builder`: object to write the bootconfig data into.
-///
-/// # Returns
-/// `()` on success, error if the images fail to verify or we fail to update the bootconfig.
-fn avb_verify_slot<'a>(
-    ops: &mut impl GblOps<'a>,
-    kernel: &[u8],
-    vendor_boot: &[u8],
-    init_boot: &[u8],
-    dtbo: Option<&[u8]>,
-    bootconfig_builder: &mut BootConfigBuilder,
-) -> Result<()> {
-    let mut partitions = vec![c"boot", c"vendor_boot", c"init_boot"];
-    let mut preloaded =
-        vec![("boot", kernel), ("vendor_boot", vendor_boot), ("init_boot", init_boot)];
-
-    if let Some(dtbo) = dtbo {
-        partitions.push(c"dtbo");
-        preloaded.push(("dtbo", dtbo));
-    }
-
-    let mut avb_ops = GblEfiAvbOps::new(ops, Some(&preloaded));
-    let avb_state = match avb_ops.read_is_device_unlocked()? {
-        true => "orange",
-        _ => "green",
-    };
-
-    let res = slot_verify(
-        &mut avb_ops,
-        &partitions,
-        Some(c"_a"),
-        SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
-        // For demo, we use the same setting as Cuttlefish u-boot.
-        HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
-    )
-    .map_err(|e| IntegrationError::from(e.without_verify_data()))?;
-
-    // Append avb generated bootconfig.
-    for cmdline_arg in res.cmdline().to_str().unwrap().split(' ') {
-        write!(bootconfig_builder, "{}\n", cmdline_arg).or(Err(Error::BufferTooSmall(None)))?;
-    }
-
-    // Append "androidboot.verifiedbootstate="
-    write!(bootconfig_builder, "androidboot.verifiedbootstate={}\n", avb_state)
-        .or(Err(Error::BufferTooSmall(None)))?;
-    Ok(())
-}
-
-/// Helper function to parse common fields from boot image headers.
-///
-/// # Returns
-///
-/// Returns a tuple of 6 slices corresponding to:
-/// (kernel_size, cmdline, page_size, ramdisk_size, second_size, dtb_size)
-fn boot_header_elements<B: ByteSlice + PartialEq>(
-    hdr: &BootImage<B>,
-) -> Result<(usize, &[u8], usize, usize, usize, usize)> {
-    const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
-    Ok(match hdr {
-        BootImage::V2(ref hdr) => {
-            let kernel_size = hdr._base._base.kernel_size as usize;
-            let page_size = hdr._base._base.page_size as usize;
-            let ramdisk_size = hdr._base._base.ramdisk_size as usize;
-            let second_size = hdr._base._base.second_size as usize;
-            let dtb_size = hdr.dtb_size as usize;
-            (
-                kernel_size,
-                &hdr._base._base.cmdline[..],
-                page_size,
-                ramdisk_size,
-                second_size,
-                dtb_size,
-            )
-        }
-        BootImage::V3(ref hdr) => {
-            (hdr.kernel_size as usize, &hdr.cmdline[..], PAGE_SIZE, hdr.ramdisk_size as usize, 0, 0)
-        }
-        BootImage::V4(ref hdr) => (
-            hdr._base.kernel_size as usize,
-            &hdr._base.cmdline[..],
-            PAGE_SIZE,
-            hdr._base.ramdisk_size as usize,
-            0,
-            0,
-        ),
-        _ => {
-            return Err(Error::UnsupportedVersion.into());
-        }
-    })
-}
-
-/// Helper function to parse common fields from vendor image headers.
-///
-/// # Returns
-///
-/// Returns a tuple of 5 slices corresponding to:
-/// (vendor_ramdisk_size, hdr_size, cmdline, page_size, dtb_size)
-fn vendor_header_elements<B: ByteSlice + PartialEq>(
-    hdr: &VendorImageHeader<B>,
-) -> Result<(usize, usize, &[u8], usize, usize)> {
-    Ok(match hdr {
-        VendorImageHeader::V3(ref hdr) => (
-            hdr.vendor_ramdisk_size as usize,
-            SafeNum::from(hdr.bytes().len())
-                .round_up(hdr.page_size)
-                .try_into()
-                .map_err(Error::from)?,
-            &hdr.cmdline.as_bytes(),
-            hdr.page_size as usize,
-            hdr.dtb_size as usize,
-        ),
-        VendorImageHeader::V4(ref hdr) => (
-            hdr._base.vendor_ramdisk_size as usize,
-            SafeNum::from(hdr.bytes().len())
-                .round_up(hdr._base.page_size)
-                .try_into()
-                .map_err(Error::from)?,
-            &hdr._base.cmdline.as_bytes(),
-            hdr._base.page_size as usize,
-            hdr._base.dtb_size as usize,
-        ),
-    })
-}
-
-/// Loads Android images from disk and fixes up bootconfig, commandline, and FDT.
-///
-/// A number of simplifications are made:
-///
-///   * No A/B slot switching is performed. It always boot from *_a slot.
-///   * No dynamic partitions.
-///   * Only support V3/V4 image and Android 13+ (generic ramdisk from the "init_boot" partition)
-///   * Only support booting recovery from boot image
-///
-/// # Arguments
-/// * `ops`: the [GblOps] object providing platform-specific backends.
-/// * `load`: the combined buffer to load all images into.
-///
-/// # Returns
-/// Returns a tuple of 4 slices corresponding to:
-///   (ramdisk load buffer, FDT load buffer, kernel load buffer, unused buffer).
-pub fn load_android_simple<'a, 'b>(
-    ops: &mut impl GblOps<'b>,
-    load: &'a mut [u8],
-) -> Result<(&'a mut [u8], &'a mut [u8], &'a mut [u8], &'a mut [u8])> {
-    const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
-
-    let (bcb_buffer, load) = load.split_at_mut(BootloaderMessage::SIZE_BYTES);
-    ops.read_from_partition_sync("misc", 0, bcb_buffer)?;
-    let bcb = BootloaderMessage::from_bytes_ref(bcb_buffer)?;
-    let boot_mode = bcb.boot_mode()?;
-    gbl_println!(ops, "boot mode from BCB: {}", boot_mode);
-
-    // Parse boot header.
-    let (boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
-    ops.read_from_partition_sync("boot_a", 0, boot_header_buffer)?;
-    let boot_header = BootImage::parse(boot_header_buffer).map_err(Error::from)?;
-    let (kernel_size, cmdline, kernel_hdr_size, boot_ramdisk_size, boot_second_size, boot_dtb_size) =
-        boot_header_elements(&boot_header)?;
-    gbl_println!(ops, "boot image size: {}", kernel_size);
-    gbl_println!(ops, "boot image cmdline: \"{}\"", from_utf8(cmdline).unwrap());
-    gbl_println!(ops, "boot ramdisk size: {}", boot_ramdisk_size);
-    gbl_println!(ops, "boot dtb size: {}", boot_dtb_size);
-
-    // Parse vendor boot header.
-    let (vendor_boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
-    ops.read_from_partition_sync("vendor_boot_a", 0, vendor_boot_header_buffer)?;
-    let vendor_boot_header =
-        VendorImageHeader::parse(vendor_boot_header_buffer).map_err(Error::from)?;
-    let (vendor_ramdisk_size, vendor_hdr_size, vendor_cmdline, vendor_page_size, vendor_dtb_size) =
-        vendor_header_elements(&vendor_boot_header)?;
-    gbl_println!(ops, "vendor ramdisk size: {}", vendor_ramdisk_size);
-    gbl_println!(ops, "vendor cmdline: \"{}\"", from_utf8(vendor_cmdline).unwrap());
-    gbl_println!(ops, "vendor dtb size: {}", vendor_dtb_size);
-
-    let (dtbo_buffer, load) = match ops.partition_size("dtbo_a") {
-        Ok(Some(sz)) => {
-            let (dtbo_buffer, load) =
-                aligned_subslice(load, FDT_ALIGNMENT)?.split_at_mut(sz.try_into().unwrap());
-            ops.read_from_partition_sync("dtbo_a", 0, dtbo_buffer)?;
-            (Some(dtbo_buffer), load)
-        }
-        _ => (None, load),
-    };
-
-    // Parse init_boot header
-    let init_boot_header_buffer = &mut load[..PAGE_SIZE];
-    let (generic_ramdisk_size, init_boot_hdr_size) = match ops.partition_size("init_boot_a") {
-        Ok(Some(_sz)) => {
-            ops.read_from_partition_sync("init_boot_a", 0, init_boot_header_buffer)?;
-            let init_boot_header =
-                BootImage::parse(init_boot_header_buffer).map_err(Error::from)?;
-            match init_boot_header {
-                BootImage::V3(ref hdr) => (hdr.ramdisk_size as usize, PAGE_SIZE),
-                BootImage::V4(ref hdr) => (hdr._base.ramdisk_size as usize, PAGE_SIZE),
-                _ => {
-                    gbl_println!(ops, "V0/V1/V2 images are not supported");
-                    return Err(Error::UnsupportedVersion.into());
-                }
-            }
-        }
-        _ => (0, 0),
-    };
-    gbl_println!(ops, "init_boot image size: {}", generic_ramdisk_size);
-
-    // Load and prepare various images.
-    let images_buffer = aligned_subslice(load, KERNEL_ALIGNMENT)?;
-    let load = &mut images_buffer[..];
-
-    // Load kernel
-    // Kernel may need to reserve additional memory after itself. To avoid the risk of this
-    // memory overlapping with ramdisk. We place kernel after ramdisk. We first load it to the tail
-    // of the buffer and move it forward as much as possible after ramdisk and fdt are loaded,
-    // fixed-up and finalized.
-    let boot_img_load_offset: usize = {
-        let off = SafeNum::from(load.len()) - kernel_size - boot_ramdisk_size;
-        let off_idx: usize = off.try_into().map_err(Error::from)?;
-        let aligned_off = off - (&load[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
-        aligned_off.try_into().map_err(Error::from)?
-    };
-    let (load, boot_img_buffer) = load.split_at_mut(boot_img_load_offset);
-    ops.read_from_partition_sync(
-        "boot_a",
-        kernel_hdr_size.try_into().unwrap(),
-        &mut boot_img_buffer[..kernel_size + boot_ramdisk_size],
-    )?;
-
-    // Load vendor ramdisk
-    let mut ramdisk_load_curr = SafeNum::ZERO;
-    ops.read_from_partition_sync(
-        "vendor_boot_a",
-        u64::try_from(vendor_hdr_size).map_err(Error::from)?,
-        &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..vendor_ramdisk_size],
-    )?;
-    ramdisk_load_curr += vendor_ramdisk_size;
-
-    // Load generic ramdisk
-    if generic_ramdisk_size > 0 {
-        ops.read_from_partition_sync(
-            "init_boot_a",
-            init_boot_hdr_size.try_into().unwrap(),
-            &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..generic_ramdisk_size],
-        )?;
-        ramdisk_load_curr += generic_ramdisk_size;
-    }
-
-    // Load ramdisk from boot image
-    if boot_ramdisk_size > 0 {
-        load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..boot_ramdisk_size]
-            .copy_from_slice(&boot_img_buffer[kernel_size..][..boot_ramdisk_size]);
-        ramdisk_load_curr += boot_ramdisk_size;
-    }
-
-    // Prepare partition data for avb verification
-    let (vendor_boot_load_buffer, remains) = load.split_at_mut(vendor_ramdisk_size);
-    let (init_boot_load_buffer, remains) = remains.split_at_mut(generic_ramdisk_size);
-    let (_boot_ramdisk_load_buffer, remains) = remains.split_at_mut(boot_ramdisk_size);
-    // Prepare a BootConfigBuilder to add avb generated bootconfig.
-    let mut bootconfig_builder = BootConfigBuilder::new(remains)?;
-    // Perform avb verification.
-    avb_verify_slot(
-        ops,
-        boot_img_buffer,
-        vendor_boot_load_buffer,
-        init_boot_load_buffer,
-        dtbo_buffer.as_deref(),
-        &mut bootconfig_builder,
-    )?;
-
-    // Move kernel to end of the boot image buffer
-    let (_boot_img_buffer, kernel_tail_buffer) = {
-        let off = SafeNum::from(boot_img_buffer.len()) - kernel_size;
-        let off_idx: usize = off.try_into().map_err(Error::from)?;
-        let aligned_off = off - (&boot_img_buffer[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
-        let aligned_off_idx = aligned_off.try_into().map_err(Error::from)?;
-        boot_img_buffer.copy_within(0..kernel_size, aligned_off_idx);
-        boot_img_buffer.split_at_mut(aligned_off_idx)
-    };
-
-    // Add slot index
-    bootconfig_builder.add("androidboot.slot_suffix=_a\n")?;
-
-    match boot_mode {
-        // TODO(b/329716686): Support bootloader mode
-        AndroidBootMode::Normal | AndroidBootMode::BootloaderBootOnce => {
-            bootconfig_builder.add("androidboot.force_normal_boot=1\n")?
-        }
-        _ => {
-            // Do nothing
-        }
-    }
-
-    // V4 image has vendor bootconfig.
-    if let VendorImageHeader::V4(ref hdr) = vendor_boot_header {
-        let mut bootconfig_offset = SafeNum::from(vendor_hdr_size);
-        for image_size in
-            [hdr._base.vendor_ramdisk_size, hdr._base.dtb_size, hdr.vendor_ramdisk_table_size]
-        {
-            bootconfig_offset += SafeNum::from(image_size).round_up(hdr._base.page_size);
-        }
-        bootconfig_builder.add_with(|out| {
-            ops.read_from_partition_sync(
-                "vendor_boot_a",
-                bootconfig_offset.try_into()?,
-                &mut out[..hdr.bootconfig_size as usize],
-            )?;
-            Ok(hdr.bootconfig_size as usize)
-        })?;
-    }
-    // Check if there is a device specific bootconfig partition.
-    match ops.partition_size("bootconfig") {
-        Ok(Some(sz)) => {
-            bootconfig_builder.add_with(|out| {
-                // For proof-of-concept only, we just load as much as possible and figure out the
-                // actual bootconfig string length after. This however, can introduce large amount
-                // of unnecessary disk access. In real implementation, we might want to either read
-                // page by page or find way to know the actual length first.
-                let max_size = core::cmp::min(sz.try_into().unwrap(), out.len());
-                ops.read_from_partition_sync("bootconfig", 0, &mut out[..max_size])?;
-                // Compute the actual config string size. The config is a null-terminated string.
-                Ok(CStr::from_bytes_until_nul(&out[..])
-                    .or(Err(Error::InvalidInput))?
-                    .to_bytes()
-                    .len())
-            })?;
-        }
-        _ => {}
-    }
-    gbl_println!(ops, "final bootconfig: \"{}\"", bootconfig_builder);
-
-    ramdisk_load_curr += bootconfig_builder.config_bytes().len();
-
-    // On ARM, we may need to decompress the kernel and re-split the buffer to the new kernel size.
-    #[cfg(target_arch = "aarch64")]
-    let (load, kernel_size, kernel_tail_buffer) = {
-        let kernel_size = kernel_tail_buffer.len();
-        let compressed_kernel_offset = images_buffer.len() - kernel_size;
-        let decompressed_kernel_offset =
-            decompress_kernel(ops, images_buffer, compressed_kernel_offset)?;
-        let (load, kernel_tail_buffer) = images_buffer.split_at_mut(decompressed_kernel_offset);
-        (load, kernel_tail_buffer.len(), kernel_tail_buffer)
-    };
-
-    // Prepare FDT.
-
-    // For cuttlefish, FDT comes from EFI vendor configuration table installed by u-boot. In real
-    // product, it may come from vendor boot image.
-    let mut fdt_bytes_buffer = vec![0u8; max(vendor_dtb_size, boot_dtb_size)];
-    let fdt_bytes_buffer = &mut fdt_bytes_buffer[..];
-    let fdt_bytes = match ops.get_custom_device_tree() {
-        Some(fdt_bytes) => fdt_bytes,
-        None if vendor_dtb_size > 0 => {
-            let vendor_dtb_offset: usize = (SafeNum::from(vendor_hdr_size)
-                + SafeNum::from(vendor_ramdisk_size))
-            .round_up(vendor_page_size)
-            .try_into()
-            .map_err(Error::from)?;
-            gbl_println!(
-                ops,
-                "Loading vendor_boot dtb size {} at {}",
-                vendor_dtb_size,
-                vendor_dtb_offset
-            );
-            let fdt_bytes = &mut fdt_bytes_buffer[..vendor_dtb_size.try_into().unwrap()];
-            ops.read_from_partition_sync(
-                "vendor_boot_a",
-                vendor_dtb_offset.try_into().unwrap(),
-                fdt_bytes,
-            )?;
-            fdt_bytes
-        }
-        None if boot_dtb_size > 0 => {
-            let mut boot_dtb_offset = SafeNum::from(kernel_hdr_size);
-            for image_size in [kernel_size, boot_ramdisk_size, boot_second_size] {
-                boot_dtb_offset += SafeNum::from(image_size).round_up(kernel_hdr_size);
-            }
-            let fdt_bytes = &mut fdt_bytes_buffer[..boot_dtb_size.try_into().unwrap()];
-            ops.read_from_partition_sync("boot_a", boot_dtb_offset.try_into().unwrap(), fdt_bytes)?;
-            fdt_bytes
-        }
-        None => &mut [],
-    };
-    let fdt_origin = Fdt::new(fdt_bytes)?;
-
-    // Use the remaining load buffer for updating FDT.
-    let (ramdisk_load_buffer, load) =
-        load.split_at_mut(ramdisk_load_curr.try_into().map_err(Error::from)?);
-    let load = aligned_subslice(load, FDT_ALIGNMENT)?;
-    let mut fdt = Fdt::new_from_init(&mut load[..], fdt_bytes)?;
-
-    // Add ramdisk range to FDT
-    let ramdisk_addr: u64 =
-        (ramdisk_load_buffer.as_ptr() as usize).try_into().map_err(Error::from)?;
-    let ramdisk_end: u64 =
-        ramdisk_addr + u64::try_from(ramdisk_load_buffer.len()).map_err(Error::from)?;
-    fdt.set_property("chosen", c"linux,initrd-start", &ramdisk_addr.to_be_bytes())?;
-    fdt.set_property("chosen", c"linux,initrd-end", &ramdisk_end.to_be_bytes())?;
-    gbl_println!(ops, "linux,initrd-start: {:#x}", ramdisk_addr);
-    gbl_println!(ops, "linux,initrd-end: {:#x}", ramdisk_end);
-
-    // Concatenate kernel commandline and add it to FDT.
-    let bootargs_prop = CStr::from_bytes_with_nul(b"bootargs\0").unwrap();
-    let all_cmdline = [
-        cstr_bytes_to_str(fdt_origin.get_property("chosen", bootargs_prop).unwrap_or(&[0]))?,
-        " ",
-        cstr_bytes_to_str(cmdline)?,
-        " ",
-        cstr_bytes_to_str(vendor_cmdline)?,
-        "\0",
-    ];
-    let mut all_cmdline_len = 0;
-    all_cmdline.iter().for_each(|v| all_cmdline_len += v.len());
-    let cmdline_payload = fdt.set_property_placeholder("chosen", bootargs_prop, all_cmdline_len)?;
-    let mut cmdline_payload_off: usize = 0;
-    for ele in all_cmdline {
-        cmdline_payload[cmdline_payload_off..][..ele.len()].clone_from_slice(ele.as_bytes());
-        cmdline_payload_off += ele.len();
-    }
-    gbl_println!(ops, "final cmdline: \"{}\"", from_utf8(cmdline_payload).unwrap());
-
-    // Finalize FDT to actual used size.
-    fdt.shrink_to_fit()?;
-
-    // Move the kernel backward as much as possible to preserve more space after it. This is
-    // necessary in case the input buffer is at the end of address space.
-    let kernel_tail_buffer_size = kernel_tail_buffer.len();
-    let ramdisk_load_buffer_size = ramdisk_load_buffer.len();
-    let fdt_len = fdt.header_ref()?.actual_size();
-    // Split out the ramdisk.
-    let (ramdisk, remains) = images_buffer.split_at_mut(ramdisk_load_buffer_size);
-    // Split out the fdt.
-    let (fdt, kernel) = aligned_subslice(remains, FDT_ALIGNMENT)?.split_at_mut(fdt_len);
-    // Move the kernel backward as much as possible.
-    let kernel = aligned_subslice(kernel, KERNEL_ALIGNMENT)?;
-    let kernel_start = kernel.len().checked_sub(kernel_tail_buffer_size).unwrap();
-    kernel.copy_within(kernel_start..kernel_start.checked_add(kernel_size).unwrap(), 0);
-    // Split out the remaining buffer.
-    let (kernel, remains) = kernel.split_at_mut(kernel_size);
-
-    Ok((ramdisk, fdt, kernel, remains))
-}
+use libgbl::{android_boot::load_android_simple, gbl_print, gbl_println, GblOps, Os, Result};
 
 // The following implements a demo for booting Android from disk. It can be run from
 // Cuttlefish by adding `--android_efi_loader=<path of this EFI binary>` to the command line.
@@ -506,16 +30,30 @@ pub fn load_android_simple<'a, 'b>(
 // flow in libgbl, which will eventually replace this demo. The demo is currently used as an
 // end-to-end test for libraries developed so far.
 pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
-    let mut blks = find_block_devices(&entry)?;
-    let partitions = &blks.as_gbl_parts()?;
-    let mut ops = Ops { efi_entry: &entry, partitions };
+    let blks = find_block_devices(&entry)?;
+    let mut ops = Ops::new(&entry, &blks[..], Some(Os::Android));
+    let mut bootimg_buffer = &mut vec![0u8; 128 * 1024 * 1024][..]; // 128 MB
+
+    match ops.should_stop_in_fastboot() {
+        Ok(true) => fastboot(&mut ops, &mut bootimg_buffer)?,
+        Err(e) => {
+            gbl_println!(ops, "Warning: error while checking fastboot trigger ({:?})", e);
+            gbl_println!(ops, "Ignoring error and continuing with normal boot");
+        }
+        _ => {}
+    }
 
     gbl_println!(ops, "Try booting as Android");
 
     // Allocate buffer for load.
     let mut load_buffer = vec![0u8; 128 * 1024 * 1024]; // 128MB
 
-    let (ramdisk, fdt, kernel, remains) = load_android_simple(&mut ops, &mut load_buffer[..])?;
+    let (ramdisk, fdt, kernel, remains) = if bootimg_buffer.starts_with(b"ANDROID!") {
+        let mut ramboot_ops = RambootOps { ops: &mut ops, bootimg_buffer };
+        load_android_simple(&mut ramboot_ops, &mut load_buffer[..])?
+    } else {
+        load_android_simple(&mut ops, &mut load_buffer[..])?
+    };
 
     gbl_println!(ops, "");
     gbl_println!(
@@ -537,7 +75,11 @@ pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
 
     #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
     {
-        let fdt = fdt::Fdt::new(&fdt[..])?;
+        use fdt::Fdt;
+        use liberror::Error;
+        use libgbl::android_boot::BOOTARGS_PROP;
+
+        let fdt = Fdt::new(&fdt[..])?;
         drop(blks); // Drop `blks` to release the borrow on `entry`.
         let efi_mmap = exit_boot_services(entry, remains)?;
         // SAFETY: We currently target at Cuttlefish emulator where images are provided valid.
@@ -545,11 +87,7 @@ pub fn android_boot_demo(entry: EfiEntry) -> Result<()> {
             boot::x86::boot_linux_bzimage(
                 kernel,
                 ramdisk,
-                fdt.get_property(
-                    "chosen",
-                    core::ffi::CStr::from_bytes_with_nul(b"bootargs\0").unwrap(),
-                )
-                .unwrap(),
+                fdt.get_property("chosen", BOOTARGS_PROP).unwrap(),
                 |e820_entries| {
                     // Convert EFI memory type to e820 memory type.
                     if efi_mmap.len() > e820_entries.len() {
diff --git a/gbl/efi/src/avb.rs b/gbl/efi/src/avb.rs
deleted file mode 100644
index 365e4c6..0000000
--- a/gbl/efi/src/avb.rs
+++ /dev/null
@@ -1,155 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// This is an example implementation of the libavb rust wrapper backend in the EFI environment. It
-// is mainly for use by the boot demo. Eventually, these backends will be implemented from the
-// `GblOps` interface in libgbl, where EFI services will be one level lower as its backend instead.
-
-use avb::{IoError, IoResult, Ops as AvbOps, PublicKeyForPartitionInfo};
-use core::ffi::CStr;
-use libgbl::GblOps;
-use uuid::Uuid;
-
-extern crate avb_sysdeps;
-
-/// [AvbOps] implementation for [GblOps].
-// TODO(b/363074091): this code is now platform-independent; move it into libgbl.
-pub struct GblEfiAvbOps<'a, G> {
-    gbl_ops: &'a mut G,
-    preloaded_partitions: Option<&'a [(&'a str, &'a [u8])]>,
-}
-
-/// # Lifetimes
-/// * `'a`: borrowed data minimum lifetime
-/// * `'b`: [GblOps] partition lifetime
-impl<'a, 'b, G: GblOps<'b>> GblEfiAvbOps<'a, G> {
-    pub fn new(
-        gbl_ops: &'a mut G,
-        preloaded_partitions: Option<&'a [(&'a str, &'a [u8])]>,
-    ) -> Self {
-        Self { gbl_ops, preloaded_partitions }
-    }
-
-    /// Returns the size of a partition.
-    fn partition_size(&mut self, partition: &str) -> IoResult<u64> {
-        self.gbl_ops.partition_size(partition).or(Err(IoError::Io))?.ok_or(IoError::NoSuchPartition)
-    }
-}
-
-/// A helper function for converting CStr to str
-fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
-    Ok(s.to_str().map_err(|_| err)?)
-}
-
-impl<'a, 'b, G: GblOps<'b>> AvbOps<'a> for GblEfiAvbOps<'a, G> {
-    fn read_from_partition(
-        &mut self,
-        partition: &CStr,
-        offset: i64,
-        buffer: &mut [u8],
-    ) -> IoResult<usize> {
-        let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-        let partition_size: u64 =
-            self.partition_size(part_str)?.try_into().map_err(|_| IoError::Oom)?;
-        let read_off: u64 = match offset < 0 {
-            true => {
-                partition_size.checked_sub(offset.abs() as u64).ok_or(IoError::InvalidValueSize)?
-            }
-            _ => offset.try_into().map_err(|_| IoError::InvalidValueSize)?,
-        };
-        self.gbl_ops.read_from_partition_sync(part_str, read_off, buffer).or(Err(IoError::Io))?;
-        Ok(buffer.len())
-    }
-
-    fn get_preloaded_partition(&mut self, partition: &CStr) -> IoResult<&'a [u8]> {
-        let part_str = cstr_to_str(partition, IoError::NotImplemented)?;
-        Ok(self
-            .preloaded_partitions
-            .ok_or(IoError::NotImplemented)?
-            .iter()
-            .find(|(name, _)| *name == part_str)
-            .ok_or(IoError::NotImplemented)?
-            .1)
-    }
-
-    fn validate_vbmeta_public_key(
-        &mut self,
-        _public_key: &[u8],
-        _public_key_metadata: Option<&[u8]>,
-    ) -> IoResult<bool> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        Ok(true)
-    }
-
-    fn read_rollback_index(&mut self, _rollback_index_location: usize) -> IoResult<u64> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        Ok(0)
-    }
-
-    fn write_rollback_index(
-        &mut self,
-        _rollback_index_location: usize,
-        _index: u64,
-    ) -> IoResult<()> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        Ok(())
-    }
-
-    fn read_is_device_unlocked(&mut self) -> IoResult<bool> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        // For now always consider unlocked.
-        Ok(true)
-    }
-
-    fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> IoResult<Uuid> {
-        // The ops is only used to check that a partition exists. GUID is not used.
-        self.partition_size(cstr_to_str(partition, IoError::NoSuchPartition)?)?;
-        Ok(Uuid::nil())
-    }
-
-    fn get_size_of_partition(&mut self, partition: &CStr) -> IoResult<u64> {
-        match self.get_preloaded_partition(partition) {
-            Ok(img) => Ok(img.len().try_into().unwrap()),
-            _ => {
-                let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
-                self.partition_size(part_str)
-            }
-        }
-    }
-
-    fn read_persistent_value(&mut self, _name: &CStr, _value: &mut [u8]) -> IoResult<usize> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        unimplemented!();
-    }
-
-    fn write_persistent_value(&mut self, _name: &CStr, _value: &[u8]) -> IoResult<()> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        unimplemented!();
-    }
-
-    fn erase_persistent_value(&mut self, _name: &CStr) -> IoResult<()> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        unimplemented!();
-    }
-
-    fn validate_public_key_for_partition(
-        &mut self,
-        _partition: &CStr,
-        _public_key: &[u8],
-        _public_key_metadata: Option<&[u8]>,
-    ) -> IoResult<PublicKeyForPartitionInfo> {
-        // Not supported until we add our GBL specific EFI protocol that does this.
-        unimplemented!();
-    }
-}
diff --git a/gbl/efi/src/efi_blocks.rs b/gbl/efi/src/efi_blocks.rs
index 31c99a8..4e2212f 100644
--- a/gbl/efi/src/efi_blocks.rs
+++ b/gbl/efi/src/efi_blocks.rs
@@ -21,13 +21,12 @@ use efi::{
 };
 use efi_types::EfiBlockIoMedia;
 use gbl_async::block_on;
-use gbl_storage::{AsyncBlockDevice, BlockInfo, BlockIoAsync, GptCache};
+use gbl_storage::{gpt_buffer_size, BlockInfo, BlockIo, Disk, Gpt, SliceMaybeUninit};
 use liberror::Error;
-use libgbl::partition::{check_part_unique, Partition, PartitionBlockDevice};
-use safemath::SafeNum;
+use libgbl::partition::GblDisk;
 
 /// `EfiBlockDeviceIo` wraps a EFI `BlockIoProtocol` or `BlockIo2Protocol` and implements the
-/// `BlockIoAsync` interface.
+/// `BlockIo` interface.
 pub enum EfiBlockDeviceIo<'a> {
     Sync(Protocol<'a, BlockIoProtocol>),
     Async(Protocol<'a, BlockIo2Protocol>),
@@ -52,12 +51,20 @@ impl<'a> EfiBlockDeviceIo<'a> {
     }
 }
 
-impl BlockIoAsync for EfiBlockDeviceIo<'_> {
+// SAFETY:
+// `read_blocks()` usess EFI protocol that guarantees to read exact number of blocks that were
+// requested, or return error.
+// For async `read_blocks_ex()` blocking wait guarantees that read finishes.
+unsafe impl BlockIo for EfiBlockDeviceIo<'_> {
     fn info(&mut self) -> BlockInfo {
         (*self).info()
     }
 
-    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), Error> {
+    async fn read_blocks(
+        &mut self,
+        blk_offset: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<(), Error> {
         match self {
             EfiBlockDeviceIo::Sync(v) => v.read_blocks(blk_offset, out),
             EfiBlockDeviceIo::Async(v) => v.read_blocks_ex(blk_offset, out).await,
@@ -74,78 +81,17 @@ impl BlockIoAsync for EfiBlockDeviceIo<'_> {
     }
 }
 
-const MAX_GPT_ENTRIES: u64 = 128;
-
-/// `PartitionInfoBuffer` manages the buffer for raw partition name or GPT partition table.
-enum PartitionInfoBuffer {
-    Gpt(Vec<u8>),
-    // TODO(b/357688291): Add raw partition entry once supported.
-}
-
-/// `EfiBlockDevice` manages EFI block IO, scratch and partition table buffers.
-pub struct EfiBlockDevice<'a> {
-    io: EfiBlockDeviceIo<'a>,
-    scratch: Vec<u8>,
-    partition: PartitionInfoBuffer,
-}
-
-impl<'a> EfiBlockDevice<'a> {
-    /// Creates a new instance as GPT partition device.
-    ///
-    /// The API allocates scratch and GPT buffer from heap.
-    pub fn new_gpt(mut io: EfiBlockDeviceIo<'a>) -> Result<Self, Error> {
-        let scratch_size =
-            SafeNum::from(AsyncBlockDevice::<EfiBlockDeviceIo>::required_scratch_size(&mut io)?);
-        let mut gpt_buf = vec![0u8; GptCache::required_buffer_size(MAX_GPT_ENTRIES)?];
-        // Initializes GPT buffer.
-        let _ = GptCache::from_uninit(MAX_GPT_ENTRIES, &mut gpt_buf)?;
-        Ok(Self {
-            io,
-            scratch: vec![0u8; scratch_size.try_into()?],
-            partition: PartitionInfoBuffer::Gpt(gpt_buf),
-        })
-    }
-
-    /// Creates an instance of GBL partition block device.
-    pub fn as_gbl_part(
-        &mut self,
-    ) -> Result<PartitionBlockDevice<&mut EfiBlockDeviceIo<'a>>, Error> {
-        let blk = AsyncBlockDevice::new(&mut self.io, &mut self.scratch)?;
-        Ok(match &mut self.partition {
-            PartitionInfoBuffer::Gpt(buf) => {
-                PartitionBlockDevice::new_gpt(blk, GptCache::from_existing(buf).unwrap())
-            }
-        })
-    }
-}
-
-/// `EfiMultiBlockDevices` wraps a vector of `EfiBlockDevice`.
-pub struct EfiMultiBlockDevices<'a>(pub Vec<EfiBlockDevice<'a>>);
+const MAX_GPT_ENTRIES: usize = 128;
 
-impl<'a> EfiMultiBlockDevices<'a> {
-    /// Creates a vector of `PartitionBlockDevice`
-    pub fn as_gbl_parts(
-        &mut self,
-    ) -> Result<Vec<PartitionBlockDevice<&mut EfiBlockDeviceIo<'a>>>, Error> {
-        let mut res = vec![];
-        for ele in &mut self.0 {
-            res.push(ele.as_gbl_part()?)
-        }
-        Ok(res)
-    }
-
-    /// Finds a partition.
-    // TODO(b/357688291): Remove once we switch to GblOps for finding partitions.
-    pub fn find_partition(&mut self, part: &str) -> Result<Partition, Error> {
-        Ok(check_part_unique(&self.as_gbl_parts()?, part)?.1)
-    }
-}
+/// The [GblDisk] type in the GBL EFI context.
+pub type EfiGblDisk<'a> = GblDisk<Disk<EfiBlockDeviceIo<'a>, Vec<u8>>, Gpt<Vec<u8>>>;
 
 /// Finds and returns all EFI devices supporting either EFI_BLOCK_IO or EFI_BLOCK_IO2 protocol.
-pub fn find_block_devices(efi_entry: &EfiEntry) -> Result<EfiMultiBlockDevices, Error> {
+pub fn find_block_devices(efi_entry: &EfiEntry) -> Result<Vec<EfiGblDisk<'_>>, Error> {
     let bs = efi_entry.system_table().boot_services();
     let block_dev_handles = bs.locate_handle_buffer_by_protocol::<BlockIoProtocol>()?;
-    let mut block_devices = Vec::<EfiBlockDevice>::new();
+    let mut gbl_disks = vec![];
+    let gpt_buffer_size = gpt_buffer_size(MAX_GPT_ENTRIES)?;
     for (idx, handle) in block_dev_handles.handles().iter().enumerate() {
         // Prioritizes `BlockIo2Protocol`.
         let blk_io = match bs.open_protocol::<BlockIo2Protocol>(*handle) {
@@ -156,17 +102,16 @@ pub fn find_block_devices(efi_entry: &EfiEntry) -> Result<EfiMultiBlockDevices,
             continue;
         }
         // TODO(b/357688291): Support raw partition based on device path info.
-        let mut blk = EfiBlockDevice::new_gpt(blk_io)?;
-        match block_on(blk.as_gbl_part()?.sync_gpt()) {
-            Ok(true) => {
-                efi_println!(efi_entry, "Block #{}: GPT detected", idx);
-            }
-            Err(e) => {
-                efi_println!(efi_entry, "Block #{}: Failed to find GPT. {:?}", idx, e);
-            }
+        let disk = GblDisk::new_gpt(
+            Disk::new_alloc_scratch(blk_io).unwrap(),
+            Gpt::new(vec![0u8; gpt_buffer_size]).unwrap(),
+        );
+        match block_on(disk.sync_gpt()) {
+            Ok(Some(v)) => efi_println!(efi_entry, "Block #{idx} GPT sync result: {v}"),
+            Err(e) => efi_println!(efi_entry, "Block #{idx} error while syncing GPT: {e}"),
             _ => {}
         };
-        block_devices.push(blk);
+        gbl_disks.push(disk);
     }
-    Ok(EfiMultiBlockDevices(block_devices))
+    Ok(gbl_disks)
 }
diff --git a/gbl/efi/src/fastboot.rs b/gbl/efi/src/fastboot.rs
index 9a268c6..485e3ab 100644
--- a/gbl/efi/src/fastboot.rs
+++ b/gbl/efi/src/fastboot.rs
@@ -18,64 +18,78 @@
 // supported/unsupported features at the moment.
 
 use crate::{
-    efi_blocks::find_block_devices,
-    net::{with_efi_network, EfiTcpSocket},
+    net::{EfiGblNetwork, EfiTcpSocket},
     ops::Ops,
 };
-use alloc::vec::Vec;
-use core::{cmp::min, fmt::Write, future::Future, mem::take};
+use alloc::{boxed::Box, vec::Vec};
+use core::{cmp::min, fmt::Write, future::Future, mem::take, pin::Pin, sync::atomic::AtomicU64};
 use efi::{
     efi_print, efi_println,
     protocol::{gbl_efi_fastboot_usb::GblFastbootUsbProtocol, Protocol},
     EfiEntry,
 };
-use fastboot::{
-    process_next_command, run_tcp_session, CommandResult, FastbootImplementation, TcpStream,
-    Transport,
-};
-use gbl_async::{yield_now, YieldCounter};
-use gbl_cyclic_executor::CyclicExecutor;
+use fastboot::{TcpStream, Transport};
+use gbl_async::{block_on, YieldCounter};
 use liberror::{Error, Result};
-use libgbl::{
-    fastboot::{GblFastboot, TasksExecutor},
-    GblOps,
-};
-use spin::{Mutex, MutexGuard};
+use libgbl::fastboot::{run_gbl_fastboot, GblTcpStream, GblUsbTransport, PinFutContainer};
 
 const DEFAULT_TIMEOUT_MS: u64 = 5_000;
 const FASTBOOT_TCP_PORT: u16 = 5554;
 
 struct EfiFastbootTcpTransport<'a, 'b, 'c> {
-    last_err: Result<()>,
     socket: &'c mut EfiTcpSocket<'a, 'b>,
 }
 
 impl<'a, 'b, 'c> EfiFastbootTcpTransport<'a, 'b, 'c> {
     fn new(socket: &'c mut EfiTcpSocket<'a, 'b>) -> Self {
-        Self { last_err: Ok(()), socket: socket }
+        Self { socket: socket }
     }
 }
 
 impl TcpStream for EfiFastbootTcpTransport<'_, '_, '_> {
     /// Reads to `out` for exactly `out.len()` number bytes from the TCP connection.
     async fn read_exact(&mut self, out: &mut [u8]) -> Result<()> {
-        self.last_err = self.socket.receive_exact(out, DEFAULT_TIMEOUT_MS).await;
-        self.last_err.as_ref().or(Err(Error::Other(Some("Tcp read error"))))?;
-        Ok(())
+        self.socket.receive_exact(out, DEFAULT_TIMEOUT_MS).await
     }
 
     /// Sends exactly `data.len()` number bytes from `data` to the TCP connection.
     async fn write_exact(&mut self, data: &[u8]) -> Result<()> {
-        self.last_err = self.socket.send_exact(data, DEFAULT_TIMEOUT_MS).await;
-        self.last_err.as_ref().or(Err(Error::Other(Some("Tcp write error"))))?;
-        Ok(())
+        self.socket.send_exact(data, DEFAULT_TIMEOUT_MS).await
+    }
+}
+
+impl GblTcpStream for EfiFastbootTcpTransport<'_, '_, '_> {
+    fn accept_new(&mut self) -> bool {
+        let efi_entry = self.socket.efi_entry;
+        self.socket.poll();
+        // If not listenining, start listening.
+        // If not connected but it's been `DEFAULT_TIMEOUT_MS`, restart listening in case the remote
+        // client disconnects in the middle of TCP handshake and leaves the socket in a half open
+        // state.
+        if !self.socket.is_listening_or_handshaking()
+            || (!self.socket.check_active()
+                && self.socket.time_since_last_listen() > DEFAULT_TIMEOUT_MS)
+        {
+            let _ = self
+                .socket
+                .listen(FASTBOOT_TCP_PORT)
+                .inspect_err(|e| efi_println!(efi_entry, "TCP listen error: {:?}", e));
+
+            // TODO(b/368647237): Enable only in Fuchsia context.
+            self.socket.broadcast_fuchsia_fastboot_mdns();
+        } else if self.socket.check_active() {
+            self.socket.set_io_yield_threshold(1024 * 1024); // 1MB
+            let remote = self.socket.get_socket().remote_endpoint().unwrap();
+            efi_println!(efi_entry, "TCP connection from {}", remote);
+            return true;
+        }
+        false
     }
 }
 
 /// `UsbTransport` implements the `fastboot::Transport` trait using USB interfaces from
 /// GBL_EFI_FASTBOOT_USB_PROTOCOL.
 pub struct UsbTransport<'a> {
-    last_err: Result<()>,
     max_packet_size: usize,
     protocol: Protocol<'a, GblFastbootUsbProtocol>,
     io_yield_counter: YieldCounter,
@@ -88,79 +102,71 @@ pub struct UsbTransport<'a> {
 impl<'a> UsbTransport<'a> {
     fn new(max_packet_size: usize, protocol: Protocol<'a, GblFastbootUsbProtocol>) -> Self {
         Self {
-            last_err: Ok(()),
             max_packet_size,
             protocol,
-            io_yield_counter: YieldCounter::new(u64::MAX),
+            io_yield_counter: YieldCounter::new(1024 * 1024),
             prefetched: (vec![0u8; max_packet_size], 0),
         }
     }
 
-    /// Sets the maximum number of bytes to read or write before a force await.
-    pub fn set_io_yield_threshold(&mut self, threshold: u64) {
-        self.io_yield_counter = YieldCounter::new(threshold)
-    }
-
-    /// Reads the next packet from the EFI USB protocol into the given buffer.
-    async fn receive_next_from_efi(&mut self, out: &mut [u8]) -> Result<usize> {
-        match self.protocol.receive_packet(out).await {
-            Ok(sz) => {
-                // Forces a yield to the executor if the data received/sent reaches a certain
-                // threshold. This is to prevent the async code from holding up the CPU for too long
-                // in case IO speed is high and the executor uses cooperative scheduling.
-                self.io_yield_counter.increment(sz.try_into().unwrap()).await;
-                return Ok(sz);
-            }
-            Err(e) => {
-                self.last_err = Err(e.into());
-                return Err(Error::Other(Some("USB receive error")));
-            }
-        }
-    }
-
-    /// Waits until a packet is cached into an internal buffer.
-    async fn cache_next_packet(&mut self) -> Result<()> {
+    /// Polls and cache the next USB packet.
+    ///
+    /// Returns Ok(true) if there is a new packet. Ok(false) if there is no incoming packet. Err()
+    /// otherwise.
+    fn poll_next_packet(&mut self) -> Result<bool> {
         match &mut self.prefetched {
-            (pkt, len) if *len == 0 => {
-                let mut packet = take(pkt);
-                let len = self.receive_next_from_efi(&mut packet[..]).await?;
-                self.prefetched = (packet, len);
-            }
-            _ => {}
+            (pkt, len) if *len == 0 => match self.protocol.fastboot_usb_receive(pkt) {
+                Ok(out_size) => {
+                    *len = out_size;
+                    return Ok(true);
+                }
+                Err(Error::NotReady) => return Ok(false),
+                Err(e) => return Err(e),
+            },
+            _ => Ok(true),
         }
-        Ok(())
     }
 }
 
 impl Transport for UsbTransport<'_> {
     async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize> {
-        match &mut self.prefetched {
+        let len = match &mut self.prefetched {
             (pkt, len) if *len > 0 => {
                 let out = out.get_mut(..*len).ok_or(Error::BufferTooSmall(Some(*len)))?;
                 let src = pkt.get(..*len).ok_or(Error::Other(Some("Invalid USB read size")))?;
                 out.clone_from_slice(src);
-                return Ok(take(len));
+                take(len)
             }
-            _ => self.receive_next_from_efi(out).await,
-        }
+            _ => self.protocol.receive_packet(out).await?,
+        };
+        // Forces a yield to the executor if the data received/sent reaches a certain
+        // threshold. This is to prevent the async code from holding up the CPU for too long
+        // in case IO speed is high and the executor uses cooperative scheduling.
+        self.io_yield_counter.increment(len.try_into().unwrap()).await;
+        Ok(len)
     }
 
     async fn send_packet(&mut self, packet: &[u8]) -> Result<()> {
-        self.last_err = async {
-            let mut curr = &packet[..];
-            while !curr.is_empty() {
-                let to_send = min(curr.len(), self.max_packet_size);
-                self.protocol.send_packet(&curr[..to_send], DEFAULT_TIMEOUT_MS).await?;
-                // Forces a yield to the executor if the data received/sent reaches a certain
-                // threshold. This is to prevent the async code from holding up the CPU for too long
-                // in case IO speed is high and the executor uses cooperative scheduling.
-                self.io_yield_counter.increment(to_send.try_into().unwrap()).await;
-                curr = &curr[to_send..];
-            }
-            Ok(())
+        let mut curr = &packet[..];
+        while !curr.is_empty() {
+            let to_send = min(curr.len(), self.max_packet_size);
+            self.protocol.send_packet(&curr[..to_send], DEFAULT_TIMEOUT_MS).await?;
+            // Forces a yield to the executor if the data received/sent reaches a certain
+            // threshold. This is to prevent the async code from holding up the CPU for too long
+            // in case IO speed is high and the executor uses cooperative scheduling.
+            self.io_yield_counter.increment(to_send.try_into().unwrap()).await;
+            curr = &curr[to_send..];
         }
-        .await;
-        Ok(*self.last_err.as_ref().map_err(|_| Error::Other(Some("USB send error")))?)
+        Ok(())
+    }
+}
+
+impl GblUsbTransport for UsbTransport<'_> {
+    fn has_packet(&mut self) -> bool {
+        let efi_entry = self.protocol.efi_entry();
+        self.poll_next_packet()
+            .inspect_err(|e| efi_println!(efi_entry, "Error while polling next packet: {:?}", e))
+            .unwrap_or(false)
     }
 }
 
@@ -174,156 +180,60 @@ fn init_usb(efi_entry: &EfiEntry) -> Result<UsbTransport> {
     }
 }
 
-/// `EfiFbTaskExecutor` implements the `TasksExecutor` trait used by GBL fastboot for scheduling
-/// disk IO tasks.
+// Wrapper of vector of pinned futures.
 #[derive(Default)]
-struct EfiFbTaskExecutor<'a>(Mutex<CyclicExecutor<'a>>);
+struct VecPinFut<'a>(Vec<Pin<Box<dyn Future<Output = ()> + 'a>>>);
 
-impl<'a> TasksExecutor<'a> for EfiFbTaskExecutor<'a> {
-    fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()> {
-        Ok(self.0.lock().spawn_task(task))
+impl<'a> PinFutContainer<'a> for VecPinFut<'a> {
+    fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F) {
+        self.0.push(Box::pin(f()));
     }
-}
 
-/// Waits until a shared resource protected by a mutex is acquired successfully.
-async fn lock<T>(resource: &Mutex<T>) -> MutexGuard<T> {
-    loop {
-        // Yield first so that repetitive calls guarantees at least one yield.
-        yield_now().await;
-        match resource.try_lock() {
-            Some(v) => return v,
-            _ => {}
+    fn for_each_remove_if(
+        &mut self,
+        mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+    ) {
+        for idx in (0..self.0.len()).rev() {
+            cb(&mut self.0[idx].as_mut()).then(|| self.0.swap_remove(idx));
         }
     }
 }
 
-/// Task routine for Fastboot over USB.
-async fn fastboot_usb(
-    efi_entry: &EfiEntry,
-    gbl_fb: &Mutex<&mut impl FastbootImplementation>,
-    usb: &mut UsbTransport<'_>,
-) {
-    usb.set_io_yield_threshold(1024 * 1024); // 1MB
-    loop {
-        match usb.cache_next_packet().await {
-            Err(_) => efi_println!(efi_entry, "Fastboot USB error: {:?}", usb.last_err),
-            _ => match process_next_command(usb, *lock(gbl_fb).await).await {
-                Err(_) => efi_println!(efi_entry, "Fastboot USB error: {:?}", usb.last_err),
-                _ => {}
-            },
-        }
-    }
-}
+pub fn fastboot(efi_gbl_ops: &mut Ops, bootimg_buf: &mut [u8]) -> Result<()> {
+    let efi_entry = efi_gbl_ops.efi_entry;
+    efi_println!(efi_entry, "Entering fastboot mode...");
 
-/// Task routine for Fastboot over TCP.
-async fn fastboot_tcp(
-    efi_entry: &EfiEntry,
-    gbl_fb: &Mutex<&mut impl FastbootImplementation>,
-    socket: &mut EfiTcpSocket<'_, '_>,
-) {
-    socket.set_io_yield_threshold(1024 * 1024); // 1MB
-    let mut listen_start_timestamp = EfiTcpSocket::timestamp(0);
-    loop {
-        // Acquires the lock before proceeding to handle network. This reduces interference to the
-        // Fastboot USB task which maybe in the middle of a download. `lock()` internally yields
-        // control to the executor and check later if the mutex can't be acquired.
-        let mut gbl_fb = lock(gbl_fb).await;
-        socket.poll();
-        let mut reset_socket = false;
-        if socket.check_active() {
-            let remote = socket.get_socket().remote_endpoint().unwrap();
-            efi_println!(efi_entry, "TCP connection from {}", remote);
-            let mut transport = EfiFastbootTcpTransport::new(socket);
-            let _ = run_tcp_session(&mut transport, *gbl_fb).await;
-            match transport.last_err {
-                Ok(()) | Err(Error::Disconnected) => {}
-                Err(e) => efi_println!(efi_entry, "Fastboot TCP error {:?}", e),
-            }
-            reset_socket = true;
-        }
-        // Reset once in a while in case a remote client disconnects in the middle of
-        // TCP handshake and leaves the socket in a half open state.
-        if reset_socket || EfiTcpSocket::timestamp(listen_start_timestamp) > DEFAULT_TIMEOUT_MS {
-            listen_start_timestamp = EfiTcpSocket::timestamp(0);
-            if let Err(e) = socket.listen(FASTBOOT_TCP_PORT) {
-                efi_println!(efi_entry, "TCP listen error: {:?}", e);
-            }
-        }
-        // Necessary because our executor uses cooperative scheduling.
-        yield_now().await;
-    }
-}
+    let usb = init_usb(efi_entry)
+        .inspect(|_| efi_println!(efi_entry, "Started Fastboot over USB."))
+        .inspect_err(|e| efi_println!(efi_entry, "Failed to start Fastboot over USB. {:?}.", e))
+        .ok();
 
-/// Spawns and runs Fastboot tasks.
-fn run_fastboot<'a>(
-    efi_entry: &EfiEntry,
-    gbl_fb: &mut GblFastboot<'_, 'a, EfiFbTaskExecutor<'a>, impl GblOps<'a>>,
-    socket: Option<&mut EfiTcpSocket>,
-    usb: Option<&mut UsbTransport>,
-) -> Result<()> {
-    assert!(socket.is_some() || usb.is_some());
-    let blk_io_executor = gbl_fb.blk_io_executor();
-    let gbl_fb = gbl_fb.into();
-    let mut task_executor: CyclicExecutor = Default::default();
-    // Fastboot over USB task.
-    match usb {
-        Some(v) => {
-            efi_println!(efi_entry, "Started Fastboot over USB.");
-            task_executor.spawn_task(fastboot_usb(efi_entry, &gbl_fb, v));
-        }
-        _ => {}
-    }
-    // Fastboot over TCP task.
-    match socket {
-        Some(v) => {
+    let ts = AtomicU64::new(0);
+    let mut net: EfiGblNetwork = Default::default();
+    let mut tcp = net
+        .init(efi_entry, &ts)
+        .inspect(|v| {
             efi_println!(efi_entry, "Started Fastboot over TCP");
             efi_println!(efi_entry, "IP address:");
             v.interface().ip_addrs().iter().for_each(|v| {
                 efi_println!(efi_entry, "\t{}", v.address());
             });
-            task_executor.spawn_task(fastboot_tcp(efi_entry, &gbl_fb, v));
-        }
-        _ => {}
-    }
-    // Task for scheduling disk IO tasks spawned by Fastboot.
-    task_executor.spawn_task(async {
-        loop {
-            blk_io_executor.0.lock().poll();
-            yield_now().await;
-        }
-    });
-    // Run all tasks.
-    task_executor.run();
-    Ok(())
-}
+        })
+        .inspect_err(|e| efi_println!(efi_entry, "Failed to start EFI network. {:?}.", e))
+        .ok();
+    let tcp = tcp.as_mut().map(|v| EfiFastbootTcpTransport::new(v));
+
+    let download_buffers = vec![vec![0u8; 512 * 1024 * 1024]; 2].into();
+    block_on(run_gbl_fastboot(
+        efi_gbl_ops,
+        &download_buffers,
+        VecPinFut::default(),
+        usb,
+        tcp,
+        bootimg_buf,
+    ));
+
+    efi_println!(efi_entry, "Leaving fastboot mode...");
 
-/// Runs Fastboot.
-pub fn fastboot(efi_entry: &EfiEntry) -> Result<()> {
-    // TODO(b/328786603): Figure out where to get download buffer size.
-    let mut download_buffers = vec![vec![0u8; 512 * 1024 * 1024]; 2];
-    let download_buffers =
-        download_buffers.iter_mut().map(|v| v.as_mut_slice().into()).collect::<Vec<_>>();
-    let mut blks = find_block_devices(efi_entry)?;
-    let partitions = &blks.as_gbl_parts()?;
-    let mut gbl_ops = Ops { efi_entry: &efi_entry, partitions };
-    let blk_io_executor: EfiFbTaskExecutor = Default::default();
-    let gbl_fb = &mut GblFastboot::new(&blk_io_executor, &mut gbl_ops, &download_buffers);
-
-    let mut usb = match init_usb(efi_entry) {
-        Ok(v) => Some(v),
-        Err(e) => {
-            efi_println!(efi_entry, "Failed to start Fastboot over USB. {:?}.", e);
-            None
-        }
-    };
-
-    match with_efi_network(efi_entry, |socket| {
-        run_fastboot(efi_entry, gbl_fb, Some(socket), usb.as_mut())
-    }) {
-        Err(e) => {
-            efi_println!(efi_entry, "Failed to start EFI network. {:?}.", e);
-            run_fastboot(efi_entry, gbl_fb, None, usb.as_mut())
-        }
-        v => v?,
-    }
+    Ok(())
 }
diff --git a/gbl/efi/src/fuchsia_boot.rs b/gbl/efi/src/fuchsia_boot.rs
index 0e07123..44254e1 100644
--- a/gbl/efi/src/fuchsia_boot.rs
+++ b/gbl/efi/src/fuchsia_boot.rs
@@ -12,31 +12,45 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::{efi_blocks::find_block_devices, ops::Ops};
+use crate::utils::efi_to_zbi_mem_range_type;
+#[allow(unused_imports)]
+use crate::{
+    efi_blocks::find_block_devices, fastboot::fastboot, ops::Ops, utils::get_efi_mem_attr,
+};
 use core::fmt::Write;
-use efi::{efi_print, efi_println, EfiEntry};
+use efi::{efi_print, efi_println, EfiEntry, EfiMemoryAttributesTable, EfiMemoryMap};
+use efi_types::{
+    EfiMemoryAttributesTableHeader, EfiMemoryDescriptor, EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME,
+};
 use liberror::Error;
+use liberror::Error::BufferTooSmall;
 use libgbl::{
-    fuchsia_boot::{zircon_load_verify_abr, zircon_part_name},
-    Result,
+    fuchsia_boot::{zircon_check_enter_fastboot, zircon_load_verify_abr, zircon_part_name},
+    partition::check_part_unique,
+    IntegrationError::UnificationError,
+    Os, Result,
 };
+use safemath::SafeNum;
+use zbi::{zbi_format::zbi_mem_range_t, ZbiContainer, ZbiFlags, ZbiType};
+use zerocopy::{ByteSliceMut, Ref};
+
+const PAGE_SIZE: u64 = 4096;
 
 /// Check if the disk GPT layout is a Fuchsia device layout.
 pub fn is_fuchsia_gpt(efi_entry: &EfiEntry) -> Result<()> {
-    let mut gpt_devices = find_block_devices(&efi_entry)?;
-    let partitions: [&[&str]; 8] = [
-        &["zircon_a"],
-        &["zircon_b"],
-        &["zircon_r"],
+    let gpt_devices = find_block_devices(&efi_entry)?;
+    let partitions: &[&[&str]] = &[
+        &["zircon_a", "zircon-a"],
+        &["zircon_b", "zircon-b"],
+        &["zircon_r", "zircon-r"],
         &["vbmeta_a"],
         &["vbmeta_b"],
         &["vbmeta_r"],
-        &["fvm"],
         &["misc", "durable_boot"],
     ];
     if !partitions
         .iter()
-        .all(|&partition| partition.iter().any(|v| gpt_devices.find_partition(*v).is_ok()))
+        .all(|&partition| partition.iter().any(|v| check_part_unique(&gpt_devices[..], *v).is_ok()))
     {
         return Err(Error::NotFound.into());
     }
@@ -48,40 +62,49 @@ pub fn is_fuchsia_gpt(efi_entry: &EfiEntry) -> Result<()> {
 pub fn fuchsia_boot_demo(efi_entry: EfiEntry) -> Result<()> {
     efi_println!(efi_entry, "Try booting as Fuchsia/Zircon");
 
-    // Allocates buffer for load.
-    let mut load_buffer = vec![0u8; 128 * 1024 * 1024]; // 128MB
-    let (_zbi_items, _kernel, slot) = {
-        let mut blks = find_block_devices(&efi_entry)?;
-        let partitions = &blks.as_gbl_parts()?;
-        let mut ops = Ops { efi_entry: &efi_entry, partitions };
-        zircon_load_verify_abr(&mut ops, &mut load_buffer)?
+    let (mut zbi_items_buffer, mut _kernel_buffer, slot) = {
+        let blks = find_block_devices(&efi_entry)?;
+        let mut ops = Ops::new(&efi_entry, &blks[..], Some(Os::Fuchsia));
+        // Checks whether to enter fastboot mode.
+        if zircon_check_enter_fastboot(&mut ops) {
+            fastboot(&mut ops, &mut [])?;
+        }
+        zircon_load_verify_abr(&mut ops)?
     };
     efi_println!(efi_entry, "Booting from slot: {}", zircon_part_name(Some(slot)));
 
+    let _zbi_items = zbi_items_buffer.used_mut();
+
     #[cfg(target_arch = "aarch64")]
     {
         // Uses the unused buffer for `exit_boot_services` to store output memory map.
         // The map is not used for now. We currently rely on UEFI firmware to pass memory map via
         // an raw zbi blob in device tree. Long term we want to support adding from EFI memory maps
         // if none is provided.
-        let item_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size();
+        let item_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size()?;
         let (_, remains) = _zbi_items.split_at_mut(item_size);
         let _ = efi::exit_boot_services(efi_entry, remains).unwrap();
         // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
         // assume the caller has addressed all safety and security concerns.
-        unsafe { boot::aarch64::jump_zircon_el2_or_lower(_kernel, _zbi_items) };
+        unsafe { boot::aarch64::jump_zircon_el2_or_lower(_kernel_buffer.used_mut(), _zbi_items) };
     }
 
     #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
     {
-        let items_size = zbi::ZbiContainer::parse(&mut _zbi_items[..])?.container_size();
-        let (_, remains) = _zbi_items.split_at_mut(items_size);
+        const BUFFER_SIZE: usize = 32 * 1024 / 2;
+        let mut mem_map_buf = [0u8; BUFFER_SIZE];
+        let mut zbi_items = zbi::ZbiContainer::parse(&mut _zbi_items[..])?;
+        let efi_memory_attribute_table = get_efi_mem_attr(&efi_entry).ok_or(Error::InvalidInput)?;
+
         // `exit_boot_service` returnes EFI memory map that is used to derive and append MEM_CONFIG
         // items.
-        let _ = efi::exit_boot_services(efi_entry, remains).unwrap();
+        let efi_memory_map = efi::exit_boot_services(efi_entry, &mut mem_map_buf).unwrap();
+
+        add_memory_items(&efi_memory_map, &efi_memory_attribute_table, &mut zbi_items)?;
+
         // SAFETY: The kernel has passed libavb verification or device is unlocked, in which case we
         // assume the caller has addressed all safety and security concerns.
-        unsafe { boot::x86::zbi_boot(_kernel, _zbi_items) };
+        unsafe { boot::x86::zbi_boot(_kernel_buffer.used_mut(), _zbi_items) };
     }
 
     #[cfg(target_arch = "riscv64")]
@@ -89,3 +112,153 @@ pub fn fuchsia_boot_demo(efi_entry: EfiEntry) -> Result<()> {
         unimplemented!();
     }
 }
+
+// This function must not use allocation
+#[allow(unused)]
+fn add_memory_items<B>(
+    efi_memory_map: &EfiMemoryMap,
+    efi_memory_attribute_table: &EfiMemoryAttributesTable,
+    zbi_items: &mut ZbiContainer<B>,
+) -> Result<()>
+where
+    B: ByteSliceMut + PartialEq,
+{
+    generate_efi_memory_attributes_table_item(
+        efi_memory_map,
+        efi_memory_attribute_table,
+        zbi_items,
+    )?;
+
+    generate_mem_config_item(efi_memory_map, zbi_items)?;
+
+    Ok(())
+}
+
+fn generate_efi_memory_attributes_table_item<'b, B>(
+    efi_memory_map: &EfiMemoryMap<'b>,
+    efi_memory_attribute_table: &EfiMemoryAttributesTable,
+    zbi_items: &mut ZbiContainer<B>,
+) -> Result<()>
+where
+    B: ByteSliceMut + PartialEq,
+{
+    let payload = zbi_items.get_next_payload()?;
+    let provided_payload_size = payload.len();
+    let (mut header, mut tail) =
+        Ref::<&mut [u8], EfiMemoryAttributesTableHeader>::new_from_prefix(payload)
+            .ok_or(Error::BadBufferSize)?;
+
+    for efi_memory_desc in efi_memory_map.into_iter() {
+        if efi_memory_desc.attributes & EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME == 0 {
+            continue;
+        }
+
+        let mut base = efi_memory_desc.physical_start;
+        let mut size: u64 = (SafeNum::from(efi_memory_desc.number_of_pages) * PAGE_SIZE)
+            .try_into()
+            .map_err(Error::from)?;
+
+        // This EMAT entry is either a sub-region or a full copy of the memory map region, per
+        // EFI 2.10 4.6.4: "Additionally, every memory region described by a Descriptor in
+        // EFI_MEMORY_ATTRIBUTES_TABLE must be a sub-region of, or equal to, a descriptor in the
+        // table produced by GetMemoryMap()."
+        //
+        // This means that we do not have to consider the case where the EMAT entry only overlaps
+        // the end of the memory map entry.
+        //
+        // EMAT items are ordered by physical address, so once we go past |base| we can quit the
+        // loop.
+        for emat_item in efi_memory_attribute_table
+            .into_iter()
+            .skip_while(move |item| item.physical_start < base)
+            .take_while(move |item| item.physical_start < base + size)
+        {
+            if emat_item.physical_start > base {
+                // Create a region for [base ... emat_item->PhysicalStart), because that region is
+                // not covered by the EMAT.
+                let mut generated_item;
+                (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
+                    .ok_or(UnificationError(BufferTooSmall(Some(
+                        size_of::<EfiMemoryDescriptor>(),
+                    ))))?;
+
+                generated_item.physical_start = base;
+                generated_item.number_of_pages = (emat_item.physical_start - base) / PAGE_SIZE;
+                generated_item.virtual_start = 0;
+                generated_item.attributes = EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME;
+                generated_item.memory_type = emat_item.memory_type;
+
+                // Adjust base and size forward.
+                size -= emat_item.physical_start - base;
+                base = emat_item.physical_start;
+            } else {
+                // emat_item.physical_start == base
+                // Create a region for [base ... emat_item->NumberOfPages * PAGE_SIZE)
+                let mut generated_item;
+                (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
+                    .ok_or(UnificationError(BufferTooSmall(Some(
+                        size_of::<EfiMemoryDescriptor>(),
+                    ))))?;
+                *generated_item = *emat_item;
+
+                // Adjust base and size forward.
+                base += emat_item.number_of_pages * PAGE_SIZE;
+                size -= emat_item.number_of_pages * PAGE_SIZE;
+            }
+        }
+
+        if size != 0 {
+            let mut generated_item;
+            (generated_item, tail) = Ref::<_, EfiMemoryDescriptor>::new_from_prefix(tail)
+                .ok_or(UnificationError(BufferTooSmall(Some(size_of::<EfiMemoryDescriptor>()))))?;
+
+            generated_item.physical_start = base;
+            generated_item.number_of_pages = size / PAGE_SIZE;
+            generated_item.virtual_start = 0;
+            generated_item.attributes = EFI_MEMORY_ATTRIBUTE_EMA_RUNTIME;
+            generated_item.memory_type = efi_memory_desc.memory_type;
+        }
+    }
+
+    let used_payload = provided_payload_size - tail.len();
+    header.descriptor_size = size_of::<EfiMemoryDescriptor>().try_into().map_err(Error::from)?;
+    header.number_of_entries =
+        (used_payload / size_of::<EfiMemoryDescriptor>()).try_into().unwrap();
+    header.reserved = 0;
+    header.version = 1;
+
+    zbi_items.create_entry(
+        ZbiType::EfiMemoryAttributesTable,
+        0,
+        ZbiFlags::default(),
+        used_payload,
+    )?;
+
+    Ok(())
+}
+
+fn generate_mem_config_item<'b, B>(
+    efi_memory_map: &EfiMemoryMap<'b>,
+    zbi_items: &mut ZbiContainer<B>,
+) -> Result<()>
+where
+    B: ByteSliceMut + PartialEq,
+{
+    let mut tail = zbi_items.get_next_payload()?;
+    let provided_payload_size = tail.len();
+
+    for efi_desc in efi_memory_map.into_iter() {
+        let mut zbi_mem_range: Ref<&mut [u8], zbi_mem_range_t>;
+        (zbi_mem_range, tail) = Ref::new_from_prefix(tail)
+            .ok_or(UnificationError(BufferTooSmall(Some(size_of::<zbi_mem_range_t>()))))?;
+        zbi_mem_range.paddr = efi_desc.physical_start;
+        zbi_mem_range.length = efi_desc.number_of_pages * PAGE_SIZE;
+        zbi_mem_range.type_ = efi_to_zbi_mem_range_type(efi_desc.memory_type);
+        zbi_mem_range.reserved = 0;
+    }
+
+    let used_payload = provided_payload_size - tail.len();
+    zbi_items.create_entry(ZbiType::MemConfig, 0, ZbiFlags::default(), used_payload)?;
+
+    Ok(())
+}
diff --git a/gbl/efi/src/lib.rs b/gbl/efi/src/lib.rs
index 9ee0155..d4313ba 100644
--- a/gbl/efi/src/lib.rs
+++ b/gbl/efi/src/lib.rs
@@ -36,8 +36,6 @@ mod utils;
 #[cfg(not(test))]
 mod android_boot;
 #[cfg(not(test))]
-mod avb;
-#[cfg(not(test))]
 mod fastboot;
 #[cfg(not(test))]
 mod fuchsia_boot;
@@ -55,7 +53,7 @@ pub(crate) use efi_mocks as efi;
 use {
     core::fmt::Write,
     efi::{efi_print, efi_println, EfiEntry},
-    libgbl::{GblOps, Result},
+    libgbl::Result,
     utils::loaded_image_path,
 };
 
@@ -68,15 +66,23 @@ enum TargetOs {
 #[cfg(not(test))]
 fn get_target_os(entry: &EfiEntry) -> TargetOs {
     let mut buf = [0u8; 1];
-    if fuchsia_boot::is_fuchsia_gpt(&entry).is_ok()
-        || entry
-            .system_table()
-            .runtime_services()
-            .get_variable(&efi::GBL_EFI_VENDOR_GUID, efi::GBL_EFI_OS_BOOT_TARGET_VARNAME, &mut buf)
-            .is_ok()
+    if entry
+        .system_table()
+        .runtime_services()
+        .get_variable(&efi::GBL_EFI_VENDOR_GUID, efi::GBL_EFI_OS_BOOT_TARGET_VARNAME, &mut buf)
+        .is_ok()
     {
+        efi_println!(
+            entry,
+            "`{}` is set. Proceeding as Fuchsia.",
+            efi::GBL_EFI_OS_BOOT_TARGET_VARNAME
+        );
+        TargetOs::Fuchsia
+    } else if fuchsia_boot::is_fuchsia_gpt(&entry).is_ok() {
+        efi_println!(entry, "Partition layout looks like Fuchsia. Proceeding as Fuchsia");
         TargetOs::Fuchsia
     } else {
+        efi_println!(entry, "Proceeding as Android");
         TargetOs::Android
     }
 }
@@ -84,24 +90,11 @@ fn get_target_os(entry: &EfiEntry) -> TargetOs {
 /// GBL EFI application logic entry point.
 #[cfg(not(test))]
 pub fn app_main(entry: EfiEntry) -> Result<()> {
-    let mut ops = ops::Ops { efi_entry: &entry, partitions: &[] };
-
-    efi_println!(entry, "****Rust EFI Application****");
+    efi_println!(entry, "****Generic Bootloader Application****");
     if let Ok(v) = loaded_image_path(&entry) {
         efi_println!(entry, "Image path: {}", v);
     }
 
-    match ops.should_stop_in_fastboot() {
-        Ok(true) => {
-            fastboot::fastboot(&entry)?;
-        }
-        Ok(false) => {}
-        Err(e) => {
-            efi_println!(entry, "Warning: error while checking fastboot trigger ({:?})", e);
-            efi_println!(entry, "Ignoring error and continuing with normal boot");
-        }
-    }
-
     match get_target_os(&entry) {
         TargetOs::Fuchsia => fuchsia_boot::fuchsia_boot_demo(entry)?,
         TargetOs::Android => android_boot::android_boot_demo(entry)?,
diff --git a/gbl/efi/src/net.rs b/gbl/efi/src/net.rs
index d6f32e4..ef668b7 100644
--- a/gbl/efi/src/net.rs
+++ b/gbl/efi/src/net.rs
@@ -12,8 +12,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::error::{listen_to_unified, recv_to_unified, send_to_unified};
-use crate::utils::{get_device_path, loop_with_timeout};
+use crate::{
+    error::{listen_to_unified, recv_to_unified, send_to_unified},
+    utils::{get_device_path, loop_with_timeout},
+};
 use alloc::{boxed::Box, vec::Vec};
 use core::{
     fmt::Write,
@@ -23,22 +25,25 @@ use efi::{
     efi_print, efi_println,
     protocol::{simple_network::SimpleNetworkProtocol, Protocol},
     utils::{ms_to_100ns, Timeout},
-    DeviceHandle, EfiEntry, EventNotify, EventType, Tpl,
+    DeviceHandle, EfiEntry, Event, EventNotify, EventType, Tpl,
 };
 use efi_types::{EfiEvent, EfiMacAddress, EFI_TIMER_DELAY_TIMER_PERIODIC};
 use gbl_async::{yield_now, YieldCounter};
 use liberror::{Error, Result};
+use libgbl::fastboot::fuchsia_fastboot_mdns_packet;
 use smoltcp::{
-    iface::{Config, Interface, SocketSet},
+    iface::{Config, Interface, SocketSet, SocketStorage},
     phy,
     phy::{Device, DeviceCapabilities, Medium},
-    socket::tcp,
+    socket::{
+        tcp::{Socket as TcpSocket, SocketBuffer, State},
+        udp::{PacketBuffer, Socket as UdpSocket, UdpMetadata},
+    },
+    storage::PacketMetadata,
     time::Instant,
-    wire::{EthernetAddress, IpAddress, IpCidr, Ipv6Address},
+    wire::{EthernetAddress, IpAddress, IpCidr, IpListenEndpoint, Ipv6Address},
 };
 
-/// Maintains a timestamp needed by smoltcp network. It's updated periodically during timer event.
-static NETWORK_TIMESTAMP: AtomicU64 = AtomicU64::new(0);
 /// Ethernet frame size for frame pool.
 const ETHERNET_FRAME_SIZE: usize = 1536;
 // Update period in milliseconds for `NETWORK_TIMESTAMP`.
@@ -106,7 +111,7 @@ impl Drop for EfiNetworkDevice<'_> {
             // SAFETY:
             // Each pointer is created by `Box::new()` in `EfiNetworkDevice::new()`. Thus the
             // pointer is valid and layout matches.
-            let _ = unsafe { Box::from_raw(v) };
+            drop(unsafe { Box::<[u8; ETHERNET_FRAME_SIZE]>::from_raw(*v) });
         });
     }
 }
@@ -254,16 +259,6 @@ impl phy::TxToken for TxToken<'_, '_> {
     }
 }
 
-/// Returns the current value of timestamp.
-fn timestamp() -> u64 {
-    NETWORK_TIMESTAMP.load(Ordering::Relaxed)
-}
-
-/// Returns a smoltcp time `Instant` value.
-fn time_instant() -> Instant {
-    Instant::from_millis(i64::try_from(timestamp()).unwrap())
-}
-
 /// Find the first available network device.
 fn find_net_device(efi_entry: &EfiEntry) -> Result<DeviceHandle> {
     // Find the device whose path is the "smallest" lexicographically, this ensures that it's not
@@ -309,11 +304,15 @@ fn ll_mac_ip6_addr_from_efi_mac(mac: EfiMacAddress) -> (EthernetAddress, IpAddre
 
 /// `EfiTcpSocket` groups together necessary components for performing TCP.
 pub struct EfiTcpSocket<'a, 'b> {
+    pub(crate) efi_entry: &'a EfiEntry,
     efi_net_dev: &'b mut EfiNetworkDevice<'a>,
-    interface: &'b mut Interface,
-    sockets: &'b mut SocketSet<'b>,
-    efi_entry: &'a EfiEntry,
+    interface: Interface,
+    socket_set: SocketSet<'b>,
     io_yield_counter: YieldCounter,
+    last_listen_timestamp: Option<u64>,
+    _time_update_event: Event<'a, 'b>,
+    timestamp: &'b AtomicU64,
+    fuchsia_fastboot_mdns_packet: Vec<u8>,
 }
 
 impl<'a, 'b> EfiTcpSocket<'a, 'b> {
@@ -321,12 +320,24 @@ impl<'a, 'b> EfiTcpSocket<'a, 'b> {
     pub fn listen(&mut self, port: u16) -> Result<()> {
         self.get_socket().abort();
         self.get_socket().listen(port).map_err(listen_to_unified)?;
+        self.last_listen_timestamp = Some(self.timestamp(0));
         Ok(())
     }
 
+    // Checks if the socket is listening or performing handshake.
+    pub fn is_listening_or_handshaking(&mut self) -> bool {
+        matches!(self.get_socket().state(), State::Listen | State::SynReceived)
+    }
+
+    /// Returns the amount of time elapsed since last call to `Self::listen()`. If `listen()` has
+    /// never been called, `u64::MAX` is returned.
+    pub fn time_since_last_listen(&mut self) -> u64 {
+        self.last_listen_timestamp.map(|v| self.timestamp(v)).unwrap_or(u64::MAX)
+    }
+
     /// Polls network device.
     pub fn poll(&mut self) {
-        self.interface.poll(time_instant(), self.efi_net_dev, self.sockets);
+        self.interface.poll(self.instant(), self.efi_net_dev, &mut self.socket_set);
     }
 
     /// Polls network and check if the socket is in an active state.
@@ -336,15 +347,15 @@ impl<'a, 'b> EfiTcpSocket<'a, 'b> {
     }
 
     /// Gets a reference to the smoltcp socket object.
-    pub fn get_socket(&mut self) -> &mut tcp::Socket<'b> {
+    pub fn get_socket(&mut self) -> &mut TcpSocket<'b> {
         // We only consider single socket use case for now.
-        let handle = self.sockets.iter().next().unwrap().0;
-        self.sockets.get_mut::<tcp::Socket>(handle)
+        let handle = self.socket_set.iter().next().unwrap().0;
+        self.socket_set.get_mut::<TcpSocket>(handle)
     }
 
     /// Checks whether a socket is closed.
     fn is_closed(&mut self) -> bool {
-        return !self.get_socket().is_open() || self.get_socket().state() == tcp::State::CloseWait;
+        return !self.get_socket().is_open() || self.get_socket().state() == State::CloseWait;
     }
 
     /// Sets the maximum number of bytes to read or write before a force await.
@@ -423,85 +434,223 @@ impl<'a, 'b> EfiTcpSocket<'a, 'b> {
 
     /// Gets the smoltcp `Interface` for this socket.
     pub fn interface(&self) -> &Interface {
-        self.interface
+        &self.interface
     }
 
     /// Returns the number of milliseconds elapsed since the `base` timestamp.
-    pub fn timestamp(base: u64) -> u64 {
-        let curr = timestamp();
+    pub fn timestamp(&self, base: u64) -> u64 {
+        let curr = self.timestamp.load(Ordering::Relaxed);
         // Assume there can be at most one overflow.
         match curr < base {
             true => u64::MAX - (base - curr),
             false => curr - base,
         }
     }
+
+    /// Returns a smoltcp time `Instant` value.
+    fn instant(&self) -> Instant {
+        to_smoltcp_instant(self.timestamp(0))
+    }
+
+    /// Broadcasts Fuchsia Fastboot MDNS service once.
+    pub fn broadcast_fuchsia_fastboot_mdns(&mut self) {
+        const MDNS_PORT: u16 = 5353;
+        const IP6_BROADCAST_ADDR: &[u8] =
+            &[0xFF, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFB];
+        let ip6_broadcast = Ipv6Address::from_bytes(&IP6_BROADCAST_ADDR[..]);
+        let meta =
+            UdpMetadata { endpoint: (ip6_broadcast, MDNS_PORT).into(), meta: Default::default() };
+        let handle = self.socket_set.iter().nth(1).unwrap().0;
+        let socket = self.socket_set.get_mut::<UdpSocket>(handle);
+        if !socket.is_open() {
+            match socket.bind(IpListenEndpoint { addr: None, port: MDNS_PORT }) {
+                Err(e) => efi_println!(self.efi_entry, "bind error: {:?}", e),
+                _ => {}
+            }
+        }
+        if socket.can_send() {
+            match socket.send_slice(&self.fuchsia_fastboot_mdns_packet, meta) {
+                Err(e) => efi_println!(self.efi_entry, "UDP send error: {:?}", e),
+                _ => {}
+            }
+        }
+    }
 }
 
-/// Initializes network environment and provides a TCP socket for callers to run a closure. The API
-/// handles clean up automatically after returning.
-pub fn with_efi_network<F, R>(efi_entry: &EfiEntry, mut f: F) -> Result<R>
-where
-    F: FnMut(&mut EfiTcpSocket) -> R,
-{
-    let bs = efi_entry.system_table().boot_services();
-
-    // Creates timestamp update event.
-    let _ = NETWORK_TIMESTAMP.swap(0, Ordering::Relaxed);
-    let mut notify_fn = |_: EfiEvent| {
-        NETWORK_TIMESTAMP.fetch_add(NETWORK_TIMESTAMP_UPDATE_PERIOD, Ordering::Relaxed);
-    };
-    let mut notify = EventNotify::new(Tpl::Callback, &mut notify_fn);
-    // SAFETY: the notification callback never allocates, deallocates, or panics.
-    let timer =
-        unsafe { bs.create_event_with_notification(EventType::TimerNotifySignal, &mut notify) }?;
-    bs.set_timer(
-        &timer,
-        EFI_TIMER_DELAY_TIMER_PERIODIC,
-        ms_to_100ns(NETWORK_TIMESTAMP_UPDATE_PERIOD)?,
-    )?;
-
-    // Creates and initializes simple network protocol.
-    let snp_dev = find_net_device(efi_entry)?;
-    let snp = bs.open_protocol::<SimpleNetworkProtocol>(snp_dev)?;
-    reset_simple_network(&snp)?;
-
-    // The TCP stack requires ICMP6 solicitation for discovery. Enable promiscuous mode so that all
-    // uni/multicast packets can be captured.
-    match snp.set_promiscuous_mode() {
-        Err(e) => efi_println!(
+/// Returns a smoltcp time `Instant` value from a u64 timestamp.
+fn to_smoltcp_instant(ts: u64) -> Instant {
+    Instant::from_millis(i64::try_from(ts).unwrap())
+}
+
+/// Internal type that contains net driver interfaces and buffers for creating GBL network and
+/// sockets.
+///
+/// # Lifetimes
+///
+/// * `'a`: Lifetime of [EfiEntry] borrowed.
+/// * `'b`: Lifetime of [SocketStorage<'b>], which eventually refers to Self.
+/// * `'c`: Lifetime of [AtomicU64] borrowed.
+struct EfiGblNetworkInternal<'a, 'b, 'c> {
+    efi_entry: &'a EfiEntry,
+    tcp_tx_buffer: Vec<u8>,
+    tcp_rx_buffer: Vec<u8>,
+    udp_tx_payload_buffer: Vec<u8>,
+    udp_rx_payload_buffer: Vec<u8>,
+    udp_tx_metadata_buffer: Vec<PacketMetadata<UdpMetadata>>,
+    udp_rx_metadata_buffer: Vec<PacketMetadata<UdpMetadata>>,
+    socket_storage: [SocketStorage<'b>; 2],
+    efi_net_dev: EfiNetworkDevice<'a>,
+    timestamp: &'c AtomicU64,
+    notify_fn: Option<Box<dyn FnMut(EfiEvent) + Sync + 'c>>,
+    notify: Option<EventNotify<'b>>,
+}
+
+impl<'a, 'b, 'c> EfiGblNetworkInternal<'a, 'b, 'c> {
+    /// Creates a new instance of [EfiGblNetworkInternal].
+    fn new(efi_entry: &'a EfiEntry, timestamp: &'c AtomicU64) -> Result<Self> {
+        // Creates and initializes simple network protocol.
+        let snp_dev = find_net_device(efi_entry)?;
+        let snp = efi_entry
+            .system_table()
+            .boot_services()
+            .open_protocol::<SimpleNetworkProtocol>(snp_dev)?;
+        reset_simple_network(&snp)?;
+
+        // The TCP stack requires ICMP6 solicitation for discovery. Enable promiscuous mode so that
+        // all uni/multicast packets can be captured.
+        match snp.set_promiscuous_mode() {
+            Err(e) => efi_println!(
+                efi_entry,
+                "Warning: Failed to set promiscuous mode {e:?}. Device may be undiscoverable",
+            ),
+            _ => {}
+        }
+
+        Ok(Self {
             efi_entry,
-            "Warning: Failed to set promiscuous mode {e:?}. Device may be undiscoverable",
-        ),
-        _ => {}
+            tcp_tx_buffer: vec![0u8; SOCKET_TX_RX_BUFFER],
+            tcp_rx_buffer: vec![0u8; SOCKET_TX_RX_BUFFER],
+            udp_tx_payload_buffer: vec![0u8; ETHERNET_FRAME_SIZE],
+            udp_rx_payload_buffer: vec![0u8; ETHERNET_FRAME_SIZE],
+            udp_tx_metadata_buffer: vec![PacketMetadata::EMPTY; 1],
+            udp_rx_metadata_buffer: vec![PacketMetadata::EMPTY; 1],
+            socket_storage: Default::default(),
+            // Allocates 7(chosen randomly) extra TX frames. Revisits if it is not enough.
+            efi_net_dev: EfiNetworkDevice::new(snp, 7, &efi_entry),
+            timestamp,
+            notify_fn: None,
+            notify: None,
+        })
     }
 
-    // Gets our MAC address and IPv6 address.
-    // We can also consider getting this from vendor configuration.
-    let (ll_mac, ll_ip6_addr) = ll_mac_ip6_addr_from_efi_mac(snp.mode()?.current_address);
-
-    // Creates an `EfiNetworkDevice`.
-    // Allocates 7(chosen randomly) extra TX frames. Revisits if it is not enough.
-    let mut efi_net_dev = EfiNetworkDevice::new(snp, 7, &efi_entry);
-    // Configures smoltcp network interface.
-    let mut interface =
-        Interface::new(Config::new(ll_mac.into()), &mut efi_net_dev, time_instant());
-    interface.update_ip_addrs(|ip_addrs| ip_addrs.push(IpCidr::new(ll_ip6_addr, 64)).unwrap());
-    // Creates an instance of socket.
-    let mut tx_buffer = vec![0u8; SOCKET_TX_RX_BUFFER];
-    let mut rx_buffer = vec![0u8; SOCKET_TX_RX_BUFFER];
-    let tx_socket_buffer = tcp::SocketBuffer::new(&mut tx_buffer[..]);
-    let rx_socket_buffer = tcp::SocketBuffer::new(&mut rx_buffer[..]);
-    let socket = tcp::Socket::new(rx_socket_buffer, tx_socket_buffer);
-    let mut sockets: [_; 1] = Default::default();
-    let mut sockets = SocketSet::new(&mut sockets[..]);
-    let _ = sockets.add(socket);
-    let mut socket = EfiTcpSocket {
-        efi_net_dev: &mut efi_net_dev,
-        interface: &mut interface,
-        sockets: &mut sockets,
-        efi_entry: efi_entry,
-        io_yield_counter: YieldCounter::new(u64::MAX),
-    };
+    /// Creates an instance of [EfiTcpSocket].
+    fn create_socket(&'b mut self) -> Result<EfiTcpSocket<'a, 'b>> {
+        // Resets network timestamp to 0.
+        let _ = self.timestamp.swap(0, Ordering::Relaxed);
+
+        // Initializes notification functions.
+        if self.notify_fn.is_none() {
+            self.notify_fn = Some(Box::new(|_: EfiEvent| {
+                self.timestamp.fetch_add(NETWORK_TIMESTAMP_UPDATE_PERIOD, Ordering::Relaxed);
+            }));
+            self.notify = Some(EventNotify::new(Tpl::Callback, self.notify_fn.as_mut().unwrap()));
+        }
 
-    Ok(f(&mut socket))
+        // Creates a timer event for updating the global timestamp.
+        let bs = self.efi_entry.system_table().boot_services();
+        // SAFETY: the notification callback in `notify_fn` initialized above never allocates,
+        // deallocates, or panics.
+        let _time_update_event = unsafe {
+            bs.create_event_with_notification(
+                EventType::TimerNotifySignal,
+                self.notify.as_mut().unwrap(),
+            )
+        }?;
+        bs.set_timer(
+            &_time_update_event,
+            EFI_TIMER_DELAY_TIMER_PERIODIC,
+            ms_to_100ns(NETWORK_TIMESTAMP_UPDATE_PERIOD)?,
+        )?;
+
+        // Gets our MAC address and IPv6 address.
+        // We can also consider getting this from vendor configuration.
+        let (ll_mac, ll_ip6_addr) =
+            ll_mac_ip6_addr_from_efi_mac(self.efi_net_dev.protocol.mode()?.current_address);
+        // Configures smoltcp network interface.
+        let mut interface = Interface::new(
+            Config::new(ll_mac.into()),
+            &mut self.efi_net_dev,
+            to_smoltcp_instant(0),
+        );
+        interface.update_ip_addrs(|ip_addrs| ip_addrs.push(IpCidr::new(ll_ip6_addr, 64)).unwrap());
+
+        // Generates Fuchsia Fastboot MDNS packet.
+        let eth_mac = ll_mac.as_bytes();
+        let fuchsia_node_name = format!(
+            "fuchsia-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}",
+            eth_mac[0], eth_mac[1], eth_mac[2], eth_mac[3], eth_mac[4], eth_mac[5]
+        );
+        let fuchsia_fastboot_mdns_packet =
+            fuchsia_fastboot_mdns_packet(fuchsia_node_name.as_str(), ll_ip6_addr.as_bytes())?
+                .into();
+
+        // Creates sockets.
+        let mut socket_set = SocketSet::new(&mut self.socket_storage[..]);
+        // Creates a TCP socket for fastboot over TCP.
+        let tx_socket_buffer = SocketBuffer::new(&mut self.tcp_tx_buffer[..]);
+        let rx_socket_buffer = SocketBuffer::new(&mut self.tcp_rx_buffer[..]);
+        let tcp_socket = TcpSocket::new(rx_socket_buffer, tx_socket_buffer);
+        let _ = socket_set.add(tcp_socket);
+        // Creates a UDP socket for MDNS broadcast.
+        let udp_tx_packet_buffer = PacketBuffer::new(
+            &mut self.udp_tx_metadata_buffer[..],
+            &mut self.udp_tx_payload_buffer[..],
+        );
+        let udp_rx_packet_buffer = PacketBuffer::new(
+            &mut self.udp_rx_metadata_buffer[..],
+            &mut self.udp_rx_payload_buffer[..],
+        );
+        let udp_socket = UdpSocket::new(udp_rx_packet_buffer, udp_tx_packet_buffer);
+        let _ = socket_set.add(udp_socket);
+        Ok(EfiTcpSocket {
+            efi_entry: self.efi_entry,
+            efi_net_dev: &mut self.efi_net_dev,
+            interface,
+            socket_set,
+            io_yield_counter: YieldCounter::new(u64::MAX),
+            last_listen_timestamp: None,
+            _time_update_event,
+            timestamp: self.timestamp,
+            fuchsia_fastboot_mdns_packet,
+        })
+    }
+}
+
+/// The GBL network stack.
+///
+/// # Lifetimes
+///
+/// * `'a`: Lifetime of `efi_entry` borrowed.
+/// * `'b`: Lifetime of Self.
+/// * `'c`: Lifetime of external timestamp borrowed.
+#[derive(Default)]
+pub struct EfiGblNetwork<'a, 'b, 'c>(Option<EfiGblNetworkInternal<'a, 'b, 'c>>);
+
+impl<'a, 'b, 'c: 'b> EfiGblNetwork<'a, 'b, 'c> {
+    /// Initializes GBL network and creates GBL sockets.
+    ///
+    /// # Args:
+    ///
+    /// * `efi_entry`: A [EfiEntry].
+    /// * `ts`: A reference to an [AtomicU64].
+    pub fn init(
+        &'b mut self,
+        efi_entry: &'a EfiEntry,
+        timestamp: &'c AtomicU64,
+    ) -> Result<EfiTcpSocket<'a, 'b>> {
+        // Drops any existing network first to release the global event notify function.
+        self.0 = None;
+        self.0 = Some(EfiGblNetworkInternal::new(efi_entry, timestamp)?);
+        self.0.as_mut().unwrap().create_socket()
+    }
 }
diff --git a/gbl/efi/src/ops.rs b/gbl/efi/src/ops.rs
index 1cc2b80..f3ab74c 100644
--- a/gbl/efi/src/ops.rs
+++ b/gbl/efi/src/ops.rs
@@ -16,33 +16,137 @@
 
 use crate::{
     efi,
-    efi_blocks::EfiBlockDeviceIo,
+    efi_blocks::EfiGblDisk,
     utils::{get_efi_fdt, wait_key_stroke},
 };
-use alloc::alloc::{alloc, handle_alloc_error, Layout};
-use core::{ffi::CStr, fmt::Write, mem::MaybeUninit, num::NonZeroUsize, slice::from_raw_parts_mut};
+use alloc::{
+    alloc::{alloc, handle_alloc_error, Layout},
+    vec::Vec,
+};
+use arrayvec::ArrayVec;
+use core::{
+    cmp::min, ffi::CStr, fmt::Write, mem::MaybeUninit, num::NonZeroUsize, ops::DerefMut, ptr::null,
+    slice::from_raw_parts_mut,
+};
 use efi::{
-    efi_print, efi_println, protocol::gbl_efi_image_loading::GblImageLoadingProtocol, EfiEntry,
+    efi_print, efi_println,
+    protocol::{
+        dt_fixup::DtFixupProtocol, gbl_efi_ab_slot::GblSlotProtocol, gbl_efi_avb::GblAvbProtocol,
+        gbl_efi_fastboot::GblFastbootProtocol, gbl_efi_image_loading::GblImageLoadingProtocol,
+        gbl_efi_os_configuration::GblOsConfigurationProtocol,
+    },
+    EfiEntry,
+};
+use efi_types::{
+    GblEfiAvbKeyValidationStatus, GblEfiAvbVerificationResult, GblEfiBootReason,
+    GblEfiDeviceTreeMetadata, GblEfiImageInfo, GblEfiVerifiedDeviceTree,
+    GBL_EFI_BOOT_REASON_BOOTLOADER, GBL_EFI_BOOT_REASON_COLD, GBL_EFI_BOOT_REASON_FASTBOOTD,
+    GBL_EFI_BOOT_REASON_RECOVERY, PARTITION_NAME_LEN_U16,
 };
-use efi_types::{GblEfiImageInfo, PARTITION_NAME_LEN_U16};
 use fdt::Fdt;
-use liberror::Error;
+use gbl_storage::{BlockIo, Disk, Gpt, SliceMaybeUninit};
+use liberror::{Error, Result};
 use libgbl::{
-    ops::{AvbIoError, AvbIoResult, CertPermanentAttributes, ImageBuffer, SHA256_DIGEST_SIZE},
-    partition::PartitionBlockDevice,
+    constants::{ImageName, BOOTCMD_SIZE},
+    device_tree::{
+        DeviceTreeComponent, DeviceTreeComponentSource, DeviceTreeComponentsRegistry,
+        MAXIMUM_DEVICE_TREE_COMPONENTS,
+    },
+    gbl_avb::state::{BootStateColor, KeyValidationStatus},
+    ops::{
+        AvbIoError, AvbIoResult, CertPermanentAttributes, ImageBuffer, RebootReason, Slot,
+        SlotsMetadata, SHA256_DIGEST_SIZE,
+    },
+    partition::GblDisk,
     slots::{BootToken, Cursor},
-    BootImages, GblOps, Result as GblResult,
+    GblOps, Os, Result as GblResult,
 };
 use safemath::SafeNum;
 use zbi::ZbiContainer;
 use zerocopy::AsBytes;
 
+fn to_avb_validation_status_or_panic(status: GblEfiAvbKeyValidationStatus) -> KeyValidationStatus {
+    match status {
+        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID => KeyValidationStatus::Valid,
+        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY => {
+            KeyValidationStatus::ValidCustomKey
+        }
+        efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID => KeyValidationStatus::Invalid,
+        _ => panic!("Unrecognized avb key validation status: {}", status),
+    }
+}
+
+fn avb_color_to_efi_color(color: BootStateColor) -> u32 {
+    match color {
+        BootStateColor::Green => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_GREEN,
+        BootStateColor::Yellow => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_YELLOW,
+        BootStateColor::Orange => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_ORANGE,
+        BootStateColor::RedEio => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED_EIO,
+        BootStateColor::Red => efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED,
+    }
+}
+
+fn dt_component_to_efi_dt(component: &DeviceTreeComponent) -> GblEfiVerifiedDeviceTree {
+    let metadata = match component.source {
+        DeviceTreeComponentSource::Dtb(m) | DeviceTreeComponentSource::Dtbo(m) => m,
+        _ => Default::default(),
+    };
+
+    GblEfiVerifiedDeviceTree {
+        metadata: GblEfiDeviceTreeMetadata {
+            source: match component.source {
+                DeviceTreeComponentSource::Boot => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_BOOT,
+                DeviceTreeComponentSource::VendorBoot => {
+                    efi_types::GBL_EFI_DEVICE_TREE_SOURCE_VENDOR_BOOT
+                }
+                DeviceTreeComponentSource::Dtb(_) => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_DTB,
+                DeviceTreeComponentSource::Dtbo(_) => efi_types::GBL_EFI_DEVICE_TREE_SOURCE_DTBO,
+            },
+            id: metadata.id,
+            rev: metadata.rev,
+            custom: metadata.custom,
+            reserved: Default::default(),
+        },
+        device_tree: component.dt.as_ptr() as _,
+        selected: component.selected,
+    }
+}
+
+fn efi_error_to_avb_error(error: Error) -> AvbIoError {
+    match error {
+        // EFI_STATUS_OUT_OF_RESOURCES
+        Error::OutOfResources => AvbIoError::Oom,
+        // EFI_STATUS_DEVICE_ERROR
+        Error::DeviceError => AvbIoError::Io,
+        // EFI_STATUS_NOT_FOUND
+        Error::NotFound => AvbIoError::NoSuchValue,
+        // EFI_STATUS_END_OF_FILE
+        Error::EndOfFile => AvbIoError::RangeOutsidePartition,
+        // EFI_STATUS_INVALID_PARAMETER
+        Error::InvalidInput => AvbIoError::InvalidValueSize,
+        // EFI_STATUS_BUFFER_TOO_SMALL
+        Error::BufferTooSmall(required) => {
+            AvbIoError::InsufficientSpace(required.unwrap_or_default())
+        }
+        // EFI_STATUS_UNSUPPORTED
+        Error::Unsupported => AvbIoError::NotImplemented,
+        _ => AvbIoError::NotImplemented,
+    }
+}
+
 pub struct Ops<'a, 'b> {
     pub efi_entry: &'a EfiEntry,
-    pub partitions: &'b [PartitionBlockDevice<'b, &'b mut EfiBlockDeviceIo<'a>>],
+    pub disks: &'b [EfiGblDisk<'a>],
+    pub zbi_bootloader_files_buffer: Vec<u8>,
+    pub os: Option<Os>,
 }
 
-impl<'a> Ops<'a, '_> {
+impl<'a, 'b> Ops<'a, 'b> {
+    /// Creates a new instance of [Ops]
+    pub fn new(efi_entry: &'a EfiEntry, disks: &'b [EfiGblDisk<'a>], os: Option<Os>) -> Self {
+        Self { efi_entry, disks, zbi_bootloader_files_buffer: Default::default(), os }
+    }
+
     /// Gets the property of an FDT node from EFI FDT.
     ///
     /// Returns `None` if fail to get the node
@@ -90,7 +194,6 @@ impl<'a> Ops<'a, '_> {
     /// Uses provided allocator.
     ///
     /// # Arguments
-    /// * `efi_entry` - EFI entry
     /// * `image_name` - image name to differentiate the buffer properties
     /// * `size` - requested buffer size
     ///
@@ -101,29 +204,14 @@ impl<'a> Ops<'a, '_> {
     // Allocated buffer is leaked intentionally. ImageBuffer is assumed to reference static memory.
     // ImageBuffer is not expected to be released, and is allocated to hold data necessary for next
     // boot stage (kernel boot). All allocated buffers are expected to be used by kernel.
-    fn allocate_image_buffer(
-        image_name: &str,
-        size: NonZeroUsize,
-    ) -> liberror::Result<ImageBuffer<'static>> {
-        const KERNEL_ALIGNMENT: usize = 2 * 1024 * 1024;
-        const FDT_ALIGNMENT: usize = 8;
-        const BOOTCMD_SIZE: usize = 16 * 1024;
+    fn allocate_image_buffer(image_name: &str, size: NonZeroUsize) -> Result<ImageBuffer<'static>> {
         let size = match image_name {
-            "boot" => size.get(),
             "ramdisk" => (SafeNum::from(size.get()) + BOOTCMD_SIZE).try_into()?,
             _ => size.get(),
         };
         // Check for `from_raw_parts_mut()` safety requirements.
         assert!(size < isize::MAX.try_into().unwrap());
-        let align = match image_name {
-            "boot" => KERNEL_ALIGNMENT,
-            "fdt" => FDT_ALIGNMENT,
-            _ => 1,
-        };
-
-        if size == 0 {
-            return Err(Error::Other(Some("allocate_image_buffer() expects non zero size")));
-        }
+        let align = ImageName::try_from(image_name).map(|i| i.alignment()).unwrap_or(1);
 
         let layout = Layout::from_size_align(size, align).or(Err(Error::InvalidAlignment))?;
         // SAFETY:
@@ -159,12 +247,7 @@ impl Write for Ops<'_, '_> {
     }
 }
 
-impl<'a, 'b> GblOps<'b> for Ops<'a, 'b>
-where
-    Self: 'b,
-{
-    type PartitionBlockIo = &'b mut EfiBlockDeviceIo<'a>;
-
+impl<'a, 'b, 'd> GblOps<'b, 'd> for Ops<'a, 'b> {
     fn console_out(&mut self) -> Option<&mut dyn Write> {
         Some(self)
     }
@@ -174,9 +257,16 @@ where
         "\r\n"
     }
 
-    fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
+    fn should_stop_in_fastboot(&mut self) -> Result<bool> {
         // TODO(b/349829690): also query GblSlotProtocol.get_boot_reason() for board-specific
         // fastboot triggers.
+
+        // TODO(b/366520234): Switch to use GblSlotProtocol.should_stop_in_fastboot once available.
+        match self.get_efi_fdt_prop("gbl", c"stop-in-fastboot") {
+            Some(v) => return Ok(*v.get(0).unwrap_or(&0) == 1),
+            _ => {}
+        }
+
         efi_println!(self.efi_entry, "Press Backspace to enter fastboot");
         let found = wait_key_stroke(
             self.efi_entry,
@@ -190,18 +280,28 @@ where
         found.or(Err(Error::Other(Some("wait for key stroke error"))))
     }
 
-    fn preboot(&mut self, _: BootImages) -> Result<(), Error> {
-        unimplemented!();
+    /// Reboots the system into the last set boot mode.
+    fn reboot(&mut self) {
+        self.efi_entry.system_table().runtime_services().cold_reset();
     }
 
-    fn partitions(&self) -> Result<&'b [PartitionBlockDevice<'b, Self::PartitionBlockIo>], Error> {
-        Ok(self.partitions)
+    fn disks(
+        &self,
+    ) -> &'b [GblDisk<
+        Disk<impl BlockIo + 'b, impl DerefMut<Target = [u8]> + 'b>,
+        Gpt<impl DerefMut<Target = [u8]> + 'b>,
+    >] {
+        self.disks
+    }
+
+    fn expected_os(&mut self) -> Result<Option<Os>> {
+        Ok(self.os)
     }
 
     fn zircon_add_device_zbi_items(
         &mut self,
         container: &mut ZbiContainer<&mut [u8]>,
-    ) -> Result<(), Error> {
+    ) -> Result<()> {
         // TODO(b/353272981): Switch to use OS configuration protocol once it is implemented on
         // existing platforms such as VIM3.
         Ok(match self.get_efi_fdt_prop("zircon", c"zbi-blob") {
@@ -210,35 +310,98 @@ where
         })
     }
 
-    fn do_fastboot<B: gbl_storage::AsBlockDevice>(&self, _: &mut Cursor<B>) -> GblResult<()> {
-        unimplemented!();
+    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
+        // Switches to use get_image_buffer once available.
+        const DEFAULT_SIZE: usize = 4096;
+        if self.zbi_bootloader_files_buffer.is_empty() {
+            self.zbi_bootloader_files_buffer.resize(DEFAULT_SIZE, 0);
+        }
+        Some(self.zbi_bootloader_files_buffer.as_mut_slice())
     }
 
-    fn load_slot_interface<'c, B: gbl_storage::AsBlockDevice>(
+    fn load_slot_interface<'c>(
         &'c mut self,
-        _: &'c mut B,
+        _: &'c mut dyn FnMut(&mut [u8]) -> Result<()>,
         _: BootToken,
-    ) -> GblResult<Cursor<'c, B>> {
+    ) -> GblResult<Cursor<'c>> {
         unimplemented!();
     }
 
     fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
-        Ok(true)
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => protocol.read_is_device_unlocked().map_err(efi_error_to_avb_error),
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
     }
 
-    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
-        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
-        Ok(0)
+    fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => protocol
+                .read_rollback_index(rollback_index_location)
+                .map_err(efi_error_to_avb_error),
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
     }
 
     fn avb_write_rollback_index(
         &mut self,
-        _rollback_index_location: usize,
-        _index: u64,
+        rollback_index_location: usize,
+        index: u64,
     ) -> AvbIoResult<()> {
-        // TODO(b/337846185): Switch to use GBL Verified Boot EFI protocol when available.
-        Ok(())
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => protocol
+                .write_rollback_index(rollback_index_location, index)
+                .map_err(efi_error_to_avb_error),
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
+    }
+
+    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => {
+                protocol.read_persistent_value(name, value).map_err(efi_error_to_avb_error)
+            }
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
+    }
+
+    fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => {
+                protocol.write_persistent_value(name, Some(value)).map_err(efi_error_to_avb_error)
+            }
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
+    }
+
+    fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => {
+                protocol.write_persistent_value(name, None).map_err(efi_error_to_avb_error)
+            }
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
+    }
+
+    fn avb_validate_vbmeta_public_key(
+        &self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> AvbIoResult<KeyValidationStatus> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => protocol
+                .validate_vbmeta_public_key(public_key, public_key_metadata)
+                .map(to_avb_validation_status_or_panic)
+                .map_err(efi_error_to_avb_error),
+            Err(_) => Err(AvbIoError::NotImplemented),
+        }
     }
 
     fn avb_cert_read_permanent_attributes(
@@ -261,11 +424,40 @@ where
         Ok(hash.try_into().map_err(|_| AvbIoError::Io)?)
     }
 
-    fn get_image_buffer<'c>(
+    fn avb_handle_verification_result(
+        &mut self,
+        color: BootStateColor,
+        digest: Option<&CStr>,
+        boot_os_version: Option<&[u8]>,
+        boot_security_patch: Option<&[u8]>,
+        system_os_version: Option<&[u8]>,
+        system_security_patch: Option<&[u8]>,
+        vendor_os_version: Option<&[u8]>,
+        vendor_security_patch: Option<&[u8]>,
+    ) -> AvbIoResult<()> {
+        match self.efi_entry.system_table().boot_services().find_first_and_open::<GblAvbProtocol>()
+        {
+            Ok(protocol) => protocol
+                .handle_verification_result(&GblEfiAvbVerificationResult {
+                    color: avb_color_to_efi_color(color),
+                    digest: digest.map_or(null(), |p| p.as_ptr() as _),
+                    boot_version: boot_os_version.map_or(null(), |p| p.as_ptr()),
+                    boot_security_patch: boot_security_patch.map_or(null(), |p| p.as_ptr()),
+                    system_version: system_os_version.map_or(null(), |p| p.as_ptr()),
+                    system_security_patch: system_security_patch.map_or(null(), |p| p.as_ptr()),
+                    vendor_version: vendor_os_version.map_or(null(), |p| p.as_ptr()),
+                    vendor_security_patch: vendor_security_patch.map_or(null(), |p| p.as_ptr()),
+                })
+                .map_err(efi_error_to_avb_error),
+            _ => Ok(()),
+        }
+    }
+
+    fn get_image_buffer(
         &mut self,
         image_name: &str,
         size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'c>> {
+    ) -> GblResult<ImageBuffer<'d>> {
         self.get_buffer_image_loading(image_name, size)
             .or(Self::allocate_image_buffer(image_name, size)
                 .map_err(|e| libgbl::IntegrationError::UnificationError(e)))
@@ -277,12 +469,435 @@ where
         // instead to provide a Cuttlefish-specific backend.
         Some(get_efi_fdt(&self.efi_entry)?.1)
     }
+
+    fn fixup_os_commandline<'c>(
+        &mut self,
+        commandline: &CStr,
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c str>> {
+        Ok(
+            match self
+                .efi_entry
+                .system_table()
+                .boot_services()
+                .find_first_and_open::<GblOsConfigurationProtocol>()
+            {
+                Ok(protocol) => {
+                    protocol.fixup_kernel_commandline(commandline, fixup_buffer)?;
+                    Some(CStr::from_bytes_until_nul(&fixup_buffer[..])?.to_str()?)
+                }
+                _ => None,
+            },
+        )
+    }
+
+    fn fixup_bootconfig<'c>(
+        &mut self,
+        bootconfig: &[u8],
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c [u8]>> {
+        Ok(
+            match self
+                .efi_entry
+                .system_table()
+                .boot_services()
+                .find_first_and_open::<GblOsConfigurationProtocol>()
+            {
+                Ok(protocol) => {
+                    let fixup_size = protocol.fixup_bootconfig(bootconfig, fixup_buffer)?;
+                    Some(&fixup_buffer[..fixup_size])
+                }
+                _ => None,
+            },
+        )
+    }
+
+    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<()> {
+        if let Ok(protocol) =
+            self.efi_entry.system_table().boot_services().find_first_and_open::<DtFixupProtocol>()
+        {
+            protocol.fixup(device_tree)?;
+        }
+
+        Ok(())
+    }
+
+    fn select_device_trees(
+        &mut self,
+        components_registry: &mut DeviceTreeComponentsRegistry,
+    ) -> Result<()> {
+        match self
+            .efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblOsConfigurationProtocol>()
+        {
+            Ok(protocol) => {
+                // Protocol detected, convert to UEFI types.
+                let mut uefi_components: ArrayVec<_, MAXIMUM_DEVICE_TREE_COMPONENTS> =
+                    components_registry
+                        .components()
+                        .map(|component| dt_component_to_efi_dt(component))
+                        .collect();
+
+                protocol.select_device_trees(&mut uefi_components[..])?;
+
+                // Propagate selections to the components_registry.
+                components_registry
+                    .components_mut()
+                    .zip(uefi_components.iter_mut())
+                    .enumerate()
+                    .for_each(|(index, (component, uefi_component))| {
+                        if uefi_component.selected {
+                            efi_println!(
+                                self.efi_entry,
+                                "Device tree component at index {} got selected by UEFI call. \
+                                Source: {}",
+                                index,
+                                component.source
+                            );
+                        }
+                        component.selected = uefi_component.selected;
+                    });
+
+                Ok(())
+            }
+            _ => components_registry.autoselect(),
+        }
+    }
+
+    fn fastboot_variable<'arg>(
+        &mut self,
+        name: &CStr,
+        args: impl Iterator<Item = &'arg CStr> + Clone,
+        out: &mut [u8],
+    ) -> Result<usize> {
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblFastbootProtocol>()?
+            .get_var(name, args, out)
+    }
+
+    fn fastboot_visit_all_variables(&mut self, cb: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblFastbootProtocol>()?
+            .get_var_all(cb)
+    }
+
+    fn slots_metadata(&mut self) -> Result<SlotsMetadata> {
+        Ok(SlotsMetadata {
+            slot_count: self
+                .efi_entry
+                .system_table()
+                .boot_services()
+                .find_first_and_open::<GblSlotProtocol>()?
+                .load_boot_data()?
+                .slot_count
+                .try_into()
+                .unwrap(),
+        })
+    }
+
+    fn get_current_slot(&mut self) -> Result<Slot> {
+        // TODO(b/363075013): Refactors the opening of slot protocol into a common helper once
+        // `MockBootServices::find_first_and_open` is updated to return Protocol<'_, T>.
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblSlotProtocol>()?
+            .get_current_slot()?
+            .try_into()
+    }
+
+    fn get_next_slot(&mut self, mark_boot_attempt: bool) -> Result<Slot> {
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblSlotProtocol>()?
+            .get_next_slot(mark_boot_attempt)?
+            .try_into()
+    }
+
+    fn set_active_slot(&mut self, slot: u8) -> Result<()> {
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblSlotProtocol>()?
+            .set_active_slot(slot)
+    }
+
+    fn set_reboot_reason(&mut self, reason: RebootReason) -> Result<()> {
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblSlotProtocol>()?
+            .set_boot_reason(gbl_to_efi_boot_reason(reason), b"")
+    }
+
+    fn get_reboot_reason(&mut self) -> Result<RebootReason> {
+        let mut subreason = [0u8; 128];
+        self.efi_entry
+            .system_table()
+            .boot_services()
+            .find_first_and_open::<GblSlotProtocol>()?
+            .get_boot_reason(&mut subreason[..])
+            .map(|(v, _)| efi_to_gbl_boot_reason(v))
+    }
+}
+
+/// Converts a [GblEfiBootReason] to [RebootReason].
+fn efi_to_gbl_boot_reason(reason: GblEfiBootReason) -> RebootReason {
+    match reason {
+        GBL_EFI_BOOT_REASON_RECOVERY => RebootReason::Recovery,
+        GBL_EFI_BOOT_REASON_BOOTLOADER => RebootReason::Bootloader,
+        GBL_EFI_BOOT_REASON_FASTBOOTD => RebootReason::FastbootD,
+        _ => RebootReason::Normal,
+    }
+}
+
+/// Converts a [RebootReason] to [GblEfiBootReason].
+fn gbl_to_efi_boot_reason(reason: RebootReason) -> GblEfiBootReason {
+    match reason {
+        RebootReason::Recovery => GBL_EFI_BOOT_REASON_RECOVERY,
+        RebootReason::Bootloader => GBL_EFI_BOOT_REASON_BOOTLOADER,
+        RebootReason::FastbootD => GBL_EFI_BOOT_REASON_FASTBOOTD,
+        RebootReason::Normal => GBL_EFI_BOOT_REASON_COLD,
+    }
+}
+
+/// Inherits everything from `ops` but override a few such as read boot_a from
+/// bootimg_buffer, avb_write_rollback_index(), slot operation etc
+pub struct RambootOps<'b, T> {
+    pub ops: &'b mut T,
+    pub bootimg_buffer: &'b mut [u8],
+}
+
+impl<'a, 'd, T: GblOps<'a, 'd>> GblOps<'a, 'd> for RambootOps<'_, T> {
+    fn console_out(&mut self) -> Option<&mut dyn Write> {
+        self.ops.console_out()
+    }
+
+    fn should_stop_in_fastboot(&mut self) -> Result<bool> {
+        self.ops.should_stop_in_fastboot()
+    }
+
+    fn reboot(&mut self) {
+        self.ops.reboot()
+    }
+
+    fn disks(
+        &self,
+    ) -> &'a [GblDisk<
+        Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
+        Gpt<impl DerefMut<Target = [u8]> + 'a>,
+    >] {
+        self.ops.disks()
+    }
+
+    fn expected_os(&mut self) -> Result<Option<Os>> {
+        self.ops.expected_os()
+    }
+
+    fn zircon_add_device_zbi_items(
+        &mut self,
+        container: &mut ZbiContainer<&mut [u8]>,
+    ) -> Result<()> {
+        self.ops.zircon_add_device_zbi_items(container)
+    }
+
+    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
+        self.ops.get_zbi_bootloader_files_buffer()
+    }
+
+    fn load_slot_interface<'c>(
+        &'c mut self,
+        _fnmut: &'c mut dyn FnMut(&mut [u8]) -> Result<()>,
+        _boot_token: BootToken,
+    ) -> GblResult<Cursor<'c>> {
+        self.ops.load_slot_interface(_fnmut, _boot_token)
+    }
+
+    fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
+        self.ops.avb_read_is_device_unlocked()
+    }
+
+    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64> {
+        self.ops.avb_read_rollback_index(_rollback_index_location)
+    }
+
+    fn avb_write_rollback_index(&mut self, _: usize, _: u64) -> AvbIoResult<()> {
+        // We don't want to persist AVB related data such as updating antirollback indices.
+        Ok(())
+    }
+
+    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize> {
+        self.ops.avb_read_persistent_value(name, value)
+    }
+
+    fn avb_write_persistent_value(&mut self, _: &CStr, _: &[u8]) -> AvbIoResult<()> {
+        // We don't want to persist AVB related data such as updating current VBH.
+        Ok(())
+    }
+
+    fn avb_erase_persistent_value(&mut self, _: &CStr) -> AvbIoResult<()> {
+        // We don't want to persist AVB related data such as updating current VBH.
+        Ok(())
+    }
+
+    fn avb_cert_read_permanent_attributes(
+        &mut self,
+        attributes: &mut CertPermanentAttributes,
+    ) -> AvbIoResult<()> {
+        self.ops.avb_cert_read_permanent_attributes(attributes)
+    }
+
+    fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
+        self.ops.avb_cert_read_permanent_attributes_hash()
+    }
+
+    fn get_image_buffer(
+        &mut self,
+        image_name: &str,
+        size: NonZeroUsize,
+    ) -> GblResult<ImageBuffer<'d>> {
+        self.ops.get_image_buffer(image_name, size)
+    }
+
+    fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
+        self.ops.get_custom_device_tree()
+    }
+
+    fn fixup_os_commandline<'c>(
+        &mut self,
+        commandline: &CStr,
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c str>> {
+        self.ops.fixup_os_commandline(commandline, fixup_buffer)
+    }
+
+    fn fixup_bootconfig<'c>(
+        &mut self,
+        bootconfig: &[u8],
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c [u8]>> {
+        self.ops.fixup_bootconfig(bootconfig, fixup_buffer)
+    }
+
+    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<()> {
+        self.ops.fixup_device_tree(device_tree)
+    }
+
+    fn select_device_trees(
+        &mut self,
+        components_registry: &mut DeviceTreeComponentsRegistry,
+    ) -> Result<()> {
+        self.ops.select_device_trees(components_registry)
+    }
+
+    fn read_from_partition_sync(
+        &mut self,
+        part: &str,
+        off: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
+        if part == "boot_a" {
+            let len = min(self.bootimg_buffer.len() - off as usize, out.len());
+            out.clone_from_slice(&self.bootimg_buffer[off as usize..off as usize + len]);
+            Ok(())
+        } else {
+            self.ops.read_from_partition_sync(part, off, out)
+        }
+    }
+
+    fn avb_handle_verification_result(
+        &mut self,
+        color: BootStateColor,
+        digest: Option<&CStr>,
+        boot_os_version: Option<&[u8]>,
+        boot_security_patch: Option<&[u8]>,
+        system_os_version: Option<&[u8]>,
+        system_security_patch: Option<&[u8]>,
+        vendor_os_version: Option<&[u8]>,
+        vendor_security_patch: Option<&[u8]>,
+    ) -> AvbIoResult<()> {
+        self.ops.avb_handle_verification_result(
+            color,
+            digest,
+            boot_os_version,
+            boot_security_patch,
+            system_os_version,
+            system_security_patch,
+            vendor_os_version,
+            vendor_security_patch,
+        )
+    }
+
+    fn avb_validate_vbmeta_public_key(
+        &self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> AvbIoResult<KeyValidationStatus> {
+        self.ops.avb_validate_vbmeta_public_key(public_key, public_key_metadata)
+    }
+
+    fn slots_metadata(&mut self) -> Result<SlotsMetadata> {
+        // Ramboot is not suppose to call this interface.
+        unreachable!()
+    }
+
+    fn get_current_slot(&mut self) -> Result<Slot> {
+        // Ramboot is slotless
+        Err(Error::Unsupported)
+    }
+
+    fn get_next_slot(&mut self, _: bool) -> Result<Slot> {
+        // Ramboot is not suppose to call this interface.
+        unreachable!()
+    }
+
+    fn set_active_slot(&mut self, _: u8) -> Result<()> {
+        // Ramboot is not suppose to call this interface.
+        unreachable!()
+    }
+
+    fn set_reboot_reason(&mut self, _: RebootReason) -> Result<()> {
+        // Ramboot is not suppose to call this interface.
+        unreachable!()
+    }
+
+    fn get_reboot_reason(&mut self) -> Result<RebootReason> {
+        // Assumes that ramboot use normal boot mode. But we might consider supporting recovery
+        // if there is a usecase.
+        Ok(RebootReason::Normal)
+    }
+
+    fn fastboot_variable<'arg>(
+        &mut self,
+        _: &CStr,
+        _: impl Iterator<Item = &'arg CStr> + Clone,
+        _: &mut [u8],
+    ) -> Result<usize> {
+        // Ramboot should not need this.
+        unreachable!();
+    }
+
+    fn fastboot_visit_all_variables(&mut self, _: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
+        // Ramboot should not need this.
+        unreachable!();
+    }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
-    use efi_mocks::MockEfi;
+    use efi_mocks::{
+        protocol::{gbl_efi_ab_slot::GblSlotProtocol, gbl_efi_avb::GblAvbProtocol},
+        MockEfi,
+    };
+    use efi_types::GBL_EFI_BOOT_REASON;
     use mockall::predicate::eq;
 
     #[test]
@@ -292,8 +907,401 @@ mod test {
         mock_efi.con_out.expect_write_str().with(eq("foo bar")).return_const(Ok(()));
         let installed = mock_efi.install();
 
-        let mut ops = Ops { efi_entry: installed.entry(), partitions: &[] };
+        let mut ops = Ops::new(installed.entry(), &[], None);
 
         assert!(write!(&mut ops, "{} {}", "foo", "bar").is_ok());
     }
+
+    #[test]
+    fn ops_avb_validate_vbmeta_public_key_returns_valid() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.validate_vbmeta_public_key_result =
+            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Ok(KeyValidationStatus::Valid));
+    }
+
+    #[test]
+    fn ops_avb_validate_vbmeta_public_key_returns_valid_custom_key() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.validate_vbmeta_public_key_result =
+            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(
+            ops.avb_validate_vbmeta_public_key(&[], None),
+            Ok(KeyValidationStatus::ValidCustomKey)
+        );
+    }
+
+    #[test]
+    fn ops_avb_validate_vbmeta_public_key_returns_invalid() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.validate_vbmeta_public_key_result =
+            Some(Ok(efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Ok(KeyValidationStatus::Invalid));
+    }
+
+    #[test]
+    fn ops_avb_validate_vbmeta_public_key_failed_error_mapped() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.validate_vbmeta_public_key_result = Some(Err(Error::OutOfResources));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Err(AvbIoError::Oom));
+    }
+
+    #[test]
+    fn ops_avb_validate_vbmeta_public_key_protocol_not_found_mapped_to_not_implemented() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_validate_vbmeta_public_key(&[], None), Err(AvbIoError::NotImplemented));
+    }
+
+    #[test]
+    fn ops_avb_read_is_device_unlocked_returns_true() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_is_device_unlocked_result = Some(Ok(true));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_is_device_unlocked(), Ok(true));
+    }
+
+    #[test]
+    fn ops_avb_read_is_device_unlocked_returns_false() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_is_device_unlocked_result = Some(Ok(false));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_is_device_unlocked(), Ok(false));
+    }
+
+    #[test]
+    fn ops_avb_read_is_device_unlocked_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_is_device_unlocked(), Err(AvbIoError::NotImplemented));
+    }
+
+    #[test]
+    fn ops_avb_read_rollback_index_success() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_rollback_index_result = Some(Ok(12345));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_rollback_index(0), Ok(12345));
+    }
+
+    #[test]
+    fn ops_avb_read_rollback_index_error() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_rollback_index_result = Some(Err(Error::OutOfResources));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_rollback_index(0), Err(AvbIoError::Oom));
+    }
+
+    #[test]
+    fn ops_avb_read_rollback_index_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_read_rollback_index(0), Err(AvbIoError::NotImplemented));
+    }
+
+    #[test]
+    fn ops_avb_write_rollback_index_success() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_rollback_index_result = Some(Ok(()));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert!(ops.avb_write_rollback_index(0, 12345).is_ok());
+    }
+
+    #[test]
+    fn ops_avb_write_rollback_index_error() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_rollback_index_result = Some(Err(Error::InvalidInput));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_write_rollback_index(0, 12345), Err(AvbIoError::InvalidValueSize));
+    }
+
+    #[test]
+    fn ops_avb_write_rollback_index_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_write_rollback_index(0, 12345), Err(AvbIoError::NotImplemented));
+    }
+
+    #[test]
+    fn ops_avb_read_persistent_value_success() {
+        const EXPECTED_LEN: usize = 4;
+
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_persistent_value_result = Some(Ok(EXPECTED_LEN));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        let mut buffer = [0u8; EXPECTED_LEN];
+        assert_eq!(ops.avb_read_persistent_value(c"test", &mut buffer), Ok(EXPECTED_LEN));
+    }
+
+    #[test]
+    fn ops_avb_read_persistent_value_error() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.read_persistent_value_result = Some(Err(Error::OutOfResources));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        let mut buffer = [0u8; 0];
+        assert_eq!(ops.avb_read_persistent_value(c"test", &mut buffer), Err(AvbIoError::Oom));
+    }
+
+    #[test]
+    fn ops_avb_read_persistent_value_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        let mut buffer = [0u8; 0];
+        assert_eq!(
+            ops.avb_read_persistent_value(c"test", &mut buffer),
+            Err(AvbIoError::NotImplemented)
+        );
+    }
+
+    #[test]
+    fn ops_avb_write_persistent_value_success() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_persistent_value_result = Some(Ok(()));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Ok(()));
+    }
+
+    #[test]
+    fn ops_avb_write_persistent_value_error() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_persistent_value_result = Some(Err(Error::InvalidInput));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Err(AvbIoError::InvalidValueSize));
+    }
+
+    #[test]
+    fn ops_avb_write_persistent_value_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_write_persistent_value(c"test", b""), Err(AvbIoError::NotImplemented));
+    }
+
+    #[test]
+    fn ops_avb_erase_persistent_value_success() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_persistent_value_result = Some(Ok(()));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_erase_persistent_value(c"test"), Ok(()));
+    }
+
+    #[test]
+    fn ops_avb_erase_persistent_value_error() {
+        let mut mock_efi = MockEfi::new();
+        let mut avb = GblAvbProtocol::default();
+        avb.write_persistent_value_result = Some(Err(Error::DeviceError));
+        mock_efi.boot_services.expect_find_first_and_open::<GblAvbProtocol>().return_const(Ok(avb));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_erase_persistent_value(c"test"), Err(AvbIoError::Io));
+    }
+
+    #[test]
+    fn ops_avb_erase_persistent_value_protocol_not_found() {
+        let mut mock_efi = MockEfi::new();
+        mock_efi
+            .boot_services
+            .expect_find_first_and_open::<GblAvbProtocol>()
+            .returning(|| Err(Error::NotFound));
+
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+
+        assert_eq!(ops.avb_erase_persistent_value(c"test"), Err(AvbIoError::NotImplemented));
+    }
+
+    /// Helper for testing `set_boot_reason`
+    fn test_set_reboot_reason(input: RebootReason, expect: GBL_EFI_BOOT_REASON) {
+        let mut mock_efi = MockEfi::new();
+        mock_efi.boot_services.expect_find_first_and_open::<GblSlotProtocol>().times(1).returning(
+            move || {
+                let mut slot = GblSlotProtocol::default();
+                slot.expect_set_boot_reason().times(1).returning(move |reason, _| {
+                    assert_eq!(reason, expect);
+                    Ok(())
+                });
+                Ok(slot)
+            },
+        );
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+        assert_eq!(ops.set_reboot_reason(input), Ok(()));
+    }
+
+    #[test]
+    fn test_set_reboot_reason_normal() {
+        test_set_reboot_reason(RebootReason::Normal, GBL_EFI_BOOT_REASON_COLD);
+    }
+
+    #[test]
+    fn test_set_reboot_reason_recovery() {
+        test_set_reboot_reason(RebootReason::Recovery, GBL_EFI_BOOT_REASON_RECOVERY);
+    }
+
+    #[test]
+    fn test_set_reboot_reason_bootloader() {
+        test_set_reboot_reason(RebootReason::Bootloader, GBL_EFI_BOOT_REASON_BOOTLOADER);
+    }
+
+    #[test]
+    fn test_set_reboot_reason_fastbootd() {
+        test_set_reboot_reason(RebootReason::FastbootD, GBL_EFI_BOOT_REASON_FASTBOOTD);
+    }
+
+    /// Helper for testing `get_boot_reason`
+    fn test_get_reboot_reason(input: GBL_EFI_BOOT_REASON, expect: RebootReason) {
+        let mut mock_efi = MockEfi::new();
+        mock_efi.boot_services.expect_find_first_and_open::<GblSlotProtocol>().times(1).returning(
+            move || {
+                let mut slot = GblSlotProtocol::default();
+                slot.expect_get_boot_reason().times(1).returning(move |_| Ok((input, 0)));
+                Ok(slot)
+            },
+        );
+        let installed = mock_efi.install();
+        let mut ops = Ops::new(installed.entry(), &[], None);
+        assert_eq!(ops.get_reboot_reason().unwrap(), expect)
+    }
+
+    #[test]
+    fn test_get_reboot_reason_normal() {
+        test_get_reboot_reason(GBL_EFI_BOOT_REASON_COLD, RebootReason::Normal);
+    }
+
+    #[test]
+    fn test_get_reboot_reason_recovery() {
+        test_get_reboot_reason(GBL_EFI_BOOT_REASON_RECOVERY, RebootReason::Recovery);
+    }
+
+    #[test]
+    fn test_get_reboot_reason_bootloader() {
+        test_get_reboot_reason(GBL_EFI_BOOT_REASON_BOOTLOADER, RebootReason::Bootloader);
+    }
+
+    #[test]
+    fn test_get_reboot_reason_fastbootd() {
+        test_get_reboot_reason(GBL_EFI_BOOT_REASON_FASTBOOTD, RebootReason::FastbootD);
+    }
 }
diff --git a/gbl/efi/src/utils.rs b/gbl/efi/src/utils.rs
index 8f0f594..b1c5390 100644
--- a/gbl/efi/src/utils.rs
+++ b/gbl/efi/src/utils.rs
@@ -13,7 +13,7 @@
 // limitations under the License.
 
 use crate::efi;
-use core::ffi::CStr;
+use ::efi::EfiMemoryAttributesTable;
 use efi::{
     protocol::{
         device_path::{DevicePathProtocol, DevicePathText, DevicePathToTextProtocol},
@@ -27,21 +27,10 @@ use efi_types::{EfiGuid, EfiInputKey};
 use fdt::FdtHeader;
 use liberror::Error;
 use libgbl::Result;
-use safemath::SafeNum;
 
 pub const EFI_DTB_TABLE_GUID: EfiGuid =
     EfiGuid::new(0xb1b621d5, 0xf19c, 0x41a5, [0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0]);
 
-/// Gets a subslice of the given slice with aligned address according to `alignment`
-pub fn aligned_subslice(
-    bytes: &mut [u8],
-    alignment: usize,
-) -> core::result::Result<&mut [u8], Error> {
-    let addr = bytes.as_ptr() as usize;
-    let aligned_start = SafeNum::from(addr).round_up(alignment) - addr;
-    Ok(&mut bytes[aligned_start.try_into()?..])
-}
-
 /// Helper function to get the `DevicePathText` from a `DeviceHandle`.
 pub fn get_device_path<'a>(
     entry: &'a EfiEntry,
@@ -100,11 +89,6 @@ pub fn efi_to_e820_mem_type(efi_mem_type: u32) -> u32 {
     }
 }
 
-/// A helper to convert a bytes slice containing a null-terminated string to `str`
-pub fn cstr_bytes_to_str(data: &[u8]) -> core::result::Result<&str, Error> {
-    Ok(CStr::from_bytes_until_nul(data)?.to_str()?)
-}
-
 /// Repetitively runs a closure until it signals completion or timeout.
 ///
 /// * If `f` returns `Ok(R)`, an `Ok(Some(R))` is returned immediately.
@@ -147,3 +131,33 @@ pub fn wait_key_stroke(
     })?
     .unwrap_or(Ok(false))
 }
+
+// Converts an EFI memory type to a zbi_mem_range_t type.
+pub fn efi_to_zbi_mem_range_type(efi_mem_type: u32) -> u32 {
+    match efi_mem_type {
+        efi_types::EFI_MEMORY_TYPE_LOADER_CODE
+        | efi_types::EFI_MEMORY_TYPE_LOADER_DATA
+        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_CODE
+        | efi_types::EFI_MEMORY_TYPE_BOOT_SERVICES_DATA
+        | efi_types::EFI_MEMORY_TYPE_CONVENTIONAL_MEMORY => zbi::zbi_format::ZBI_MEM_TYPE_RAM,
+        _ => zbi::zbi_format::ZBI_MEM_TYPE_RESERVED,
+    }
+}
+
+/// Find Memory attributes from EFI configuration_table
+#[allow(unused)]
+pub fn get_efi_mem_attr<'a>(entry: &'a EfiEntry) -> Option<EfiMemoryAttributesTable<'static>> {
+    entry.system_table().configuration_table().and_then(|config_tables| {
+        config_tables
+            .iter()
+            .find_map(|&table| {
+                // SAFETY:
+                // `table` is valid EFI Configuration table provided by EFI
+                match unsafe { EfiMemoryAttributesTable::new(table) } {
+                    Err(Error::NotFound) => None,
+                    other => Some(other.ok()),
+                }
+            })
+            .flatten()
+    })
+}
diff --git a/gbl/integration/aosp_u-boot-mainline/BUILD b/gbl/integration/aosp_uefi-gbl-mainline/BUILD
similarity index 100%
rename from gbl/integration/aosp_u-boot-mainline/BUILD
rename to gbl/integration/aosp_uefi-gbl-mainline/BUILD
diff --git a/gbl/integration/aosp_u-boot-mainline/workspace.bzl b/gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl
similarity index 98%
rename from gbl/integration/aosp_u-boot-mainline/workspace.bzl
rename to gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl
index 251508e..ed62b44 100644
--- a/gbl/integration/aosp_u-boot-mainline/workspace.bzl
+++ b/gbl/integration/aosp_uefi-gbl-mainline/workspace.bzl
@@ -384,6 +384,12 @@ cc_library(
         ),
     )
 
+    native.new_local_repository(
+        name = "zbi",
+        path = "prebuilts/fuchsia_sdk/",
+        build_file = "//prebuilts/fuchsia_sdk:BUILD.zbi.bazel",
+    )
+
     # Following are third party rust crates dependencies which already contain a
     # BUILD file that we can use as-is without any modification.
 
diff --git a/gbl/libabr/src/lib.rs b/gbl/libabr/src/lib.rs
index 6da4b16..94c9309 100644
--- a/gbl/libabr/src/lib.rs
+++ b/gbl/libabr/src/lib.rs
@@ -112,6 +112,17 @@ impl From<SlotIndex> for c_uint {
     }
 }
 
+// Implement conversion to char
+impl From<SlotIndex> for char {
+    fn from(_val: SlotIndex) -> Self {
+        match _val {
+            SlotIndex::A => 'a',
+            SlotIndex::B => 'b',
+            SlotIndex::R => 'r',
+        }
+    }
+}
+
 // Implement conversion from c_uint for C interfaces.
 impl TryFrom<c_uint> for SlotIndex {
     type Error = Error;
@@ -650,6 +661,15 @@ pub fn get_and_clear_one_shot_flag(abr_ops: &mut dyn Ops) -> Result<u8> {
     Ok(res)
 }
 
+/// Gets and clears one shot bootloader flag only.
+pub fn get_and_clear_one_shot_bootloader(abr_ops: &mut dyn Ops) -> Result<bool> {
+    let (mut abr_data, abr_data_orig) = load_metadata(abr_ops)?;
+    let res = abr_data.one_shot_flags;
+    abr_data.one_shot_flags &= !ONE_SHOT_BOOTLOADER;
+    save_metadata_if_changed(abr_ops, &mut abr_data, &abr_data_orig)?;
+    Ok((res & ONE_SHOT_BOOTLOADER) != 0)
+}
+
 /// Reverses the bit of a byte.
 fn reverse_byte(b: u8) -> u8 {
     const LOOKUP_TABLE_4BIT_REVERSE: &[u8] =
@@ -683,7 +703,17 @@ fn crc32(data: &[u8]) -> u32 {
 
 #[cfg(test)]
 mod test {
+    use super::*;
     // Testing is currently done against the C interface tests in upstream Fuchsia:
     // https://fuchsia.googlesource.com/fuchsia/+/96f7268b497f998ffcbeef73425b031bd7f4db65/src/firmware/lib/abr/test/libabr_test.cc
     // These tests will be ported to here as rust tests in the future.
+
+    #[test]
+    fn test_get_and_clear_one_shot_bootloader() {
+        let mut meta = [0u8; ABR_DATA_SIZE];
+        set_one_shot_bootloader(&mut meta, true).unwrap();
+        set_one_shot_recovery(&mut meta, true).unwrap();
+        assert!(get_and_clear_one_shot_bootloader(&mut meta).unwrap());
+        assert_eq!(get_and_clear_one_shot_flag(&mut meta).unwrap(), ONE_SHOT_RECOVERY);
+    }
 }
diff --git a/gbl/libasync/src/lib.rs b/gbl/libasync/src/lib.rs
index 59493fe..d84d4ec 100644
--- a/gbl/libasync/src/lib.rs
+++ b/gbl/libasync/src/lib.rs
@@ -21,6 +21,7 @@
 
 use core::{
     future::Future,
+    ops::DerefMut,
     pin::{pin, Pin},
     ptr::null,
     task::{Context, Poll, RawWaker, RawWakerVTable, Waker},
@@ -57,7 +58,9 @@ pub fn block_on<O>(fut: impl Future<Output = O>) -> O {
 /// Polls a Future.
 ///
 /// Returns Some(_) if ready, None otherwise.
-pub fn poll<F: Future<Output = O> + ?Sized, O>(fut: &mut Pin<&mut F>) -> Option<O> {
+pub fn poll<O, F: Future<Output = O> + ?Sized>(
+    fut: &mut Pin<impl DerefMut<Target = F>>,
+) -> Option<O> {
     // SAFETY:
     // * All methods for noop_raw_waker() are either noop or have no shared state. Thus they are
     //   thread-safe.
@@ -69,6 +72,14 @@ pub fn poll<F: Future<Output = O> + ?Sized, O>(fut: &mut Pin<&mut F>) -> Option<
     }
 }
 
+/// Polls the given future for up to `n` times.
+pub fn poll_n_times<O, F: Future<Output = O> + ?Sized>(
+    fut: &mut Pin<impl DerefMut<Target = F>>,
+    n: usize,
+) -> Option<O> {
+    (0..n).find_map(|_| poll(fut))
+}
+
 /// `Yield` implements a simple API for yielding control once to the executor.
 struct Yield(bool);
 
@@ -153,6 +164,22 @@ where
     (out_lhs, out_rhs)
 }
 
+/// Runs a [Future] and checks and asserts that it returns eventually.
+pub async fn assert_return<O>(fut: impl Future<Output = O>) -> O {
+    struct Returned(bool);
+
+    impl Drop for Returned {
+        fn drop(&mut self) {
+            assert!(self.0)
+        }
+    }
+
+    let mut flag = Returned(false);
+    let res = fut.await;
+    flag.0 = true;
+    res
+}
+
 #[cfg(test)]
 mod test {
     use super::*;
@@ -242,4 +269,18 @@ mod test {
         assert!(lhs.is_some());
         assert!(rhs.is_none());
     }
+
+    #[test]
+    fn test_assert_return() {
+        // Finishes. No assert.
+        block_on(assert_return(async { yield_now().await }));
+    }
+
+    #[test]
+    #[should_panic]
+    fn test_assert_return_panics() {
+        let mut fut = pin!(assert_return(async { yield_now().await }));
+        // Need one more poll to finish. Thus it should panic when going out of scope.
+        assert!(poll(&mut fut).is_none());
+    }
 }
diff --git a/gbl/libboot/BUILD b/gbl/libboot/BUILD
index 3ddd30f..4982222 100644
--- a/gbl/libboot/BUILD
+++ b/gbl/libboot/BUILD
@@ -77,7 +77,7 @@ rust_library(
         ":x86_bootparam_defs",
         "@gbl//liberror",
         "@gbl//libsafemath",
-        "@gbl//third_party/libzbi",
+        "@zbi",
         "@zerocopy",
     ] + select({
         "@gbl//toolchain:gbl_rust_uefi_aarch64": [
diff --git a/gbl/libboot/src/aarch64.rs b/gbl/libboot/src/aarch64.rs
index 6655c91..3dd1a6f 100644
--- a/gbl/libboot/src/aarch64.rs
+++ b/gbl/libboot/src/aarch64.rs
@@ -124,7 +124,7 @@ pub unsafe fn jump_linux_el2_or_lower(kernel: &[u8], ramdisk: &[u8], fdt: &[u8])
 pub unsafe fn jump_zircon_el2_or_lower(kernel: &[u8], zbi_item: &[u8]) -> ! {
     assert_ne!(current_el(), ExceptionLevel::EL3);
     let (entry, _) =
-        ZbiContainer::parse(zbi_item).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
+        ZbiContainer::parse(kernel).unwrap().get_kernel_entry_and_reserved_memory_size().unwrap();
     flush_dcache_buffer(kernel);
     flush_dcache_buffer(zbi_item);
     let addr = (kernel.as_ptr() as usize).checked_add(usize::try_from(entry).unwrap()).unwrap();
diff --git a/gbl/libbootimg/BUILD b/gbl/libbootimg/BUILD
index ef6dbe4..6d0f55a 100644
--- a/gbl/libbootimg/BUILD
+++ b/gbl/libbootimg/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2023-2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -105,7 +105,7 @@ genrule(
 
 rust_library(
     # The naming is expected by "@mkbootimg//:rust/bootimg.rs".
-    name = "bootimg_private",
+    name = "bootimg_bindgen",
     srcs = ["src/defs.rs"],
     crate_root = "src/defs.rs",
     data = [":bootimg_sources_gen"],
@@ -122,7 +122,7 @@ rust_library(
     data = [":bootimg_sources_gen"],
     rustc_flags = ANDROID_RUST_LINTS,
     deps = [
-        ":bootimg_private",
+        ":bootimg_bindgen",
         "@gbl//liberror",
         "@zerocopy",
     ],
diff --git a/gbl/libbootimg/src/lib.rs b/gbl/libbootimg/src/lib.rs
index d2b0135..2469658 100644
--- a/gbl/libbootimg/src/lib.rs
+++ b/gbl/libbootimg/src/lib.rs
@@ -20,7 +20,7 @@
 #[rustfmt::skip]
 mod bootimg;
 pub use bootimg::*;
-pub use bootimg_private as defs;
+pub use bootimg_bindgen as defs;
 
 use liberror::Error;
 
diff --git a/gbl/efi/arch/aarch64/BUILD b/gbl/libbootparams/BUILD
similarity index 83%
rename from gbl/efi/arch/aarch64/BUILD
rename to gbl/libbootparams/BUILD
index ee78561..57c4212 100644
--- a/gbl/efi/arch/aarch64/BUILD
+++ b/gbl/libbootparams/BUILD
@@ -20,23 +20,18 @@ package(
 )
 
 rust_library(
-    name = "aarch64",
+    name = "libbootparams",
     srcs = glob(["src/**/*.rs"]),
-    crate_name = "gbl_efi_aarch64",
+    crate_name = "bootparams",
+    edition = "2021",
     rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         "@gbl//liberror",
-        "@gbl//libgbl",
-        "@lz4_flex",
-        "@zune_inflate",
     ],
 )
 
 rust_test(
     name = "test",
-    crate = ":aarch64",
+    crate = ":libbootparams",
     rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        "@gbl//libefi:mocks",
-    ],
 )
diff --git a/gbl/libbootconfig/src/lib.rs b/gbl/libbootparams/src/bootconfig.rs
similarity index 86%
rename from gbl/libbootconfig/src/lib.rs
rename to gbl/libbootparams/src/bootconfig.rs
index bf15912..b9d7a0b 100644
--- a/gbl/libbootconfig/src/lib.rs
+++ b/gbl/libbootparams/src/bootconfig.rs
@@ -12,11 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-//! Library for constructing kernel bootconfig. See the following for more detail:
+//! Module for constructing bootconfig. See the following for more details:
 //!
-//!   https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig#bootloader-changes
-
-#![cfg_attr(not(test), no_std)]
+//! https://source.android.com/docs/core/architecture/bootloader/implementing-bootconfig#bootloader-changes
 
 use liberror::{Error, Result};
 
@@ -73,10 +71,11 @@ impl<'a> BootConfigBuilder<'a> {
     /// is not possible or desired.
     pub fn add_with<F>(&mut self, reader: F) -> Result<()>
     where
-        F: FnOnce(&mut [u8]) -> Result<usize>,
+        F: FnOnce(&[u8], &mut [u8]) -> Result<usize>,
     {
         let remains = self.remaining_capacity();
-        let size = reader(&mut self.buffer[self.current_size..][..remains])?;
+        let (current_buffer, remains_buffer) = self.buffer.split_at_mut(self.current_size);
+        let size = reader(&current_buffer[..], &mut remains_buffer[..remains])?;
         assert!(size <= remains);
         self.current_size += size;
         // Content may have been modified. Re-compute trailer.
@@ -88,7 +87,7 @@ impl<'a> BootConfigBuilder<'a> {
         if self.remaining_capacity() < config.len() {
             return Err(Error::BufferTooSmall(Some(config.len())));
         }
-        self.add_with(|out| {
+        self.add_with(|_, out| {
             out[..config.len()].clone_from_slice(config.as_bytes());
             Ok(config.len())
         })
@@ -131,7 +130,7 @@ impl core::fmt::Display for BootConfigBuilder<'_> {
 
 impl core::fmt::Write for BootConfigBuilder<'_> {
     fn write_str(&mut self, s: &str) -> core::fmt::Result {
-        self.add_with(|out| {
+        self.add_with(|_, out| {
             out.get_mut(..s.len())
                 .ok_or(Error::BufferTooSmall(Some(s.len())))?
                 .clone_from_slice(s.as_bytes());
@@ -222,6 +221,32 @@ androidboot.verifiedbootstate=orange
         );
     }
 
+    #[test]
+    fn test_add_with_incremental() {
+        let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
+        let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
+
+        let mut offset = 0;
+        for ele in TEST_CONFIG.strip_suffix('\n').unwrap().split('\n') {
+            let config = std::string::String::from(ele) + "\n";
+
+            builder
+                .add_with(|current, out| {
+                    assert_eq!(current, &TEST_CONFIG.as_bytes()[..offset]);
+
+                    out[..config.len()].copy_from_slice(config.as_bytes());
+                    Ok(config.len())
+                })
+                .unwrap();
+
+            offset += config.len();
+        }
+        assert_eq!(
+            builder.config_bytes().to_vec(),
+            [TEST_CONFIG.as_bytes(), TEST_CONFIG_TRAILER].concat().to_vec()
+        );
+    }
+
     #[test]
     fn test_add_incremental_via_fmt_write() {
         let mut buffer = [0u8; TEST_CONFIG.len() + TEST_CONFIG_TRAILER.len()];
@@ -259,6 +284,6 @@ androidboot.verifiedbootstate=orange
     fn test_add_with_error() {
         let mut buffer = [0u8; BOOTCONFIG_TRAILER_SIZE + 1];
         let mut builder = BootConfigBuilder::new(&mut buffer[..]).unwrap();
-        assert!(builder.add_with(|_| Err(Error::Other(None))).is_err());
+        assert!(builder.add_with(|_, _| Err(Error::Other(None))).is_err());
     }
 }
diff --git a/gbl/libbootparams/src/commandline.rs b/gbl/libbootparams/src/commandline.rs
new file mode 100644
index 0000000..f035795
--- /dev/null
+++ b/gbl/libbootparams/src/commandline.rs
@@ -0,0 +1,331 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Module for constructing kernel commandline.
+//!
+//! https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html
+
+use core::ffi::CStr;
+use liberror::{Error, Error::BufferTooSmall, Error::InvalidInput, Result};
+
+/// A class for constructing commandline section.
+pub struct CommandlineBuilder<'a> {
+    current_size: usize,
+    buffer: &'a mut [u8],
+}
+
+/// Null terminator.
+const COMMANDLINE_TRAILING_SIZE: usize = 1;
+
+impl<'a> CommandlineBuilder<'a> {
+    /// Initialize with a given buffer.
+    pub fn new(buffer: &'a mut [u8]) -> Result<Self> {
+        if buffer.len() < COMMANDLINE_TRAILING_SIZE {
+            return Err(BufferTooSmall(Some(COMMANDLINE_TRAILING_SIZE)));
+        }
+        let mut ret = Self { current_size: 0, buffer: buffer };
+        ret.update_null_terminator();
+        Ok(ret)
+    }
+
+    /// Initialize with a provided buffer that already contains a command line.
+    pub fn new_from_prefix(buffer: &'a mut [u8]) -> Result<Self> {
+        let prefix = CStr::from_bytes_until_nul(buffer).map_err(Error::from)?;
+        Ok(Self { current_size: prefix.to_bytes().len(), buffer: buffer })
+    }
+
+    /// Get the remaining capacity.
+    pub fn remaining_capacity(&self) -> usize {
+        self.buffer.len() - self.current_size - COMMANDLINE_TRAILING_SIZE
+    }
+
+    /// Get the current command line.
+    pub fn as_str(&self) -> &str {
+        // Maintain data null-terminated so not expecting to fail.
+        CStr::from_bytes_with_nul(&self.buffer[..self.current_size + 1])
+            .unwrap()
+            .to_str()
+            .unwrap()
+            .trim()
+    }
+
+    /// Append a new command line segment via a reader callback.
+    ///
+    /// Callback arguments:
+    /// * `&CStr`     - Current null terminated command line data.
+    /// * `&mut [u8]` - Remaining buffer for reading the data into. May be an empty buffer.
+    ///
+    /// Callback return value:
+    /// It must return the total size written or error. Null terminator must not be included in
+    /// the written buffer. Attempting to return a size greater than the input buffer will cause
+    /// it to panic. Empty read is allowed.
+    ///
+    /// It's up to the caller to make sure the read content will eventually form a valid
+    /// command line (space separation is handled by the call). The API is for situations where
+    /// command line is read from sources such as disk and separate buffer allocation is not
+    /// possible or desired.
+    pub fn add_with<F>(&mut self, reader: F) -> Result<()>
+    where
+        F: FnOnce(&CStr, &mut [u8]) -> Result<usize>,
+    {
+        let (current_buffer, mut remains_buffer) =
+            self.buffer.split_at_mut(self.current_size + COMMANDLINE_TRAILING_SIZE);
+
+        let remains_len = remains_buffer.len();
+        // Don't need to reserve space for null terminator since buffer is already empty.
+        // Not expecting callback to append any data in this case.
+        if remains_len != 0 {
+            // Existing null terminator is gonna be replaced with separator, so need
+            // a space for another null terminator to append.
+            remains_buffer = &mut remains_buffer[..remains_len - 1];
+        }
+
+        let current_commandline = CStr::from_bytes_with_nul(current_buffer).unwrap();
+        let size = match reader(current_commandline, &mut remains_buffer[..]) {
+            // Handle buffer too small to make sure we request additional space for null
+            // terminator.
+            Err(BufferTooSmall(Some(requested))) => Err(BufferTooSmall(Some(requested + 1))),
+            other => other,
+        }?;
+        // Empty write, do nothing.
+        if size == 0 {
+            return Ok(());
+        }
+        // Appended command line data cannot have null terminator.
+        if remains_buffer[..size].contains(&0u8) {
+            return Err(InvalidInput);
+        }
+
+        assert!(size <= remains_buffer.len());
+
+        // Replace current null terminator with space separator. This logic adding a redundant
+        // leading space in case build is currently empty. Keep it as is for the simplicity.
+        self.buffer[self.current_size] = b' ';
+        // +1 for space separator
+        self.current_size += size + 1;
+        self.update_null_terminator();
+
+        Ok(())
+    }
+
+    /// Append a new command line.
+    /// Wrapper over `add_with`, so refer to its documentation for details.
+    pub fn add(&mut self, commandline: &str) -> Result<()> {
+        if commandline.is_empty() {
+            return Ok(());
+        }
+
+        // +1 for space separator
+        let required_capacity = commandline.len() + 1;
+        if self.remaining_capacity() < required_capacity {
+            return Err(Error::BufferTooSmall(Some(required_capacity)));
+        }
+
+        self.add_with(|_, out| {
+            out[..commandline.len()].clone_from_slice(commandline.as_bytes());
+            Ok(commandline.len())
+        })
+    }
+
+    /// Update the command line null terminator at the end of the current buffer.
+    fn update_null_terminator(&mut self) {
+        self.buffer[self.current_size] = 0;
+    }
+}
+
+impl core::fmt::Display for CommandlineBuilder<'_> {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        write!(f, "{}", self.as_str())
+    }
+}
+
+impl core::fmt::Write for CommandlineBuilder<'_> {
+    fn write_str(&mut self, s: &str) -> core::fmt::Result {
+        self.add(s).map_err(|_| core::fmt::Error)
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use core::fmt::Write;
+
+    const TEST_COMMANDLINE: &[u8] =
+        b"video=vfb:640x400,bpp=32,memsize=3072000 console=ttyMSM0,115200n8 earlycon bootconfig\0";
+    const NODE_TO_ADD: &str = "bootconfig";
+
+    #[test]
+    fn test_new_from_prefix() {
+        let mut test_commandline = TEST_COMMANDLINE.to_vec();
+
+        let builder = CommandlineBuilder::new_from_prefix(&mut test_commandline[..]).unwrap();
+        assert_eq!(
+            builder.as_str(),
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_new_from_prefix_without_null_terminator() {
+        let mut test_commandline = TEST_COMMANDLINE.to_vec();
+
+        assert!(CommandlineBuilder::new_from_prefix(&mut test_commandline[..1]).is_err());
+    }
+
+    #[test]
+    fn test_empty_initial_buffer() {
+        let mut empty = [0u8; 0];
+
+        assert!(CommandlineBuilder::new(&mut empty[..]).is_err());
+    }
+
+    #[test]
+    fn test_add_incremental() {
+        // 1 extra byte for leading space
+        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+        for element in
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
+        {
+            builder.add(element).unwrap();
+        }
+
+        assert_eq!(
+            builder.as_str(),
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_add_incremental_via_fmt_write() {
+        // 1 extra byte for leading space
+        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+        for element in
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
+        {
+            write!(builder, "{}", element).unwrap();
+        }
+
+        assert_eq!(
+            builder.as_str(),
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_add_with_incremental() {
+        // 1 extra byte for leading space
+        let mut buffer = [0u8; TEST_COMMANDLINE.len() + 1];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        let mut offset = 0;
+        for element in
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap().split(' ')
+        {
+            builder
+                .add_with(|current, out| {
+                    let current = core::str::from_utf8(current.to_bytes()).unwrap().trim();
+                    let expected =
+                        core::str::from_utf8(&TEST_COMMANDLINE[..offset]).unwrap().trim();
+                    assert_eq!(current, expected);
+
+                    out[..element.len()].copy_from_slice(element.as_bytes());
+                    Ok(element.len())
+                })
+                .unwrap();
+
+            // +1 for space separator
+            offset += element.len() + 1;
+        }
+
+        assert_eq!(
+            builder.as_str(),
+            CStr::from_bytes_until_nul(TEST_COMMANDLINE).unwrap().to_str().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_add_single_node_to_full_buffer() {
+        // 1 extra byte for leading space
+        let mut buffer = [0u8; NODE_TO_ADD.len() + COMMANDLINE_TRAILING_SIZE + 1];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        builder.add(NODE_TO_ADD).unwrap();
+        assert_eq!(builder.as_str(), NODE_TO_ADD);
+        assert_eq!(builder.remaining_capacity(), 0);
+    }
+
+    #[test]
+    fn test_add_with_single_node_to_full_buffer() {
+        // 1 extra byte for leading space
+        let mut buffer = [0u8; NODE_TO_ADD.len() + COMMANDLINE_TRAILING_SIZE + 1];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        assert!(builder
+            .add_with(|current, out| {
+                assert_eq!(current.to_bytes().len(), 0);
+                out[..NODE_TO_ADD.len()].copy_from_slice(NODE_TO_ADD.as_bytes());
+                Ok(NODE_TO_ADD.len())
+            })
+            .is_ok());
+        assert_eq!(builder.remaining_capacity(), 0);
+    }
+
+    #[test]
+    fn test_add_to_empty_not_enough_space() {
+        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        // + 1 requested for space separator
+        assert_eq!(
+            builder.add(NODE_TO_ADD),
+            Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len() + 1)))
+        );
+    }
+
+    #[test]
+    fn test_add_with_to_empty_not_enough_space_requested_space_for_separator() {
+        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        assert_eq!(
+            builder.add_with(|_, _| { Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len()))) }),
+            Err(Error::BufferTooSmall(Some(NODE_TO_ADD.len() + 1)))
+        );
+    }
+
+    #[test]
+    fn test_empty_add_with_to_empty_succeed() {
+        let mut buffer = [0u8; COMMANDLINE_TRAILING_SIZE];
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        assert!(builder.add_with(|_, _| { Ok(0) }).is_ok());
+    }
+
+    #[test]
+    fn test_add_with_null_terminator_invalid_input() {
+        let mut buffer = TEST_COMMANDLINE.to_vec();
+        let mut builder = CommandlineBuilder::new(&mut buffer[..]).unwrap();
+
+        assert_eq!(
+            builder.add_with(|_, out| {
+                let with_null_terminator = b"null\0terminator";
+                out[..with_null_terminator.len()].copy_from_slice(&with_null_terminator[..]);
+                Ok(with_null_terminator.len())
+            }),
+            Err(Error::InvalidInput)
+        );
+    }
+}
diff --git a/gbl/libbootparams/src/lib.rs b/gbl/libbootparams/src/lib.rs
new file mode 100644
index 0000000..d9c5b94
--- /dev/null
+++ b/gbl/libbootparams/src/lib.rs
@@ -0,0 +1,21 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Library for building kernel command line and bootconfig. Refer to modules tests on how to
+//! use it.
+
+#![cfg_attr(not(test), no_std)]
+
+pub mod bootconfig;
+pub mod commandline;
diff --git a/gbl/libdttable/BUILD b/gbl/libdttable/BUILD
index 625a675..9313201 100644
--- a/gbl/libdttable/BUILD
+++ b/gbl/libdttable/BUILD
@@ -79,8 +79,7 @@ rust_library(
 rust_test(
     name = "libdttable_test",
     compile_data = [
-        "@gbl//libdttable/test:dttable.img",
-        "@gbl//libdttable/test:corrupted_dttable.img",
+        "@gbl//libdttable/test/data:all",
     ],
     crate = ":libdttable",
     rustc_flags = ANDROID_RUST_LINTS,
diff --git a/gbl/libdttable/src/lib.rs b/gbl/libdttable/src/lib.rs
index e5b9563..225afa7 100644
--- a/gbl/libdttable/src/lib.rs
+++ b/gbl/libdttable/src/lib.rs
@@ -77,14 +77,24 @@ impl DtTableHeaderEntry {
     }
 }
 
-/// Device tree blob obtained from multidt table image
-pub struct DtTableEntry<'a> {
+/// Metadata provided by entry header
+#[derive(Copy, Default, Clone, Eq, PartialEq, Debug)]
+pub struct DtTableMetadata {
     /// id field from corresponding entry header
     pub id: u32,
     /// rev field from corresponding entry header
     pub rev: u32,
+    /// custom field from corresponding entry header
+    pub custom: [u32; 4],
+}
+
+/// Device tree blob obtained from multidt table image
+#[derive(Copy, Clone, Eq, PartialEq, Debug)]
+pub struct DtTableEntry<'a> {
     /// dtb payload extracted from image
     pub dtb: &'a [u8],
+    /// Metadata provided by corresponding entry header
+    pub metadata: DtTableMetadata,
 }
 
 /// Represents entier multidt table image
@@ -94,6 +104,26 @@ pub struct DtTableImage<'a> {
     entries: LayoutVerified<&'a [u8], [DtTableHeaderEntry]>,
 }
 
+/// To iterate over entries.
+pub struct DtTableImageIterator<'a> {
+    table_image: &'a DtTableImage<'a>,
+    current_index: usize,
+}
+
+impl<'a> Iterator for DtTableImageIterator<'a> {
+    type Item = DtTableEntry<'a>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.current_index < self.table_image.entries_count() {
+            let result = self.table_image.nth_entry(self.current_index).unwrap();
+            self.current_index += 1;
+            Some(result)
+        } else {
+            None
+        }
+    }
+}
+
 impl<'a> DtTableImage<'a> {
     /// Verify and parse passed buffer following multidt table structure
     pub fn from_bytes(buffer: &'a [u8]) -> Result<DtTableImage<'a>> {
@@ -122,8 +152,13 @@ impl<'a> DtTableImage<'a> {
     }
 
     /// Get amount of presented dt entries in the multidt table image
-    pub fn entries_count(&self) -> u32 {
-        self.header.dt_entry_count()
+    pub fn entries_count(&self) -> usize {
+        self.header.dt_entry_count().try_into().unwrap()
+    }
+
+    /// Returns an iterator over the entries in the DT table image
+    pub fn entries(&'a self) -> DtTableImageIterator<'a> {
+        DtTableImageIterator { table_image: self, current_index: 0 }
     }
 
     /// Get nth dtb buffer with multidt table structure metadata
@@ -139,7 +174,10 @@ impl<'a> DtTableImage<'a> {
         let dtb_buffer =
             self.buffer.get(dtb_start..dtb_end).ok_or(Error::BufferTooSmall(Some(dtb_end)))?;
 
-        Ok(DtTableEntry { id: entry.id(), rev: entry.rev(), dtb: dtb_buffer })
+        Ok(DtTableEntry {
+            dtb: dtb_buffer,
+            metadata: DtTableMetadata { id: entry.id(), rev: entry.rev(), custom: entry.0.custom },
+        })
     }
 }
 
@@ -150,7 +188,7 @@ mod test {
 
     #[test]
     fn test_dt_table_is_parsed() {
-        let dttable = include_bytes!("../test/dttable.img").to_vec();
+        let dttable = include_bytes!("../test/data/dttable.img").to_vec();
         let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
 
         assert_eq!(table.entries_count(), 2, "Test data dttable image must have 2 dtb entries");
@@ -158,19 +196,56 @@ mod test {
         let first_entry = table.nth_entry(0).unwrap();
         let second_entry = table.nth_entry(1).unwrap();
 
-        assert_eq!(first_entry.id, 1, "First dttable entry id is incorrect");
-        assert_eq!(first_entry.rev, 0, "First dttable entry rev is incorrect");
-        assert_eq!(second_entry.id, 2, "Second dttable entry id is incorrect");
-        assert_eq!(second_entry.rev, 0, "Second dttable entry rev is incorrect");
+        assert_eq!(
+            first_entry.metadata,
+            DtTableMetadata { id: 1, rev: 0, custom: Default::default() },
+            "First dttable entry is incorrect"
+        );
+        assert_eq!(
+            second_entry.metadata,
+            DtTableMetadata { id: 2, rev: 0, custom: Default::default() },
+            "Second dttable entry is incorrect"
+        );
 
         // verify fdt headers are properly parsed
         let _ = Fdt::new(first_entry.dtb).unwrap();
         let _ = Fdt::new(second_entry.dtb).unwrap();
     }
 
+    #[test]
+    fn test_dt_table_is_parsed_iterator() {
+        let dttable = include_bytes!("../test/data/dttable.img").to_vec();
+        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
+
+        // Collect entries from the iterator
+        let entries: Vec<_> = table.entries().collect();
+
+        // Verify that the iterator yields the correct number of entries
+        assert_eq!(entries.len(), 2, "Iterator should yield 2 entries");
+
+        // Unwrap the entries from Result
+        let first_entry = &entries[0];
+        let second_entry = &entries[1];
+
+        assert_eq!(
+            first_entry.metadata,
+            DtTableMetadata { id: 1, rev: 0, custom: Default::default() },
+            "First dttable entry metadata is incorrect"
+        );
+        assert_eq!(
+            second_entry.metadata,
+            DtTableMetadata { id: 2, rev: 0, custom: Default::default() },
+            "Second dttable entry metadata is incorrect"
+        );
+
+        // Verify FDT headers are properly parsed
+        let _ = Fdt::new(first_entry.dtb).unwrap();
+        let _ = Fdt::new(second_entry.dtb).unwrap();
+    }
+
     #[test]
     fn test_failed_to_parse_corrupted_dt_table() {
-        let dttable = include_bytes!("../test/corrupted_dttable.img").to_vec();
+        let dttable = include_bytes!("../test/data/corrupted_dttable.img").to_vec();
 
         assert!(
             DtTableImage::from_bytes(&dttable[..]).is_err(),
diff --git a/gbl/libdttable/test/BUILD b/gbl/libdttable/test/data/BUILD
similarity index 85%
rename from gbl/libdttable/test/BUILD
rename to gbl/libdttable/test/data/BUILD
index 8798319..8012128 100644
--- a/gbl/libdttable/test/BUILD
+++ b/gbl/libdttable/test/data/BUILD
@@ -12,4 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-exports_files(glob(["**/*"]))
+filegroup(
+    name = "all",
+    srcs = glob(["**/*"]),
+    visibility = ["//visibility:public"],
+)
diff --git a/gbl/libdttable/test/corrupted_dttable.img b/gbl/libdttable/test/data/corrupted_dttable.img
similarity index 100%
rename from gbl/libdttable/test/corrupted_dttable.img
rename to gbl/libdttable/test/data/corrupted_dttable.img
diff --git a/gbl/libdttable/test/dttable.img b/gbl/libdttable/test/data/dttable.img
similarity index 100%
rename from gbl/libdttable/test/dttable.img
rename to gbl/libdttable/test/data/dttable.img
diff --git a/gbl/libdttable/test/gen_test_dttable.sh b/gbl/libdttable/test/gen_test_dttable.sh
index 04afca9..0632395 100755
--- a/gbl/libdttable/test/gen_test_dttable.sh
+++ b/gbl/libdttable/test/gen_test_dttable.sh
@@ -17,14 +17,15 @@
 set -e
 
 readonly SCRIPT_DIR=`cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd`
+readonly DATA_DIR="${SCRIPT_DIR}/data/"
 readonly TMP_DIR=`mktemp -d`
 
 dtc -I dts -O dtb -o ${TMP_DIR}/a.dtb ${SCRIPT_DIR}/a.dts
 dtc -I dts -O dtb -o ${TMP_DIR}/b.dtb ${SCRIPT_DIR}/b.dts
 
-echo "corrupted dttable" > ${SCRIPT_DIR}/corrupted_dttable.img
+echo "corrupted dttable" > ${DATA_DIR}/corrupted_dttable.img
 
 # mkdtboimg is built by cd aosp/system/libufdt/utils && mm
-mkdtboimg create ${SCRIPT_DIR}/dttable.img \
+mkdtboimg create ${DATA_DIR}/dttable.img \
         --id=0x2 --rev=0x0 ${TMP_DIR}/b.dtb \
         --id=0x1 --rev=0x0 ${TMP_DIR}/a.dtb
diff --git a/gbl/libefi/BUILD b/gbl/libefi/BUILD
index 969947d..56feebf 100644
--- a/gbl/libefi/BUILD
+++ b/gbl/libefi/BUILD
@@ -32,6 +32,7 @@ rust_library(
         "@gbl//libgbl",
         "@gbl//libsafemath",
         "@gbl//libstorage",
+        "@gbl//libutils",
         "@spin",
         "@zerocopy",
     ],
@@ -43,8 +44,7 @@ rust_test(
     rustc_flags = ANDROID_RUST_LINTS,
     deps = [
         "@gbl//libavb:sysdeps",
-        "@gbl//libstorage:libstorage_testlib",
-        "@gbl//third_party/libzbi",
+        "@zbi",
     ],
 )
 
diff --git a/gbl/libefi/mocks/lib.rs b/gbl/libefi/mocks/lib.rs
index 8b21cba..222bd7b 100644
--- a/gbl/libefi/mocks/lib.rs
+++ b/gbl/libefi/mocks/lib.rs
@@ -25,7 +25,11 @@ pub mod utils;
 use efi_types::{EfiConfigurationTable, EfiTimerDelay};
 use liberror::Result;
 use mockall::mock;
-use protocol::simple_text_output::{passthrough_con_out, MockSimpleTextOutputProtocol};
+use protocol::{
+    gbl_efi_ab_slot::GblSlotProtocol,
+    gbl_efi_avb::GblAvbProtocol,
+    simple_text_output::{passthrough_con_out, MockSimpleTextOutputProtocol},
+};
 use std::cell::RefCell;
 
 /// libefi types that can be used in tests as-is.
@@ -57,6 +61,8 @@ pub struct MockEfi {
     pub entry: MockEfiEntry,
     /// The global [MockSystemTable] to set expectations on.
     pub system_table: MockSystemTable,
+    /// The global [MockBootServices] to set expectations on.
+    pub boot_services: MockBootServices,
     /// The global [MockSimpleTextOutputProtocol] to set expectations on.
     pub con_out: MockSimpleTextOutputProtocol,
 }
@@ -81,11 +87,13 @@ impl MockEfi {
         entry.expect_system_table().returning(|| passthrough_system_table());
 
         let mut system_table = MockSystemTable::default();
+        system_table.expect_boot_services().returning(|| passthrough_boot_services());
         system_table.expect_con_out().returning(|| Ok(passthrough_con_out()));
 
+        let boot_services = MockBootServices::default();
         let con_out = MockSimpleTextOutputProtocol::default();
 
-        Self { entry, system_table, con_out }
+        Self { entry, system_table, boot_services, con_out }
     }
 
     /// Installs the [MockEfi] in thread-local state.
@@ -163,6 +171,9 @@ mock! {
         /// Returns a [MockBootServices].
         pub fn boot_services(&self) -> MockBootServices;
 
+        /// Returns a [MockRuntimeServices].
+        pub fn runtime_services(&self) -> MockRuntimeServices;
+
         /// Returns a [MockSimpleTextOutputProtocol]. This is a singleton protocol which is
         /// always-open, as opposed to most protocols which need to be opened explicitly.
         pub fn con_out(&self) -> Result<MockSimpleTextOutputProtocol>;
@@ -181,6 +192,9 @@ impl !Send for MockSystemTable {}
 /// Returns a [MockSystemTable] that forwards all calls to `MOCK_EFI`.
 fn passthrough_system_table() -> MockSystemTable {
     let mut table = MockSystemTable::default();
+    table.expect_boot_services().returning(|| {
+        MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().system_table.boot_services())
+    });
     table
         .expect_con_out()
         .returning(|| MOCK_EFI.with_borrow_mut(|efi| efi.as_mut().unwrap().system_table.con_out()));
@@ -219,6 +233,23 @@ mock! {
 /// Map to the libefi name so code under test can just use one name.
 pub type BootServices = MockBootServices;
 
+/// Returns a [MockBootServices] that forwards all calls to `MOCK_EFI`.
+fn passthrough_boot_services() -> MockBootServices {
+    let mut services = MockBootServices::default();
+    services.expect_find_first_and_open::<GblAvbProtocol>().returning(|| {
+        MOCK_EFI.with_borrow_mut(|efi| {
+            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblAvbProtocol>()
+        })
+    });
+    services.expect_find_first_and_open::<GblSlotProtocol>().returning(|| {
+        MOCK_EFI.with_borrow_mut(|efi| {
+            efi.as_mut().unwrap().boot_services.find_first_and_open::<GblSlotProtocol>()
+        })
+    });
+
+    services
+}
+
 mock! {
     /// Mock [efi::LocatedHandles].
     pub LocatedHandles {}
@@ -233,6 +264,17 @@ mock! {
 /// Map to the libefi name so code under test can just use one name.
 pub type Event = MockEvent;
 
+mock! {
+    /// Mock [efi::RuntimeServices].
+    pub RuntimeServices {
+        /// Performs a cold reset.
+        pub fn cold_reset(&self);
+    }
+}
+
+/// Map to the libefi name so code under test can just use one name.
+pub type RuntimeServices = MockRuntimeServices;
+
 #[cfg(test)]
 pub mod test {
     use super::*;
diff --git a/gbl/libefi/mocks/protocol.rs b/gbl/libefi/mocks/protocol.rs
index bd1d7dd..07206ba 100644
--- a/gbl/libefi/mocks/protocol.rs
+++ b/gbl/libefi/mocks/protocol.rs
@@ -18,9 +18,13 @@
 //! to either one using the same path.
 
 use crate::{DeviceHandle, MOCK_EFI};
+use core::ffi::CStr;
 use core::fmt::Write;
 use efi::protocol::gbl_efi_image_loading::EfiImageBuffer;
-use efi_types::{EfiInputKey, GblEfiImageInfo, GblEfiPartitionName};
+use efi_types::{
+    EfiInputKey, GblEfiAvbKeyValidationStatus, GblEfiAvbVerificationResult, GblEfiImageInfo,
+    GblEfiPartitionName, GblEfiVerifiedDeviceTree,
+};
 use liberror::Result;
 use mockall::mock;
 
@@ -148,3 +152,196 @@ pub mod gbl_efi_image_loading {
     /// Map to the libefi name so code under test can just use one name.
     pub type GblImageLoadingProtocol = MockGblImageLoadingProtocol;
 }
+
+/// Mock os_configuration protocol.
+pub mod gbl_efi_os_configuration {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::OsConfigurationProtocol].
+        pub GblOsConfigurationProtocol {
+            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_kernel_commandline()`
+            pub fn fixup_kernel_commandline(
+                &self,
+                commandline: &CStr,
+                fixup: &[u8],
+            ) -> Result<()>;
+
+            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_bootconfig()`
+            pub fn fixup_bootconfig(
+                &self,
+                bootconfig: &[u8],
+                fixup: &mut [u8],
+            ) -> Result<usize>;
+
+            /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.select_device_trees()`
+            pub fn select_device_trees(
+                &self,
+                components: &mut [GblEfiVerifiedDeviceTree],
+            ) -> Result<()>;
+        }
+    }
+
+    /// Map to the libefi name so code under test can just use one name.
+    pub type GblOsConfigurationProtocol = MockGblOsConfigurationProtocol;
+}
+
+/// Mock dt_fixup protocol.
+pub mod dt_fixup {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::DtFixupProtocol].
+        pub DtFixupProtocol {
+            /// Wraps `EFI_DT_FIXUP_PROTOCOL.fixup()`
+            pub fn fixup(&self, device_tree: &mut [u8]) -> Result<()>;
+        }
+    }
+
+    /// Map to the libefi name so code under test can just use one name.
+    pub type DtFixupProtocol = MockDtFixupProtocol;
+}
+
+/// Mock avb protocol.
+pub mod gbl_efi_avb {
+    use super::*;
+
+    /// Mock implementation of `GBL_EFI_AVB_PROTOCOL`.
+    /// We use a custom mock implementation instead of relying on `mockall` due to its limitations
+    /// regarding argument lifetimes. Specifically, in this case, `mockall` requires the
+    /// `validate_vbmeta_public_key.public_key_metadata` argument to have a `'static` lifetime,
+    /// which is not practical for our use case.
+    #[derive(Clone, Default)]
+    pub struct GblAvbProtocol {
+        /// Expected return value from `validate_vbmeta_public_key`.
+        pub validate_vbmeta_public_key_result: Option<Result<GblEfiAvbKeyValidationStatus>>,
+        /// Expected return value from `read_is_device_unlocked`.
+        pub read_is_device_unlocked_result: Option<Result<bool>>,
+        /// Expected return value from `read_rollback_index`.
+        pub read_rollback_index_result: Option<Result<u64>>,
+        /// Expected return value from `write_rollback_index`.
+        pub write_rollback_index_result: Option<Result<()>>,
+        /// Expected return value from `read_persistent_value`.
+        pub read_persistent_value_result: Option<Result<usize>>,
+        /// Expected return value from `write_persistent_value`.
+        pub write_persistent_value_result: Option<Result<()>>,
+    }
+
+    impl GblAvbProtocol {
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.validate_vbmeta_public_key()`.
+        pub fn validate_vbmeta_public_key(
+            &self,
+            _public_key: &[u8],
+            _public_key_metadata: Option<&[u8]>,
+        ) -> Result<GblEfiAvbKeyValidationStatus> {
+            self.validate_vbmeta_public_key_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_is_device_unlocked()`.
+        pub fn read_is_device_unlocked(&self) -> Result<bool> {
+            self.read_is_device_unlocked_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_rollback_index()`.
+        pub fn read_rollback_index(&self, _index_location: usize) -> Result<u64> {
+            self.read_rollback_index_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.write_rollback_index()`.
+        pub fn write_rollback_index(
+            &self,
+            _index_location: usize,
+            _rollback_index: u64,
+        ) -> Result<()> {
+            self.write_rollback_index_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.read_persistent_value()`.
+        pub fn read_persistent_value(&self, _name: &CStr, _value: &mut [u8]) -> Result<usize> {
+            self.read_persistent_value_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.write_persistent_value()`.
+        pub fn write_persistent_value(&self, _name: &CStr, _value: Option<&[u8]>) -> Result<()> {
+            self.write_persistent_value_result.unwrap()
+        }
+
+        /// Wraps `GBL_EFI_AVB_PROTOCOL.handle_verification_result()`.
+        pub fn handle_verification_result(
+            &self,
+            _verification_result: &GblEfiAvbVerificationResult,
+        ) -> Result<()> {
+            unimplemented!();
+        }
+    }
+}
+
+/// Mock gbl_efi_fastboot protocol.
+pub mod gbl_efi_fastboot {
+    use super::*;
+
+    mock! {
+        /// Mock [efi::protocol::gbl_efi_fastboot::Var].
+        pub Var {
+            /// Get name, arguments and corresponding value.
+            pub fn get<'s>(&self, out: &mut [u8])
+                -> Result<(&'static str, [&'static str; 1], &'static str)>;
+        }
+    }
+
+    /// Mock [efi::GblFastbootProtocol].
+    pub struct GblFastbootProtocol {}
+
+    impl GblFastbootProtocol {
+        /// Protocol<'_, GblFastbootProtocol>::get_var.
+        pub fn get_var<'a>(
+            &self,
+            _: &CStr,
+            _: impl Iterator<Item = &'a CStr> + Clone,
+            _: &mut [u8],
+        ) -> Result<usize> {
+            unimplemented!()
+        }
+
+        /// Protocol<'_, GblFastbootProtocol>::get_var_all.
+        pub fn get_var_all(&self, _: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
+            unimplemented!()
+        }
+    }
+
+    /// Map to the libefi name so code under test can just use one name.
+    pub type Var = MockVar;
+}
+
+/// Mock gbl_efi_ab_slot
+pub mod gbl_efi_ab_slot {
+    use super::*;
+    use efi::protocol::gbl_efi_ab_slot::GblSlot;
+    use efi_types::{GblEfiBootReason, GblEfiSlotMetadataBlock};
+
+    mock! {
+        /// Mock of [GblSlotProtocol]
+        pub GblSlotProtocol {
+            /// Mock of GblSlotProtocol::get_current_slot.
+            pub fn get_current_slot(&self) -> Result<GblSlot>;
+
+            /// Mock of GblSlotProtocol::get_next_slot.
+            pub fn get_next_slot(&self, mark_boot_attempt: bool) -> Result<GblSlot>;
+
+            /// Mock of GblSlotProtocol::load_boot_data.
+            pub fn load_boot_data(&self) -> Result<GblEfiSlotMetadataBlock>;
+
+            /// Mock of GblSlotProtocol::set_active_slot.
+            pub fn set_active_slot(&self, idx: u8) -> Result<()>;
+
+            /// Mock of GblSlotProtocol::set_boot_reason.
+            pub fn set_boot_reason(&self, reason: GblEfiBootReason, subreason: &[u8]) -> Result<()>;
+
+            /// Mock of GblSlotProtocol::get_boot_reason.
+            pub fn get_boot_reason(&self, subreason: &mut [u8]) -> Result<(GblEfiBootReason, usize)>;
+        }
+    }
+
+    /// Map to the libefi name so code under test can just use one name.
+    pub type GblSlotProtocol = MockGblSlotProtocol;
+}
diff --git a/gbl/libefi/src/ab_slots.rs b/gbl/libefi/src/ab_slots.rs
index c9c5242..c5603f1 100644
--- a/gbl/libefi/src/ab_slots.rs
+++ b/gbl/libefi/src/ab_slots.rs
@@ -23,9 +23,9 @@ use gbl::slots::{
 use liberror::{Error, Result};
 
 use efi_types::{
-    GBL_EFI_BOOT_REASON_GBL_EFI_BOOTLOADER as REASON_BOOTLOADER,
-    GBL_EFI_BOOT_REASON_GBL_EFI_EMPTY_BOOT_REASON as REASON_EMPTY,
-    GBL_EFI_BOOT_REASON_GBL_EFI_RECOVERY as REASON_RECOVERY,
+    GBL_EFI_BOOT_REASON_BOOTLOADER as REASON_BOOTLOADER,
+    GBL_EFI_BOOT_REASON_EMPTY_BOOT_REASON as REASON_EMPTY,
+    GBL_EFI_BOOT_REASON_RECOVERY as REASON_RECOVERY,
 };
 
 use crate::protocol::{gbl_efi_ab_slot as ab_slot, Protocol};
@@ -83,7 +83,6 @@ impl Manager for ABManager<'_> {
     }
 
     fn mark_boot_attempt(&mut self) -> Result<BootToken> {
-        self.protocol.mark_boot_attempt().or(Err(Error::OperationProhibited))?;
         self.boot_token.take().ok_or(Error::OperationProhibited)
     }
 
@@ -150,7 +149,7 @@ impl Manager for ABManager<'_> {
         }
     }
 
-    fn write_back(&mut self, _: &mut dyn gbl_storage::AsBlockDevice) {
+    fn write_back(&mut self, _: &mut dyn FnMut(&mut [u8]) -> Result<()>) {
         // Note: `expect` instead of swallowing the error.
         // It is important that changes are not silently dropped.
         self.protocol.flush().expect("could not write back modifications to slot metadata");
@@ -168,20 +167,28 @@ mod test {
     use efi_types::{
         EfiStatus, GblEfiABSlotProtocol, GblEfiSlotInfo, GblEfiSlotMetadataBlock,
         EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
-        GBL_EFI_BOOT_REASON_GBL_EFI_EMPTY_BOOT_REASON as REASON_EMPTY,
-        GBL_EFI_BOOT_REASON_GBL_EFI_RECOVERY as REASON_RECOVERY,
-        GBL_EFI_BOOT_REASON_GBL_EFI_WATCHDOG as REASON_WATCHDOG,
+        GBL_EFI_BOOT_REASON_EMPTY_BOOT_REASON as REASON_EMPTY,
+        GBL_EFI_BOOT_REASON_RECOVERY as REASON_RECOVERY,
+        GBL_EFI_BOOT_REASON_WATCHDOG as REASON_WATCHDOG,
     };
     use gbl::{
-        ops::{AvbIoResult, CertPermanentAttributes, SHA256_DIGEST_SIZE},
-        partition::PartitionBlockDevice,
+        ops::{
+            AvbIoResult, CertPermanentAttributes, RebootReason, SlotsMetadata, SHA256_DIGEST_SIZE,
+        },
+        partition::GblDisk,
         slots::{Bootability, Cursor, RecoveryTarget, UnbootableReason},
-        BootImages, Gbl, GblOps, Result as GblResult,
+        Gbl, GblOps, Os, Result as GblResult,
+    };
+    use gbl_storage::{BlockIo, BlockIoNull, Disk, Gpt};
+    use libgbl::{
+        device_tree::DeviceTreeComponentsRegistry,
+        gbl_avb::state::{BootStateColor, KeyValidationStatus},
+        ops::ImageBuffer,
     };
-    use gbl_storage_testlib::TestBlockDevice;
-    use libgbl::ops::ImageBuffer;
     // TODO(b/350526796): use ptr.is_aligned() when Rust 1.79 is in Android
+    use core::ops::DerefMut;
     use std::{
+        ffi::CStr,
         fmt::Write,
         mem::align_of,
         num::NonZeroUsize,
@@ -243,10 +250,7 @@ mod test {
         }
     }
 
-    impl<'a> GblOps<'a> for TestGblOps<'_>
-    where
-        Self: 'a,
-    {
+    impl<'a, 'd> GblOps<'a, 'd> for TestGblOps<'_> {
         fn console_out(&mut self) -> Option<&mut dyn Write> {
             unimplemented!();
         }
@@ -255,29 +259,38 @@ mod test {
             unimplemented!();
         }
 
-        fn preboot(&mut self, _: BootImages) -> Result<()> {
+        fn reboot(&mut self) {
             unimplemented!();
         }
 
-        fn partitions(&self) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>]> {
-            unimplemented!();
+        fn disks(
+            &self,
+        ) -> &'a [GblDisk<
+            Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
+            Gpt<impl DerefMut<Target = [u8]> + 'a>,
+        >] {
+            &[] as &[GblDisk<Disk<BlockIoNull, &mut [u8]>, Gpt<&mut [u8]>>]
+        }
+
+        fn expected_os(&mut self) -> Result<Option<Os>> {
+            Ok(None)
         }
 
         fn zircon_add_device_zbi_items(&mut self, _: &mut ZbiContainer<&mut [u8]>) -> Result<()> {
             unimplemented!();
         }
 
-        fn do_fastboot<B: gbl_storage::AsBlockDevice>(&self, _: &mut Cursor<B>) -> GblResult<()> {
-            unimplemented!();
+        fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
+            None
         }
 
-        fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+        fn load_slot_interface<'b>(
             &'b mut self,
-            block_dev: &'b mut B,
+            persist: &'b mut dyn FnMut(&mut [u8]) -> Result<()>,
             boot_token: BootToken,
-        ) -> GblResult<Cursor<'b, B>> {
+        ) -> GblResult<Cursor<'b>> {
             self.manager.boot_token = Some(boot_token);
-            Ok(Cursor { ctx: &mut self.manager, block_dev })
+            Ok(Cursor { ctx: &mut self.manager, persist })
         }
 
         fn avb_read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
@@ -296,6 +309,14 @@ mod test {
             unimplemented!();
         }
 
+        fn avb_validate_vbmeta_public_key(
+            &self,
+            _public_key: &[u8],
+            _public_key_metadata: Option<&[u8]>,
+        ) -> AvbIoResult<KeyValidationStatus> {
+            unimplemented!();
+        }
+
         fn avb_cert_read_permanent_attributes(
             &mut self,
             _attributes: &mut CertPermanentAttributes,
@@ -309,17 +330,111 @@ mod test {
             unimplemented!();
         }
 
-        fn get_image_buffer<'c>(
+        fn avb_read_persistent_value(
+            &mut self,
+            _name: &CStr,
+            _value: &mut [u8],
+        ) -> AvbIoResult<usize> {
+            unimplemented!();
+        }
+
+        fn avb_write_persistent_value(&mut self, _name: &CStr, _value: &[u8]) -> AvbIoResult<()> {
+            unimplemented!();
+        }
+
+        fn avb_erase_persistent_value(&mut self, _name: &CStr) -> AvbIoResult<()> {
+            unimplemented!();
+        }
+
+        fn avb_handle_verification_result(
+            &mut self,
+            _color: BootStateColor,
+            _digest: Option<&CStr>,
+            _boot_os_version: Option<&[u8]>,
+            _boot_security_patch: Option<&[u8]>,
+            _system_os_version: Option<&[u8]>,
+            _system_security_patch: Option<&[u8]>,
+            _vendor_os_version: Option<&[u8]>,
+            _vendor_security_patch: Option<&[u8]>,
+        ) -> AvbIoResult<()> {
+            unimplemented!();
+        }
+
+        fn get_image_buffer(
             &mut self,
             _image_name: &str,
             _size: NonZeroUsize,
-        ) -> GblResult<ImageBuffer<'c>> {
+        ) -> GblResult<ImageBuffer<'d>> {
             unimplemented!();
         }
 
         fn get_custom_device_tree(&mut self) -> Option<&'a [u8]> {
             unimplemented!();
         }
+
+        fn fixup_os_commandline<'c>(
+            &mut self,
+            _commandline: &CStr,
+            _fixup_buffer: &'c mut [u8],
+        ) -> Result<Option<&'c str>> {
+            unimplemented!();
+        }
+
+        fn fixup_bootconfig<'c>(
+            &mut self,
+            _bootconfig: &[u8],
+            _fixup_buffer: &'c mut [u8],
+        ) -> Result<Option<&'c [u8]>> {
+            unimplemented!();
+        }
+
+        fn fixup_device_tree(&mut self, _device_tree: &mut [u8]) -> Result<()> {
+            unimplemented!();
+        }
+
+        fn select_device_trees(
+            &mut self,
+            _components: &mut DeviceTreeComponentsRegistry,
+        ) -> Result<()> {
+            unimplemented!();
+        }
+
+        fn fastboot_variable<'arg>(
+            &mut self,
+            _: &CStr,
+            _: impl Iterator<Item = &'arg CStr> + Clone,
+            _: &mut [u8],
+        ) -> Result<usize> {
+            unimplemented!()
+        }
+
+        fn fastboot_visit_all_variables(&mut self, _: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
+            unimplemented!()
+        }
+
+        fn slots_metadata(&mut self) -> Result<SlotsMetadata> {
+            unimplemented!();
+        }
+
+        fn get_current_slot(&mut self) -> Result<Slot> {
+            unimplemented!()
+        }
+
+        fn get_next_slot(&mut self, _: bool) -> Result<Slot> {
+            unimplemented!()
+        }
+
+        fn set_active_slot(&mut self, _: u8) -> Result<()> {
+            unimplemented!()
+        }
+
+        fn set_reboot_reason(&mut self, _: RebootReason) -> Result<()> {
+            unimplemented!()
+        }
+
+        fn get_reboot_reason(&mut self) -> Result<RebootReason> {
+            unimplemented!()
+        }
     }
 
     #[test]
@@ -331,10 +446,10 @@ mod test {
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
 
             {
-                let mut block_device: TestBlockDevice = Default::default();
+                let mut persist = |_: &mut [u8]| Ok(());
                 let mut test_ops = TestGblOps::new(protocol);
                 let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-                let _ = gbl.load_slot_interface(&mut block_device).unwrap();
+                let _ = gbl.load_slot_interface(&mut persist).unwrap();
             }
         });
         assert!(ATOMIC.with(|a| a.load(Ordering::Relaxed)));
@@ -350,10 +465,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
 
             let slots: Vec<Slot> = cursor.ctx.slots_iter().collect();
             assert_eq!(
@@ -439,10 +554,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
 
             let slot = Slot {
                 suffix: 'a'.into(),
@@ -463,26 +578,15 @@ mod test {
 
     #[test]
     fn test_mark_boot_attempt() {
-        extern "C" fn mark_boot_attempt(_: *mut GblEfiABSlotProtocol) -> EfiStatus {
-            ATOMIC.with(|a| a.store(true, Ordering::Relaxed));
-            EFI_STATUS_SUCCESS
-        }
-
-        ATOMIC.with(|a| a.store(false, Ordering::Relaxed));
         run_test(|image_handle, systab_ptr| {
-            let mut ab = GblEfiABSlotProtocol {
-                mark_boot_attempt: Some(mark_boot_attempt),
-                flush: Some(flush),
-                ..Default::default()
-            };
+            let mut ab = GblEfiABSlotProtocol { flush: Some(flush), ..Default::default() };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
             assert!(cursor.ctx.mark_boot_attempt().is_ok());
-            assert!(ATOMIC.with(|a| a.load(Ordering::Relaxed)));
 
             assert_eq!(cursor.ctx.mark_boot_attempt(), Err(Error::OperationProhibited));
         });
@@ -521,10 +625,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
             assert_eq!(cursor.ctx.get_max_retries().unwrap(), 66usize.into());
         });
     }
@@ -550,10 +654,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
 
             assert_eq!(cursor.ctx.set_active_slot('b'.into()), Ok(()));
             assert_eq!(cursor.ctx.set_active_slot('c'.into()), Err(Error::Other(None)));
@@ -590,10 +694,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
 
             assert_eq!(
                 cursor.ctx.set_slot_unbootable('a'.into(), UnbootableReason::SystemUpdate),
@@ -647,10 +751,10 @@ mod test {
             };
             let efi_entry = EfiEntry { image_handle, systab_ptr };
             let protocol = generate_protocol::<ab_slot::GblSlotProtocol>(&efi_entry, &mut ab);
-            let mut block_device: TestBlockDevice = Default::default();
+            let mut persist = |_: &mut [u8]| Ok(());
             let mut test_ops = TestGblOps::new(protocol);
             let mut gbl = Gbl::<TestGblOps>::new(&mut test_ops);
-            let cursor = gbl.load_slot_interface(&mut block_device).unwrap();
+            let cursor = gbl.load_slot_interface(&mut persist).unwrap();
 
             assert_eq!(cursor.ctx.get_oneshot_status(), None);
             assert_eq!(
diff --git a/gbl/libefi/src/allocation.rs b/gbl/libefi/src/allocation.rs
index a0be720..03a27b0 100644
--- a/gbl/libefi/src/allocation.rs
+++ b/gbl/libefi/src/allocation.rs
@@ -12,12 +12,15 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::EfiEntry;
+use crate::{EfiEntry, RuntimeServices};
 use efi_types::EFI_MEMORY_TYPE_LOADER_DATA;
 
-use core::alloc::{GlobalAlloc, Layout};
 use core::mem::size_of_val;
 use core::ptr::null_mut;
+use core::{
+    alloc::{GlobalAlloc, Layout},
+    fmt::Write,
+};
 use liberror::{Error, Result};
 use safemath::SafeNum;
 
@@ -28,12 +31,18 @@ use safemath::SafeNum;
 /// ```
 /// #[no_mangle]
 /// #[global_allocator]
-/// static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiAllocator::Uninitialized;
+/// static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator = EfiState::new();
 /// ```
 ///
 /// This is only useful for real UEFI applications; attempting to install the `EFI_GLOBAL_ALLOCATOR`
 /// for host-side unit tests will cause the test to panic immediately.
-pub enum EfiAllocator {
+pub struct EfiAllocator {
+    state: EfiState,
+    runtime_services: Option<RuntimeServices>,
+}
+
+/// Represents the global EFI state.
+enum EfiState {
     /// Initial state, no UEFI entry point has been set, global hooks will not work.
     Uninitialized,
     /// [EfiEntry] is registered, global hooks are active.
@@ -42,6 +51,16 @@ pub enum EfiAllocator {
     Exited,
 }
 
+impl EfiState {
+    /// Returns a reference to the EfiEntry.
+    fn efi_entry(&self) -> Option<&EfiEntry> {
+        match self {
+            EfiState::Initialized(ref entry) => Some(entry),
+            _ => None,
+        }
+    }
+}
+
 // This is a bit ugly, but we only expect this library to be used by our EFI application so it
 // doesn't need to be super clean or scalable. The user has to declare the global variable
 // exactly as written in the [EfiAllocator] docs for this to link properly.
@@ -49,14 +68,34 @@ extern "Rust" {
     static mut EFI_GLOBAL_ALLOCATOR: EfiAllocator;
 }
 
-/// An internal API to obtain library internal global EfiEntry.
-pub(crate) fn internal_efi_entry() -> Option<&'static EfiEntry> {
+/// An internal API to obtain library internal global EfiEntry and RuntimeServices.
+pub(crate) fn internal_efi_entry_and_rt(
+) -> (Option<&'static EfiEntry>, Option<&'static RuntimeServices>) {
     // SAFETY:
-    // For now, `EfiAllocator` is only modified in `init_efi_global_alloc()` when `EfiAllocator` is
-    // being initialized or in `exit_efi_global_alloc` after `EFI_BOOT_SERVICES.
-    // ExitBootServices()` is called, where there should be no event/notification function that can
-    // be triggered. Therefore, it should be safe from race condition.
-    unsafe { EFI_GLOBAL_ALLOCATOR.get_efi_entry() }
+    // EFI_GLOBAL_ALLOCATOR is only read by `internal_efi_entry_and_rt()` and modified by
+    // `init_efi_global_alloc()` and `exit_efi_global_alloc()`. The safety requirements of
+    // `init_efi_global_alloc()` and `exit_efi_global_alloc()` mandate that there can be no EFI
+    // event/notification/interrupt that can be triggered when they are called. This suggests that
+    // there cannot be concurrent read and modification on `EFI_GLOBAL_ALLOCATOR` possible. Thus its
+    // access is safe from race condition.
+    unsafe { EFI_GLOBAL_ALLOCATOR.get_efi_entry_and_rt() }
+}
+
+/// Try to print via `EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL` in `EFI_SYSTEM_TABLE.ConOut`.
+///
+/// Errors are ignored.
+#[macro_export]
+macro_rules! efi_try_print {
+    ($( $x:expr ),* $(,)? ) => {
+        {
+            let _ = (|| -> Result<()> {
+                if let Some(entry) = crate::allocation::internal_efi_entry_and_rt().0 {
+                    write!(entry.system_table_checked()?.con_out()?, $($x,)*)?;
+                }
+                Ok(())
+            })();
+        }
+    };
 }
 
 /// Initializes global allocator.
@@ -67,11 +106,13 @@ pub(crate) fn internal_efi_entry() -> Option<&'static EfiEntry> {
 /// there is no event/notification function that can be triggered or modify it. Otherwise there
 /// is a risk of race condition.
 pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> Result<()> {
-    // SAFETY: See SAFETY of `internal_efi_entry()`
+    // SAFETY: See SAFETY of `internal_efi_entry_and_rt()`
     unsafe {
-        match EFI_GLOBAL_ALLOCATOR {
-            EfiAllocator::Uninitialized => {
-                EFI_GLOBAL_ALLOCATOR = EfiAllocator::Initialized(efi_entry);
+        EFI_GLOBAL_ALLOCATOR.runtime_services =
+            efi_entry.system_table_checked().and_then(|v| v.runtime_services_checked()).ok();
+        match EFI_GLOBAL_ALLOCATOR.state {
+            EfiState::Uninitialized => {
+                EFI_GLOBAL_ALLOCATOR.state = EfiState::Initialized(efi_entry);
                 Ok(())
             }
             _ => Err(Error::AlreadyStarted),
@@ -87,41 +128,46 @@ pub(crate) unsafe fn init_efi_global_alloc(efi_entry: EfiEntry) -> Result<()> {
 /// there is no event/notification function that can be triggered or modify it. Otherwise there
 /// is a risk of race condition.
 pub(crate) unsafe fn exit_efi_global_alloc() {
-    // SAFETY: See SAFETY of `internal_efi_entry()`
+    // SAFETY: See SAFETY of `internal_efi_entry_and_rt()`
     unsafe {
-        EFI_GLOBAL_ALLOCATOR = EfiAllocator::Exited;
+        EFI_GLOBAL_ALLOCATOR.state = EfiState::Exited;
     }
 }
 
 impl EfiAllocator {
-    /// Returns a reference to the EfiEntry.
-    fn get_efi_entry(&self) -> Option<&EfiEntry> {
-        match self {
-            EfiAllocator::Initialized(ref entry) => Some(entry),
-            _ => None,
-        }
+    /// Creates a new instance.
+    pub const fn new() -> Self {
+        Self { state: EfiState::Uninitialized, runtime_services: None }
+    }
+
+    /// Gets EfiEntry and RuntimeServices
+    fn get_efi_entry_and_rt(&self) -> (Option<&EfiEntry>, Option<&RuntimeServices>) {
+        (self.state.efi_entry(), self.runtime_services.as_ref())
     }
 
     /// Allocate memory via EFI_BOOT_SERVICES.
     fn allocate(&self, size: usize) -> *mut u8 {
-        match self
-            .get_efi_entry()
-            .unwrap()
-            .system_table()
-            .boot_services()
-            .allocate_pool(EFI_MEMORY_TYPE_LOADER_DATA, size)
-        {
-            Ok(p) => p as *mut _,
-            _ => null_mut(),
-        }
+        self.state
+            .efi_entry()
+            .ok_or(Error::InvalidState)
+            .and_then(|v| v.system_table_checked())
+            .and_then(|v| v.boot_services_checked())
+            .and_then(|v| v.allocate_pool(EFI_MEMORY_TYPE_LOADER_DATA, size))
+            .inspect_err(|e| efi_try_print!("failed to allocate: {e}"))
+            .unwrap_or(null_mut()) as _
     }
 
-    /// Deallocate memory previously allocated by `Self::allocate()`. Passing invalid pointer will
-    /// cause the method to panic.
+    /// Deallocate memory previously allocated by `Self::allocate()`.
+    ///
+    /// Errors are logged but ignored.
     fn deallocate(&self, ptr: *mut u8) {
-        match self.get_efi_entry() {
+        match self.state.efi_entry() {
             Some(ref entry) => {
-                entry.system_table().boot_services().free_pool(ptr as *mut _).unwrap();
+                let _ = entry
+                    .system_table_checked()
+                    .and_then(|v| v.boot_services_checked())
+                    .and_then(|v| v.free_pool(ptr as *mut _))
+                    .inspect_err(|e| efi_try_print!("failed to deallocate: {e}"));
             }
             // After EFI_BOOT_SERVICES.ExitBootServices(), all allocated memory is considered
             // leaked and under full ownership of subsequent OS loader code.
diff --git a/gbl/libefi/src/lib.rs b/gbl/libefi/src/lib.rs
index e88e5dd..ca862a9 100644
--- a/gbl/libefi/src/lib.rs
+++ b/gbl/libefi/src/lib.rs
@@ -69,18 +69,21 @@ use core::{fmt::Write, panic::PanicInfo};
 
 use core::{marker::PhantomData, ptr::null_mut, slice::from_raw_parts};
 use efi_types::{
-    EfiBootService, EfiConfigurationTable, EfiEvent, EfiGuid, EfiHandle, EfiMemoryDescriptor,
-    EfiMemoryType, EfiRuntimeService, EfiSystemTable, EfiTimerDelay, EFI_EVENT_TYPE_NOTIFY_SIGNAL,
-    EFI_EVENT_TYPE_NOTIFY_WAIT, EFI_EVENT_TYPE_RUNTIME, EFI_EVENT_TYPE_SIGNAL_EXIT_BOOT_SERVICES,
+    EfiBootService, EfiConfigurationTable, EfiEvent, EfiGuid, EfiHandle,
+    EfiMemoryAttributesTableHeader, EfiMemoryDescriptor, EfiMemoryType, EfiRuntimeService,
+    EfiSystemTable, EfiTimerDelay, EFI_EVENT_TYPE_NOTIFY_SIGNAL, EFI_EVENT_TYPE_NOTIFY_WAIT,
+    EFI_EVENT_TYPE_RUNTIME, EFI_EVENT_TYPE_SIGNAL_EXIT_BOOT_SERVICES,
     EFI_EVENT_TYPE_SIGNAL_VIRTUAL_ADDRESS_CHANGE, EFI_EVENT_TYPE_TIMER,
     EFI_LOCATE_HANDLE_SEARCH_TYPE_BY_PROTOCOL, EFI_OPEN_PROTOCOL_ATTRIBUTE_BY_HANDLE_PROTOCOL,
+    EFI_RESET_TYPE, EFI_RESET_TYPE_EFI_RESET_COLD, EFI_STATUS, EFI_STATUS_SUCCESS,
 };
 use liberror::{Error, Result};
+use libutils::aligned_subslice;
 use protocol::{
     simple_text_output::SimpleTextOutputProtocol,
     {Protocol, ProtocolInfo},
 };
-use zerocopy::Ref;
+use zerocopy::{FromBytes, Ref};
 
 /// `EfiEntry` stores the EFI system table pointer and image handle passed from the entry point.
 /// It's the root data structure that derives all other wrapper APIs and structures.
@@ -91,9 +94,19 @@ pub struct EfiEntry {
 
 impl EfiEntry {
     /// Gets an instance of `SystemTable`.
+    ///
+    /// Panics if the pointer is NULL.
     pub fn system_table(&self) -> SystemTable {
+        self.system_table_checked().unwrap()
+    }
+
+    /// Gets an instance of `SystemTable` if pointer is valid.
+    pub fn system_table_checked(&self) -> Result<SystemTable> {
         // SAFETY: Pointers to UEFI data strucutres.
-        SystemTable { efi_entry: self, table: unsafe { self.systab_ptr.as_ref() }.unwrap() }
+        Ok(SystemTable {
+            efi_entry: self,
+            table: unsafe { self.systab_ptr.as_ref() }.ok_or(Error::Unsupported)?,
+        })
     }
 
     /// Gets the image handle.
@@ -106,6 +119,10 @@ impl EfiEntry {
 pub const GBL_EFI_VENDOR_GUID: EfiGuid =
     EfiGuid::new(0x5a6d92f3, 0xa2d0, 0x4083, [0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]);
 
+/// GUID for UEFI Memory Attributes Table
+pub const EFI_MEMORY_ATTRIBUTES_GUID: EfiGuid =
+    EfiGuid::new(0xdcfa911d, 0x26eb, 0x469f, [0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20]);
+
 /// The name of the UEFI variable that GBL defines to determine whether to boot Fuchsia.
 /// The value of the variable is ignored: if the variable is present,
 /// it indicates that the bootloader should attempt to boot a Fuchsia target.
@@ -124,26 +141,14 @@ pub unsafe fn initialize(
     image_handle: EfiHandle,
     systab_ptr: *const EfiSystemTable,
 ) -> Result<EfiEntry> {
-    let efi_entry = EfiEntry { image_handle, systab_ptr };
     // SAFETY: By safety requirement of this function, `initialize` is only called once upon
     // entering EFI application, where there should be no event notify function that can be
     // triggered.
     unsafe {
-        // Create another one for internal global allocator.
+        // Create one for internal global allocator.
         allocation::init_efi_global_alloc(EfiEntry { image_handle, systab_ptr })?;
     }
-    Ok(efi_entry)
-}
-
-/// A helper for getting a subslice with an aligned address.
-pub fn aligned_subslice(buffer: &mut [u8], alignment: usize) -> Option<&mut [u8]> {
-    let addr = buffer.as_ptr() as usize;
-    let aligned_offset = addr
-        .checked_add(alignment - 1)?
-        .checked_div(alignment)?
-        .checked_mul(alignment)?
-        .checked_sub(addr)?;
-    buffer.get_mut(aligned_offset..)
+    Ok(EfiEntry { image_handle, systab_ptr })
 }
 
 /// Exits boot service and returns the memory map in the given buffer.
@@ -155,8 +160,7 @@ pub fn aligned_subslice(buffer: &mut [u8], alignment: usize) -> Option<&mut [u8]
 /// Existing heap allocated memories will maintain their states. All system memory including them
 /// will be under onwership of the subsequent OS or OS loader code.
 pub fn exit_boot_services(entry: EfiEntry, mmap_buffer: &mut [u8]) -> Result<EfiMemoryMap> {
-    let aligned = aligned_subslice(mmap_buffer, core::mem::align_of::<EfiMemoryDescriptor>())
-        .ok_or(Error::BufferTooSmall(None))?;
+    let aligned = aligned_subslice(mmap_buffer, core::mem::align_of::<EfiMemoryDescriptor>())?;
 
     let res = entry.system_table().boot_services().get_memory_map(aligned)?;
     entry.system_table().boot_services().exit_boot_services(&res)?;
@@ -179,20 +183,38 @@ pub struct SystemTable<'a> {
 
 impl<'a> SystemTable<'a> {
     /// Creates an instance of `BootServices`
+    ///
+    /// Panics if not implemented by UEFI.
     pub fn boot_services(&self) -> BootServices<'a> {
-        BootServices {
+        self.boot_services_checked().unwrap()
+    }
+
+    /// Creates an instance of `BootServices`
+    ///
+    /// Returns Err(()) if not implemented by UEFI.
+    pub fn boot_services_checked(&self) -> Result<BootServices<'a>> {
+        Ok(BootServices {
             efi_entry: self.efi_entry,
             // SAFETY: Pointers to UEFI data strucutres.
-            boot_services: unsafe { self.table.boot_services.as_ref() }.unwrap(),
-        }
+            boot_services: unsafe { self.table.boot_services.as_ref() }
+                .ok_or(Error::Unsupported)?,
+        })
     }
 
     /// Creates an instance of `RuntimeServices`
-    pub fn runtime_services(&self) -> RuntimeServices<'a> {
-        RuntimeServices {
+    ///
+    /// Panics if run time services is not implemented.
+    pub fn runtime_services(&self) -> RuntimeServices {
+        self.runtime_services_checked().unwrap()
+    }
+
+    /// Creates an instance of `RuntimeServices` if available from system table.
+    pub fn runtime_services_checked(&self) -> Result<RuntimeServices> {
+        Ok(RuntimeServices {
             // SAFETY: Pointers to UEFI data strucutres.
-            runtime_services: unsafe { self.table.runtime_services.as_ref() }.unwrap(),
-        }
+            runtime_services: *unsafe { self.table.runtime_services.as_ref() }
+                .ok_or(Error::Unsupported)?,
+        })
     }
 
     /// Gets the `EFI_SYSTEM_TABLE.ConOut` field.
@@ -485,11 +507,11 @@ impl<'a> BootServices<'a> {
 
 /// `RuntimeServices` provides methods for accessing various EFI_RUNTIME_SERVICES interfaces.
 #[derive(Clone, Copy)]
-pub struct RuntimeServices<'a> {
-    runtime_services: &'a EfiRuntimeService,
+pub struct RuntimeServices {
+    runtime_services: EfiRuntimeService,
 }
 
-impl<'a> RuntimeServices<'a> {
+impl RuntimeServices {
     /// Wrapper of `EFI_RUNTIME_SERVICES.GetVariable()`.
     pub fn get_variable(&self, guid: &EfiGuid, name: &str, out: &mut [u8]) -> Result<usize> {
         let mut size = out.len();
@@ -533,6 +555,37 @@ impl<'a> RuntimeServices<'a> {
             )
         }
     }
+
+    /// Wrapper of `EFI_RUNTIME_SERVICES.reset_system`.
+    pub fn reset_system(
+        &self,
+        reset_type: EFI_RESET_TYPE,
+        reset_status: EFI_STATUS,
+        reset_data: Option<&mut [u8]>,
+    ) -> ! {
+        let (reset_data_len, reset_data_ptr) = match reset_data {
+            Some(v) => (v.len(), v.as_mut_ptr() as _),
+            _ => (0, null_mut()),
+        };
+        // SAFETY:
+        // * `reset_data_ptr` is either a valid pointer or NULL which by UEFI spec is allowed.
+        // * The call reboots the device and thus is not expected to return.
+        unsafe {
+            self.runtime_services.reset_system.unwrap()(
+                reset_type,
+                reset_status,
+                reset_data_len,
+                reset_data_ptr,
+            );
+        }
+
+        unreachable!();
+    }
+
+    /// Performs a cold reset without status code or data.
+    pub fn cold_reset(&self) -> ! {
+        self.reset_system(EFI_RESET_TYPE_EFI_RESET_COLD, EFI_STATUS_SUCCESS, None)
+    }
 }
 
 /// EFI Event type to pass to BootServicess::create_event.
@@ -646,6 +699,7 @@ unsafe extern "C" fn efi_event_cb(event: EfiEvent, ctx: *mut core::ffi::c_void)
 }
 
 /// A type for accessing memory map.
+#[derive(Debug)]
 pub struct EfiMemoryMap<'a> {
     buffer: &'a mut [u8],
     map_key: usize,
@@ -713,6 +767,89 @@ impl<'a: 'b, 'b> IntoIterator for &'b EfiMemoryMap<'a> {
     }
 }
 
+/// A type for accessing Memory attributes table
+pub struct EfiMemoryAttributesTable<'a> {
+    /// EfiMemoryAttributesTable header
+    pub header: &'a EfiMemoryAttributesTableHeader,
+    tail: &'a [u8],
+}
+
+/// Iterator for traversing `EfiMemoryAttributesTable` descriptors.
+pub struct EfiMemoryAttributesTableIter<'a> {
+    descriptor_size: usize,
+    tail: &'a [u8],
+}
+
+impl<'a> Iterator for EfiMemoryAttributesTableIter<'a> {
+    type Item = &'a EfiMemoryDescriptor;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        // Descriptor size can be greater than `EfiMemoryDescriptor`, so we potentially slice off
+        // pieces greater than struct size. Thus can't just convert buffer to slice of
+        // corresponding type.
+        if let Some((desc_bytes, tail_new)) = self.tail.split_at_checked(self.descriptor_size) {
+            let desc =
+                Ref::<_, EfiMemoryDescriptor>::new_from_prefix(desc_bytes).unwrap().0.into_ref();
+            self.tail = tail_new;
+            Some(desc)
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> EfiMemoryAttributesTable<'a> {
+    /// Creates a new instance with the given parameters obtained from `get_memory_map()`.
+    ///
+    /// # Returns
+    /// Ok(EfiMemoryAttributesTable) - on success
+    /// Err(Error::NotFound) - if table type is incorrect
+    /// Err(e) - if error `e` occurred parsing table buffer
+    //
+    // SAFETY:
+    // `configuration_table` must be valid EFI Configuration Table object.
+    pub unsafe fn new(
+        configuration_table: EfiConfigurationTable,
+    ) -> Result<EfiMemoryAttributesTable<'a>> {
+        if configuration_table.vendor_guid != EFI_MEMORY_ATTRIBUTES_GUID {
+            return Err(Error::NotFound);
+        }
+        let buf = configuration_table.vendor_table;
+
+        // SAFETY: Buffer provided by EFI configuration table.
+        let header = unsafe {
+            let header_bytes =
+                from_raw_parts(buf as *const u8, size_of::<EfiMemoryAttributesTableHeader>());
+            EfiMemoryAttributesTableHeader::ref_from(header_bytes).ok_or(Error::InvalidInput)?
+        };
+
+        // Note: `descriptor_size` may be bigger than `EfiMemoryDescriptor`.
+        let descriptor_size: usize = header.descriptor_size.try_into().unwrap();
+        let descriptors_count: usize = header.number_of_entries.try_into().unwrap();
+
+        // SAFETY: Buffer provided by EFI configuration table.
+        let tail = unsafe {
+            from_raw_parts(
+                (buf as *const u8).add(core::mem::size_of_val(header)),
+                descriptors_count * descriptor_size,
+            )
+        };
+
+        Ok(Self { header, tail })
+    }
+}
+
+impl<'a> IntoIterator for &EfiMemoryAttributesTable<'a> {
+    type Item = &'a EfiMemoryDescriptor;
+    type IntoIter = EfiMemoryAttributesTableIter<'a>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        let descriptor_size = usize::try_from(self.header.descriptor_size).unwrap();
+        let tail = &self.tail[..];
+        EfiMemoryAttributesTableIter { descriptor_size, tail }
+    }
+}
+
 /// A type representing a UEFI handle to a UEFI device.
 #[derive(Debug, Copy, Clone, PartialEq)]
 pub struct DeviceHandle(EfiHandle);
@@ -778,23 +915,25 @@ macro_rules! efi_println {
     };
 }
 
+/// Resets system. Hangs if not supported.
+#[cfg(not(test))]
+pub fn reset() -> ! {
+    efi_try_print!("Resetting...\r\n");
+    match allocation::internal_efi_entry_and_rt().1 {
+        Some(rt) => rt.cold_reset(),
+        _ => efi_try_print!("Runtime services not supported. Hangs...\r\n"),
+    }
+    loop {}
+}
+
 /// Provides a builtin panic handler.
 /// In the long term, to improve flexibility, consider allowing application to install a custom
 /// handler into `EfiEntry` to be called here.
 /// Don't set this as the panic handler so that other crates' tests can depend on libefi.
 #[cfg(not(test))]
 pub fn panic(panic: &PanicInfo) -> ! {
-    // If there is a valid internal `efi_entry` from global allocator, print the panic info.
-    let entry = allocation::internal_efi_entry();
-    if let Some(e) = entry {
-        match e.system_table().con_out() {
-            Ok(mut con_out) => {
-                let _ = write!(con_out, "Panics! {}\r\n", panic);
-            }
-            _ => {}
-        }
-    }
-    loop {}
+    efi_try_print!("Panics! {}\r\n", panic);
+    reset();
 }
 
 #[cfg(test)]
diff --git a/gbl/libefi/src/protocol.rs b/gbl/libefi/src/protocol.rs
index 0422846..8b212e2 100644
--- a/gbl/libefi/src/protocol.rs
+++ b/gbl/libefi/src/protocol.rs
@@ -22,7 +22,9 @@ use efi_types::*;
 pub mod block_io;
 pub mod block_io2;
 pub mod device_path;
+pub mod dt_fixup;
 pub mod gbl_efi_ab_slot;
+pub mod gbl_efi_avb;
 pub mod gbl_efi_fastboot;
 pub mod gbl_efi_fastboot_usb;
 pub mod gbl_efi_image_loading;
diff --git a/gbl/libefi/src/protocol/block_io.rs b/gbl/libefi/src/protocol/block_io.rs
index f1b8a4b..6df78c5 100644
--- a/gbl/libefi/src/protocol/block_io.rs
+++ b/gbl/libefi/src/protocol/block_io.rs
@@ -17,6 +17,7 @@
 use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
 use efi_types::{EfiBlockIoMedia, EfiBlockIoProtocol, EfiGuid};
+use gbl_storage::SliceMaybeUninit;
 use liberror::{Error, Result};
 
 /// EFI_BLOCK_IO_PROTOCOL
@@ -32,7 +33,11 @@ impl ProtocolInfo for BlockIoProtocol {
 // Protocol interface wrappers.
 impl Protocol<'_, BlockIoProtocol> {
     /// Wrapper of `EFI_BLOCK_IO_PROTOCOL.read_blocks()`
-    pub fn read_blocks(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
+    pub fn read_blocks(
+        &self,
+        lba: u64,
+        buffer: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
@@ -45,7 +50,7 @@ impl Protocol<'_, BlockIoProtocol> {
                 self.media()?.media_id,
                 lba,
                 buffer.len(),
-                buffer.as_mut_ptr() as *mut _
+                buffer.as_mut().as_mut_ptr() as *mut _
             )
         }
     }
diff --git a/gbl/libefi/src/protocol/block_io2.rs b/gbl/libefi/src/protocol/block_io2.rs
index 8964c87..86962c9 100644
--- a/gbl/libefi/src/protocol/block_io2.rs
+++ b/gbl/libefi/src/protocol/block_io2.rs
@@ -22,7 +22,8 @@ use crate::{
 use efi_types::{
     EfiBlockIo2Protocol, EfiBlockIo2Token, EfiBlockIoMedia, EfiGuid, EFI_STATUS_NOT_READY,
 };
-use gbl_async::yield_now;
+use gbl_async::{assert_return, yield_now};
+use gbl_storage::SliceMaybeUninit;
 use liberror::{efi_status_to_result, Error, Result};
 
 /// EFI_BLOCK_IO2_PROTOCOL
@@ -55,7 +56,11 @@ impl Protocol<'_, BlockIo2Protocol> {
     }
 
     /// Wraps `EfiBlockIo2Protocol.read_blocks_ex`.
-    pub async fn read_blocks_ex(&self, lba: u64, buffer: &mut [u8]) -> Result<()> {
+    pub async fn read_blocks_ex(
+        &self,
+        lba: u64,
+        buffer: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
         let bs = self.efi_entry().system_table().boot_services();
         // UEFI spec requires that NOTIFY_WAIT event be always created with a callback.
         let mut notify_fn = &mut |_| ();
@@ -67,12 +72,14 @@ impl Protocol<'_, BlockIo2Protocol> {
             EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
         // SAFETY:
         // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        //   established by `Protocol::new()`.
+        //    established by `Protocol::new()`.
         // * `self.interface` is input parameter and will not be retained. It outlives the call.
-        // * `Self::wait_io_completion()` is called immediately after. It makes sure the IO is either
-        //   completed successfully or is reset if `check_event` fails. Thus it's guaranteed that
-        //   after `Self::wait_io_completion()` returns, `buffer` and `token` are not being retained
-        //   by the UEFI firmware anymore.
+        // * `Self::wait_io_completion()` is called immediately after. It makes sure the IO is
+        //   either completed successfully or is reset if `check_event` fails. Thus it's
+        //   guaranteed that after `Self::wait_io_completion()` returns, `buffer` and `token` are
+        //   not being retained by the UEFI firmware anymore.
+        // * `assert_return` asserts that `wait_io_completion` returns eventually. Otherwise it
+        //   panics if the top level Future gets dropped before it returns.
         unsafe {
             efi_call!(
                 self.interface()?.read_blocks_ex,
@@ -81,10 +88,10 @@ impl Protocol<'_, BlockIo2Protocol> {
                 lba,
                 &mut token,
                 buffer.len(),
-                buffer.as_mut_ptr() as _
+                buffer.as_mut().as_mut_ptr() as _
             )?;
         }
-        self.wait_io_completion(&event).await?;
+        assert_return(self.wait_io_completion(&event)).await?;
         efi_status_to_result(token.transaction_status)
     }
 
@@ -110,7 +117,7 @@ impl Protocol<'_, BlockIo2Protocol> {
                 buffer.as_mut_ptr() as _
             )?;
         }
-        self.wait_io_completion(&event).await?;
+        assert_return(self.wait_io_completion(&event)).await?;
         efi_status_to_result(token.transaction_status)
     }
 
@@ -125,10 +132,8 @@ impl Protocol<'_, BlockIo2Protocol> {
         let mut token =
             EfiBlockIo2Token { event: event.efi_event, transaction_status: EFI_STATUS_NOT_READY };
         // SAFETY: See safety comment for `Self::read_blocks_ex()`.
-        unsafe {
-            efi_call!(self.interface()?.flush_blocks_ex, self.interface, &mut token,)?;
-        }
-        self.wait_io_completion(&event).await?;
+        unsafe { efi_call!(self.interface()?.flush_blocks_ex, self.interface, &mut token) }?;
+        assert_return(self.wait_io_completion(&event)).await?;
         efi_status_to_result(token.transaction_status)
     }
 
diff --git a/gbl/libefi/src/protocol/dt_fixup.rs b/gbl/libefi/src/protocol/dt_fixup.rs
new file mode 100644
index 0000000..f205643
--- /dev/null
+++ b/gbl/libefi/src/protocol/dt_fixup.rs
@@ -0,0 +1,133 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `EFI_DT_FIXUP_PROTOCOL`.
+
+use crate::efi_call;
+use crate::protocol::{Protocol, ProtocolInfo};
+use efi_types::{EfiDtFixupProtocol, EfiGuid, EFI_DT_APPLY_FIXUPS};
+use liberror::Result;
+
+/// `EFI_DT_FIXUP_PROTOCOL` implementation.
+pub struct DtFixupProtocol;
+
+impl ProtocolInfo for DtFixupProtocol {
+    type InterfaceType = EfiDtFixupProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0xe617d64c, 0xfe08, 0x46da, [0xf4, 0xdc, 0xbb, 0xd5, 0x87, 0x0c, 0x73, 0x00]);
+}
+
+// Protocol interface wrappers.
+impl Protocol<'_, DtFixupProtocol> {
+    /// Wraps `EFI_DT_FIXUP_PROTOCOL.fixup()`.
+    pub fn fixup(&self, device_tree: &mut [u8]) -> Result<()> {
+        let mut buffer_size = device_tree.len();
+
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * `device_tree` is non-null buffer available for write, used only within the call.
+        // * `buffer_size` is non-null usize buffer available for write, used only within the call.
+        unsafe {
+            efi_call!(
+                @bufsize buffer_size,
+                self.interface()?.fixup,
+                self.interface,
+                device_tree.as_mut_ptr() as _,
+                &mut buffer_size,
+                EFI_DT_APPLY_FIXUPS
+            )?;
+        }
+
+        Ok(())
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use crate::test::run_test_with_mock_protocol;
+    use efi_types::{EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_SUCCESS};
+    use liberror::Error;
+    use std::{ffi::c_void, slice};
+
+    #[test]
+    fn fixup_device_tree_updated() {
+        // Don't check actual FDT content for simplicity.
+        const DEVICE_TREE_BUFFER: &[u8] = b"this_is_device_tree";
+        const UPDATED_DEVICE_TREE_BUFFER: &[u8] = b"this_is_device_trie";
+
+        // C callback implementation to modify provided FDT to UPDATED_DEVICE_TREE_BUFFER.
+        unsafe extern "C" fn c_modify(
+            _: *mut EfiDtFixupProtocol,
+            device_tree: *mut c_void,
+            buffer_size: *mut usize,
+            flags: u32,
+        ) -> EfiStatus {
+            assert_eq!(flags, EFI_DT_APPLY_FIXUPS);
+            // SAFETY:
+            // * `device_tree` is a valid pointer to the writtable buffer at least `buffer_size`
+            // size.
+            // * `buffer_size` is a valid pointer to usize.
+            let fdt_buffer =
+                unsafe { slice::from_raw_parts_mut(device_tree as *mut u8, *buffer_size) };
+            assert_eq!(fdt_buffer, DEVICE_TREE_BUFFER);
+
+            fdt_buffer.copy_from_slice(UPDATED_DEVICE_TREE_BUFFER);
+
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = EfiDtFixupProtocol { fixup: Some(c_modify), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |dt_fixup_protocol| {
+            let mut fdt_buffer: Vec<u8> = DEVICE_TREE_BUFFER.to_vec();
+
+            assert!(dt_fixup_protocol.fixup(&mut fdt_buffer[..]).is_ok());
+            assert_eq!(&fdt_buffer[..], UPDATED_DEVICE_TREE_BUFFER);
+        });
+    }
+
+    #[test]
+    fn fixup_device_tree_fixup_buffer_too_small() {
+        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
+        // C callback implementation to return an error.
+        unsafe extern "C" fn c_error(
+            _: *mut EfiDtFixupProtocol,
+            _: *mut c_void,
+            buffer_size: *mut usize,
+            _: u32,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `buffer_size` is a valid pointer to writtable usize buffer.
+            unsafe {
+                *buffer_size = EXPECTED_REQUESTED_FIXUP_SIZE;
+            }
+            EFI_STATUS_BUFFER_TOO_SMALL
+        }
+
+        let c_interface = EfiDtFixupProtocol { fixup: Some(c_error), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |dt_fixup_protocol| {
+            let mut fdt_buffer = [0u8; 128];
+
+            assert_eq!(
+                dt_fixup_protocol.fixup(&mut fdt_buffer[..]),
+                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
+            );
+        });
+    }
+}
diff --git a/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs b/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
index 299fcd0..e24c4de 100644
--- a/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
+++ b/gbl/libefi/src/protocol/gbl_efi_ab_slot.rs
@@ -106,10 +106,29 @@ impl<'a> Protocol<'a, GblSlotProtocol> {
         // established by `Protocol::new()`.
         // `self.interface` is an input parameter and will not be retained. It outlives the call.
         // `info` is an output parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.get_current_slot, self.interface, &mut info)? }
+        unsafe { efi_call!(self.interface()?.get_current_slot, self.interface, &mut info)? };
         Ok(info.into())
     }
 
+    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.GetNextSlot()`
+    pub fn get_next_slot(&self, mark_boot_attempt: bool) -> Result<GblSlot> {
+        let mut info = GblEfiSlotInfo::default();
+        // SAFETY:
+        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // established by `Protocol::new()`.
+        // `self.interface`, `info` are input/output parameter and will not be retained. It
+        // outlives the call.
+        unsafe {
+            efi_call!(
+                self.interface()?.get_next_slot,
+                self.interface,
+                mark_boot_attempt,
+                &mut info as _
+            )?;
+        }
+        Ok(GblSlot::from(info))
+    }
+
     /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.set_active_slot()`
     pub fn set_active_slot(&self, idx: u8) -> Result<()> {
         // SAFETY:
@@ -129,15 +148,6 @@ impl<'a> Protocol<'a, GblSlotProtocol> {
         unsafe { efi_call!(self.interface()?.set_slot_unbootable, self.interface, idx, reason) }
     }
 
-    /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.mark_boot_attempt()`
-    pub fn mark_boot_attempt(&self) -> Result<()> {
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        unsafe { efi_call!(self.interface()?.mark_boot_attempt, self.interface) }
-    }
-
     /// Wrapper of `GBL_EFI_SLOT_PROTOCOL.reinitialize()`
     pub fn reinitialize(&self) -> Result<()> {
         // SAFETY:
diff --git a/gbl/libefi/src/protocol/gbl_efi_avb.rs b/gbl/libefi/src/protocol/gbl_efi_avb.rs
new file mode 100644
index 0000000..fda9028
--- /dev/null
+++ b/gbl/libefi/src/protocol/gbl_efi_avb.rs
@@ -0,0 +1,700 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Rust wrapper for `GBL_EFI_AVB_PROTOCOL`.
+
+use crate::efi_call;
+use crate::protocol::{Protocol, ProtocolInfo};
+use core::ffi::CStr;
+use core::ptr::null;
+use efi_types::{
+    EfiGuid, GblEfiAvbKeyValidationStatus, GblEfiAvbProtocol, GblEfiAvbVerificationResult,
+};
+use liberror::Result;
+
+/// `GBL_EFI_AVB_PROTOCOL` implementation.
+pub struct GblAvbProtocol;
+
+impl ProtocolInfo for GblAvbProtocol {
+    type InterfaceType = GblEfiAvbProtocol;
+
+    const GUID: EfiGuid =
+        EfiGuid::new(0x6bc66b9a, 0xd5c9, 0x4c02, [0x9d, 0xa9, 0x50, 0xaf, 0x19, 0x8d, 0x91, 0x2c]);
+}
+
+// Protocol interface wrappers.
+impl Protocol<'_, GblAvbProtocol> {
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.validate_vbmeta_public_key()`.
+    pub fn validate_vbmeta_public_key(
+        &self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> Result<GblEfiAvbKeyValidationStatus> {
+        let mut validation_status: GblEfiAvbKeyValidationStatus =
+            efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_INVALID;
+
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`
+        // * `public_key` pointer is not-null and used only within the call
+        // * `public_key_metadata` pointer (can be null), used only within the call
+        // * `validation_status` non-null pointer available to write
+        unsafe {
+            efi_call!(
+                self.interface()?.validate_vbmeta_public_key,
+                self.interface,
+                public_key.as_ptr() as *const _,
+                public_key.len(),
+                public_key_metadata.map_or(null(), |m| m.as_ptr() as *const _),
+                public_key_metadata.map_or(0, |m| m.len()),
+                &mut validation_status,
+            )?
+        }
+
+        Ok(validation_status)
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_is_device_unlocked()`.
+    pub fn read_is_device_unlocked(&self) -> Result<bool> {
+        let mut is_unlocked: bool = false;
+
+        // SAFETY:
+        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
+        // object established by `Protocol::new()`.
+        // * `is_unlocked` is a non-null pointer to a `bool` available for write.
+        unsafe {
+            efi_call!(self.interface()?.read_is_device_unlocked, self.interface, &mut is_unlocked)?
+        }
+
+        Ok(is_unlocked)
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_rollback_index()`.
+    pub fn read_rollback_index(&self, index_location: usize) -> Result<u64> {
+        let mut rollback_index: u64 = 0;
+
+        // SAFETY:
+        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
+        //   object established by `Protocol::new()`.
+        // * `rollback_index` is a valid pointer to a `u64` available for write.
+        unsafe {
+            efi_call!(
+                self.interface()?.read_rollback_index,
+                self.interface,
+                index_location,
+                &mut rollback_index,
+            )?
+        }
+
+        Ok(rollback_index)
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.write_rollback_index()`.
+    pub fn write_rollback_index(&self, index_location: usize, rollback_index: u64) -> Result<()> {
+        // SAFETY:
+        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
+        //   object established by `Protocol::new()`.
+        unsafe {
+            efi_call!(
+                self.interface()?.write_rollback_index,
+                self.interface,
+                index_location,
+                rollback_index,
+            )?
+        }
+
+        Ok(())
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.read_persistent_value()`.
+    pub fn read_persistent_value(&self, name: &CStr, value: &mut [u8]) -> Result<usize> {
+        let mut value_buffer_size = value.len();
+
+        let value_ptr = match value.is_empty() {
+            true => core::ptr::null_mut(),
+            false => value.as_mut_ptr(),
+        };
+
+        // SAFETY:
+        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
+        //   object established by `Protocol::new()`.
+        // * `name` is a valid pointer to a null-terminated string used only within the call.
+        // * `value_ptr` is either a valid pointer to a writable buffer or a null pointer, used only
+        //   within the call
+        // * `value_buffer_size` holds a mutable reference to `usize`, used only within the call.
+        unsafe {
+            efi_call!(
+                @bufsize value_buffer_size,
+                self.interface()?.read_persistent_value,
+                self.interface,
+                name.as_ptr(),
+                value_ptr,
+                &mut value_buffer_size,
+            )?
+        }
+
+        Ok(value_buffer_size)
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.write_persistent_value()`.
+    pub fn write_persistent_value(&self, name: &CStr, value: Option<&[u8]>) -> Result<()> {
+        let (value_ptr, value_len) = match value {
+            Some(v) => (v.as_ptr(), v.len()),
+            None => (core::ptr::null(), 0),
+        };
+
+        // SAFETY:
+        // * `self.interface()?` guarantees `self.interface` is non-null and points to a valid
+        //   object established by `Protocol::new()`.
+        // * `name` is a valid pointer to a null-terminated string used only within the call.
+        // * `value_ptr` is a valid pointer to `value_len` sized buffer or null, used only within
+        //   the call.
+        unsafe {
+            efi_call!(
+                self.interface()?.write_persistent_value,
+                self.interface,
+                name.as_ptr(),
+                value_ptr,
+                value_len,
+            )?
+        }
+
+        Ok(())
+    }
+
+    /// Wraps `GBL_EFI_AVB_PROTOCOL.handle_verification_result()`.
+    pub fn handle_verification_result(
+        &self,
+        verification_result: &GblEfiAvbVerificationResult,
+    ) -> Result<()> {
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * `verification_result` pointer is not-null and used only within the call.
+        unsafe {
+            efi_call!(
+                self.interface()?.handle_verification_result,
+                self.interface,
+                verification_result as *const _
+            )
+        }
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::{protocol::EFI_STATUS_BUFFER_TOO_SMALL, test::run_test_with_mock_protocol, Error};
+    use efi_types::{EfiStatus, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS};
+    use std::{ffi::c_char, ptr, slice};
+
+    #[test]
+    fn validate_vbmeta_public_key_status_provided() {
+        const EXPECTED_PUBLIC_KEY: &[u8] = b"test_key";
+        const EXPECTED_STATUS: GblEfiAvbKeyValidationStatus =
+            efi_types::GBL_EFI_AVB_KEY_VALIDATION_STATUS_VALID_CUSTOM_KEY;
+
+        // C callback implementation that returns an error
+        unsafe extern "C" fn c_return_error(
+            _: *mut GblEfiAvbProtocol,
+            public_key_ptr: *const u8,
+            public_key_len: usize,
+            _metadata_ptr: *const u8,
+            _metadata_len: usize,
+            validation_status_ptr: *mut GblEfiAvbKeyValidationStatus,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `public_key_ptr` is a non-null pointer to the buffer at least `public_key_len`
+            // size.
+            let public_key_buffer =
+                unsafe { slice::from_raw_parts(public_key_ptr, public_key_len) };
+
+            assert_eq!(public_key_buffer, EXPECTED_PUBLIC_KEY);
+
+            // SAFETY:
+            // * `validation_status_ptr` is a non-null pointer to GblEfiAvbKeyValidationStatus
+            // available to write.
+            unsafe { *validation_status_ptr = EXPECTED_STATUS };
+
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            validate_vbmeta_public_key: Some(c_return_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(
+                avb_protocol.validate_vbmeta_public_key(EXPECTED_PUBLIC_KEY, None),
+                Ok(EXPECTED_STATUS)
+            );
+        });
+    }
+
+    #[test]
+    fn validate_vbmeta_public_key_error_handled() {
+        // C callback implementation that returns an error
+        unsafe extern "C" fn c_return_error(
+            _: *mut GblEfiAvbProtocol,
+            _public_key_ptr: *const u8,
+            _public_key_len: usize,
+            _metadata_ptr: *const u8,
+            _metadata_len: usize,
+            _validation_status_ptr: *mut GblEfiAvbKeyValidationStatus,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            validate_vbmeta_public_key: Some(c_return_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert!(avb_protocol.validate_vbmeta_public_key(b"test_key", None).is_err());
+        });
+    }
+
+    #[test]
+    fn handle_verification_result_data_provided() {
+        const COLOR: u32 = efi_types::GBL_EFI_AVB_BOOT_STATE_COLOR_RED;
+
+        // C callback implementation that returns success.
+        unsafe extern "C" fn c_return_success(
+            _: *mut GblEfiAvbProtocol,
+            result: *const GblEfiAvbVerificationResult,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `result` is non-null.
+            assert_eq!(unsafe { (*result).color }, COLOR);
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            handle_verification_result: Some(c_return_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            let verification_result =
+                GblEfiAvbVerificationResult { color: COLOR, ..Default::default() };
+
+            assert!(avb_protocol.handle_verification_result(&verification_result).is_ok());
+        });
+    }
+
+    #[test]
+    fn handle_verification_result_error() {
+        // C callback implementation that returns an error.
+        unsafe extern "C" fn c_return_error(
+            _: *mut GblEfiAvbProtocol,
+            _: *const GblEfiAvbVerificationResult,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            handle_verification_result: Some(c_return_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            let verification_result = GblEfiAvbVerificationResult::default();
+
+            assert!(avb_protocol.handle_verification_result(&verification_result).is_err());
+        });
+    }
+
+    #[test]
+    fn read_is_device_unlocked_returns_true() {
+        /// C callback implementation that sets is_unlocked to true.
+        ///
+        /// # Safety:
+        /// Caller must guaranteed that `is_unlocked_ptr` points to a valid bool variable available
+        /// for write.
+        unsafe extern "C" fn c_return_true(
+            _: *mut GblEfiAvbProtocol,
+            is_unlocked_ptr: *mut bool,
+        ) -> EfiStatus {
+            // SAFETY: By safety requirement of this function, is_unlocked_ptr is a valid pointer.
+            unsafe { *is_unlocked_ptr = true };
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            read_is_device_unlocked: Some(c_return_true),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(avb_protocol.read_is_device_unlocked(), Ok(true));
+        });
+    }
+
+    #[test]
+    fn read_is_device_unlocked_returns_false() {
+        /// C callback implementation that sets is_unlocked to false.
+        ///
+        /// # Safety:
+        /// Caller must guaranteed that `is_unlocked_ptr` points to a valid bool variable available
+        /// for write.
+        unsafe extern "C" fn c_return_false(
+            _: *mut GblEfiAvbProtocol,
+            is_unlocked_ptr: *mut bool,
+        ) -> EfiStatus {
+            // SAFETY: By safety requirement of this function, is_unlocked_ptr is a valid pointer.
+            unsafe { *is_unlocked_ptr = false };
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            read_is_device_unlocked: Some(c_return_false),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(avb_protocol.read_is_device_unlocked(), Ok(false));
+        });
+    }
+
+    #[test]
+    fn read_is_device_unlocked_error_handled() {
+        /// C callback implementation that returns an error.
+        unsafe extern "C" fn c_return_error(_: *mut GblEfiAvbProtocol, _: *mut bool) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            read_is_device_unlocked: Some(c_return_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert!(avb_protocol.read_is_device_unlocked().is_err());
+        });
+    }
+
+    #[test]
+    fn read_rollback_index_returns_value() {
+        const EXPECTED_INDEX_LOCATION: usize = 1;
+        const EXPECTED_ROLLBACK_INDEX: u64 = 42;
+
+        /// C callback implementation that sets rollback_index to EXPECTED_ROLLBACK_INDEX.
+        ///
+        /// # Safety:
+        /// Caller must guaranteed that `rollback_index_ptr` points to a valid u64 variable
+        /// available for write.
+        unsafe extern "C" fn c_return_value(
+            _: *mut GblEfiAvbProtocol,
+            index_location: usize,
+            rollback_index_ptr: *mut u64,
+        ) -> EfiStatus {
+            assert_eq!(index_location, EXPECTED_INDEX_LOCATION);
+
+            // SAFETY: By safety requirement of this function, `rollback_index_ptr` is a valid
+            // pointer.
+            unsafe { *rollback_index_ptr = EXPECTED_ROLLBACK_INDEX };
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface =
+            GblEfiAvbProtocol { read_rollback_index: Some(c_return_value), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(
+                avb_protocol.read_rollback_index(EXPECTED_INDEX_LOCATION),
+                Ok(EXPECTED_ROLLBACK_INDEX)
+            );
+        });
+    }
+
+    #[test]
+    fn read_rollback_index_error_handled() {
+        /// C callback implementation that returns an error.
+        unsafe extern "C" fn c_return_error(
+            _: *mut GblEfiAvbProtocol,
+            _: usize,
+            _: *mut u64,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface =
+            GblEfiAvbProtocol { read_rollback_index: Some(c_return_error), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert!(avb_protocol.read_rollback_index(0).is_err());
+        });
+    }
+
+    #[test]
+    fn write_rollback_index_success() {
+        const EXPECTED_INDEX_LOCATION: usize = 1;
+        const EXPECTED_ROLLBACK_INDEX: u64 = 42;
+
+        /// C callback implementation that checks the passed parameters and returns success.
+        unsafe extern "C" fn c_return_success(
+            _: *mut GblEfiAvbProtocol,
+            index_location: usize,
+            rollback_index: u64,
+        ) -> EfiStatus {
+            assert_eq!(index_location, EXPECTED_INDEX_LOCATION);
+            assert_eq!(rollback_index, EXPECTED_ROLLBACK_INDEX);
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            write_rollback_index: Some(c_return_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert!(avb_protocol
+                .write_rollback_index(EXPECTED_INDEX_LOCATION, EXPECTED_ROLLBACK_INDEX)
+                .is_ok());
+        });
+    }
+
+    #[test]
+    fn write_rollback_index_error_handled() {
+        /// C callback implementation that returns an error.
+        unsafe extern "C" fn c_return_error(
+            _: *mut GblEfiAvbProtocol,
+            _: usize,
+            _: u64,
+        ) -> EfiStatus {
+            EFI_STATUS_INVALID_PARAMETER
+        }
+
+        let c_interface =
+            GblEfiAvbProtocol { write_rollback_index: Some(c_return_error), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert!(avb_protocol.write_rollback_index(0, 0).is_err());
+        });
+    }
+
+    #[test]
+    fn read_persistent_value_success() {
+        const EXPECTED_NAME: &CStr = c"test_key";
+        const EXPECTED_VALUE: &[u8] = b"test_value";
+
+        /// C callback implementation.
+        ///
+        /// # Safety:
+        /// * Caller must guaranteed that `name` points to a valid null-terminated string.
+        /// * Caller must guaranteed that `value` points to non-null `value_size` sized bytes
+        ///   buffer.
+        /// * Caller must guaranteed that `value_size` points to a valid usize available to write
+        ///   value buffer.
+        unsafe extern "C" fn c_read_persistent_value_success(
+            _: *mut GblEfiAvbProtocol,
+            name: *const c_char,
+            value: *mut u8,
+            value_size: *mut usize,
+        ) -> EfiStatus {
+            assert_eq!(
+                // SAFETY:
+                // * `name` is a valid pointer to null-terminated string.
+                unsafe { CStr::from_ptr(name) },
+                EXPECTED_NAME
+            );
+            assert_eq!(
+                // SAFETY:
+                // * `value_size` is a valid non-null pointer to `usize` value.
+                unsafe { ptr::read(value_size) },
+                EXPECTED_VALUE.len()
+            );
+
+            // SAFETY:
+            // * `value` is non-null pointer available for write.
+            let value_buffer = unsafe { slice::from_raw_parts_mut(value, EXPECTED_VALUE.len()) };
+            value_buffer.copy_from_slice(EXPECTED_VALUE);
+
+            return EFI_STATUS_SUCCESS;
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            read_persistent_value: Some(c_read_persistent_value_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            let mut buffer = [0u8; EXPECTED_VALUE.len()];
+
+            assert_eq!(
+                avb_protocol.read_persistent_value(EXPECTED_NAME, &mut buffer),
+                Ok(EXPECTED_VALUE.len())
+            );
+            assert_eq!(&buffer, EXPECTED_VALUE);
+        });
+    }
+
+    #[test]
+    fn read_persistent_value_buffer_too_small() {
+        const EXPECTED_BUFFER_SIZE: usize = 12;
+
+        /// C callback implementation.
+        ///
+        /// # Safety:
+        /// * Caller must guaranteed that `value_size` points to a valid usize available to write
+        ///   value buffer.
+        unsafe extern "C" fn c_read_persistent_value_buffer_too_small(
+            _: *mut GblEfiAvbProtocol,
+            _: *const c_char,
+            _: *mut u8,
+            value_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `value_size` is a valid non-null pointer to `usize` value.
+            unsafe { ptr::write(value_size, EXPECTED_BUFFER_SIZE) };
+
+            return EFI_STATUS_BUFFER_TOO_SMALL;
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            read_persistent_value: Some(c_read_persistent_value_buffer_too_small),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            let mut buffer = [0u8; 0];
+
+            assert_eq!(
+                avb_protocol.read_persistent_value(c"name", &mut buffer),
+                Err(Error::BufferTooSmall(Some(EXPECTED_BUFFER_SIZE)))
+            );
+        });
+    }
+
+    #[test]
+    fn write_persistent_value_success() {
+        const EXPECTED_NAME: &CStr = c"test_key";
+        const EXPECTED_VALUE: &[u8] = b"test_value";
+
+        /// C callback implementation.
+        ///
+        /// # Safety:
+        /// * Caller must guarantee that `name` points to a valid null-terminated string.
+        /// * Caller must guarantee that `value` points to a valid `value_size` sized bytes buffer.
+        unsafe extern "C" fn c_write_persistent_value_success(
+            _: *mut GblEfiAvbProtocol,
+            name: *const c_char,
+            value: *const u8,
+            value_size: usize,
+        ) -> EfiStatus {
+            assert_eq!(
+                // SAFETY:
+                // * `name` is a valid pointer to null-terminated string.
+                unsafe { CStr::from_ptr(name) },
+                EXPECTED_NAME
+            );
+            assert_eq!(value_size, EXPECTED_VALUE.len());
+
+            // SAFETY:
+            // * `value` is a valid pointer to `value_size` bytes.
+            let value_buffer = unsafe { slice::from_raw_parts(value, value_size) };
+            assert_eq!(value_buffer, EXPECTED_VALUE);
+
+            return EFI_STATUS_SUCCESS;
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            write_persistent_value: Some(c_write_persistent_value_success),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(
+                avb_protocol.write_persistent_value(EXPECTED_NAME, Some(EXPECTED_VALUE)),
+                Ok(())
+            );
+        });
+    }
+
+    #[test]
+    fn write_persistent_value_delete() {
+        const EXPECTED_NAME: &CStr = c"test_key";
+
+        /// C callback implementation for deleting a persistent value.
+        ///
+        /// # Safety:
+        /// * Caller must guarantee that `name` points to a valid null-terminated string.
+        unsafe extern "C" fn c_write_persistent_value_delete(
+            _: *mut GblEfiAvbProtocol,
+            name: *const c_char,
+            value: *const u8,
+            value_size: usize,
+        ) -> EfiStatus {
+            assert_eq!(
+                // SAFETY:
+                // * `name` is a valid pointer to null-terminated string.
+                unsafe { CStr::from_ptr(name) },
+                EXPECTED_NAME
+            );
+            assert!(value.is_null());
+            assert_eq!(value_size, 0);
+
+            return EFI_STATUS_SUCCESS;
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            write_persistent_value: Some(c_write_persistent_value_delete),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(avb_protocol.write_persistent_value(EXPECTED_NAME, None), Ok(()));
+        });
+    }
+
+    #[test]
+    fn write_persistent_value_error_handled() {
+        const EXPECTED_NAME: &CStr = c"test_key";
+        const EXPECTED_VALUE: &[u8] = b"test_value";
+
+        /// C callback implementation that returns an error.
+        ///
+        /// # Safety:
+        /// * Caller must guarantee that `name` points to a valid null-terminated string.
+        unsafe extern "C" fn c_write_persistent_value_error(
+            _: *mut GblEfiAvbProtocol,
+            name: *const c_char,
+            _: *const u8,
+            _: usize,
+        ) -> EfiStatus {
+            assert_eq!(
+                // SAFETY:
+                // * `name` is a valid pointer to null-terminated string.
+                unsafe { CStr::from_ptr(name) },
+                EXPECTED_NAME
+            );
+
+            return EFI_STATUS_INVALID_PARAMETER;
+        }
+
+        let c_interface = GblEfiAvbProtocol {
+            write_persistent_value: Some(c_write_persistent_value_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |avb_protocol| {
+            assert_eq!(
+                avb_protocol.write_persistent_value(EXPECTED_NAME, Some(EXPECTED_VALUE)),
+                Err(Error::InvalidInput),
+            );
+        });
+    }
+}
diff --git a/gbl/libefi/src/protocol/gbl_efi_fastboot.rs b/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
index 226c4ff..e50c74d 100644
--- a/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
+++ b/gbl/libefi/src/protocol/gbl_efi_fastboot.rs
@@ -18,11 +18,13 @@ use crate::{
     efi_call,
     protocol::{Protocol, ProtocolInfo},
 };
-use arrayvec::ArrayVec;
-use core::str::{from_utf8, Split};
-use efi_types::{
-    EfiGuid, GblEfiFastbootArg, GblEfiFastbootPolicy, GblEfiFastbootProtocol, GblEfiFastbootToken,
+use core::{
+    ffi::{c_char, c_void, CStr},
+    ptr::null,
+    slice::from_raw_parts,
+    str::from_utf8,
 };
+use efi_types::{EfiGuid, GblEfiFastbootPolicy, GblEfiFastbootProtocol};
 use liberror::{Error, Result};
 
 /// GBL_EFI_FASTBOOT_PROTOCOL
@@ -40,111 +42,94 @@ impl ProtocolInfo for GblFastbootProtocol {
         EfiGuid::new(0xc67e48a0, 0x5eb8, 0x4127, [0xbe, 0x89, 0xdf, 0x2e, 0xd9, 0x3d, 0x8a, 0x9a]);
 }
 
-/// Wrapper type for get_next_var_args() tokens.
-///
-/// Tokens are opaque values used to store the iterator's position.
-/// They can also be passed in get_var() to give the backend a hint
-/// on where to find a variable entry.
-#[derive(Copy, Clone, Debug)]
-pub struct Token(GblEfiFastbootToken);
-
-impl Token {
-    const fn new() -> Self {
-        Self(core::ptr::null())
-    }
-}
-
 impl Protocol<'_, GblFastbootProtocol> {
-    /// Hint-free wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var()`
-    pub fn get_var(&self, args: Split<'_, char>, buffer: &mut [u8]) -> Result<usize> {
-        self.get_var_with_hint(args, buffer, Token::new())
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var() with hint.`
-    pub fn get_var_with_hint(
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var`
+    pub fn get_var<'a>(
         &self,
-        args: Split<'_, char>,
-        buffer: &mut [u8],
-        hint: Token,
+        var: &CStr,
+        args: impl Iterator<Item = &'a CStr> + Clone,
+        out: &mut [u8],
     ) -> Result<usize> {
-        let mut bufsize = buffer.len();
-        let mut call_args: [GblEfiFastbootArg; MAX_ARGS + 1] = Default::default();
-        let mut call_args_len = 0usize;
-        for (a, ca) in core::iter::zip(args, call_args.iter_mut()) {
-            ca.str_utf8 = a.as_ptr();
-            ca.len = a.len();
-            call_args_len += 1;
-        }
-
-        if call_args_len == MAX_ARGS + 1 {
-            return Err(Error::InvalidInput);
-        }
-
+        let mut args_arr = [null(); MAX_ARGS];
+        let num_args = safemath::SafeNum::from(1) + args.clone().count();
+        let args_arr = args_arr.get_mut(..num_args.try_into()?).ok_or(Error::InvalidInput)?;
+        args_arr[0] = var.as_ptr();
+        args_arr[1..].iter_mut().zip(args).for_each(|(l, r)| *l = r.as_ptr());
+        let mut bufsize = out.len();
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
-        // No parameter is Null except optionally `hint`, and all parameters outlive the call.
-        // Null is a valid value for hint.
+        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
         unsafe {
             efi_call!(
                 @bufsize bufsize,
                 self.interface()?.get_var,
                 self.interface,
-                call_args.as_ptr(),
-                call_args_len,
-                buffer.as_mut_ptr(),
-                &mut bufsize,
-                hint.0,
+                args_arr.as_ptr(),
+                args_arr.len(),
+                out.as_mut_ptr(),
+                &mut bufsize
             )?
         };
         Ok(bufsize)
     }
 
-    fn start_var_iterator(&self) -> Result<Token> {
-        let mut token = Token::new();
-
-        // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // `self.interface` is an input parameter and will not be retained. It outlives the call.
-        // `token.0` is an output parameter. It is not retained, and it outlives the call.
-        // Null is a valid value for token.
-        unsafe { efi_call!(self.interface()?.start_var_iterator, self.interface, &mut token.0)? };
-
-        Ok(token)
-    }
-
-    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_next_var_args()`
-    fn get_next_var_args(
-        &self,
-        args: &mut [GblEfiFastbootArg],
-        token: Token,
-    ) -> Result<(usize, Token)> {
-        let mut bufsize = args.len();
-        let mut new_token = token;
+    /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.get_var_all`
+    pub fn get_var_all(&self, mut cb: impl FnMut(&[&CStr], &CStr)) -> Result<()> {
+        struct Callback<'a>(&'a mut dyn FnMut(&[&CStr], &CStr));
+
+        /// Callback C function to be passed to the `get_var_all` function.
+        ///
+        /// # Safety
+        ///
+        /// * Caller must guarantee that `ctx` points to a valid instance of `Callback`, outlives
+        ///   the call, and not being referenced elsewhere.
+        /// * Caller must guarantee that `args` points to an array of NULL-terminated strings with
+        ///   size `len` and outlives the call.
+        /// * Caller must guarantee that `val` points to valid NULL-terminated strings and outlives
+        ///   the call.
+        unsafe extern "C" fn get_var_all_cb(
+            ctx: *mut c_void,
+            args: *const *const c_char,
+            len: usize,
+            val: *const c_char,
+        ) {
+            // SAFETY: By safety requirement of this function, `args` points to an array of
+            // NULL-terminated strings of length `len`.
+            let args =
+                unsafe { from_raw_parts(args, len) }.iter().map(|v| unsafe { CStr::from_ptr(*v) });
+            // SAFETY: By requirement of this function, `ctx` points to a `Callback`.
+            let cb = unsafe { (ctx as *mut Callback).as_mut() }.unwrap();
+            // Checks number of arguments and stores them in an array.
+            let mut args_arr = [c""; MAX_ARGS];
+            match args_arr.get_mut(..len) {
+                Some(v) => {
+                    v.iter_mut().zip(args).for_each(|(l, r)| *l = r);
+                    // SAFETY: By safety requirement of this function `val` points to a
+                    // NULL-terminated string.
+                    (cb.0)(&v, unsafe { CStr::from_ptr(val) })
+                }
+                _ => (cb.0)(&[c"<Number of arguments exceeds limit>"], c""),
+            }
+        }
 
         // SAFETY:
-        // `self.interface()?` guarantees self.interface is non-null and points to a valid object
-        // established by `Protocol::new()`.
-        // No parameter is retained, and all parameters outlive the call.
-        // No parameter is Null except possibly `new_token.0`
-        // Null is a valid value for `new_token.0`.
+        // *`self.interface()?` guarantees self.interface is non-null and points to a valid object
+        // * established by `Protocol::new()`.
+        // * The `ctx` parameter is a valid `Callback` object, outlives the call and not being
+        //   referenced elsewhere(declared inline at the parameter site).
+        // * By UEFI interface requirement, vendor firmware passes array of C strings to
+        //   `get_var_all_cb` that remains valid for the call.
         unsafe {
             efi_call!(
-                @bufsize bufsize,
-                self.interface()?.get_next_var_args,
+                self.interface()?.get_var_all,
                 self.interface,
-                args.as_mut_ptr(),
-                &mut bufsize,
-                &mut new_token.0
+                &mut Callback(&mut cb) as *mut _ as _,
+                Some(get_var_all_cb),
             )?
         };
-        Ok((bufsize, new_token))
-    }
 
-    /// Returns an iterator over backend fastboot variables.
-    pub fn var_iter(&self) -> Result<VarIterator> {
-        VarIterator::try_new(self)
+        Ok(())
     }
 
     /// Wrapper of `GBL_EFI_FASTBOOT_PROTOCOL.run_oem_function()`
@@ -180,8 +165,7 @@ impl Protocol<'_, GblFastbootProtocol> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call,
-        // and no pointers are Null.
+        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
         unsafe { efi_call!(self.interface()?.get_policy, self.interface, &mut policy)? };
 
         Ok(policy)
@@ -212,8 +196,7 @@ impl Protocol<'_, GblFastbootProtocol> {
         // SAFETY:
         // `self.interface()?` guarantees self.interface is non-null and points to a valid object
         // established by `Protocol::new()`.
-        // No parameters are retained, all parameters outlive the call,
-        // and no pointers are Null.
+        // No parameters are retained, all parameters outlive the call, and no pointers are Null.
         unsafe {
             efi_call!(
                 self.interface()?.get_partition_permissions,
@@ -248,318 +231,19 @@ impl Protocol<'_, GblFastbootProtocol> {
     }
 }
 
-/// Iterator over fastboot variables.
-pub struct VarIterator<'a> {
-    protocol: &'a Protocol<'a, GblFastbootProtocol>,
-    token: Token,
-}
-
-impl<'a> VarIterator<'a> {
-    /// Tries to construct a new iterator over fastboot variables.
-    /// Returns Err if the call to protocol.start_var_iterator fails.
-    pub fn try_new(protocol: &'a Protocol<'a, GblFastbootProtocol>) -> Result<Self> {
-        let token = protocol.start_var_iterator()?;
-        Ok(Self { protocol, token })
-    }
-}
-
-impl<'a> Iterator for VarIterator<'a> {
-    type Item = (ArrayVec<GblEfiFastbootArg, MAX_ARGS>, Token);
-    fn next(&mut self) -> Option<Self::Item> {
-        let mut args = [GblEfiFastbootArg::default(); MAX_ARGS];
-
-        let prev_token = self.token;
-        let (len, token) = self.protocol.get_next_var_args(&mut args, self.token).ok()?;
-        self.token = token;
-
-        if len == 0 {
-            None
-        } else {
-            let mut args = ArrayVec::from(args);
-            args.truncate(len);
-            Some((args, prev_token))
-        }
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::*;
-    use crate::test::{generate_protocol, run_test};
-    use crate::EfiEntry;
-    use core::slice;
+    use crate::{
+        protocol::GetVarAllCallback,
+        test::{generate_protocol, run_test},
+        EfiEntry,
+    };
     use core::{
         ffi::{c_void, CStr},
-        ptr::addr_of,
-    };
-    use efi_types::{
-        EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_NOT_FOUND,
-        EFI_STATUS_SUCCESS,
+        slice::from_raw_parts_mut,
     };
-
-    #[derive(Copy, Clone, Debug)]
-    struct VarEntry<'a, 'b> {
-        var_args: &'a [GblEfiFastbootArg],
-        val: &'b CStr,
-    }
-
-    // SAFETY:
-    // All VarEntry entities are immutable and static.
-    unsafe impl Sync for VarEntry<'static, 'static> {}
-
-    fn count_bytes_cstr(cstr: &CStr) -> usize {
-        cstr.to_bytes_with_nul().iter().position(|c| *c == 0).unwrap()
-    }
-
-    unsafe fn join_args(args: &[GblEfiFastbootArg], conjunction: &str) -> String {
-        args.iter()
-            .map(|arg| {
-                // SAFETY: It is the caller's responsibility to verify that `arg.str_utf8`
-                // points to a byte slice of length `arg.len`.
-                core::str::from_utf8(unsafe { slice::from_raw_parts(arg.str_utf8, arg.len) })
-                    .unwrap()
-            })
-            .fold(String::new(), |mut acc, s| {
-                acc.push_str(s);
-                acc.push_str(conjunction);
-                acc
-            })
-    }
-
-    const fn from_str(s: &str) -> GblEfiFastbootArg {
-        GblEfiFastbootArg { str_utf8: s.as_ptr(), len: s.len() }
-    }
-
-    static VARS: &[VarEntry] = &[
-        VarEntry { var_args: &[from_str("bivalve")], val: c"clam" },
-        VarEntry { var_args: &[from_str("cephalopod"), from_str("nautiloid")], val: c"nautilus" },
-        VarEntry { var_args: &[from_str("cephalopod"), from_str("coleoid")], val: c"squid" },
-        VarEntry {
-            var_args: &[from_str("gastropod"), from_str("muricidae"), from_str("nucella")],
-            val: c"whelk",
-        },
-    ];
-
-    #[derive(Copy, Clone, Debug)]
-    struct PtrWrapper<T> {
-        ptr: *const T,
-    }
-
-    impl<T> PtrWrapper<T> {
-        const fn new(ptr: *const T) -> Self {
-            Self { ptr }
-        }
-        const fn get(&self) -> *const T {
-            self.ptr
-        }
-    }
-
-    static VARS_ADDR: PtrWrapper<VarEntry> = PtrWrapper::new(addr_of!(VARS[0]));
-    // SAFETY
-    // `VARS_ADDR` is a known valid pointer to a known-length array of VarEntry.
-    // `VARS_ADDR + VARS.len()` is extremely unlikely to overwrap,
-    // and `VARS_END` is never dereferenced.
-    static VARS_END: PtrWrapper<VarEntry> =
-        PtrWrapper::new(unsafe { VARS_ADDR.get().add(VARS.len()) });
-
-    // SAFETY
-    // PtrWrapper and the pointer it wraps are immutable.
-    unsafe impl<T> Sync for PtrWrapper<T> {}
-
-    unsafe fn arg_slices_equal_p(lhs: &[GblEfiFastbootArg], rhs: &[GblEfiFastbootArg]) -> bool {
-        if lhs.len() != rhs.len() {
-            return false;
-        }
-
-        // SAFETY:
-        // It is the caller's responsibility to guarantee that for each element
-        // 'arg' of `lhs`, `arg.str_utf8` is a valid UTF-8 encoded string of length `arg.len`.
-        let lhs = lhs.iter().map(|arg| unsafe {
-            core::str::from_utf8_unchecked(core::slice::from_raw_parts(arg.str_utf8, arg.len))
-        });
-        // SAFETY:
-        // It is the caller's responsibility to guarantee that for each element
-        // 'arg' of `rhs`, `arg.str_utf8` is a valid UTF-8 encoded string of length `arg.len`.
-        let rhs = rhs.iter().map(|arg| unsafe {
-            core::str::from_utf8_unchecked(core::slice::from_raw_parts(arg.str_utf8, arg.len))
-        });
-
-        core::iter::zip(lhs, rhs).all(|(l, r)| l == r)
-    }
-
-    unsafe extern "C" fn get_var(
-        _: *mut GblEfiFastbootProtocol,
-        args: *const GblEfiFastbootArg,
-        args_len: usize,
-        buffer: *mut u8,
-        bufsize: *mut usize,
-        _token: GblEfiFastbootToken,
-    ) -> EfiStatus {
-        if args.is_null() || buffer.is_null() || bufsize.is_null() {
-            return EFI_STATUS_INVALID_PARAMETER;
-        }
-        // SAFETY:
-        // The check at the beginning of the function guarantees that `args` is not Null.
-        // It is the caller's responsibility to guarantee that `args` points to a valid
-        // array of initialized GblEfiFastbootArg structs of length `args_len`.
-        let args = unsafe { core::slice::from_raw_parts(args, args_len) };
-
-        // SAFETY:
-        // All elements of `VARS` contain valid UTF-8 encoded strings.
-        // It is the caller's responsibility to guarantee that all elements of `args`
-        // contain valid UTF-8 encoded strings.
-        let entry = VARS.iter().find(|entry| unsafe { arg_slices_equal_p(args, &entry.var_args) });
-        if let Some(entry) = entry {
-            let val_len = count_bytes_cstr(entry.val);
-            // SAFETY:
-            // `bufsize` is not Null due to check at beginning of function.
-            // Caller is responsible for passing a well-aligned pointer to a valid usize.
-            let bs = unsafe { *bufsize };
-            // SAFETY:
-            // `bufsize` is not Null due to check at beginning of function.
-            // It is the caller's responsibility to pass a valid, well-aligned pointer as `bufsize`.
-            unsafe { *bufsize = val_len };
-            if val_len > bs {
-                EFI_STATUS_BUFFER_TOO_SMALL
-            } else {
-                // SAFETY:
-                // `buffer` is not Null due to check at beginning of function.
-                // It is the caller's responsibiltiy to pass a valid, well-aligned pointer
-                // to an array of `u8` at least as long as the initial value of `bufsize`.
-                unsafe { buffer.copy_from(entry.val.to_bytes().as_ptr(), *bufsize) };
-                EFI_STATUS_SUCCESS
-            }
-        } else {
-            EFI_STATUS_NOT_FOUND
-        }
-    }
-
-    unsafe extern "C" fn start_var_iterator(
-        _: *mut GblEfiFastbootProtocol,
-        token: *mut GblEfiFastbootToken,
-    ) -> EfiStatus {
-        if token.is_null() {
-            return EFI_STATUS_INVALID_PARAMETER;
-        }
-
-        // SAFETY:
-        // `token` is not Null.
-        // It is the caller's responsibility to pass a valid,
-        // well aligned pointer as `token`.
-        // `VARS_ADDR` contains a valid pointer to a static array.
-        unsafe { *token = VARS_ADDR.get() as *const c_void };
-        EFI_STATUS_SUCCESS
-    }
-
-    unsafe extern "C" fn get_next_var_args(
-        _: *mut GblEfiFastbootProtocol,
-        args: *mut GblEfiFastbootArg,
-        args_len: *mut usize,
-        token: *mut GblEfiFastbootToken,
-    ) -> EfiStatus {
-        if args.is_null() || args_len.is_null() || token.is_null() {
-            return EFI_STATUS_INVALID_PARAMETER;
-        }
-
-        // SAFETY:
-        // `token` is not Null due to check at beginning of function.
-        // caller is responsible for passing a valid, well-aligned pointer.
-        let pos = unsafe { *token.cast::<*const VarEntry>() };
-        if pos == VARS_END.get() {
-            // SAFETY:
-            // `args_len` is not null due to check at beginning of funcion.
-            // caller is responsible for passing a valid, well-aligned pointer as `args_len`.
-            unsafe { *args_len = 0 };
-            return EFI_STATUS_SUCCESS;
-        } else if pos < VARS_ADDR.get() || pos > VARS_END.get() {
-            return EFI_STATUS_INVALID_PARAMETER;
-        }
-
-        // SAFETY:
-        // `args_len` is not Null due to check at beginning of function.
-        // caller is responsible for passing a valid, well-aligned pointer for args_len.
-        let args_max_len = unsafe { *args_len };
-
-        // SAFETY:
-        // `pos` is between `&VARS` inclusive and `&VARS + VARS.len()` exclusive
-        // due to check earlier.
-        let elt = unsafe { *pos };
-        // SAFETY:
-        // `args_len` is not Null.
-        // caller is responsible for passing a valid, well-aligned pointer.
-        unsafe { *args_len = elt.var_args.len() };
-        if args_max_len < elt.var_args.len() {
-            return EFI_STATUS_BUFFER_TOO_SMALL;
-        }
-
-        for (i, varg) in elt.var_args.iter().enumerate() {
-            // SAFETY:
-            // `args` is not Null due to check at beginning of function.
-            // `args_len` is at least as large as as `elt.var_args.len()`
-            // due to check before returning BUFFER_TOO_SMALL.
-            // It is the caller's responsibility to guarantee that `args` is a valid
-            // array of at least `args_len` length.
-            unsafe { *args.add(i) = *varg };
-        }
-        // SAFETY:
-        // `token` is not Null due to check at beginning of function.
-        // `pos.add(1)` either points to a valid entry in `VARS` or
-        // one past the end of `VARS`, which is a valid pointer to construct
-        // for the purpose of checking for the end of iteration.
-        unsafe { *token = pos.add(1).cast::<c_void>() };
-
-        EFI_STATUS_SUCCESS
-    }
-
-    #[test]
-    fn test_var_iterator() {
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol {
-                start_var_iterator: Some(start_var_iterator),
-                get_next_var_args: Some(get_next_var_args),
-                ..Default::default()
-            };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-            let var_iter = protocol.var_iter().unwrap();
-
-            // SAFETY:
-            // All elements of `VARS`, and therefore all elements of `var_iter`,
-            // contain valid UTF-8 encoded strings.
-            let actual: Vec<String> = var_iter
-                .map(|(args, _token): (_, Token)| unsafe { join_args(&args, ":") })
-                .collect();
-
-            let expected = &[
-                "bivalve:",
-                "cephalopod:nautiloid:",
-                "cephalopod:coleoid:",
-                "gastropod:muricidae:nucella:",
-            ];
-
-            assert_eq!(expected, actual.as_slice());
-        });
-    }
-
-    #[test]
-    fn test_get_var() {
-        run_test(|image_handle, systab_ptr| {
-            let mut fb = GblEfiFastbootProtocol { get_var: Some(get_var), ..Default::default() };
-            let efi_entry = EfiEntry { image_handle, systab_ptr };
-            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
-
-            let args = "cephalopod:coleoid".split(':');
-            let mut buffer = [0u8; 32];
-            let len = protocol.get_var(args, &mut buffer).unwrap();
-            let actual = std::str::from_utf8(&buffer[..len]).unwrap();
-            assert_eq!(actual, "squid");
-
-            let args = "cephalopod:nautiloid".split(':');
-            let len = protocol.get_var_with_hint(args, &mut buffer, Token::new()).unwrap();
-            let actual = std::str::from_utf8(&buffer[..len]).unwrap();
-            assert_eq!(actual, "nautilus");
-        });
-    }
+    use efi_types::{EfiStatus, EFI_STATUS_SUCCESS};
 
     #[test]
     fn test_serial_number() {
@@ -603,4 +287,128 @@ mod test {
             assert_eq!(protocol.serial_number(), Err(Error::InvalidInput));
         });
     }
+
+    #[test]
+    fn test_get_var() {
+        /// # Safety
+        ///
+        /// * Caller must guarantee that `args` points to an array of NULL-terminated strings with
+        ///   size `num_args`.
+        /// * Caller must guarantee that `out` points to a `[u8]`
+        /// * Caller must guarantee that `out_size` points to a `usize`
+        unsafe extern "C" fn get_var_test(
+            _: *mut GblEfiFastbootProtocol,
+            args: *const *const c_char,
+            num_args: usize,
+            out: *mut u8,
+            out_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY: By safety requirement of this function, `args` points to an array of
+            // NULL-terminated strings with length `num_args`.
+            let args = unsafe { from_raw_parts(args, num_args) }
+                .iter()
+                .map(|v| unsafe { CStr::from_ptr(*v) })
+                .collect::<Vec<_>>();
+            assert_eq!(args, [c"var", c"arg1", c"arg2"]);
+            // SAFETY: By safety requirement of this function, `out_size` points to a `usize`;
+            let out_size = &mut unsafe { *out_size };
+            // SAFETY: By safety requirement of this function, `out` points to a `[u8]`;
+            let out = unsafe { from_raw_parts_mut(out, *out_size) };
+            out.clone_from_slice(c"val".to_bytes());
+            *out_size = c"val".to_bytes().len();
+            EFI_STATUS_SUCCESS
+        }
+
+        run_test(|image_handle, systab_ptr| {
+            let mut fb =
+                GblEfiFastbootProtocol { get_var: Some(get_var_test), ..Default::default() };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+            let mut out = [0u8; 3];
+            let args = [c"arg1", c"arg2"];
+            assert_eq!(protocol.get_var(c"var", args.iter().copied(), &mut out[..]), Ok(3));
+            assert_eq!(&out, b"val");
+        });
+    }
+
+    #[test]
+    fn test_get_var_all() {
+        /// # Safety
+        ///
+        /// * Caller must guarantee that `ctx` points to data needed by function pointer `cb`.
+        unsafe extern "C" fn test_get_var_all(
+            _: *mut GblEfiFastbootProtocol,
+            ctx: *mut c_void,
+            cb: GetVarAllCallback,
+        ) -> EfiStatus {
+            for (args, val) in [
+                ([c"foo", c"foo_arg1", c"foo_arg2"], c"foo_val"),
+                ([c"bar", c"bar_arg1", c"bar_arg2"], c"bar_val"),
+            ] {
+                let args = args.map(|v| v.as_ptr());
+                // SAFETY:
+                // * `args` is an array of NULL-terminated strings. `val` is a NULL-terminated
+                //   string.
+                // * By safety requirement of this function, `ctx` points to a valid type of data
+                //   needed by `cb`.
+                unsafe { (cb.unwrap())(ctx, args.as_ptr(), args.len(), val.as_ptr()) };
+            }
+            EFI_STATUS_SUCCESS
+        }
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol {
+                get_var_all: Some(test_get_var_all),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+            let mut out = vec![];
+            protocol
+                .get_var_all(|args, val| {
+                    let args_str =
+                        args.iter().map(|v| v.to_str().unwrap()).collect::<Vec<_>>().join(":");
+                    out.push(format!("{args_str}: {}", val.to_str().unwrap()))
+                })
+                .unwrap();
+            assert_eq!(out, ["foo:foo_arg1:foo_arg2: foo_val", "bar:bar_arg1:bar_arg2: bar_val",])
+        });
+    }
+
+    #[test]
+    fn test_get_var_all_exceeds_max_arguments() {
+        /// # Safety
+        ///
+        /// * Caller must guarantee that `ctx` points to data needed by function pointer `cb`.
+        unsafe extern "C" fn test_get_var_all(
+            _: *mut GblEfiFastbootProtocol,
+            ctx: *mut c_void,
+            cb: GetVarAllCallback,
+        ) -> EfiStatus {
+            let args = [c"".as_ptr(); MAX_ARGS + 1];
+            // SAFETY:
+            // * `args` is an array of NULL-terminated strings. `val` is a NULL-terminated
+            //   string.
+            // * By safety requirement of this function, `ctx` points to a valid type of data
+            //   needed by `cb`.
+            unsafe { (cb.unwrap())(ctx, args.as_ptr(), args.len(), c"".as_ptr()) };
+            EFI_STATUS_SUCCESS
+        }
+        run_test(|image_handle, systab_ptr| {
+            let mut fb = GblEfiFastbootProtocol {
+                get_var_all: Some(test_get_var_all),
+                ..Default::default()
+            };
+            let efi_entry = EfiEntry { image_handle, systab_ptr };
+            let protocol = generate_protocol::<GblFastbootProtocol>(&efi_entry, &mut fb);
+            let mut out = vec![];
+            protocol
+                .get_var_all(|args, val| {
+                    let args_str =
+                        args.iter().map(|v| v.to_str().unwrap()).collect::<Vec<_>>().join(":");
+                    out.push(format!("{args_str}: {}", val.to_str().unwrap()))
+                })
+                .unwrap();
+            assert_eq!(out, ["<Number of arguments exceeds limit>: "])
+        });
+    }
 }
diff --git a/gbl/libefi/src/protocol/gbl_efi_image_loading.rs b/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
index d5e2343..f832322 100644
--- a/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
+++ b/gbl/libefi/src/protocol/gbl_efi_image_loading.rs
@@ -50,10 +50,12 @@ pub struct EfiImageBuffer {
 }
 
 impl EfiImageBuffer {
-    // SAFETY:
+    // # Safety
+    //
     // `gbl_buffer` must represent valid buffer.
     //
     // # Return
+    //
     // Err(EFI_STATUS_INVALID_PARAMETER) - If `gbl_buffer.Memory` == NULL
     // Err(EFI_STATUS_ALREADY_STARTED) - Requested buffer was already returned and is still in use.
     // Err(err) - on error
@@ -88,6 +90,23 @@ impl EfiImageBuffer {
     pub fn take(mut self) -> &'static mut [MaybeUninit<u8>] {
         self.buffer.take().unwrap()
     }
+
+    // Removes address from `RETURNED_BUFFERS`.
+    //
+    // # Safety
+    //
+    // Caller must guarantee that address is not referenced anymore.
+    unsafe fn release(address: usize) {
+        let mut returned_buffers = RETURNED_BUFFERS.lock();
+        let res = returned_buffers.iter().position(|&val| val == address);
+        debug_assert!(
+            res.is_some(),
+            "EfiImageBuffer::release trying to release address ({address}) that is not tracked"
+        );
+        if let Some(pos) = res {
+            returned_buffers.swap_remove(pos);
+        }
+    }
 }
 
 impl Drop for EfiImageBuffer {
@@ -96,13 +115,10 @@ impl Drop for EfiImageBuffer {
             return;
         }
 
-        let mut returned_buffers = RETURNED_BUFFERS.lock();
-        if let Some(pos) = returned_buffers
-            .iter()
-            .position(|&val| val == (*self.buffer.as_ref().unwrap()).as_ptr() as usize)
-        {
-            returned_buffers.swap_remove(pos);
-        }
+        // SAFETY:
+        // EfiIMageBuffer is the only owner of the buffer. The only way to get address for it is to
+        // call `take()` which consumes `self.buffer`, which we check above.
+        unsafe { EfiImageBuffer::release((*self.buffer.as_ref().unwrap()).as_ptr() as usize) };
     }
 }
 
@@ -196,6 +212,9 @@ mod test {
         EfiStatus, EFI_STATUS_BAD_BUFFER_SIZE, EFI_STATUS_BUFFER_TOO_SMALL,
         EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
     };
+    use spin::MutexGuard;
+    use std::cell::RefCell;
+    use std::collections::HashSet;
 
     const UCS2_STR: [u16; 8] = [0x2603, 0x0073, 0x006e, 0x006f, 0x0077, 0x006d, 0x0061, 0x006e];
     const UTF8_STR: &str = "☃snowman";
@@ -621,8 +640,127 @@ mod test {
     }
 
     // Mutex to make sure tests that use `static RETURNED_BUFFERS` do not run in parallel to avoid
-    // unexpected results since this is global static that would be shared between tests.
+    // unexpected results since this is global static that would be shared between tests. And can
+    // overflow due to amount of tests.
+    //
+    // See MEMORY_TEST thread local variable that should be used for convenience.
     static GET_BUFFER_MUTEX: Mutex<()> = Mutex::new(());
+
+    // Size of MEMORY_TEST buffers
+    const MEMORY_TEST_BUF_SIZE: usize = 100;
+
+    // Helper struct for safe acquisition of the memory and releasing it on exit
+    struct MemoryTest<'a> {
+        // Tracking if test guard was acquired with `start()`
+        init: bool,
+        // Keep track of all buffers returned
+        returned_buffers: HashSet<*mut [u8; MEMORY_TEST_BUF_SIZE]>,
+        // Store same buffer value for `get_memory_same()` calls.
+        same_buffer: Option<*mut c_void>,
+        // It is necessary to run 1 test at a time that uses UEFI `get_buffer()`.
+        // Because it is uses static size array to track returned values to prevent reusing same
+        // buffer. With current number of test if they run simultaneously there are situations when
+        // array limit is reached and unlucky test will fail. To prevent this flakiness this guard
+        // is used.
+        _get_buffer_guard: MutexGuard<'a, ()>,
+    }
+
+    thread_local! {
+        static MEMORY_TEST: RefCell<MemoryTest<'static>> = RefCell::new(MemoryTest::new());
+    }
+    struct MemoryTestInitGuard {}
+
+    impl Drop for MemoryTestInitGuard {
+        fn drop(&mut self) {
+            MEMORY_TEST.with_borrow_mut(|v| v.stop());
+        }
+    }
+
+    // Helper implementation for getting raw buffers for `get_buffer()` calls.
+    // And cleanly releasing buffers at the end of the test to prevent memory leaks.
+    //
+    // Use `thread_local` static MEMORY_TEST variable.
+    //
+    // ```
+    // let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
+    // ...
+    // buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+    // ...
+    // ```
+    // _memory_guard will make sure to cleanup all memory that was retrieved by `get_memory()` call
+    //
+    // Note:
+    // If using raw EfiImageBuffer, there is no need for this helper. Since the structure does
+    // cleaning on its own.
+    // Except when using `EfiImageBuffer::take()` then manual `EfiImageBuffer::release()` must be
+    // used.
+    impl MemoryTest<'_> {
+        fn new() -> Self {
+            MemoryTest {
+                init: false,
+                returned_buffers: HashSet::new(),
+                same_buffer: None,
+                _get_buffer_guard: GET_BUFFER_MUTEX.lock(),
+            }
+        }
+
+        fn start(&mut self) -> MemoryTestInitGuard {
+            assert!(!self.init);
+            self.init = true;
+            MemoryTestInitGuard {}
+        }
+
+        // Return heap allocated buffer, and keep track of its address
+        // To verify it was properly released
+        //
+        // # Safety
+        //
+        // Returned pointers must not be used after guard returned by `start()`
+        // is destroyed.
+        unsafe fn get_memory(&mut self) -> *mut c_void {
+            assert!(self.init);
+            let ptr = Box::into_raw(Box::new([0u8; MEMORY_TEST_BUF_SIZE]));
+            assert!(self.returned_buffers.insert(ptr));
+            ptr as *mut c_void
+        }
+
+        // Return same buffer for all calls, allocating and tracking it only for first call.
+        //
+        // # Safety
+        //
+        // Returned pointers must not be used after guard returned by `start()`
+        // is destroyed.
+        unsafe fn get_memory_same(&mut self) -> *mut c_void {
+            if self.same_buffer.is_none() {
+                // SAFETY:
+                // This function has same requirements as `get_memory()`
+                let address = unsafe { self.get_memory() };
+
+                self.same_buffer = Some(address);
+            }
+
+            *self.same_buffer.as_mut().unwrap()
+        }
+
+        // Clear address from buffers returned list
+        // Which allows to reuse it in other tests.
+        fn stop(&mut self) {
+            assert!(self.init);
+            self.init = false;
+            self.same_buffer = None;
+            for ptr in self.returned_buffers.drain() {
+                // SAFETY:
+                // `ptr` is valid since was created by `Box::into_raw()`.
+                // Double free is covered by safety requirements for this function. (`release_memory()`
+                // must be called only on buffer holding the only reference to buffer.)
+                // As well as tracking `returned_buffers` and asserting remove in the line above.
+                unsafe {
+                    let _restore_box = Box::from_raw(ptr);
+                }
+            }
+        }
+    }
+
     #[test]
     fn test_proto_get_buffer_error() {
         unsafe extern "C" fn get_buffer(
@@ -641,6 +779,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             assert!(protocol.get_buffer(&gbl_image_info).is_err());
         });
     }
@@ -672,15 +811,12 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let res = protocol.get_buffer(&gbl_image_info);
             assert_eq!(res.unwrap_err(), Error::InvalidInput);
         });
     }
 
-    fn get_memory() -> Box<[u8; 100]> {
-        Box::new([0; 100])
-    }
-
     #[test]
     fn test_proto_get_buffer_zero_size() {
         unsafe extern "C" fn get_buffer(
@@ -694,7 +830,13 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+            }
             buffer.SizeBytes = 0;
 
             EFI_STATUS_SUCCESS
@@ -708,7 +850,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let res = protocol.get_buffer(&gbl_image_info).unwrap();
             assert!(res.buffer.as_ref().unwrap().is_empty());
         });
@@ -730,7 +872,13 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+            }
             buffer.SizeBytes = image_info.SizeBytes - 1;
 
             EFI_STATUS_SUCCESS
@@ -745,7 +893,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let res = protocol.get_buffer(&gbl_image_info);
             assert_eq!(res.unwrap_err(), Error::BufferTooSmall(Some(10)));
         });
@@ -764,9 +912,14 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            let mem = get_memory();
-            buffer.SizeBytes = mem.len();
-            buffer.Memory = Box::leak(mem).as_mut_ptr() as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+            }
+            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
 
             EFI_STATUS_SUCCESS
         }
@@ -780,7 +933,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let buf = protocol.get_buffer(&gbl_image_info).unwrap();
             assert_ne!(buf.buffer.as_ref().unwrap().as_ptr(), null_mut());
             assert_eq!(buf.buffer.as_ref().unwrap().len(), 100);
@@ -810,9 +963,14 @@ mod test {
                 IMAGE_TYPE_STR
             );
 
-            let mem = get_memory();
-            buffer.SizeBytes = mem.len();
-            buffer.Memory = Box::leak(mem).as_mut_ptr() as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+            }
+            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
 
             EFI_STATUS_SUCCESS
         }
@@ -828,9 +986,8 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
-            let res = protocol.get_buffer(&gbl_image_info);
-            assert!(res.is_ok());
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
+            assert!(protocol.get_buffer(&gbl_image_info).is_ok());
         });
     }
 
@@ -847,9 +1004,14 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            let mem = get_memory();
-            buffer.SizeBytes = mem.len();
-            buffer.Memory = 0x1000 as *mut c_void;
+            // SAFETY:
+            // `get_memory_same()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory_same());
+            }
+            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
 
             EFI_STATUS_SUCCESS
         }
@@ -863,7 +1025,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let _buf = protocol.get_buffer(&gbl_image_info).unwrap();
             assert_eq!(protocol.get_buffer(&gbl_image_info).unwrap_err(), Error::AlreadyStarted);
         });
@@ -882,9 +1044,14 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            let mem = get_memory();
-            buffer.SizeBytes = mem.len();
-            buffer.Memory = 0x2000 as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory_same());
+            }
+            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
 
             EFI_STATUS_SUCCESS
         }
@@ -898,7 +1065,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             protocol.get_buffer(&gbl_image_info).unwrap();
             protocol.get_buffer(&gbl_image_info).unwrap();
         });
@@ -918,10 +1085,14 @@ mod test {
             // `buffer` must be valid pointer to `GblEfiImageBuffer`
             let buffer = unsafe { buffer.as_mut() }.unwrap();
 
-            let mem = get_memory();
-            buffer.SizeBytes = mem.len();
-            // Make sure to return different memory
-            buffer.Memory = Box::leak(get_memory()).as_mut_ptr() as *mut c_void;
+            // SAFETY:
+            // `get_memory()` results are returned in `buffer` in `get_buffer()` function.
+            // All usage of `get_buffer()` results are not leaving `run_test()` scope.
+            // Same function where `start()` guard is acquired, so it will not outlive guard.
+            unsafe {
+                buffer.Memory = MEMORY_TEST.with_borrow_mut(|v| v.get_memory());
+            }
+            buffer.SizeBytes = MEMORY_TEST_BUF_SIZE;
 
             EFI_STATUS_SUCCESS
         }
@@ -935,7 +1106,7 @@ mod test {
             let protocol =
                 generate_protocol::<GblImageLoadingProtocol>(&efi_entry, &mut image_loading);
 
-            let _guard = GET_BUFFER_MUTEX.lock();
+            let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
             let mut keep_alive: Vec<EfiImageBuffer> = vec![];
             for _ in 1..=MAX_ARRAY_SIZE + 1 {
                 keep_alive.push(protocol.get_buffer(&gbl_image_info).unwrap());
@@ -949,7 +1120,7 @@ mod test {
         let gbl_buffer =
             GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
 
-        let _guard = GET_BUFFER_MUTEX.lock();
+        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
         // SAFETY:
         // 'gbl_buffer` represents valid buffer created by vector.
         let res = unsafe { EfiImageBuffer::new(gbl_buffer) };
@@ -960,7 +1131,7 @@ mod test {
     fn test_efi_image_buffer_null() {
         let gbl_buffer = GblEfiImageBuffer { Memory: null_mut(), SizeBytes: 1 };
 
-        let _guard = GET_BUFFER_MUTEX.lock();
+        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
         // SAFETY:
         // 'gbl_buffer` contains Memory == NULL, which is valid input value. And we expect Error as
         // a result
@@ -974,7 +1145,7 @@ mod test {
         let gbl_buffer =
             GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
 
-        let _guard = GET_BUFFER_MUTEX.lock();
+        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
         // SAFETY:
         // 'gbl_buffer` represents valid buffer created by vector.
         let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
@@ -993,7 +1164,7 @@ mod test {
         let gbl_buffer =
             GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
 
-        let _guard = GET_BUFFER_MUTEX.lock();
+        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
         // SAFETY:
         // 'gbl_buffer` represents valid buffer created by vector.
         let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) };
@@ -1012,16 +1183,23 @@ mod test {
         let gbl_buffer =
             GblEfiImageBuffer { Memory: v.as_mut_ptr() as *mut c_void, SizeBytes: v.len() };
 
-        let _guard = GET_BUFFER_MUTEX.lock();
+        let _memory_guard = MEMORY_TEST.with_borrow_mut(|v| v.start());
         // SAFETY:
         // 'gbl_buffer` represents valid buffer created by vector.
         let res1 = unsafe { EfiImageBuffer::new(gbl_buffer) }.unwrap();
-        let _tmp = res1.take();
+        let buf_no_owner = res1.take();
 
         // Since `res1` was taken, we can't reuse same buffer.
         // SAFETY:
         // 'gbl_buffer` represents valid buffer created by vector.
         let res2 = unsafe { EfiImageBuffer::new(gbl_buffer) };
         assert_eq!(res2.unwrap_err(), Error::AlreadyStarted);
+
+        // Make sure to clean tracking
+        // SAFETY:
+        // `buf_no_owner` is the only reference to buffer
+        unsafe {
+            EfiImageBuffer::release(buf_no_owner.as_ptr() as usize);
+        }
     }
 }
diff --git a/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs b/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
index d482ca5..4426c67 100644
--- a/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
+++ b/gbl/libefi/src/protocol/gbl_efi_os_configuration.rs
@@ -16,8 +16,9 @@
 
 use crate::efi_call;
 use crate::protocol::{Protocol, ProtocolInfo};
-use efi_types::{EfiGuid, GblEfiOsConfigurationProtocol};
-use liberror::Result;
+use core::ffi::CStr;
+use efi_types::{EfiGuid, GblEfiOsConfigurationProtocol, GblEfiVerifiedDeviceTree};
+use liberror::{Error, Result};
 
 /// `GBL_EFI_OS_CONFIGURATION_PROTOCOL` implementation.
 pub struct GblOsConfigurationProtocol;
@@ -31,47 +32,79 @@ impl ProtocolInfo for GblOsConfigurationProtocol {
 
 // Protocol interface wrappers.
 impl Protocol<'_, GblOsConfigurationProtocol> {
-    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupKernelCommandline()`
-    pub fn fixup_kernel_commandline(&self, data: &mut [u8]) -> Result<usize> {
-        let mut buffer_size = data.len();
+    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_kernel_commandline()`.
+    pub fn fixup_kernel_commandline(&self, commandline: &CStr, fixup: &mut [u8]) -> Result<()> {
+        if fixup.is_empty() {
+            return Err(Error::InvalidInput);
+        }
+
+        let mut fixup_size = fixup.len();
+        fixup[0] = 0;
         // SAFETY:
         // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
         //   established by `Protocol::new()`.
-        // * all arguments are only borrowed for the call and will not be retained.
+        // * `commandline` is a valid pointer to null-terminated string used only within the call.
+        // * `fixup` is non-null buffer available for write, used only within the call.
+        // * `fixup_size` is non-null buffer available for write, used only within the call.
         unsafe {
             efi_call!(
-                @bufsize buffer_size,
+                @bufsize fixup_size,
                 self.interface()?.fixup_kernel_commandline,
                 self.interface,
-                data.as_mut_ptr(),
-                &mut buffer_size
+                commandline.as_ptr() as _,
+                fixup.as_mut_ptr(),
+                &mut fixup_size
             )?;
         }
 
-        Ok(buffer_size)
+        Ok(())
     }
 
-    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.FixupBootconfig()`
-    pub fn fixup_bootconfig(&self, data: &mut [u8]) -> Result<usize> {
-        let mut buffer_size = data.len();
+    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.fixup_bootconfig()`.
+    pub fn fixup_bootconfig(&self, bootconfig: &[u8], fixup: &mut [u8]) -> Result<usize> {
+        if fixup.is_empty() {
+            return Err(Error::InvalidInput);
+        }
+
+        let mut fixup_size = fixup.len();
         // SAFETY:
         // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
         //   established by `Protocol::new()`.
-        // * all arguments are only borrowed for the call and will not be retained.
+        // * `bootconfig` is non-null buffer used only within the call.
+        // * `fixup` is non-null buffer available for write, used only within the call.
+        // * `fixup_size` is non-null usize buffer available for write, used only within the call.
         unsafe {
             efi_call!(
-                @bufsize buffer_size,
+                @bufsize fixup_size,
                 self.interface()?.fixup_bootconfig,
                 self.interface,
-                data.as_mut_ptr(),
-                &mut buffer_size
+                bootconfig.as_ptr(),
+                bootconfig.len(),
+                fixup.as_mut_ptr(),
+                &mut fixup_size
             )?;
         }
 
-        // TODO(b/354021403): figure out how to report EFI_BUFFER_TOO_SMALL buffer size. For now
-        // we just drop the updated `buffer_size`.
+        Ok(fixup_size)
+    }
 
-        Ok(buffer_size)
+    /// Wraps `GBL_EFI_OS_CONFIGURATION_PROTOCOL.select_device_trees()`.
+    pub fn select_device_trees(&self, components: &mut [GblEfiVerifiedDeviceTree]) -> Result<()> {
+        // SAFETY:
+        // * `self.interface()?` guarantees self.interface is non-null and points to a valid object
+        //   established by `Protocol::new()`.
+        // * `components` is non-null buffer available for write, used only within the call.
+        // * `components_len` is non-null usize buffer, used only within the call.
+        unsafe {
+            efi_call!(
+                self.interface()?.select_device_trees,
+                self.interface,
+                components.as_mut_ptr() as _,
+                components.len(),
+            )?;
+        }
+
+        Ok(())
     }
 }
 
@@ -80,18 +113,17 @@ mod test {
     use super::*;
 
     use crate::test::run_test_with_mock_protocol;
-    use efi_types::{EfiStatus, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS};
-    use liberror::Error;
-    use std::{
-        ffi::{CStr, CString},
-        slice,
+    use efi_types::{
+        EfiStatus, EFI_STATUS_BUFFER_TOO_SMALL, EFI_STATUS_INVALID_PARAMETER, EFI_STATUS_SUCCESS,
     };
+    use std::{ffi::CStr, slice};
 
     #[test]
     fn fixup_kernel_commandline_no_op() {
         // No-op C callback implementation.
         unsafe extern "C" fn c_return_success(
             _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
             _: *mut u8,
             _: *mut usize,
         ) -> EfiStatus {
@@ -104,47 +136,61 @@ mod test {
         };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut commandline = CString::new("foo=bar baz").unwrap().into_bytes_with_nul();
-            assert!(os_config_protocol.fixup_kernel_commandline(&mut commandline[..]).is_ok());
+            let mut fixup_buffer = [0x0; 128];
+            let commandline = c"foo=bar baz";
+
+            assert!(os_config_protocol
+                .fixup_kernel_commandline(commandline, &mut fixup_buffer)
+                .is_ok());
+            assert_eq!(
+                CStr::from_bytes_until_nul(&fixup_buffer[..]).unwrap().to_str().unwrap(),
+                ""
+            );
         });
     }
 
     #[test]
-    fn fixup_kernel_commandline_add_arg() {
-        // C callback implementation to add " 123" to the given command line.
-        unsafe extern "C" fn c_add_123(
+    fn fixup_kernel_commandline_provided() {
+        const EXPECTED_COMMANDLINE: &CStr = c"a=b";
+        const EXPECTED_FIXUP: &[u8] = b"hello=world\0";
+        const EXPECTED_FIXUP_STR: &str = "hello=world";
+
+        // C callback implementation to add "hello=world" to the given command line.
+        unsafe extern "C" fn c_add_hello_world(
             _: *mut GblEfiOsConfigurationProtocol,
-            data: *mut u8,
-            buffer_size: *mut usize,
+            command_line: *const u8,
+            fixup: *mut u8,
+            _: *mut usize,
         ) -> EfiStatus {
-            // SAFETY:
-            // * we pass a valid `data` buffer of length `buffer_size`
-            // * this function has exclusive access to the buffer while it's executing
-            let commandline =
-                unsafe { slice::from_raw_parts_mut(data, *buffer_size.as_ref().unwrap()) };
+            assert_eq!(
+                // SAFETY:
+                // * `command_line` is valid pointer to null terminated string.
+                unsafe { CStr::from_ptr(command_line as _) },
+                EXPECTED_COMMANDLINE
+            );
 
-            let nul_pos = commandline.iter().position(|c| *c == b'\0').unwrap();
-            commandline[nul_pos..nul_pos + 5].copy_from_slice(b" 123\0");
+            // SAFETY:
+            // * `fixup` is valid writtable buffer with enough space for test data.
+            let fixup_buffer = unsafe { slice::from_raw_parts_mut(fixup, EXPECTED_FIXUP.len()) };
+            fixup_buffer.copy_from_slice(EXPECTED_FIXUP);
 
             EFI_STATUS_SUCCESS
         }
 
         let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_kernel_commandline: Some(c_add_123),
+            fixup_kernel_commandline: Some(c_add_hello_world),
             ..Default::default()
         };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut commandline = CString::new("foo=bar baz").unwrap().into_bytes_with_nul();
-            // Add 4 extra bytes to the command line buffer so the C callback can add its data.
-            commandline.extend_from_slice(b"\0\0\0\0");
-            assert_eq!(
-                os_config_protocol.fixup_kernel_commandline(&mut commandline[..]),
-                Ok(commandline.len()),
-            );
+            let mut fixup_buffer = [0x0; 128];
+
+            assert!(os_config_protocol
+                .fixup_kernel_commandline(EXPECTED_COMMANDLINE, &mut fixup_buffer)
+                .is_ok());
             assert_eq!(
-                CStr::from_bytes_until_nul(&commandline[..]).unwrap(),
-                CString::new("foo=bar baz 123").unwrap().as_c_str()
+                CStr::from_bytes_until_nul(&fixup_buffer[..]).unwrap().to_str().unwrap(),
+                EXPECTED_FIXUP_STR,
             );
         });
     }
@@ -154,6 +200,7 @@ mod test {
         // C callback implementation to return an error.
         unsafe extern "C" fn c_error(
             _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
             _: *mut u8,
             _: *mut usize,
         ) -> EfiStatus {
@@ -166,21 +213,65 @@ mod test {
         };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut fixup_buffer = [0x0; 128];
+            let commandline = c"foo=bar baz";
+
             assert_eq!(
-                os_config_protocol.fixup_kernel_commandline(&mut []),
+                os_config_protocol.fixup_kernel_commandline(commandline, &mut fixup_buffer),
                 Err(Error::InvalidInput),
             );
         });
     }
 
+    #[test]
+    fn fixup_kernel_commandline_buffer_too_small() {
+        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
+        // C callback implementation to return an error.
+        unsafe extern "C" fn c_error(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
+            _: *mut u8,
+            fixup_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `fixup_size` is a valid pointer to writtable usize buffer.
+            unsafe {
+                *fixup_size = EXPECTED_REQUESTED_FIXUP_SIZE;
+            }
+            EFI_STATUS_BUFFER_TOO_SMALL
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            fixup_kernel_commandline: Some(c_error),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut fixup_buffer = [0x0; 128];
+            let commandline = c"foo=bar baz";
+
+            assert_eq!(
+                os_config_protocol.fixup_kernel_commandline(commandline, &mut fixup_buffer),
+                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
+            );
+        });
+    }
+
     #[test]
     fn fixup_bootconfig_no_op() {
         // No-op C callback implementation.
         unsafe extern "C" fn c_return_success(
             _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
+            _: usize,
             _: *mut u8,
-            _: *mut usize,
+            fixup_size: *mut usize,
         ) -> EfiStatus {
+            // SAFETY:
+            // * `fixup_size` is a valid pointer to writtable usize buffer.
+            unsafe {
+                *fixup_size = 0;
+            }
             EFI_STATUS_SUCCESS
         }
 
@@ -190,48 +281,62 @@ mod test {
         };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut bootconfig = CString::new("foo=bar\nbaz").unwrap().into_bytes_with_nul();
-            assert!(os_config_protocol.fixup_bootconfig(&mut bootconfig[..]).is_ok());
+            let mut fixup_buffer = [0x0; 128];
+            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
+
+            assert_eq!(
+                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
+                Ok(0)
+            );
         });
     }
 
     #[test]
-    fn fixup_fixup_bootconfig_add_arg() {
-        // C callback implementation to add "\n123" to the given bootconfig.
-        unsafe extern "C" fn c_add_123(
+    fn fixup_bootconfig_provided() {
+        // no trailer for simplicity
+        const EXPECTED_BOOTCONFIG: &[u8] = b"a=b\nc=d\n";
+        const EXPECTED_LEN: usize = 4;
+        const EXPECTED_FIXUP: &[u8] = b"e=f\n";
+
+        // C callback implementation to add "e=f" to the given bootconfig.
+        unsafe extern "C" fn c_add_ef(
             _: *mut GblEfiOsConfigurationProtocol,
-            data: *mut u8,
-            buffer_size: *mut usize,
+            bootconfig: *const u8,
+            bootconfig_size: usize,
+            fixup: *mut u8,
+            fixup_size: *mut usize,
         ) -> EfiStatus {
             // SAFETY:
-            // * we pass a valid `data` buffer of length `buffer_size`
-            // * this function has exclusive access to the buffer while it's executing
-            let bootconfig =
-                unsafe { slice::from_raw_parts_mut(data, *buffer_size.as_ref().unwrap()) };
+            // * `bootconfig` is a valid pointer to the buffer at least `bootconfig_size` size.
+            let bootconfig_buffer = unsafe { slice::from_raw_parts(bootconfig, bootconfig_size) };
 
-            let nul_pos = bootconfig.iter().position(|c| *c == b'\0').unwrap();
-            bootconfig[nul_pos..nul_pos + 5].copy_from_slice(b"\n123\0");
+            assert_eq!(bootconfig_buffer, EXPECTED_BOOTCONFIG);
+
+            // SAFETY:
+            // * `fixup` is a valid writtable buffer with enough space for test data.
+            // * `fixup_size` is a valid pointer to writtable usize buffer.
+            let fixup_buffer = unsafe {
+                *fixup_size = EXPECTED_FIXUP.len();
+                slice::from_raw_parts_mut(fixup, *fixup_size)
+            };
+            fixup_buffer.copy_from_slice(EXPECTED_FIXUP);
 
             EFI_STATUS_SUCCESS
         }
 
         let c_interface = GblEfiOsConfigurationProtocol {
-            fixup_bootconfig: Some(c_add_123),
+            fixup_bootconfig: Some(c_add_ef),
             ..Default::default()
         };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            let mut bootconfig = CString::new("foo=bar\nbaz").unwrap().into_bytes_with_nul();
-            // Add 4 extra bytes to the command line buffer so the C callback can add its data.
-            bootconfig.extend_from_slice(b"\0\0\0\0");
-            assert_eq!(
-                os_config_protocol.fixup_bootconfig(&mut bootconfig[..]),
-                Ok(bootconfig.len()),
-            );
+            let mut fixup_buffer = [0x0; 128];
+
             assert_eq!(
-                CStr::from_bytes_until_nul(&bootconfig[..]).unwrap(),
-                CString::new("foo=bar\nbaz\n123").unwrap().as_c_str()
+                os_config_protocol.fixup_bootconfig(&EXPECTED_BOOTCONFIG[..], &mut fixup_buffer),
+                Ok(EXPECTED_LEN),
             );
+            assert_eq!(&fixup_buffer[..EXPECTED_LEN], &EXPECTED_FIXUP[..],);
         });
     }
 
@@ -240,6 +345,8 @@ mod test {
         // C callback implementation to return an error.
         unsafe extern "C" fn c_error(
             _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
+            _: usize,
             _: *mut u8,
             _: *mut usize,
         ) -> EfiStatus {
@@ -250,7 +357,78 @@ mod test {
             GblEfiOsConfigurationProtocol { fixup_bootconfig: Some(c_error), ..Default::default() };
 
         run_test_with_mock_protocol(c_interface, |os_config_protocol| {
-            assert_eq!(os_config_protocol.fixup_bootconfig(&mut []), Err(Error::InvalidInput),);
+            let mut fixup_buffer = [0x0; 128];
+            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
+
+            assert_eq!(
+                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
+                Err(Error::InvalidInput)
+            );
+        });
+    }
+
+    #[test]
+    fn fixup_bootconfig_fixup_buffer_too_small() {
+        const EXPECTED_REQUESTED_FIXUP_SIZE: usize = 256;
+        // C callback implementation to return an error.
+        unsafe extern "C" fn c_error(
+            _: *mut GblEfiOsConfigurationProtocol,
+            _: *const u8,
+            _: usize,
+            _: *mut u8,
+            fixup_size: *mut usize,
+        ) -> EfiStatus {
+            // SAFETY:
+            // * `fixup_size` is a valid pointer to writtable usize buffer.
+            unsafe {
+                *fixup_size = EXPECTED_REQUESTED_FIXUP_SIZE;
+            }
+            EFI_STATUS_BUFFER_TOO_SMALL
+        }
+
+        let c_interface =
+            GblEfiOsConfigurationProtocol { fixup_bootconfig: Some(c_error), ..Default::default() };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let mut fixup_buffer = [0x0; 128];
+            let bootconfig = c"foo=bar\nbaz".to_bytes_with_nul();
+
+            assert_eq!(
+                os_config_protocol.fixup_bootconfig(&bootconfig[..], &mut fixup_buffer),
+                Err(Error::BufferTooSmall(Some(EXPECTED_REQUESTED_FIXUP_SIZE))),
+            );
+        });
+    }
+
+    #[test]
+    fn select_device_trees_selected() {
+        // C callback implementation to select first component.
+        unsafe extern "C" fn c_select_first(
+            _: *mut GblEfiOsConfigurationProtocol,
+            device_trees: *mut GblEfiVerifiedDeviceTree,
+            num: usize,
+        ) -> EfiStatus {
+            assert_eq!(num, 1);
+
+            // SAFETY:
+            // * device_trees is non-null buffer available for write.
+            unsafe {
+                (*device_trees).selected = true;
+            }
+
+            EFI_STATUS_SUCCESS
+        }
+
+        let c_interface = GblEfiOsConfigurationProtocol {
+            select_device_trees: Some(c_select_first),
+            ..Default::default()
+        };
+
+        run_test_with_mock_protocol(c_interface, |os_config_protocol| {
+            let device_trees = &mut [GblEfiVerifiedDeviceTree::default()];
+
+            assert!(os_config_protocol.select_device_trees(device_trees).is_ok());
+            assert!(device_trees[0].selected);
         });
     }
 }
diff --git a/gbl/libefi_types/BUILD b/gbl/libefi_types/BUILD
index f689b9d..e84d273 100644
--- a/gbl/libefi_types/BUILD
+++ b/gbl/libefi_types/BUILD
@@ -53,6 +53,7 @@ rust_bindgen(
         "--with-derive-partialeq",
         "--with-derive-default",
         "--with-derive-custom-struct=EfiMemoryDescriptor=AsBytes,FromBytes,FromZeroes",
+        "--with-derive-custom-struct=EfiMemoryAttributesTableHeader=AsBytes,FromBytes,FromZeroes",
         "--allowlist-type",
         "(Efi.*)|(GblEfi.*)|(GBL_EFI_.*)",
         "--allowlist-var",
diff --git a/gbl/libefi_types/defs/efi.h b/gbl/libefi_types/defs/efi.h
index a58b9b6..9d01b80 100644
--- a/gbl/libefi_types/defs/efi.h
+++ b/gbl/libefi_types/defs/efi.h
@@ -27,7 +27,9 @@
 #include "protocols/block_io2_protocol.h"
 #include "protocols/block_io_protocol.h"
 #include "protocols/device_path_protocol.h"
+#include "protocols/dt_fixup_protocol.h"
 #include "protocols/gbl_efi_ab_slot_protocol.h"
+#include "protocols/gbl_efi_avb_protocol.h"
 #include "protocols/gbl_efi_fastboot_protocol.h"
 #include "protocols/gbl_efi_fastboot_usb.h"
 #include "protocols/gbl_efi_image_loading_protocol.h"
diff --git a/gbl/libefi_types/defs/gbl_efi_common.h b/gbl/libefi_types/defs/gbl_efi_common.h
index d1a218e..a4f36fc 100644
--- a/gbl/libefi_types/defs/gbl_efi_common.h
+++ b/gbl/libefi_types/defs/gbl_efi_common.h
@@ -27,6 +27,6 @@
       .data3=0x4083,                                            \
       .data4=[0x91, 0xa1, 0xa5, 0x0f, 0x6c, 0x3d, 0x98, 0x30]   \
   }
-#define GBL_EFI_OS_BOOT_TARGET_VARNAME "gbl_os_boot_target"
+#define GBL_EFI_OS_BOOT_TARGET_VARNAME "gbl_os_boot_fuchsia"
 
 #endif  /* __GBL_EFI_COMMON_H__ */
diff --git a/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h b/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h
new file mode 100644
index 0000000..5d220b2
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/dt_fixup_protocol.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// This is a protocol proposed by U-boot and being used by Kernel UEFI stub.
+// https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL
+// https://github.com/u-boot/u-boot/blob/master/include/efi_dt_fixup.h
+
+#ifndef __EFI_DT_FIXUP_PROTOCOL_H__
+#define __EFI_DT_FIXUP_PROTOCOL_H__
+
+#include "types.h"
+
+const uint64_t EFI_DT_FIXUP_PROTOCOL_REVISION = 0x00010000;
+
+// Add nodes and update properties
+const uint32_t EFI_DT_APPLY_FIXUPS = 0x00000001;
+// Reserve memory according to the /reserved-memory node and the memory
+// reservation block
+const uint32_t EFI_DT_RESERVE_MEMORY = 0x00000002;
+// Install the device-tree as configuration table
+const uint32_t EFI_DT_INSTALL_TABLE = 0x00000004;
+const uint32_t EFI_DT_ALL =
+    EFI_DT_APPLY_FIXUPS | EFI_DT_RESERVE_MEMORY | EFI_DT_INSTALL_TABLE;
+
+typedef struct EfiDtFixupProtocol {
+  uint64_t revision;
+  EfiStatus (*fixup)(struct EfiDtFixupProtocol* self, void* fdt,
+                     size_t* buffer_size, uint32_t flags);
+} EfiDtFixupProtocol;
+
+#endif  // __EFI_DT_FIXUP_PROTOCOL_H__
\ No newline at end of file
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
index df5dde7..cbeb888 100644
--- a/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_ab_slot_protocol.h
@@ -37,18 +37,25 @@ typedef enum GBL_EFI_UNBOOTABLE_REASON {
   GBL_EFI_VERIFICATION_FAILURE,
 } GblEfiUnbootableReason;
 
+// We are currently following
+// https://cs.android.com/android/platform/superproject/main/+/main:system/core/bootstat/bootstat.cpp;l=229
+// for boot reason code.
+//
+// But we may want to revisit this since GBL mostly just cares normal,
+// bootloader, fastbootd, recovery mode.
 typedef enum GBL_EFI_BOOT_REASON {
-  GBL_EFI_EMPTY_BOOT_REASON = 0,
-  GBL_EFI_UNKNOWN_EFI_BOOT_REASON = 1,
-  GBL_EFI_WATCHDOG = 14,
-  GBL_EFI_KERNEL_PANIC = 15,
-  GBL_EFI_RECOVERY = 3,
-  GBL_EFI_BOOTLOADER = 55,
-  GBL_EFI_COLD = 56,
-  GBL_EFI_HARD = 57,
-  GBL_EFI_WARM = 58,
-  GBL_EFI_SHUTDOWN,
-  GBL_EFI_REBOOT = 18,
+  EMPTY_BOOT_REASON = 0,
+  UNKNOWN_EFI_BOOT_REASON = 1,
+  WATCHDOG = 14,
+  KERNEL_PANIC = 15,
+  RECOVERY = 3,
+  BOOTLOADER = 55,
+  COLD = 56,
+  HARD = 57,
+  WARM = 58,
+  SHUTDOWN,
+  REBOOT = 18,
+  FASTBOOTD = 196,
 } GblEfiBootReason;
 
 typedef struct {
@@ -82,11 +89,12 @@ typedef struct GblEfiABSlotProtocol {
                              GblEfiSlotInfo* /* out param */);
   EfiStatus (*get_current_slot)(struct GblEfiABSlotProtocol*,
                                 GblEfiSlotInfo* /* out param */);
+  EfiStatus (*get_next_slot)(struct GblEfiABSlotProtocol*, bool,
+                             GblEfiSlotInfo* /* out param */);
   // Slot metadata manipulation methods
   EfiStatus (*set_active_slot)(struct GblEfiABSlotProtocol*, uint8_t);
   EfiStatus (*set_slot_unbootable)(struct GblEfiABSlotProtocol*, uint8_t,
                                    uint32_t);
-  EfiStatus (*mark_boot_attempt)(struct GblEfiABSlotProtocol*);
   EfiStatus (*reinitialize)(struct GblEfiABSlotProtocol*);
   // Miscellaneous methods
   EfiStatus (*get_boot_reason)(struct GblEfiABSlotProtocol*,
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h
new file mode 100644
index 0000000..a91caae
--- /dev/null
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_avb_protocol.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This is a custom protocol introduced by GBL.
+// See gbl/docs/gbl_efi_avb_protocol.md for details.
+
+#ifndef __GBL_AVB_PROTOCOL_H__
+#define __GBL_AVB_PROTOCOL_H__
+
+#include "types.h"
+
+// Os boot state color.
+//
+// https://source.android.com/docs/security/features/verifiedboot/boot-flow#communicating-verified-boot-state-to-users
+typedef enum GBL_EFI_AVB_BOOT_STATE_COLOR {
+  GREEN,
+  YELLOW,
+  ORANGE,
+  RED_EIO,
+  RED,
+} GblEfiAvbBootStateColor;
+
+// Vbmeta key validation status.
+//
+// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
+typedef enum GBL_EFI_AVB_KEY_VALIDATION_STATUS {
+  VALID,
+  VALID_CUSTOM_KEY,
+  INVALID,
+} GblEfiAvbKeyValidationStatus;
+
+typedef struct {
+  // GblEfiAvbBootStateColor
+  uint32_t color;
+
+  // Pointer to nul-terminated ASCII hex digest calculated by libavb. May be
+  // null in case of verification failed (RED boot state color).
+  const char8_t* digest;
+
+  // Pointers to nul-terminated os versions and security_patches for different
+  // boot components. NULL is provided in case value isn't presented in the boot
+  // artifacts or fatal AVB failure.
+  // https://source.android.com/docs/core/architecture/bootloader/version-info-avb
+  const char8_t* boot_version;
+  const char8_t* boot_security_patch;
+  const char8_t* system_version;
+  const char8_t* system_security_patch;
+  const char8_t* vendor_version;
+  const char8_t* vendor_security_patch;
+} GblEfiAvbVerificationResult;
+
+typedef struct GblEfiAvbProtocol {
+  uint64_t revision;
+
+  EfiStatus (*validate_vbmeta_public_key)(
+      struct GblEfiAvbProtocol* self, const uint8_t* public_key_data,
+      size_t public_key_length, const uint8_t* public_key_metadata,
+      size_t public_key_metadata_length,
+      /* GblEfiAvbKeyValidationStatus */ uint32_t* validation_status);
+
+  EfiStatus (*read_is_device_unlocked)(struct GblEfiAvbProtocol* self,
+                                       bool* is_unlocked);
+
+  EfiStatus (*read_rollback_index)(struct GblEfiAvbProtocol* self,
+                                   size_t index_location,
+                                   uint64_t* rollback_index);
+
+  EfiStatus (*write_rollback_index)(struct GblEfiAvbProtocol* self,
+                                    size_t index_location,
+                                    uint64_t rollback_index);
+
+  EfiStatus (*read_persistent_value)(struct GblEfiAvbProtocol* self,
+                                     const char* name, uint8_t* value,
+                                     size_t* value_size);
+
+  EfiStatus (*write_persistent_value)(struct GblEfiAvbProtocol* self,
+                                      const char* name, const uint8_t* value,
+                                      size_t value_size);
+
+  EfiStatus (*handle_verification_result)(
+      struct GblEfiAvbProtocol* self,
+      const GblEfiAvbVerificationResult* result);
+
+} GblEfiAvbProtocol;
+
+#endif  //__GBL_AVB_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
index 1cf9388..280059e 100644
--- a/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_fastboot_protocol.h
@@ -25,11 +25,6 @@
 
 #define GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8 32
 
-typedef struct GblEfiFastbootArg {
-  const char8_t* str_utf8;
-  size_t len;
-} GblEfiFastbootArg;
-
 typedef struct GblEfiFastbootPolicy {
   // Indicates whether device can be unlocked
   bool can_unlock;
@@ -40,6 +35,15 @@ typedef struct GblEfiFastbootPolicy {
   bool can_ram_boot;
 } GblEfiFastbootPolicy;
 
+// Callback function pointer passed to GblEfiFastbootProtocol.get_var_all.
+//
+// context: Caller specific context.
+// args: An array of NULL-terminated strings that contains the variable name
+//       followed by additional arguments if any.
+// val: A NULL-terminated string representing the value.
+typedef void (*GetVarAllCallback)(void* context, const char* const* args,
+                                  size_t num_args, const char* val);
+
 typedef enum GBL_EFI_FASTBOOT_PARTITION_PERMISSION_FLAGS {
   // Firmware can read the given partition and send its data to fastboot client.
   GBL_EFI_FASTBOOT_PARTITION_READ = 0x1 << 0,
@@ -56,8 +60,6 @@ typedef enum GBL_EFI_FASTBOOT_LOCK_FLAGS {
   GBL_EFI_FASTBOOT_GBL_EFI_CRITICAL_LOCKED = 0x1 << 1,
 } GblEfiFastbootLockFlags;
 
-typedef void const* GblEfiFastbootToken;
-
 typedef struct GblEfiFastbootProtocol {
   // Revision of the protocol supported.
   uint32_t version;
@@ -65,14 +67,11 @@ typedef struct GblEfiFastbootProtocol {
   char8_t serial_number[GBL_EFI_FASTBOOT_SERIAL_NUMBER_MAX_LEN_UTF8];
 
   // Fastboot variable methods
-  EfiStatus (*get_var)(struct GblEfiFastbootProtocol* this,
-                       const GblEfiFastbootArg* args, size_t num_args,
-                       char8_t* buf, size_t* bufsize, GblEfiFastbootToken hint);
-  EfiStatus (*start_var_iterator)(struct GblEfiFastbootProtocol* this,
-                                  GblEfiFastbootToken* token);
-  EfiStatus (*get_next_var_args)(struct GblEfiFastbootProtocol* this,
-                                 GblEfiFastbootArg* args, size_t* num_args,
-                                 GblEfiFastbootToken* token);
+  EfiStatus (*get_var)(struct GblEfiFastbootProtocol* self,
+                       const char* const* args, size_t num_args, uint8_t* out,
+                       size_t* out_size);
+  EfiStatus (*get_var_all)(struct GblEfiFastbootProtocol* self, void* ctx,
+                           GetVarAllCallback cb);
 
   // Fastboot oem function methods
   EfiStatus (*run_oem_function)(struct GblEfiFastbootProtocol* this,
diff --git a/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h b/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
index c734311..be4e957 100644
--- a/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
+++ b/gbl/libefi_types/defs/protocols/gbl_efi_os_configuration_protocol.h
@@ -23,14 +23,56 @@
 
 #include "types.h"
 
+typedef enum GBL_EFI_DEVICE_TREE_SOURCE {
+  BOOT,
+  VENDOR_BOOT,
+  DTBO,
+  DTB
+} GblEfiDeviceTreeSource;
+
+typedef struct {
+  // GblDeviceTreeSource
+  uint32_t source;
+  // Values are zeroed and must not be used in case of BOOT / VENDOR_BOOT source
+  uint32_t id;
+  uint32_t rev;
+  uint32_t custom[4];
+  // Make sure GblDeviceTreeMetadata size is 8-bytes aligned. Also reserved for
+  // the future cases
+  uint32_t reserved;
+} GblEfiDeviceTreeMetadata;
+
+typedef struct {
+  GblEfiDeviceTreeMetadata metadata;
+  // Base device tree / overlay buffer (guaranteed to be 8-bytes aligned),
+  // cannot be NULL. Device tree size can be identified by the header totalsize
+  // field
+  const void* device_tree;
+  // Indicates whether this device tree (or overlay) must be included in the
+  // final device tree. Set to true by a FW if this component must be used
+  bool selected;
+} GblEfiVerifiedDeviceTree;
+
+// Warning: API is UNSTABLE
+// Documentation:
+// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
 typedef struct GblEfiOsConfigurationProtocol {
   uint64_t revision;
+
+  // Generates fixups for the kernel command line built by GBL.
   EfiStatus (*fixup_kernel_commandline)(
-      struct GblEfiOsConfigurationProtocol* self, char8_t* data,
-      size_t* buffer_size);
+      struct GblEfiOsConfigurationProtocol* self, const char8_t* command_line,
+      char8_t* fixup, size_t* fixup_buffer_size);
+
+  // Generates fixups for the bootconfig built by GBL.
   EfiStatus (*fixup_bootconfig)(struct GblEfiOsConfigurationProtocol* self,
-                                char8_t* data, size_t* buffer_size);
-  // TODO(b/353272981): remaining fields.
+                                const char8_t* bootconfig, size_t size,
+                                char8_t* fixup, size_t* fixup_buffer_size);
+
+  // Selects which device trees and overlays to use from those loaded by GBL.
+  EfiStatus (*select_device_trees)(struct GblEfiOsConfigurationProtocol* self,
+                                   GblEfiVerifiedDeviceTree* device_trees,
+                                   size_t num_device_trees);
 } GblEfiOsConfigurationProtocol;
 
 #endif  //__GBL_OS_CONFIGURATION_PROTOCOL_H__
diff --git a/gbl/libefi_types/defs/types.h b/gbl/libefi_types/defs/types.h
index 41308f2..29758c9 100644
--- a/gbl/libefi_types/defs/types.h
+++ b/gbl/libefi_types/defs/types.h
@@ -40,6 +40,24 @@ typedef struct EfiGuid {
   uint8_t data4[8];
 } EfiGuid;
 
+typedef struct EfiMemoryAttributesTableHeader {
+  uint32_t version;
+  uint32_t number_of_entries;
+  uint32_t descriptor_size;
+  uint32_t reserved;
+} EfiMemoryAttributesTableHeader;
+
+typedef enum EFI_MEMORY_ATTRIBUTE : uint64_t {
+  EMA_UC = 0x0000000000000001, /* uncached */
+  EMA_WC = 0x0000000000000002, /* write-coalescing */
+  EMA_WT = 0x0000000000000004, /* write-through */
+  EMA_WB = 0x0000000000000008, /* write-back */
+  EMA_WP = 0x0000000000001000, /* write-protect */
+  EMA_RP = 0x0000000000002000, /* read-protect */
+  EMA_XP = 0x0000000000004000, /* execute-protect */
+  EMA_RUNTIME = 0x8000000000000000,
+} EfiMemoryAttribute;
+
 typedef struct EfiMemoryDescriptor {
   uint32_t memory_type;
   uint32_t padding;
@@ -78,7 +96,7 @@ typedef struct EfiCapsuleHeader {
 
 typedef void (*EfiEventNotify)(EfiEvent event, void* ctx);
 
-typedef enum EFI_EVENT_TYPE: uint32_t {
+typedef enum EFI_EVENT_TYPE : uint32_t {
   TIMER = 0x80000000,
   RUNTIME = 0x40000000,
   NOTIFY_WAIT = 0x00000100,
@@ -87,14 +105,18 @@ typedef enum EFI_EVENT_TYPE: uint32_t {
   SIGNAL_VIRTUAL_ADDRESS_CHANGE = 0x60000202,
 } EfiEventType;
 
-typedef enum EFI_TPL: size_t {
+typedef enum EFI_TPL : size_t {
   APPLICATION = 4,
   CALLBACK = 8,
   NOTIFY = 16,
   HIGH_LEVEL = 31,
 } EfiTpl;
 
-typedef enum EFI_TIMER_DELAY { TIMER_CANCEL, TIMER_PERIODIC, TIMER_RELATIVE } EfiTimerDelay;
+typedef enum EFI_TIMER_DELAY {
+  TIMER_CANCEL,
+  TIMER_PERIODIC,
+  TIMER_RELATIVE
+} EfiTimerDelay;
 
 typedef enum {
   RESERVED_MEMORY_TYPE,
diff --git a/gbl/liberror/src/lib.rs b/gbl/liberror/src/lib.rs
index 32e1a8e..542d3a8 100644
--- a/gbl/liberror/src/lib.rs
+++ b/gbl/liberror/src/lib.rs
@@ -34,11 +34,100 @@
 
 #![cfg_attr(not(any(test, android_dylib)), no_std)]
 
-use core::ffi::{FromBytesUntilNulError, FromBytesWithNulError};
-use core::str::Utf8Error;
+use core::{
+    ffi::{FromBytesUntilNulError, FromBytesWithNulError},
+    str::Utf8Error,
+};
 
 use efi_types as efi;
 
+/// Gpt related errors.
+#[derive(Copy, Clone, Debug, PartialEq, Eq)]
+pub enum GptError {
+    /// Secondary header is valid, but different from primary.
+    DifferentFromPrimary,
+    /// Disk size is not enough to accommodate maximum allowed entries.
+    DiskTooSmall,
+    /// GPT entries buffer is too small for the expected number of entries.
+    EntriesTruncated,
+    /// GPT header CRC is not correct.
+    IncorrectHeaderCrc,
+    /// GPT header MAGIC is not correct.
+    IncorrectMagic(u64),
+    /// GPT entries CRC doesn't match.
+    IncorrectEntriesCrc,
+    /// Invalid first and last usable block in the GPT header.
+    InvalidFirstLastUsableBlock {
+        /// The value of first usable block in the GPT header.
+        first: u64,
+        /// The value of last usable block in the GPT header.
+        last: u64,
+        /// Expected range inclusive.
+        range: (u64, u64),
+    },
+    /// Partition range is invalid.
+    InvalidPartitionRange {
+        /// Partition index (1-based).
+        idx: usize,
+        /// Range of the partition, inclusive.
+        part_range: (u64, u64),
+        /// Range of usable block, inclusive.
+        usable_range: (u64, u64),
+    },
+    /// Invalid start block for primary GPT entries.
+    InvalidPrimaryEntriesStart {
+        /// The entry start block value.
+        value: u64,
+        /// Expected range.
+        expect_range: (u64, u64),
+    },
+    /// Invalid start block for secondary GPT entries.
+    InvalidSecondaryEntriesStart {
+        /// The entry start block value.
+        value: u64,
+        /// Expected range.
+        expect_range: (u64, u64),
+    },
+    /// Number of entries greater than maximum allowed.
+    NumberOfEntriesOverflow {
+        /// Actual number of entries,
+        entries: u32,
+        /// Maximum allowed.
+        max_allowed: usize,
+    },
+    /// Two partitions overlap.
+    PartitionRangeOverlap {
+        /// Previous partition in overlap. (partition index, first, last)
+        prev: (usize, u64, u64),
+        /// Next partition in overlap. (partition index, first, last)
+        next: (usize, u64, u64),
+    },
+    /// Unexpected GPT header size.
+    UnexpectedEntrySize {
+        /// The actual entry size in the GPT header.
+        actual: u32,
+        /// The expected size.
+        expect: usize,
+    },
+    /// Unexpected GPT header size.
+    UnexpectedHeaderSize {
+        /// The actual header size in the GPT header.
+        actual: u32,
+        /// The expected size.
+        expect: usize,
+    },
+    /// Zero partition type GUID.
+    ZeroPartitionTypeGUID {
+        /// Partition index (1-based).
+        idx: usize,
+    },
+    /// Zero partition unique GUID.
+    ZeroPartitionUniqueGUID {
+        /// Partition index (1-based).
+        idx: usize,
+    },
+}
+
 /// Common, universal error type
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum Error {
@@ -83,6 +172,8 @@ pub enum Error {
     EndOfMedia,
     /// A polled operation has finished
     Finished,
+    /// GPT related errors.
+    GptError(GptError),
     /// A HTTP error occurred during a network operation.
     HttpError,
     /// An ICMP error occurred during a network operation.
diff --git a/gbl/libfastboot/src/lib.rs b/gbl/libfastboot/src/lib.rs
index 0dd4988..b1e94c8 100644
--- a/gbl/libfastboot/src/lib.rs
+++ b/gbl/libfastboot/src/lib.rs
@@ -69,6 +69,7 @@
 
 use core::{
     cmp::min,
+    ffi::CStr,
     fmt::{Debug, Display, Formatter, Write},
     str::{from_utf8, Split},
 };
@@ -201,6 +202,19 @@ impl<T: Display> From<T> for CommandError {
 /// Type alias for Result that wraps a CommandError
 pub type CommandResult<T> = core::result::Result<T, CommandError>;
 
+/// Fastboot reboot mode
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub enum RebootMode {
+    /// "fastboot reboot". Normal reboot.
+    Normal,
+    /// "fastboot reboot-bootloader". Reboot to bootloader.
+    Bootloader,
+    /// "fastboot reboot-fastboot". Reboot to userspace fastboot.
+    Fastboot,
+    /// "fastboot reboot-recovery". Reboot to recovery.
+    Recovery,
+}
+
 /// Implementation for Fastboot command backends.
 pub trait FastbootImplementation {
     /// Backend for `fastboot getvar ...`
@@ -215,26 +229,26 @@ pub trait FastbootImplementation {
     /// * `var`: Name of the variable.
     /// * `args`: Additional arguments.
     /// * `out`: Output buffer for storing the variable value.
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
+    /// * `responder`: An instance of `InfoSender`.
     ///
     /// TODO(b/322540167): Figure out other reserved variables.
     async fn get_var(
         &mut self,
-        var: &str,
-        args: Split<char>,
+        var: &CStr,
+        args: impl Iterator<Item = &'_ CStr> + Clone,
         out: &mut [u8],
-        utils: &mut impl FastbootUtils,
+        responder: impl InfoSender,
     ) -> CommandResult<usize>;
 
     /// A helper API for getting the value of a fastboot variable and decoding it into string.
     async fn get_var_as_str<'s>(
         &mut self,
-        var: &str,
-        args: Split<'_, char>,
+        var: &CStr,
+        args: impl Iterator<Item = &'_ CStr> + Clone,
+        responder: impl InfoSender,
         out: &'s mut [u8],
-        utils: &mut impl FastbootUtils,
     ) -> CommandResult<&'s str> {
-        let size = self.get_var(var, args, out, utils).await?;
+        let size = self.get_var(var, args, out, responder).await?;
         Ok(from_utf8(out.get(..size).ok_or("Invalid variable size")?)
             .map_err(|_| "Value is not string")?)
     }
@@ -246,16 +260,16 @@ pub trait FastbootImplementation {
     ///
     /// # Args
     ///
-    /// * `sender`: An implementation VarSender. Implementation should call `VarSender::send` for
-    ///   all combinations of Fastboot variable/argument/value that needs to be included in the
-    ///   response to `fastboot getvarl all`:
+    /// * `responder`: An implementation VarInfoSender. Implementation should call
+    ///   `VarInfoSender::send` for all combinations of Fastboot variable/argument/value that needs
+    ///   to be included in the response to `fastboot getvarl all`:
     ///
-    ///   async fn get_var_all(&mut self, f: F, utils: &mut impl FastbootUtils)
+    ///   async fn get_var_all(&mut self, f: F, resp: impl VarInfoSender)
     ///     -> CommandResult<()> {
-    ///       sender.send("partition-size", &["boot_a"], /* size of boot_a */).await?;
-    ///       sender.send("partition-size", &["boot_b"], /* size of boot_b */).await?;
-    ///       sender.send("partition-size", &["init_boot_a"], /* size of init_boot_a */).await?;
-    ///       sender.send("partition-size", &["init_boot_b"], /* size of init_boot_b */).await?;
+    ///       resp.send("partition-size", &["boot_a"], /* size of boot_a */).await?;
+    ///       resp.send("partition-size", &["boot_b"], /* size of boot_b */).await?;
+    ///       resp.send("partition-size", &["init_boot_a"], /* size of init_boot_a */).await?;
+    ///       resp.send("partition-size", &["init_boot_b"], /* size of init_boot_b */).await?;
     ///       Ok(())
     ///   }
     ///
@@ -268,61 +282,62 @@ pub trait FastbootImplementation {
     ///   (bootloader) partition-size:init_boot_b: <size of init_boot_b>
     ///   ...
     ///
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    ///
     /// TODO(b/322540167): This and `get_var()` contain duplicated logic. Investigate if there can
     /// be better solutions for doing the combination traversal.
-    async fn get_var_all(
-        &mut self,
-        sender: &mut impl VarSender,
-        utils: &mut impl FastbootUtils,
-    ) -> CommandResult<()>;
+    async fn get_var_all(&mut self, responder: impl VarInfoSender) -> CommandResult<()>;
 
     /// Backend for getting download buffer
     async fn get_download_buffer(&mut self) -> &mut [u8];
 
-    /// Notifies that a download is completed.
-    async fn download_complete(&mut self, download_size: usize) -> CommandResult<()>;
+    /// Called when a download is completed.
+    async fn download_complete(
+        &mut self,
+        download_size: usize,
+        responder: impl InfoSender,
+    ) -> CommandResult<()>;
 
     /// Backend for `fastboot flash ...`
     ///
     /// # Args
     ///
     /// * `part`: Name of the partition.
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    async fn flash(&mut self, part: &str, utils: &mut impl FastbootUtils) -> CommandResult<()>;
+    /// * `responder`: An instance of `InfoSender`.
+    async fn flash(&mut self, part: &str, responder: impl InfoSender) -> CommandResult<()>;
+
+    /// Backend for `fastboot erase ...`
+    ///
+    /// # Args
+    ///
+    /// * `part`: Name of the partition.
+    /// * `responder`: An instance of `InfoSender`.
+    async fn erase(&mut self, part: &str, responder: impl InfoSender) -> CommandResult<()>;
 
     /// Backend for `fastboot get_staged ...`
     ///
     /// # Args
     ///
-    /// * `upload_builder`: An instance of `UploadBuilder` for initiating and uploading data. For
-    ///   example:
+    /// * `responder`: An instance of `UploadBuilder + InfoSender` for initiating and uploading
+    ///   data. For example:
     ///
     ///   ```
     ///   async fn upload(
     ///       &mut self,
-    ///       upload_builder: UploadBuilder,
-    ///       utils: &mut impl FastbootUtils,
+    ///       responder: impl UploadBuilder + InfoSender,
     ///   ) -> CommandResult<()> {
+    ///       let data = ..;
     ///       // Sends a total of 1024 bytes data.
-    ///       let mut uploader = upload_builder.start(1024).await?;
+    ///       responder.send_info("About to upload...").await?;
+    ///       let mut uploader = responder.initiate_upload(1024).await?;
     ///       // Can upload in multiple batches.
-    ///       uploader.upload(&utils.download_buffer[..512]).await?;
-    ///       uploader.upload(&utils.download_buffer[512..]).await?;
+    ///       uploader.upload(&data[..512]).await?;
+    ///       uploader.upload(&data[512..]).await?;
     ///       Ok(())
     ///   }
     ///   ```
     ///
     ///   If implementation fails to upload enough, or attempts to upload more than expected data
     ///   with `Uploader::upload()`, an error will be returned.
-    ///
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    async fn upload(
-        &mut self,
-        upload_builder: impl UploadBuilder,
-        utils: &mut impl FastbootUtils,
-    ) -> CommandResult<()>;
+    async fn upload(&mut self, responder: impl UploadBuilder + InfoSender) -> CommandResult<()>;
 
     /// Backend for `fastboot fetch ...`
     ///
@@ -331,24 +346,68 @@ pub trait FastbootImplementation {
     /// * `part`: The partition name.
     /// * `offset`: The offset into the partition for upload.
     /// * `size`: The number of bytes to upload.
-    /// * `upload_builder`: An instance of `UploadBuilder` for initiating and uploading data.
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
+    /// * `responder`: An instance of `UploadBuilder + InfoSender` for initiating and uploading data.
     async fn fetch(
         &mut self,
         part: &str,
         offset: u64,
         size: u64,
-        upload_builder: impl UploadBuilder,
-        utils: &mut impl FastbootUtils,
+        responder: impl UploadBuilder + InfoSender,
     ) -> CommandResult<()>;
 
+    /// Backend for `fastboot reboot/reboot-bootloader/reboot-fastboot/reboot-recovery`
+    ///
+    /// # Args
+    ///
+    /// * `mode`: An `RebootMode` specifying the reboot mode.
+    /// * `responder`: An instance of `InfoSender + OkaySender`. Implementation should call
+    ///   `responder.send_okay("")` right before reboot to notify the remote host that the
+    ///   operation is successful.
+    ///
+    /// # Returns
+    ///
+    /// * The method is not expected to return if reboot is successful.
+    /// * Returns `Err(e)` on error.
+    async fn reboot(
+        &mut self,
+        mode: RebootMode,
+        responder: impl InfoSender + OkaySender,
+    ) -> CommandError;
+
+    /// Method for handling `fastboot continue` clean up.
+    ///
+    /// `run()` and `run_tcp_session()` exit after receiving `fastboot continue.` The method is for
+    /// implementation to perform necessary clean up.
+    ///
+    /// # Args
+    ///
+    /// * `responder`: An instance of `InfoSender`.
+    async fn r#continue(&mut self, responder: impl InfoSender) -> CommandResult<()>;
+
+    /// Backend for `fastboot set_active`.
+    async fn set_active(&mut self, slot: &str, responder: impl InfoSender) -> CommandResult<()>;
+
+    /// Backend for `fastboot boot`
+    ///
+    /// # Args
+    ///
+    /// * `responder`: An instance of `InfoSender + OkaySender`. Implementation should call
+    ///   `responder.send_okay("")` right before boot to notify the remote host that the
+    ///   operation is successful.
+    ///
+    /// # Returns
+    ///
+    /// * The method is always return OK to let fastboot continue.
+    /// * Returns `Err(e)` on error.
+    async fn boot(&mut self, responder: impl InfoSender + OkaySender) -> CommandResult<()>;
+
     /// Backend for `fastboot oem ...`.
     ///
     /// # Args
     ///
     /// * `cmd`: The OEM command string that comes after "oem ".
-    /// * `utils`: A mutable reference to an instance of `FastbootUtils`.
-    /// * `res`: The response buffer. Upon success, implementation can use the buffer to
+    /// * `responder`: An instance of `InfoSender`.
+    /// * `res`: The responder buffer. Upon success, implementation can use the buffer to
     ///   construct a valid UTF8 string which will be sent as "OKAY<string>"
     ///
     /// # Returns
@@ -357,7 +416,7 @@ pub trait FastbootImplementation {
     async fn oem<'a>(
         &mut self,
         cmd: &str,
-        utils: &mut impl FastbootUtils,
+        responder: impl InfoSender,
         res: &'a mut [u8],
     ) -> CommandResult<&'a [u8]>;
 
@@ -379,139 +438,199 @@ macro_rules! fastboot_msg {
 
 /// An internal convenient macro that constructs a formatted fastboot OKAY message.
 macro_rules! fastboot_okay {
-    ( $arr:expr, $( $x:expr ),* ) => { fastboot_msg!($arr, "OKAY", $($x,)*) };
+    ( $arr:expr, $( $x:expr ),* $(,)?) => { fastboot_msg!($arr, "OKAY", $($x,)*) };
 }
 
 /// An internal convenient macro that constructs a formatted fastboot FAIL message.
 macro_rules! fastboot_fail {
-    ( $arr:expr, $( $x:expr ),* ) => { fastboot_msg!($arr, "FAIL", $($x,)*) };
-}
-
-/// An internal convenient macro that constructs a formatted fastboot INFO message.
-macro_rules! fastboot_info {
-    ( $arr:expr, $( $x:expr ),* ) => { fastboot_msg!($arr, "INFO", $($x,)*) };
+    ( $arr:expr, $( $x:expr ),* $(,)?) => { fastboot_msg!($arr, "FAIL", $($x,)*) };
 }
 
-/// `VarSender` provides interfaces for sending variable/args/value combination during the
+/// `VarInfoSender` provide an interface for sending variable/args/value combination during the
 /// processing of `fastboot getvar all`
-pub trait VarSender {
+pub trait VarInfoSender {
     /// Send a combination of variable name, arguments and value.
     ///
-    /// In actual fastboot context, the method should send an "INFO<var>:<args>:<val>" message to
-    /// the host.
-    async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()>;
+    /// The method sends a fastboot message "INFO<var>:<args>:<val>" to the host.
+    ///
+    /// # Args
+    ///
+    /// * `name`: Name of the fastboot variable.
+    /// * `args`: An iterator to additional arguments.
+    /// * `val`: Value of the variable.
+    async fn send_var_info(
+        &mut self,
+        name: &str,
+        args: impl IntoIterator<Item = &'_ str>,
+        val: &str,
+    ) -> Result<()>;
 }
 
-/// `FbVarSender` wraps a fastboot transport and implements `VarSender`
-struct FbVarSender<'a, T: Transport> {
-    transport: &'a mut T,
-    transport_error: &'a mut Result<()>,
+/// Provides an API for sending fastboot INFO messages.
+pub trait InfoSender {
+    /// Sends formatted INFO message.
+    ///
+    /// # Args:
+    ///
+    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
+    async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(&mut self, cb: F) -> Result<()>;
+
+    /// Sends a Fastboot "INFO<`msg`>" packet.
+    async fn send_info(&mut self, msg: &str) -> Result<()> {
+        self.send_formatted_info(|w| write!(w, "{}", msg).unwrap()).await
+    }
 }
 
-impl<'a, T: Transport> VarSender for FbVarSender<'a, T> {
-    async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()> {
-        // Sends a "INFO<var>:<':'-separated args>:<val>" packet to the host.
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        let mut formatted_bytes = FormattedBytes::new(&mut res);
-        write!(formatted_bytes, "INFO{}", name).unwrap();
-        args.iter().for_each(|arg| write!(formatted_bytes, ":{}", arg).unwrap());
-        write!(formatted_bytes, ": {}", val).unwrap();
-        let size = formatted_bytes.size();
-        *self.transport_error = self.transport.send_packet(&res[..size]).await;
-        Ok((*self.transport_error)?)
+/// Provides an API for sending fastboot OKAY messages.
+pub trait OkaySender {
+    /// Sends formatted Okay message.
+    ///
+    /// # Args:
+    ///
+    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
+    async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, cb: F) -> Result<()>;
+
+    /// Sends a fastboot OKAY<msg> packet. `Self` is consumed.
+    async fn send_okay(self, msg: &str) -> Result<()>
+    where
+        Self: Sized,
+    {
+        self.send_formatted_okay(|w| write!(w, "{}", msg).unwrap()).await
     }
 }
 
-/// `FastbootUtil` provides utilities APIs for getting the current downloaded data size and sending
-/// fastboot INFO messages.
-pub trait FastbootUtils {
-    /// Sends a Fastboot "INFO<`msg`>" packet.
-    async fn send_info(&mut self, msg: &str) -> CommandResult<()>;
+/// `UploadBuilder` provides API for initiating a fastboot upload.
+pub trait UploadBuilder {
+    /// Starts the upload.
+    ///
+    /// In a real fastboot context, the method should send `DATA0xXXXXXXXX` to the remote host to
+    /// start the download. An `Uploader` implementation should be returned for uploading payload.
+    async fn initiate_upload(self, data_size: u64) -> Result<impl Uploader>;
+}
 
-    /// Returns transport errors if there are any.
-    fn transport_error(&self) -> Result<()>;
+/// `UploadBuilder` provides API for uploading payload.
+pub trait Uploader {
+    /// Uploads data to the Fastboot host.
+    async fn upload(&mut self, data: &[u8]) -> Result<()>;
 }
 
-/// `FastbootUtilData` implements the FastbootUtil trait for user backend to use.
-struct FastbootUtilData<'a, T: Transport> {
+/// `Responder` implements APIs for fastboot backend to send fastboot messages and uploading data.
+struct Responder<'a, T: Transport> {
+    buffer: [u8; MAX_RESPONSE_SIZE],
     transport: &'a mut T,
     transport_error: Result<()>,
+    remaining_upload: u64,
 }
 
-impl<'a, T: Transport> FastbootUtilData<'a, T> {
+impl<'a, T: Transport> Responder<'a, T> {
     fn new(transport: &'a mut T) -> Self {
-        Self { transport, transport_error: Ok(()) }
+        Self {
+            buffer: [0u8; MAX_RESPONSE_SIZE],
+            transport,
+            transport_error: Ok(()),
+            remaining_upload: 0,
+        }
     }
-}
 
-impl<T: Transport> FastbootUtils for FastbootUtilData<'_, T> {
-    async fn send_info(&mut self, msg: &str) -> CommandResult<()> {
+    /// A helper for sending a fastboot message in the buffer.
+    async fn send_buffer(&mut self, size: usize) -> Result<()> {
         self.transport_error?;
-        let mut res = [0u8; MAX_RESPONSE_SIZE];
-        self.transport_error = self.transport.send_packet(fastboot_info!(res, "{}", msg)).await;
+        assert!(size < self.buffer.len());
+        self.transport_error = self.transport.send_packet(&self.buffer[..size]).await;
         Ok(self.transport_error?)
     }
 
-    /// Returns the `Self:;transport_error`.
-    fn transport_error(&self) -> Result<()> {
-        self.transport_error
+    /// Helper for sending a formatted fastboot message.
+    ///
+    /// # Args:
+    ///
+    /// * `cb`: A closure provided by the caller for constructing the formatted messagae.
+    async fn send_formatted_msg<F: FnOnce(&mut dyn Write)>(
+        &mut self,
+        msg_type: &str,
+        cb: F,
+    ) -> Result<()> {
+        let mut formatted_bytes = FormattedBytes::new(&mut self.buffer);
+        write!(formatted_bytes, "{}", msg_type).unwrap();
+        cb(&mut formatted_bytes);
+        let size = formatted_bytes.size();
+        self.send_buffer(size).await
     }
-}
 
-/// A noop Transport to pass to `FastbootUtilData` when info send is not allowed.
-struct NoopTransport {}
-
-impl Transport for NoopTransport {
-    async fn receive_packet(&mut self, _: &mut [u8]) -> Result<usize> {
-        Ok(0)
+    /// Sends a fastboot DATA message.
+    async fn send_data_message(&mut self, data_size: u64) -> Result<()> {
+        self.send_formatted_msg("DATA", |v| write!(v, "{:08x}", data_size).unwrap()).await
     }
+}
 
-    async fn send_packet(&mut self, _: &[u8]) -> Result<()> {
-        Ok(())
+impl<'a, T: Transport> VarInfoSender for &mut Responder<'a, T> {
+    async fn send_var_info(
+        &mut self,
+        name: &str,
+        args: impl IntoIterator<Item = &'_ str>,
+        val: &str,
+    ) -> Result<()> {
+        // Sends a "INFO<var>:<':'-separated args>:<val>" packet to the host.
+        Ok(self
+            .send_formatted_msg("INFO", |v| {
+                write!(v, "{}", name).unwrap();
+                args.into_iter().for_each(|arg| write!(v, ":{}", arg).unwrap());
+                write!(v, ": {}", val).unwrap();
+            })
+            .await?)
     }
 }
 
-/// `UploadBuilder` provides API for initiating a fastboot upload.
-pub trait UploadBuilder {
-    /// Starts the upload.
-    ///
-    /// In a real fastboot context, the method should send `DATA0xXXXXXXXX` to the remote host to
-    /// start the download. An `Uploader` implementation should be returned for uploading payload.
-    async fn start(self, data_size: u64) -> CommandResult<impl Uploader>;
+/// An internal convenient macro that sends a formatted fastboot OKAY message via a `Responder`
+macro_rules! reply_okay {
+    ( $resp:expr, $( $x:expr ),* $(,)?) => {
+        {
+            let len = fastboot_okay!($resp.buffer, $($x,)*).len();
+            $resp.send_buffer(len).await
+        }
+    };
 }
 
-/// `UploadBuilder` provides API for uploading payload.
-pub trait Uploader {
-    /// Uploads data to the Fastboot host.
-    async fn upload(&mut self, data: &[u8]) -> CommandResult<()>;
+/// An internal convenient macro that sends a formatted fastboot FAIL message via a `Responder`
+macro_rules! reply_fail {
+    ( $resp:expr, $( $x:expr ),* $(,)?) => {
+        {
+            let len = fastboot_fail!($resp.buffer, $($x,)*).len();
+            $resp.send_buffer(len).await
+        }
+    };
 }
 
-/// `FbUploadBuilder` implements the `UploadBuilder`/`Uploader` traits for uploading user payload.
-struct FbUploadBuilder<'a, T: Transport> {
-    transport: &'a mut T,
-    error: &'a mut Result<()>,
-    remaining: &'a mut u64,
+impl<T: Transport> InfoSender for &mut Responder<'_, T> {
+    async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(&mut self, cb: F) -> Result<()> {
+        Ok(self.send_formatted_msg("INFO", cb).await?)
+    }
+}
+
+impl<T: Transport> OkaySender for &mut Responder<'_, T> {
+    async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, cb: F) -> Result<()> {
+        Ok(self.send_formatted_msg("OKAY", cb).await?)
+    }
 }
 
-impl<'a, T: Transport> UploadBuilder for FbUploadBuilder<'a, T> {
-    async fn start(self, data_size: u64) -> CommandResult<impl Uploader> {
-        let mut res = [0u8; 16];
-        self.transport.send_packet(snprintf!(res, "DATA{:08x}", data_size).as_bytes()).await?;
-        *self.remaining = data_size;
+impl<'a, T: Transport> UploadBuilder for &mut Responder<'a, T> {
+    async fn initiate_upload(self, data_size: u64) -> Result<impl Uploader> {
+        self.send_data_message(data_size).await?;
+        self.remaining_upload = data_size;
         Ok(self)
     }
 }
 
-impl<'a, T: Transport> Uploader for FbUploadBuilder<'a, T> {
+impl<'a, T: Transport> Uploader for &mut Responder<'a, T> {
     /// Uploads data. Returns error if accumulative amount exceeds `data_size` passed to
     /// `UploadBuilder::start()`.
-    async fn upload(&mut self, data: &[u8]) -> CommandResult<()> {
-        (*self.error)?;
-        *self.remaining = self
-            .remaining
+    async fn upload(&mut self, data: &[u8]) -> Result<()> {
+        self.transport_error?;
+        self.remaining_upload = self
+            .remaining_upload
             .checked_sub(data.len().try_into().map_err(|_| "")?)
-            .ok_or::<CommandError>("".into())?;
-        *self.error = self.transport.send_packet(data).await;
+            .ok_or(Error::Other(Some("Invalid size of upload data")))?;
+        self.transport_error = self.transport.send_packet(data).await;
         Ok(())
     }
 }
@@ -519,7 +638,9 @@ impl<'a, T: Transport> Uploader for FbUploadBuilder<'a, T> {
 pub mod test_utils {
     //! Test utilities to help users of this library write unit tests.
 
-    use crate::{CommandResult, UploadBuilder, Uploader};
+    use crate::{InfoSender, UploadBuilder, Uploader};
+    use core::fmt::Write;
+    use liberror::Error;
 
     /// A test implementation of `UploadBuilder` for unittesting
     /// `FastbootImplementation::upload()`.
@@ -528,16 +649,26 @@ pub mod test_utils {
     pub struct TestUploadBuilder<'a>(pub &'a mut [u8]);
 
     impl<'a> UploadBuilder for TestUploadBuilder<'a> {
-        async fn start(self, _: u64) -> CommandResult<impl Uploader> {
+        async fn initiate_upload(self, _: u64) -> Result<impl Uploader, Error> {
             Ok(TestUploader(0, self.0))
         }
     }
 
+    impl<'a> InfoSender for TestUploadBuilder<'a> {
+        async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(
+            &mut self,
+            _: F,
+        ) -> Result<(), Error> {
+            // Not needed currently.
+            Ok(())
+        }
+    }
+
     // (Bytes sent, upload buffer)
     struct TestUploader<'a>(usize, &'a mut [u8]);
 
     impl Uploader for TestUploader<'_> {
-        async fn upload(&mut self, data: &[u8]) -> CommandResult<()> {
+        async fn upload(&mut self, data: &[u8]) -> Result<(), Error> {
             self.1[self.0..][..data.len()].clone_from_slice(data);
             self.0 = self.0.checked_add(data.len()).unwrap();
             Ok(())
@@ -547,40 +678,37 @@ pub mod test_utils {
 
 const MAX_DOWNLOAD_SIZE_NAME: &'static str = "max-download-size";
 
-/// A helper for getting the string version of a fastboot variable value.
-async fn get_var_str<'s>(
-    var: &str,
-    args: Split<'_, char>,
-    out: &'s mut [u8],
-    transport: &mut impl Transport,
-    fb_impl: &mut impl FastbootImplementation,
-) -> CommandResult<&'s str> {
-    let mut utils = FastbootUtilData::new(transport);
-    fb_impl.get_var_as_str(var, args, out, &mut utils).await
+/// Converts a null-terminated command line string where arguments are separated by ':' into an
+/// iterator of individual argument as CStr.
+fn cmd_to_c_string_args(cmd: &mut [u8]) -> impl Iterator<Item = &CStr> + Clone {
+    let end = cmd.iter().position(|v| *v == 0).unwrap();
+    // Replace ':' with NULL.
+    cmd.iter_mut().filter(|v| **v == b':').for_each(|v| *v = 0);
+    cmd[..end + 1].split_inclusive(|v| *v == 0).map(|v| CStr::from_bytes_until_nul(v).unwrap())
 }
 
 /// Helper for handling "fastboot getvar ..."
 async fn get_var(
-    mut args: Split<'_, char>,
+    cmd: &mut [u8],
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let mut resp = Responder::new(transport);
+    let mut args = cmd_to_c_string_args(cmd).skip(1);
     let Some(var) = args.next() else {
-        return transport.send_packet(fastboot_fail!(res, "Missing variable")).await;
+        return reply_fail!(resp, "Missing variable");
     };
 
-    match var {
+    match var.to_str()? {
         "all" => return get_var_all(transport, fb_impl).await,
         MAX_DOWNLOAD_SIZE_NAME => {
-            let msg = fastboot_okay!(res, "{:#x}", fb_impl.get_download_buffer().await.len());
-            return transport.send_packet(msg).await;
+            return reply_okay!(resp, "{:#x}", fb_impl.get_download_buffer().await.len());
         }
-        v => {
+        _ => {
             let mut val = [0u8; MAX_RESPONSE_SIZE];
-            match get_var_str(v, args, &mut val[..], transport, fb_impl).await {
-                Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)).await,
-                Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+            match fb_impl.get_var_as_str(var, args, &mut resp, &mut val[..]).await {
+                Ok(s) => reply_okay!(resp, "{}", s),
+                Err(e) => reply_fail!(resp, "{}", e.to_str()),
             }
         }
     }
@@ -589,14 +717,13 @@ async fn get_var(
 /// A wrapper of `get_var_all()` that first iterates reserved variables.
 async fn get_var_all_with_native(
     fb_impl: &mut impl FastbootImplementation,
-    sender: &mut impl VarSender,
+    mut sender: impl VarInfoSender,
 ) -> CommandResult<()> {
     // Process the built-in MAX_DOWNLOAD_SIZE_NAME variable.
     let mut size_str = [0u8; 32];
     let size_str = snprintf!(size_str, "{:#x}", fb_impl.get_download_buffer().await.len());
-    sender.send(MAX_DOWNLOAD_SIZE_NAME, &[], size_str).await?;
-    // Don't allow other custom INFO messages because variable values are sent as INFO messages.
-    fb_impl.get_var_all(sender, &mut FastbootUtilData::new(&mut NoopTransport {})).await
+    sender.send_var_info(MAX_DOWNLOAD_SIZE_NAME, [], size_str).await?;
+    fb_impl.get_var_all(sender).await
 }
 
 /// Method for handling "fastboot getvar all"
@@ -604,14 +731,12 @@ async fn get_var_all(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
-    let transport_error = &mut Ok(());
-    let mut sender = FbVarSender { transport, transport_error };
-    let get_res = get_var_all_with_native(fb_impl, &mut sender).await;
-    (*transport_error)?;
+    let mut resp = Responder::new(transport);
+    // Don't allow custom INFO messages because variable values are sent as INFO messages.
+    let get_res = get_var_all_with_native(fb_impl, &mut resp).await;
     match get_res {
-        Ok(()) => transport.send_packet(fastboot_okay!(res, "")).await,
-        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+        Ok(()) => reply_okay!(resp, ""),
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
     }
 }
 
@@ -621,42 +746,42 @@ async fn download(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let mut resp = Responder::new(transport);
     let total_download_size = match (|| -> CommandResult<usize> {
-        usize::try_from(next_arg_u64(&mut args, Err("Not enough argument".into()))?)
+        usize::try_from(next_arg_u64(&mut args)?.ok_or("Not enough argument")?)
             .map_err(|_| "Download size overflow".into())
     })() {
-        Err(e) => return transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+        Err(e) => return reply_fail!(resp, "{}", e.to_str()),
         Ok(v) => v,
     };
     let download_buffer = &mut fb_impl.get_download_buffer().await;
     if total_download_size > download_buffer.len() {
-        return transport.send_packet(fastboot_fail!(res, "Download size is too big")).await;
+        return reply_fail!(resp, "Download size is too big");
     } else if total_download_size == 0 {
-        return transport.send_packet(fastboot_fail!(res, "Zero download size")).await;
+        return reply_fail!(resp, "Zero download size");
     }
 
     // Starts the download
     let download_buffer = &mut download_buffer[..total_download_size];
-    transport.send_packet(snprintf!(res, "DATA{:#x}", total_download_size).as_bytes()).await?;
+    // `total_download_size` is parsed from `next_arg_u64` and thus should fit into u64.
+    resp.send_data_message(u64::try_from(total_download_size).unwrap()).await?;
     let mut downloaded = 0;
     while downloaded < total_download_size {
         let (_, remains) = &mut download_buffer.split_at_mut(downloaded);
-        match transport.receive_packet(remains).await? {
+        match resp.transport.receive_packet(remains).await? {
             0 => yield_now().await,
             v => match downloaded.checked_add(v) {
                 Some(v) if v > total_download_size => {
-                    let msg = snprintf!(res, "FAILMore data received then expected");
-                    return transport.send_packet(msg.as_bytes()).await;
+                    return reply_fail!(resp, "More data received then expected");
                 }
                 Some(v) => downloaded = v,
                 _ => return Err(Error::Other(Some("Invalid read size from transport"))),
             },
         };
     }
-    match fb_impl.download_complete(downloaded).await {
-        Ok(()) => transport.send_packet(fastboot_okay!(res, "")).await,
-        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+    match fb_impl.download_complete(downloaded, &mut resp).await {
+        Ok(()) => reply_okay!(resp, ""),
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
     }
 }
 
@@ -666,15 +791,33 @@ async fn flash(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let mut resp = Responder::new(transport);
     let flash_res =
         match cmd.strip_prefix("flash:").ok_or::<CommandError>("Missing partition".into()) {
-            Ok(part) => fb_impl.flash(part, &mut FastbootUtilData::new(transport)).await,
+            Ok(part) => fb_impl.flash(part, &mut resp).await,
             Err(e) => Err(e),
         };
     match flash_res {
-        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
-        _ => transport.send_packet(fastboot_okay!(res, "")).await,
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
+        _ => reply_okay!(resp, ""),
+    }
+}
+
+/// Helper for handling "fastboot erase ...".
+async fn erase(
+    cmd: &str,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut resp = Responder::new(transport);
+    let flash_res =
+        match cmd.strip_prefix("erase:").ok_or::<CommandError>("Missing partition".into()) {
+            Ok(part) => fb_impl.erase(part, &mut resp).await,
+            Err(e) => Err(e),
+        };
+    match flash_res {
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
+        _ => reply_okay!(resp, ""),
     }
 }
 
@@ -683,21 +826,13 @@ async fn upload(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
-    // No INFO message should be sent during upload.
-    let noop_transport = &mut NoopTransport {};
-    let mut utils = FastbootUtilData::new(noop_transport);
-    let mut upload_error = Ok(());
-    let mut remaining = 0;
-    let upload_builder =
-        FbUploadBuilder { transport, error: &mut upload_error, remaining: &mut remaining };
-    let upload_res = fb_impl.upload(upload_builder, &mut utils).await;
-    upload_error?;
-    match remaining > 0 {
+    let mut resp = Responder::new(transport);
+    let upload_res = fb_impl.upload(&mut resp).await;
+    match resp.remaining_upload > 0 {
         true => return Err(Error::InvalidInput),
         _ => match upload_res {
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
-            _ => transport.send_packet(fastboot_okay!(res, "")).await,
+            Err(e) => reply_fail!(resp, "{}", e.to_str()),
+            _ => reply_okay!(resp, ""),
         },
     }
 }
@@ -709,11 +844,7 @@ async fn fetch(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
-    let mut upload_error = Ok(());
-    let mut remaining = 0;
-    let upload_builder =
-        FbUploadBuilder { transport, error: &mut upload_error, remaining: &mut remaining };
+    let mut resp = Responder::new(transport);
     let fetch_res = async {
         let cmd = cmd.strip_prefix("fetch:").ok_or::<CommandError>("Missing arguments".into())?;
         if args.clone().count() < 3 {
@@ -722,89 +853,161 @@ async fn fetch(
         // Parses backward. Parses size, offset first and treats the remaining string as
         // partition name. This allows ":" in partition name.
         let mut rev = args.clone().rev();
-        let sz = next_arg(&mut rev, Err("Invalid argument".into()))?;
-        let off = next_arg(&mut rev, Err("Invalid argument".into()))?;
+        let sz = next_arg(&mut rev).ok_or("Missing size")?;
+        let off = next_arg(&mut rev).ok_or("Invalid offset")?;
         let part = &cmd[..cmd.len() - (off.len() + sz.len() + 2)];
-        // No INFO message should be sent during upload.
-        let noop_transport = &mut NoopTransport {};
-        let mut utils = FastbootUtilData::new(noop_transport);
-        fb_impl.fetch(part, hex_to_u64(off)?, hex_to_u64(sz)?, upload_builder, &mut utils).await
+        fb_impl.fetch(part, hex_to_u64(off)?, hex_to_u64(sz)?, &mut resp).await
     }
     .await;
-    upload_error?;
-    match remaining > 0 {
+    match resp.remaining_upload > 0 {
         true => return Err(Error::InvalidInput),
         _ => match fetch_res {
-            Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
-            _ => transport.send_packet(fastboot_okay!(res, "")).await,
+            Err(e) => reply_fail!(resp, "{}", e.to_str()),
+            _ => reply_okay!(resp, ""),
         },
     }
 }
 
+// Handles `fastboot reboot*`
+async fn reboot(
+    mode: RebootMode,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut resp = Responder::new(transport);
+    let e = fb_impl.reboot(mode, &mut resp).await;
+    reply_fail!(resp, "{}", e.to_str())
+}
+
+// Handles `fastboot boot`
+async fn boot(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut resp = Responder::new(transport);
+    let boot_res = async { fb_impl.boot(&mut resp).await }.await;
+    match boot_res {
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
+        _ => reply_okay!(resp, "boot_command"),
+    }
+}
+
+// Handles `fastboot continue`
+async fn r#continue(
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut resp = Responder::new(transport);
+    match fb_impl.r#continue(&mut resp).await {
+        Ok(_) => reply_okay!(resp, ""),
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
+    }
+}
+
+// Handles `fastboot set_active`
+async fn set_active(
+    mut args: Split<'_, char>,
+    transport: &mut impl Transport,
+    fb_impl: &mut impl FastbootImplementation,
+) -> Result<()> {
+    let mut resp = Responder::new(transport);
+    let res = async {
+        let slot = next_arg(&mut args).ok_or("Missing slot")?;
+        fb_impl.set_active(slot, &mut resp).await
+    };
+    match res.await {
+        Ok(_) => reply_okay!(resp, ""),
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
+    }
+}
+
 /// Helper for handling "fastboot oem ...".
 async fn oem(
     cmd: &str,
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    let mut utils = FastbootUtilData::new(transport);
+    let mut resp = Responder::new(transport);
     let mut oem_out = [0u8; MAX_RESPONSE_SIZE - 4];
-    let oem_res = fb_impl.oem(cmd, &mut utils, &mut oem_out[..]).await;
-    utils.transport_error()?;
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
+    let oem_res = fb_impl.oem(cmd, &mut resp, &mut oem_out[..]).await;
     match oem_res {
         Ok(msg) => match from_utf8(msg) {
-            Ok(s) => transport.send_packet(fastboot_okay!(res, "{}", s)).await,
-            Err(e) => {
-                transport.send_packet(fastboot_fail!(res, "Invalid return string {}", e)).await
-            }
+            Ok(s) => reply_okay!(resp, "{}", s),
+            Err(e) => reply_fail!(resp, "Invalid return string {}", e),
         },
-        Err(e) => transport.send_packet(fastboot_fail!(res, "{}", e.to_str())).await,
+        Err(e) => reply_fail!(resp, "{}", e.to_str()),
     }
 }
 
-/// Process the next Fastboot command from the transport.
+/// Process the next Fastboot command from  the transport.
+///
+/// # Returns
+///
+/// * Returns Ok(is_continue) on success where `is_continue` is true if command is
+///   `fastboot continue`.
+/// * Returns Err() on errors.
 pub async fn process_next_command(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
-) -> Result<()> {
-    let mut packet = [0u8; MAX_COMMAND_SIZE];
-    let cmd_size = match transport.receive_packet(&mut packet[..]).await? {
-        0 => return Ok(()),
+) -> Result<bool> {
+    let mut packet = [0u8; MAX_COMMAND_SIZE + 1];
+    let cmd_size = match transport.receive_packet(&mut packet[..MAX_COMMAND_SIZE]).await? {
+        0 => return Ok(false),
         v => v,
     };
-    let mut res = [0u8; MAX_RESPONSE_SIZE];
     let Ok(cmd_str) = from_utf8(&packet[..cmd_size]) else {
-        return transport.send_packet(fastboot_fail!(res, "Invalid Command")).await;
+        transport.send_packet(fastboot_fail!(packet, "Invalid Command")).await?;
+        return Ok(false);
     };
     let mut args = cmd_str.split(':');
     let Some(cmd) = args.next() else {
-        return transport.send_packet(fastboot_fail!(res, "No command")).await;
+        return transport.send_packet(fastboot_fail!(packet, "No command")).await.map(|_| false);
     };
     match cmd {
-        "getvar" => get_var(args, transport, fb_impl).await,
+        "boot" => {
+            boot(transport, fb_impl).await?;
+            return Ok(true);
+        }
+        "continue" => {
+            r#continue(transport, fb_impl).await?;
+            return Ok(true);
+        }
         "download" => download(args, transport, fb_impl).await,
+        "erase" => erase(cmd_str, transport, fb_impl).await,
+        "fetch" => fetch(cmd_str, args, transport, fb_impl).await,
         "flash" => flash(cmd_str, transport, fb_impl).await,
+        "getvar" => get_var(&mut packet[..], transport, fb_impl).await,
+        "reboot" => reboot(RebootMode::Normal, transport, fb_impl).await,
+        "reboot-bootloader" => reboot(RebootMode::Bootloader, transport, fb_impl).await,
+        "reboot-fastboot" => reboot(RebootMode::Fastboot, transport, fb_impl).await,
+        "reboot-recovery" => reboot(RebootMode::Recovery, transport, fb_impl).await,
+        "set_active" => set_active(args, transport, fb_impl).await,
         "upload" => upload(transport, fb_impl).await,
-        "fetch" => fetch(cmd_str, args, transport, fb_impl).await,
         _ if cmd_str.starts_with("oem ") => oem(&cmd_str[4..], transport, fb_impl).await,
-        _ => transport.send_packet(fastboot_fail!(res, "Command not found")).await,
-    }
+        _ => transport.send_packet(fastboot_fail!(packet, "Command not found")).await,
+    }?;
+    Ok(false)
 }
 
 /// Keeps polling and processing fastboot commands from the transport.
+///
+/// # Returns
+///
+/// * Returns Ok(()) if "fastboot continue" is received.
+/// * Returns Err() on errors.
 pub async fn run(
     transport: &mut impl Transport,
     fb_impl: &mut impl FastbootImplementation,
 ) -> Result<()> {
-    loop {
-        process_next_command(transport, fb_impl).await?;
-    }
+    while !process_next_command(transport, fb_impl).await? {}
+    Ok(())
 }
 
 /// Runs a fastboot over TCP session.
 ///
-/// The method performs fastboot over TCP handshake and then call `Self::run(...)`.
+/// The method performs fastboot over TCP handshake and then call `run(...)`.
+///
+/// Returns Ok(()) if "fastboot continue" is received.
 pub async fn run_tcp_session(
     tcp_stream: &mut impl TcpStream,
     fb_impl: &mut impl FastbootImplementation,
@@ -868,19 +1071,13 @@ pub(crate) fn hex_to_u64(s: &str) -> CommandResult<u64> {
     Ok(u64::from_str_radix(s.strip_prefix("0x").unwrap_or(s), 16)?)
 }
 
-/// A helper to check and fetch the next argument or fall back to the default if not available.
+/// A helper to check and fetch the next non-empty argument.
 ///
 /// # Args
 ///
 /// args: A string iterator.
-/// default: This will be returned as it is if args doesn't have the next element(). Providing a
-///   Ok(str) is equivalent to providing a default value. Providing an Err() is equivalent to
-///   requiring that the next argument is mandatory.
-pub fn next_arg<'a, T: Iterator<Item = &'a str>>(
-    args: &mut T,
-    default: CommandResult<&'a str>,
-) -> CommandResult<&'a str> {
-    args.next().filter(|v| *v != "").ok_or("").or(default.map_err(|e| e.into()))
+pub fn next_arg<'a, T: Iterator<Item = &'a str>>(args: &mut T) -> Option<&'a str> {
+    args.next().filter(|v| *v != "")
 }
 
 /// A helper to check and fetch the next argument as a u64 hex string.
@@ -888,18 +1085,17 @@ pub fn next_arg<'a, T: Iterator<Item = &'a str>>(
 /// # Args
 ///
 /// args: A string iterator.
-/// default: This will be returned as it is if args doesn't have the next element(). Providing a
-///   Ok(u64) is equivalent to providing a default value. Providing an Err() is equivalent to
-///   requiring that the next argument is mandatory.
 ///
-/// Returns error if the next argument is not a valid hex string.
-pub fn next_arg_u64<'a, T: Iterator<Item = &'a str>>(
-    args: &mut T,
-    default: CommandResult<u64>,
-) -> CommandResult<u64> {
-    match next_arg(args, Err("".into())) {
-        Ok(v) => hex_to_u64(v),
-        _ => default.map_err(|e| e.into()),
+///
+/// # Returns
+///
+/// * Returns Ok(Some(v)) is next argument is available and a valid u64 hex.
+/// * Returns Ok(None) is next argument is not available
+/// * Returns Err() if next argument is present but not a valid u64 hex.
+pub fn next_arg_u64<'a, T: Iterator<Item = &'a str>>(args: &mut T) -> CommandResult<Option<u64>> {
+    match next_arg(args) {
+        Some(v) => Ok(Some(hex_to_u64(v)?)),
+        _ => Ok(None),
     }
 }
 
@@ -912,8 +1108,10 @@ mod test {
     struct FastbootTest {
         // A mapping from (variable name, argument) to variable value.
         vars: BTreeMap<(&'static str, &'static [&'static str]), &'static str>,
-        // The partition arg from Fastboot command
+        // The partition arg from Fastboot flash command
         flash_partition: String,
+        // The partition arg from Fastboot erase command
+        erase_partition: String,
         // Upload size, batches of data to upload,
         upload_config: (u64, Vec<Vec<u8>>),
         // A map from partition name to (upload size override, partition data)
@@ -923,18 +1121,20 @@ mod test {
         oem_command: String,
         download_buffer: Vec<u8>,
         downloaded_size: usize,
+        reboot_mode: Option<RebootMode>,
+        active_slot: Option<String>,
     }
 
     impl FastbootImplementation for FastbootTest {
         async fn get_var(
             &mut self,
-            var: &str,
-            args: Split<'_, char>,
+            var: &CStr,
+            args: impl Iterator<Item = &'_ CStr> + Clone,
             out: &mut [u8],
-            _: &mut impl FastbootUtils,
+            _: impl InfoSender,
         ) -> CommandResult<usize> {
-            let args = args.collect::<Vec<_>>();
-            match self.vars.get(&(var, &args[..])) {
+            let args = args.map(|v| v.to_str().unwrap()).collect::<Vec<_>>();
+            match self.vars.get(&(var.to_str()?, &args[..])) {
                 Some(v) => {
                     out[..v.len()].clone_from_slice(v.as_bytes());
                     Ok(v.len())
@@ -943,13 +1143,9 @@ mod test {
             }
         }
 
-        async fn get_var_all(
-            &mut self,
-            sender: &mut impl VarSender,
-            _: &mut impl FastbootUtils,
-        ) -> CommandResult<()> {
+        async fn get_var_all(&mut self, mut responder: impl VarInfoSender) -> CommandResult<()> {
             for ((var, config), value) in &self.vars {
-                sender.send(var, config, value).await?;
+                responder.send_var_info(var, config.iter().copied(), value).await?;
             }
             Ok(())
         }
@@ -958,23 +1154,28 @@ mod test {
             self.download_buffer.as_mut_slice()
         }
 
-        async fn download_complete(&mut self, download_size: usize) -> CommandResult<()> {
+        async fn download_complete(
+            &mut self,
+            download_size: usize,
+            _: impl InfoSender,
+        ) -> CommandResult<()> {
             self.downloaded_size = download_size;
             Ok(())
         }
 
-        async fn flash(&mut self, part: &str, _: &mut impl FastbootUtils) -> CommandResult<()> {
+        async fn flash(&mut self, part: &str, _: impl InfoSender) -> CommandResult<()> {
             self.flash_partition = part.into();
             Ok(())
         }
 
-        async fn upload(
-            &mut self,
-            upload_builder: impl UploadBuilder,
-            _utils: &mut impl FastbootUtils,
-        ) -> CommandResult<()> {
+        async fn erase(&mut self, part: &str, _: impl InfoSender) -> CommandResult<()> {
+            self.erase_partition = part.into();
+            Ok(())
+        }
+
+        async fn upload(&mut self, responder: impl UploadBuilder) -> CommandResult<()> {
             let (size, batches) = &self.upload_config;
-            let mut uploader = upload_builder.start(*size).await?;
+            let mut uploader = responder.initiate_upload(*size).await?;
             for ele in batches {
                 uploader.upload(&ele[..]).await?;
             }
@@ -986,24 +1187,48 @@ mod test {
             part: &str,
             offset: u64,
             size: u64,
-            upload_builder: impl UploadBuilder,
-            _utils: &mut impl FastbootUtils,
+            responder: impl UploadBuilder + InfoSender,
         ) -> CommandResult<()> {
             let (size_override, data) = self.fetch_data.get(part).ok_or("Not Found")?;
-            let mut uploader = upload_builder.start(*size_override).await?;
-            uploader.upload(&data[offset.try_into().unwrap()..][..size.try_into().unwrap()]).await
+            let mut uploader = responder.initiate_upload(*size_override).await?;
+            Ok(uploader
+                .upload(&data[offset.try_into().unwrap()..][..size.try_into().unwrap()])
+                .await?)
+        }
+
+        async fn boot(&mut self, mut responder: impl InfoSender + OkaySender) -> CommandResult<()> {
+            Ok(responder.send_info("Boot to boot.img...").await?)
+        }
+
+        async fn reboot(
+            &mut self,
+            mode: RebootMode,
+            responder: impl InfoSender + OkaySender,
+        ) -> CommandError {
+            responder.send_okay("").await.unwrap();
+            self.reboot_mode = Some(mode);
+            "reboot-return".into()
+        }
+
+        async fn r#continue(&mut self, mut responder: impl InfoSender) -> CommandResult<()> {
+            Ok(responder.send_info("Continuing to boot...").await?)
+        }
+
+        async fn set_active(&mut self, slot: &str, _: impl InfoSender) -> CommandResult<()> {
+            self.active_slot = Some(slot.into());
+            Ok(())
         }
 
         async fn oem<'b>(
             &mut self,
             cmd: &str,
-            utils: &mut impl FastbootUtils,
+            mut responder: impl InfoSender,
             res: &'b mut [u8],
         ) -> CommandResult<&'b [u8]> {
             let (res_str, infos) = &mut self.oem_output;
             self.oem_command = cmd.into();
             for ele in infos {
-                utils.send_info(ele.as_str()).await?;
+                responder.send_info(ele.as_str()).await?;
             }
             Ok(snprintf!(res, "{}", *res_str).as_bytes())
         }
@@ -1076,6 +1301,22 @@ mod test {
         }
     }
 
+    #[test]
+    fn test_boot() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 1024];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"boot");
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert_eq!(
+            transport.out_queue,
+            VecDeque::<Vec<u8>>::from([
+                b"INFOBoot to boot.img...".into(),
+                b"OKAYboot_command".into()
+            ])
+        );
+    }
+
     #[test]
     fn test_non_exist_command() {
         let mut fastboot_impl: FastbootTest = Default::default();
@@ -1185,7 +1426,7 @@ mod test {
         let _ = block_on(run(&mut transport, &mut fastboot_impl));
         assert_eq!(
             transport.out_queue,
-            VecDeque::<Vec<u8>>::from([b"DATA0x400".into(), b"OKAY".into(),])
+            VecDeque::<Vec<u8>>::from([b"DATA00000400".into(), b"OKAY".into(),])
         );
         assert_eq!(fastboot_impl.downloaded_size, download_content.len());
         assert_eq!(fastboot_impl.download_buffer, download_content);
@@ -1245,7 +1486,7 @@ mod test {
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
-                b"DATA0x3ff".into(),
+                b"DATA000003ff".into(),
                 b"FAILMore data received then expected".into(),
                 b"OKAY0x400".into(),
             ])
@@ -1292,6 +1533,26 @@ mod test {
         assert_eq!(transport.out_queue, [b"FAILMissing partition"]);
     }
 
+    #[test]
+    fn test_erase() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 2048];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"erase:boot_a:0::");
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert_eq!(fastboot_impl.erase_partition, "boot_a:0::");
+        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
+    }
+
+    #[test]
+    fn test_erase_missing_partition() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut transport = TestTransport::new();
+        transport.add_input(b"erase");
+        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        assert_eq!(transport.out_queue, [b"FAILMissing partition"]);
+    }
+
     #[test]
     fn test_upload() {
         let mut fastboot_impl: FastbootTest = Default::default();
@@ -1346,7 +1607,7 @@ mod test {
         fastboot_impl
             .fetch_data
             .insert("boot_a:0::", (0x400, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
         assert_eq!(
             transport.out_queue,
             VecDeque::<Vec<u8>>::from([
@@ -1366,8 +1627,7 @@ mod test {
         fastboot_impl
             .fetch_data
             .insert("boot_a:0::", (0x400 - 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
+        assert!(block_on(process_next_command(&mut transport, &mut fastboot_impl)).is_err());
     }
 
     #[test]
@@ -1379,8 +1639,7 @@ mod test {
         fastboot_impl
             .fetch_data
             .insert("boot_a:0::", (0x400 + 1, vec![vec![0u8; 0x200], vec![1u8; 0x400]].concat()));
-        let _ = block_on(run(&mut transport, &mut fastboot_impl));
-        assert!(block_on(run(&mut transport, &mut fastboot_impl)).is_err());
+        assert!(block_on(process_next_command(&mut transport, &mut fastboot_impl)).is_err());
     }
 
     #[test]
@@ -1418,7 +1677,7 @@ mod test {
         let expected: &[&[u8]] = &[
             b"FB01",
             b"\x00\x00\x00\x00\x00\x00\x00\x09OKAY0x400",
-            b"\x00\x00\x00\x00\x00\x00\x00\x09DATA0x400",
+            b"\x00\x00\x00\x00\x00\x00\x00\x0cDATA00000400",
             b"\x00\x00\x00\x00\x00\x00\x00\x04OKAY",
         ];
         assert_eq!(tcp_stream.out_queue, VecDeque::from(expected.concat()));
@@ -1428,7 +1687,6 @@ mod test {
     #[test]
     fn test_fastboot_tcp_invalid_handshake() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut tcp_stream: TestTcpStream = Default::default();
         tcp_stream.add_input(b"ABCD");
         assert_eq!(
@@ -1440,7 +1698,6 @@ mod test {
     #[test]
     fn test_fastboot_tcp_packet_size_exceeds_maximum() {
         let mut fastboot_impl: FastbootTest = Default::default();
-        fastboot_impl.download_buffer = vec![0u8; 1024];
         let mut tcp_stream: TestTcpStream = Default::default();
         tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
         tcp_stream.add_input(&(MAX_COMMAND_SIZE + 1).to_be_bytes());
@@ -1449,4 +1706,105 @@ mod test {
             Error::InvalidInput
         );
     }
+
+    #[test]
+    fn test_reboot() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut transport = TestTransport::new();
+        transport.add_input(b"reboot");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Normal));
+        assert_eq!(transport.out_queue[0], b"OKAY");
+        // Failure is expected here because test reboot implementation always returns, which
+        // automatically generates a fastboot failure packet.
+        assert!(transport.out_queue[1].starts_with(b"FAIL"));
+    }
+
+    #[test]
+    fn test_reboot_bootloader() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut transport = TestTransport::new();
+        transport.add_input(b"reboot-bootloader");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Bootloader));
+        assert_eq!(transport.out_queue[0], b"OKAY");
+        // Failure is expected here because test reboot implementation always returns, which
+        // automatically generates a fastboot failure packet.
+        assert!(transport.out_queue[1].starts_with(b"FAIL"));
+    }
+
+    #[test]
+    fn test_reboot_fastboot() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut transport = TestTransport::new();
+        transport.add_input(b"reboot-fastboot");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Fastboot));
+        assert_eq!(transport.out_queue[0], b"OKAY");
+        // Failure is expected here because test reboot implementation always returns, which
+        // automatically generates a fastboot failure packet.
+        assert!(transport.out_queue[1].starts_with(b"FAIL"));
+    }
+
+    #[test]
+    fn test_reboot_recovery() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut transport = TestTransport::new();
+        transport.add_input(b"reboot-recovery");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(fastboot_impl.reboot_mode, Some(RebootMode::Recovery));
+        assert_eq!(transport.out_queue[0], b"OKAY");
+        // Failure is expected here because test reboot implementation always returns, which
+        // automatically generates a fastboot failure packet.
+        assert!(transport.out_queue[1].starts_with(b"FAIL"));
+    }
+
+    #[test]
+    fn test_continue() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 1024];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"getvar:max-download-size");
+        transport.add_input(b"continue");
+        transport.add_input(b"getvar:max-download-size");
+        block_on(run(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(
+            transport.out_queue,
+            VecDeque::<Vec<u8>>::from([
+                b"OKAY0x400".into(),
+                b"INFOContinuing to boot...".into(),
+                b"OKAY".into()
+            ])
+        );
+    }
+
+    #[test]
+    fn test_continue_run_tcp() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        let mut tcp_stream: TestTcpStream = Default::default();
+        tcp_stream.add_input(TCP_HANDSHAKE_MESSAGE);
+        tcp_stream.add_length_prefixed_input(b"continue");
+        block_on(run_tcp_session(&mut tcp_stream, &mut fastboot_impl)).unwrap();
+    }
+
+    #[test]
+    fn test_set_active() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 1024];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"set_active:a");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"OKAY".into()]));
+        assert_eq!(fastboot_impl.active_slot, Some("a".into()));
+    }
+
+    #[test]
+    fn test_set_active_missing_slot() {
+        let mut fastboot_impl: FastbootTest = Default::default();
+        fastboot_impl.download_buffer = vec![0u8; 1024];
+        let mut transport = TestTransport::new();
+        transport.add_input(b"set_active");
+        block_on(process_next_command(&mut transport, &mut fastboot_impl)).unwrap();
+        assert_eq!(transport.out_queue, VecDeque::<Vec<u8>>::from([b"FAILMissing slot".into()]));
+    }
 }
diff --git a/gbl/libfdt/BUILD b/gbl/libfdt/BUILD
index abc5782..fa416a0 100644
--- a/gbl/libfdt/BUILD
+++ b/gbl/libfdt/BUILD
@@ -122,6 +122,7 @@ rust_library(
         ":libfdt_sysdeps_static",
         ":libufdt_bindgen",
         ":libufdt_c_static",
+        "@arrayvec",
         "@gbl//libc",
         "@gbl//liberror",
         "@gbl//libsafemath",
diff --git a/gbl/libfdt/src/lib.rs b/gbl/libfdt/src/lib.rs
index 269562e..71ef623 100644
--- a/gbl/libfdt/src/lib.rs
+++ b/gbl/libfdt/src/lib.rs
@@ -19,21 +19,23 @@
 extern crate alloc;
 extern crate libc;
 
-use alloc::vec::Vec;
+use arrayvec::ArrayVec;
 use core::ffi::{c_int, CStr};
 use core::mem::size_of;
 use core::slice::{from_raw_parts, from_raw_parts_mut};
-
+use liberror::{Error, Result};
 use libfdt_bindgen::{
     fdt_add_subnode_namelen, fdt_del_node, fdt_get_property, fdt_header, fdt_move, fdt_setprop,
     fdt_setprop_placeholder, fdt_strerror, fdt_subnode_offset_namelen,
 };
 use libufdt_bindgen::ufdt_apply_multioverlay;
-
-use liberror::{Error, Result};
-
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
+/// Fdt header structure size.
+pub const FDT_HEADER_SIZE: usize = size_of::<FdtHeader>();
+const MAXIMUM_OVERLAYS_TO_APPLY: usize = 16;
+const MAXIMUM_OVERLAYS_ERROR_MSG: &str = "At most 16 overlays are supported to apply at a time";
+
 /// Convert libfdt_c error code to Result
 fn map_result(code: c_int) -> Result<c_int> {
     match code {
@@ -53,12 +55,17 @@ fn map_result_libufdt(code: c_int) -> Result<c_int> {
     }
 }
 
-/// Check header and verified that totalsize does not exceed buffer size.
-fn fdt_check_header(fdt: &[u8]) -> Result<()> {
+/// Check header.
+fn fdt_check_header(header: &[u8]) -> Result<()> {
     // SAFETY:
-    // `fdt_check_header` is only access the memory pointed to by `fdt` during this call and
-    // not store the pointer for later use. `fdt` remains valid for the duration of this call.
-    map_result(unsafe { libfdt_bindgen::fdt_check_header(fdt.as_ptr() as *const _) })?;
+    // `fdt_check_header` is only access the memory pointed to by `header` during this call and
+    // not store the pointer for later use. `header` remains valid for the duration of this call.
+    map_result(unsafe { libfdt_bindgen::fdt_check_header(header.as_ptr() as *const _) })?;
+    Ok(())
+}
+
+/// Check header and verified that totalsize does not exceed buffer size.
+fn fdt_check_buffer(fdt: &[u8]) -> Result<()> {
     match FdtHeader::from_bytes_ref(fdt)?.totalsize() <= fdt.len() {
         true => Ok(()),
         _ => Err(Error::InvalidInput),
@@ -116,16 +123,20 @@ impl FdtHeader {
 
     /// Cast a bytes into a reference of FDT header
     pub fn from_bytes_ref(buffer: &[u8]) -> Result<&FdtHeader> {
+        fdt_check_header(buffer)?;
+
         Ok(Ref::<_, FdtHeader>::new_from_prefix(buffer)
-            .ok_or(Error::BufferTooSmall(Some(size_of::<FdtHeader>())))?
+            .ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?
             .0
             .into_ref())
     }
 
     /// Cast a bytes into a mutable reference of FDT header.
     pub fn from_bytes_mut(buffer: &mut [u8]) -> Result<&mut FdtHeader> {
+        fdt_check_header(buffer)?;
+
         Ok(Ref::<_, FdtHeader>::new_from_prefix(buffer)
-            .ok_or(Error::BufferTooSmall(Some(size_of::<FdtHeader>())))?
+            .ok_or(Error::BufferTooSmall(Some(FDT_HEADER_SIZE)))?
             .0
             .into_mut())
     }
@@ -139,8 +150,7 @@ impl FdtHeader {
         // SAFETY: By safety requirement of this function, `ptr` points to a valid FDT and remains
         // valid when in use.
         unsafe {
-            map_result(libfdt_bindgen::fdt_check_header(ptr as *const _))?;
-            let header_bytes = from_raw_parts(ptr, size_of::<FdtHeader>());
+            let header_bytes = from_raw_parts(ptr, FDT_HEADER_SIZE);
             let header = Self::from_bytes_ref(header_bytes)?;
             Ok((header, from_raw_parts(ptr, header.totalsize())))
         }
@@ -154,7 +164,7 @@ pub struct Fdt<T>(T);
 impl<'a, T: AsRef<[u8]> + 'a> Fdt<T> {
     /// Creates a new [Fdt] wrapping the contents of `init`.
     pub fn new(init: T) -> Result<Self> {
-        fdt_check_header(init.as_ref())?;
+        fdt_check_buffer(init.as_ref())?;
         Ok(Fdt(init))
     }
 
@@ -209,9 +219,17 @@ impl<'a, T: AsRef<[u8]> + 'a> Fdt<T> {
 
 /// APIs when data can be modified.
 impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
+    /// Creates a new mut [Fdt] wrapping the contents of `init`.
+    pub fn new_mut(init: T) -> Result<Self> {
+        let mut fdt = Fdt::new(init)?;
+        let new_size: u32 = fdt.as_mut().len().try_into().or(Err(Error::Other(None)))?;
+        fdt.header_mut()?.set_totalsize(new_size);
+        Ok(fdt)
+    }
+
     /// Creates a mutable [Fdt] copied from `init`.
     pub fn new_from_init(mut fdt: T, init: &[u8]) -> Result<Self> {
-        fdt_check_header(init)?;
+        fdt_check_buffer(init)?;
         // SAFETY: API from libfdt_c.
         map_result(unsafe {
             fdt_move(
@@ -296,10 +314,19 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
     /// Wrapper/equivalent of ufdt_apply_multioverlay.
     /// It extend current FDT buffer by applying passed overlays.
     pub fn multioverlay_apply(&mut self, overlays: &[&[u8]]) -> Result<()> {
+        // Avoid shrinking device tree or doing any other actions in case nothing to apply.
+        if overlays.is_empty() {
+            return Ok(());
+        }
+        if overlays.len() > MAXIMUM_OVERLAYS_TO_APPLY {
+            return Err(Error::Other(Some(MAXIMUM_OVERLAYS_ERROR_MSG)));
+        }
+
         self.shrink_to_fit()?;
 
-        // Have to allocate vector to convert input fat references into the raw pointers
-        let pointers: Vec<_> = overlays.iter().map(|&slice| slice.as_ptr()).collect();
+        // Convert input fat references into the raw pointers.
+        let pointers: ArrayVec<_, MAXIMUM_OVERLAYS_TO_APPLY> =
+            overlays.iter().map(|&slice| slice.as_ptr()).collect();
 
         // SAFETY: The `ufdt_apply_multioverlay` function guarantees that `self.0` is accessed
         // within the specified length boundaries. The `pointers` are non-null and are accessed
@@ -332,10 +359,26 @@ impl<T: AsMut<[u8]> + AsRef<[u8]>> Fdt<T> {
     }
 }
 
+impl<T: AsMut<[u8]>> AsMut<[u8]> for Fdt<T> {
+    fn as_mut(&mut self) -> &mut [u8] {
+        self.0.as_mut()
+    }
+}
+
+impl<T: AsRef<[u8]>> AsRef<[u8]> for Fdt<T> {
+    fn as_ref(&self) -> &[u8] {
+        self.0.as_ref()
+    }
+}
+
 #[cfg(test)]
 mod test {
     use super::*;
 
+    // Fdt is required to be 8 bytes aligned. Buffer to test alignment-related logic.
+    #[repr(align(8))]
+    struct AlignedBytes<const N: usize>([u8; N]);
+
     /// Checks to verify `overlay_*_by_path`/`overlay_*_by_reference` are successfully applied
     fn check_overlays_are_applied(fdt: &[u8]) {
         let fdt = Fdt::new(fdt).unwrap();
@@ -488,6 +531,28 @@ mod test {
         assert_eq!(fdt.get_property("/new-node", c"custom").unwrap().to_vec(), data);
     }
 
+    #[test]
+    fn test_header_from_bytes() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let header = FdtHeader::from_bytes_ref(&init[..]).unwrap();
+
+        assert_eq!(header.totalsize(), init.len());
+    }
+
+    #[test]
+    fn test_header_from_bytes_wrong_alignment() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+
+        const HEADER_SIZE: usize = size_of::<FdtHeader>();
+        let mut bytes = AlignedBytes([0u8; HEADER_SIZE + 1]);
+
+        // Guaranteed not to be 8 bytes aligned.
+        let (_, unaligned) = bytes.0.split_at_mut(1);
+        unaligned.copy_from_slice(&init[..HEADER_SIZE]);
+
+        assert!(FdtHeader::from_bytes_ref(unaligned).is_err());
+    }
+
     #[test]
     fn test_header_from_raw() {
         let init = include_bytes!("../test/data/base.dtb").to_vec();
@@ -630,4 +695,19 @@ mod test {
             "expected the problem is catched when applying overlay with wrong target path"
         );
     }
+
+    #[test]
+    fn test_fdt_multioverlay_apply_maximum_amount_of_overlays_handled() {
+        let init = include_bytes!("../test/data/base.dtb").to_vec();
+        let too_many_overlays = &[&[] as &[u8]; MAXIMUM_OVERLAYS_TO_APPLY + 1];
+
+        let mut fdt_buf = vec![0u8; init.len()];
+        let mut fdt = Fdt::new_from_init(&mut fdt_buf[..], &init[..]).unwrap();
+
+        assert_eq!(
+            fdt.multioverlay_apply(too_many_overlays),
+            Err(Error::Other(Some(MAXIMUM_OVERLAYS_ERROR_MSG))),
+            "too many overlays isn't handled"
+        );
+    }
 }
diff --git a/gbl/libgbl/BUILD b/gbl/libgbl/BUILD
index 2132066..044bdc9 100644
--- a/gbl/libgbl/BUILD
+++ b/gbl/libgbl/BUILD
@@ -26,6 +26,7 @@ rust_library(
     rustc_flags = ANDROID_RUST_LINTS,
     visibility = ["//visibility:public"],
     deps = [
+        "@arrayvec",
         "@avb",
         "@avb//:avb_bindgen",
         "@bitflags",
@@ -34,16 +35,24 @@ rust_library(
         "@gbl//libabr",
         "@gbl//libasync",
         "@gbl//libboot",
+        "@gbl//libbootimg",
+        "@gbl//libbootparams",
+        "@gbl//libdttable",
         "@gbl//liberror",
         "@gbl//libfastboot",
+        "@gbl//libfdt",
+        "@gbl//libmisc",
         "@gbl//libsafemath",
         "@gbl//libstorage",
-        "@gbl//third_party/libzbi",
+        "@gbl//libutils",
         "@itertools_noalloc",
+        "@lz4_flex",
         "@spin",
         "@static_assertions",
         "@uuid",
+        "@zbi",
         "@zerocopy",
+        "@zune_inflate",
     ],
 )
 
@@ -56,6 +65,8 @@ rust_test(
     crate = ":libgbl",
     crate_features = ["uuid"],
     data = [
+        "@gbl//libdttable/test/data:all",
+        "@gbl//libfdt/test/data:all",
         "@gbl//libgbl/testdata:cert_metadata.bin",
         "@gbl//libgbl/testdata:cert_permanent_attributes.bad.bin",
         "@gbl//libgbl/testdata:cert_permanent_attributes.bad.hash",
@@ -83,7 +94,6 @@ rust_test(
         "@avb//:avb_test",
         "@gbl//libasync:cyclic_executor",
         "@gbl//libavb:sysdeps",
-        "@gbl//libstorage:libstorage_testlib",
         "@itertools",
         "@itertools_noalloc",
         "@static_assertions",
diff --git a/gbl/libgbl/Cargo.toml b/gbl/libgbl/Cargo.toml
index 8d4d65a..3d330d8 100644
--- a/gbl/libgbl/Cargo.toml
+++ b/gbl/libgbl/Cargo.toml
@@ -25,7 +25,6 @@ default = []
 alloc = []
 
 [dependencies]
-zbi = {version = "0.1", path = "../third_party/libzbi"}
 gbl_storage = {version = "0.1", path = "../libstorage"}
 spin = "0.9"
 static_assertions = "0"
diff --git a/gbl/libgbl/src/android_boot/mod.rs b/gbl/libgbl/src/android_boot/mod.rs
new file mode 100644
index 0000000..9c5815e
--- /dev/null
+++ b/gbl/libgbl/src/android_boot/mod.rs
@@ -0,0 +1,553 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Android boot support.
+
+use crate::{
+    device_tree::{DeviceTreeComponentSource, DeviceTreeComponentsRegistry, FDT_ALIGNMENT},
+    gbl_avb::{
+        ops::GblAvbOps,
+        state::{BootStateColor, KeyValidationStatus},
+    },
+    gbl_print, gbl_println, GblOps, IntegrationError, Result,
+};
+use arrayvec::ArrayVec;
+use avb::{slot_verify, HashtreeErrorMode, Ops as _, SlotVerifyFlags};
+use bootimg::{BootImage, VendorImageHeader};
+use bootparams::{bootconfig::BootConfigBuilder, commandline::CommandlineBuilder};
+use core::{ffi::CStr, fmt::Write};
+use dttable::DtTableImage;
+use fdt::Fdt;
+use liberror::Error;
+use libutils::aligned_subslice;
+use misc::{AndroidBootMode, BootloaderMessage};
+use safemath::SafeNum;
+use zerocopy::{AsBytes, ByteSlice};
+
+#[cfg(target_arch = "aarch64")]
+use crate::decompress::decompress_kernel;
+
+/// Device tree bootargs property to store kernel command line.
+pub const BOOTARGS_PROP: &CStr = c"bootargs";
+/// Linux kernel requires 2MB alignment.
+const KERNEL_ALIGNMENT: usize = 2 * 1024 * 1024;
+
+/// A helper to convert a bytes slice containing a null-terminated string to `str`
+fn cstr_bytes_to_str(data: &[u8]) -> core::result::Result<&str, Error> {
+    Ok(CStr::from_bytes_until_nul(data)?.to_str()?)
+}
+
+/// Helper function for performing libavb verification.
+///
+/// Currently this requires the caller to preload all relevant images from disk; in its final
+/// state `ops` will provide the necessary callbacks for where the images should go in RAM and
+/// which ones are preloaded.
+///
+/// # Arguments
+/// * `ops`: [GblOps] providing device-specific backend.
+/// * `kernel`: buffer containing the `boot` image loaded from disk.
+/// * `vendor_boot`: buffer containing the `vendor_boot` image loaded from disk.
+/// * `init_boot`: buffer containing the `init_boot` image loaded from disk.
+/// * `dtbo`: buffer containing the `dtbo` image loaded from disk, if it exists.
+/// * `bootconfig_builder`: object to write the bootconfig data into.
+///
+/// # Returns
+/// `()` on success, error if the images fail to verify or we fail to update the bootconfig.
+fn avb_verify_slot<'a, 'b>(
+    ops: &mut impl GblOps<'a, 'b>,
+    kernel: &[u8],
+    vendor_boot: &[u8],
+    init_boot: &[u8],
+    dtbo: Option<&[u8]>,
+    bootconfig_builder: &mut BootConfigBuilder,
+) -> Result<()> {
+    // We need the list of partition names to verify with libavb, and a corresponding list of
+    // (name, image) tuples to register as [GblAvbOps] preloaded data.
+    let mut partitions = ArrayVec::<_, 4>::new();
+    let mut preloaded = ArrayVec::<_, 4>::new();
+    for (c_name, image) in [
+        (c"boot", Some(kernel)),
+        (c"vendor_boot", Some(vendor_boot)),
+        (c"init_boot", Some(init_boot)),
+        (c"dtbo", dtbo),
+    ] {
+        if let Some(image) = image {
+            partitions.push(c_name);
+            preloaded.push((c_name.to_str().unwrap(), image));
+        }
+    }
+
+    // TODO(b/337846185): Pass AVB_SLOT_VERIFY_FLAGS_RESTART_CAUSED_BY_HASHTREE_CORRUPTION in
+    // case verity corruption is detected by HLOS.
+    let mut avb_ops = GblAvbOps::new(ops, &preloaded[..], false);
+    let res = slot_verify(
+        &mut avb_ops,
+        &partitions,
+        Some(c"_a"),
+        SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
+        // TODO(b/337846185): For demo, we use the same setting as Cuttlefish u-boot.
+        // Pass AVB_HASHTREE_ERROR_MODE_MANAGED_RESTART_AND_EIO and handle EIO.
+        HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
+    )
+    .map_err(|e| IntegrationError::from(e.without_verify_data()))?;
+
+    // TODO(b/337846185): Handle RED and RED_EIO (AVB_HASHTREE_ERROR_MODE_EIO).
+    let color = match avb_ops.read_is_device_unlocked()? {
+        false if avb_ops.key_validation_status()? == KeyValidationStatus::ValidCustomKey => {
+            BootStateColor::Yellow
+        }
+        false => BootStateColor::Green,
+        true => BootStateColor::Orange,
+    };
+    avb_ops.handle_verification_result(&res, color)?;
+
+    // Append avb generated bootconfig.
+    for cmdline_arg in res.cmdline().to_str().unwrap().split(' ') {
+        write!(bootconfig_builder, "{}\n", cmdline_arg).or(Err(Error::BufferTooSmall(None)))?;
+    }
+
+    // Append "androidboot.verifiedbootstate="
+    write!(bootconfig_builder, "androidboot.verifiedbootstate={}\n", color)
+        .or(Err(Error::BufferTooSmall(None)))?;
+    Ok(())
+}
+
+/// Helper function to parse common fields from boot image headers.
+///
+/// # Returns
+///
+/// Returns a tuple of 6 slices corresponding to:
+/// (kernel_size, cmdline, page_size, ramdisk_size, second_size, dtb_size)
+fn boot_header_elements<B: ByteSlice + PartialEq>(
+    hdr: &BootImage<B>,
+) -> Result<(usize, &str, usize, usize, usize, usize)> {
+    const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
+    Ok(match hdr {
+        BootImage::V2(ref hdr) => (
+            hdr._base._base.kernel_size as usize,
+            cstr_bytes_to_str(&hdr._base._base.cmdline[..])?,
+            hdr._base._base.page_size as usize,
+            hdr._base._base.ramdisk_size as usize,
+            hdr._base._base.second_size as usize,
+            hdr.dtb_size as usize,
+        ),
+        BootImage::V3(ref hdr) => (
+            hdr.kernel_size as usize,
+            cstr_bytes_to_str(&hdr.cmdline[..])?,
+            PAGE_SIZE,
+            hdr.ramdisk_size as usize,
+            0,
+            0,
+        ),
+        BootImage::V4(ref hdr) => (
+            hdr._base.kernel_size as usize,
+            cstr_bytes_to_str(&hdr._base.cmdline[..])?,
+            PAGE_SIZE,
+            hdr._base.ramdisk_size as usize,
+            0,
+            0,
+        ),
+        _ => {
+            return Err(Error::UnsupportedVersion.into());
+        }
+    })
+}
+
+/// Helper function to parse common fields from vendor image headers.
+///
+/// # Returns
+///
+/// Returns a tuple of 5 slices corresponding to:
+/// (vendor_ramdisk_size, hdr_size, cmdline, page_size, dtb_size, vendor_bootconfig_size, vendor_ramdisk_table_size)
+fn vendor_header_elements<B: ByteSlice + PartialEq>(
+    hdr: &VendorImageHeader<B>,
+) -> Result<(usize, usize, &str, usize, usize, usize, usize)> {
+    Ok(match hdr {
+        VendorImageHeader::V3(ref hdr) => (
+            hdr.vendor_ramdisk_size as usize,
+            SafeNum::from(hdr.bytes().len())
+                .round_up(hdr.page_size)
+                .try_into()
+                .map_err(Error::from)?,
+            cstr_bytes_to_str(&hdr.cmdline.as_bytes())?,
+            hdr.page_size as usize,
+            hdr.dtb_size as usize,
+            0,
+            0,
+        ),
+        VendorImageHeader::V4(ref hdr) => (
+            hdr._base.vendor_ramdisk_size as usize,
+            SafeNum::from(hdr.bytes().len())
+                .round_up(hdr._base.page_size)
+                .try_into()
+                .map_err(Error::from)?,
+            cstr_bytes_to_str(&hdr._base.cmdline.as_bytes())?,
+            hdr._base.page_size as usize,
+            hdr._base.dtb_size as usize,
+            hdr.bootconfig_size as usize,
+            hdr.vendor_ramdisk_table_size as usize,
+        ),
+    })
+}
+
+/// Loads Android images from disk and fixes up bootconfig, commandline, and FDT.
+///
+/// A number of simplifications are made:
+///
+///   * No A/B slot switching is performed. It always boot from *_a slot.
+///   * No dynamic partitions.
+///   * Only support V3/V4 image and Android 13+ (generic ramdisk from the "init_boot" partition)
+///   * Only support booting recovery from boot image
+///
+/// # Arguments
+/// * `ops`: the [GblOps] object providing platform-specific backends.
+/// * `load`: the combined buffer to load all images into.
+///
+/// # Returns
+/// Returns a tuple of 4 slices corresponding to:
+///   (ramdisk load buffer, FDT load buffer, kernel load buffer, unused buffer).
+pub fn load_android_simple<'a, 'b, 'c>(
+    ops: &mut impl GblOps<'b, 'c>,
+    load: &'a mut [u8],
+) -> Result<(&'a mut [u8], &'a mut [u8], &'a mut [u8], &'a mut [u8])> {
+    const PAGE_SIZE: usize = 4096; // V3/V4 image has fixed page size 4096;
+
+    let (bcb_buffer, load) = load.split_at_mut(BootloaderMessage::SIZE_BYTES);
+    ops.read_from_partition_sync("misc", 0, bcb_buffer)?;
+    let bcb = BootloaderMessage::from_bytes_ref(bcb_buffer)?;
+    let boot_mode = bcb.boot_mode()?;
+    gbl_println!(ops, "boot mode from BCB: {}", boot_mode);
+
+    // TODO(b/370317273): use high level abstraction over boot to avoid working
+    // with offsets on application level.
+    // Parse boot header.
+    let (boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
+    ops.read_from_partition_sync("boot_a", 0, boot_header_buffer)?;
+    let boot_header = BootImage::parse(boot_header_buffer).map_err(Error::from)?;
+    let (
+        kernel_size,
+        boot_cmdline,
+        kernel_hdr_size,
+        boot_ramdisk_size,
+        boot_second_size,
+        boot_dtb_size,
+    ) = boot_header_elements(&boot_header)?;
+    gbl_println!(ops, "boot image size: {}", kernel_size);
+    gbl_println!(ops, "boot image cmdline: \"{}\"", boot_cmdline);
+    gbl_println!(ops, "boot ramdisk size: {}", boot_ramdisk_size);
+    gbl_println!(ops, "boot dtb size: {}", boot_dtb_size);
+
+    // TODO(b/370317273): use high level abstraction over vendor_boot to avoid working
+    // with offsets on application level.
+    // Parse vendor boot header.
+    let (vendor_boot_header_buffer, load) = load.split_at_mut(PAGE_SIZE);
+    let vendor_boot_header;
+    let (
+        vendor_ramdisk_size,
+        vendor_hdr_size,
+        vendor_cmdline,
+        vendor_page_size,
+        vendor_dtb_size,
+        vendor_bootconfig_size,
+        vendor_ramdisk_table_size,
+    ) = match ops.partition_size("vendor_boot_a") {
+        Ok(Some(_sz)) => {
+            ops.read_from_partition_sync("vendor_boot_a", 0, vendor_boot_header_buffer)?;
+            vendor_boot_header =
+                VendorImageHeader::parse(vendor_boot_header_buffer).map_err(Error::from)?;
+            vendor_header_elements(&vendor_boot_header)?
+        }
+        _ => (0 as usize, 0 as usize, "", 0 as usize, 0 as usize, 0 as usize, 0),
+    };
+
+    gbl_println!(ops, "vendor ramdisk size: {}", vendor_ramdisk_size);
+    gbl_println!(ops, "vendor cmdline: \"{}\"", vendor_cmdline);
+    gbl_println!(ops, "vendor dtb size: {}", vendor_dtb_size);
+
+    let (dtbo_buffer, load) = match ops.partition_size("dtbo_a") {
+        Ok(Some(sz)) => {
+            let (dtbo_buffer, load) = load.split_at_mut(sz.try_into().unwrap());
+            ops.read_from_partition_sync("dtbo_a", 0, dtbo_buffer)?;
+            (Some(dtbo_buffer), load)
+        }
+        _ => (None, load),
+    };
+
+    let mut components: DeviceTreeComponentsRegistry<'a> = DeviceTreeComponentsRegistry::new();
+    let load = match dtbo_buffer {
+        Some(ref dtbo_buffer) => {
+            let dtbo_table = DtTableImage::from_bytes(dtbo_buffer)?;
+            components.append_from_dtbo(&dtbo_table, load)?
+        }
+        _ => load,
+    };
+
+    // First: check for custom FDT (Cuttlefish).
+    let load = if ops.get_custom_device_tree().is_none() {
+        // Second: "vendor_boot" FDT.
+        let (source, part, offset, size) = if vendor_dtb_size > 0 {
+            // DTB is located after the header and ramdisk (aligned).
+            let offset = (SafeNum::from(vendor_hdr_size) + SafeNum::from(vendor_ramdisk_size))
+                .round_up(vendor_page_size)
+                .try_into()
+                .map_err(Error::from)?;
+            (DeviceTreeComponentSource::VendorBoot, "vendor_boot_a", offset, vendor_dtb_size)
+        // Third: "boot" FDT.
+        } else if boot_dtb_size > 0 {
+            // DTB is located after the header, kernel, ramdisk, and second images (aligned).
+            let mut offset = SafeNum::from(kernel_hdr_size);
+            for image_size in [kernel_size, boot_ramdisk_size, boot_second_size] {
+                offset += SafeNum::from(image_size).round_up(kernel_hdr_size);
+            }
+            (
+                DeviceTreeComponentSource::Boot,
+                "boot_a",
+                offset.try_into().map_err(Error::from)?,
+                boot_dtb_size,
+            )
+        } else {
+            return Err(Error::NoFdt.into());
+        };
+
+        let (fdt_buffer, load) = aligned_subslice(load, FDT_ALIGNMENT)?.split_at_mut(size);
+        ops.read_from_partition_sync(part, offset, fdt_buffer)?;
+        components.append(ops, source, fdt_buffer, load)?
+    } else {
+        load
+    };
+
+    // Parse init_boot header
+    let init_boot_header_buffer = &mut load[..PAGE_SIZE];
+    let (generic_ramdisk_size, init_boot_hdr_size) = match ops.partition_size("init_boot_a") {
+        Ok(Some(_sz)) => {
+            ops.read_from_partition_sync("init_boot_a", 0, init_boot_header_buffer)?;
+            let init_boot_header =
+                BootImage::parse(init_boot_header_buffer).map_err(Error::from)?;
+            match init_boot_header {
+                BootImage::V3(ref hdr) => (hdr.ramdisk_size as usize, PAGE_SIZE),
+                BootImage::V4(ref hdr) => (hdr._base.ramdisk_size as usize, PAGE_SIZE),
+                _ => {
+                    gbl_println!(ops, "V0/V1/V2 images are not supported");
+                    return Err(Error::UnsupportedVersion.into());
+                }
+            }
+        }
+        _ => (0, 0),
+    };
+    gbl_println!(ops, "init_boot image size: {}", generic_ramdisk_size);
+
+    // Load and prepare various images.
+    let images_buffer = aligned_subslice(load, KERNEL_ALIGNMENT)?;
+    let load = &mut images_buffer[..];
+
+    // Load kernel
+    // Kernel may need to reserve additional memory after itself. To avoid the risk of this
+    // memory overlapping with ramdisk. We place kernel after ramdisk. We first load it to the tail
+    // of the buffer and move it forward as much as possible after ramdisk and fdt are loaded,
+    // fixed-up and finalized.
+    let boot_img_load_offset: usize = {
+        let off = SafeNum::from(load.len()) - kernel_size - boot_ramdisk_size;
+        let off_idx: usize = off.try_into().map_err(Error::from)?;
+        let aligned_off = off - (&load[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
+        aligned_off.try_into().map_err(Error::from)?
+    };
+    let (load, boot_img_buffer) = load.split_at_mut(boot_img_load_offset);
+    ops.read_from_partition_sync(
+        "boot_a",
+        kernel_hdr_size.try_into().unwrap(),
+        &mut boot_img_buffer[..kernel_size + boot_ramdisk_size],
+    )?;
+
+    // Load vendor ramdisk
+    let mut ramdisk_load_curr = SafeNum::ZERO;
+    if vendor_ramdisk_size > 0 {
+        ops.read_from_partition_sync(
+            "vendor_boot_a",
+            u64::try_from(vendor_hdr_size).map_err(Error::from)?,
+            &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..vendor_ramdisk_size],
+        )?;
+    }
+    ramdisk_load_curr += vendor_ramdisk_size;
+
+    // Load generic ramdisk
+    if generic_ramdisk_size > 0 {
+        ops.read_from_partition_sync(
+            "init_boot_a",
+            init_boot_hdr_size.try_into().unwrap(),
+            &mut load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..generic_ramdisk_size],
+        )?;
+        ramdisk_load_curr += generic_ramdisk_size;
+    }
+
+    // Load ramdisk from boot image
+    if boot_ramdisk_size > 0 {
+        load[ramdisk_load_curr.try_into().map_err(Error::from)?..][..boot_ramdisk_size]
+            .copy_from_slice(&boot_img_buffer[kernel_size..][..boot_ramdisk_size]);
+        ramdisk_load_curr += boot_ramdisk_size;
+    }
+
+    // Prepare partition data for avb verification
+    let (vendor_boot_load_buffer, remains) = load.split_at_mut(vendor_ramdisk_size);
+    let (init_boot_load_buffer, remains) = remains.split_at_mut(generic_ramdisk_size);
+    let (_boot_ramdisk_load_buffer, remains) = remains.split_at_mut(boot_ramdisk_size);
+    // Prepare a BootConfigBuilder to add avb generated bootconfig.
+    let mut bootconfig_builder = BootConfigBuilder::new(remains)?;
+    // Perform avb verification.
+    avb_verify_slot(
+        ops,
+        boot_img_buffer,
+        vendor_boot_load_buffer,
+        init_boot_load_buffer,
+        dtbo_buffer.as_deref(),
+        &mut bootconfig_builder,
+    )?;
+
+    // Move kernel to end of the boot image buffer
+    let (_boot_img_buffer, kernel_tail_buffer) = {
+        let off = SafeNum::from(boot_img_buffer.len()) - kernel_size;
+        let off_idx: usize = off.try_into().map_err(Error::from)?;
+        let aligned_off = off - (&boot_img_buffer[off_idx] as *const _ as usize % KERNEL_ALIGNMENT);
+        let aligned_off_idx = aligned_off.try_into().map_err(Error::from)?;
+        boot_img_buffer.copy_within(0..kernel_size, aligned_off_idx);
+        boot_img_buffer.split_at_mut(aligned_off_idx)
+    };
+
+    // Add slot index
+    bootconfig_builder.add("androidboot.slot_suffix=_a\n")?;
+
+    match boot_mode {
+        // TODO(b/329716686): Support bootloader mode
+        AndroidBootMode::Normal | AndroidBootMode::BootloaderBootOnce => {
+            bootconfig_builder.add("androidboot.force_normal_boot=1\n")?
+        }
+        _ => {
+            // Do nothing
+        }
+    }
+
+    // V4 image has vendor bootconfig.
+    if vendor_bootconfig_size > 0 {
+        let mut bootconfig_offset = SafeNum::from(vendor_hdr_size);
+        for image_size in [vendor_ramdisk_size, vendor_dtb_size, vendor_ramdisk_table_size] {
+            bootconfig_offset += SafeNum::from(image_size).round_up(vendor_page_size);
+        }
+        bootconfig_builder.add_with(|_, out| {
+            ops.read_from_partition_sync(
+                "vendor_boot_a",
+                bootconfig_offset.try_into()?,
+                &mut out[..vendor_bootconfig_size as usize],
+            )?;
+            Ok(vendor_bootconfig_size as usize)
+        })?;
+    }
+
+    // TODO(b/353272981): Handle buffer too small
+    bootconfig_builder.add_with(|bytes, out| {
+        // TODO(b/353272981): Verify provided bootconfig and fail here
+        Ok(ops.fixup_bootconfig(&bytes, out)?.map(|slice| slice.len()).unwrap_or(0))
+    })?;
+    gbl_println!(ops, "final bootconfig: \"{}\"", bootconfig_builder);
+
+    ramdisk_load_curr += bootconfig_builder.config_bytes().len();
+
+    // On ARM, we may need to decompress the kernel and re-split the buffer to the new kernel size.
+    #[cfg(target_arch = "aarch64")]
+    let (load, kernel_size, kernel_tail_buffer) = {
+        let kernel_size = kernel_tail_buffer.len();
+        let compressed_kernel_offset = images_buffer.len() - kernel_size;
+        let decompressed_kernel_offset =
+            decompress_kernel(ops, images_buffer, compressed_kernel_offset)?;
+        let (load, kernel_tail_buffer) = images_buffer.split_at_mut(decompressed_kernel_offset);
+        (load, kernel_tail_buffer.len(), kernel_tail_buffer)
+    };
+
+    // Use the remaining load buffer for the FDT.
+    let (ramdisk_load_buffer, load) =
+        load.split_at_mut(ramdisk_load_curr.try_into().map_err(Error::from)?);
+
+    let (base, overlays): (&[u8], &[&[u8]]) = if let Some(custom_fdt) = ops.get_custom_device_tree()
+    {
+        (custom_fdt, &[])
+    } else {
+        ops.select_device_trees(&mut components)?;
+        components.selected()?
+    };
+
+    let fdt_buffer = aligned_subslice(load, FDT_ALIGNMENT)?;
+    let mut fdt = Fdt::new_from_init(fdt_buffer, base)?;
+
+    gbl_println!(ops, "Applying {} overlays", overlays.len());
+    fdt.multioverlay_apply(overlays)?;
+    gbl_println!(ops, "Overlays applied");
+
+    // Add ramdisk range to FDT
+    let ramdisk_addr: u64 =
+        (ramdisk_load_buffer.as_ptr() as usize).try_into().map_err(Error::from)?;
+    let ramdisk_end: u64 =
+        ramdisk_addr + u64::try_from(ramdisk_load_buffer.len()).map_err(Error::from)?;
+    fdt.set_property("chosen", c"linux,initrd-start", &ramdisk_addr.to_be_bytes())?;
+    fdt.set_property("chosen", c"linux,initrd-end", &ramdisk_end.to_be_bytes())?;
+    gbl_println!(ops, "linux,initrd-start: {:#x}", ramdisk_addr);
+    gbl_println!(ops, "linux,initrd-end: {:#x}", ramdisk_end);
+
+    // Update the FDT commandline.
+    let device_tree_commandline_length = match fdt.get_property("chosen", BOOTARGS_PROP) {
+        Ok(val) => CStr::from_bytes_until_nul(val).map_err(Error::from)?.to_bytes().len(),
+        Err(_) => 0,
+    };
+
+    // Reserve 1024 bytes for separators and fixup.
+    let final_commandline_len =
+        device_tree_commandline_length + boot_cmdline.len() + vendor_cmdline.len() + 1024;
+    let final_commandline_buffer =
+        fdt.set_property_placeholder("chosen", BOOTARGS_PROP, final_commandline_len)?;
+
+    let mut commandline_builder =
+        CommandlineBuilder::new_from_prefix(&mut final_commandline_buffer[..])?;
+    commandline_builder.add(boot_cmdline)?;
+    commandline_builder.add(vendor_cmdline)?;
+
+    // TODO(b/353272981): Handle buffer too small
+    commandline_builder.add_with(|current, out| {
+        // TODO(b/353272981): Verify provided command line and fail here.
+        Ok(ops.fixup_os_commandline(current, out)?.map(|fixup| fixup.len()).unwrap_or(0))
+    })?;
+    gbl_println!(ops, "final cmdline: \"{}\"", commandline_builder.as_str());
+
+    // Make sure we provide an actual device tree size, so FW can calculate amount of space
+    // available for fixup.
+    fdt.shrink_to_fit()?;
+    // TODO(b/353272981): Make a copy of current device tree and verify provided fixup.
+    // TODO(b/353272981): Handle buffer too small
+    ops.fixup_device_tree(fdt.as_mut())?;
+    fdt.shrink_to_fit()?;
+
+    // Move the kernel backward as much as possible to preserve more space after it. This is
+    // necessary in case the input buffer is at the end of address space.
+    let kernel_tail_buffer_size = kernel_tail_buffer.len();
+    let ramdisk_load_buffer_size = ramdisk_load_buffer.len();
+    let fdt_len = fdt.header_ref()?.actual_size();
+    // Split out the ramdisk.
+    let (ramdisk, remains) = images_buffer.split_at_mut(ramdisk_load_buffer_size);
+    // Split out the fdt.
+    let (fdt, kernel) = aligned_subslice(remains, FDT_ALIGNMENT)?.split_at_mut(fdt_len);
+    // Move the kernel backward as much as possible.
+    let kernel = aligned_subslice(kernel, KERNEL_ALIGNMENT)?;
+    let kernel_start = kernel.len().checked_sub(kernel_tail_buffer_size).unwrap();
+    kernel.copy_within(kernel_start..kernel_start.checked_add(kernel_size).unwrap(), 0);
+    // Split out the remaining buffer.
+    let (kernel, remains) = kernel.split_at_mut(kernel_size);
+
+    Ok((ramdisk, fdt, kernel, remains))
+}
diff --git a/gbl/libgbl/src/constants.rs b/gbl/libgbl/src/constants.rs
new file mode 100644
index 0000000..4e195ec
--- /dev/null
+++ b/gbl/libgbl/src/constants.rs
@@ -0,0 +1,104 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This file provides common constants that are used in GBL
+
+// TODO(b/380392958) Cleanup other used of the constants. Move them here as well.
+
+use core::fmt::{Debug, Display, Formatter};
+use liberror::Error;
+use static_assertions::const_assert_eq;
+
+macro_rules! KiB  (
+    ($x:expr) => {
+        $x*1024
+    }
+);
+const_assert_eq!(KiB!(1), 1024);
+const_assert_eq!(KiB!(5), 5 * 1024);
+
+macro_rules! MiB  (
+    ($x:expr) => {
+        $x*KiB!(1024)
+    }
+);
+const_assert_eq!(MiB!(1), 1024 * 1024);
+const_assert_eq!(MiB!(5), 5 * 1024 * 1024);
+
+/// Kernel image alignment requirement.
+pub const KERNEL_ALIGNMENT: usize = MiB!(2);
+
+/// Zircon Kernel image alignment requirement.
+pub const ZIRCON_KERNEL_ALIGNMENT: usize = KiB!(64);
+
+/// FDT image alignment requirement.
+pub const FDT_ALIGNMENT: usize = 8;
+
+/// Expected max size for BootCmd zbi item.
+pub const BOOTCMD_SIZE: usize = KiB!(16);
+
+/// Page size
+pub const PAGE_SIZE: usize = KiB!(4);
+
+/// Image names list.
+/// Used for identifying what buffer size/alignment is necessary.
+#[derive(Debug, PartialEq, Clone)]
+pub enum ImageName {
+    /// ZBI for Zircon kernel
+    ZbiZircon,
+    /// ZBI items
+    ZbiItems,
+    /// Boot
+    Boot,
+    /// FDT
+    Fdt,
+}
+
+impl ImageName {
+    /// Get alignment required for the [ImageName]
+    pub fn alignment(&self) -> usize {
+        match self {
+            Self::ZbiZircon => ZIRCON_KERNEL_ALIGNMENT,
+            Self::ZbiItems => PAGE_SIZE,
+            Self::Boot => KERNEL_ALIGNMENT,
+            Self::Fdt => FDT_ALIGNMENT,
+        }
+    }
+}
+
+impl Display for ImageName {
+    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
+        let str = match self {
+            ImageName::ZbiZircon => "zbi_zircon",
+            ImageName::ZbiItems => "zbi_items",
+            ImageName::Boot => "boot",
+            ImageName::Fdt => "fdt",
+        };
+        write!(f, "{str}")
+    }
+}
+
+impl TryFrom<&str> for ImageName {
+    type Error = Error;
+
+    fn try_from(value: &str) -> Result<Self, Self::Error> {
+        Ok(match value {
+            "zbi_zircon" => ImageName::ZbiZircon,
+            "zbi_items" => ImageName::ZbiItems,
+            "boot" => ImageName::Boot,
+            "fdt" => ImageName::Fdt,
+            _ => return Err(Error::InvalidInput),
+        })
+    }
+}
diff --git a/gbl/efi/arch/aarch64/src/lib.rs b/gbl/libgbl/src/decompress.rs
similarity index 82%
rename from gbl/efi/arch/aarch64/src/lib.rs
rename to gbl/libgbl/src/decompress.rs
index 51d7059..6a9f63b 100644
--- a/gbl/efi/arch/aarch64/src/lib.rs
+++ b/gbl/libgbl/src/decompress.rs
@@ -12,14 +12,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-//! ARM-specific library for GBL EFI application.
-#![cfg_attr(not(test), no_std)]
+//! Image decompression support.
 
-// Decompression is done on the heap
+// gzip [DeflateDecoder] requires heap allocation. LZ4 decompression currently uses the heap but
+// could potentially be adjusted to use preallocated buffers if necessary.
 extern crate alloc;
 
+use crate::{gbl_print, gbl_println, GblOps};
 use liberror::{Error, Result};
-use libgbl::{gbl_print, gbl_println, GblOps};
 use lz4_flex::decompress_into;
 use zune_inflate::DeflateDecoder;
 
@@ -31,8 +31,8 @@ use zune_inflate::DeflateDecoder;
 /// # Returns
 /// The offset of the decompressed kernel in `buffer`. If the kernel was not compressed. this
 /// function is a no-op and will return `kernel_start` unchanged.
-pub fn decompress_kernel<'a>(
-    ops: &mut impl GblOps<'a>,
+pub fn decompress_kernel<'a, 'b>(
+    ops: &mut impl GblOps<'a, 'b>,
     buffer: &mut [u8],
     kernel_start: usize,
 ) -> Result<usize> {
@@ -90,25 +90,24 @@ pub fn decompress_kernel<'a>(
 #[cfg(test)]
 mod test {
     use super::*;
-    use efi_mocks::MockEfi;
+    use crate::ops::test::FakeGblOps;
 
     #[test]
-    fn ops_write_trait() {
-        let mut mock_efi = MockEfi::new();
-        let installed = mock_efi.install();
-
+    fn decompress_kernel_lz4() {
         let original_data = "Test TTTTTTTTT 123";
         let compressed_data = [
             0x02, 0x21, 0x4c, 0x18, 0x0f, 0x00, 0x00, 0x00, 0x63, 0x54, 0x65, 0x73, 0x74, 0x20,
             0x54, 0x01, 0x00, 0x50, 0x54, 0x20, 0x31, 0x32, 0x33,
         ];
 
-        let buffer = vec![0u8; 8 * 1024];
-        // Copy compressed data somewhere in buffer.
-        buffer[buffer.len() - compressed_data.len()..].clone_from_slice(compressed_data);
+        // Create a buffer with the compressed data at the end.
+        let mut buffer = vec![0u8; 8 * 1024];
+        let compressed_offset = buffer.len() - compressed_data.len();
+        buffer[compressed_offset..].clone_from_slice(&compressed_data[..]);
 
         let offset =
-            decompress_kernel(installed.entry(), buffer, buffer.len() - compressed_data.len());
-        assert_eq!(buffer[offset..], original_data);
+            decompress_kernel(&mut FakeGblOps::default(), &mut buffer[..], compressed_offset)
+                .unwrap();
+        assert_eq!(&buffer[offset..], original_data.as_bytes());
     }
 }
diff --git a/gbl/libgbl/src/device_tree.rs b/gbl/libgbl/src/device_tree.rs
new file mode 100644
index 0000000..5f9349c
--- /dev/null
+++ b/gbl/libgbl/src/device_tree.rs
@@ -0,0 +1,598 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! GblOps trait that defines device tree components helpers.
+
+use crate::{gbl_print, gbl_println, GblOps};
+use arrayvec::ArrayVec;
+use dttable::{DtTableImage, DtTableMetadata};
+use fdt::{Fdt, FdtHeader, FDT_HEADER_SIZE};
+use liberror::{Error, Result};
+use libutils::aligned_subslice;
+
+/// Device tree alignment.
+pub const FDT_ALIGNMENT: usize = 8;
+/// Maximum amount of device tree components GBL can handle to select from.
+/// TODO(b/353272981): Use dynamic memory to store components. Currently
+/// DeviceTreeComponentsRegistry takes about 18kb of stack, which can be slow and dangerous.
+pub const MAXIMUM_DEVICE_TREE_COMPONENTS: usize = 256;
+/// Error message to fail in case of unsupported amount of device tree components.
+pub const MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG: &str =
+    "At most 256 device components are supported to build the final one";
+
+/// The source device tree component is coming from.
+#[derive(Copy, Clone, Eq, PartialEq, Debug)]
+pub enum DeviceTreeComponentSource {
+    /// Loaded from Boot partition.
+    Boot,
+    /// Loaded from Vendor Boot partition.
+    VendorBoot,
+    /// Loaded from DTB partition.
+    Dtb(DtTableMetadata),
+    /// Loaded from DTBO partition.
+    Dtbo(DtTableMetadata),
+}
+
+impl core::fmt::Display for DeviceTreeComponentSource {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        match self {
+            DeviceTreeComponentSource::Boot => write!(f, "Boot"),
+            DeviceTreeComponentSource::VendorBoot => write!(f, "VendorBoot"),
+            DeviceTreeComponentSource::Dtb(_) => write!(f, "Dtb"),
+            DeviceTreeComponentSource::Dtbo(_) => write!(f, "Dtbo"),
+        }
+    }
+}
+
+/// Device tree component (device tree or overlay) to build the final one.
+#[derive(Copy, Clone, Eq, PartialEq, Debug)]
+pub struct DeviceTreeComponent<'a> {
+    /// Source the component is loaded from.
+    pub source: DeviceTreeComponentSource,
+    /// Device tree component payload. Must be 8 bytes aligned.
+    pub dt: &'a [u8],
+    /// Device tree component is selected.
+    pub selected: bool,
+}
+
+/// Maintain, select and get the device tree components to build the final device tree.
+pub struct DeviceTreeComponentsRegistry<'a> {
+    components: ArrayVec<DeviceTreeComponent<'a>, MAXIMUM_DEVICE_TREE_COMPONENTS>,
+    /// `selected_overlays` array is used to return selected overlays as a sequential reference
+    /// slice. It must only be used within the `selected()` method and must not be assumed
+    /// valid elsewhere.
+    selected_overlays: ArrayVec<&'a [u8], MAXIMUM_DEVICE_TREE_COMPONENTS>,
+}
+
+impl<'a> DeviceTreeComponent<'a> {
+    /// Whether device tree component is base device tree or overlay.
+    pub fn is_base_device_tree(&self) -> bool {
+        matches!(
+            self.source,
+            DeviceTreeComponentSource::Boot
+                | DeviceTreeComponentSource::VendorBoot
+                | DeviceTreeComponentSource::Dtb(_)
+        )
+    }
+}
+
+impl<'a> DeviceTreeComponentsRegistry<'a> {
+    /// Create new empty DeviceTreeComponentsRegistry.
+    pub fn new() -> Self {
+        DeviceTreeComponentsRegistry {
+            components: ArrayVec::new(),
+            selected_overlays: ArrayVec::new(),
+        }
+    }
+
+    /// Load device tree components from a dt table image. Ensure components are 8 bytes
+    /// aligned by using provided buffer to cut from. Returns remain buffer.
+    fn append_from_dttable<'b>(
+        &mut self,
+        is_dtb: bool,
+        dttable: &DtTableImage<'b>,
+        buffer: &'a mut [u8],
+    ) -> Result<&'a mut [u8]> {
+        if dttable.entries_count() > self.components.remaining_capacity() {
+            return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
+        }
+
+        let mut remains = buffer;
+        for entry in dttable.entries() {
+            // TODO(b/374336105): Find a better way to handle 8-bytes alignment rather than copy.
+            let (aligned_buffer, rest) = aligned_subslice(remains, FDT_ALIGNMENT)?
+                .split_at_mut_checked(entry.dtb.len())
+                .ok_or(Error::Other(Some(
+                    "Provided buffer is too small to ensure dttable entry is aligned",
+                )))?;
+            aligned_buffer.copy_from_slice(entry.dtb);
+
+            self.components.push(DeviceTreeComponent {
+                source: if is_dtb {
+                    DeviceTreeComponentSource::Dtb(entry.metadata)
+                } else {
+                    DeviceTreeComponentSource::Dtbo(entry.metadata)
+                },
+                dt: aligned_buffer,
+                selected: false,
+            });
+
+            remains = rest;
+        }
+
+        Ok(remains)
+    }
+
+    /// Load device tree components from a dtbo image. Ensure components are 8 bytes
+    /// aligned by using provided `buffer` to cut from. Returns remain buffer.
+    pub fn append_from_dtbo<'b>(
+        &mut self,
+        dttable: &DtTableImage<'b>,
+        buffer: &'a mut [u8],
+    ) -> Result<&'a mut [u8]> {
+        self.append_from_dttable(false, dttable, buffer)
+    }
+
+    /// Append additional device trees from the buffer, where they are stored sequentially.
+    /// Ensure components are 8 bytes aligned by using provided buffer to cut from. Returns remain
+    /// buffer.
+    /// TODO(b/363244924): Remove after partners migrated to DTB.
+    fn append_from_multifdt_buffer<'b, 'c>(
+        &mut self,
+        ops: &mut impl GblOps<'b, 'c>,
+        source: DeviceTreeComponentSource,
+        data: &'a [u8],
+        buffer: &'a mut [u8],
+    ) -> Result<&'a mut [u8]> {
+        let mut components_added = 0;
+        let mut data_remains = data;
+        let mut buffer_remains = buffer;
+        while data_remains.len() >= FDT_HEADER_SIZE {
+            let aligned_buffer = aligned_subslice(buffer_remains, FDT_ALIGNMENT)?;
+
+            let header_slice = aligned_buffer.get_mut(..FDT_HEADER_SIZE).ok_or(Error::Other(
+                Some("Provided buffer is too small to ensure multidt entry is aligned"),
+            ))?;
+            // Fdt header must be aligned, so copy to an aligned buffer.
+            header_slice.copy_from_slice(&data_remains[..FDT_HEADER_SIZE]);
+            let next_fdt_size = FdtHeader::from_bytes_ref(header_slice)?.totalsize();
+
+            if self.components.is_full() {
+                return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
+            }
+
+            // Cut fdt and temporary buffers to make sure result fdt is 8 bytes aligned
+            let (data_buffer, data_buffer_remains) =
+                data_remains.split_at_checked(next_fdt_size).ok_or(Error::Other(Some(
+                    "Multidt structure has a valid header but doesn't have a device tree payload",
+                )))?;
+            let (aligned_buffer, aligned_buffer_remains) =
+                aligned_buffer.split_at_mut_checked(next_fdt_size).ok_or(Error::Other(Some(
+                    "Provided buffer is too small to ensure multidt entry is aligned",
+                )))?;
+            aligned_buffer.copy_from_slice(data_buffer);
+
+            Fdt::new(&aligned_buffer)?;
+            self.components.push(DeviceTreeComponent {
+                source: source,
+                dt: &aligned_buffer[..],
+                selected: false,
+            });
+
+            components_added += 1;
+            data_remains = data_buffer_remains;
+            buffer_remains = aligned_buffer_remains;
+        }
+
+        if components_added > 0 {
+            gbl_println!(
+                ops,
+                "WARNING: {} additional device trees detected in {}. This is only temporarily \
+                supported in GBL. Please migrate to the DTB partition to provide multiple device \
+                trees for selection.",
+                components_added,
+                source,
+            );
+        }
+
+        Ok(buffer_remains)
+    }
+
+    /// Append device tree components from provided buffer prefix. `fdt` must be a 8 bytes aligned
+    /// valid fdt buffer. `fdt` may also have multiple fdt buffers placed sequentially. Ensure each
+    /// of such components are 8 bytes aligned by using provided `buffer` to cut from. Returns
+    /// remain buffer.
+    /// TODO(b/363244924): Remove multiple fdt support after partners migrated to DTB.
+    pub fn append<'b, 'c>(
+        &mut self,
+        ops: &mut impl GblOps<'b, 'c>,
+        source: DeviceTreeComponentSource,
+        fdt: &'a [u8],
+        buffer: &'a mut [u8],
+    ) -> Result<&'a mut [u8]> {
+        if self.components.is_full() {
+            return Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)));
+        }
+
+        let header = FdtHeader::from_bytes_ref(fdt)?;
+        let (fdt_buffer, fdt_remains) = fdt.split_at(header.totalsize());
+        self.components.push(DeviceTreeComponent {
+            source: source,
+            dt: fdt_buffer,
+            selected: false,
+        });
+
+        // TODO(b/363244924): Remove after partners migrated to DTB.
+        self.append_from_multifdt_buffer(ops, source, fdt_remains, buffer)
+    }
+
+    /// Default implementation of selected logic in case external one isn't provided.
+    /// Only base device tree is supported to choose from. Otherwise fail. No overlays will be
+    /// selected.
+    pub fn autoselect(&mut self) -> Result<()> {
+        let base_device_tree_count =
+            self.components.iter().filter(|component| component.is_base_device_tree()).count();
+        if base_device_tree_count > 1 {
+            return Err(Error::Other(Some(
+                "Base device tree autoselection isn't supported if multiple device trees are \
+                provided",
+            )));
+        }
+
+        let base = self
+            .components
+            .iter_mut()
+            .find(|component| component.is_base_device_tree())
+            .ok_or(Error::Other(Some("0 base device trees to autoselect from")))?;
+        base.selected = true;
+
+        Ok(())
+    }
+
+    /// Return selected base device tree and overlays to apply. Fail in case selection isn't
+    /// correct. For correctness rules refer to `GblOps.select_device_trees` requirements.
+    pub fn selected(&mut self) -> Result<(&[u8], &[&[u8]])> {
+        let base_device_tree_count = self
+            .components
+            .iter()
+            .filter(|component| component.is_base_device_tree() && component.selected)
+            .count();
+        if base_device_tree_count > 1 {
+            return Err(Error::Other(Some("More than 1 base device tree is selected")));
+        }
+
+        let base = self
+            .components
+            .iter()
+            .find(|component| component.is_base_device_tree() && component.selected)
+            .ok_or(Error::Other(Some("0 base device trees are selected")))?;
+
+        self.selected_overlays = self
+            .components
+            .iter()
+            .filter(|component| !component.is_base_device_tree() && component.selected)
+            .map(|component| component.dt)
+            .collect();
+
+        Ok((base.dt, &self.selected_overlays[..]))
+    }
+
+    /// Iterator over components.
+    pub fn components(&self) -> impl Iterator<Item = &DeviceTreeComponent<'a>> {
+        self.components.iter()
+    }
+
+    /// Mutable iterator over components.
+    pub fn components_mut(&mut self) -> impl Iterator<Item = &mut DeviceTreeComponent<'a>> {
+        self.components.iter_mut()
+    }
+}
+
+#[cfg(test)]
+pub(crate) mod test {
+    use super::*;
+    use crate::ops::test::FakeGblOps;
+
+    #[test]
+    fn test_components_registry_empty() {
+        let registry = DeviceTreeComponentsRegistry::new();
+
+        assert_eq!(registry.components().count(), 0);
+    }
+
+    #[test]
+    fn test_components_registry_append_component() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        registry
+            .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], &mut buffer)
+            .unwrap();
+
+        assert_eq!(registry.components().count(), 1);
+
+        let component = registry.components().next().unwrap();
+
+        assert_eq!(
+            component,
+            &DeviceTreeComponent {
+                source: DeviceTreeComponentSource::Boot,
+                dt: &dt[..],
+                selected: false,
+            }
+        );
+        assert!(component.is_base_device_tree());
+    }
+
+    #[test]
+    fn test_components_registry_append_too_many_components() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let mut current_buffer = &mut buffer[..];
+        // Fill the whole reserved space
+        for _ in 0..MAXIMUM_DEVICE_TREE_COMPONENTS {
+            current_buffer = registry
+                .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer)
+                .unwrap();
+        }
+
+        assert_eq!(
+            registry.append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer),
+            Err(Error::Other(Some(MAXIMUM_DEVICE_TREE_COMPONENTS_ERROR_MSG)))
+        );
+    }
+
+    #[test]
+    fn test_components_append_from_dtbo() {
+        let dttable = include_bytes!("../../libdttable/test/data/dttable.img").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let table = DtTableImage::from_bytes(&dttable[..]).unwrap();
+        registry.append_from_dtbo(&table, &mut buffer[..]).unwrap();
+
+        // Check data is loaded
+        let components: Vec<_> = registry.components().cloned().collect();
+        let expected_components: Vec<DeviceTreeComponent> = table
+            .entries()
+            .map(|e| DeviceTreeComponent {
+                source: DeviceTreeComponentSource::Dtbo(e.metadata),
+                dt: e.dtb,
+                selected: false,
+            })
+            .collect();
+        assert_eq!(components, expected_components);
+
+        // Check data is aligned
+        registry.components().for_each(|c| assert!(c.dt.as_ptr().align_offset(FDT_ALIGNMENT) == 0));
+    }
+
+    #[test]
+    fn test_components_returns_selected() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let sources = [
+            DeviceTreeComponentSource::VendorBoot,
+            DeviceTreeComponentSource::Boot,
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+        ];
+        let mut current_buffer = &mut buffer[..];
+        for source in sources.iter() {
+            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
+        }
+
+        // Select base device tree
+        registry.components_mut().nth(1).unwrap().selected = true;
+        // Select first overlay
+        registry.components_mut().nth(2).unwrap().selected = true;
+        // Select second overlay
+        registry.components_mut().nth(3).unwrap().selected = true;
+
+        let expected_overlays =
+            &[registry.components().nth(2).unwrap().dt, registry.components().nth(3).unwrap().dt];
+        // Expected selected data
+        let expected_selected = (registry.components().nth(1).unwrap().dt, &expected_overlays[..]);
+
+        assert_eq!(registry.selected().unwrap(), expected_selected);
+    }
+
+    #[test]
+    fn test_components_returns_selected_no_overlays() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let sources = [
+            DeviceTreeComponentSource::VendorBoot,
+            DeviceTreeComponentSource::Boot,
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+        ];
+        let mut current_buffer = &mut buffer[..];
+        for source in sources.iter() {
+            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
+        }
+
+        // Select base device tree
+        registry.components_mut().nth(1).unwrap().selected = true;
+
+        // Expected selected data
+        let expected_selected = (registry.components().nth(1).unwrap().dt, &[][..]);
+
+        assert_eq!(registry.selected().unwrap(), expected_selected);
+    }
+
+    #[test]
+    fn test_components_returns_no_base_device_tree_failed() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let sources = [
+            DeviceTreeComponentSource::VendorBoot,
+            DeviceTreeComponentSource::Boot,
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+        ];
+        let mut current_buffer = &mut buffer[..];
+        for source in sources.iter() {
+            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
+        }
+
+        // Select first overlay
+        registry.components_mut().nth(2).unwrap().selected = true;
+        // Select second overlay
+        registry.components_mut().nth(3).unwrap().selected = true;
+
+        assert!(registry.selected().is_err());
+    }
+
+    #[test]
+    fn test_components_returns_multiple_base_device_trees_failed() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let sources = [
+            DeviceTreeComponentSource::VendorBoot,
+            DeviceTreeComponentSource::Boot,
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+        ];
+        let mut current_buffer = &mut buffer[..];
+        for source in sources.iter() {
+            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
+        }
+
+        // Select first base device tree
+        registry.components_mut().nth(0).unwrap().selected = true;
+        // Select second base device tree
+        registry.components_mut().nth(1).unwrap().selected = true;
+
+        assert!(registry.selected().is_err());
+    }
+
+    #[test]
+    fn test_components_autoselect() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let sources = [
+            DeviceTreeComponentSource::VendorBoot,
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+            DeviceTreeComponentSource::Dtbo(Default::default()),
+        ];
+        let mut current_buffer = &mut buffer[..];
+        for source in sources.iter() {
+            current_buffer = registry.append(&mut gbl_ops, *source, &dt, current_buffer).unwrap();
+        }
+
+        assert!(registry.autoselect().is_ok());
+
+        // Expected auto selected data
+        let expected_selected = (registry.components().nth(0).unwrap().dt, &[][..]);
+
+        assert_eq!(registry.selected().unwrap(), expected_selected);
+    }
+
+    #[test]
+    fn test_components_autoselect_no_overlays() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        registry
+            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], &mut buffer)
+            .unwrap();
+
+        assert!(registry.autoselect().is_ok());
+
+        // Expected auto selected data
+        let expected_selected = (registry.components().nth(0).unwrap().dt, &[][..]);
+
+        assert_eq!(registry.selected().unwrap(), expected_selected);
+    }
+
+    #[test]
+    fn test_components_autoselect_multiple_base_device_trees_failed() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        let mut current_buffer = &mut buffer[..];
+        current_buffer = registry
+            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], current_buffer)
+            .unwrap();
+        registry
+            .append(&mut gbl_ops, DeviceTreeComponentSource::Boot, &dt[..], current_buffer)
+            .unwrap();
+
+        assert!(registry.autoselect().is_err());
+    }
+
+    #[test]
+    fn test_components_autoselect_no_base_device_trees_failed() {
+        let dt = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        registry
+            .append(
+                &mut gbl_ops,
+                DeviceTreeComponentSource::Dtbo(Default::default()),
+                &dt[..],
+                &mut buffer,
+            )
+            .unwrap();
+
+        assert!(registry.autoselect().is_err());
+    }
+
+    #[test]
+    fn test_components_append_from_multifd() {
+        let half = include_bytes!("../../libfdt/test/data/base.dtb").to_vec();
+        let dt = [half.clone(), half].concat();
+        let mut buffer = vec![0u8; 2 * 1024 * 1024]; // 2 MB
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut registry = DeviceTreeComponentsRegistry::new();
+
+        registry
+            .append(&mut gbl_ops, DeviceTreeComponentSource::VendorBoot, &dt[..], &mut buffer)
+            .unwrap();
+
+        assert_eq!(registry.components().count(), 2);
+    }
+}
diff --git a/gbl/libgbl/src/fastboot/buffer_pool.rs b/gbl/libgbl/src/fastboot/buffer_pool.rs
new file mode 100644
index 0000000..5f34106
--- /dev/null
+++ b/gbl/libgbl/src/fastboot/buffer_pool.rs
@@ -0,0 +1,96 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use super::shared::Shared;
+use core::{
+    mem::{swap, take},
+    ops::{Deref, DerefMut},
+};
+use gbl_async::yield_now;
+
+/// Provides interfaces for allocating and deallocating buffers.
+pub trait BufferPool {
+    /// The type that can be dereferenced into a buffer.
+    type Buffer: DerefMut<Target = [u8]>;
+
+    /// Allocates a buffer.
+    ///
+    /// * Returns Some(_) on success.
+    /// * Returns None if buffer is not available.
+    fn allocate(&mut self) -> Option<Self::Buffer>;
+
+    /// Deallocates a buffer.
+    fn deallocate(&mut self, buf: Self::Buffer);
+}
+
+// Implements for all types of fixed size preallocated buffers, including `&mut [&mut [u8]]`,
+// `Vec<Vec<u8>`, `&mut [Vec<u8>]` and `Vec<&mut [u8]>`.
+impl<B, T> BufferPool for T
+where
+    B: DerefMut<Target = [u8]> + Default, // Can be `&mut [u8]`, `Vec<u8>`
+    T: DerefMut<Target = [B]>,            // Can be `&mut [B]`, `Vec<B>`
+{
+    type Buffer = B;
+
+    fn allocate(&mut self) -> Option<B> {
+        self.iter_mut().find_map(|v| (v.len() > 0).then_some(take(v)))
+    }
+
+    fn deallocate(&mut self, mut buf: B) {
+        swap(&mut buf, self.iter_mut().find(|v| v.len() == 0).unwrap());
+    }
+}
+
+impl<T: BufferPool> Shared<T> {
+    // Try allocate a [ScopedBuffer]
+    pub(crate) fn allocate(&self) -> Option<ScopedBuffer<T>> {
+        self.borrow_mut().allocate().map(|v| ScopedBuffer { buf: Some(v), pool: self })
+    }
+
+    // Allocates a [ScopedBuffer] and waits until succeed.
+    pub(crate) async fn allocate_async(&self) -> ScopedBuffer<T> {
+        loop {
+            match self.allocate() {
+                Some(v) => return v,
+                _ => yield_now().await,
+            }
+        }
+    }
+}
+
+/// Represents a scoped buffer allocated by `BufferPool`.
+pub(crate) struct ScopedBuffer<'a, T: BufferPool> {
+    buf: Option<T::Buffer>,
+    pool: &'a Shared<T>,
+}
+
+impl<T: BufferPool> Drop for ScopedBuffer<'_, T> {
+    fn drop(&mut self) {
+        self.pool.borrow_mut().deallocate(self.buf.take().unwrap())
+    }
+}
+
+impl<T: BufferPool> Deref for ScopedBuffer<'_, T> {
+    type Target = [u8];
+
+    fn deref(&self) -> &Self::Target {
+        self.buf.as_ref().unwrap()
+    }
+}
+
+impl<T: BufferPool> DerefMut for ScopedBuffer<'_, T> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        self.buf.as_mut().unwrap()
+    }
+}
diff --git a/gbl/libgbl/src/fastboot/mod.rs b/gbl/libgbl/src/fastboot/mod.rs
index 22c731b..ebcee8e 100644
--- a/gbl/libgbl/src/fastboot/mod.rs
+++ b/gbl/libgbl/src/fastboot/mod.rs
@@ -14,131 +14,414 @@
 
 //! Fastboot backend for libgbl.
 
-use crate::{partition::check_part_unique, GblOps};
+use crate::{
+    fuchsia_boot::GblAbrOps,
+    gbl_print, gbl_println,
+    partition::{check_part_unique, GblDisk, PartitionIo},
+    GblOps,
+};
+pub use abr::{mark_slot_active, set_one_shot_bootloader, set_one_shot_recovery, SlotIndex};
 use core::{
-    cmp::min,
-    fmt::Write,
-    future::Future,
-    mem::take,
-    str::{from_utf8, Split},
+    array::from_fn, cmp::min, ffi::CStr, fmt::Write, future::Future, marker::PhantomData,
+    mem::take, ops::DerefMut, pin::Pin, str::from_utf8,
 };
 use fastboot::{
-    next_arg, next_arg_u64, snprintf, CommandResult, FastbootImplementation, FastbootUtils,
-    FormattedBytes, UploadBuilder, Uploader, VarSender,
+    next_arg, next_arg_u64, process_next_command, run_tcp_session, snprintf, CommandError,
+    CommandResult, FastbootImplementation, FormattedBytes, InfoSender, OkaySender, RebootMode,
+    UploadBuilder, Uploader, VarInfoSender,
 };
-use gbl_async::yield_now;
+use gbl_async::{join, yield_now};
+use gbl_storage::{BlockIo, Disk, Gpt};
+use liberror::Error;
 use safemath::SafeNum;
-use spin::{Mutex, MutexGuard};
+use zbi::{ZbiContainer, ZbiType};
 
 mod vars;
-use vars::{fb_vars_get, fb_vars_get_all};
 
 pub(crate) mod sparse;
 use sparse::is_sparse_image;
 
-/// `TasksExecutor` provides interfaces for spawning and scheduling async tasks.
-pub trait TasksExecutor<'a> {
-    /// Spawns a new task.
-    fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()>;
+mod shared;
+pub use shared::Shared;
+
+mod buffer_pool;
+pub use buffer_pool::BufferPool;
+use buffer_pool::ScopedBuffer;
+
+mod pin_fut_container;
+pub use pin_fut_container::PinFutContainer;
+use pin_fut_container::{PinFutContainerTyped, PinFutSlice};
+
+// Re-exports dependency types
+pub use fastboot::{TcpStream, Transport};
+
+/// Reserved name for indicating flashing GPT.
+const FLASH_GPT_PART: &str = "gpt";
+
+/// Represents a GBL Fastboot async task.
+enum Task<'a, 'b, B: BlockIo, P: BufferPool> {
+    /// Image flashing task. (partition io, downloaded data, data size)
+    Flash(PartitionIo<'a, B>, ScopedBuffer<'b, P>, usize),
+    // Image erase task.
+    Erase(PartitionIo<'a, B>, ScopedBuffer<'b, P>),
+    None,
+}
+
+impl<'a, 'b, B: BlockIo, P: BufferPool> Task<'a, 'b, B, P> {
+    // Runs the task.
+    async fn run(self) {
+        let _ = async {
+            match self {
+                Self::Flash(mut part_io, mut download, data_size) => {
+                    match is_sparse_image(&download) {
+                        Ok(_) => part_io.write_sparse(0, &mut download).await,
+                        _ => part_io.write(0, &mut download[..data_size]).await,
+                    }
+                }
+                Self::Erase(mut part_io, mut buffer) => part_io.zeroize(&mut buffer).await,
+                _ => Ok(()),
+            }
+        }
+        .await;
+    }
 }
 
 /// `GblFastboot` implements fastboot commands in the GBL context.
-pub struct GblFastboot<'a, 'b, T: TasksExecutor<'b>, G> {
-    blk_io_executor: &'a T,
-    pub(crate) gbl_ops: &'b mut G,
-    download_buffers: &'b [Mutex<&'b mut [u8]>],
-    current_download_buffer: Option<MutexGuard<'b, &'b mut [u8]>>,
+///
+/// # Lifetimes
+///
+/// * `'a`: [GblOps] and disks lifetime.
+/// * `'b`: Lifetime for the buffer allocated by `P`.
+/// * `'c`: Lifetime of the pinned [Future]s in task container `task`.
+/// * `'d`: Lifetime of the `tasks` and `gbl_ops` objects borrowed.
+/// * `'e`: Lifetime of the ImageBuffers returned by `get_image_buffer()`.
+///
+/// # Generics
+///
+/// * `G`: Type of `Self::gbl_ops` which implements [GblOps].
+/// * `B`: Type that implements [BlockIo] in the [Disk] parameter of [GblDisk] for `Self::disks`.
+/// * `S`: Type of scratch buffer in the [Disk] parameter of [GblDisk] for `Self::disks`.
+/// * `T`: Type of gpt buffer in the [Gpt] parameter of [GblDisk] for `Self::disks`.
+/// * `P`: Type of `Self::buffer_pool` which implements [BufferPool].
+/// * `C`: Type of `Self::tasks` which implements [PinFutContainerTyped].
+/// * `F`: Type of [Future] stored by `Self::Tasks`.
+struct GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
+where
+    G: GblOps<'a, 'e>,
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    T: DerefMut<Target = [u8]>,
+    P: BufferPool,
+{
+    pub(crate) gbl_ops: &'d mut G,
+    // We store the partition devices returned by `gbl_ops.disks()` directly instead of getting it
+    // from `gbl_ops` later because we need to establish to the compiler that the hidden type of
+    // [BlockIo] in `GblDisk<Disk<impl BlockIO...>...>` returned by `gbl_ops.disks()` will be the
+    // same as the [BlockIo] type (denoted as B) in the function pointer
+    // `task_mapper`: fn(Task<'a, 'b, B, P>) -> F`. Otherwise, compiler won't allow `fn flash()`
+    // to call `task_mapper` with a `Task` constructed from `GblDisk<Disk<impl BlockIO...>...>`.
+    disks: &'a [GblDisk<Disk<B, S>, Gpt<T>>],
+    buffer_pool: &'b Shared<P>,
+    task_mapper: fn(Task<'a, 'b, B, P>) -> F,
+    tasks: &'d Shared<C>,
+    current_download_buffer: Option<ScopedBuffer<'b, P>>,
     current_download_size: usize,
-    enable_async_block_io: bool,
+    enable_async_task: bool,
     default_block: Option<usize>,
+    bootimg_buf: &'b mut [u8],
+    // Introduces marker type so that we can enforce constraint 'd <= min('b, 'c).
+    // The constraint is expressed in the implementation block for the `FastbootImplementation`
+    // trait.
+    _tasks_context_lifetime: PhantomData<&'c P>,
+    _get_image_buffer_lifetime: PhantomData<&'e ()>,
 }
 
-impl<'a, 'b, T: TasksExecutor<'b>, G: GblOps<'b>> GblFastboot<'a, 'b, T, G> {
-    /// Creates a new instance.
-    pub fn new(
-        blk_io_executor: &'a T,
-        gbl_ops: &'b mut G,
-        download_buffers: &'b [Mutex<&'b mut [u8]>],
+// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
+impl<'a: 'c, 'b: 'c, 'c, 'd, 'e, G, B, S, T, P, C, F>
+    GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
+where
+    G: GblOps<'a, 'e>,
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    T: DerefMut<Target = [u8]>,
+    P: BufferPool,
+    C: PinFutContainerTyped<'c, F>,
+    F: Future<Output = ()> + 'c,
+{
+    /// Creates a new [GblFastboot].
+    ///
+    /// # Args
+    ///
+    /// * `gbl_ops`: An implementation of `GblOps`.
+    /// * `disks`: The disk devices returned by `gbl_ops.disks()`. This is needed for expressing the
+    ///   property that the hidden [BlockIo] type is the same as that in `task_mapper`.
+    /// * `task_mapper`: A function pointer that maps `Task<'a, 'b, G, B>` to the target [Future]
+    ///   type `F` for input to `PinFutContainerTyped<F>::add_with()`.
+    /// * `tasks`: A shared instance of `PinFutContainerTyped<F>`.
+    /// * `buffer_pool`: A shared instance of `BufferPool`.
+    ///
+    /// The combination of `task_mapper` and `tasks` allows type `F`, which will be running the
+    /// async function `Task::run()`, to be defined at the callsite. This is necessary for the
+    /// usage of preallocated pinned futures (by `run_gbl_fastboot_stack()`) because the returned
+    /// type of a `async fn` is compiler-generated and can't be named. The only way to create a
+    /// preallocated slice of anonymous future is to keep the type generic and pass in the
+    /// anonymous future instance at the initialization callsite (aka defining use) and let compiler
+    /// infer and propagate it.
+    fn new(
+        gbl_ops: &'d mut G,
+        disks: &'a [GblDisk<Disk<B, S>, Gpt<T>>],
+        task_mapper: fn(Task<'a, 'b, B, P>) -> F,
+        tasks: &'d Shared<C>,
+        buffer_pool: &'b Shared<P>,
+        bootimg_buf: &'b mut [u8],
     ) -> Self {
         Self {
-            blk_io_executor,
             gbl_ops,
-            download_buffers,
+            disks,
+            task_mapper,
+            tasks,
+            buffer_pool,
             current_download_buffer: None,
             current_download_size: 0,
-            enable_async_block_io: false,
+            enable_async_task: false,
             default_block: None,
+            bootimg_buf,
+            _tasks_context_lifetime: PhantomData,
+            _get_image_buffer_lifetime: PhantomData,
+        }
+    }
+
+    /// Returns the shared task container.
+    fn tasks(&self) -> &'d Shared<impl PinFutContainerTyped<'c, F>> {
+        self.tasks
+    }
+
+    /// Listens on the given USB/TCP channels and runs fastboot.
+    async fn run(
+        &mut self,
+        mut usb: Option<impl GblUsbTransport>,
+        mut tcp: Option<impl GblTcpStream>,
+    ) {
+        if usb.is_none() && tcp.is_none() {
+            gbl_println!(self.gbl_ops, "No USB or TCP found for GBL Fastboot");
+            return;
         }
+        let tasks = self.tasks();
+        // The fastboot command loop task for interacting with the remote host.
+        let cmd_loop_end = Shared::from(false);
+        let cmd_loop_task = async {
+            loop {
+                if let Some(v) = usb.as_mut() {
+                    if v.has_packet() {
+                        let res = match process_next_command(v, self).await {
+                            Ok(true) => break,
+                            v => v,
+                        };
+                        if res.is_err() {
+                            gbl_println!(self.gbl_ops, "GBL Fastboot USB session error: {:?}", res);
+                        }
+                    }
+                }
+
+                if let Some(v) = tcp.as_mut() {
+                    if v.accept_new() {
+                        let res = match run_tcp_session(v, self).await {
+                            Ok(()) => break,
+                            v => v,
+                        };
+                        if res.is_err_and(|e| e != Error::Disconnected) {
+                            gbl_println!(self.gbl_ops, "GBL Fastboot TCP session error: {:?}", res);
+                        }
+                    }
+                }
+
+                yield_now().await;
+            }
+            *cmd_loop_end.borrow_mut() = true;
+        };
+
+        // Schedules [Task] spawned by GBL fastboot.
+        let gbl_fb_tasks = async {
+            while tasks.borrow_mut().poll_all() > 0 || !*cmd_loop_end.borrow_mut() {
+                yield_now().await;
+            }
+        };
+
+        let _ = join(cmd_loop_task, gbl_fb_tasks).await;
+    }
+
+    /// Extracts the next argument and verifies that it is a valid block device ID if present.
+    ///
+    /// # Returns
+    ///
+    /// * Returns `Ok(Some(blk_id))` if next argument is present and is a valid block device ID.
+    /// * Returns `None` if next argument is not available and there are more than one block
+    ///   devices.
+    /// * Returns `Err(())` if next argument is present but is an invalid block device ID.
+    fn check_next_arg_blk_id<'s>(
+        &self,
+        args: &mut impl Iterator<Item = &'s str>,
+    ) -> CommandResult<Option<usize>> {
+        let devs = self.disks;
+        let blk_id = match next_arg_u64(args)? {
+            Some(v) => {
+                let v = usize::try_from(v)?;
+                // Checks out of range.
+                devs.get(v).ok_or("Invalid block ID")?;
+                Some(v)
+            }
+            _ => None,
+        };
+        let blk_id = blk_id.or(self.default_block);
+        let blk_id = blk_id.or((devs.len() == 1).then_some(0));
+        Ok(blk_id)
     }
 
-    /// Returns the block IO task executor.
-    pub fn blk_io_executor(&self) -> &'a T {
-        self.blk_io_executor
+    /// Parses and checks the argument for "fastboot flash gpt/<blk_idx>/"resize".
+    ///
+    /// # Returns
+    ///
+    /// * Returns `Ok(Some((blk_idx, resize)))` if command is a GPT flashing command.
+    /// * Returns `Ok(None)` if command is not a GPT flashing command.
+    /// * Returns `Err()` otherwise.
+    pub(crate) fn parse_flash_gpt_args(&self, part: &str) -> CommandResult<Option<(usize, bool)>> {
+        // Syntax: flash gpt/<blk_idx>/"resize"
+        let mut args = part.split('/');
+        if next_arg(&mut args).filter(|v| *v == FLASH_GPT_PART).is_none() {
+            return Ok(None);
+        }
+        // Parses block device ID.
+        let blk_id = self
+            .check_next_arg_blk_id(&mut args)?
+            .ok_or("Block ID is required for flashing GPT")?;
+        // Parses resize option.
+        let resize = match next_arg(&mut args) {
+            Some("resize") => true,
+            Some(_) => return Err("Unknown argument".into()),
+            _ => false,
+        };
+        Ok(Some((blk_id, resize)))
     }
 
-    /// Parses and checkds the partition argument and returns the partition name, block device
+    /// Parses and checks the partition argument and returns the partition name, block device
     /// index, start offset and size.
     pub(crate) fn parse_partition<'s>(
         &self,
-        mut args: Split<'s, char>,
+        part: &'s str,
     ) -> CommandResult<(Option<&'s str>, usize, u64, u64)> {
-        let devs = self.gbl_ops.partitions()?;
+        let devs = self.disks;
+        let mut args = part.split('/');
         // Parses partition name.
-        let part = next_arg(&mut args, Err("".into())).ok();
+        let part = next_arg(&mut args);
         // Parses block device ID.
-        let blk_id = next_arg_u64(&mut args, Err("".into())).ok();
-        let blk_id = blk_id.map(|v| usize::try_from(v)).transpose()?;
-        let blk_id = blk_id.or(self.default_block);
+        let blk_id = self.check_next_arg_blk_id(&mut args)?;
         // Parses sub window offset.
-        let window_offset = next_arg_u64(&mut args, Ok(0))?;
+        let window_offset = next_arg_u64(&mut args)?.unwrap_or(0);
         // Parses sub window size.
-        let window_size = next_arg_u64(&mut args, Err("".into())).ok();
-        // Checks and resolves blk_id and partition size
-        let (blk_id, partition) = match blk_id {
-            None => check_part_unique(devs, part.ok_or("Must provide a partition")?)?,
-            Some(v) => (v, devs.get(v).ok_or("Invalid block ID")?.find_partition(part)?),
+        let window_size = next_arg_u64(&mut args)?;
+        // Checks uniqueness of the partition and resolves its block device ID.
+        let find = |p: Option<&'s str>| match blk_id {
+            None => Ok((check_part_unique(devs, p.ok_or("Must provide a partition")?)?, p)),
+            Some(v) => Ok(((v, devs[v].find_partition(p)?), p)),
+        };
+        let ((blk_id, partition), actual) = match find(part) {
+            // Some legacy Fuchsia devices in the field uses name "fuchsia-fvm" for the standard
+            // "fvm" partition. However all of our infra uses the standard name "fvm" when flashing.
+            // Here we do a one off mapping if the device falls into this case. Once we have a
+            // solution for migrating those devices off the legacy name, we can remove this.
+            //
+            // If we run into more of such legacy aliases that we can't migrate, consider adding
+            // interfaces in GblOps for this.
+            Err(Error::NotFound) if part == Some("fvm") => find(Some("fuchsia-fvm"))?,
+            v => v?,
         };
         let part_sz = SafeNum::from(partition.size()?);
         let window_size = window_size.unwrap_or((part_sz - window_offset).try_into()?);
         u64::try_from(part_sz - window_size - window_offset)?;
-        Ok((part, blk_id, window_offset, window_size))
+        Ok((actual, blk_id, window_offset, window_size))
     }
 
-    /// Checks and waits until a download buffer is allocated.
-    async fn ensure_download_buffer(&mut self) -> &mut [u8] {
-        while self.current_download_buffer.is_none() {
-            self.current_download_buffer = self.download_buffers.iter().find_map(|v| v.try_lock());
-            match self.current_download_buffer.is_some() {
-                true => break,
-                _ => yield_now().await,
+    /// Takes the download data and resets download size.
+    fn take_download(&mut self) -> Option<(ScopedBuffer<'b, P>, usize)> {
+        Some((self.current_download_buffer.take()?, take(&mut self.current_download_size)))
+    }
+
+    /// Waits until a Disk device is ready and get the [PartitionIo] for `part`.
+    pub async fn wait_partition_io(
+        &self,
+        blk: usize,
+        part: Option<&str>,
+    ) -> CommandResult<PartitionIo<'a, B>> {
+        loop {
+            match self.disks[blk].partition_io(part) {
+                Err(Error::NotReady) => yield_now().await,
+                Ok(v) => {
+                    v.last_err()?;
+                    return Ok(v);
+                }
+                Err(e) => return Err(e.into()),
             }
         }
-        self.current_download_buffer.as_mut().unwrap()
+    }
+
+    /// An internal helper for parsing a partition and getting the partition IO
+    async fn parse_and_get_partition_io(
+        &self,
+        part: &str,
+    ) -> CommandResult<(usize, PartitionIo<'a, B>)> {
+        let (part, blk_idx, start, sz) = self.parse_partition(part)?;
+        Ok((blk_idx, self.wait_partition_io(blk_idx, part).await?.sub(start, sz)?))
+    }
+
+    /// Helper for scheduiling an async task.
+    ///
+    /// * If `Self::enable_async_task` is true, the method will add the task to the background task
+    ///   list. Otherwise it simply runs the task.
+    async fn schedule_task(
+        &mut self,
+        task: Task<'a, 'b, B, P>,
+        responder: &mut impl InfoSender,
+    ) -> CommandResult<()> {
+        match self.enable_async_task {
+            true => {
+                let mut t = Some((self.task_mapper)(task));
+                self.tasks.borrow_mut().add_with(|| t.take().unwrap());
+                while t.is_some() {
+                    yield_now().await;
+                    self.tasks.borrow_mut().add_with(|| t.take().unwrap());
+                }
+                self.tasks.borrow_mut().poll_all();
+                let info = "An IO task is launched. To sync manually, run \"oem gbl-sync-tasks\".";
+                responder.send_info(info).await?
+            }
+            _ => task.run().await,
+        };
+        Ok(())
     }
 
     /// Waits for all block devices to be ready.
     async fn sync_all_blocks(&self) -> CommandResult<()> {
-        for ele in self.gbl_ops.partitions()? {
-            let _ = ele.wait_partition_io(None).await;
+        for (idx, _) in self.disks.iter().enumerate() {
+            let _ = self.wait_partition_io(idx, None).await;
         }
         Ok(())
     }
 
-    /// Implementation for "fastboot oem gbl-sync-blocks".
-    async fn oem_sync_blocks<'c>(
+    /// Implementation for "fastboot oem gbl-sync-tasks".
+    async fn oem_sync_blocks<'s>(
         &self,
-        utils: &mut impl FastbootUtils,
-        res: &'c mut [u8],
-    ) -> CommandResult<&'c [u8]> {
+        mut responder: impl InfoSender,
+        res: &'s mut [u8],
+    ) -> CommandResult<&'s [u8]> {
         self.sync_all_blocks().await?;
         // Checks error.
         let mut has_error = false;
-        for (i, ele) in self.gbl_ops.partitions()?.iter().enumerate() {
+        for (i, ele) in self.disks.iter().enumerate() {
             match ele.partition_io(None)?.last_err() {
                 Ok(_) => {}
                 Err(e) => {
                     has_error = true;
-                    utils.send_info(snprintf!(res, "Block #{} error: {:?}.", i, e)).await?;
+                    responder.send_info(snprintf!(res, "Block #{} error: {:?}.", i, e)).await?;
                 }
             }
         }
@@ -147,70 +430,158 @@ impl<'a, 'b, T: TasksExecutor<'b>, G: GblOps<'b>> GblFastboot<'a, 'b, T, G> {
             _ => Ok(b""),
         }
     }
+
+    /// Syncs all storage devices and reboots.
+    async fn sync_block_and_reboot(
+        &mut self,
+        mode: RebootMode,
+        mut resp: impl InfoSender + OkaySender,
+    ) -> CommandResult<()> {
+        resp.send_info("Syncing storage...").await?;
+        self.sync_all_blocks().await?;
+        match mode {
+            RebootMode::Normal => {
+                resp.send_info("Rebooting...").await?;
+                resp.send_okay("").await?;
+                self.gbl_ops.reboot();
+            }
+            RebootMode::Bootloader => {
+                let f = self.gbl_ops.reboot_bootloader()?;
+                resp.send_info("Rebooting to bootloader...").await?;
+                resp.send_okay("").await?;
+                f()
+            }
+            RebootMode::Recovery => {
+                let f = self.gbl_ops.reboot_recovery()?;
+                resp.send_info("Rebooting to recovery...").await?;
+                resp.send_okay("").await?;
+                f()
+            }
+            _ => return Err("Unsupported".into()),
+        }
+        Ok(())
+    }
+
+    /// Appends a staged payload as bootloader file.
+    async fn add_staged_bootloader_file(&mut self, file_name: &str) -> CommandResult<()> {
+        let buffer = self
+            .gbl_ops
+            .get_zbi_bootloader_files_buffer_aligned()
+            .ok_or("No ZBI bootloader file buffer is provided")?;
+        let data = self.current_download_buffer.as_mut().ok_or("No file staged")?;
+        let data = &mut data[..self.current_download_size];
+        let mut zbi = match ZbiContainer::parse(&mut buffer[..]) {
+            Ok(v) => v,
+            _ => ZbiContainer::new(&mut buffer[..])?,
+        };
+        let next_payload = zbi.get_next_payload()?;
+        // Format: name length (1 byte) | name | file content.
+        let (name_len, rest) = next_payload.split_at_mut_checked(1).ok_or("Buffer too small")?;
+        let (name, rest) = rest.split_at_mut_checked(file_name.len()).ok_or("Buffer too small")?;
+        let file_content = rest.get_mut(..data.len()).ok_or("Buffer too small")?;
+        name_len[0] = file_name.len().try_into().map_err(|_| "File name length overflows 256")?;
+        name.clone_from_slice(file_name.as_bytes());
+        file_content.clone_from_slice(data);
+        // Creates the entry;
+        zbi.create_entry(
+            ZbiType::BootloaderFile,
+            0,
+            Default::default(),
+            1 + file_name.len() + data.len(),
+        )?;
+        Ok(())
+    }
 }
 
-impl<'b, T: TasksExecutor<'b>, G: GblOps<'b>> FastbootImplementation for GblFastboot<'_, 'b, T, G> {
+// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
+impl<'a: 'c, 'b: 'c, 'c, 'e, G, B, S, T, P, C, F> FastbootImplementation
+    for GblFastboot<'a, 'b, 'c, '_, 'e, G, B, S, T, P, C, F>
+where
+    G: GblOps<'a, 'e>,
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    T: DerefMut<Target = [u8]>,
+    P: BufferPool,
+    C: PinFutContainerTyped<'c, F>,
+    F: Future<Output = ()> + 'c,
+{
     async fn get_var(
         &mut self,
-        var: &str,
-        args: Split<'_, char>,
+        var: &CStr,
+        args: impl Iterator<Item = &'_ CStr> + Clone,
         out: &mut [u8],
-        _utils: &mut impl FastbootUtils,
+        _: impl InfoSender,
     ) -> CommandResult<usize> {
-        Ok(fb_vars_get(self, var, args, out).await?.ok_or("No such variable")?)
+        Ok(self.get_var_internal(var, args, out)?.len())
     }
 
-    async fn get_var_all(
-        &mut self,
-        var_logger: &mut impl VarSender,
-        _utils: &mut impl FastbootUtils,
-    ) -> CommandResult<()> {
-        fb_vars_get_all(self, var_logger).await
+    async fn get_var_all(&mut self, mut resp: impl VarInfoSender) -> CommandResult<()> {
+        self.get_var_all_internal(&mut resp).await
     }
 
     async fn get_download_buffer(&mut self) -> &mut [u8] {
-        self.ensure_download_buffer().await
+        if self.current_download_buffer.is_none() {
+            self.current_download_buffer = Some(self.buffer_pool.allocate_async().await);
+        }
+        self.current_download_buffer.as_mut().unwrap()
     }
 
-    async fn download_complete(&mut self, download_size: usize) -> CommandResult<()> {
+    async fn download_complete(
+        &mut self,
+        download_size: usize,
+        _: impl InfoSender,
+    ) -> CommandResult<()> {
         self.current_download_size = download_size;
         Ok(())
     }
 
-    async fn flash(&mut self, part: &str, utils: &mut impl FastbootUtils) -> CommandResult<()> {
-        let (part, blk_idx, start, sz) = self.parse_partition(part.split(':'))?;
-        let partitions = self.gbl_ops.partitions()?;
-        let mut part_io = partitions[blk_idx].wait_partition_io(part).await?.sub(start, sz)?;
-        part_io.last_err()?;
-        let mut download_buffer = self.current_download_buffer.take().ok_or("No download")?;
-        let data_size = take(&mut self.current_download_size);
-        let write_task = async move {
-            let _ = match is_sparse_image(&download_buffer) {
-                Ok(_) => part_io.write_sparse(0, &mut download_buffer).await,
-                _ => part_io.write(0, &mut download_buffer[..data_size]).await,
+    async fn flash(&mut self, part: &str, mut responder: impl InfoSender) -> CommandResult<()> {
+        let disks = self.disks;
+
+        // Checks if we are flashing new GPT partition table
+        if let Some((blk_idx, resize)) = self.parse_flash_gpt_args(part)? {
+            self.wait_partition_io(blk_idx, None).await?;
+            let (mut gpt, size) = self.take_download().ok_or("No GPT downloaded")?;
+            responder.send_info("Updating GPT...").await?;
+            return match disks[blk_idx].update_gpt(&mut gpt[..size], resize).await {
+                Err(Error::NotReady) => panic!("Should not be busy"),
+                Err(Error::Unsupported) => Err("Block device is not for GPT".into()),
+                v => Ok(v?),
             };
-        };
-        match self.enable_async_block_io {
-            true => {
-                self.blk_io_executor.spawn_task(write_task)?;
-                let info = "An IO task is launched. To sync manually, run \"oem gbl-sync-blocks\".";
-                utils.send_info(info).await?
-            }
-            _ => write_task.await,
-        };
+        }
+
+        let (blk_idx, part_io) = self.parse_and_get_partition_io(part).await?;
+        let (download_buffer, data_size) = self.take_download().ok_or("No download")?;
+        let write_task = Task::Flash(part_io, download_buffer, data_size);
+        self.schedule_task(write_task, &mut responder).await?;
         // Checks if block is ready already and returns errors. This can be the case when the
         // operation is synchronous or runs into early errors.
-        match partitions[blk_idx].partition_io(part) {
-            Ok(v) => Ok(v.last_err()?),
-            _ => Ok(()),
+        Ok(disks[blk_idx].status().result()?)
+    }
+
+    async fn erase(&mut self, part: &str, mut responder: impl InfoSender) -> CommandResult<()> {
+        let disks = self.disks;
+
+        // Checks if we are erasing GPT partition table.
+        if let Some((blk_idx, _)) = self.parse_flash_gpt_args(part)? {
+            self.wait_partition_io(blk_idx, None).await?;
+            return match disks[blk_idx].erase_gpt().await {
+                Err(Error::NotReady) => panic!("Should not be busy"),
+                Err(Error::Unsupported) => Err("Block device is not for GPT".into()),
+                v => Ok(v?),
+            };
         }
+
+        let (blk_idx, part_io) = self.parse_and_get_partition_io(part).await?;
+        self.get_download_buffer().await;
+        let erase_task = Task::Erase(part_io, self.take_download().unwrap().0);
+        self.schedule_task(erase_task, &mut responder).await?;
+        // Checks if block is ready already and returns errors. This can be the case when the
+        // operation is synchronous or runs into early errors.
+        Ok(disks[blk_idx].status().result()?)
     }
 
-    async fn upload(
-        &mut self,
-        _: impl UploadBuilder,
-        _: &mut impl FastbootUtils,
-    ) -> CommandResult<()> {
+    async fn upload(&mut self, _: impl UploadBuilder) -> CommandResult<()> {
         Err("Unimplemented".into())
     }
 
@@ -219,17 +590,16 @@ impl<'b, T: TasksExecutor<'b>, G: GblOps<'b>> FastbootImplementation for GblFast
         part: &str,
         offset: u64,
         size: u64,
-        upload_builder: impl UploadBuilder,
-        utils: &mut impl FastbootUtils,
+        mut responder: impl UploadBuilder + InfoSender,
     ) -> CommandResult<()> {
-        let (part, blk_idx, start, sz) = self.parse_partition(part.split(':'))?;
-        let partitions = self.gbl_ops.partitions()?;
-        let mut part_io = partitions[blk_idx].wait_partition_io(part).await?.sub(start, sz)?;
-        part_io.last_err()?;
-        let buffer = self.ensure_download_buffer().await;
+        let (_, mut part_io) = self.parse_and_get_partition_io(part).await?;
+        let buffer = self.get_download_buffer().await;
         let end = u64::try_from(SafeNum::from(offset) + size)?;
         let mut curr = offset;
-        let mut uploader = upload_builder.start(size).await?;
+        responder
+            .send_formatted_info(|v| write!(v, "Uploading {} bytes...", size).unwrap())
+            .await?;
+        let mut uploader = responder.initiate_upload(size).await?;
         while curr < end {
             let to_send = min(usize::try_from(end - curr)?, buffer.len());
             part_io.read(curr, &mut buffer[..to_send]).await?;
@@ -239,36 +609,230 @@ impl<'b, T: TasksExecutor<'b>, G: GblOps<'b>> FastbootImplementation for GblFast
         Ok(())
     }
 
-    async fn oem<'a>(
+    async fn reboot(
+        &mut self,
+        mode: RebootMode,
+        resp: impl InfoSender + OkaySender,
+    ) -> CommandError {
+        match self.sync_block_and_reboot(mode, resp).await {
+            Err(e) => e,
+            _ => "Unknown".into(),
+        }
+    }
+
+    async fn r#continue(&mut self, mut resp: impl InfoSender) -> CommandResult<()> {
+        resp.send_info("Syncing storage...").await?;
+        Ok(self.sync_all_blocks().await?)
+    }
+
+    async fn set_active(&mut self, slot: &str, _: impl InfoSender) -> CommandResult<()> {
+        self.sync_all_blocks().await?;
+        match self.gbl_ops.expected_os_is_fuchsia()? {
+            // TODO(b/374776896): Prioritizes platform specific `set_active_slot`  if available.
+            true => Ok(mark_slot_active(
+                &mut GblAbrOps(self.gbl_ops),
+                match slot {
+                    "a" => SlotIndex::A,
+                    "b" => SlotIndex::B,
+                    _ => return Err("Invalid slot index for Fuchsia A/B/R".into()),
+                },
+            )?),
+            _ => Err("Not supported".into()),
+        }
+    }
+
+    async fn oem<'s>(
         &mut self,
         cmd: &str,
-        utils: &mut impl FastbootUtils,
-        res: &'a mut [u8],
-    ) -> CommandResult<&'a [u8]> {
+        mut responder: impl InfoSender,
+        res: &'s mut [u8],
+    ) -> CommandResult<&'s [u8]> {
+        let mut args = cmd.split(' ');
+        let cmd = args.next().ok_or("Missing command")?;
         match cmd {
-            "gbl-sync-blocks" => self.oem_sync_blocks(utils, res).await,
-            "gbl-enable-async-block-io" => {
-                self.enable_async_block_io = true;
+            "gbl-sync-tasks" => self.oem_sync_blocks(responder, res).await,
+            "gbl-enable-async-task" => {
+                self.enable_async_task = true;
                 Ok(b"")
             }
-            "gbl-disable-async-block-io" => {
-                self.enable_async_block_io = false;
+            "gbl-disable-async-task" => {
+                self.enable_async_task = false;
                 Ok(b"")
             }
             "gbl-unset-default-block" => {
                 self.default_block = None;
                 Ok(b"")
             }
-            _ if cmd.starts_with("gbl-set-default-block ") => {
-                let mut args = cmd.split(' ');
-                let _ = args.next();
-                let id = next_arg_u64(&mut args, Err("Missing block device ID".into()))?;
+            "gbl-set-default-block" => {
+                let id = next_arg_u64(&mut args)?.ok_or("Missing block device ID")?;
+                let id = usize::try_from(id)?;
+                self.disks.get(id).ok_or("Out of range")?;
                 self.default_block = Some(id.try_into()?);
+                responder
+                    .send_formatted_info(|f| write!(f, "Default block device: {id:#x}").unwrap())
+                    .await?;
+                Ok(b"")
+            }
+            "add-staged-bootloader-file" => {
+                let file_name = next_arg(&mut args).ok_or("Missing file name")?;
+                self.add_staged_bootloader_file(file_name).await?;
                 Ok(b"")
             }
             _ => Err("Unknown oem command".into()),
         }
     }
+
+    async fn boot(&mut self, mut resp: impl InfoSender + OkaySender) -> CommandResult<()> {
+        let len = core::cmp::min(self.bootimg_buf.len(), self.current_download_size);
+        let data = self.current_download_buffer.as_mut().ok_or("No file staged")?;
+        let data = &mut data[..self.current_download_size];
+
+        self.bootimg_buf[..len].copy_from_slice(&data[..len]);
+        resp.send_info("Boot into boot.img").await?;
+        Ok(())
+    }
+}
+
+/// `GblUsbTransport` defines transport interfaces for running GBL fastboot over USB.
+pub trait GblUsbTransport: Transport {
+    /// Checks whether there is a new USB packet.
+    fn has_packet(&mut self) -> bool;
+}
+
+/// `GblTcpStream` defines transport interfaces for running GBL fastboot over TCP.
+pub trait GblTcpStream: TcpStream {
+    /// Accepts a new TCP connection.
+    ///
+    /// If a connection is in progress, it should be aborted first.
+    ///
+    /// Returns true if a new connection is established, false otherwise.
+    fn accept_new(&mut self) -> bool;
+}
+
+/// Runs GBL fastboot on the given USB/TCP channels.
+///
+/// # Args:
+///
+/// * `gbl_ops`: An instance of [GblOps].
+/// * `buffer_pool`: An implementation of [BufferPool].
+/// * `tasks`: An implementation of [PinFutContainer]
+/// * `usb`: An optional implementation of [GblUsbTransport].
+/// * `tcp`: An optional implementation of [GblTcpStream].
+///
+/// # Lifetimes
+/// * `'a`: Lifetime of [GblOps].
+/// * `'b`: Lifetime of `download_buffers`.
+/// * `'c`: Lifetime of `tasks`.
+pub async fn run_gbl_fastboot<'a: 'c, 'b: 'c, 'c, 'd>(
+    gbl_ops: &mut impl GblOps<'a, 'd>,
+    buffer_pool: &'b Shared<impl BufferPool>,
+    tasks: impl PinFutContainer<'c> + 'c,
+    usb: Option<impl GblUsbTransport>,
+    tcp: Option<impl GblTcpStream>,
+    bootimg_buf: &'b mut [u8],
+) {
+    let tasks = tasks.into();
+    let disks = gbl_ops.disks();
+    GblFastboot::new(gbl_ops, disks, Task::run, &tasks, buffer_pool, bootimg_buf)
+        .run(usb, tcp)
+        .await;
+}
+
+/// Runs GBL fastboot on the given USB/TCP channels with N stack allocated worker tasks.
+///
+/// The choice of N depends on the level of parallelism the platform can support. For platform with
+/// `n` storage devices that can independently perform non-blocking IO, it will required `N = n`
+/// and a `buffer_pool` that can allocate at least n+1 buffers at the same time in order to achieve
+/// parallel flashing to all storages plus a parallel downloading. However, it is common for
+/// disks that need to be flashed to be on the same block deviece so flashing of them becomes
+/// sequential, in which case N can be smaller. Caller should take into consideration usage pattern
+/// for determining N.
+///
+/// # Args:
+///
+/// * `gbl_ops`: An instance of [GblOps].
+/// * `buffer_pool`: An implementation of [BufferPool].
+/// * `usb`: An optional implementation of [GblUsbTransport].
+/// * `tcp`: An optional implementation of [GblTcpStream].
+pub async fn run_gbl_fastboot_stack<'a, 'b, const N: usize>(
+    gbl_ops: &mut impl GblOps<'a, 'b>,
+    buffer_pool: impl BufferPool,
+    usb: Option<impl GblUsbTransport>,
+    tcp: Option<impl GblTcpStream>,
+    bootimg_buf: &mut [u8],
+) {
+    let buffer_pool = buffer_pool.into();
+    // Creates N worker tasks.
+    let mut tasks: [_; N] = from_fn(|_| Task::None.run());
+    // It is possible to avoid the use of the unsafe `Pin::new_unchecked` by delaring the array and
+    // manually pinning each element i.e.
+    //
+    // ```
+    // let mut tasks = [
+    //     core::pin::pin!(Task::None.run()),
+    //     core::pin::pin!(Task::None.run()),
+    //     core::pin::pin!(Task::None.run()),
+    // ];
+    // ```
+    //
+    // Parameterization of `N` will be an issue, but might be solvable with procedural macro.
+    // SAFETY: `tasks` is immediately shadowed and thus guaranteed not moved for the rest of its
+    // lifetime.
+    let mut tasks: [_; N] = tasks.each_mut().map(|v| unsafe { Pin::new_unchecked(v) });
+    let tasks = PinFutSlice::new(&mut tasks[..]).into();
+    let disks = gbl_ops.disks();
+    GblFastboot::new(gbl_ops, disks, Task::run, &tasks, &buffer_pool, bootimg_buf)
+        .run(usb, tcp)
+        .await;
+}
+
+/// Pre-generates a Fuchsia Fastboot MDNS service broadcast packet.
+///
+/// Fuchsia ffx development flow can detect fastboot devices that broadcast a "_fastboot·_tcp·local"
+/// MDNS service. This API generates the broadcast MDNS packet for Ipv6. Caller is reponsible for
+/// sending this packet via UDP at the following address and port (defined by MDNS):
+///
+/// * ipv6: ff02::fb
+/// * port: 5353
+///
+/// # Args
+///
+/// * `node_name`: The Fuchsia node name for the service. Must be a 22 character ASCII string in the
+///   format "fuchsia-xxxx-xxxx-xxxx".
+/// * `ipv6_addr`: The Ipv6 address bytes.
+///
+/// The packet generated by the API contains the given IPv6 address and a fuchsia node name derived
+/// from the given ethernet mac address `eth_mac`.
+pub fn fuchsia_fastboot_mdns_packet(node_name: &str, ipv6_addr: &[u8]) -> Result<[u8; 140], Error> {
+    // Pre-generated Fuchsia fastboot MDNS service packet template.
+    // It contains the node name and ipv6 address. We simply replace with the device's node name and
+    // ipv6 address.
+    let mut packet: [u8; 140] = [
+        0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x09, 0x5f, 0x66,
+        0x61, 0x73, 0x74, 0x62, 0x6f, 0x6f, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f,
+        0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x19, 0x16,
+        0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x34, 0x38, 0x32, 0x31, 0x2d, 0x30, 0x62,
+        0x33, 0x31, 0x2d, 0x65, 0x61, 0x66, 0x38, 0xc0, 0x0c, 0xc0, 0x2c, 0x00, 0x21, 0x80, 0x01,
+        0x00, 0x00, 0x00, 0x78, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x15, 0xb2, 0x16, 0x66, 0x75,
+        0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x34, 0x38, 0x32, 0x31, 0x2d, 0x30, 0x62, 0x33, 0x31,
+        0x2d, 0x65, 0x61, 0x66, 0x38, 0xc0, 0x1b, 0xc0, 0x57, 0x00, 0x1c, 0x80, 0x01, 0x00, 0x00,
+        0x00, 0x78, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x21, 0x0b,
+        0xff, 0xfe, 0x31, 0xea, 0xf8,
+    ];
+    // Offsets to the fuchsia node name field.
+    const NODE_NAME_OFFSETS: &[usize; 2] = &[45, 88];
+    // Offset to the IPv6 address field.
+    const IP6_ADDR_OFFSET: usize = 124;
+
+    if node_name.as_bytes().len() != 22 {
+        return Err(Error::InvalidInput);
+    }
+
+    for off in NODE_NAME_OFFSETS {
+        packet[*off..][..node_name.len()].clone_from_slice(node_name.as_bytes());
+    }
+    packet[IP6_ADDR_OFFSET..][..ipv6_addr.len()].clone_from_slice(ipv6_addr);
+    Ok(packet)
 }
 
 #[cfg(test)]
@@ -276,122 +840,141 @@ mod test {
     use super::*;
     use crate::{
         ops::test::{FakeGblOps, FakeGblOpsStorage},
-        partition::PartitionBlockDevice,
+        Os,
+    };
+    use abr::{
+        get_and_clear_one_shot_bootloader, get_boot_slot, mark_slot_unbootable, ABR_DATA_SIZE,
+    };
+    use core::{
+        mem::size_of,
+        pin::{pin, Pin},
+        str::from_utf8,
     };
-    use core::{cmp::max, future::Future, pin::pin};
     use fastboot::{test_utils::TestUploadBuilder, MAX_RESPONSE_SIZE};
-    use gbl_async::{block_on, poll};
-    use gbl_cyclic_executor::CyclicExecutor;
-    use gbl_storage_testlib::{BackingStore, TestBlockDeviceBuilder, TestBlockIo};
+    use gbl_async::{block_on, poll, poll_n_times};
+    use gbl_storage::GPT_GUID_LEN;
     use liberror::Error;
+    use spin::{Mutex, MutexGuard};
+    use std::ffi::CString;
+    use std::{collections::VecDeque, io::Read};
+    use zerocopy::AsBytes;
 
-    /// A test implementation of FastbootUtils.
+    /// A test implementation of [InfoSender] and [OkaySender].
     #[derive(Default)]
-    struct TestFastbootUtils {}
+    struct TestResponder {
+        okay_sent: Mutex<bool>,
+        info_messages: Mutex<Vec<String>>,
+    }
 
-    impl FastbootUtils for TestFastbootUtils {
-        /// Sends a Fastboot "INFO<`msg`>" packet.
-        async fn send_info(&mut self, _: &str) -> CommandResult<()> {
+    impl InfoSender for &TestResponder {
+        async fn send_formatted_info<F: FnOnce(&mut dyn Write)>(
+            &mut self,
+            cb: F,
+        ) -> Result<(), Error> {
+            let mut msg: String = "".into();
+            cb(&mut msg);
+            self.info_messages.try_lock().unwrap().push(msg);
             Ok(())
         }
+    }
 
-        /// Returns transport errors if there are any.
-        fn transport_error(&self) -> Result<(), Error> {
+    impl OkaySender for &TestResponder {
+        /// Sends a Fastboot "INFO<`msg`>" packet.
+        async fn send_formatted_okay<F: FnOnce(&mut dyn Write)>(self, _: F) -> Result<(), Error> {
+            *self.okay_sent.try_lock().unwrap() = true;
             Ok(())
         }
     }
 
-    type TestGblFastboot<'a, 'b> = GblFastboot<'a, 'b, TestGblFbExecutor<'b>, FakeGblOps<'b>>;
-
     /// Helper to test fastboot variable value.
-    fn check_var(gbl_fb: &mut TestGblFastboot, var: &str, args: &str, expected: &str) {
-        let mut utils: TestFastbootUtils = Default::default();
+    fn check_var(gbl_fb: &mut impl FastbootImplementation, var: &str, args: &str, expected: &str) {
+        let resp: TestResponder = Default::default();
+        let args_c = args.split(':').map(|v| CString::new(v).unwrap()).collect::<Vec<_>>();
+        let args_c = args_c.iter().map(|v| v.as_c_str());
+        let var_c = CString::new(var).unwrap();
         let mut out = vec![0u8; MAX_RESPONSE_SIZE];
-        let val = block_on(gbl_fb.get_var_as_str(var, args.split(':'), &mut out[..], &mut utils))
-            .unwrap();
+        let val =
+            block_on(gbl_fb.get_var_as_str(var_c.as_c_str(), args_c, &resp, &mut out[..])).unwrap();
         assert_eq!(val, expected, "var {}:{} = {} != {}", var, args, val, expected,);
     }
 
     /// A helper to set the download content.
-    fn set_download(gbl_fb: &mut TestGblFastboot, data: &[u8]) {
-        block_on(gbl_fb.ensure_download_buffer());
-        gbl_fb.current_download_buffer.as_mut().unwrap()[..data.len()].clone_from_slice(data);
-        gbl_fb.current_download_size = data.len();
+    fn set_download(gbl_fb: &mut impl FastbootImplementation, data: &[u8]) {
+        block_on(gbl_fb.get_download_buffer())[..data.len()].clone_from_slice(data);
+        block_on(gbl_fb.download_complete(data.len(), &TestResponder::default())).unwrap();
     }
 
-    /// `TestGblFbExecutor` wraps a `CyclicExecutor` and implements `TasksExecutor` trait.
-    #[derive(Default)]
-    struct TestGblFbExecutor<'a>(Mutex<CyclicExecutor<'a>>);
-
-    impl<'a> TasksExecutor<'a> for TestGblFbExecutor<'a> {
-        fn spawn_task(&self, task: impl Future<Output = ()> + 'a) -> CommandResult<()> {
-            Ok(self.0.try_lock().unwrap().spawn_task(task))
+    impl<'a> PinFutContainer<'a> for Vec<Pin<Box<dyn Future<Output = ()> + 'a>>> {
+        fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F) {
+            self.push(Box::pin(f()));
         }
-    }
 
-    /// A Helper type for preparing test data such as block devices AND download buffers for
-    /// Fastboot tests.
-    struct TestData {
-        /// Fake backing storage.
-        storage: FakeGblOpsStorage,
-        /// Download buffers.
-        download: Vec<Vec<u8>>,
-    }
-
-    impl TestData {
-        /// Creates a new instance.
-        ///
-        /// Initializes `dl_n` number of download buffers with size `dl_sz`.
-        fn new(dl_sz: usize, dl_n: usize) -> Self {
-            Self { storage: Default::default(), download: vec![vec![0u8; dl_sz]; dl_n] }
+        fn for_each_remove_if(
+            &mut self,
+            mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+        ) {
+            for idx in (0..self.len()).rev() {
+                cb(&mut self[idx].as_mut()).then(|| self.swap_remove(idx));
+            }
         }
+    }
 
-        /// Creates an array of `PartitionBlockDevice` and fastboot download buffers.
-        fn get(&mut self) -> (Vec<PartitionBlockDevice<&mut TestBlockIo>>, Vec<Mutex<&mut [u8]>>) {
-            (
-                self.storage.as_partition_block_devices(),
-                self.download.iter_mut().map(|v| (&mut v[..]).into()).collect::<Vec<_>>(),
-            )
-        }
+    #[test]
+    fn test_get_var_gbl() {
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let storage = FakeGblOpsStorage::default();
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        check_var(
+            &mut gbl_fb,
+            FakeGblOps::GBL_TEST_VAR,
+            "arg",
+            format!("{}:Some(\"arg\")", FakeGblOps::GBL_TEST_VAR_VAL).as_str(),
+        );
     }
 
     #[test]
     fn test_get_var_partition_info() {
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
-        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        storage.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        storage.add_raw_device(c"raw_1", [0x55u8; 8 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         // Check different semantics
         check_var(&mut gbl_fb, "partition-size", "boot_a", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a:", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a::", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a:::", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a:0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a:0:", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a::0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a:0:0", "0x2000");
-        check_var(&mut gbl_fb, "partition-size", "boot_a::0x1000", "0x1000");
-
-        check_var(&mut gbl_fb, "partition-size", "boot_b:0", "0x3000");
-        check_var(&mut gbl_fb, "partition-size", "vendor_boot_a:1", "0x1000");
-        check_var(&mut gbl_fb, "partition-size", "vendor_boot_b:1", "0x1800");
-        check_var(&mut gbl_fb, "partition-size", "boot_a::0x1000", "0x1000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a/", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a//", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a///", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a/0", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a/0/", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a//0", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a/0/0", "0x2000");
+        check_var(&mut gbl_fb, "partition-size", "boot_a//0x1000", "0x1000");
+
+        check_var(&mut gbl_fb, "partition-size", "boot_b/0", "0x3000");
+        check_var(&mut gbl_fb, "partition-size", "vendor_boot_a/1", "0x1000");
+        check_var(&mut gbl_fb, "partition-size", "vendor_boot_b/1", "0x1800");
+        check_var(&mut gbl_fb, "partition-size", "boot_a//0x1000", "0x1000");
         check_var(&mut gbl_fb, "partition-size", "raw_0", "0x1000");
         check_var(&mut gbl_fb, "partition-size", "raw_1", "0x2000");
 
-        let mut utils: TestFastbootUtils = Default::default();
+        let resp: TestResponder = Default::default();
         let mut out = vec![0u8; MAX_RESPONSE_SIZE];
         assert!(block_on(gbl_fb.get_var_as_str(
-            "partition",
-            "non-existent".split(':'),
+            c"partition",
+            [c"non-existent"].into_iter(),
+            &resp,
             &mut out[..],
-            &mut utils
         ))
         .is_err());
     }
@@ -399,8 +982,14 @@ mod test {
     /// `TestVarSender` implements `TestVarSender`. It stores outputs in a vector of string.
     struct TestVarSender(Vec<String>);
 
-    impl VarSender for TestVarSender {
-        async fn send(&mut self, name: &str, args: &[&str], val: &str) -> CommandResult<()> {
+    impl VarInfoSender for &mut TestVarSender {
+        async fn send_var_info(
+            &mut self,
+            name: &str,
+            args: impl IntoIterator<Item = &'_ str>,
+            val: &str,
+        ) -> Result<(), Error> {
+            let args = args.into_iter().collect::<Vec<_>>();
             self.0.push(format!("{}:{}: {}", name, args.join(":"), val));
             Ok(())
         }
@@ -408,19 +997,20 @@ mod test {
 
     #[test]
     fn test_get_var_all() {
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
-        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-
-        let mut utils: TestFastbootUtils = Default::default();
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        storage.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        storage.add_raw_device(c"raw_1", [0x55u8; 8 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+
         let mut logger = TestVarSender(vec![]);
-        block_on(gbl_fb.get_var_all(&mut logger, &mut utils)).unwrap();
+        block_on(gbl_fb.get_var_all(&mut logger)).unwrap();
         assert_eq!(
             logger.0,
             [
@@ -432,99 +1022,110 @@ mod test {
                 "block-device:1:total-blocks: 0x100",
                 "block-device:1:block-size: 0x200",
                 "block-device:1:status: idle",
-                "block-device:2:total-blocks: 0x8",
-                "block-device:2:block-size: 0x200",
+                "block-device:2:total-blocks: 0x1000",
+                "block-device:2:block-size: 0x1",
                 "block-device:2:status: idle",
-                "block-device:3:total-blocks: 0x10",
-                "block-device:3:block-size: 0x200",
+                "block-device:3:total-blocks: 0x2000",
+                "block-device:3:block-size: 0x1",
                 "block-device:3:status: idle",
                 "gbl-default-block:: None",
-                "partition-size:boot_a:0: 0x2000",
-                "partition-type:boot_a:0: raw",
-                "partition-size:boot_b:0: 0x3000",
-                "partition-type:boot_b:0: raw",
-                "partition-size:vendor_boot_a:1: 0x1000",
-                "partition-type:vendor_boot_a:1: raw",
-                "partition-size:vendor_boot_b:1: 0x1800",
-                "partition-type:vendor_boot_b:1: raw",
-                "partition-size:raw_0:2: 0x1000",
-                "partition-type:raw_0:2: raw",
-                "partition-size:raw_1:3: 0x2000",
-                "partition-type:raw_1:3: raw",
+                "partition-size:boot_a/0: 0x2000",
+                "partition-type:boot_a/0: raw",
+                "partition-size:boot_b/0: 0x3000",
+                "partition-type:boot_b/0: raw",
+                "partition-size:vendor_boot_a/1: 0x1000",
+                "partition-type:vendor_boot_a/1: raw",
+                "partition-size:vendor_boot_b/1: 0x1800",
+                "partition-type:vendor_boot_b/1: raw",
+                "partition-size:raw_0/2: 0x1000",
+                "partition-type:raw_0/2: raw",
+                "partition-size:raw_1/3: 0x2000",
+                "partition-type:raw_1/3: raw",
+                format!("{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_str(),
+                format!("{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_str(),
             ]
         );
     }
 
     /// A helper for fetching partition from a `GblFastboot`
     fn fetch<EOff: core::fmt::Debug, ESz: core::fmt::Debug>(
-        fb: &mut TestGblFastboot,
+        fb: &mut impl FastbootImplementation,
         part: String,
         off: impl TryInto<u64, Error = EOff>,
         size: impl TryInto<u64, Error = ESz>,
     ) -> CommandResult<Vec<u8>> {
         let off = off.try_into().unwrap();
         let size = size.try_into().unwrap();
-        // Forces upload in two batches for testing.
-        let download_buffer = vec![0u8; max(1, usize::try_from(size).unwrap() / 2usize)];
-        let mut utils: TestFastbootUtils = Default::default();
         let mut upload_out = vec![0u8; usize::try_from(size).unwrap()];
         let test_uploader = TestUploadBuilder(&mut upload_out[..]);
-        block_on(fb.fetch(part.as_str(), off, size, test_uploader, &mut utils))?;
+        block_on(fb.fetch(part.as_str(), off, size, test_uploader))?;
         Ok(upload_out)
     }
 
     #[test]
     fn test_fetch_invalid_partition_arg() {
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         // Missing mandatory block device ID for raw block partition.
-        assert!(fetch(&mut gbl_fb, "::0:0".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "//0/0".into(), 0, 0).is_err());
 
         // GPT partition does not exist.
-        assert!(fetch(&mut gbl_fb, "non:::".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "non///".into(), 0, 0).is_err());
 
         // GPT Partition is not unique.
-        assert!(fetch(&mut gbl_fb, "vendor_boot_a:::".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "vendor_boot_a///".into(), 0, 0).is_err());
 
         // Offset overflows.
-        assert!(fetch(&mut gbl_fb, "boot_a::0x2001:".into(), 0, 1).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a//0x2001/".into(), 0, 1).is_err());
         assert!(fetch(&mut gbl_fb, "boot_a".into(), 0x2000, 1).is_err());
 
         // Size overflows.
-        assert!(fetch(&mut gbl_fb, "boot_a:::0x2001".into(), 0, 0).is_err());
+        assert!(fetch(&mut gbl_fb, "boot_a///0x2001".into(), 0, 0).is_err());
         assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, 0x2001).is_err());
     }
 
     /// A helper for testing raw block upload. It verifies that data read from block device
     /// `blk_id` in range [`off`, `off`+`size`) is the same as `disk[off..][..size]`
-    fn check_blk_upload(fb: &mut TestGblFastboot, blk_id: u64, off: u64, size: u64, disk: &[u8]) {
+    fn check_blk_upload(
+        fb: &mut impl FastbootImplementation,
+        blk_id: u64,
+        off: u64,
+        size: u64,
+        disk: &[u8],
+    ) {
         let expected = disk[off.try_into().unwrap()..][..size.try_into().unwrap()].to_vec();
         // offset/size as part of the partition string.
-        let part = format!(":{:#x}:{:#x}:{:#x}", blk_id, off, size);
+        let part = format!("/{:#x}/{:#x}/{:#x}", blk_id, off, size);
         assert_eq!(fetch(fb, part, 0, size).unwrap(), expected);
         // offset/size as separate fetch arguments.
-        let part = format!(":{:#x}", blk_id);
+        let part = format!("/{:#x}", blk_id);
         assert_eq!(fetch(fb, part, off, size).unwrap(), expected);
     }
 
     #[test]
     fn test_fetch_raw_block() {
-        let mut test_data = TestData::new(128 * 1024, 1);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
         let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
         let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        test_data.storage.add_gpt_device(disk_0);
-        test_data.storage.add_gpt_device(disk_1);
-        let (parts, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&parts);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        storage.add_gpt_device(disk_0);
+        storage.add_gpt_device(disk_1);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         let off = 512;
         let size = 512;
@@ -536,7 +1137,7 @@ mod test {
     /// `part` at disk `blk_id` in range [`off`, `off`+`size`) is the same as
     /// `partition_data[off..][..size]`.
     fn check_part_upload(
-        fb: &mut TestGblFastboot,
+        fb: &mut impl FastbootImplementation,
         part: &str,
         off: u64,
         size: u64,
@@ -547,24 +1148,26 @@ mod test {
             partition_data[off.try_into().unwrap()..][..size.try_into().unwrap()].to_vec();
         let blk_id = blk_id.map_or("".to_string(), |v| format!("{:#x}", v));
         // offset/size as part of the partition string.
-        let gpt_part = format!("{}:{}:{:#x}:{:#x}", part, blk_id, off, size);
+        let gpt_part = format!("{}/{}/{:#x}/{:#x}", part, blk_id, off, size);
         assert_eq!(fetch(fb, gpt_part, 0, size).unwrap(), expected);
         // offset/size as separate fetch arguments.
-        let gpt_part = format!("{}:{}", part, blk_id);
+        let gpt_part = format!("{}/{}", part, blk_id);
         assert_eq!(fetch(fb, gpt_part, off, size).unwrap(), expected);
     }
 
     #[test]
     fn test_fetch_partition() {
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
-        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        storage.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        storage.add_raw_device(c"raw_1", [0x55u8; 8 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
         let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
@@ -596,18 +1199,18 @@ mod test {
     }
 
     /// A helper function to flash data to a partition
-    fn flash_part(fb: &mut TestGblFastboot, part: &str, data: &[u8]) {
+    fn flash_part(fb: &mut impl FastbootImplementation, part: &str, data: &[u8]) {
         // Prepare a download buffer.
         let dl_size = data.len();
         let download = data.to_vec();
-        let mut utils: TestFastbootUtils = Default::default();
+        let resp: TestResponder = Default::default();
         set_download(fb, &download[..]);
-        block_on(fb.flash(part, &mut utils)).unwrap();
+        block_on(fb.flash(part, &resp)).unwrap();
         assert_eq!(fetch(fb, part.into(), 0, dl_size).unwrap(), download);
     }
 
     /// A helper for testing partition flashing.
-    fn check_flash_part(fb: &mut TestGblFastboot, part: &str, expected: &[u8]) {
+    fn check_flash_part(fb: &mut impl FastbootImplementation, part: &str, expected: &[u8]) {
         flash_part(fb, part, expected);
         // Also flashes bit-wise reversed version in case the initial content is the same.
         flash_part(fb, part, &flipped_bits(expected));
@@ -617,15 +1220,17 @@ mod test {
     fn test_flash_partition() {
         let disk_0 = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
         let disk_1 = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(disk_0);
-        test_data.storage.add_gpt_device(disk_1);
-        test_data.storage.add_raw_device("raw_0", [0xaau8; 4 * 1024]);
-        test_data.storage.add_raw_device("raw_1", [0x55u8; 8 * 1024]);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(disk_0);
+        storage.add_gpt_device(disk_1);
+        storage.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        storage.add_raw_device(c"raw_1", [0x55u8; 8 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         let expect_boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
         let expect_boot_b = include_bytes!("../../../libstorage/test/boot_b.bin");
@@ -633,46 +1238,48 @@ mod test {
         check_flash_part(&mut gbl_fb, "boot_b", expect_boot_b);
         check_flash_part(&mut gbl_fb, "raw_0", &[0xaau8; 4 * 1024]);
         check_flash_part(&mut gbl_fb, "raw_1", &[0x55u8; 8 * 1024]);
-        check_flash_part(&mut gbl_fb, ":0", disk_0);
-        check_flash_part(&mut gbl_fb, ":1", disk_1);
+        check_flash_part(&mut gbl_fb, "/0", disk_0);
+        check_flash_part(&mut gbl_fb, "/1", disk_1);
 
         // Partital flash
         let off = 0x200;
         let size = 1024;
-        check_flash_part(&mut gbl_fb, "boot_a::200", &expect_boot_a[off..size]);
-        check_flash_part(&mut gbl_fb, "boot_b::200", &expect_boot_b[off..size]);
-        check_flash_part(&mut gbl_fb, ":0:200", &disk_0[off..size]);
-        check_flash_part(&mut gbl_fb, ":1:200", &disk_1[off..size]);
+        check_flash_part(&mut gbl_fb, "boot_a//200", &expect_boot_a[off..size]);
+        check_flash_part(&mut gbl_fb, "boot_b//200", &expect_boot_b[off..size]);
+        check_flash_part(&mut gbl_fb, "/0/200", &disk_0[off..size]);
+        check_flash_part(&mut gbl_fb, "/1/200", &disk_1[off..size]);
     }
 
     #[test]
     fn test_flash_partition_sparse() {
         let raw = include_bytes!("../../testdata/sparse_test_raw.bin");
         let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_raw_device("raw", vec![0u8; raw.len()]);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"raw", vec![0u8; raw.len()]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
 
         let download = sparse.to_vec();
-        let mut utils: TestFastbootUtils = Default::default();
+        let resp: TestResponder = Default::default();
         set_download(&mut gbl_fb, &download[..]);
-        block_on(gbl_fb.flash(":0", &mut utils)).unwrap();
-        assert_eq!(fetch(&mut gbl_fb, ":0".into(), 0, raw.len()).unwrap(), raw);
+        block_on(gbl_fb.flash("/0", &resp)).unwrap();
+        assert_eq!(fetch(&mut gbl_fb, "/0".into(), 0, raw.len()).unwrap(), raw);
     }
 
     /// A helper to invoke OEM commands.
     ///
     /// Returns the result and INFO strings.
     async fn oem(
-        fb: &mut TestGblFastboot<'_, '_>,
+        fb: &mut impl FastbootImplementation,
         oem_cmd: &str,
-        utils: &mut impl FastbootUtils,
+        resp: impl InfoSender,
     ) -> CommandResult<String> {
         let mut res = [0u8; MAX_RESPONSE_SIZE];
-        fb.oem(oem_cmd, utils, &mut res[..]).await?;
+        fb.oem(oem_cmd, resp, &mut res[..]).await?;
         Ok(from_utf8(&mut res[..]).unwrap().into())
     }
 
@@ -681,47 +1288,44 @@ mod test {
         // Creates two block devices for writing raw and sparse image.
         let sparse_raw = include_bytes!("../../testdata/sparse_test_raw.bin");
         let sparse = include_bytes!("../../testdata/sparse_test.bin");
-        let dev_sparse = TestBlockDeviceBuilder::new()
-            .add_partition("sparse", BackingStore::Size(sparse_raw.len()))
-            .build();
-        let mut test_data = TestData::new(128 * 1024, 2);
-        test_data.storage.add_gpt_device(dev_sparse.io.storage);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-        let mut utils: TestFastbootUtils = Default::default();
-
-        // "oem gbl-sync-blocks" should return immediately when there is no pending IOs.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils))).unwrap().is_ok());
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(vec![0u8; sparse_raw.len() + 67 * 512]);
+        let mut gpt_builder = storage[1].gpt_builder().unwrap();
+        gpt_builder.add("sparse", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).unwrap();
+        block_on(gpt_builder.persist()).unwrap();
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
+
+        // "oem gbl-sync-tasks" should return immediately when there is no pending IOs.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp))).unwrap().is_ok());
         // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
-            .unwrap()
-            .is_ok());
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
 
         // Flashes "boot_a".
         let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
         set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
+        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
 
         // Flashes the "sparse" partition on the different block device.
         set_download(&mut gbl_fb, sparse);
-        block_on(gbl_fb.flash("sparse", &mut utils)).unwrap();
-
-        // The two blocks should be in the pending state.
-        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
+        block_on(gbl_fb.flash("sparse", &resp)).unwrap();
         check_var(&mut gbl_fb, "block-device", "1:status", "IO pending");
 
-        // There should be two disk IO tasks spawned.
-        assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 2);
         {
-            // "oem gbl-sync-blocks" should block.
-            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils));
+            // "oem gbl-sync-tasks" should block.
+            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp));
             assert!(poll(oem_sync_blk_fut).is_none());
             // Schedules the disk IO tasks to completion.
-            blk_io_executor.0.try_lock().unwrap().run();
-            // "oem gbl-sync-blocks" should now be able to finish.
+            tasks.borrow_mut().run();
+            // "oem gbl-sync-tasks" should now be able to finish.
             assert!(poll(oem_sync_blk_fut).unwrap().is_ok());
         }
 
@@ -739,42 +1343,43 @@ mod test {
 
     #[test]
     fn test_async_flash_block_on_busy_blk() {
-        let mut test_data = TestData::new(128 * 1024, 2);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-        let mut utils: TestFastbootUtils = Default::default();
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
 
         // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
-            .unwrap()
-            .is_ok());
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
 
         // Flashes boot_a partition.
         let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
         set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
 
         // Flashes boot_b partition.
         let expect_boot_b = flipped_bits(include_bytes!("../../../libstorage/test/boot_b.bin"));
         set_download(&mut gbl_fb, expect_boot_b.as_slice());
         {
-            let flash_boot_b_fut = &mut pin!(gbl_fb.flash("boot_b", &mut utils));
+            let flash_boot_b_fut = &mut pin!(gbl_fb.flash("boot_b", &resp));
             // Previous IO has not completed. Block is busy.
             assert!(poll(flash_boot_b_fut).is_none());
             // There should only be the previous disk IO task for "boot_a".
-            assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 1);
+            assert_eq!(tasks.borrow_mut().size(), 1);
             // Schedule the disk IO task for "flash boot_a" to completion.
-            blk_io_executor.0.try_lock().unwrap().run();
+            tasks.borrow_mut().run();
             // The blocked "flash boot_b" should now be able to finish.
             assert!(poll(flash_boot_b_fut).is_some());
             // There should be a disk IO task spawned for "flash boot_b".
-            assert_eq!(blk_io_executor.0.try_lock().unwrap().num_tasks(), 1);
+            assert_eq!(tasks.borrow_mut().size(), 1);
             // Schedule the disk IO tasks for "flash boot_b" to completion.
-            blk_io_executor.0.try_lock().unwrap().run();
+            tasks.borrow_mut().run();
         }
 
         // Verifies flashed image.
@@ -790,70 +1395,119 @@ mod test {
 
     #[test]
     fn test_async_flash_error() {
-        let mut test_data = TestData::new(128 * 1024, 2);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let mut gbl_ops = FakeGblOps::new(&storage);
         // Injects an error.
-        partitions[0].partition_io(None).unwrap().dev().io().errors =
-            [liberror::Error::Other(None)].into();
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-        let mut utils: TestFastbootUtils = Default::default();
+        storage[0].partition_io(None).unwrap().dev().io().error =
+            liberror::Error::Other(None).into();
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
 
         // Enable async IO.
-        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-block-io", &mut utils)))
-            .unwrap()
-            .is_ok());
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
         // Flashes boot_a partition.
         let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
         set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        block_on(gbl_fb.flash("boot_a", &mut utils)).unwrap();
+        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
         // Schedules the disk IO tasks to completion.
-        blk_io_executor.0.try_lock().unwrap().run();
+        tasks.borrow_mut().run();
         // New flash to "boot_a" should fail due to previous error
         set_download(&mut gbl_fb, expect_boot_a.as_slice());
-        assert!(block_on(gbl_fb.flash("boot_a", &mut utils)).is_err());
-        // "oem gbl-sync-blocks" should fail.
-        assert!(block_on(oem(&mut gbl_fb, "gbl-sync-blocks", &mut utils)).is_err());
+        assert!(block_on(gbl_fb.flash("boot_a", &resp)).is_err());
+        // "oem gbl-sync-tasks" should fail.
+        assert!(block_on(oem(&mut gbl_fb, "gbl-sync-tasks", &resp)).is_err());
+    }
+
+    #[test]
+    fn test_async_erase() {
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"raw_0", [0xaau8; 4096]);
+        storage.add_raw_device(c"raw_1", [0x55u8; 4096]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
+
+        // Enable async IO.
+        assert!(poll(&mut pin!(oem(&mut gbl_fb, "gbl-enable-async-task", &resp))).unwrap().is_ok());
+
+        // Erases "raw_0".
+        block_on(gbl_fb.erase("raw_0", &resp)).unwrap();
+        check_var(&mut gbl_fb, "block-device", "0:status", "IO pending");
+
+        // Erases second half of "raw_1"
+        block_on(gbl_fb.erase("raw_1//800", &resp)).unwrap();
+        check_var(&mut gbl_fb, "block-device", "1:status", "IO pending");
+
+        {
+            // "oem gbl-sync-tasks" should block.
+            let oem_sync_blk_fut = &mut pin!(oem(&mut gbl_fb, "gbl-sync-tasks", &resp));
+            assert!(poll(oem_sync_blk_fut).is_none());
+            // Schedules the disk IO tasks to completion.
+            tasks.borrow_mut().run();
+            // "oem gbl-sync-tasks" should now be able to finish.
+            assert!(poll(oem_sync_blk_fut).unwrap().is_ok());
+        }
+
+        // The two blocks should be in the idle state.
+        check_var(&mut gbl_fb, "block-device", "0:status", "idle");
+        check_var(&mut gbl_fb, "block-device", "1:status", "idle");
+
+        assert_eq!(storage[0].partition_io(None).unwrap().dev().io().storage, [0u8; 4096]);
+        assert_eq!(
+            storage[1].partition_io(None).unwrap().dev().io().storage,
+            [[0x55u8; 2048], [0u8; 2048]].concat()
+        );
     }
 
     #[test]
     fn test_default_block() {
-        let mut test_data = TestData::new(128 * 1024, 1);
-        test_data.storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 1]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
         let disk_dup = include_bytes!("../../../libstorage/test/gpt_test_2.bin");
-        test_data.storage.add_gpt_device(disk_dup);
-        test_data.storage.add_gpt_device(disk_dup);
+        storage.add_gpt_device(disk_dup);
+        storage.add_gpt_device(disk_dup);
         let raw_a = [0xaau8; 4 * 1024];
         let raw_b = [0x55u8; 8 * 1024];
-        test_data.storage.add_raw_device("raw", raw_a);
-        test_data.storage.add_raw_device("raw", raw_b);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-        let mut utils: TestFastbootUtils = Default::default();
+        storage.add_raw_device(c"raw", raw_a);
+        storage.add_raw_device(c"raw", raw_b);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let resp: TestResponder = Default::default();
 
         let boot_a = include_bytes!("../../../libstorage/test/boot_a.bin");
         // Flips the bits on partition "vendor_boot_a" on block device #2 to make it different from
         // block #1.
         let vendor_boot_a =
             flipped_bits(include_bytes!("../../../libstorage/test/vendor_boot_a.bin"));
-        flash_part(&mut gbl_fb, "vendor_boot_a:2", &vendor_boot_a);
+        flash_part(&mut gbl_fb, "vendor_boot_a/2", &vendor_boot_a);
 
         let size = 512;
         let off = 512;
 
         check_var(&mut gbl_fb, "gbl-default-block", "", "None");
         // Sets default block to #2
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 2", &mut utils)).unwrap();
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 2", &resp)).unwrap();
         check_var(&mut gbl_fb, "gbl-default-block", "", "0x2");
         // The following fetch should succeed and fetch from "vendor_boot_a" on block 2.
         check_part_upload(&mut gbl_fb, "vendor_boot_a", off, size, None, &vendor_boot_a);
 
         // Sets default block to #4 (raw_b)
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 4", &mut utils)).unwrap();
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 4", &resp)).unwrap();
         check_var(&mut gbl_fb, "gbl-default-block", "", "0x4");
         // The following fetch should succeed and fetch from "raw" on block 4.
         check_part_upload(&mut gbl_fb, "raw", off, size, None, &raw_b);
@@ -867,31 +1521,941 @@ mod test {
         assert!(fetch(&mut gbl_fb, "boot_a".into(), 0, boot_a.len()).is_err());
 
         // Sets default block to #1 (unmodified `disk_dup`)
-        block_on(oem(&mut gbl_fb, "gbl-set-default-block 1", &mut utils)).unwrap();
+        block_on(oem(&mut gbl_fb, "gbl-set-default-block 1", &resp)).unwrap();
         check_var(&mut gbl_fb, "gbl-default-block", "", "0x1");
         // Fetches whole raw block but without block ID should use the default block.
         check_part_upload(&mut gbl_fb, "", off, size, None, disk_dup);
 
         // Unset default block
-        block_on(oem(&mut gbl_fb, "gbl-unset-default-block", &mut utils)).unwrap();
+        block_on(oem(&mut gbl_fb, "gbl-unset-default-block", &resp)).unwrap();
         check_var(&mut gbl_fb, "gbl-default-block", "", "None");
         // Fetching non-unique partitions should now fail.
         assert!(fetch(&mut gbl_fb, "raw".into(), 0, raw_a.len()).is_err());
         assert!(fetch(&mut gbl_fb, "vendor_boot_a".into(), 0, vendor_boot_a.len()).is_err());
-        assert!(fetch(&mut gbl_fb, ":".into(), 0, 512).is_err());
+        assert!(fetch(&mut gbl_fb, "/".into(), 0, 512).is_err());
     }
 
     #[test]
     fn test_set_default_block_invalid_arg() {
-        let mut test_data = TestData::new(128 * 1024, 2);
-        let (partitions, dl_buffers) = test_data.get();
-        let mut gbl_ops = FakeGblOps::new(&partitions);
-        let blk_io_executor: TestGblFbExecutor = Default::default();
-        let mut gbl_fb = GblFastboot::new(&blk_io_executor, &mut gbl_ops, &dl_buffers);
-        let mut utils: TestFastbootUtils = Default::default();
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let storage = FakeGblOpsStorage::default();
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let resp: TestResponder = Default::default();
         // Missing block device ID.
-        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block ", &mut utils)).is_err());
+        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block ", &resp)).is_err());
         // Invalid block device ID.
-        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block zzz", &mut utils)).is_err());
+        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block zzz", &resp)).is_err());
+        // Out of range block device ID. (We've added no block device).
+        assert!(block_on(oem(&mut gbl_fb, "gbl-set-default-block 0", &resp)).is_err());
+    }
+
+    #[test]
+    fn test_reboot_sync_all_blocks() {
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
+
+        block_on(oem(&mut gbl_fb, "gbl-enable-async-task", &resp)).unwrap();
+
+        // Flashes "boot_a".
+        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
+        // Checks initial state, okay_sent=false.
+        assert!(!(*resp.okay_sent.try_lock().unwrap()));
+        // Performs a reboot.
+        let mut reboot_fut = pin!(gbl_fb.reboot(RebootMode::Normal, &resp));
+        // There is a pending flash task. Reboot should wait.
+        assert!(poll(&mut reboot_fut).is_none());
+        assert!(!(*resp.okay_sent.try_lock().unwrap()));
+        assert_eq!(resp.info_messages.try_lock().unwrap()[1], "Syncing storage...");
+        // Schedules the disk IO tasks to completion.
+        tasks.borrow_mut().run();
+        // The reboot can now complete.
+        assert!(poll(&mut reboot_fut).is_some());
+        assert!((*resp.okay_sent.try_lock().unwrap()));
+        assert_eq!(resp.info_messages.try_lock().unwrap()[2], "Rebooting...");
+    }
+
+    #[test]
+    fn test_continue_sync_all_blocks() {
+        let dl_buffers = Shared::from(vec![vec![0u8; 128 * 1024]; 2]);
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let tasks = vec![].into();
+        let parts = gbl_ops.disks();
+        let mut gbl_fb =
+            GblFastboot::new(&mut gbl_ops, parts, Task::run, &tasks, &dl_buffers, &mut []);
+        let tasks = gbl_fb.tasks();
+        let resp: TestResponder = Default::default();
+
+        block_on(oem(&mut gbl_fb, "gbl-enable-async-task", &resp)).unwrap();
+
+        // Flashes "boot_a".
+        let expect_boot_a = flipped_bits(include_bytes!("../../../libstorage/test/boot_a.bin"));
+        set_download(&mut gbl_fb, expect_boot_a.as_slice());
+        block_on(gbl_fb.flash("boot_a", &resp)).unwrap();
+        // Performs a continue.
+        let mut continue_fut = pin!(gbl_fb.r#continue(&resp));
+        // There is a pending flash task. Continue should wait.
+        assert!(poll(&mut continue_fut).is_none());
+        assert!(!(*resp.okay_sent.try_lock().unwrap()));
+        assert_eq!(resp.info_messages.try_lock().unwrap()[1], "Syncing storage...");
+        // Schedules the disk IO tasks to completion.
+        tasks.borrow_mut().run();
+        // The continue can now complete.
+        assert!(poll(&mut continue_fut).is_some());
+    }
+
+    /// Generates a length prefixed byte sequence.
+    fn length_prefixed(data: &[u8]) -> Vec<u8> {
+        [&data.len().to_be_bytes()[..], data].concat()
+    }
+
+    /// Used for a test implementation of [GblUsbTransport] and [GblTcpStream].
+    #[derive(Default)]
+    struct TestListener {
+        usb_in_queue: VecDeque<Vec<u8>>,
+        usb_out_queue: VecDeque<Vec<u8>>,
+
+        tcp_in_queue: VecDeque<u8>,
+        tcp_out_queue: VecDeque<u8>,
+    }
+
+    /// A shared [TestListener].
+    #[derive(Default)]
+    struct SharedTestListener(Mutex<TestListener>);
+
+    impl SharedTestListener {
+        /// Locks the listener
+        fn lock(&self) -> MutexGuard<TestListener> {
+            self.0.try_lock().unwrap()
+        }
+
+        /// Adds packet to USB input
+        fn add_usb_input(&self, packet: &[u8]) {
+            self.lock().usb_in_queue.push_back(packet.into());
+        }
+
+        /// Adds bytes to input stream.
+        fn add_tcp_input(&self, data: &[u8]) {
+            self.lock().tcp_in_queue.append(&mut data.to_vec().into());
+        }
+
+        /// Adds a length pre-fixed bytes stream.
+        fn add_tcp_length_prefixed_input(&self, data: &[u8]) {
+            self.add_tcp_input(&length_prefixed(data));
+        }
+
+        /// Gets a copy of `Self::usb_out_queue`.
+        fn usb_out_queue(&self) -> VecDeque<Vec<u8>> {
+            self.lock().usb_out_queue.clone()
+        }
+
+        /// Gets a copy of `Self::tcp_out_queue`.
+        fn tcp_out_queue(&self) -> VecDeque<u8> {
+            self.lock().tcp_out_queue.clone()
+        }
+
+        /// A helper for decoding USB output packets as a string
+        fn dump_usb_out_queue(&self) -> String {
+            let mut res = String::from("");
+            for v in self.lock().usb_out_queue.iter() {
+                let v = String::from_utf8(v.clone()).unwrap_or(format!("{:?}", v));
+                res += format!("b{:?},\n", v).as_str();
+            }
+            res
+        }
+
+        /// A helper for decoding TCP output data as strings
+        fn dump_tcp_out_queue(&self) -> String {
+            let mut data = self.lock();
+            let mut v;
+            let (_, mut remains) = data.tcp_out_queue.make_contiguous().split_at(4);
+            let mut res = String::from("");
+            while !remains.is_empty() {
+                // Parses length-prefixed payload.
+                let (len, rest) = remains.split_first_chunk::<{ size_of::<u64>() }>().unwrap();
+                (v, remains) = rest.split_at(u64::from_be_bytes(*len).try_into().unwrap());
+                let s = String::from_utf8(v.to_vec()).unwrap_or(format!("{:?}", v));
+                res += format!("b{:?},\n", s).as_str();
+            }
+            res
+        }
+    }
+
+    impl Transport for &SharedTestListener {
+        async fn receive_packet(&mut self, out: &mut [u8]) -> Result<usize, Error> {
+            match self.lock().usb_in_queue.pop_front() {
+                Some(v) => Ok((&v[..]).read(out).unwrap()),
+                _ => Err(Error::Other(Some("No more data"))),
+            }
+        }
+
+        async fn send_packet(&mut self, packet: &[u8]) -> Result<(), Error> {
+            Ok(self.lock().usb_out_queue.push_back(packet.into()))
+        }
+    }
+
+    impl GblUsbTransport for &SharedTestListener {
+        fn has_packet(&mut self) -> bool {
+            !self.lock().usb_in_queue.is_empty()
+        }
+    }
+
+    impl TcpStream for &SharedTestListener {
+        async fn read_exact(&mut self, out: &mut [u8]) -> Result<(), Error> {
+            match self.lock().tcp_in_queue.read(out).unwrap() == out.len() {
+                true => Ok(()),
+                _ => Err(Error::Other(Some("No more data"))),
+            }
+        }
+
+        async fn write_exact(&mut self, data: &[u8]) -> Result<(), Error> {
+            Ok(self.lock().tcp_out_queue.append(&mut data.to_vec().into()))
+        }
+    }
+
+    impl GblTcpStream for &SharedTestListener {
+        fn accept_new(&mut self) -> bool {
+            !self.lock().tcp_in_queue.is_empty()
+        }
+    }
+
+    /// A helper to make an expected stream of USB output.
+    fn make_expected_usb_out(data: &[&[u8]]) -> VecDeque<Vec<u8>> {
+        VecDeque::from(data.iter().map(|v| v.to_vec()).collect::<Vec<_>>())
+    }
+
+    /// A helper to make an expected stream of TCP output.
+    fn make_expected_tcp_out(data: &[&[u8]]) -> VecDeque<u8> {
+        let mut res = VecDeque::<u8>::from(b"FB01".to_vec());
+        data.iter().for_each(|v| res.append(&mut length_prefixed(v).into()));
+        res
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot() {
+        let storage = FakeGblOpsStorage::default();
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"getvar:version-bootloader");
+        listener.add_tcp_input(b"FB01");
+        listener.add_tcp_length_prefixed_input(b"getvar:max-download-size");
+        listener.add_tcp_length_prefixed_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[b"OKAY1.0"]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+
+        assert_eq!(
+            listener.tcp_out_queue(),
+            make_expected_tcp_out(&[b"OKAY0x20000", b"INFOSyncing storage...", b"OKAY"]),
+            "\nActual TCP output:\n{}",
+            listener.dump_tcp_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_parallel_task() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"raw_0", [0u8; 4 * 1024]);
+        storage.add_raw_device(c"raw_1", [0u8; 8 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+        let mut fb_fut =
+            pin!(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        listener.add_usb_input(b"oem gbl-enable-async-task");
+        listener.add_usb_input(format!("download:{:#x}", 4 * 1024).as_bytes());
+        listener.add_usb_input(&[0x55u8; 4 * 1024]);
+        listener.add_usb_input(b"flash:raw_0");
+
+        listener.add_tcp_input(b"FB01");
+        listener.add_tcp_length_prefixed_input(format!("download:{:#x}", 8 * 1024).as_bytes());
+        listener.add_tcp_length_prefixed_input(&[0xaau8; 8 * 1024]);
+        listener.add_tcp_length_prefixed_input(b"flash:raw_1");
+
+        assert!(poll_n_times(&mut fb_fut, 100).is_none());
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"OKAY",
+                b"DATA00001000",
+                b"OKAY",
+                b"INFOAn IO task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+
+        assert_eq!(
+            listener.tcp_out_queue(),
+            make_expected_tcp_out(&[
+                b"DATA00002000",
+                b"OKAY",
+                b"INFOAn IO task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
+                b"OKAY",
+            ]),
+            "\nActual TCP output:\n{}",
+            listener.dump_tcp_out_queue()
+        );
+
+        // Verifies flashed image on raw_0.
+        assert_eq!(storage[0].partition_io(None).unwrap().dev().io().storage, [0x55u8; 4 * 1024]);
+
+        // Verifies flashed image on raw_1.
+        assert_eq!(storage[1].partition_io(None).unwrap().dev().io().storage, [0xaau8; 8 * 1024]);
+    }
+
+    #[test]
+    fn test_oem_add_staged_bootloader_file() {
+        let storage = FakeGblOpsStorage::default();
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.get_zbi_bootloader_files_buffer().unwrap().fill(0);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        // Stages two zbi files.
+        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
+        listener.add_usb_input(b"foo");
+        listener.add_usb_input(b"oem add-staged-bootloader-file file_1");
+        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
+        listener.add_usb_input(b"bar");
+        listener.add_usb_input(b"oem add-staged-bootloader-file file_2");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        let buffer = gbl_ops.get_zbi_bootloader_files_buffer_aligned().unwrap();
+        let container = ZbiContainer::parse(&buffer[..]).unwrap();
+        let mut iter = container.iter();
+        assert_eq!(iter.next().unwrap().payload.as_bytes(), b"\x06file_1foo");
+        assert_eq!(iter.next().unwrap().payload.as_bytes(), b"\x06file_2bar");
+        assert!(iter.next().is_none());
+    }
+
+    #[test]
+    fn test_oem_add_staged_bootloader_file_missing_file_name() {
+        let storage = FakeGblOpsStorage::default();
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(format!("download:{:#x}", 3).as_bytes());
+        listener.add_usb_input(b"foo");
+        listener.add_usb_input(b"oem add-staged-bootloader-file");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"DATA00000003",
+                b"OKAY",
+                b"FAILMissing file name",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        )
+    }
+
+    #[test]
+    fn test_oem_add_staged_bootloader_file_missing_download() {
+        let storage = FakeGblOpsStorage::default();
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"oem add-staged-bootloader-file file1");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[b"FAILNo file staged", b"INFOSyncing storage...", b"OKAY",]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_fuchsia_fastboot_mdns_packet() {
+        let expected = [
+            0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x09, 0x5f,
+            0x66, 0x61, 0x73, 0x74, 0x62, 0x6f, 0x6f, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05,
+            0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78,
+            0x00, 0x19, 0x16, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x35, 0x32, 0x35,
+            0x34, 0x2d, 0x30, 0x30, 0x31, 0x32, 0x2d, 0x33, 0x34, 0x35, 0x36, 0xc0, 0x0c, 0xc0,
+            0x2c, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x1f, 0x00, 0x00, 0x00,
+            0x00, 0x15, 0xb2, 0x16, 0x66, 0x75, 0x63, 0x68, 0x73, 0x69, 0x61, 0x2d, 0x35, 0x32,
+            0x35, 0x34, 0x2d, 0x30, 0x30, 0x31, 0x32, 0x2d, 0x33, 0x34, 0x35, 0x36, 0xc0, 0x1b,
+            0xc0, 0x57, 0x00, 0x1c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x10, 0xfe, 0x80,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12, 0x34, 0x56,
+        ];
+        let ip6_addr = &[
+            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12,
+            0x34, 0x56,
+        ];
+        assert_eq!(
+            fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-3456", ip6_addr).unwrap(),
+            expected
+        );
+    }
+
+    #[test]
+    fn test_fuchsia_fastboot_mdns_packet_invalid_node_name() {
+        let ip6_addr = &[
+            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x54, 0x00, 0xff, 0xfe, 0x12,
+            0x34, 0x56,
+        ];
+        assert!(fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-345", ip6_addr).is_err());
+        assert!(fuchsia_fastboot_mdns_packet("fuchsia-5254-0012-34567", ip6_addr).is_err());
+    }
+
+    #[test]
+    fn test_oem_update_gpt() {
+        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        // Erase the primary and secondary header.
+        let mut disk = disk_orig.to_vec();
+        disk[512..][..512].fill(0);
+        disk.last_chunk_mut::<512>().unwrap().fill(0);
+
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(&disk);
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        // Checks that there is no valid partitions for block #0.
+        listener.add_usb_input(b"getvar:partition-size:boot_a");
+        listener.add_usb_input(b"getvar:partition-size:boot_b");
+        // No partitions on block #0 should show up in `getvar:all` despite being a GPT device,
+        // since the GPTs are corrupted.
+        listener.add_usb_input(b"getvar:all");
+        // Download a GPT
+        let gpt = &disk_orig[..34 * 512];
+        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
+        listener.add_usb_input(gpt);
+        listener.add_usb_input(b"flash:gpt/0");
+        // Checks that we can get partition info now.
+        listener.add_usb_input(b"getvar:partition-size:boot_a");
+        listener.add_usb_input(b"getvar:partition-size:boot_b");
+        listener.add_usb_input(b"getvar:all");
+
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"FAILNotFound",
+                b"FAILNotFound",
+                b"INFOmax-download-size: 0x20000",
+                b"INFOversion-bootloader: 1.0",
+                b"INFOmax-fetch-size: 0xffffffffffffffff",
+                b"INFOblock-device:0:total-blocks: 0x80",
+                b"INFOblock-device:0:block-size: 0x200",
+                b"INFOblock-device:0:status: idle",
+                b"INFOblock-device:1:total-blocks: 0x100",
+                b"INFOblock-device:1:block-size: 0x200",
+                b"INFOblock-device:1:status: idle",
+                b"INFOgbl-default-block: None",
+                b"INFOpartition-size:vendor_boot_a/1: 0x1000",
+                b"INFOpartition-type:vendor_boot_a/1: raw",
+                b"INFOpartition-size:vendor_boot_b/1: 0x1800",
+                b"INFOpartition-type:vendor_boot_b/1: raw",
+                format!("INFO{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_bytes(),
+                format!("INFO{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_bytes(),
+                b"OKAY",
+                b"DATA00004400",
+                b"OKAY",
+                b"INFOUpdating GPT...",
+                b"OKAY",
+                b"OKAY0x2000",
+                b"OKAY0x3000",
+                b"INFOmax-download-size: 0x20000",
+                b"INFOversion-bootloader: 1.0",
+                b"INFOmax-fetch-size: 0xffffffffffffffff",
+                b"INFOblock-device:0:total-blocks: 0x80",
+                b"INFOblock-device:0:block-size: 0x200",
+                b"INFOblock-device:0:status: idle",
+                b"INFOblock-device:1:total-blocks: 0x100",
+                b"INFOblock-device:1:block-size: 0x200",
+                b"INFOblock-device:1:status: idle",
+                b"INFOgbl-default-block: None",
+                b"INFOpartition-size:boot_a/0: 0x2000",
+                b"INFOpartition-type:boot_a/0: raw",
+                b"INFOpartition-size:boot_b/0: 0x3000",
+                b"INFOpartition-type:boot_b/0: raw",
+                b"INFOpartition-size:vendor_boot_a/1: 0x1000",
+                b"INFOpartition-type:vendor_boot_a/1: raw",
+                b"INFOpartition-size:vendor_boot_b/1: 0x1800",
+                b"INFOpartition-type:vendor_boot_b/1: raw",
+                format!("INFO{}:1: {}:1", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_bytes(),
+                format!("INFO{}:2: {}:2", FakeGblOps::GBL_TEST_VAR, FakeGblOps::GBL_TEST_VAR_VAL)
+                    .as_bytes(),
+                b"OKAY",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_update_gpt_resize() {
+        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Doubles the size of the disk
+        disk.resize(disk_orig.len() * 2, 0);
+
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        storage.add_gpt_device(&disk);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        // Checks current size of last partition `boot_b`.
+        listener.add_usb_input(b"getvar:partition-size:boot_b");
+        // Sets a default block.
+        listener.add_usb_input(b"oem gbl-set-default-block 1");
+        let gpt = &disk_orig[..34 * 512];
+        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
+        listener.add_usb_input(gpt);
+        // No need to specify block device index
+        listener.add_usb_input(b"flash:gpt//resize");
+        // Checks updated size of last partition `boot_b`.
+        listener.add_usb_input(b"getvar:partition-size:boot_b");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"OKAY0x3000",
+                b"INFODefault block device: 0x1",
+                b"OKAY",
+                b"DATA00004400",
+                b"OKAY",
+                b"INFOUpdating GPT...",
+                b"OKAY",
+                b"OKAY0x15a00",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_update_gpt_no_downloaded_gpt() {
+        let disk = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(&disk);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"flash:gpt/0");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[b"FAILNo GPT downloaded", b"INFOSyncing storage...", b"OKAY",]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_update_gpt_bad_gpt() {
+        let disk = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(&disk);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+        // Download a bad GPT.
+        let mut gpt = disk[..34 * 512].to_vec();
+        gpt[512] = !gpt[512];
+        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
+        listener.add_usb_input(&gpt);
+        listener.add_usb_input(b"flash:gpt/0");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"DATA00004400",
+                b"OKAY",
+                b"INFOUpdating GPT...",
+                b"FAILGptError(\n    IncorrectMagic(\n        6075990659671082682,\n    ),\n)",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_update_gpt_invalid_input() {
+        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(&disk_orig);
+        storage.add_gpt_device(&disk_orig);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        let gpt = &disk_orig[..34 * 512];
+        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
+        listener.add_usb_input(gpt);
+        // Missing block device ID.
+        listener.add_usb_input(b"flash:gpt");
+        // Out of range block device ID.
+        listener.add_usb_input(b"flash:gpt/2");
+        // Invalid option.
+        listener.add_usb_input(b"flash:gpt/0/invalid-arg");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"DATA00004400",
+                b"OKAY",
+                b"FAILBlock ID is required for flashing GPT",
+                b"FAILInvalid block ID",
+                b"FAILUnknown argument",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_update_gpt_fail_on_raw_blk() {
+        let disk_orig = include_bytes!("../../../libstorage/test/gpt_test_1.bin");
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"raw_0", [0u8; 1024 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        let gpt = &disk_orig[..34 * 512];
+        listener.add_usb_input(format!("download:{:#x}", gpt.len()).as_bytes());
+        listener.add_usb_input(gpt);
+        listener.add_usb_input(b"flash:gpt/0");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"DATA00004400",
+                b"OKAY",
+                b"INFOUpdating GPT...",
+                b"FAILBlock device is not for GPT",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_erase_gpt() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_1.bin"));
+        storage.add_gpt_device(include_bytes!("../../../libstorage/test/gpt_test_2.bin"));
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        // Erases the GPT on disk #0.
+        listener.add_usb_input(b"erase:gpt/0");
+        // Checks that we can no longer get partition info on disk #0.
+        listener.add_usb_input(b"getvar:partition-size:boot_a");
+        listener.add_usb_input(b"getvar:partition-size:boot_b");
+        // Checks that we can still get partition info on disk #1.
+        listener.add_usb_input(b"getvar:partition-size:vendor_boot_a");
+        listener.add_usb_input(b"getvar:partition-size:vendor_boot_b");
+        listener.add_usb_input(b"continue");
+
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"OKAY",
+                b"FAILNotFound",
+                b"FAILNotFound",
+                b"OKAY0x1000",
+                b"OKAY0x1800",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_oem_erase_gpt_fail_on_raw_blk() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"raw_0", [0u8; 1024 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"erase:gpt/0");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"FAILBlock device is not for GPT",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    /// Helper for testing fastboot set_active in fuchsia A/B/R mode.
+    fn test_run_gbl_fastboot_set_active_fuchsia_abr(cmd: &str, slot: SlotIndex) {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        mark_slot_unbootable(&mut GblAbrOps(&mut gbl_ops), SlotIndex::A).unwrap();
+        mark_slot_unbootable(&mut GblAbrOps(&mut gbl_ops), SlotIndex::B).unwrap();
+
+        // Flash some data to `durable_boot` after A/B/R metadata. This is for testing that sync
+        // storage is done first.
+        let data = vec![0x55u8; 4 * 1024 - ABR_DATA_SIZE];
+        listener.add_usb_input(b"oem gbl-enable-async-task");
+        listener.add_usb_input(format!("download:{:#x}", 4 * 1024 - ABR_DATA_SIZE).as_bytes());
+        listener.add_usb_input(&data);
+        listener.add_usb_input(format!("flash:durable_boot//{:#x}", ABR_DATA_SIZE).as_bytes());
+        // Issues set_active commands
+        listener.add_usb_input(cmd.as_bytes());
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"OKAY",
+                b"DATA00000fe0",
+                b"OKAY",
+                b"INFOAn IO task is launched. To sync manually, run \"oem gbl-sync-tasks\".",
+                b"OKAY",
+                b"OKAY",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (slot, false));
+        // Verifies storage sync
+        assert_eq!(
+            storage[0].partition_io(None).unwrap().dev().io().storage[ABR_DATA_SIZE..],
+            data
+        );
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_set_active_fuchsia_abr_a() {
+        test_run_gbl_fastboot_set_active_fuchsia_abr("set_active:a", SlotIndex::A);
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_set_active_fuchsia_abr_b() {
+        test_run_gbl_fastboot_set_active_fuchsia_abr("set_active:b", SlotIndex::B);
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_set_active_fuchsia_abr_invalid_slot() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"set_active:r");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"FAILInvalid slot index for Fuchsia A/B/R",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_fuchsia_reboot_bootloader_abr() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"reboot-bootloader");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"INFOSyncing storage...",
+                b"INFORebooting to bootloader...",
+                b"OKAY",
+                b"FAILUnknown",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+
+        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(true));
+    }
+
+    #[test]
+    fn test_run_gbl_fastboot_fuchsia_reboot_recovery_abr() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(b"reboot-recovery");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"INFOSyncing storage...",
+                b"INFORebooting to recovery...",
+                b"OKAY",
+                b"FAILUnknown",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
+
+        // One shot recovery is set.
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::R, false));
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
+    }
+
+    #[test]
+    fn test_legacy_fvm_partition_aliase() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"fuchsia-fvm", [0x00u8; 4 * 1024]);
+        let buffers = vec![vec![0u8; 128 * 1024]; 2];
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        let listener: SharedTestListener = Default::default();
+        let (usb, tcp) = (&listener, &listener);
+
+        listener.add_usb_input(format!("download:{:#x}", 4 * 1024).as_bytes());
+        listener.add_usb_input(&[0xaau8; 4 * 1024]);
+        listener.add_usb_input(b"flash:fvm");
+        listener.add_usb_input(b"continue");
+        block_on(run_gbl_fastboot_stack::<2>(&mut gbl_ops, buffers, Some(usb), Some(tcp), &mut []));
+
+        assert_eq!(
+            listener.usb_out_queue(),
+            make_expected_usb_out(&[
+                b"DATA00001000",
+                b"OKAY",
+                b"OKAY",
+                b"INFOSyncing storage...",
+                b"OKAY",
+            ]),
+            "\nActual USB output:\n{}",
+            listener.dump_usb_out_queue()
+        );
     }
 }
diff --git a/gbl/libgbl/src/fastboot/pin_fut_container.rs b/gbl/libgbl/src/fastboot/pin_fut_container.rs
new file mode 100644
index 0000000..88d8849
--- /dev/null
+++ b/gbl/libgbl/src/fastboot/pin_fut_container.rs
@@ -0,0 +1,124 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use core::{future::Future, pin::Pin};
+use gbl_async::poll;
+
+/// A container abstraction that takes input of dynamically typed [Future]s and stores them at
+/// pinned memory locations.
+pub trait PinFutContainer<'a> {
+    /// Adds and pins a new [Future] of any type generated by the given closure `f`.
+    ///
+    /// If operation cannot be performed, such as due to no capacity, `f` should not be called.
+    fn add_with<F: Future<Output = ()> + 'a>(&mut self, f: impl FnOnce() -> F);
+
+    /// Calls the closure on each element in the container. Removes the element if it returns true.
+    fn for_each_remove_if(
+        &mut self,
+        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+    );
+}
+
+/// An internal container abstraction that takes input of a specific type of [Future] and stores
+/// them at pinned memory locations.
+pub(crate) trait PinFutContainerTyped<'a, F: Future + 'a> {
+    /// Adds and pins a new [Future] of type T into the container returned by `f`.
+    ///
+    /// If operation cannot be performed, such as due to no capacity, `f` should not be called.
+    fn add_with(&mut self, f: impl FnOnce() -> F);
+
+    /// Calls the closure on each element in the container. Removes the element if it returns true.
+    fn for_each_remove_if(
+        &mut self,
+        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+    );
+
+    /// Returns the number of items
+    #[cfg(test)]
+    fn size(&mut self) -> usize {
+        let mut res = 0;
+        self.for_each_remove_if(|_| {
+            res += 1;
+            false
+        });
+        res
+    }
+
+    /// Polls all the [Future] once. Returns the number or unfinished ones.
+    fn poll_all(&mut self) -> usize {
+        let mut res = 0;
+        self.for_each_remove_if(|v| {
+            let finished = poll(v).is_some();
+            res += usize::from(!finished);
+            finished
+        });
+        res
+    }
+
+    /// Runs until all futures are finished
+    #[cfg(test)]
+    fn run(&mut self) {
+        while self.poll_all() > 0 {}
+    }
+}
+
+/// `PinFutContainer` can implement `PinFutContainerTyped` for any [Future] type.
+impl<'a, F: Future<Output = ()> + 'a, T: PinFutContainer<'a>> PinFutContainerTyped<'a, F> for T {
+    fn add_with(&mut self, f: impl FnOnce() -> F) {
+        PinFutContainer::add_with(self, move || f())
+    }
+
+    fn for_each_remove_if(
+        &mut self,
+        cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+    ) {
+        PinFutContainer::for_each_remove_if(self, cb)
+    }
+}
+
+/// An implementation of `PinFutContainerTyped` backed by a preallocated slice.
+pub(crate) struct PinFutSlice<'a, F> {
+    arr: &'a mut [Pin<&'a mut F>],
+    used: usize,
+}
+
+impl<'a, F> PinFutSlice<'a, F> {
+    /// Creates a new instance
+    pub fn new(arr: &'a mut [Pin<&'a mut F>]) -> Self {
+        Self { arr, used: 0 }
+    }
+}
+
+impl<'a, F: Future<Output = ()> + 'a> PinFutContainerTyped<'a, F> for PinFutSlice<'a, F> {
+    fn add_with(&mut self, f: impl FnOnce() -> F) {
+        if self.used < self.arr.len() {
+            self.arr[self.used].set(f());
+            self.used += 1;
+        }
+    }
+
+    fn for_each_remove_if(
+        &mut self,
+        mut cb: impl FnMut(&mut Pin<&mut (dyn Future<Output = ()> + 'a)>) -> bool,
+    ) {
+        // Iterates from the end because we swap remove with the last.
+        for idx in (0..self.used).rev() {
+            if cb(&mut (self.arr[idx].as_mut() as _)) {
+                // Swaps remove with the last element
+                self.used -= 1;
+                self.arr.swap(idx, self.used);
+            }
+        }
+    }
+}
diff --git a/gbl/libgbl/src/fastboot/shared.rs b/gbl/libgbl/src/fastboot/shared.rs
new file mode 100644
index 0000000..e5d1908
--- /dev/null
+++ b/gbl/libgbl/src/fastboot/shared.rs
@@ -0,0 +1,41 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use core::{
+    cell::RefCell,
+    ops::{Deref, DerefMut},
+};
+
+/// A shared instance guarded by `RefCell`.
+pub struct Shared<T>(RefCell<T>);
+
+impl<T> From<T> for Shared<T> {
+    fn from(val: T) -> Self {
+        Shared(val.into())
+    }
+}
+
+impl<T> Deref for Shared<T> {
+    type Target = RefCell<T>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl<T> DerefMut for Shared<T> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.0
+    }
+}
diff --git a/gbl/libgbl/src/fastboot/sparse.rs b/gbl/libgbl/src/fastboot/sparse.rs
index 725f1ee..640eab9 100644
--- a/gbl/libgbl/src/fastboot/sparse.rs
+++ b/gbl/libgbl/src/fastboot/sparse.rs
@@ -16,7 +16,7 @@ use core::{
     cmp::{max, min},
     mem::size_of,
 };
-use fastboot::CommandError;
+use liberror::Error;
 use static_assertions::const_assert;
 use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
 
@@ -66,7 +66,7 @@ const ERR_ARITHMETIC_OVERFLOW: &str = "Arithmetic Overflow";
 const ERR_IMAGE_SIZE: &str = "Bad image. Invalid image size";
 
 /// Checks if a sparse image is valid and returns the sparse header.
-pub fn is_sparse_image(sparse_img: &[u8]) -> Result<SparseHeader, CommandError> {
+pub fn is_sparse_image(sparse_img: &[u8]) -> Result<SparseHeader, Error> {
     let sparse_header: SparseHeader = copy_from(sparse_img)?;
     if sparse_header.magic != HEADER_MAGIC {
         return Err("Sparse magic mismatch".into());
@@ -135,7 +135,7 @@ const_assert!(size_of::<FillInfo>() < size_of::<ChunkHeader>());
 /// `SparseRawWriter` defines an interface for writing to raw storage used by `write_sparse_image`.
 pub(crate) trait SparseRawWriter {
     /// Writes bytes from `data` to the destination storage at offset `off`
-    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError>;
+    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error>;
 }
 
 /// Write a sparse image in `sparse_img`.
@@ -152,7 +152,7 @@ pub(crate) trait SparseRawWriter {
 pub async fn write_sparse_image(
     sparse_img: &mut [u8],
     writer: &mut impl SparseRawWriter,
-) -> Result<u64, CommandError> {
+) -> Result<u64, Error> {
     let sparse_header: SparseHeader = is_sparse_image(sparse_img)?;
     let mut curr: usize = size_of::<SparseHeader>();
     let mut write_offset = 0u64;
@@ -224,7 +224,7 @@ struct FillBuffer<'a> {
 
 impl FillBuffer<'_> {
     /// Get a buffer up to `size` number of bytes filled with `val`.
-    fn get(&mut self, val: u32, size: u64) -> Result<&mut [u8], CommandError> {
+    fn get(&mut self, val: u32, size: u64) -> Result<&mut [u8], Error> {
         let aligned_len = self.buffer.len() - (self.buffer.len() % size_of::<u32>());
         let size: usize = min(to_u64(aligned_len)?, size).try_into().unwrap();
         if Some(val) != self.curr_val {
@@ -244,7 +244,7 @@ fn get_mut<L: TryInto<usize>, R: TryInto<usize>>(
     bytes: &mut [u8],
     start: L,
     end: R,
-) -> Result<&mut [u8], CommandError> {
+) -> Result<&mut [u8], Error> {
     bytes.get_mut(to_usize(start)?..to_usize(end)?).ok_or(ERR_IMAGE_SIZE.into())
 }
 
@@ -253,39 +253,42 @@ fn get<L: TryInto<usize>, R: TryInto<usize>>(
     bytes: &[u8],
     start: L,
     end: R,
-) -> Result<&[u8], CommandError> {
+) -> Result<&[u8], Error> {
     bytes.get(to_usize(start)?..to_usize(end)?).ok_or(ERR_IMAGE_SIZE.into())
 }
 
 /// A helper to return a copy of a zerocopy object from bytes.
-fn copy_from<T: AsBytes + FromBytes + Default>(bytes: &[u8]) -> Result<T, CommandError> {
+fn copy_from<T: AsBytes + FromBytes + Default>(bytes: &[u8]) -> Result<T, Error> {
     let mut res: T = Default::default();
     res.as_bytes_mut().clone_from_slice(get(bytes, 0, size_of::<T>())?);
     Ok(res)
 }
 
+// Investigate switching the following to use SafeNum. A naive replacement results in too many
+// `try_into()?` callsites which looks chaotics. Some proper wrapper might still be needed.
+
 /// Checks and converts an integer into usize.
-fn to_usize<T: TryInto<usize>>(val: T) -> Result<usize, CommandError> {
+fn to_usize<T: TryInto<usize>>(val: T) -> Result<usize, Error> {
     Ok(val.try_into().map_err(|_| ERR_ARITHMETIC_OVERFLOW)?)
 }
 
 /// Adds two usize convertible numbers and checks overflow.
-fn usize_add<L: TryInto<usize>, R: TryInto<usize>>(lhs: L, rhs: R) -> Result<usize, CommandError> {
+fn usize_add<L: TryInto<usize>, R: TryInto<usize>>(lhs: L, rhs: R) -> Result<usize, Error> {
     Ok(to_usize(lhs)?.checked_add(to_usize(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
 }
 
 /// Checks and converts an integer into u64
-fn to_u64<T: TryInto<u64>>(val: T) -> Result<u64, CommandError> {
+fn to_u64<T: TryInto<u64>>(val: T) -> Result<u64, Error> {
     Ok(val.try_into().map_err(|_| ERR_ARITHMETIC_OVERFLOW)?)
 }
 
 /// Adds two u64 convertible numbers and checks overflow.
-fn u64_add<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, CommandError> {
+fn u64_add<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, Error> {
     Ok(to_u64(lhs)?.checked_add(to_u64(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
 }
 
 /// Multiplies two u64 convertible numbers and checks overflow.
-fn u64_mul<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, CommandError> {
+fn u64_mul<L: TryInto<u64>, R: TryInto<u64>>(lhs: L, rhs: R) -> Result<u64, Error> {
     Ok(to_u64(lhs)?.checked_mul(to_u64(rhs)?).ok_or(ERR_ARITHMETIC_OVERFLOW)?)
 }
 
@@ -295,7 +298,7 @@ mod test {
     use gbl_async::block_on;
 
     impl SparseRawWriter for Vec<u8> {
-        async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError> {
+        async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
             self[off.try_into().unwrap()..][..data.len()].clone_from_slice(data);
             Ok(())
         }
diff --git a/gbl/libgbl/src/fastboot/vars.rs b/gbl/libgbl/src/fastboot/vars.rs
index f46b134..c759532 100644
--- a/gbl/libgbl/src/fastboot/vars.rs
+++ b/gbl/libgbl/src/fastboot/vars.rs
@@ -12,307 +12,214 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+use crate::fastboot::PinFutContainerTyped;
 use crate::{
-    fastboot::{GblFastboot, TasksExecutor},
+    fastboot::{BufferPool, GblFastboot},
     GblOps,
 };
-use core::fmt::Write;
-use core::str::{from_utf8, Split};
-use fastboot::{next_arg, next_arg_u64, snprintf, CommandError, FormattedBytes, VarSender};
-
-/// Internal trait that provides methods for getting and enumerating values for one or multiple
-/// related fastboot variables.
-pub(crate) trait Variable {
-    /// Get the variable value given variable name and arguments.
-    ///
-    /// Return Ok(Some(`size`)) where `size` is the number of bytes written to `out`. Return
-    /// `Ok(None)` if the variable is not supported.
-    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        name: &str,
-        args: Split<'_, char>,
-        out: &mut [u8],
-    ) -> Result<Option<usize>, CommandError>;
-
-    /// Iterates and calls `f` on all values/arguments combinations.
-    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        sender: &mut impl VarSender,
-    ) -> Result<(), CommandError>;
-}
-
-// Constant fastboot variableGblFbResource,101
-impl Variable for (&'static str, &'static str) {
-    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        _: &mut GblFastboot<'_, 'b, T, G>,
-        name: &str,
-        _: Split<'_, char>,
-        out: &mut [u8],
-    ) -> Result<Option<usize>, CommandError> {
-        Ok((name == self.0).then_some(snprintf!(out, "{}", self.1).len()))
+use core::{ffi::CStr, fmt::Write, future::Future, ops::DerefMut, str::from_utf8};
+use fastboot::{next_arg, next_arg_u64, snprintf, CommandResult, FormattedBytes, VarInfoSender};
+use gbl_async::{block_on, select, yield_now};
+use gbl_storage::BlockIo;
+
+// See definition of [GblFastboot] for docs on lifetimes and generics parameters.
+impl<'a: 'c, 'b: 'c, 'c, 'd, 'e, G, B, S, T, P, C, F>
+    GblFastboot<'a, 'b, 'c, 'd, 'e, G, B, S, T, P, C, F>
+where
+    G: GblOps<'a, 'e>,
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    T: DerefMut<Target = [u8]>,
+    P: BufferPool,
+    C: PinFutContainerTyped<'c, F>,
+    F: Future<Output = ()> + 'c,
+{
+    const VERSION_BOOTLOADER: &'static str = "version-bootloader";
+    const VERSION_BOOTLOADER_VAL: &'static str = "1.0";
+
+    const MAX_FETCH_SIZE: &'static str = "max-fetch-size";
+    const MAX_FETCH_SIZE_VAL: &'static str = "0xffffffffffffffff";
+
+    /// Entry point for "fastboot getvar <variable>..."
+    pub(crate) fn get_var_internal<'s, 't>(
+        &mut self,
+        name: &CStr,
+        args: impl Iterator<Item = &'t CStr> + Clone,
+        out: &'s mut [u8],
+    ) -> CommandResult<&'s str> {
+        let args_str = args.clone().map(|v| v.to_str());
+        // Checks that all arguments are valid str first.
+        args_str.clone().find(|v| v.is_err()).unwrap_or(Ok(""))?;
+        let args_str = args_str.map(|v| v.unwrap());
+        Ok(match name.to_str()? {
+            Self::VERSION_BOOTLOADER => snprintf!(out, "{}", Self::VERSION_BOOTLOADER_VAL),
+            Self::MAX_FETCH_SIZE => snprintf!(out, "{}", Self::MAX_FETCH_SIZE_VAL),
+            Self::PARTITION_SIZE => self.get_var_partition_size(args_str, out)?,
+            Self::PARTITION_TYPE => self.get_var_partition_type(args_str, out)?,
+            Self::BLOCK_DEVICE => self.get_var_block_device(args_str, out)?,
+            Self::DEFAULT_BLOCK => self.get_var_default_block(out)?,
+            _ => {
+                let sz = self.gbl_ops.fastboot_variable(name, args, out)?;
+                from_utf8(out.get(..sz).ok_or("Invalid variable value size")?)?
+            }
+        })
     }
 
-    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        _: &mut GblFastboot<'_, 'b, T, G>,
-        sender: &mut impl VarSender,
-    ) -> Result<(), CommandError> {
-        sender.send(self.0, &[], self.1).await
+    /// Entry point for "fastboot getvar all..."
+    pub(crate) async fn get_var_all_internal(
+        &mut self,
+        send: &mut impl VarInfoSender,
+    ) -> CommandResult<()> {
+        send.send_var_info(Self::VERSION_BOOTLOADER, [], Self::VERSION_BOOTLOADER_VAL).await?;
+        send.send_var_info(Self::MAX_FETCH_SIZE, [], Self::MAX_FETCH_SIZE_VAL).await?;
+        self.get_all_block_device(send).await?;
+        let mut buf = [0u8; 32];
+        send.send_var_info(Self::DEFAULT_BLOCK, [], self.get_var_default_block(&mut buf)?).await?;
+        self.get_all_partition_size_type(send).await?;
+
+        // Gets platform specific variables
+        let tasks = self.tasks();
+        Ok(self.gbl_ops.fastboot_visit_all_variables(|args, val| {
+            if let Some((name, args)) = args.split_first_chunk::<1>() {
+                let name = name[0].to_str().unwrap_or("?");
+                let args = args.iter().map(|v| v.to_str().unwrap_or("?"));
+                let val = val.to_str().unwrap_or("?");
+                // Manually polls async tasks so that we can still get parallelism while running in
+                // the context of backend.
+                let _ = block_on(select(send.send_var_info(name, args, val), async {
+                    loop {
+                        tasks.borrow_mut().poll_all();
+                        yield_now().await;
+                    }
+                }));
+            }
+        })?)
     }
-}
 
-/// `Partition` variable provides information of GPT partitions
-///
-/// `fastboot getvar partition-size:<GBL Fastboot partition>`
-/// `fastboot getvar partition-type:<GBL Fastboot partition>`
-pub(crate) struct Partition {}
+    const PARTITION_SIZE: &'static str = "partition-size";
+    const PARTITION_TYPE: &'static str = "partition-type";
+
+    /// "fastboot getvar partition-size"
+    fn get_var_partition_size<'s, 't>(
+        &mut self,
+        mut args: impl Iterator<Item = &'t str> + Clone,
+        out: &'s mut [u8],
+    ) -> CommandResult<&'s str> {
+        let (_, _, _, sz) = self.parse_partition(args.next().ok_or("Missing partition")?)?;
+        Ok(snprintf!(out, "{:#x}", sz))
+    }
 
-const PARTITION_SIZE: &str = "partition-size";
-const PARTITION_TYPE: &str = "partition-type";
-impl Variable for Partition {
-    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        name: &str,
-        args: Split<'_, char>,
-        out: &mut [u8],
-    ) -> Result<Option<usize>, CommandError> {
-        let (_, _, start, sz) = gbl_fb.parse_partition(args.clone())?;
-        Ok(match name {
-            PARTITION_SIZE => Some(snprintf!(out, "{:#x}", sz).len()),
-            PARTITION_TYPE => Some(snprintf!(out, "raw").len()), // Image type not supported yet.
-            _ => None,
-        })
+    /// "fastboot getvar partition-type"
+    fn get_var_partition_type<'s, 't>(
+        &mut self,
+        mut args: impl Iterator<Item = &'t str> + Clone,
+        out: &'s mut [u8],
+    ) -> CommandResult<&'s str> {
+        self.parse_partition(args.next().ok_or("Missing partition")?)?;
+        Ok(snprintf!(out, "raw"))
     }
 
-    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        sender: &mut impl VarSender,
-    ) -> Result<(), CommandError> {
+    /// Gets all "partition-size/partition-type"
+    async fn get_all_partition_size_type(
+        &mut self,
+        responder: &mut impl VarInfoSender,
+    ) -> CommandResult<()> {
         // Though any sub range of a GPT partition or raw block counts as a partition in GBL
         // Fastboot, for "getvar all" we only enumerate whole range GPT partitions.
-        let partitions = gbl_fb.gbl_ops.partitions()?;
+        let disks = self.disks;
         let mut size_str = [0u8; 32];
-        for (idx, blk) in partitions.iter().enumerate() {
-            for ptn in blk.partition_iter() {
+        for (idx, blk) in disks.iter().enumerate() {
+            for ptn_idx in 0..blk.num_partitions().unwrap_or(0) {
+                let ptn = blk.get_partition_by_idx(ptn_idx)?;
                 let sz: u64 = ptn.size()?;
                 let part = ptn.name()?;
-                let mut id_str = [0u8; 32];
-                let id = snprintf!(id_str, "{:x}", idx);
-                sender.send(PARTITION_SIZE, &[part, id], snprintf!(size_str, "{:#x}", sz)).await?;
+                // Assumes max partition name length of 72 plus max u64 hex string length 18.
+                let mut part_id_buf = [0u8; 128];
+                let part = snprintf!(part_id_buf, "{}/{:x}", part, idx);
+                responder
+                    .send_var_info(Self::PARTITION_SIZE, [part], snprintf!(size_str, "{:#x}", sz))
+                    .await?;
                 // Image type is not supported yet.
-                sender.send(PARTITION_TYPE, &[part, id], snprintf!(size_str, "raw")).await?;
+                responder
+                    .send_var_info(Self::PARTITION_TYPE, [part], snprintf!(size_str, "raw"))
+                    .await?;
             }
         }
         Ok(())
     }
-}
 
-/// `BlockDevice` variable provides information of block devices.
-///
-/// `fastboot getvar block-device:<id>:total-blocks`
-/// `fastboot getvar block-device:<id>:block-size`
-pub(crate) struct BlockDevice {}
+    const BLOCK_DEVICE: &'static str = "block-device";
+    const TOTAL_BLOCKS: &'static str = "total-blocks";
+    const BLOCK_SIZE: &'static str = "block-size";
+    const BLOCK_DEVICE_STATUS: &'static str = "status";
 
-const BLOCK_DEVICE: &str = "block-device";
-const TOTAL_BLOCKS: &str = "total-blocks";
-const BLOCK_SIZE: &str = "block-size";
-const BLOCK_DEVICE_STATUS: &str = "status";
-
-impl Variable for BlockDevice {
-    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        name: &str,
-        mut args: Split<'_, char>,
-        out: &mut [u8],
-    ) -> Result<Option<usize>, CommandError> {
-        Ok(match name {
-            BLOCK_DEVICE => {
-                let id = next_arg_u64(&mut args, Err("Missing block device ID".into()))?;
-                let id = usize::try_from(id)?;
-                let val_type = next_arg(&mut args, Err("Missing value type".into()))?;
-                let blk = &gbl_fb.gbl_ops.partitions()?[id];
-                let info = blk.block_info();
-                Some(
-                    match val_type {
-                        TOTAL_BLOCKS => snprintf!(out, "{:#x}", info.num_blocks),
-                        BLOCK_SIZE => snprintf!(out, "{:#x}", info.block_size),
-                        BLOCK_DEVICE_STATUS => {
-                            snprintf!(out, "{}", blk.status().to_str())
-                        }
-                        _ => return Err("Invalid type".into()),
-                    }
-                    .len(),
-                )
+    /// Block device related information.
+    ///
+    /// `fastboot getvar block-device:<id>:total-blocks`
+    /// `fastboot getvar block-device:<id>:block-size`
+    /// `fastboot getvar block-device:<id>:status`
+    fn get_var_block_device<'s, 't>(
+        &mut self,
+        mut args: impl Iterator<Item = &'t str> + Clone,
+        out: &'s mut [u8],
+    ) -> CommandResult<&'s str> {
+        let id = next_arg_u64(&mut args)?.ok_or("Missing block device ID")?;
+        let id = usize::try_from(id)?;
+        let val_type = next_arg(&mut args).ok_or("Missing value type")?;
+        let blk = &self.disks[id];
+        let info = blk.block_info();
+        Ok(match val_type {
+            Self::TOTAL_BLOCKS => snprintf!(out, "{:#x}", info.num_blocks),
+            Self::BLOCK_SIZE => snprintf!(out, "{:#x}", info.block_size),
+            Self::BLOCK_DEVICE_STATUS => {
+                snprintf!(out, "{}", blk.status().to_str())
             }
-            _ => None,
+            _ => return Err("Invalid type".into()),
         })
     }
 
-    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        sender: &mut impl VarSender,
-    ) -> Result<(), CommandError> {
+    /// Gets all "block-device" variables.
+    async fn get_all_block_device(
+        &mut self,
+        responder: &mut impl VarInfoSender,
+    ) -> CommandResult<()> {
         let mut val = [0u8; 32];
-        for (idx, blk) in gbl_fb.gbl_ops.partitions()?.iter().enumerate() {
+        for (idx, blk) in self.gbl_ops.disks().iter().enumerate() {
             let mut id_str = [0u8; 32];
             let id = snprintf!(id_str, "{:x}", idx);
             let info = blk.block_info();
-            sender
-                .send(BLOCK_DEVICE, &[id, TOTAL_BLOCKS], snprintf!(val, "{:#x}", info.num_blocks))
+            responder
+                .send_var_info(
+                    Self::BLOCK_DEVICE,
+                    [id, Self::TOTAL_BLOCKS],
+                    snprintf!(val, "{:#x}", info.num_blocks),
+                )
                 .await?;
-            sender
-                .send(BLOCK_DEVICE, &[id, BLOCK_SIZE], snprintf!(val, "{:#x}", info.block_size))
+            responder
+                .send_var_info(
+                    Self::BLOCK_DEVICE,
+                    [id, Self::BLOCK_SIZE],
+                    snprintf!(val, "{:#x}", info.block_size),
+                )
                 .await?;
-            sender
-                .send(
-                    BLOCK_DEVICE,
-                    &[id, BLOCK_DEVICE_STATUS],
+            responder
+                .send_var_info(
+                    Self::BLOCK_DEVICE,
+                    [id, Self::BLOCK_DEVICE_STATUS],
                     snprintf!(val, "{}", blk.status().to_str()),
                 )
                 .await?;
         }
         Ok(())
     }
-}
-
-/// Gives the value of current default block device ID set by "oem gbl-set-default-block".
-///
-/// `fastboot getvar gbl-default-block`
-pub(crate) struct DefaultBlock {}
 
-const DEFAULT_BLOCK: &str = "gbl-default-block";
+    const DEFAULT_BLOCK: &'static str = "gbl-default-block";
 
-impl Variable for DefaultBlock {
-    async fn get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        name: &str,
-        _: Split<'_, char>,
-        out: &mut [u8],
-    ) -> Result<Option<usize>, CommandError> {
-        Ok(match name {
-            DEFAULT_BLOCK => Some(
-                match gbl_fb.default_block {
-                    Some(v) => snprintf!(out, "{:#x}", v),
-                    _ => snprintf!(out, "None"),
-                }
-                .len(),
-            ),
-            _ => None,
+    /// "fastboot getvar gbl-default-block"
+    fn get_var_default_block<'s>(&mut self, out: &'s mut [u8]) -> CommandResult<&'s str> {
+        Ok(match self.default_block {
+            Some(v) => snprintf!(out, "{:#x}", v),
+            None => snprintf!(out, "None"),
         })
     }
-
-    async fn get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-        &self,
-        gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-        sender: &mut impl VarSender,
-    ) -> Result<(), CommandError> {
-        let mut val = [0u8; 32];
-        match gbl_fb.default_block {
-            Some(v) => sender.send(DEFAULT_BLOCK, &[], snprintf!(val, "{:#x}", v)).await,
-            _ => sender.send(DEFAULT_BLOCK, &[], snprintf!(val, "None")).await,
-        }
-    }
-}
-
-/// `fb_vars_api` generates a `fn fb_vars_get()` and `fn fb_vars_get_all()` helper API for all
-/// registered Fastboot variables.
-macro_rules! fb_vars_api {
-    ($($vars:expr),+ $(,)?) => {
-        /// Gets a Fastboot variable.
-        ///
-        /// The macro simply generates `var.get()` calls for each variable. i.e.:
-        ///
-        ///   pub(crate) async fn fb_vars_get<G: GblOps<'b>>(
-        ///       gbl_fb: &mut GblFastboot<'_, '_, B>,
-        ///       name: &str,
-        ///       args: Split<'_, char>,
-        ///       out: &mut [u8],
-        ///   ) -> Result<Option<usize>, CommandError> {
-        ///       match ("version-bootloader", "1.0").get(gbl_fb, name, args, out).await? {
-        ///           Some(v) => return Ok(Some(v)),
-        ///           _ => {}
-        ///       }
-        ///
-        ///       match BlockDevice {}.get(gbl_fb, name, args, out).await? {
-        ///           Some(v) => return Ok(Some(v)),
-        ///           _ => {}
-        ///       }
-        ///
-        ///       Ok(None)
-        ///   }
-        pub(crate) async fn fb_vars_get<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-            gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-            name: &str,
-            args: Split<'_, char>,
-            out: &mut [u8],
-        ) -> Result<Option<usize>, CommandError> {
-            fb_vars_get_body!(gbl_fb, name, args.clone(), out, $($vars),*);
-            Ok(None)
-        }
-
-        /// Gets all Fastboot variable values.
-        ///
-        /// The macro simply generates `var.get_all()` calls for each variable.
-        ///
-        ///   pub(crate) async fn fb_vars_get_all<G: GblOps<'b>>(
-        ///       gbl_fb: &mut GblFastboot<'_, '_, B>,
-        ///       sender: &mut impl VarSender,
-        ///   ) -> Result<(), CommandError> {
-        ///       ("version-bootloader", "1.0").get_all(gbl_fb, sender).await?;
-        ///       ("max-fetch-size", "0xffffffffffffffff").get_all(gbl_fb, sender).await?;
-        ///       BlockDevice {}.get_all(gbl_fb, sender).await?;
-        ///       Partition {}.get_all(gbl_fb, sender).await?;
-        ///       Ok(())
-        ///   }
-        pub(crate) async fn fb_vars_get_all<'b, T: TasksExecutor<'b>, G: GblOps<'b>>(
-            gbl_fb: &mut GblFastboot<'_, 'b, T, G>,
-            sender: &mut impl VarSender,
-        ) -> Result<(), CommandError> {
-            fb_vars_get_all_body!(gbl_fb, sender, $($vars),*);
-            Ok(())
-        }
-    }
-}
-
-// `fb_vars_get_body` generates the body for `fn fb_vars_get()`
-macro_rules! fb_vars_get_body {
-    ($gbl_fb:expr, $name:expr, $args:expr, $out:expr, $var:expr) => {
-        match $var.get($gbl_fb, $name, $args, $out).await? {
-            Some(v) => return Ok(Some(v)),
-            _ => {}
-        }
-    };
-    ($gbl_fb:expr, $name:expr, $args:expr, $out:expr, $var:expr, $($remains:expr),+ $(,)?) => {
-        fb_vars_get_body!($gbl_fb, $name, $args, $out, $var);
-        fb_vars_get_body!($gbl_fb, $name, $args, $out, $($remains),*)
-    };
-}
-
-// `fb_vars_get_all_body` generates the body for `fn fb_vars_get_all()`
-macro_rules! fb_vars_get_all_body {
-    ($gbl_fb:expr, $sender:expr, $var:expr) => {
-        $var.get_all($gbl_fb, $sender).await?
-    };
-    ($gbl_fb:expr, $sender:expr, $var:expr, $($remains:expr),+ $(,)?) => {
-        fb_vars_get_all_body!($gbl_fb, $sender, $var);
-        fb_vars_get_all_body!($gbl_fb, $sender, $($remains),*)
-    };
-}
-
-fb_vars_api! {
-    ("version-bootloader", "1.0"),
-    // GBL Fastboot can internally handle uploading in batches, thus there is no limit on
-    // max-fetch-size.
-    ("max-fetch-size", "0xffffffffffffffff"),
-    BlockDevice {},
-    DefaultBlock {},
-    Partition {},
 }
diff --git a/gbl/libgbl/src/fuchsia_boot/mod.rs b/gbl/libgbl/src/fuchsia_boot/mod.rs
index bae47ec..ced081a 100644
--- a/gbl/libgbl/src/fuchsia_boot/mod.rs
+++ b/gbl/libgbl/src/fuchsia_boot/mod.rs
@@ -14,33 +14,49 @@
 
 //! This file provides APIs for loading, verifying and booting Fuchsia/Zircon.
 
-use crate::{gbl_print, gbl_println, GblOps, Result as GblResult};
-pub use abr::{get_boot_slot, Ops as AbrOps, SlotIndex};
-use core::fmt::Write;
+use crate::{gbl_print, gbl_println, image_buffer::ImageBuffer, GblOps, Result as GblResult};
+pub use abr::{get_and_clear_one_shot_bootloader, get_boot_slot, Ops as AbrOps, SlotIndex};
+use core::{fmt::Write, mem::MaybeUninit, num::NonZeroUsize};
 use liberror::{Error, Result};
+use libutils::aligned_subslice;
 use safemath::SafeNum;
 use zbi::{ZbiContainer, ZbiFlags, ZbiHeader, ZbiType};
 use zerocopy::AsBytes;
 
 mod vboot;
-use vboot::zircon_verify_kernel;
+use vboot::{copy_items_after_kernel, zircon_verify_kernel};
 
 /// Kernel load address alignment. Value taken from
 /// https://fuchsia.googlesource.com/fuchsia/+/4f204d8a0243e84a86af4c527a8edcc1ace1615f/zircon/kernel/target/arm64/boot-shim/BUILD.gn#38
 pub const ZIRCON_KERNEL_ALIGN: usize = 64 * 1024;
 
 const DURABLE_BOOT_PARTITION: &str = "durable_boot";
+const MISC_PARTITION: &str = "misc";
+const ABR_PARTITION_ALIASES: &[&str] = &[DURABLE_BOOT_PARTITION, MISC_PARTITION];
+
+/// Helper function to find partition given a list of possible aliases.
+fn find_part_aliases<'a, 'b, 'c>(
+    ops: &mut (impl GblOps<'a, 'c> + ?Sized),
+    aliases: &'b [&str],
+) -> Result<&'b str> {
+    Ok(*aliases
+        .iter()
+        .find(|v| matches!(ops.partition_size(v), Ok(Some(_))))
+        .ok_or(Error::NotFound)?)
+}
 
 /// `GblAbrOps` wraps an object implementing `GblOps` and implements the `abr::Ops` trait.
-struct GblAbrOps<'a, T>(&'a mut T);
+pub(crate) struct GblAbrOps<'a, T: ?Sized>(pub &'a mut T);
 
-impl<'b, T: GblOps<'b>> AbrOps for GblAbrOps<'_, T> {
+impl<'b, 'c, T: GblOps<'b, 'c> + ?Sized> AbrOps for GblAbrOps<'_, T> {
     fn read_abr_metadata(&mut self, out: &mut [u8]) -> Result<()> {
-        self.0.read_from_partition_sync(DURABLE_BOOT_PARTITION, 0, out)
+        let part = find_part_aliases(self.0, &ABR_PARTITION_ALIASES)?;
+        self.0.read_from_partition_sync(part, 0, out)
     }
 
     fn write_abr_metadata(&mut self, data: &mut [u8]) -> Result<()> {
-        self.0.write_to_partition_sync(DURABLE_BOOT_PARTITION, 0, data)
+        let part = find_part_aliases(self.0, &ABR_PARTITION_ALIASES)?;
+        self.0.write_to_partition_sync(part, 0, data)
     }
 
     fn console(&mut self) -> Option<&mut dyn Write> {
@@ -48,24 +64,11 @@ impl<'b, T: GblOps<'b>> AbrOps for GblAbrOps<'_, T> {
     }
 }
 
-/// A helper for getting the smallest offset in a slice with aligned address.
-fn aligned_offset(buffer: &[u8], alignment: usize) -> Result<usize> {
-    let addr = SafeNum::from(buffer.as_ptr() as usize);
-    (addr.round_up(alignment) - addr).try_into().map_err(From::from)
-}
-
-/// A helper for getting a subslice with an aligned address.
-fn aligned_subslice(buffer: &mut [u8], alignment: usize) -> Result<&mut [u8]> {
-    let aligned_offset = aligned_offset(buffer, alignment)?;
-    let len = buffer.len();
-    Ok(buffer.get_mut(aligned_offset..).ok_or(Error::BufferTooSmall(Some(aligned_offset)))?)
-}
-
 /// A helper for splitting the trailing unused portion of a ZBI container buffer.
 ///
 /// Returns a tuple of used subslice and unused subslice
 fn zbi_split_unused_buffer(zbi: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])> {
-    Ok(zbi.split_at_mut(ZbiContainer::parse(&zbi[..])?.container_size()))
+    Ok(zbi.split_at_mut(ZbiContainer::parse(&zbi[..])?.container_size()?))
 }
 
 /// Relocates a ZBI kernel to a different buffer.
@@ -78,7 +81,7 @@ pub fn relocate_kernel(kernel: &[u8], dest: &mut [u8]) -> GblResult<()> {
     }
 
     let kernel = ZbiContainer::parse(&kernel[..])?;
-    let kernel_item = kernel.is_bootable()?;
+    let kernel_item = kernel.get_bootable_kernel_item()?;
     let hdr = kernel_item.header;
     // Creates a new ZBI kernel item at the destination.
     let mut relocated = ZbiContainer::new(&mut dest[..])?;
@@ -114,18 +117,21 @@ pub fn relocate_to_tail(kernel: &mut [u8]) -> GblResult<(&mut [u8], &mut [u8])>
     Ok(kernel.split_at_mut(reloc_addr.checked_sub(kernel.as_ptr() as usize).unwrap()))
 }
 
-/// Gets the slotted/slotless standard zircon partition name.
-pub fn zircon_part_name(slot: Option<SlotIndex>) -> &'static str {
+/// Gets the list of aliases for slotted/slotless zircon partition name.
+fn zircon_part_name_aliases(slot: Option<SlotIndex>) -> &'static [&'static str] {
     match slot {
-        Some(slot) => match slot {
-            SlotIndex::A => "zircon_a",
-            SlotIndex::B => "zircon_b",
-            SlotIndex::R => "zircon_r",
-        },
-        _ => "zircon",
+        Some(SlotIndex::A) => &["zircon_a", "zircon-a"][..],
+        Some(SlotIndex::B) => &["zircon_b", "zircon-b"][..],
+        Some(SlotIndex::R) => &["zircon_r", "zircon-r"][..],
+        _ => &["zircon"][..],
     }
 }
 
+/// Gets the slotted/slotless standard zircon partition name.
+pub fn zircon_part_name(slot: Option<SlotIndex>) -> &'static str {
+    zircon_part_name_aliases(slot)[0]
+}
+
 /// Gets the ZBI command line string for the current slot.
 fn slot_cmd_line(slot: SlotIndex) -> &'static str {
     match slot {
@@ -141,18 +147,33 @@ fn slot_cmd_line(slot: SlotIndex) -> &'static str {
 ///
 /// * `ops`: A reference to an object that implements `GblOps`.
 /// * `slot`: None if slotless. Otherwise the target slot to boot.
-/// * `load`: Buffer for loading the kernel.
+/// * `slot_booted_successfully`: whether the slot is known-successful boot, and if so then this
+/// function will update the anti-rollbacks.
 ///
 /// On success returns a pair containing: 1. the slice of the ZBI container with device ZBI items
-/// and 2. the slice of the relocated kernel at the tail.
-pub fn zircon_load_verify<'a, 'b>(
-    ops: &mut impl GblOps<'b>,
+/// and 2. the slice of container containing the kernel.
+pub fn zircon_load_verify<'a, 'd>(
+    ops: &mut impl GblOps<'a, 'd>,
     slot: Option<SlotIndex>,
     slot_booted_successfully: bool,
-    load: &'a mut [u8],
-) -> GblResult<(&'a mut [u8], &'a mut [u8])> {
-    let load = aligned_subslice(load, ZIRCON_KERNEL_ALIGN)?;
-    let zircon_part = zircon_part_name(slot);
+) -> GblResult<(ImageBuffer<'d>, ImageBuffer<'d>)> {
+    // TODO(b/379778252): use single `zbi_zircon` buffer for container to store both kernel and
+    // arguments/items
+    let mut zbi_items_img =
+        ops.get_image_buffer("zbi_items", NonZeroUsize::new(64 * 1024 * 1024).unwrap()).unwrap();
+
+    let init_len = zbi_items_img.tail().len();
+    // TODO(b/379787423): it is possible to optimize this initialisation by treating
+    // `zbi_items_img` same as kernel image (&[MaybeUninit]).
+    MaybeUninit::fill(zbi_items_img.tail(), 0);
+
+    // SAFETY: buffer was fully filled with 0 which is valid init value for u8
+    unsafe {
+        zbi_items_img.advance_used(init_len).unwrap();
+    }
+    let mut zbi_items = ZbiContainer::new(zbi_items_img.used_mut())?;
+
+    let zircon_part = find_part_aliases(ops, zircon_part_name_aliases(slot))?;
 
     // Reads ZBI header to computes the total size of kernel.
     let mut zbi_header: ZbiHeader = Default::default();
@@ -162,19 +183,35 @@ pub fn zircon_load_verify<'a, 'b>(
         .map_err(Error::from)?;
 
     // Reads the entire kernel
-    let kernel = load.get_mut(..image_length).ok_or(Error::BufferTooSmall(Some(image_length)))?;
-    ops.read_from_partition_sync(zircon_part, 0, kernel)?;
+    // TODO(b/379778252): as part of an attempt to use single container for kernel and arguments,
+    // it would be necessary to read kernel header first to figure out how much space needed
+    // (kernel size + scratch space)
+    let mut kernel_img =
+        ops.get_image_buffer("zbi_zircon", NonZeroUsize::new(128 * 1024 * 1024).unwrap()).unwrap();
+    let kernel_uninit = kernel_img
+        .as_mut()
+        .get_mut(..image_length)
+        .ok_or(Error::BufferTooSmall(Some(image_length)))?;
+    ops.read_from_partition_sync(zircon_part, 0, kernel_uninit)?;
+    // SAFETY: buffer was successfully filled from partition
+    unsafe {
+        kernel_img.advance_used(image_length).unwrap();
+    }
+    let load = kernel_img.used_mut();
 
     // Performs AVB verification.
-    zircon_verify_kernel(ops, slot, slot_booted_successfully, &mut load[..])?;
+    // TODO(b/379789161) verify that kernel buffer is big enough for the image and scratch buffer.
+    zircon_verify_kernel(ops, slot, slot_booted_successfully, load, &mut zbi_items)?;
+    // TODO(b/380409163) make sure moved items are before appended one to facilitate overriding.
+    // It is not as efficient as moving kernel since ZBI items would contain file system and be
+    // bigger than kernel.
+    copy_items_after_kernel(load, &mut zbi_items)?;
 
     // Append additional ZBI items.
-    let mut zbi_kernel = ZbiContainer::parse(&mut load[..])?;
-
     match slot {
         Some(slot) => {
             // Appends current slot item.
-            zbi_kernel.create_entry_with_payload(
+            zbi_items.create_entry_with_payload(
                 ZbiType::CmdLine,
                 0,
                 ZbiFlags::default(),
@@ -184,13 +221,16 @@ pub fn zircon_load_verify<'a, 'b>(
         _ => {}
     }
 
-    // Relocates the kernel to the tail to reserved extra memory that the kernel may require.
-    let (zbi_items, relocated) = relocate_to_tail(&mut load[..])?;
-
     // Appends device specific ZBI items.
-    ops.zircon_add_device_zbi_items(&mut ZbiContainer::parse(&mut zbi_items[..])?)?;
+    ops.zircon_add_device_zbi_items(&mut zbi_items)?;
+
+    // Appends staged bootloader file if present.
+    match ops.get_zbi_bootloader_files_buffer_aligned().map(|v| ZbiContainer::parse(v)) {
+        Some(Ok(v)) => zbi_items.extend(&v)?,
+        _ => {}
+    }
 
-    Ok((zbi_items, relocated))
+    Ok((zbi_items_img, kernel_img))
 }
 
 /// Loads and verifies the active slot kernel according to A/B/R.
@@ -200,36 +240,66 @@ pub fn zircon_load_verify<'a, 'b>(
 /// # Args
 ///
 /// * `ops`: A reference to an object that implements `GblOps`.
-/// * `buffer`: Buffer for loading the kernel.
 ///
 /// Returns a tuple containing: 1. the slice of the ZBI container with device ZBI items, 2. the
 /// slice of the relocated kernel, and 3. the selected slot index.
-pub fn zircon_load_verify_abr<'a, 'b>(
-    ops: &mut impl GblOps<'b>,
-    buffer: &'a mut [u8],
-) -> GblResult<(&'a mut [u8], &'a mut [u8], SlotIndex)> {
+pub fn zircon_load_verify_abr<'a, 'd>(
+    ops: &mut impl GblOps<'a, 'd>,
+) -> GblResult<(ImageBuffer<'d>, ImageBuffer<'d>, SlotIndex)> {
     let (slot, successful) = get_boot_slot(&mut GblAbrOps(ops), true);
     gbl_println!(ops, "Loading kernel from {}...", zircon_part_name(Some(slot)));
-    let (zbi_items, kernel) = zircon_load_verify(ops, Some(slot), successful, buffer)?;
+    let (zbi_items_img, kernel_img) = zircon_load_verify(ops, Some(slot), successful)?;
     gbl_println!(ops, "Successfully loaded slot: {}", zircon_part_name(Some(slot)));
-    Ok((zbi_items, kernel, slot))
+    Ok((zbi_items_img, kernel_img, slot))
+}
+
+/// Checks whether platform or A/B/R metadata instructs GBL to boot into fastboot mode.
+///
+/// # Returns
+///
+/// Returns true if fastboot mode is enabled, false if not.
+pub fn zircon_check_enter_fastboot<'a, 'b>(ops: &mut impl GblOps<'a, 'b>) -> bool {
+    match get_and_clear_one_shot_bootloader(&mut GblAbrOps(ops)) {
+        Ok(true) => {
+            gbl_println!(ops, "A/B/R one-shot-bootloader is set");
+            return true;
+        }
+        Err(e) => {
+            gbl_println!(ops, "Warning: error while checking A/B/R one-shot-bootloader ({:?})", e);
+            gbl_println!(ops, "Ignoring error and considered not set");
+        }
+        _ => {}
+    };
+
+    match ops.should_stop_in_fastboot() {
+        Ok(true) => {
+            gbl_println!(ops, "Platform instructs GBL to enter fastboot mode");
+            return true;
+        }
+        Err(e) => {
+            gbl_println!(ops, "Warning: error while checking platform fastboot trigger ({:?})", e);
+            gbl_println!(ops, "Ignoring error and considered not triggered");
+        }
+        _ => {}
+    };
+    false
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
-    use crate::{
-        ops::{
-            test::{FakeGblOps, FakeGblOpsStorage},
-            CertPermanentAttributes,
-        },
-        partition::PartitionBlockDevice,
+    use crate::ops::{
+        test::{FakeGblOps, FakeGblOpsStorage, TestGblDisk},
+        CertPermanentAttributes,
+    };
+    use abr::{
+        mark_slot_active, mark_slot_unbootable, set_one_shot_bootloader, ABR_MAX_TRIES_REMAINING,
     };
-    use abr::{mark_slot_active, mark_slot_unbootable, ABR_MAX_TRIES_REMAINING};
     use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
-    use gbl_storage_testlib::TestBlockIo;
+    use gbl_storage::as_uninit_mut;
+    use libutils::aligned_offset;
     use std::{
-        collections::{BTreeSet, HashMap},
+        collections::{BTreeSet, HashMap, LinkedList},
         fs,
         ops::{Deref, DerefMut},
         path::Path,
@@ -272,27 +342,41 @@ mod test {
     /// on all devices.
     pub(crate) fn create_storage() -> FakeGblOpsStorage {
         let mut storage = FakeGblOpsStorage::default();
-        storage.add_raw_device_padded("zircon_a", read_test_data(ZIRCON_A_ZBI_FILE));
-        storage.add_raw_device_padded("zircon_b", read_test_data(ZIRCON_B_ZBI_FILE));
-        storage.add_raw_device_padded("zircon_r", read_test_data(ZIRCON_R_ZBI_FILE));
-        storage.add_raw_device_padded("zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
-        storage.add_raw_device_padded("vbmeta_a", read_test_data(VBMETA_A_FILE));
-        storage.add_raw_device_padded("vbmeta_b", read_test_data(VBMETA_B_FILE));
-        storage.add_raw_device_padded("vbmeta_r", read_test_data(VBMETA_R_FILE));
-        storage.add_raw_device_padded("vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
-        storage.add_raw_device_padded("durable_boot", vec![0u8; 64 * 1024]);
+        storage.add_raw_device(c"zircon_a", read_test_data(ZIRCON_A_ZBI_FILE));
+        storage.add_raw_device(c"zircon_b", read_test_data(ZIRCON_B_ZBI_FILE));
+        storage.add_raw_device(c"zircon_r", read_test_data(ZIRCON_R_ZBI_FILE));
+        storage.add_raw_device(c"zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
+        storage.add_raw_device(c"vbmeta_a", read_test_data(VBMETA_A_FILE));
+        storage.add_raw_device(c"vbmeta_b", read_test_data(VBMETA_B_FILE));
+        storage.add_raw_device(c"vbmeta_r", read_test_data(VBMETA_R_FILE));
+        storage.add_raw_device(c"vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
+        storage.add_raw_device(c"durable_boot", vec![0u8; 64 * 1024]);
         storage
     }
 
-    pub(crate) fn create_gbl_ops<'a>(
-        partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>],
-    ) -> FakeGblOps<'a> {
+    /// Returns a default [FakeGblOpsStorage] with valid test images and using legacy partition
+    /// names.
+    pub(crate) fn create_storage_legacy_names() -> FakeGblOpsStorage {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"zircon-a", read_test_data(ZIRCON_A_ZBI_FILE));
+        storage.add_raw_device(c"zircon-b", read_test_data(ZIRCON_B_ZBI_FILE));
+        storage.add_raw_device(c"zircon-r", read_test_data(ZIRCON_R_ZBI_FILE));
+        storage.add_raw_device(c"zircon", read_test_data(ZIRCON_SLOTLESS_ZBI_FILE));
+        storage.add_raw_device(c"vbmeta_a", read_test_data(VBMETA_A_FILE));
+        storage.add_raw_device(c"vbmeta_b", read_test_data(VBMETA_B_FILE));
+        storage.add_raw_device(c"vbmeta_r", read_test_data(VBMETA_R_FILE));
+        storage.add_raw_device(c"vbmeta", read_test_data(VBMETA_SLOTLESS_FILE));
+        storage.add_raw_device(c"misc", vec![0u8; 64 * 1024]);
+        storage
+    }
+
+    pub(crate) fn create_gbl_ops<'a>(partitions: &'a [TestGblDisk]) -> FakeGblOps<'a, '_> {
         let mut ops = FakeGblOps::new(&partitions);
         ops.avb_ops.unlock_state = Ok(false);
         ops.avb_ops.rollbacks = HashMap::from([
-            (TEST_ROLLBACK_INDEX_LOCATION, 0),
-            (AVB_CERT_PSK_VERSION_LOCATION.try_into().unwrap(), 0),
-            (AVB_CERT_PIK_VERSION_LOCATION.try_into().unwrap(), 0),
+            (TEST_ROLLBACK_INDEX_LOCATION, Ok(0)),
+            (AVB_CERT_PSK_VERSION_LOCATION.try_into().unwrap(), Ok(0)),
+            (AVB_CERT_PIK_VERSION_LOCATION.try_into().unwrap(), Ok(0)),
         ]);
         ops.avb_ops.use_cert = true;
         ops.avb_ops.cert_permanent_attributes = Some(
@@ -362,6 +446,14 @@ mod test {
         container.create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), cmd).unwrap();
     }
 
+    /// Helper to append a command line ZBI item to a ZBI container
+    pub(crate) fn append_zbi_file(zbi: &mut [u8], payload: &[u8]) {
+        let mut container = ZbiContainer::parse(zbi).unwrap();
+        container
+            .create_entry_with_payload(ZbiType::BootloaderFile, 0, ZbiFlags::default(), payload)
+            .unwrap();
+    }
+
     /// Helper for testing `zircon_load_verify`.
     fn test_load_verify(
         ops: &mut FakeGblOps,
@@ -369,53 +461,138 @@ mod test {
         expected_zbi_items: &[u8],
         expected_kernel: &[u8],
     ) {
-        // Test load buffer layout:
-        // |  zircon_x.zbi + items| ~~ |~64k~| relocated kernel + reserved |
-        // | ---------- 64K -----------|~~~~~| ----------------------------|
-        let sz = 2 * ZIRCON_KERNEL_ALIGN + expected_kernel.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE;
-        let mut load = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
         let original_rb = ops.avb_ops.rollbacks.clone();
         // Loads and verifies with unsuccessful slot flag first.
-        let (zbi_items, relocated) = zircon_load_verify(ops, slot, false, &mut load).unwrap();
+        let (mut zbi_items, mut kernel) = zircon_load_verify(ops, slot, false).unwrap();
         // Verifies loaded ZBI kernel/items
-        assert_eq!(normalize_zbi(expected_zbi_items), normalize_zbi(zbi_items));
-        // Verifies relocated kernel
-        assert_eq!(normalize_zbi(expected_kernel), normalize_zbi(relocated));
-        // Relocated kernel is at the latest aligned address
-        let off = (relocated.as_ptr() as usize) - (load.as_ptr() as usize);
-        assert_eq!(off, 2 * ZIRCON_KERNEL_ALIGN);
+        assert_eq!(normalize_zbi(expected_zbi_items), normalize_zbi(zbi_items.used_mut()));
+        // Verifies kernel
+        assert_eq!(normalize_zbi(expected_kernel), normalize_zbi(kernel.used_mut()));
+        // Kernel is at aligned address
+        assert_eq!(kernel.used_mut().as_ptr() as usize % ZIRCON_KERNEL_ALIGN, 0);
 
         // Verifies that the slot successful flag is passed correctly.
         // Unsuccessful slot, rollback not updated.
         assert_eq!(ops.avb_ops.rollbacks, original_rb);
         // Loads and verifies with successful slot flag.
-        zircon_load_verify(ops, slot, true, &mut load).unwrap();
+        zircon_load_verify(ops, slot, true).unwrap();
         // Successful slot, rollback updated.
         assert_eq!(
             ops.avb_ops.rollbacks,
             [
-                (TEST_ROLLBACK_INDEX_LOCATION, TEST_ROLLBACK_INDEX_VALUE),
-                (usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION),
-                (usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION)
+                (TEST_ROLLBACK_INDEX_LOCATION, Ok(TEST_ROLLBACK_INDEX_VALUE)),
+                (
+                    usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(),
+                    Ok(TEST_CERT_PSK_VERSION)
+                ),
+                (
+                    usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(),
+                    Ok(TEST_CERT_PIK_VERSION)
+                )
             ]
             .into()
         );
     }
 
+    // Helper to create local buffers and convert them to be used as ImageBuffers
+    // This struct owns the buffers, and returns ImageBuffers maps that reference them.
+    //
+    // Tests should make sure to provide enough buffers for all `get_image_buffer()` calls.
+    //
+    struct ImageBuffersPool(LinkedList<(String, Vec<AlignedBuffer>)>);
+
+    impl ImageBuffersPool {
+        pub fn builder() -> ImageBuffersBuilder {
+            ImageBuffersBuilder::new()
+        }
+
+        // number - number of expected get_image_buffer calls. Each call consumes buffers from the
+        // list. If there are not enough it will start returning errors.
+        //
+        // size - size for the buffers
+        fn new(number: usize, size: usize) -> Self {
+            let mut zbi_items_buffer_vec = Vec::<AlignedBuffer>::new();
+            let mut zbi_zircon_buffer_vec = Vec::<AlignedBuffer>::new();
+            for _ in 0..number {
+                zbi_zircon_buffer_vec.push(AlignedBuffer::new(size, ZIRCON_KERNEL_ALIGN));
+                zbi_items_buffer_vec.push(AlignedBuffer::new(size, ZBI_ALIGNMENT_USIZE));
+            }
+
+            Self(
+                [
+                    (String::from("zbi_zircon"), zbi_zircon_buffer_vec),
+                    (String::from("zbi_items"), zbi_items_buffer_vec),
+                ]
+                .into(),
+            )
+        }
+
+        pub fn get(&mut self) -> HashMap<String, LinkedList<ImageBuffer>> {
+            self.0
+                .iter_mut()
+                .map(|(key, val_vec)| {
+                    (
+                        key.clone(),
+                        val_vec
+                            .iter_mut()
+                            .map(|e| ImageBuffer::new(as_uninit_mut(e.as_mut())))
+                            .collect(),
+                    )
+                })
+                .collect()
+        }
+    }
+
+    struct ImageBuffersBuilder {
+        // Number of buffers for each image name
+        number: usize,
+        // Size of the buffers
+        size: usize,
+    }
+
+    /// Tests should make sure to provide enough buffers for all `get_image_buffer()` calls.
+    /// Default number of calls is 1, if more expected use `builder().number(N).build()`
+    /// Default buffer sizes are 2KiB, if different size required use `builder().size(1MiB).build()`
+    impl ImageBuffersBuilder {
+        pub fn new() -> ImageBuffersBuilder {
+            Self { number: 1, size: 2 * 1024 }
+        }
+
+        /// If more than 1 `get_image_buffer()` call expected `number(N)` should be used to create
+        /// big enough pool of buffers.
+        pub fn number(mut self, number: usize) -> ImageBuffersBuilder {
+            self.number = number;
+            self
+        }
+
+        /// To change size of buffers use `builder(). size(S).build()`.
+        pub fn size(mut self, size: usize) -> ImageBuffersBuilder {
+            self.size = size;
+            self
+        }
+
+        pub fn build(self) -> ImageBuffersPool {
+            ImageBuffersPool::new(self.number, self.size)
+        }
+    }
+
     #[test]
     fn test_zircon_load_verify_slotless() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         let zbi = &read_test_data(ZIRCON_SLOTLESS_ZBI_FILE);
         let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
         // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
-        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
         append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
         test_load_verify(&mut ops, None, &expected_zbi_items, &expected_kernel);
     }
 
@@ -428,20 +605,23 @@ mod test {
     ) {
         let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
         // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
-        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
         append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
         append_cmd_line(&mut expected_zbi_items, slot_item.as_bytes());
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
         test_load_verify(ops, Some(slot), &expected_zbi_items, &expected_kernel);
     }
 
     #[test]
     fn test_load_verify_slot_a() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         let zircon_a_zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
         test_load_verify_slotted_helper(&mut ops, SlotIndex::A, zircon_a_zbi, "zvb.current_slot=a");
@@ -449,9 +629,10 @@ mod test {
 
     #[test]
     fn test_load_verify_slot_b() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         let zircon_b_zbi = &read_test_data(ZIRCON_B_ZBI_FILE);
         test_load_verify_slotted_helper(&mut ops, SlotIndex::B, zircon_b_zbi, "zvb.current_slot=b");
@@ -459,9 +640,10 @@ mod test {
 
     #[test]
     fn test_load_verify_slot_r() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         let zircon_r_zbi = &read_test_data(ZIRCON_R_ZBI_FILE);
         test_load_verify_slotted_helper(&mut ops, SlotIndex::R, zircon_r_zbi, "zvb.current_slot=r");
@@ -469,106 +651,103 @@ mod test {
 
     #[test]
     fn test_not_enough_buffer_for_reserved_memory() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().size(1024).build();
+        ops.image_buffers = image_buffers_pool.get();
 
-        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        let sz = ZIRCON_KERNEL_ALIGN + zbi.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE - 1;
-        let mut load = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
-        assert!(zircon_load_verify(&mut ops, Some(SlotIndex::A), true, &mut load).is_err());
+        assert!(zircon_load_verify(&mut ops, Some(SlotIndex::A), true).is_err());
     }
 
     /// A helper for assembling a set of test needed data. These include:
     ///
-    /// * The original partition ZBI kernel image set in the given `FakeGblOps`.
+    /// * The original ZBI kernel image on partition `part` in the given `FakeGblOps`.
     /// * A buffer for loading and verifying the kernel.
-    /// * The expected ZBI item buffer, if successfully loaded.
+    /// * The expected ZBI item buffer, if successfully loaded as slot index `slot`.
     /// * The expected ZBI kernel buffer, if successfully loaded.
     fn load_verify_test_data(
         ops: &mut FakeGblOps,
         slot: SlotIndex,
+        part: &str,
     ) -> (Vec<u8>, AlignedBuffer, AlignedBuffer, AlignedBuffer) {
-        let slot_info_map: HashMap<core::ffi::c_uint, (&str, &[u8], &str)> = [
-            (SlotIndex::A.into(), ("zircon_a", &b"zvb.current_slot=a"[..], ZIRCON_A_ZBI_FILE)),
-            (SlotIndex::B.into(), ("zircon_b", &b"zvb.current_slot=b"[..], ZIRCON_B_ZBI_FILE)),
-            (SlotIndex::R.into(), ("zircon_r", &b"zvb.current_slot=r"[..], ZIRCON_R_ZBI_FILE)),
-        ]
-        .into();
-        let (name, slot_item, original_file_name) = slot_info_map.get(&slot.into()).unwrap();
-        // Read the (possibly modified) ZBI from disk, using the original unmodified ZBI to
-        // determine the size.
-        let mut zbi = ops.copy_partition(name);
-        zbi.truncate(read_test_data(original_file_name).len());
-        // Test load buffer layout:
-        // |  zircon_x.zbi + items| ~~ | relocated kernel + reserved |
-        // | ---------- 64K -----------| ----------------------------|
+        // Read the (possibly modified) ZBI from disk.
+        let zbi = ops.copy_partition(part);
         let sz = ZIRCON_KERNEL_ALIGN + zbi.len() + TEST_KERNEL_RESERVED_MEMORY_SIZE;
         let load_buffer = AlignedBuffer::new(sz, ZIRCON_KERNEL_ALIGN);
         let expected_kernel = AlignedBuffer::new_with_data(&zbi, ZBI_ALIGNMENT_USIZE);
         // Adds extra bytes for device ZBI items.
-        let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, ZBI_ALIGNMENT_USIZE);
-        expected_zbi_items[..zbi.len()].clone_from_slice(&zbi);
+        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
         append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        append_cmd_line(&mut expected_zbi_items, slot_item);
+        append_cmd_line(
+            &mut expected_zbi_items,
+            format!("zvb.current_slot={}", char::from(slot)).as_bytes(),
+        );
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_1);
+        append_zbi_file(&mut expected_zbi_items, FakeGblOps::TEST_BOOTLOADER_FILE_2);
         (zbi, load_buffer, expected_zbi_items, expected_kernel)
     }
 
     // Calls `zircon_load_verify_abr` and checks that the specified slot is loaded.
-    fn expect_load_verify_abr_ok(ops: &mut FakeGblOps, slot: SlotIndex) {
-        let (zbi, mut load, expected_items, expected_kernel) = load_verify_test_data(ops, slot);
-        let (zbi_items, kernel, active) = zircon_load_verify_abr(ops, &mut load).unwrap();
-        assert_eq!(normalize_zbi(&expected_items), normalize_zbi(&zbi_items));
-        assert_eq!(normalize_zbi(&expected_kernel), normalize_zbi(&kernel));
+    fn expect_load_verify_abr_ok(ops: &mut FakeGblOps, slot: SlotIndex, part: &str) {
+        let (_, _load, expected_items, expected_kernel) = load_verify_test_data(ops, slot, part);
+        let (mut zbi_items, mut kernel, active) = zircon_load_verify_abr(ops).unwrap();
+        assert_eq!(normalize_zbi(&expected_items), normalize_zbi(zbi_items.used_mut()));
+        assert_eq!(normalize_zbi(&expected_kernel), normalize_zbi(kernel.used_mut()));
         assert_eq!(active, slot);
     }
 
     #[test]
     fn test_load_verify_abr_slot_a() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().build();
+        ops.image_buffers = image_buffers_pool.get();
 
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
     }
 
     #[test]
     fn test_load_verify_abr_slot_b() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().build();
+        ops.image_buffers = image_buffers_pool.get();
 
         mark_slot_active(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
     }
 
     #[test]
     fn test_load_verify_abr_slot_r() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().build();
+        ops.image_buffers = image_buffers_pool.get();
 
         mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::A).unwrap();
         mark_slot_unbootable(&mut GblAbrOps(&mut ops), SlotIndex::B).unwrap();
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
     }
 
     #[test]
     fn test_load_verify_abr_exhaust_retries() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool =
+            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
         }
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
         }
         // Tests that load falls back to R eventually.
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
     }
 
     /// Modifies data in the given partition.
@@ -581,41 +760,121 @@ mod test {
 
     #[test]
     fn test_load_verify_abr_verify_failure_a_b() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool =
+            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         corrupt_data(&mut ops, "zircon_a");
         corrupt_data(&mut ops, "zircon_b");
 
-        let (_, mut load, _, _) = load_verify_test_data(&mut ops, SlotIndex::A);
+        let (_, _load, _, _) = load_verify_test_data(&mut ops, SlotIndex::A, "zircon_a");
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            assert!(zircon_load_verify_abr(&mut ops, &mut load).is_err());
+            assert!(zircon_load_verify_abr(&mut ops).is_err());
         }
-        let (_, mut load, _, _) = load_verify_test_data(&mut ops, SlotIndex::B);
+        let (_, _load, _, _) = load_verify_test_data(&mut ops, SlotIndex::B, "zircon_b");
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            assert!(zircon_load_verify_abr(&mut ops, &mut load).is_err());
+            assert!(zircon_load_verify_abr(&mut ops).is_err());
         }
         // Tests that load falls back to R eventually.
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
     }
 
     #[test]
     fn test_load_verify_abr_verify_failure_unlocked() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool =
+            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
+        ops.image_buffers = image_buffers_pool.get();
 
         ops.avb_ops.unlock_state = Ok(true);
         corrupt_data(&mut ops, "zircon_a");
         corrupt_data(&mut ops, "zircon_b");
 
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::A);
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon_a");
         }
         for _ in 0..ABR_MAX_TRIES_REMAINING {
-            expect_load_verify_abr_ok(&mut ops, SlotIndex::B);
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon_b");
         }
-        expect_load_verify_abr_ok(&mut ops, SlotIndex::R);
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon_r");
+    }
+
+    #[test]
+    fn test_check_enter_fastboot_stop_in_fastboot() {
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+
+        ops.stop_in_fastboot = Ok(false).into();
+        assert!(!zircon_check_enter_fastboot(&mut ops));
+
+        ops.stop_in_fastboot = Ok(true).into();
+        assert!(zircon_check_enter_fastboot(&mut ops));
+
+        ops.stop_in_fastboot = Err(Error::NotImplemented).into();
+        assert!(!zircon_check_enter_fastboot(&mut ops));
+    }
+
+    #[test]
+    fn test_check_enter_fastboot_abr() {
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        set_one_shot_bootloader(&mut GblAbrOps(&mut ops), true).unwrap();
+        assert!(zircon_check_enter_fastboot(&mut ops));
+        // One-shot only.
+        assert!(!zircon_check_enter_fastboot(&mut ops));
+    }
+
+    #[test]
+    fn test_check_enter_fastboot_prioritize_abr() {
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        set_one_shot_bootloader(&mut GblAbrOps(&mut ops), true).unwrap();
+        ops.stop_in_fastboot = Ok(true).into();
+        assert!(zircon_check_enter_fastboot(&mut ops));
+        ops.stop_in_fastboot = Ok(false).into();
+        // A/B/R metadata should be prioritized in the previous check and thus one-shot-booloader
+        // flag should be cleared.
+        assert!(!zircon_check_enter_fastboot(&mut ops));
+    }
+    #[test]
+    fn test_load_verify_abr_legacy_naming() {
+        let storage = create_storage_legacy_names();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool =
+            ImageBuffersPool::builder().number((1 + 2 * ABR_MAX_TRIES_REMAINING).into()).build();
+        ops.image_buffers = image_buffers_pool.get();
+
+        // Tests by exhausting all slots retries so it exercises all legacy name matching code
+        // paths.
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::A, "zircon-a");
+        }
+        for _ in 0..ABR_MAX_TRIES_REMAINING {
+            expect_load_verify_abr_ok(&mut ops, SlotIndex::B, "zircon-b");
+        }
+        // Tests that load falls back to R eventually.
+        expect_load_verify_abr_ok(&mut ops, SlotIndex::R, "zircon-r");
+    }
+
+    #[test]
+    fn test_zircon_load_verify_no_bootloader_file() {
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
+        let mut image_buffers_pool = ImageBuffersPool::builder().number(2).build();
+        ops.image_buffers = image_buffers_pool.get();
+        ops.get_zbi_bootloader_files_buffer().unwrap().fill(0);
+
+        let zbi = &read_test_data(ZIRCON_SLOTLESS_ZBI_FILE);
+        let expected_kernel = AlignedBuffer::new_with_data(zbi, ZBI_ALIGNMENT_USIZE);
+        // Adds extra bytes for device ZBI items.
+        let mut expected_zbi_items = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
+        append_cmd_line(&mut expected_zbi_items, FakeGblOps::ADDED_ZBI_COMMANDLINE_CONTENTS);
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+        test_load_verify(&mut ops, None, &expected_zbi_items, &expected_kernel);
     }
 }
diff --git a/gbl/libgbl/src/fuchsia_boot/vboot.rs b/gbl/libgbl/src/fuchsia_boot/vboot.rs
index 7394e04..8018bb4 100644
--- a/gbl/libgbl/src/fuchsia_boot/vboot.rs
+++ b/gbl/libgbl/src/fuchsia_boot/vboot.rs
@@ -14,183 +14,13 @@
 
 use crate::{
     fuchsia_boot::{zbi_split_unused_buffer, zircon_part_name, SlotIndex},
+    gbl_avb::ops::GblAvbOps,
     gbl_print, GblOps, Result as GblResult,
 };
-use avb::{
-    cert_validate_vbmeta_public_key, slot_verify, CertOps, CertPermanentAttributes, Descriptor,
-    HashtreeErrorMode, IoError as AvbIoError, IoResult as AvbIoResult, Ops as AvbOps,
-    PublicKeyForPartitionInfo, SlotVerifyError, SlotVerifyFlags, SHA256_DIGEST_SIZE,
-};
-use core::{
-    cmp::{max, min},
-    ffi::CStr,
-};
-use safemath::SafeNum;
-use uuid::Uuid;
-use zbi::{merge_within, ZbiContainer};
-
-// For Fuchsia, maximum number of key version is 2.
-const AVB_ATX_NUM_KEY_VERSIONS: usize = 2;
-
-/// `GblZirconBootAvbOps` implements `avb::Ops` for GBL Zircon boot flow.
-struct GblZirconBootAvbOps<'a, T> {
-    gbl_ops: &'a mut T,
-    preloaded_partitions: &'a [(&'a str, &'a [u8])],
-    // Used for storing key versions to be set. (location, version).
-    // If `array_map` is imported in the future, consider switching to it.
-    key_versions: [Option<(usize, u64)>; AVB_ATX_NUM_KEY_VERSIONS],
-}
-
-impl<'a, T: GblOps<'a>> GblZirconBootAvbOps<'_, T> {
-    /// Returns the size of a partition.
-    fn partition_size(&mut self, partition: &str) -> AvbIoResult<u64> {
-        Ok(self
-            .gbl_ops
-            .partition_size(partition)
-            .or(Err(AvbIoError::Io))?
-            .ok_or(AvbIoError::NoSuchPartition)?)
-    }
-}
-
-/// A helper function for converting `CStr` to `str`
-fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
-    Ok(s.to_str().or(Err(err))?)
-}
-
-impl<'a, 'b, T: GblOps<'b>> AvbOps<'a> for GblZirconBootAvbOps<'a, T> {
-    fn read_from_partition(
-        &mut self,
-        partition: &CStr,
-        offset: i64,
-        buffer: &mut [u8],
-    ) -> AvbIoResult<usize> {
-        let part_str = cstr_to_str(partition, AvbIoError::NoSuchPartition)?;
-        let partition_size = SafeNum::from(self.partition_size(part_str)?);
-        let read_off = match offset < 0 {
-            true => partition_size - offset.abs(),
-            _ => SafeNum::from(offset),
-        };
-        let read_sz = partition_size - read_off;
-        let read_off = read_off.try_into().map_err(|_| AvbIoError::Io)?;
-        let read_sz: usize = min(buffer.len(), read_sz.try_into().map_err(|_| AvbIoError::Io)?);
-        self.gbl_ops
-            .read_from_partition_sync(part_str, read_off, &mut buffer[..read_sz])
-            .map_err(|_| AvbIoError::Io)?;
-        Ok(read_sz)
-    }
-
-    fn get_preloaded_partition(&mut self, partition: &CStr) -> AvbIoResult<&'a [u8]> {
-        let part_str = cstr_to_str(partition, AvbIoError::NotImplemented)?;
-        Ok(self
-            .preloaded_partitions
-            .iter()
-            .find(|(name, _)| *name == part_str)
-            .ok_or(AvbIoError::NotImplemented)?
-            .1)
-    }
-
-    fn validate_vbmeta_public_key(
-        &mut self,
-        public_key: &[u8],
-        public_key_metadata: Option<&[u8]>,
-    ) -> AvbIoResult<bool> {
-        cert_validate_vbmeta_public_key(self, public_key, public_key_metadata)
-    }
-
-    fn read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64> {
-        self.gbl_ops.avb_read_rollback_index(rollback_index_location)
-    }
-
-    fn write_rollback_index(
-        &mut self,
-        rollback_index_location: usize,
-        index: u64,
-    ) -> AvbIoResult<()> {
-        self.gbl_ops.avb_write_rollback_index(rollback_index_location, index)
-    }
-
-    fn read_is_device_unlocked(&mut self) -> AvbIoResult<bool> {
-        self.gbl_ops.avb_read_is_device_unlocked()
-    }
-
-    fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> AvbIoResult<Uuid> {
-        // The ops is only used to check that a partition exists. GUID is not used.
-        self.partition_size(cstr_to_str(partition, AvbIoError::NoSuchPartition)?)?;
-        Ok(Uuid::nil())
-    }
-
-    fn get_size_of_partition(&mut self, partition: &CStr) -> AvbIoResult<u64> {
-        match self.get_preloaded_partition(partition) {
-            Ok(img) => Ok(img.len().try_into().unwrap()),
-            _ => {
-                let part_str = cstr_to_str(partition, AvbIoError::NoSuchPartition)?;
-                self.partition_size(part_str)
-            }
-        }
-    }
-
-    fn read_persistent_value(&mut self, _name: &CStr, _value: &mut [u8]) -> AvbIoResult<usize> {
-        // Fuchsia might need this in the future.
-        unimplemented!();
-    }
-
-    fn write_persistent_value(&mut self, _name: &CStr, _value: &[u8]) -> AvbIoResult<()> {
-        // Not needed by Fuchsia.
-        unreachable!();
-    }
-
-    fn erase_persistent_value(&mut self, _name: &CStr) -> AvbIoResult<()> {
-        // Not needed by Fuchsia.
-        unreachable!();
-    }
-
-    fn validate_public_key_for_partition(
-        &mut self,
-        _partition: &CStr,
-        _public_key: &[u8],
-        _public_key_metadata: Option<&[u8]>,
-    ) -> AvbIoResult<PublicKeyForPartitionInfo> {
-        // Not needed by Fuchsia.
-        unreachable!();
-    }
-
-    fn cert_ops(&mut self) -> Option<&mut dyn CertOps> {
-        Some(self)
-    }
-}
-
-impl<'a, T: GblOps<'a>> CertOps for GblZirconBootAvbOps<'_, T> {
-    fn read_permanent_attributes(
-        &mut self,
-        attributes: &mut CertPermanentAttributes,
-    ) -> AvbIoResult<()> {
-        self.gbl_ops.avb_cert_read_permanent_attributes(attributes)
-    }
-
-    fn read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]> {
-        self.gbl_ops.avb_cert_read_permanent_attributes_hash()
-    }
-
-    fn set_key_version(&mut self, rollback_index_location: usize, key_version: u64) {
-        // Checks if there is already an allocated slot for this location.
-        let existing = self
-            .key_versions
-            .iter_mut()
-            .find_map(|v| v.as_mut().filter(|(loc, _)| *loc == rollback_index_location));
-        match existing {
-            Some((_, val)) => *val = max(*val, key_version),
-            _ => {
-                // Finds an empty slot and stores the rollback index.
-                *self.key_versions.iter_mut().find(|v| v.is_none()).unwrap() =
-                    Some((rollback_index_location, key_version))
-            }
-        }
-    }
-
-    fn get_random(&mut self, bytes: &mut [u8]) -> AvbIoResult<()> {
-        unimplemented!()
-    }
-}
+use avb::{slot_verify, Descriptor, HashtreeErrorMode, Ops as _, SlotVerifyError, SlotVerifyFlags};
+use core::ffi::CStr;
+use zbi::ZbiContainer;
+use zerocopy::ByteSliceMut;
 
 /// Helper for getting the A/B/R suffix.
 fn slot_suffix(slot: Option<SlotIndex>) -> Option<&'static CStr> {
@@ -202,91 +32,104 @@ fn slot_suffix(slot: Option<SlotIndex>) -> Option<&'static CStr> {
 }
 
 /// Verifies a loaded ZBI kernel.
-pub(crate) fn zircon_verify_kernel<'a, 'b>(
-    gbl_ops: &mut impl GblOps<'b>,
+///
+/// # Arguments
+///
+/// * glb_ops - GblOps implementation
+/// * slot - slot to verify
+/// * slot_booted_successfully - if true, roll back indexes will be increased
+/// * zbi_kernel - preloaded kernel to verify
+/// * zbi_items - vbmeta items will be appended to this ZbiContainer
+pub(crate) fn zircon_verify_kernel<'a, 'b, 'c, B: ByteSliceMut + PartialEq>(
+    gbl_ops: &mut impl GblOps<'b, 'c>,
     slot: Option<SlotIndex>,
     slot_booted_successfully: bool,
     zbi_kernel: &'a mut [u8],
+    zbi_items: &mut ZbiContainer<B>,
 ) -> GblResult<()> {
-    let (kernel, desc_buf) = zbi_split_unused_buffer(&mut zbi_kernel[..])?;
-    let desc_zbi_off = kernel.len();
+    let (kernel, _) = zbi_split_unused_buffer(&mut zbi_kernel[..])?;
+
+    // Verifies the kernel.
+    let part = zircon_part_name(slot);
+    let preloaded = [(part, &kernel[..])];
+    let mut avb_ops = GblAvbOps::new(gbl_ops, &preloaded[..], true);
 
     // Determines verify flags and error mode.
-    let unlocked = gbl_ops.avb_read_is_device_unlocked()?;
+    let unlocked = avb_ops.read_is_device_unlocked()?;
     let mode = HashtreeErrorMode::AVB_HASHTREE_ERROR_MODE_EIO; // Don't care for fuchsia
     let flag = match unlocked {
         true => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_ALLOW_VERIFICATION_ERROR,
         _ => SlotVerifyFlags::AVB_SLOT_VERIFY_FLAGS_NONE,
     };
 
-    {
-        // Verifies the kernel.
-        let part = zircon_part_name(slot);
-        let preloaded = [(part, &kernel[..])];
-        let mut avb_ops = GblZirconBootAvbOps {
-            gbl_ops,
-            preloaded_partitions: &preloaded[..],
-            key_versions: [None; AVB_ATX_NUM_KEY_VERSIONS],
-        };
-        // TODO(b/334962583): Supports optional additional partitions to verify.
-        let verify_res = slot_verify(&mut avb_ops, &[c"zircon"], slot_suffix(slot), flag, mode);
-        let verified_success = verify_res.is_ok();
-        let verify_data = match verify_res {
-            Ok(v) => {
-                gbl_print!(avb_ops.gbl_ops, "{} successfully verified.\r\n", part);
-                v
-            }
-            Err(SlotVerifyError::Verification(Some(v))) if unlocked => {
-                gbl_print!(avb_ops.gbl_ops, "Verification failed. Device is unlocked. Ignore.\r\n");
-                v
-            }
-            Err(_) if unlocked => {
-                gbl_print!(
-                    avb_ops.gbl_ops,
-                    "Verification failed. No valid verify metadata. \
+    // TODO(b/334962583): Supports optional additional partitions to verify.
+    let verify_res = slot_verify(&mut avb_ops, &[c"zircon"], slot_suffix(slot), flag, mode);
+    let verified_success = verify_res.is_ok();
+    let verify_data = match verify_res {
+        Ok(v) => {
+            gbl_print!(avb_ops.gbl_ops, "{} successfully verified.\r\n", part);
+            v
+        }
+        Err(SlotVerifyError::Verification(Some(v))) if unlocked => {
+            gbl_print!(avb_ops.gbl_ops, "Verification failed. Device is unlocked. Ignore.\r\n");
+            v
+        }
+        Err(_) if unlocked => {
+            gbl_print!(
+                avb_ops.gbl_ops,
+                "Verification failed. No valid verify metadata. \
                     Device is unlocked. Ignore.\r\n"
-                );
-                return Ok(());
-            }
-            Err(e) => {
-                gbl_print!(avb_ops.gbl_ops, "Verification failed {:?}.\r\n", e);
-                return Err(e.without_verify_data().into());
-            }
-        };
-
-        // Collects ZBI items from vbmetadata and appends to the `desc_buf` buffer.
-        let mut desc_container = ZbiContainer::new(&mut desc_buf[..])?;
-        for vbmeta_data in verify_data.vbmeta_data() {
-            for prop in vbmeta_data.descriptors()?.iter().filter_map(|d| match d {
-                Descriptor::Property(p) if p.key.starts_with("zbi") => Some(p),
-                _ => None,
-            }) {
-                desc_container.extend_unaligned(prop.value)?;
-            }
+            );
+            return Ok(());
+        }
+        Err(e) => {
+            gbl_print!(avb_ops.gbl_ops, "Verification failed {:?}.\r\n", e);
+            return Err(e.without_verify_data().into());
         }
+    };
 
-        // Increases rollback indices if the slot has successfully booted.
-        if verified_success && slot_booted_successfully {
-            for (loc, val) in verify_data.rollback_indexes().iter().enumerate() {
-                if *val > 0 && avb_ops.read_rollback_index(loc)? != *val {
-                    avb_ops.write_rollback_index(loc, *val)?;
-                }
+    // Collects ZBI items from vbmetadata and appends to the `zbi_items`.
+    for vbmeta_data in verify_data.vbmeta_data() {
+        for prop in vbmeta_data.descriptors()?.iter().filter_map(|d| match d {
+            Descriptor::Property(p) if p.key.starts_with("zbi") => Some(p),
+            _ => None,
+        }) {
+            zbi_items.extend_unaligned(prop.value)?;
+        }
+    }
+
+    // Increases rollback indices if the slot has successfully booted.
+    if verified_success && slot_booted_successfully {
+        for (loc, val) in verify_data.rollback_indexes().iter().enumerate() {
+            if *val > 0 && avb_ops.read_rollback_index(loc)? != *val {
+                avb_ops.write_rollback_index(loc, *val)?;
             }
+        }
 
-            // Increases rollback index values for Fuchsia key version locations.
-            for key_version in avb_ops.key_versions {
-                match key_version {
-                    Some((loc, rollback)) if avb_ops.read_rollback_index(loc)? != rollback => {
-                        avb_ops.write_rollback_index(loc, rollback)?;
-                    }
-                    _ => {}
+        // Increases rollback index values for Fuchsia key version locations.
+        for key_version in avb_ops.key_versions {
+            match key_version {
+                Some((loc, rollback)) if avb_ops.read_rollback_index(loc)? != rollback => {
+                    avb_ops.write_rollback_index(loc, rollback)?;
                 }
+                _ => {}
             }
         }
     }
 
-    // Merges the vbmeta descriptor ZBI container into the ZBI kernel container.
-    Ok(merge_within(zbi_kernel, desc_zbi_off).map(|_| ())?)
+    Ok(())
+}
+
+/// Copy ZBI items following kernel to separate container.
+pub fn copy_items_after_kernel<'a, B: ByteSliceMut + PartialEq>(
+    zbi_kernel: &'a mut [u8],
+    zbi_items: &mut ZbiContainer<B>,
+) -> GblResult<()> {
+    let zbi_container = ZbiContainer::parse(&mut zbi_kernel[..])?;
+    let mut items_iter = zbi_container.iter();
+    items_iter.next(); // Skip first kernel item
+    zbi_items.extend_items(items_iter)?;
+    Ok(())
 }
 
 #[cfg(test)]
@@ -300,78 +143,32 @@ mod test {
         ZIRCON_KERNEL_ALIGN,
     };
     use avb_bindgen::{AVB_CERT_PIK_VERSION_LOCATION, AVB_CERT_PSK_VERSION_LOCATION};
+    use zbi::ZBI_ALIGNMENT_USIZE;
 
     // The cert test keys were both generated with rollback version 42.
     const TEST_CERT_PIK_VERSION: u64 = 42;
     const TEST_CERT_PSK_VERSION: u64 = 42;
 
-    #[test]
-    fn test_avb_ops_read_from_partition_positive_off() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let gbl_ops = &mut create_gbl_ops(&partitions);
-
-        let zircon_a = gbl_ops.copy_partition("zircon_a");
-
-        let mut avb_ops =
-            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
-        let mut out = vec![0u8; 512];
-        // Positive offset.
-        avb_ops.read_from_partition(c"zircon_a", 1, &mut out[..]).unwrap();
-        assert_eq!(out, zircon_a[1..][..out.len()]);
-    }
-
-    #[test]
-    fn test_avb_ops_read_from_partition_negative_off() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let gbl_ops = &mut create_gbl_ops(&partitions);
-
-        let zircon_a = gbl_ops.copy_partition("zircon_a");
-
-        let mut avb_ops =
-            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
-        let mut out = vec![0u8; 512];
-        // Negative offset.
-        avb_ops.read_from_partition(c"zircon_a", -1024, &mut out[..]).unwrap();
-        assert_eq!(out, zircon_a[zircon_a.len() - 1024..][..out.len()]);
-    }
-
-    #[test]
-    fn test_avb_ops_read_from_partition_partial_read() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let gbl_ops = &mut create_gbl_ops(&partitions);
-
-        let zircon_a = gbl_ops.copy_partition("zircon_a");
-
-        let mut avb_ops =
-            GblZirconBootAvbOps { gbl_ops, preloaded_partitions: &[], key_versions: [None, None] };
-        let mut out = vec![0u8; 512];
-        // Partial read.
-        avb_ops.read_from_partition(c"zircon_a", -256, &mut out[..]).unwrap();
-        assert_eq!(out[..256], zircon_a[zircon_a.len() - 256..]);
-    }
-
     #[test]
     fn test_verify_success() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         let expect_rollback = ops.avb_ops.rollbacks.clone();
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         load_buffer[..zbi.len()].clone_from_slice(zbi);
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), false, &mut load_buffer).unwrap();
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), false, &mut load_buffer, &mut zbi_items)
+            .unwrap();
 
         // Verifies that vbmeta ZBI items are appended. Non-zbi items are ignored.
         let mut expected_zbi_items = AlignedBuffer::new(zbi.len() + 1024, 8);
-        expected_zbi_items[..zbi.len()].clone_from_slice(zbi);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        assert_eq!(normalize_zbi(&load_buffer), normalize_zbi(&expected_zbi_items));
+        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
 
         // Slot is not successful, rollback index should not be updated.
         assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
@@ -379,24 +176,31 @@ mod test {
 
     #[test]
     fn test_verify_update_rollback_index_for_successful_slot() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load_buffer[..zbi.len()].clone_from_slice(zbi);
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
+            .unwrap();
 
         // Slot is successful, rollback index should be updated.
         // vbmeta_a has rollback index value 2 at location 1.
         assert_eq!(
             ops.avb_ops.rollbacks,
             [
-                (1, 2),
-                (usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION),
-                (usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(), TEST_CERT_PIK_VERSION)
+                (1, Ok(2)),
+                (
+                    usize::try_from(AVB_CERT_PSK_VERSION_LOCATION).unwrap(),
+                    Ok(TEST_CERT_PSK_VERSION)
+                ),
+                (
+                    usize::try_from(AVB_CERT_PIK_VERSION_LOCATION).unwrap(),
+                    Ok(TEST_CERT_PIK_VERSION)
+                )
             ]
             .into()
         );
@@ -404,19 +208,26 @@ mod test {
 
     #[test]
     fn test_verify_failed_on_corrupted_image() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         let expect_rollback = ops.avb_ops.rollbacks.clone();
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         // Corrupts a random kernel bytes. Skips pass two ZBI headers.
         load_buffer[64] = !load_buffer[64];
         let expect_load = load_buffer.to_vec();
-        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).is_err());
+        assert!(zircon_verify_kernel(
+            &mut ops,
+            Some(SlotIndex::A),
+            true,
+            &mut load_buffer,
+            &mut zbi_items
+        )
+        .is_err());
         // Failed while device is locked. ZBI items should not be appended.
         assert_eq!(expect_load, &load_buffer[..]);
         // Rollback index should not be updated on verification failure.
@@ -425,19 +236,26 @@ mod test {
 
     #[test]
     fn test_verify_failed_on_corrupted_vbmetadata() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         let expect_rollback = ops.avb_ops.rollbacks.clone();
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load[..zbi.len()].clone_from_slice(zbi);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         let expect_load = load.to_vec();
         // Corrupts vbmetadata
         corrupt_data(&mut ops, "vbmeta_a");
-        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load).is_err());
+        assert!(zircon_verify_kernel(
+            &mut ops,
+            Some(SlotIndex::A),
+            true,
+            &mut load,
+            &mut zbi_items
+        )
+        .is_err());
         // Failed while device is locked. ZBI items should not be appended.
         assert_eq!(expect_load, &load[..]);
         // Rollback index should not be updated on verification failure.
@@ -446,20 +264,27 @@ mod test {
 
     #[test]
     fn test_verify_failed_on_rollback_protection() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         let expect_load = load_buffer.to_vec();
         // vbmeta_a has rollback index value 2 at location 1. Setting min rollback value of 3 should
         // cause rollback protection failure.
-        ops.avb_ops.rollbacks.insert(1, 3);
+        ops.avb_ops.rollbacks.insert(1, Ok(3));
         let expect_rollback = ops.avb_ops.rollbacks.clone();
-        assert!(zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).is_err());
+        assert!(zircon_verify_kernel(
+            &mut ops,
+            Some(SlotIndex::A),
+            true,
+            &mut load_buffer,
+            &mut zbi_items
+        )
+        .is_err());
         // Failed while device is locked. ZBI items should not be appended.
         assert_eq!(expect_load, &load_buffer[..]);
         // Rollback index should not be updated on verification failure.
@@ -468,47 +293,75 @@ mod test {
 
     #[test]
     fn test_verify_failure_when_unlocked() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         ops.avb_ops.unlock_state = Ok(true);
         let expect_rollback = ops.avb_ops.rollbacks.clone();
 
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         // Corrupts a random kernel bytes. Skips pass two ZBI headers.
         load_buffer[64] = !load_buffer[64];
         // Verification should proceeds OK.
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
+            .unwrap();
         // Verifies that vbmeta ZBI items are appended as long as unlocked.
-        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), 8);
-        expected_zbi_items[..load_buffer.len()].clone_from_slice(&load_buffer);
+        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
         append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
-        assert_eq!(normalize_zbi(&load_buffer), normalize_zbi(&expected_zbi_items));
+        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
         // Rollback index should not be updated in any failure cases, even when unlocked.
         assert_eq!(expect_rollback, ops.avb_ops.rollbacks);
     }
 
+    #[test]
+    fn test_copy_items_after_kernel() {
+        let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
+        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        load_buffer[..zbi.len()].clone_from_slice(zbi);
+        // Add items that will be copied
+        append_cmd_line(&mut load_buffer, b"vb_prop_0=val\0");
+        append_cmd_line(&mut load_buffer, b"vb_prop_1=val\0");
+
+        // Create ZBI items container that contain 1 element
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
+        append_cmd_line(&mut zbi_items_buffer, b"vb_prop_2=val\0");
+        let mut zbi_items = ZbiContainer::parse(&mut zbi_items_buffer[..]).unwrap();
+
+        // Verifies that ZBI items are appended
+        let mut expected_zbi_items = AlignedBuffer::new(load_buffer.len(), ZBI_ALIGNMENT_USIZE);
+        let _ = ZbiContainer::new(&mut expected_zbi_items[..]).unwrap();
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_2=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_0=val\0");
+        append_cmd_line(&mut expected_zbi_items, b"vb_prop_1=val\0");
+
+        copy_items_after_kernel(&mut load_buffer, &mut zbi_items).unwrap();
+        assert_eq!(normalize_zbi(&zbi_items_buffer), normalize_zbi(&expected_zbi_items));
+    }
+
     #[test]
     fn test_verify_failure_by_corrupted_vbmetadata_unlocked() {
-        let mut storage = create_storage();
-        let partitions = storage.as_partition_block_devices();
-        let mut ops = create_gbl_ops(&partitions);
+        let storage = create_storage();
+        let mut ops = create_gbl_ops(&storage);
 
         ops.avb_ops.unlock_state = Ok(true);
         let expect_rollback = ops.avb_ops.rollbacks.clone();
         let zbi = &read_test_data(ZIRCON_A_ZBI_FILE);
-        // Adds extra bytes for device ZBI items.
-        let mut load_buffer = AlignedBuffer::new(zbi.len() + 1024, ZIRCON_KERNEL_ALIGN);
+        let mut load_buffer = AlignedBuffer::new(zbi.len(), ZIRCON_KERNEL_ALIGN);
         load_buffer[..zbi.len()].clone_from_slice(zbi);
+        let mut zbi_items_buffer = AlignedBuffer::new(1024, ZBI_ALIGNMENT_USIZE);
+        let mut zbi_items = ZbiContainer::new(&mut zbi_items_buffer[..]).unwrap();
         let expect_load = load_buffer.to_vec();
         // Corrupts vbmetadata
         corrupt_data(&mut ops, "vbmeta_a");
-        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer).unwrap();
+        zircon_verify_kernel(&mut ops, Some(SlotIndex::A), true, &mut load_buffer, &mut zbi_items)
+            .unwrap();
         // Unlocked but vbmetadata is invalid so no ZBI items should be appended.
         assert_eq!(expect_load, &load_buffer[..]);
         // Rollback index should not be updated on verification failure.
diff --git a/gbl/libgbl/src/gbl_avb/mod.rs b/gbl/libgbl/src/gbl_avb/mod.rs
new file mode 100644
index 0000000..4d90083
--- /dev/null
+++ b/gbl/libgbl/src/gbl_avb/mod.rs
@@ -0,0 +1,18 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! GBL AVB implementation.
+
+pub(crate) mod ops;
+pub mod state;
diff --git a/gbl/libgbl/src/gbl_avb/ops.rs b/gbl/libgbl/src/gbl_avb/ops.rs
new file mode 100644
index 0000000..1df1a73
--- /dev/null
+++ b/gbl/libgbl/src/gbl_avb/ops.rs
@@ -0,0 +1,778 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Gbl AVB operations.
+
+use crate::{
+    gbl_avb::state::{BootStateColor, KeyValidationStatus},
+    gbl_print, gbl_println, GblOps,
+};
+use avb::{
+    cert_validate_vbmeta_public_key, CertOps, CertPermanentAttributes, IoError, IoResult,
+    Ops as AvbOps, PublicKeyForPartitionInfo, SlotVerifyData, SHA256_DIGEST_SIZE,
+};
+use core::{
+    cmp::{max, min},
+    ffi::CStr,
+};
+use liberror::Error;
+use safemath::SafeNum;
+use uuid::Uuid;
+
+// AVB cert tracks versions for the PIK and PSK; PRK cannot be changed so has no version info.
+const AVB_CERT_NUM_KEY_VERSIONS: usize = 2;
+
+/// Implements avb ops callbacks for [GblOps].
+pub struct GblAvbOps<'a, T> {
+    /// The underlying [GblOps].
+    pub gbl_ops: &'a mut T,
+    preloaded_partitions: &'a [(&'a str, &'a [u8])],
+    /// Used for storing key versions to be set (location, version).
+    ///
+    /// These will initially be `None`, but if using the cert extensions they will be updated during
+    /// verification. These values will not be automatically persisted to disk because whether to do
+    /// so depends on other factors such as slot success state; it's up to the user to persist them
+    /// post-verification if needed.
+    // If `array_map` is imported in the future, consider switching to it.
+    pub key_versions: [Option<(usize, u64)>; AVB_CERT_NUM_KEY_VERSIONS],
+    /// True to use the AVB cert extensions.
+    use_cert: bool,
+    /// Avb public key validation status reported by validate_vbmeta_public_key.
+    /// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
+    key_validation_status: Option<KeyValidationStatus>,
+}
+
+impl<'a, 'p, 'q, T: GblOps<'p, 'q>> GblAvbOps<'a, T> {
+    /// Creates a new [GblAvbOps].
+    pub fn new(
+        gbl_ops: &'a mut T,
+        preloaded_partitions: &'a [(&'a str, &'a [u8])],
+        use_cert: bool,
+    ) -> Self {
+        Self {
+            gbl_ops,
+            preloaded_partitions,
+            key_versions: [None; AVB_CERT_NUM_KEY_VERSIONS],
+            use_cert,
+            key_validation_status: None,
+        }
+    }
+
+    /// Returns the size of a partition.
+    ///
+    /// This will only consider the [GblOps] partitions. To include preloaded partitions as well,
+    /// use [AvbOps::get_size_of_partition].
+    fn partition_size(&mut self, partition: &str) -> IoResult<u64> {
+        self.gbl_ops.partition_size(partition).or(Err(IoError::Io))?.ok_or(IoError::NoSuchPartition)
+    }
+
+    /// Allowes implementation side to handle verification result.
+    pub fn handle_verification_result(
+        &mut self,
+        slot_verify: &SlotVerifyData,
+        color: BootStateColor,
+    ) -> IoResult<()> {
+        let mut vbmeta = None;
+        let mut vbmeta_boot = None;
+        let mut vbmeta_system = None;
+        let mut vbmeta_vendor = None;
+
+        // The Android build system automatically generates only the main vbmeta, but also allows
+        // to have separate chained partitions like vbmeta_system (for system, product, system_ext,
+        // etc.) or vbmeta_vendor (for vendor).
+        // https://android.googlesource.com/platform/external/avb/+/master/README.md#build-system-integration
+        //
+        // It may also integrate chained vbmeta into system level metadata partitions such as boot
+        // or init_boot, so they can be updated separately.
+        // https://android.googlesource.com/platform/external/avb/+/master/README.md#gki-2_0-integration
+        //
+        // Custom chained partitions are also supported by the Android build system, but we expect
+        // OEMs to follow about the same pattern.
+        // https://android-review.googlesource.com/q/Id671e2c3aee9ada90256381cce432927df03169b
+        for data in slot_verify.vbmeta_data() {
+            match data.partition_name().to_str().unwrap_or_default() {
+                "vbmeta" => vbmeta = Some(data),
+                "boot" => vbmeta_boot = Some(data),
+                "vbmeta_system" => vbmeta_system = Some(data),
+                "vbmeta_vendor" => vbmeta_vendor = Some(data),
+                _ => {}
+            }
+        }
+
+        let data = vbmeta.ok_or(IoError::NoSuchPartition)?;
+        let boot_data = vbmeta_boot.unwrap_or(data);
+        let system_data = vbmeta_system.unwrap_or(data);
+        let vendor_data = vbmeta_vendor.unwrap_or(data);
+
+        let boot_os_version = boot_data.get_property_value("com.android.build.boot.os_version");
+        let boot_security_patch =
+            boot_data.get_property_value("com.android.build.boot.security_patch");
+
+        let system_os_version =
+            system_data.get_property_value("com.android.build.system.os_version");
+        let system_security_patch =
+            system_data.get_property_value("com.android.build.system.security_patch");
+
+        let vendor_os_version =
+            vendor_data.get_property_value("com.android.build.vendor.os_version");
+        let vendor_security_patch =
+            vendor_data.get_property_value("com.android.build.vendor.security_patch");
+
+        self.gbl_ops.avb_handle_verification_result(
+            color,
+            // TODO(b/337846185): extract VBH from the command line provided by libavb.
+            None,
+            boot_os_version,
+            boot_security_patch,
+            system_os_version,
+            system_security_patch,
+            vendor_os_version,
+            vendor_security_patch,
+        )
+    }
+
+    /// Get vbmeta public key validation status reported by validate_vbmeta_public_key.
+    pub fn key_validation_status(&self) -> IoResult<KeyValidationStatus> {
+        self.key_validation_status.ok_or(IoError::NotImplemented)
+    }
+}
+
+/// A helper function for converting `CStr` to `str`
+fn cstr_to_str<E>(s: &CStr, err: E) -> Result<&str, E> {
+    Ok(s.to_str().or(Err(err))?)
+}
+
+/// # Lifetimes
+/// * `'a`: preloaded data lifetime
+/// * `'b`: [GblOps] partition lifetime
+impl<'a, 'b, 'c, T: GblOps<'b, 'c>> AvbOps<'a> for GblAvbOps<'a, T> {
+    fn read_from_partition(
+        &mut self,
+        partition: &CStr,
+        offset: i64,
+        buffer: &mut [u8],
+    ) -> IoResult<usize> {
+        let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
+        let partition_size = SafeNum::from(self.partition_size(part_str)?);
+        let read_off = match offset < 0 {
+            true => partition_size - offset.abs(),
+            _ => SafeNum::from(offset),
+        };
+        let read_sz = partition_size - read_off;
+        let read_off = read_off.try_into().or(Err(IoError::RangeOutsidePartition))?;
+        let read_sz =
+            min(buffer.len(), read_sz.try_into().or(Err(IoError::RangeOutsidePartition))?);
+        self.gbl_ops.read_from_partition_sync(part_str, read_off, &mut buffer[..read_sz]).map_err(
+            |e| match e {
+                Error::NotFound => IoError::NoSuchPartition,
+                Error::ArithmeticOverflow(_) => IoError::RangeOutsidePartition,
+                _ => IoError::Io,
+            },
+        )?;
+        Ok(read_sz)
+    }
+
+    fn get_preloaded_partition(&mut self, partition: &CStr) -> IoResult<&'a [u8]> {
+        let part_str = cstr_to_str(partition, IoError::NotImplemented)?;
+        Ok(self
+            .preloaded_partitions
+            .iter()
+            .find(|(name, _)| *name == part_str)
+            .ok_or(IoError::NotImplemented)?
+            .1)
+    }
+
+    fn validate_vbmeta_public_key(
+        &mut self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> IoResult<bool> {
+        let status = if self.use_cert {
+            match cert_validate_vbmeta_public_key(self, public_key, public_key_metadata)? {
+                true => KeyValidationStatus::Valid,
+                false => KeyValidationStatus::Invalid,
+            }
+        } else {
+            self.gbl_ops.avb_validate_vbmeta_public_key(public_key, public_key_metadata).or_else(
+                |err| {
+                    // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+                    // forced.
+                    fallback_not_implemented(
+                        self.gbl_ops,
+                        err,
+                        "validate_vbmeta_public_key",
+                        KeyValidationStatus::ValidCustomKey,
+                    )
+                },
+            )?
+        };
+
+        self.key_validation_status = Some(status);
+
+        Ok(matches!(status, KeyValidationStatus::Valid | KeyValidationStatus::ValidCustomKey))
+    }
+
+    fn read_rollback_index(&mut self, rollback_index_location: usize) -> IoResult<u64> {
+        self.gbl_ops.avb_read_rollback_index(rollback_index_location).or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "read_rollback_index", 0)
+        })
+    }
+
+    fn write_rollback_index(&mut self, rollback_index_location: usize, index: u64) -> IoResult<()> {
+        self.gbl_ops.avb_write_rollback_index(rollback_index_location, index).or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "write_rollback_index", ())
+        })
+    }
+
+    fn read_is_device_unlocked(&mut self) -> IoResult<bool> {
+        self.gbl_ops.avb_read_is_device_unlocked().or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "read_is_device_unlocked", true)
+        })
+    }
+
+    fn get_unique_guid_for_partition(&mut self, partition: &CStr) -> IoResult<Uuid> {
+        // The ops is only used to check that a partition exists. GUID is not used.
+        self.partition_size(cstr_to_str(partition, IoError::NoSuchPartition)?)?;
+        Ok(Uuid::nil())
+    }
+
+    fn get_size_of_partition(&mut self, partition: &CStr) -> IoResult<u64> {
+        match self.get_preloaded_partition(partition) {
+            Ok(img) => Ok(img.len().try_into().unwrap()),
+            _ => {
+                let part_str = cstr_to_str(partition, IoError::NoSuchPartition)?;
+                self.partition_size(part_str)
+            }
+        }
+    }
+
+    fn read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> IoResult<usize> {
+        self.gbl_ops.avb_read_persistent_value(name, value).or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "read_persistent_value", 0)
+        })
+    }
+
+    fn write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> IoResult<()> {
+        self.gbl_ops.avb_write_persistent_value(name, value).or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "write_persistent_value", ())
+        })
+    }
+
+    fn erase_persistent_value(&mut self, name: &CStr) -> IoResult<()> {
+        self.gbl_ops.avb_erase_persistent_value(name).or_else(|err| {
+            // TODO(b/337846185): Remove fallback once AVB protocol implementation is
+            // forced.
+            fallback_not_implemented(self.gbl_ops, err, "erase_persistent_value", ())
+        })
+    }
+
+    fn validate_public_key_for_partition(
+        &mut self,
+        _partition: &CStr,
+        _public_key: &[u8],
+        _public_key_metadata: Option<&[u8]>,
+    ) -> IoResult<PublicKeyForPartitionInfo> {
+        // Not needed yet; eventually we will plumb this through [GblOps].
+        unreachable!();
+    }
+
+    fn cert_ops(&mut self) -> Option<&mut dyn CertOps> {
+        match self.use_cert {
+            true => Some(self),
+            false => None,
+        }
+    }
+}
+
+/// [GblAvbOps] always implements [CertOps], but it's only used if `use_cert` is set.
+impl<'a, 'b, T: GblOps<'a, 'b>> CertOps for GblAvbOps<'_, T> {
+    fn read_permanent_attributes(
+        &mut self,
+        attributes: &mut CertPermanentAttributes,
+    ) -> IoResult<()> {
+        self.gbl_ops.avb_cert_read_permanent_attributes(attributes)
+    }
+
+    fn read_permanent_attributes_hash(&mut self) -> IoResult<[u8; SHA256_DIGEST_SIZE]> {
+        self.gbl_ops.avb_cert_read_permanent_attributes_hash()
+    }
+
+    fn set_key_version(&mut self, rollback_index_location: usize, key_version: u64) {
+        // Checks if there is already an allocated slot for this location.
+        let existing = self
+            .key_versions
+            .iter_mut()
+            .find_map(|v| v.as_mut().filter(|(loc, _)| *loc == rollback_index_location));
+        match existing {
+            Some((_, val)) => *val = max(*val, key_version),
+            _ => {
+                // Finds an empty slot and stores the rollback index.
+                *self
+                    .key_versions
+                    .iter_mut()
+                    .find(|v| v.is_none())
+                    .expect("Ran out of key version slots") =
+                    Some((rollback_index_location, key_version))
+            }
+        }
+    }
+
+    fn get_random(&mut self, _: &mut [u8]) -> IoResult<()> {
+        // Not needed yet; eventually we will plumb this through [GblOps].
+        unimplemented!()
+    }
+}
+
+fn fallback_not_implemented<'a, 'b, T>(
+    ops: &mut impl GblOps<'a, 'b>,
+    error: IoError,
+    method_name: &str,
+    value: T,
+) -> IoResult<T> {
+    match error {
+        IoError::NotImplemented => {
+            gbl_println!(
+                ops,
+                "WARNING: UEFI GblEfiAvbProtocol.{} implementation is missing. This will not be \
+                permitted in the future.",
+                method_name,
+            );
+            Ok(value)
+        }
+        err => Err(err),
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::ops::test::{FakeGblOps, FakeGblOpsStorage};
+
+    // Returns test data consisting of `size` incrementing bytes (0-255 repeating).
+    fn test_data(size: usize) -> Vec<u8> {
+        let mut data = vec![0u8; size];
+        for index in 0..data.len() {
+            data[index] = index as u8;
+        }
+        data
+    }
+
+    #[test]
+    fn read_from_partition_positive_off() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"test_part", test_data(512));
+
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        // Positive offset.
+        let mut out = [0u8; 4];
+        assert_eq!(avb_ops.read_from_partition(c"test_part", 1, &mut out[..]), Ok(4));
+        assert_eq!(out, [1, 2, 3, 4]);
+    }
+
+    #[test]
+    fn read_from_partition_negative_off() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"test_part", test_data(512));
+
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        // Negative offset should wrap from the end
+        let mut out = [0u8; 6];
+        assert_eq!(avb_ops.read_from_partition(c"test_part", -6, &mut out[..]), Ok(6));
+        assert_eq!(out, [0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF]);
+    }
+
+    #[test]
+    fn read_from_partition_partial_read() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"test_part", test_data(512));
+
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        // Reading past the end of the partition should truncate.
+        let mut out = [0u8; 6];
+        assert_eq!(avb_ops.read_from_partition(c"test_part", -3, &mut out[..]), Ok(3));
+        assert_eq!(out, [0xFD, 0xFE, 0xFF, 0, 0, 0]);
+    }
+
+    #[test]
+    fn read_from_partition_out_of_bounds() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"test_part", test_data(512));
+
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        // Reads starting out of bounds should fail.
+        let mut out = [0u8; 4];
+        assert_eq!(
+            avb_ops.read_from_partition(c"test_part", 513, &mut out[..]),
+            Err(IoError::RangeOutsidePartition)
+        );
+        assert_eq!(
+            avb_ops.read_from_partition(c"test_part", -513, &mut out[..]),
+            Err(IoError::RangeOutsidePartition)
+        );
+    }
+
+    #[test]
+    fn read_from_partition_unknown_part() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        let mut out = [0u8; 4];
+        assert_eq!(
+            avb_ops.read_from_partition(c"unknown_part", 0, &mut out[..]),
+            Err(IoError::NoSuchPartition)
+        );
+    }
+
+    #[test]
+    fn set_key_version_default() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        assert_eq!(avb_ops.key_versions, [None, None]);
+    }
+
+    #[test]
+    fn set_key_version_once() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        avb_ops.set_key_version(5, 10);
+        assert_eq!(avb_ops.key_versions, [Some((5, 10)), None]);
+    }
+
+    #[test]
+    fn set_key_version_twice() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        avb_ops.set_key_version(5, 10);
+        avb_ops.set_key_version(20, 40);
+        assert_eq!(avb_ops.key_versions, [Some((5, 10)), Some((20, 40))]);
+    }
+
+    #[test]
+    fn set_key_version_overwrite() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        avb_ops.set_key_version(5, 10);
+        avb_ops.set_key_version(20, 40);
+        avb_ops.set_key_version(5, 100);
+        assert_eq!(avb_ops.key_versions, [Some((5, 100)), Some((20, 40))]);
+    }
+
+    // AVB's key version callback cannot return an error, so if it fails we panic.
+    //
+    // It's possible we could stash the failure somewhere and check it later, but we'd have to be
+    // very careful, as failing to check the status would be a security vulnerability. For now it's
+    // safer to panic, and we only ever expect the PSK and PIK to have key versions.
+    #[test]
+    #[should_panic(expected = "Ran out of key version slots")]
+    fn set_key_version_overflow() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        avb_ops.set_key_version(5, 10);
+        avb_ops.set_key_version(20, 40);
+        avb_ops.set_key_version(40, 100);
+    }
+
+    #[test]
+    fn validate_vbmeta_public_key_valid() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Valid));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
+        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::Valid));
+    }
+
+    #[test]
+    fn validate_vbmeta_public_key_valid_custom_key() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::ValidCustomKey));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
+        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::ValidCustomKey));
+    }
+
+    #[test]
+    fn validate_vbmeta_public_key_invalid() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_key_validation_status = Some(Ok(KeyValidationStatus::Invalid));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(false));
+        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::Invalid));
+    }
+
+    #[test]
+    fn validate_vbmeta_public_key_failed() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_key_validation_status = Some(Err(IoError::Io));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Err(IoError::Io));
+        assert!(avb_ops.key_validation_status().is_err());
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn validate_vbmeta_public_key_not_implemented() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_key_validation_status = Some(Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        assert_eq!(avb_ops.validate_vbmeta_public_key(&[], None), Ok(true));
+        assert_eq!(avb_ops.key_validation_status(), Ok(KeyValidationStatus::ValidCustomKey));
+    }
+
+    #[test]
+    fn read_rollback_index_read_value() {
+        const EXPECTED_INDEX: usize = 1;
+        const EXPECTED_VALUE: u64 = 100;
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.rollbacks.insert(EXPECTED_INDEX, Ok(EXPECTED_VALUE));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.read_rollback_index(EXPECTED_INDEX), Ok(EXPECTED_VALUE));
+    }
+
+    #[test]
+    fn read_rollback_index_error_handled() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.read_rollback_index(0), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn read_rollback_index_not_implemented() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.read_rollback_index(0), Ok(0));
+    }
+
+    #[test]
+    fn write_rollback_index_write_value() {
+        const EXPECTED_INDEX: usize = 1;
+        const EXPECTED_VALUE: u64 = 100;
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_rollback_index(EXPECTED_INDEX, EXPECTED_VALUE), Ok(()));
+        assert_eq!(
+            gbl_ops.avb_ops.rollbacks.get(&EXPECTED_INDEX),
+            Some(Ok(EXPECTED_VALUE)).as_ref()
+        );
+    }
+
+    #[test]
+    fn write_rollback_index_error_handled() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::Io));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_rollback_index(0, 0), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn write_rollback_index_not_implemented() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.rollbacks.insert(0, Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_rollback_index(0, 0), Ok(()));
+    }
+
+    #[test]
+    fn read_is_device_unlocked_value_obtained() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.unlock_state = Ok(true);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+
+        assert_eq!(avb_ops.read_is_device_unlocked(), Ok(true));
+    }
+
+    #[test]
+    fn read_is_device_unlocked_error_handled() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.unlock_state = Err(IoError::Io);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.read_is_device_unlocked(), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn read_is_device_unlocked_not_implemented() {
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.unlock_state = Err(IoError::NotImplemented);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.read_is_device_unlocked(), Ok(true));
+    }
+
+    #[test]
+    fn read_persistent_value_success() {
+        const EXPECTED_NAME: &CStr = c"test";
+        const EXPECTED_VALUE: &[u8] = b"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Ok(EXPECTED_VALUE));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        let mut buffer = [0u8; EXPECTED_VALUE.len()];
+        assert_eq!(
+            avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer),
+            Ok(EXPECTED_VALUE.len())
+        );
+        assert_eq!(buffer, EXPECTED_VALUE);
+    }
+
+    #[test]
+    fn read_persistent_value_error() {
+        const EXPECTED_NAME: &CStr = c"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        let mut buffer = [0u8; 4];
+        assert_eq!(avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn read_persistent_value_not_implemented() {
+        const EXPECTED_NAME: &CStr = c"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops
+            .avb_ops
+            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        let mut buffer = [0u8; 0];
+        assert_eq!(avb_ops.read_persistent_value(EXPECTED_NAME, &mut buffer), Ok(0));
+    }
+
+    #[test]
+    fn write_persistent_value_success() {
+        const EXPECTED_NAME: &CStr = c"test";
+        const EXPECTED_VALUE: &[u8] = b"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Ok(()));
+
+        assert_eq!(
+            gbl_ops.avb_ops.persistent_values.get(EXPECTED_NAME.to_str().unwrap()),
+            Some(Ok(EXPECTED_VALUE.to_vec())).as_ref()
+        );
+    }
+
+    #[test]
+    fn write_persistent_value_error() {
+        const EXPECTED_NAME: &CStr = c"test";
+        const EXPECTED_VALUE: &[u8] = b"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn write_persistent_value_not_implemented() {
+        const EXPECTED_NAME: &CStr = c"test";
+        const EXPECTED_VALUE: &[u8] = b"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops
+            .avb_ops
+            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.write_persistent_value(EXPECTED_NAME, EXPECTED_VALUE), Ok(()));
+    }
+
+    #[test]
+    fn erase_persistent_value_success() {
+        const EXPECTED_NAME: &CStr = c"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Ok(b"test"));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Ok(()));
+
+        assert!(!gbl_ops.avb_ops.persistent_values.contains_key(EXPECTED_NAME.to_str().unwrap()));
+    }
+
+    #[test]
+    fn erase_persistent_value_error() {
+        const EXPECTED_NAME: &CStr = c"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops.avb_ops.add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::Io));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Err(IoError::Io));
+    }
+
+    // TODO(b/337846185): Remove test once AVB protocol implementation is forced.
+    #[test]
+    fn erase_persistent_value_not_implemented() {
+        const EXPECTED_NAME: &CStr = c"test";
+
+        let mut gbl_ops = FakeGblOps::new(&[]);
+        gbl_ops
+            .avb_ops
+            .add_persistent_value(EXPECTED_NAME.to_str().unwrap(), Err(IoError::NotImplemented));
+
+        let mut avb_ops = GblAvbOps::new(&mut gbl_ops, &[], false);
+        assert_eq!(avb_ops.erase_persistent_value(EXPECTED_NAME), Ok(()));
+    }
+}
diff --git a/gbl/libgbl/src/gbl_avb/state.rs b/gbl/libgbl/src/gbl_avb/state.rs
new file mode 100644
index 0000000..57b953d
--- /dev/null
+++ b/gbl/libgbl/src/gbl_avb/state.rs
@@ -0,0 +1,56 @@
+// Copyright 2024, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Gbl AVB state (version, color, etc).
+
+use core::fmt::{Display, Formatter};
+
+/// https://source.android.com/docs/security/features/verifiedboot/boot-flow#communicating-verified-boot-state-to-users
+#[derive(Clone, Copy, PartialEq)]
+pub enum BootStateColor {
+    /// Success .
+    Green,
+    /// Success but custom key is used.
+    Yellow,
+    /// Device is unlocked.
+    Orange,
+    /// Dm-verity is corrupted.
+    RedEio,
+    /// No valid OS found.
+    Red,
+}
+
+/// To use in bootconfig.
+impl Display for BootStateColor {
+    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
+        f.write_str(match self {
+            BootStateColor::Green => "green",
+            BootStateColor::Yellow => "yellow",
+            BootStateColor::Orange => "orange",
+            BootStateColor::RedEio => "red_eio",
+            BootStateColor::Red => "red",
+        })
+    }
+}
+
+/// https://source.android.com/docs/security/features/verifiedboot/boot-flow#locked-devices-with-custom-root-of-trust
+#[derive(Clone, Copy, Debug, PartialEq)]
+pub enum KeyValidationStatus {
+    /// Vbmeta key is matched with a production key.
+    Valid,
+    /// Vbmeta key is matched with a custom key.
+    ValidCustomKey,
+    /// Vbmeta key isn't matched.
+    Invalid,
+}
diff --git a/gbl/libgbl/src/image_buffer.rs b/gbl/libgbl/src/image_buffer.rs
index 0255829..aee6537 100644
--- a/gbl/libgbl/src/image_buffer.rs
+++ b/gbl/libgbl/src/image_buffer.rs
@@ -43,11 +43,23 @@ pub struct ImageBuffer<'a> {
 // Calling this when the content is not yet fully initialized causes undefined behavior.
 #[inline(always)]
 unsafe fn slice_assume_init_mut<T>(slice: &mut [MaybeUninit<T>]) -> &mut [T] {
-    // SAFETY: similar to safety notes for `slice_get_ref`, but we have a
-    // mutable reference which is also guaranteed to be valid for writes.
+    // SAFETY: Caller must make sure provided data is initialized.
     unsafe { &mut *(slice as *mut [MaybeUninit<T>] as *mut [T]) }
 }
 
+// Assuming all the elements are initialized, get a slice of them.
+//
+// # Safety
+//
+// It is up to the caller to guarantee that the `MaybeUninit<T>` elements
+// really are in an initialized state.
+// Calling this when the content is not yet fully initialized causes undefined behavior.
+#[inline(always)]
+unsafe fn slice_assume_init_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {
+    // SAFETY: Caller must make sure provided data is initialized.
+    unsafe { &*(slice as *const [MaybeUninit<T>] as *const [T]) }
+}
+
 impl ImageBuffer<'_> {
     /// Create new ImageBuffer from buffer and used_bytes
     pub fn new(buffer: &mut [MaybeUninit<u8>]) -> ImageBuffer {
@@ -79,9 +91,20 @@ impl ImageBuffer<'_> {
     }
 
     /// Return used and tail parts of the buffer
-    pub fn get_split(&mut self) -> (&mut [u8], &mut [MaybeUninit<u8>]) {
+    pub fn get_split(&self) -> (&[u8], &[MaybeUninit<u8>]) {
+        let (used, tail) = self.buffer.as_ref().unwrap().split_at(self.used_bytes);
+        // SAFETY:
+        //
+        // ImageBuffer user guarantees that changing used elements means they were initialized.
+        // And object assumes initialized only for slice [..used_bytes]
+        let initialized = unsafe { slice_assume_init_ref(used) };
+        (initialized, tail)
+    }
+
+    /// Return used and tail parts of the buffer
+    pub fn get_split_mut(&mut self) -> (&mut [u8], &mut [MaybeUninit<u8>]) {
         let (used, tail) = self.buffer.as_mut().unwrap().split_at_mut(self.used_bytes);
-        // SAFETY
+        // SAFETY:
         //
         // ImageBuffer user guaranties that changing used elements means they were initialized.
         // And object assumes initialized only for slice [..used_bytes]
@@ -90,14 +113,20 @@ impl ImageBuffer<'_> {
     }
 
     /// Slice of the buffer that is used
-    pub fn used(&mut self) -> &mut [u8] {
+    pub fn used(&self) -> &[u8] {
         let (used, _) = self.get_split();
         used
     }
 
+    /// Slice of the buffer that is used
+    pub fn used_mut(&mut self) -> &mut [u8] {
+        let (used, _) = self.get_split_mut();
+        used
+    }
+
     /// Return part of the buffer that is not used
     pub fn tail(&mut self) -> &mut [MaybeUninit<u8>] {
-        let (_, tail) = self.get_split();
+        let (_, tail) = self.get_split_mut();
         tail
     }
 }
@@ -114,13 +143,26 @@ impl AsMut<[MaybeUninit<u8>]> for ImageBuffer<'_> {
     }
 }
 
+impl PartialEq for ImageBuffer<'_> {
+    fn eq(&self, other: &Self) -> bool {
+        self.used() == other.used()
+    }
+}
+
 #[cfg(test)]
-mod test {
-    use super::*;
+/// Helper to create ImageBuffers from Vec<u8>
+pub struct ImageBufferVec {
+    buf: Vec<u8>,
+}
 
-    // Helper to create ImageBuffers from Vec<u8>
-    struct ImageBufferVec {
-        buf: Vec<u8>,
+#[cfg(test)]
+impl ImageBufferVec {
+    pub fn new(buf: Vec<u8>) -> Self {
+        Self { buf }
+    }
+
+    pub fn get(&mut self) -> ImageBuffer {
+        ImageBuffer::new(Self::slice_assume_not_init_mut(self.buf.as_mut_slice()))
     }
 
     fn slice_assume_not_init_mut<T>(slice: &mut [T]) -> &mut [MaybeUninit<T>] {
@@ -128,16 +170,11 @@ mod test {
         // mutable reference which is also guaranteed to be valid for writes.
         unsafe { &mut *(slice as *mut [T] as *mut [MaybeUninit<T>]) }
     }
+}
 
-    impl ImageBufferVec {
-        fn new(buf: Vec<u8>) -> Self {
-            Self { buf }
-        }
-
-        fn get(&mut self) -> ImageBuffer {
-            ImageBuffer::new(slice_assume_not_init_mut(self.buf.as_mut_slice()))
-        }
-    }
+#[cfg(test)]
+mod test {
+    use super::*;
 
     #[test]
     fn test_image_buffer_capacity() {
@@ -156,14 +193,17 @@ mod test {
         let mut img_buf_vec = ImageBufferVec::new(vec![0u8; 100]);
         let mut img_buf = img_buf_vec.get();
         assert_eq!(img_buf.used().len(), 0);
+        assert_eq!(img_buf.used_mut().len(), 0);
         // SAFETY:
         // All data in img_buf is initialized since it was created from vec
         unsafe { img_buf.advance_used(1).unwrap() };
         assert_eq!(img_buf.used().len(), 1);
+        assert_eq!(img_buf.used_mut().len(), 1);
         // SAFETY:
         // All data in img_buf is initialized since it was created from vec
         unsafe { img_buf.advance_used(3).unwrap() };
         assert_eq!(img_buf.used().len(), 4);
+        assert_eq!(img_buf.used_mut().len(), 4);
         assert_eq!(
             // SAFETY:
             // All data in img_buf is initialized since it was created from vec
@@ -171,6 +211,7 @@ mod test {
             Err(Error::BufferTooSmall(Some(1028)))
         );
         assert_eq!(img_buf.used().len(), 4);
+        assert_eq!(img_buf.used_mut().len(), 4);
     }
 
     #[test]
@@ -178,28 +219,83 @@ mod test {
         let mut img_buf_vec = ImageBufferVec::new(vec![0u8, 1, 2, 3]);
         let mut img_buf = img_buf_vec.get();
 
-        assert_eq!(img_buf.used(), [].as_mut_slice());
+        assert_eq!(img_buf.used(), [].as_slice());
+        assert_eq!(img_buf.used_mut(), [].as_mut_slice());
         assert_eq!(img_buf.tail().len(), 4);
         let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [].as_slice());
+        assert_eq!(tail.len(), 4);
+
+        let (used, tail) = img_buf.get_split_mut();
         assert_eq!(used, [].as_mut_slice());
         assert_eq!(tail.len(), 4);
 
         // SAFETY:
         // All data in img_buf is initialized since it was created from vec
         unsafe { img_buf.advance_used(2).unwrap() };
-        assert_eq!(img_buf.used(), [0, 1].as_mut_slice());
+        assert_eq!(img_buf.used(), [0, 1].as_slice());
+        assert_eq!(img_buf.used_mut(), [0, 1].as_mut_slice());
         assert_eq!(img_buf.tail().len(), 2);
         let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [0, 1].as_slice());
+        assert_eq!(tail.len(), 2);
+        let (used, tail) = img_buf.get_split_mut();
         assert_eq!(used, [0, 1].as_mut_slice());
         assert_eq!(tail.len(), 2);
 
         // SAFETY:
         // All data in img_buf is initialized since it was created from vec
         unsafe { img_buf.advance_used(2).unwrap() };
-        assert_eq!(img_buf.used(), [0, 1, 2, 3].as_mut_slice());
+        assert_eq!(img_buf.used(), [0, 1, 2, 3].as_slice());
+        assert_eq!(img_buf.used_mut(), [0, 1, 2, 3].as_mut_slice());
         assert_eq!(img_buf.tail().len(), 0);
         let (used, tail) = img_buf.get_split();
+        assert_eq!(used, [0, 1, 2, 3].as_slice());
+        assert_eq!(tail.len(), 0);
+        let (used, tail) = img_buf.get_split_mut();
         assert_eq!(used, [0, 1, 2, 3].as_mut_slice());
         assert_eq!(tail.len(), 0);
     }
+
+    #[test]
+    fn test_image_buffer_eq_not_init() {
+        assert_eq!(
+            ImageBufferVec::new(vec![0u8, 1, 2]).get(),
+            ImageBufferVec::new(vec![0u8, 1, 2]).get()
+        );
+    }
+
+    #[test]
+    fn test_image_buffer_eq_init_same() {
+        let mut v1 = ImageBufferVec::new(vec![0u8, 1, 2]);
+        let mut v2 = ImageBufferVec::new(vec![0u8, 1, 2]);
+        let mut image_buffer_1 = v1.get();
+        let mut image_buffer_2 = v2.get();
+
+        // SAFETY:
+        // Buffers initialised on creation.
+        unsafe {
+            image_buffer_1.advance_used(3).unwrap();
+            image_buffer_2.advance_used(3).unwrap();
+        }
+
+        assert_eq!(image_buffer_1, image_buffer_2);
+    }
+
+    #[test]
+    fn test_image_buffer_eq_diff_capacity() {
+        let mut v1 = ImageBufferVec::new(vec![0u8, 1, 2]);
+        let mut v2 = ImageBufferVec::new(vec![0u8, 1, 2, 3]);
+        let mut image_buffer_1 = v1.get();
+        let mut image_buffer_2 = v2.get();
+
+        // SAFETY:
+        // Buffers initialised on creation.
+        unsafe {
+            image_buffer_1.advance_used(2).unwrap();
+            image_buffer_2.advance_used(2).unwrap();
+        }
+
+        assert_eq!(image_buffer_1, image_buffer_2);
+    }
 }
diff --git a/gbl/libgbl/src/lib.rs b/gbl/libgbl/src/lib.rs
index 236a426..88d7f26 100644
--- a/gbl/libgbl/src/lib.rs
+++ b/gbl/libgbl/src/lib.rs
@@ -19,17 +19,17 @@
 //! The intended users of this library are firmware, bootloader, and bring-up teams at OEMs and SOC
 //! Vendors
 //!
-//! # Features
-//! * `alloc` - enables AVB ops related logic that relies on allocation and depends on allocation.
+//! This library is `no_std` as it is intended for use in bootloaders that typically will not
+//! support the Rust standard library. However, it does require `alloc` with a global allocator,
+//! currently used for:
+//! * libavb
+//! * kernel decompression
 
-// This code is intended for use in bootloaders that typically will not support
-// the Rust standard library
 #![cfg_attr(not(any(test, android_dylib)), no_std)]
 // TODO: b/312610985 - return warning for unused partitions
-#![allow(unused_variables, dead_code)]
 #![allow(async_fn_in_trait)]
-#![feature(associated_type_defaults)]
-// TODO: b/312608163 - Adding ZBI library usage to check dependencies
+// Needed for MaybeUninit::fill() experimental API
+#![feature(maybe_uninit_fill)]
 extern crate avb;
 extern crate core;
 extern crate gbl_storage;
@@ -38,21 +38,28 @@ extern crate zbi;
 
 use avb::{HashtreeErrorMode, SlotVerifyData, SlotVerifyError, SlotVerifyFlags};
 use core::ffi::CStr;
+use core::marker::PhantomData;
 
+pub mod android_boot;
 pub mod boot_mode;
 pub mod boot_reason;
+pub mod constants;
+pub mod decompress;
+pub mod device_tree;
 pub mod error;
 pub mod fastboot;
 pub mod fuchsia_boot;
-mod image_buffer;
+pub mod gbl_avb;
 pub mod ops;
-mod overlap;
 pub mod partition;
 
 /// The 'slots' module, containing types and traits for
 /// querying and modifying slotted boot behavior.
 pub mod slots;
 
+mod image_buffer;
+mod overlap;
+
 use slots::{BootTarget, BootToken, Cursor, OneShot, SuffixBytes, UnbootableReason};
 
 pub use avb::Descriptor;
@@ -60,7 +67,7 @@ pub use boot_mode::BootMode;
 pub use boot_reason::KnownBootReason;
 pub use error::{IntegrationError, Result};
 use liberror::Error;
-pub use ops::{AndroidBootImages, BootImages, FuchsiaBootImages, GblOps};
+pub use ops::{GblOps, Os};
 
 use overlap::is_overlap;
 
@@ -79,12 +86,10 @@ pub struct PartitionRamMap<'b, 'c> {
     /// Optional memory region to load partitions.
     /// If it's not provided default values will be used.
     pub address: Option<&'c mut [u8]>,
-
-    loaded: bool,
-    verified: bool,
 }
 
 /// Boot Image in memory
+#[allow(dead_code)]
 pub struct BootImage<'a>(&'a mut [u8]);
 
 /// Vendor Boot Image in memory
@@ -94,19 +99,21 @@ pub struct VendorBootImage<'a>(&'a mut [u8]);
 pub struct InitBootImage<'a>(&'a mut [u8]);
 
 /// Kernel Image in memory
+#[allow(dead_code)]
 pub struct KernelImage<'a>(&'a mut [u8]);
 
 /// Ramdisk in memory
 pub struct Ramdisk<'a>(&'a mut [u8]);
 /// Bootconfig in memory
+#[allow(dead_code)]
 pub struct Bootconfig<'a>(&'a mut [u8]);
 /// DTB in memory
+#[allow(dead_code)]
 pub struct Dtb<'a>(&'a mut [u8]);
 
 /// Create Boot Image from corresponding partition for `partitions_ram_map` and `avb_descriptors`
 /// lists
 pub fn get_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<BootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -121,7 +128,6 @@ pub fn get_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 /// Create Vendor Boot Image from corresponding partition for `partitions_ram_map` and
 /// `avb_descriptors` lists
 pub fn get_vendor_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<VendorBootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -135,7 +141,6 @@ pub fn get_vendor_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 
 /// Create Init Boot Image from corresponding partition for `partitions` and `avb_descriptors` lists
 pub fn get_init_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (Option<InitBootImage<'c>>, &'a mut [PartitionRamMap<'b, 'c>]) {
     match partitions_ram_map.len() {
@@ -149,7 +154,6 @@ pub fn get_init_boot_image<'a: 'b, 'b: 'c, 'c, 'd>(
 
 /// Create separate image types from [avb::Descriptor]
 pub fn get_images<'a: 'b, 'b: 'c, 'c, 'd>(
-    verified_data: &mut SlotVerifyData<'d>,
     partitions_ram_map: &'a mut [PartitionRamMap<'b, 'c>],
 ) -> (
     Option<BootImage<'c>>,
@@ -157,33 +161,34 @@ pub fn get_images<'a: 'b, 'b: 'c, 'c, 'd>(
     Option<VendorBootImage<'c>>,
     &'a mut [PartitionRamMap<'b, 'c>],
 ) {
-    let (boot_image, partitions_ram_map) = get_boot_image(verified_data, partitions_ram_map);
-    let (init_boot_image, partitions_ram_map) =
-        get_init_boot_image(verified_data, partitions_ram_map);
-    let (vendor_boot_image, partitions_ram_map) =
-        get_vendor_boot_image(verified_data, partitions_ram_map);
+    let (boot_image, partitions_ram_map) = get_boot_image(partitions_ram_map);
+    let (init_boot_image, partitions_ram_map) = get_init_boot_image(partitions_ram_map);
+    let (vendor_boot_image, partitions_ram_map) = get_vendor_boot_image(partitions_ram_map);
     (boot_image, init_boot_image, vendor_boot_image, partitions_ram_map)
 }
 
 /// GBL object that provides implementation of helpers for boot process.
-pub struct Gbl<'a, G>
+pub struct Gbl<'a, 'd, G>
 where
-    G: GblOps<'a>,
+    G: GblOps<'a, 'd>,
 {
     ops: &'a mut G,
     boot_token: Option<BootToken>,
+    _get_image_buffer_lifetime: PhantomData<&'d ()>,
 }
 
-impl<'a, G> Gbl<'a, G>
+// TODO(b/312610985): Investigate whether to deprecate this and remove this allow.
+#[allow(unused_variables)]
+impl<'a, 'f, G> Gbl<'a, 'f, G>
 where
-    G: GblOps<'a>,
+    G: GblOps<'a, 'f>,
 {
     /// Returns a new [Gbl] object.
     ///
     /// # Arguments
     /// * `ops` - the [GblOps] callbacks to use
     pub fn new(ops: &'a mut G) -> Self {
-        Self { ops, boot_token: Some(BootToken(())) }
+        Self { ops, boot_token: Some(BootToken(())), _get_image_buffer_lifetime: PhantomData }
     }
 
     /// Verify + Load Image Into memory
@@ -230,12 +235,12 @@ where
     ///
     /// * `Ok(Cursor)` - Cursor object that manages a Manager
     /// * `Err(Error)` - on failure
-    pub fn load_slot_interface<B: gbl_storage::AsBlockDevice>(
+    pub fn load_slot_interface(
         &'a mut self,
-        block_device: &'a mut B,
-    ) -> Result<Cursor<'a, B>> {
+        persist: &'a mut dyn FnMut(&mut [u8]) -> core::result::Result<(), Error>,
+    ) -> Result<Cursor<'a>> {
         let boot_token = self.boot_token.take().ok_or(Error::OperationProhibited)?;
-        self.ops.load_slot_interface::<B>(block_device, boot_token)
+        self.ops.load_slot_interface(persist, boot_token)
     }
 
     /// Info Load
@@ -380,13 +385,13 @@ where
     /// * `Err(Error)` - on failure
     // Nevertype could be used here when it is stable https://github.com/serde-rs/serde/issues/812
     #[allow(clippy::too_many_arguments)]
-    pub fn load_verify_boot<'b: 'c, 'c, 'd: 'b, B: gbl_storage::AsBlockDevice>(
+    pub fn load_verify_boot<'b: 'c, 'c, 'd: 'b>(
         &mut self,
         avb_ops: &mut impl avb::Ops<'b>,
         partitions_to_verify: &[&CStr],
         partitions_ram_map: &'d mut [PartitionRamMap<'b, 'c>],
         slot_verify_flags: SlotVerifyFlags,
-        slot_cursor: Cursor<B>,
+        slot_cursor: Cursor,
         kernel_load_buffer: &mut [u8],
         ramdisk_load_buffer: &mut [u8],
         fdt: &mut [u8],
@@ -429,7 +434,7 @@ where
         false
     }
 
-    fn lvb_inner<'b: 'c, 'c, 'd: 'b, 'e, B: gbl_storage::AsBlockDevice>(
+    fn lvb_inner<'b: 'c, 'c, 'd: 'b, 'e>(
         &mut self,
         avb_ops: &mut impl avb::Ops<'b>,
         ramdisk: &mut Ramdisk,
@@ -437,25 +442,17 @@ where
         partitions_to_verify: &[&CStr],
         partitions_ram_map: &'d mut [PartitionRamMap<'b, 'c>],
         slot_verify_flags: SlotVerifyFlags,
-        mut slot_cursor: Cursor<B>,
+        slot_cursor: Cursor,
     ) -> Result<(KernelImage<'e>, BootToken)> {
-        let mut oneshot_status = slot_cursor.ctx.get_oneshot_status();
+        let oneshot_status = slot_cursor.ctx.get_oneshot_status();
         slot_cursor.ctx.clear_oneshot_status();
 
-        if oneshot_status == Some(OneShot::Bootloader) {
-            match self.ops.do_fastboot(&mut slot_cursor) {
-                Ok(_) => oneshot_status = slot_cursor.ctx.get_oneshot_status(),
-                Err(IntegrationError::UnificationError(Error::NotImplemented)) => (),
-                Err(e) => return Err(e),
-            }
-        }
-
         let boot_target = match oneshot_status {
             None | Some(OneShot::Bootloader) => slot_cursor.ctx.get_boot_target()?,
             Some(OneShot::Continue(recovery)) => BootTarget::Recovery(recovery),
         };
 
-        let mut verify_data = self
+        let verify_data = self
             .load_and_verify_image(
                 avb_ops,
                 partitions_to_verify,
@@ -482,8 +479,7 @@ where
                 e
             })?;
 
-        let (boot_image, init_boot_image, vendor_boot_image, _) =
-            get_images(&mut verify_data, partitions_ram_map);
+        let (boot_image, init_boot_image, vendor_boot_image, _) = get_images(partitions_ram_map);
         let boot_image = boot_image.ok_or(Error::MissingImage)?;
         let vendor_boot_image = vendor_boot_image.ok_or(Error::MissingImage)?;
         let init_boot_image = init_boot_image.ok_or(Error::MissingImage)?;
@@ -574,7 +570,7 @@ mod tests {
             public_key: testdata(TEST_PUBLIC_KEY_PATH),
             public_key_metadata: None,
         });
-        avb_ops.rollbacks.insert(TEST_VBMETA_ROLLBACK_LOCATION, 0);
+        avb_ops.rollbacks.insert(TEST_VBMETA_ROLLBACK_LOCATION, Ok(0));
         avb_ops.unlock_state = Ok(false);
 
         avb_ops
@@ -599,8 +595,8 @@ mod tests {
         avb_ops.cert_permanent_attributes_hash = Some(perm_attr_hash.try_into().unwrap());
 
         // Add the rollbacks for the cert keys.
-        avb_ops.rollbacks.insert(avb::CERT_PIK_VERSION_LOCATION, TEST_CERT_PIK_VERSION);
-        avb_ops.rollbacks.insert(avb::CERT_PSK_VERSION_LOCATION, TEST_CERT_PSK_VERSION);
+        avb_ops.rollbacks.insert(avb::CERT_PIK_VERSION_LOCATION, Ok(TEST_CERT_PIK_VERSION));
+        avb_ops.rollbacks.insert(avb::CERT_PSK_VERSION_LOCATION, Ok(TEST_CERT_PSK_VERSION));
 
         avb_ops
     }
diff --git a/gbl/libgbl/src/ops.rs b/gbl/libgbl/src/ops.rs
index f4a9a3c..f2e11be 100644
--- a/gbl/libgbl/src/ops.rs
+++ b/gbl/libgbl/src/ops.rs
@@ -13,56 +13,52 @@
 // limitations under the License.
 
 //! GblOps trait that defines GBL callbacks.
-//!
-#[cfg(feature = "alloc")]
-extern crate alloc;
 
 pub use crate::image_buffer::ImageBuffer;
 use crate::{
     error::Result as GblResult,
-    partition::{
-        check_part_unique, read_unique_partition, write_unique_partition, PartitionBlockDevice,
-    },
+    fuchsia_boot::GblAbrOps,
+    gbl_avb::state::{BootStateColor, KeyValidationStatus},
+    partition::{check_part_unique, read_unique_partition, write_unique_partition, GblDisk},
 };
-#[cfg(feature = "alloc")]
-use alloc::ffi::CString;
-use core::{fmt::Write, num::NonZeroUsize, result::Result};
+pub use abr::{set_one_shot_bootloader, set_one_shot_recovery, SlotIndex};
+use core::{ffi::CStr, fmt::Write, num::NonZeroUsize, ops::DerefMut, result::Result};
 use gbl_async::block_on;
-use gbl_storage::{BlockIoAsync, BlockIoNull};
+use gbl_storage::SliceMaybeUninit;
+use libutils::aligned_subslice;
 
 // Re-exports of types from other dependencies that appear in the APIs of this library.
 pub use avb::{
     CertPermanentAttributes, IoError as AvbIoError, IoResult as AvbIoResult, SHA256_DIGEST_SIZE,
 };
+pub use gbl_storage::{BlockIo, Disk, Gpt};
 use liberror::Error;
-pub use zbi::ZbiContainer;
+pub use slots::{Slot, SlotsMetadata};
+pub use zbi::{ZbiContainer, ZBI_ALIGNMENT_USIZE};
 
+use super::device_tree;
 use super::slots;
 
-/// `AndroidBootImages` contains references to loaded images for booting Android.
-pub struct AndroidBootImages<'a> {
-    /// Kernel image.
-    pub kernel: &'a mut [u8],
-    /// Ramdisk to pass to the kernel.
-    pub ramdisk: &'a mut [u8],
-    /// FDT To pass to the kernel.
-    pub fdt: &'a mut [u8],
+/// Target Type of OS to boot.
+#[derive(PartialEq, Debug, Copy, Clone)]
+pub enum Os {
+    /// Android
+    Android,
+    /// Fuchsia
+    Fuchsia,
 }
 
-/// `FuchsiaBootImages` contains references to loaded images for booting Zircon.
-pub struct FuchsiaBootImages<'a> {
-    /// Kernel image.
-    pub zbi_kernel: &'a mut [u8],
-    /// ZBI container with items to pass to the kernel.
-    pub zbi_items: &'a mut [u8],
-}
-
-/// Images required to boot the supported kernels.
-pub enum BootImages<'a> {
-    /// Android boot images.
-    Android(AndroidBootImages<'a>),
-    /// Fuchsia boot images.
-    Fuchsia(FuchsiaBootImages<'a>),
+/// Contains reboot reasons for instructing GBL to boot to different modes.
+#[derive(PartialEq, Debug, Copy, Clone)]
+pub enum RebootReason {
+    /// Normal boot.
+    Normal,
+    /// Bootloader Fastboot mode.
+    Bootloader,
+    /// Userspace Fastboot mode.
+    FastbootD,
+    /// Recovery mode.
+    Recovery,
 }
 
 // https://stackoverflow.com/questions/41081240/idiomatic-callbacks-in-rust
@@ -70,18 +66,10 @@ pub enum BootImages<'a> {
 //
 /* TODO: b/312612203 - needed callbacks:
 missing:
-- validate_public_key_for_partition: None,
 - key management => atx extension in callback =>  atx_ops: ptr::null_mut(), // support optional ATX.
 */
 /// Trait that defines callbacks that can be provided to Gbl.
-pub trait GblOps<'a>
-where
-    Self: 'a,
-{
-    /// Type that implements `BlockIoAsync` for the array of `PartitionBlockDevice` returned by]
-    /// `partitions()`.
-    type PartitionBlockIo: BlockIoAsync = BlockIoNull;
-
+pub trait GblOps<'a, 'd> {
     /// Gets a console for logging messages.
     fn console_out(&mut self) -> Option<&mut dyn Write>;
 
@@ -96,26 +84,62 @@ where
     /// should abort and enter Fastboot mode.
     fn should_stop_in_fastboot(&mut self) -> Result<bool, Error>;
 
-    /// Platform specific processing of boot images before booting.
-    fn preboot(&mut self, boot_images: BootImages) -> Result<(), Error>;
+    /// Reboots the system into the last set boot mode.
+    ///
+    /// The method is not expected to return. Errors should be handled internally by the
+    /// implementation. In most cases, implementation should continue to reset even in the presence
+    /// of errors (users can force power cycle anyway). If there are error cases where reboot
+    /// absolutely can't be taken, implementation should hang and notify platform user in its own
+    /// way.
+    fn reboot(&mut self);
+
+    /// Reboots into recovery mode
+    ///
+    /// On success, returns a closure that performs the reboot.
+    fn reboot_recovery(&mut self) -> Result<impl FnOnce() + '_, Error> {
+        if self.expected_os_is_fuchsia()? {
+            // TODO(b/363075013): Checks and prioritizes platform specific `set_boot_reason()`.
+            set_one_shot_recovery(&mut GblAbrOps(self), true)?;
+            return Ok(|| self.reboot());
+        }
+        Err(Error::Unsupported)
+    }
+
+    /// Reboots into bootloader fastboot mode
+    ///
+    /// On success, returns a closure that performs the reboot.
+    fn reboot_bootloader(&mut self) -> Result<impl FnOnce() + '_, Error> {
+        if self.expected_os_is_fuchsia()? {
+            // TODO(b/363075013): Checks and prioritizes platform specific `set_boot_reason()`.
+            set_one_shot_bootloader(&mut GblAbrOps(self), true)?;
+            return Ok(|| self.reboot());
+        }
+        Err(Error::Unsupported)
+    }
 
-    /// Returns the list of partition block devices.
+    /// Returns the list of disk devices on this platform.
     ///
     /// Notes that the return slice doesn't capture the life time of `&self`, meaning that the slice
-    /// reference must be producible without borrowing the `GblOps`. This is intended and necessary
-    /// in order to parallelize fastboot flash, download and other commands. For implementation,
-    /// this typically means that the `GblOps` object should hold a reference of the array instead
-    /// of owning it.
-    fn partitions(&self) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>], Error>;
+    /// reference must be producible without borrowing `Self`. This is intended and necessary to
+    /// make disk IO and the rest of GblOps methods independent and parallelizable, which is
+    /// required for features such as parallell fastboot flash, download and other commands. For
+    /// implementation, this typically means that the `GblOps` object should hold a reference of the
+    /// array instead of owning it.
+    fn disks(
+        &self,
+    ) -> &'a [GblDisk<
+        Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
+        Gpt<impl DerefMut<Target = [u8]> + 'a>,
+    >];
 
     /// Reads data from a partition.
     async fn read_from_partition(
         &mut self,
         part: &str,
         off: u64,
-        out: &mut [u8],
+        out: &mut (impl SliceMaybeUninit + ?Sized),
     ) -> Result<(), Error> {
-        read_unique_partition(self.partitions()?, part, off, out).await
+        read_unique_partition(self.disks(), part, off, out).await
     }
 
     /// Reads data from a partition synchronously.
@@ -123,7 +147,7 @@ where
         &mut self,
         part: &str,
         off: u64,
-        out: &mut [u8],
+        out: &mut (impl SliceMaybeUninit + ?Sized),
     ) -> Result<(), Error> {
         block_on(self.read_from_partition(part, off, out))
     }
@@ -135,7 +159,7 @@ where
         off: u64,
         data: &mut [u8],
     ) -> Result<(), Error> {
-        write_unique_partition(self.partitions()?, part, off, data).await
+        write_unique_partition(self.disks(), part, off, data).await
     }
 
     /// Writes data to a partition synchronously.
@@ -150,19 +174,41 @@ where
 
     /// Returns the size of a partiiton. Returns Ok(None) if partition doesn't exist.
     fn partition_size(&mut self, part: &str) -> Result<Option<u64>, Error> {
-        match check_part_unique(self.partitions()?, part) {
+        match check_part_unique(self.disks(), part) {
             Ok((_, p)) => Ok(Some(p.size()?)),
             Err(Error::NotFound) => Ok(None),
             Err(e) => Err(e),
         }
     }
 
+    /// Returns which OS to load, or `None` to try to auto-detect based on disk layout & contents.
+    fn expected_os(&mut self) -> Result<Option<Os>, Error>;
+
+    /// Returns if the expected_os is fuchsia
+    fn expected_os_is_fuchsia(&mut self) -> Result<bool, Error> {
+        // TODO(b/374776896): Implement auto detection.
+        Ok(self.expected_os()?.map(|v| v == Os::Fuchsia).unwrap_or(false))
+    }
+
     /// Adds device specific ZBI items to the given `container`
     fn zircon_add_device_zbi_items(
         &mut self,
         container: &mut ZbiContainer<&mut [u8]>,
     ) -> Result<(), Error>;
 
+    /// Gets a buffer for staging bootloader file from fastboot.
+    ///
+    /// Fuchsia uses bootloader file for staging SSH key in development flow.
+    ///
+    /// Returns `None` if the platform does not intend to support it.
+    fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]>;
+
+    /// Gets the aligned part of buffer returned by `get_zbi_bootloader_files_buffer()` according to
+    /// ZBI alignment requirement.
+    fn get_zbi_bootloader_files_buffer_aligned(&mut self) -> Option<&mut [u8]> {
+        aligned_subslice(self.get_zbi_bootloader_files_buffer()?, ZBI_ALIGNMENT_USIZE).ok()
+    }
+
     // TODO(b/334962570): figure out how to plumb ops-provided hash implementations into
     // libavb. The tricky part is that libavb hashing APIs are global with no way to directly
     // correlate the implementation to a particular [GblOps] object, so we'll probably have to
@@ -171,19 +217,17 @@ where
     // reference to [GblOps], which may restrict implementations.
     // fn new_digest(&self) -> Option<Self::Context>;
 
-    /// Callback for when fastboot mode is requested.
-    // Nevertype could be used here when it is stable https://github.com/serde-rs/serde/issues/812
-    fn do_fastboot<B: gbl_storage::AsBlockDevice>(
-        &self,
-        cursor: &mut slots::Cursor<B>,
-    ) -> GblResult<()>;
-
     /// Load and initialize a slot manager and return a cursor over the manager on success.
-    fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+    ///
+    /// # Args
+    ///
+    /// * `persist`: A user provided closure for persisting a given slot metadata bytes to storage.
+    /// * `boot_token`: A [slots::BootToken].
+    fn load_slot_interface<'b>(
         &'b mut self,
-        block_device: &'b mut B,
+        persist: &'b mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
         boot_token: slots::BootToken,
-    ) -> GblResult<slots::Cursor<'b, B>>;
+    ) -> GblResult<slots::Cursor<'b>>;
 
     // The following is a selective subset of the interfaces in `avb::Ops` and `avb::CertOps` needed
     // by GBL's usage of AVB. The rest of the APIs are either not relevant to or are implemented and
@@ -197,17 +241,41 @@ where
     /// Reads the AVB rollback index at the given location
     ///
     /// The interface has the same requirement as `avb::Ops::read_rollback_index`.
-    fn avb_read_rollback_index(&mut self, _rollback_index_location: usize) -> AvbIoResult<u64>;
+    fn avb_read_rollback_index(&mut self, rollback_index_location: usize) -> AvbIoResult<u64>;
 
     /// Writes the AVB rollback index at the given location.
     ///
     /// The interface has the same requirement as `avb::Ops::write_rollback_index`.
     fn avb_write_rollback_index(
         &mut self,
-        _rollback_index_location: usize,
-        _index: u64,
+        rollback_index_location: usize,
+        index: u64,
     ) -> AvbIoResult<()>;
 
+    /// Reads the AVB persistent value for the given name.
+    ///
+    /// The interface has the same requirement as `avb::Ops::read_persistent_value`.
+    fn avb_read_persistent_value(&mut self, name: &CStr, value: &mut [u8]) -> AvbIoResult<usize>;
+
+    /// Writes the AVB persistent value for the given name.
+    ///
+    /// The interface has the same requirement as `avb::Ops::write_persistent_value`.
+    fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()>;
+
+    /// Erases the AVB persistent value for the given name.
+    ///
+    /// The interface has the same requirement as `avb::Ops::erase_persistent_value`.
+    fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()>;
+
+    /// Validate public key used to execute AVB.
+    ///
+    /// Used by `avb::CertOps::read_permanent_attributes_hash` so have similar requirements.
+    fn avb_validate_vbmeta_public_key(
+        &self,
+        public_key: &[u8],
+        public_key_metadata: Option<&[u8]>,
+    ) -> AvbIoResult<KeyValidationStatus>;
+
     /// Reads AVB certificate extension permanent attributes.
     ///
     /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes`.
@@ -221,12 +289,27 @@ where
     /// The interface has the same requirement as `avb::CertOps::read_permanent_attributes_hash`.
     fn avb_cert_read_permanent_attributes_hash(&mut self) -> AvbIoResult<[u8; SHA256_DIGEST_SIZE]>;
 
+    /// Handle AVB result.
+    ///
+    /// Set device state (rot / version binding), show UI, etc.
+    fn avb_handle_verification_result(
+        &mut self,
+        color: BootStateColor,
+        digest: Option<&CStr>,
+        boot_os_version: Option<&[u8]>,
+        boot_security_patch: Option<&[u8]>,
+        system_os_version: Option<&[u8]>,
+        system_security_patch: Option<&[u8]>,
+        vendor_os_version: Option<&[u8]>,
+        vendor_security_patch: Option<&[u8]>,
+    ) -> AvbIoResult<()>;
+
     /// Get buffer for specific image of requested size.
-    fn get_image_buffer<'c>(
+    fn get_image_buffer(
         &mut self,
         image_name: &str,
         size: NonZeroUsize,
-    ) -> GblResult<ImageBuffer<'c>>;
+    ) -> GblResult<ImageBuffer<'d>>;
 
     /// Returns the custom device tree to use, if any.
     ///
@@ -234,6 +317,111 @@ where
     /// currently needed for Cuttlefish, but should not be used in production devices because this
     /// data cannot be verified with libavb.
     fn get_custom_device_tree(&mut self) -> Option<&'a [u8]>;
+
+    /// Requests an OS command line to be used alongside the one built by GBL.
+    ///
+    /// The returned command line will be verified and appended on top of the command line
+    /// built by GBL. Refer to the behavior specified for the corresponding UEFI interface:
+    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
+    fn fixup_os_commandline<'c>(
+        &mut self,
+        commandline: &CStr,
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c str>, Error>;
+
+    /// Requests an OS bootconfig to be used alongside the one built by GBL.
+    ///
+    /// The returned bootconfig will be verified and appended on top of the bootconfig
+    /// built by GBL. Refer to the behavior specified for the corresponding UEFI interface:
+    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
+    fn fixup_bootconfig<'c>(
+        &mut self,
+        bootconfig: &[u8],
+        fixup_buffer: &'c mut [u8],
+    ) -> Result<Option<&'c [u8]>, Error>;
+
+    /// Selects from device tree components to build the final one.
+    ///
+    /// Provided components registry must be used to select one device tree (none is not allowed),
+    /// and any number of overlays. Refer to the behavior specified for the corresponding UEFI
+    /// interface:
+    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/gbl_os_configuration_protocol.md
+    fn select_device_trees(
+        &mut self,
+        components: &mut device_tree::DeviceTreeComponentsRegistry,
+    ) -> Result<(), Error>;
+
+    /// Provide writtable buffer of the device tree built by GBL.
+    ///
+    /// Modified device tree will be verified and used to boot a device. Refer to the behavior
+    /// specified for the corresponding UEFI interface:
+    /// https://cs.android.com/android/platform/superproject/main/+/main:bootable/libbootloader/gbl/docs/efi_protocols.md
+    /// https://github.com/U-Boot-EFI/EFI_DT_FIXUP_PROTOCOL
+    fn fixup_device_tree(&mut self, device_tree: &mut [u8]) -> Result<(), Error>;
+
+    /// Gets platform-specific fastboot variable.
+    ///
+    /// # Args
+    ///
+    /// * `name`: Varaiable name.
+    /// * `args`: Additional arguments.
+    /// * `out`: The output buffer for the value of the variable. Must be a ASCII string.
+    ///
+    /// # Returns
+    ///
+    /// * Returns the number of bytes written in `out` on success.
+    fn fastboot_variable<'arg>(
+        &mut self,
+        name: &CStr,
+        args: impl Iterator<Item = &'arg CStr> + Clone,
+        out: &mut [u8],
+    ) -> Result<usize, Error>;
+
+    /// Iterates all fastboot variables, arguments and values.
+    ///
+    /// # Args
+    ///
+    /// * `cb`: A closure that takes 1) an array of CStr that contains the variable name followed by
+    ///   any additional arguments and 2) a CStr representing the value.
+    fn fastboot_visit_all_variables(
+        &mut self,
+        cb: impl FnMut(&[&CStr], &CStr),
+    ) -> Result<(), Error>;
+
+    /// Returns a [SlotsMetadata] for the platform.
+    fn slots_metadata(&mut self) -> Result<SlotsMetadata, Error>;
+
+    /// Gets the currently booted bootloader slot.
+    ///
+    /// # Returns
+    ///
+    /// * Returns Ok(Some(slot index)) if bootloader is slotted.
+    /// * Returns Ok(Errorr::Unsupported) if bootloader is not slotted.
+    /// * Returns Err() on error.
+    fn get_current_slot(&mut self) -> Result<Slot, Error>;
+
+    /// Gets the slot for the next A/B decision.
+    ///
+    /// # Args
+    ///
+    /// * `mark_boot_attempt`: Passes true if the caller attempts to boot the returned slot and
+    ///   would like implementation to perform necessary update to the state of slot such as retry
+    ///   counter. Passes false if the caller only wants to query the slot decision and not cause
+    ///   any state change.
+    fn get_next_slot(&mut self, _mark_boot_attempt: bool) -> Result<Slot, Error>;
+
+    /// Sets the active slot for the next A/B decision.
+    ///
+    /// # Args
+    ///
+    /// * `slot`: The numeric index of the slot.
+    fn set_active_slot(&mut self, _slot: u8) -> Result<(), Error>;
+
+    /// Sets the reboot reason for the next reboot.
+    fn set_reboot_reason(&mut self, _reason: RebootReason) -> Result<(), Error>;
+
+    /// Gets the reboot reason for this boot.
+    fn get_reboot_reason(&mut self) -> Result<RebootReason, Error>;
 }
 
 /// Prints with `GblOps::console_out()`.
@@ -262,82 +450,78 @@ macro_rules! gbl_println {
 #[cfg(test)]
 pub(crate) mod test {
     use super::*;
-    use crate::partition::sync_gpt;
+    use crate::error::IntegrationError;
+    use crate::partition::GblDisk;
+    use abr::{get_and_clear_one_shot_bootloader, get_boot_slot};
     use avb::{CertOps, Ops};
     use avb_test::TestOps as AvbTestOps;
-    use gbl_storage_testlib::{TestBlockDevice, TestBlockDeviceBuilder, TestBlockIo};
-    use safemath::SafeNum;
+    use core::{
+        fmt::Write,
+        ops::{Deref, DerefMut},
+        str::from_utf8,
+    };
+    use fastboot::{snprintf, FormattedBytes};
+    use gbl_async::block_on;
+    use gbl_storage::{new_gpt_max, Disk, GptMax, RamBlockIo};
+    use std::{
+        collections::{HashMap, LinkedList},
+        ffi::CString,
+    };
     use zbi::{ZbiFlags, ZbiType};
 
+    /// Type of [GblDisk] in tests.
+    pub(crate) type TestGblDisk = GblDisk<Disk<RamBlockIo<Vec<u8>>, Vec<u8>>, GptMax>;
+
     /// Backing storage for [FakeGblOps].
     ///
     /// This needs to be a separate object because [GblOps] has designed its lifetimes to borrow
-    /// the [PartitionBlockDevice] objects rather than own it, so that they can outlive the ops
+    /// the [GblDisk] objects rather than own it, so that they can outlive the ops
     /// object when necessary.
     ///
     /// # Example usage
     /// ```
     /// let storage = FakeGblOpsStorage::default();
     /// storage.add_gpt_device(&gpt_disk_contents);
-    /// storage.add_raw_device("raw", &raw_disk_contents);
+    /// storage.add_raw_device(c"raw", &raw_disk_contents);
     ///
-    /// let partitions = storage.as_partition_block_devices();
-    /// let fake_ops = FakeGblOps(&partitions);
+    /// let fake_ops = FakeGblOps(&storage);
     /// ```
     #[derive(Default)]
-    pub(crate) struct FakeGblOpsStorage {
-        /// GPT block devices.
-        gpt_devices: Vec<TestBlockDevice>,
-        /// Raw partition block devices.
-        raw_devices: Vec<(&'static str, TestBlockDevice)>,
-    }
+    pub(crate) struct FakeGblOpsStorage(pub Vec<TestGblDisk>);
 
     impl FakeGblOpsStorage {
-        /// Adds a GPT block device.
-        pub fn add_gpt_device(&mut self, data: impl AsRef<[u8]>) {
-            self.gpt_devices.push(data.as_ref().into())
+        /// Adds a GPT disk.
+        pub(crate) fn add_gpt_device(&mut self, data: impl AsRef<[u8]>) {
+            // For test GPT images, all block sizes are 512.
+            self.0.push(TestGblDisk::new_gpt(
+                Disk::new_ram_alloc(512, 512, data.as_ref().to_vec()).unwrap(),
+                new_gpt_max(),
+            ));
+            let _ = block_on(self.0.last().unwrap().sync_gpt());
         }
 
-        /// Adds a raw partition block device.
-        pub fn add_raw_device(&mut self, name: &'static str, data: impl AsRef<[u8]>) {
-            self.raw_devices.push((name, data.as_ref().into()))
+        /// Adds a raw partition disk.
+        pub(crate) fn add_raw_device(&mut self, name: &CStr, data: impl AsRef<[u8]>) {
+            // For raw partition, use block_size=alignment=1 for simplicity.
+            TestGblDisk::new_raw(Disk::new_ram_alloc(1, 1, data.as_ref().to_vec()).unwrap(), name)
+                .and_then(|v| Ok(self.0.push(v)))
+                .unwrap()
         }
+    }
 
-        /// Similar to [add_raw_device] but pads `data` with zeros up to the next
-        /// [TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE].
-        pub(crate) fn add_raw_device_padded(&mut self, name: &'static str, mut data: Vec<u8>) {
-            let padded_size = SafeNum::from(data.len())
-                .round_up(TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE)
-                .try_into()
-                .unwrap();
-            data.resize(padded_size, 0);
-            self.add_raw_device(name, data);
-        }
+    impl Deref for FakeGblOpsStorage {
+        type Target = [TestGblDisk];
 
-        /// Returns a vector of [PartitionBlockDevice]s wrapping the added devices.
-        pub fn as_partition_block_devices(
-            &mut self,
-        ) -> Vec<PartitionBlockDevice<&mut TestBlockIo>> {
-            let mut parts = Vec::default();
-            // Convert GPT devices.
-            for device in self.gpt_devices.iter_mut() {
-                let (gpt_blk, gpt) = device.as_gpt_dev().into_blk_and_gpt();
-                parts.push(PartitionBlockDevice::new_gpt(gpt_blk, gpt));
-            }
-            // Convert raw devices.
-            for (name, device) in self.raw_devices.iter_mut() {
-                parts.push(PartitionBlockDevice::new_raw(device.as_blk_dev(), name).unwrap());
-            }
-            block_on(sync_gpt(&mut parts[..])).unwrap();
-            parts
+        fn deref(&self) -> &Self::Target {
+            &self.0[..]
         }
     }
 
     /// Fake [GblOps] implementation for testing.
     #[derive(Default)]
-    pub(crate) struct FakeGblOps<'a> {
+    pub(crate) struct FakeGblOps<'a, 'd> {
         /// Partition data to expose.
-        pub partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>],
+        pub partitions: &'a [TestGblDisk],
 
         /// Test fixture for [avb::Ops] and [avb::CertOps], provided by libavb.
         ///
@@ -345,23 +529,58 @@ pub(crate) mod test {
         /// is provided by `partitions` and our custom storage APIs rather than the [AvbTestOps]
         /// fake storage, so that we can more accurately test our storage implementation.
         pub avb_ops: AvbTestOps<'static>,
+
+        /// Value returned by `should_stop_in_fastboot`.
+        pub stop_in_fastboot: Option<Result<bool, Error>>,
+
+        /// For returned by `fn get_zbi_bootloader_files_buffer()`
+        pub zbi_bootloader_files_buffer: Vec<u8>,
+
+        /// For checking that `Self::reboot` is called.
+        pub rebooted: bool,
+
+        /// For return by `Self::expected_os()`
+        pub os: Option<Os>,
+
+        /// For return by `Self::avb_validate_vbmeta_public_key`
+        pub avb_key_validation_status: Option<AvbIoResult<KeyValidationStatus>>,
+
+        /// For return by `Self::get_image_buffer()`
+        pub image_buffers: HashMap<String, LinkedList<ImageBuffer<'d>>>,
     }
 
     /// Print `console_out` output, which can be useful for debugging.
-    impl Write for FakeGblOps<'_> {
+    impl<'a, 'd> Write for FakeGblOps<'a, 'd> {
         fn write_str(&mut self, s: &str) -> Result<(), std::fmt::Error> {
             Ok(print!("{s}"))
         }
     }
 
-    impl<'a> FakeGblOps<'a> {
+    impl<'a, 'd> FakeGblOps<'a, 'd> {
         /// For now we've just hardcoded the `zircon_add_device_zbi_items()` callback to add a
         /// single commandline ZBI item with these contents; if necessary we can generalize this
         /// later and allow tests to configure the ZBI modifications.
         pub const ADDED_ZBI_COMMANDLINE_CONTENTS: &'static [u8] = b"test_zbi_item";
+        pub const TEST_BOOTLOADER_FILE_1: &'static [u8] = b"\x06test_1foo";
+        pub const TEST_BOOTLOADER_FILE_2: &'static [u8] = b"\x06test_2bar";
+        pub const GBL_TEST_VAR: &'static str = "gbl-test-var";
+        pub const GBL_TEST_VAR_VAL: &'static str = "gbl-test-var-val";
+
+        pub fn new(partitions: &'a [TestGblDisk]) -> Self {
+            let mut res = Self {
+                partitions,
+                zbi_bootloader_files_buffer: vec![0u8; 32 * 1024],
+                ..Default::default()
+            };
+            let mut container =
+                ZbiContainer::new(res.get_zbi_bootloader_files_buffer_aligned().unwrap()).unwrap();
+            for ele in [Self::TEST_BOOTLOADER_FILE_1, Self::TEST_BOOTLOADER_FILE_2] {
+                container
+                    .create_entry_with_payload(ZbiType::BootloaderFile, 0, ZbiFlags::default(), ele)
+                    .unwrap();
+            }
 
-        pub fn new(partitions: &'a [PartitionBlockDevice<'a, &'a mut TestBlockIo>]) -> Self {
-            Self { partitions, ..Default::default() }
+            res
         }
 
         /// Copies an entire partition contents into a vector.
@@ -378,28 +597,30 @@ pub(crate) mod test {
         }
     }
 
-    impl<'a> GblOps<'a> for FakeGblOps<'a>
-    where
-        Self: 'a,
-    {
-        type PartitionBlockIo = &'a mut TestBlockIo;
-
+    impl<'a, 'd> GblOps<'a, 'd> for FakeGblOps<'a, 'd> {
         fn console_out(&mut self) -> Option<&mut dyn Write> {
             Some(self)
         }
 
         fn should_stop_in_fastboot(&mut self) -> Result<bool, Error> {
-            unimplemented!();
+            self.stop_in_fastboot.unwrap_or(Ok(false))
         }
 
-        fn preboot(&mut self, boot_images: BootImages) -> Result<(), Error> {
-            unimplemented!();
+        fn reboot(&mut self) {
+            self.rebooted = true;
         }
 
-        fn partitions(
+        fn disks(
             &self,
-        ) -> Result<&'a [PartitionBlockDevice<'a, Self::PartitionBlockIo>], Error> {
-            Ok(self.partitions)
+        ) -> &'a [GblDisk<
+            Disk<impl BlockIo + 'a, impl DerefMut<Target = [u8]> + 'a>,
+            Gpt<impl DerefMut<Target = [u8]> + 'a>,
+        >] {
+            self.partitions
+        }
+
+        fn expected_os(&mut self) -> Result<Option<Os>, Error> {
+            Ok(self.os)
         }
 
         fn zircon_add_device_zbi_items(
@@ -417,18 +638,15 @@ pub(crate) mod test {
             Ok(())
         }
 
-        fn do_fastboot<B: gbl_storage::AsBlockDevice>(
-            &self,
-            cursor: &mut slots::Cursor<B>,
-        ) -> GblResult<()> {
-            unimplemented!();
+        fn get_zbi_bootloader_files_buffer(&mut self) -> Option<&mut [u8]> {
+            Some(self.zbi_bootloader_files_buffer.as_mut_slice())
         }
 
-        fn load_slot_interface<'b, B: gbl_storage::AsBlockDevice>(
+        fn load_slot_interface<'b>(
             &'b mut self,
-            block_device: &'b mut B,
-            boot_token: slots::BootToken,
-        ) -> GblResult<slots::Cursor<'b, B>> {
+            _: &'b mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
+            _: slots::BootToken,
+        ) -> GblResult<slots::Cursor<'b>> {
             unimplemented!();
         }
 
@@ -448,6 +666,14 @@ pub(crate) mod test {
             self.avb_ops.write_rollback_index(rollback_index_location, index)
         }
 
+        fn avb_validate_vbmeta_public_key(
+            &self,
+            _public_key: &[u8],
+            _public_key_metadata: Option<&[u8]>,
+        ) -> AvbIoResult<KeyValidationStatus> {
+            self.avb_key_validation_status.clone().unwrap()
+        }
+
         fn avb_cert_read_permanent_attributes(
             &mut self,
             attributes: &mut CertPermanentAttributes,
@@ -461,16 +687,180 @@ pub(crate) mod test {
             self.avb_ops.read_permanent_attributes_hash()
         }
 
-        fn get_image_buffer<'c>(
+        fn avb_read_persistent_value(
             &mut self,
-            image_name: &str,
-            size: NonZeroUsize,
-        ) -> GblResult<ImageBuffer<'c>> {
+            name: &CStr,
+            value: &mut [u8],
+        ) -> AvbIoResult<usize> {
+            self.avb_ops.read_persistent_value(name, value)
+        }
+
+        fn avb_write_persistent_value(&mut self, name: &CStr, value: &[u8]) -> AvbIoResult<()> {
+            self.avb_ops.write_persistent_value(name, value)
+        }
+
+        fn avb_erase_persistent_value(&mut self, name: &CStr) -> AvbIoResult<()> {
+            self.avb_ops.erase_persistent_value(name)
+        }
+
+        fn avb_handle_verification_result(
+            &mut self,
+            _color: BootStateColor,
+            _digest: Option<&CStr>,
+            _boot_os_version: Option<&[u8]>,
+            _boot_security_patch: Option<&[u8]>,
+            _system_os_version: Option<&[u8]>,
+            _system_security_patch: Option<&[u8]>,
+            _vendor_os_version: Option<&[u8]>,
+            _vendor_security_patch: Option<&[u8]>,
+        ) -> AvbIoResult<()> {
             unimplemented!();
         }
 
+        fn get_image_buffer(
+            &mut self,
+            image_name: &str,
+            _size: NonZeroUsize,
+        ) -> GblResult<ImageBuffer<'d>> {
+            if let Some(buf_list) = self.image_buffers.get_mut(image_name) {
+                if let Some(buf) = buf_list.pop_front() {
+                    return Ok(buf);
+                };
+            };
+
+            gbl_println!(self, "FakeGblOps.get_image_buffer({image_name}) no buffer for the image");
+            Err(IntegrationError::UnificationError(Error::Other(Some(
+                "No buffer provided. Add sufficient buffers to FakeGblOps.image_buffers",
+            ))))
+        }
+
         fn get_custom_device_tree(&mut self) -> Option<&'static [u8]> {
             None
         }
+
+        fn fixup_os_commandline<'c>(
+            &mut self,
+            _commandline: &CStr,
+            _fixup_buffer: &'c mut [u8],
+        ) -> Result<Option<&'c str>, Error> {
+            unimplemented!();
+        }
+
+        fn fixup_bootconfig<'c>(
+            &mut self,
+            _bootconfig: &[u8],
+            _fixup_buffer: &'c mut [u8],
+        ) -> Result<Option<&'c [u8]>, Error> {
+            unimplemented!();
+        }
+
+        fn fixup_device_tree(&mut self, _: &mut [u8]) -> Result<(), Error> {
+            unimplemented!();
+        }
+
+        fn select_device_trees(
+            &mut self,
+            _: &mut device_tree::DeviceTreeComponentsRegistry,
+        ) -> Result<(), Error> {
+            unimplemented!();
+        }
+
+        fn fastboot_variable<'arg>(
+            &mut self,
+            name: &CStr,
+            mut args: impl Iterator<Item = &'arg CStr> + Clone,
+            out: &mut [u8],
+        ) -> Result<usize, Error> {
+            match name.to_str()? {
+                Self::GBL_TEST_VAR => {
+                    Ok(snprintf!(out, "{}:{:?}", Self::GBL_TEST_VAR_VAL, args.next()).len())
+                }
+                _ => Err(Error::NotFound),
+            }
+        }
+
+        fn fastboot_visit_all_variables(
+            &mut self,
+            mut cb: impl FnMut(&[&CStr], &CStr),
+        ) -> Result<(), Error> {
+            cb(
+                &[CString::new(Self::GBL_TEST_VAR).unwrap().as_c_str(), c"1"],
+                CString::new(format!("{}:1", Self::GBL_TEST_VAR_VAL)).unwrap().as_c_str(),
+            );
+            cb(
+                &[CString::new(Self::GBL_TEST_VAR).unwrap().as_c_str(), c"2"],
+                CString::new(format!("{}:2", Self::GBL_TEST_VAR_VAL)).unwrap().as_c_str(),
+            );
+            Ok(())
+        }
+
+        fn slots_metadata(&mut self) -> Result<SlotsMetadata, Error> {
+            unimplemented!();
+        }
+
+        fn get_current_slot(&mut self) -> Result<Slot, Error> {
+            unimplemented!()
+        }
+
+        fn get_next_slot(&mut self, _: bool) -> Result<Slot, Error> {
+            unimplemented!()
+        }
+
+        fn set_active_slot(&mut self, _: u8) -> Result<(), Error> {
+            unimplemented!()
+        }
+
+        fn set_reboot_reason(&mut self, _: RebootReason) -> Result<(), Error> {
+            unimplemented!()
+        }
+
+        fn get_reboot_reason(&mut self) -> Result<RebootReason, Error> {
+            unimplemented!()
+        }
+    }
+
+    #[test]
+    fn test_fuchsia_reboot_bootloader() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        (gbl_ops.reboot_bootloader().unwrap())();
+        assert!(gbl_ops.rebooted);
+        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(true));
+    }
+
+    #[test]
+    fn test_non_fuchsia_reboot_bootloader() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Android);
+        assert!(gbl_ops.reboot_bootloader().is_err_and(|e| e == Error::Unsupported));
+        assert_eq!(get_and_clear_one_shot_bootloader(&mut GblAbrOps(&mut gbl_ops)), Ok(false));
+    }
+
+    #[test]
+    fn test_fuchsia_reboot_recovery() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Fuchsia);
+        (gbl_ops.reboot_recovery().unwrap())();
+        assert!(gbl_ops.rebooted);
+        // One shot recovery is set.
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::R, false));
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
+    }
+
+    #[test]
+    fn test_non_fuchsia_reboot_recovery() {
+        let mut storage = FakeGblOpsStorage::default();
+        storage.add_raw_device(c"durable_boot", [0x00u8; 4 * 1024]);
+        let mut gbl_ops = FakeGblOps::new(&storage);
+        gbl_ops.os = Some(Os::Android);
+        assert!(gbl_ops.reboot_recovery().is_err_and(|e| e == Error::Unsupported));
+        // One shot recovery is not set.
+        assert_eq!(get_boot_slot(&mut GblAbrOps(&mut gbl_ops), true), (SlotIndex::A, false));
     }
 }
diff --git a/gbl/libgbl/src/partition.rs b/gbl/libgbl/src/partition.rs
index c411658..1e23dba 100644
--- a/gbl/libgbl/src/partition.rs
+++ b/gbl/libgbl/src/partition.rs
@@ -15,24 +15,51 @@
 //! This file implements storage and partition logic for libgbl.
 
 use crate::fastboot::sparse::{is_sparse_image, write_sparse_image, SparseRawWriter};
-use core::mem::swap;
-use fastboot::CommandError;
-use gbl_async::yield_now;
-use gbl_storage::{AsyncBlockDevice, BlockInfo, BlockIoAsync, GptCache, Partition as GptPartition};
+use core::cell::{RefCell, RefMut};
+use core::{
+    ffi::CStr,
+    mem::swap,
+    ops::{Deref, DerefMut},
+};
+use gbl_storage::{
+    BlockInfo, BlockIo, Disk, Gpt, GptBuilder, GptSyncResult, Partition as GptPartition,
+    SliceMaybeUninit,
+};
 use liberror::Error;
 use safemath::SafeNum;
-use spin::mutex::{Mutex, MutexGuard};
+
+/// Maximum name length for raw partition.
+const RAW_PARTITION_NAME_LEN: usize = 72;
+
+/// Wraps a bytes buffer containing a null-terminated C string
+#[derive(Copy, Clone, PartialEq, Debug)]
+pub struct RawName([u8; RAW_PARTITION_NAME_LEN]);
+
+impl RawName {
+    fn new(name: &CStr) -> Result<Self, Error> {
+        let mut buf = [0u8; RAW_PARTITION_NAME_LEN];
+        name.to_str().map_err(|_| Error::InvalidInput)?;
+        let name = name.to_bytes_with_nul();
+        buf.get_mut(..name.len()).ok_or(Error::InvalidInput)?.clone_from_slice(name);
+        Ok(Self(buf))
+    }
+
+    /// Decodes to a string.
+    pub fn to_str(&self) -> &str {
+        CStr::from_bytes_until_nul(&self.0[..]).unwrap().to_str().unwrap()
+    }
+}
 
 /// Represents a GBL partition.
 #[derive(Copy, Clone, PartialEq, Debug)]
-pub enum Partition<'a> {
+pub enum Partition {
     /// Raw storage partition.
-    Raw(&'a str, u64),
+    Raw(RawName, u64),
     /// Gpt Partition.
     Gpt(GptPartition),
 }
 
-impl Partition<'_> {
+impl Partition {
     /// Returns the size.
     pub fn size(&self) -> Result<u64, Error> {
         let (start, end) = self.absolute_range()?;
@@ -43,7 +70,7 @@ impl Partition<'_> {
     pub fn name(&self) -> Result<&str, Error> {
         Ok(match self {
             Partition::Gpt(gpt) => gpt.name().ok_or(Error::InvalidInput)?,
-            Partition::Raw(name, _) => name,
+            Partition::Raw(name, _) => name.to_str(),
         })
     }
 
@@ -58,30 +85,11 @@ impl Partition<'_> {
 
 /// Represents the partition table for a block device. It can either be a GPT partition table or a
 /// single whole device raw partition.
-enum PartitionTable<'a> {
-    Raw(&'a str, u64),
-    Gpt(GptCache<'a>),
-}
-
-/// Internal partition entry iterator type.
-enum PartitionIter<'a, G> {
-    /// Raw partition block device is simply a 1-partition device.
-    Raw(Option<Partition<'a>>),
-    /// Gpt partition block device holds a `GptPartition` iterator.
+enum PartitionTable<G> {
+    Raw(RawName, u64),
     Gpt(G),
 }
 
-impl<'a, G: Iterator<Item = GptPartition>> Iterator for PartitionIter<'a, G> {
-    type Item = Partition<'a>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        match self {
-            PartitionIter::Raw(part) => part.take(),
-            PartitionIter::Gpt(gpt) => gpt.next().map(|v| Partition::Gpt(v)),
-        }
-    }
-}
-
 /// The status of block device
 pub enum BlockStatus {
     /// Idle,
@@ -89,7 +97,7 @@ pub enum BlockStatus {
     /// An IO in progress.
     Pending,
     /// Error.
-    Error,
+    Error(Error),
 }
 
 impl BlockStatus {
@@ -98,35 +106,57 @@ impl BlockStatus {
         match self {
             BlockStatus::Idle => "idle",
             BlockStatus::Pending => "IO pending",
-            BlockStatus::Error => "error",
+            BlockStatus::Error(_) => "error",
+        }
+    }
+
+    /// Converts to result.
+    pub fn result(&self) -> Result<(), Error> {
+        match self {
+            Self::Error(e) => Err(*e),
+            _ => Ok(()),
         }
     }
 }
 
-/// Represents a block device that contains either GPT partitions or a single whole raw storage
+/// Represents a disk device that contains either GPT partitions or a single whole raw storage
 /// partition.
-pub struct PartitionBlockDevice<'a, B: BlockIoAsync> {
-    // Contains an `AsyncBlockDevice` for block IO and `Result` to track the most recent error.
+pub struct GblDisk<D, G> {
+    // Contains a `Disk` for block IO and `Result` to track the most recent error.
     // Wraps in `Mutex` as it will be used in parallel fastboot task.
-    blk: Mutex<(AsyncBlockDevice<'a, B>, Result<(), Error>)>,
-    partitions: PartitionTable<'a>,
+    //
+    // `blk` and `partitions` are wrapped in RefCell because they may be shared by multiple async
+    // blocks for operations such as parallel fastboot download/flashing. They are also wrapped
+    // separately in order to make operations on each independent and parallel for use cases such
+    // as getting partition info for `fastboot getvar` when disk IO is busy.
+    disk: RefCell<(D, Result<(), Error>)>,
+    partitions: RefCell<PartitionTable<G>>,
     info_cache: BlockInfo,
 }
 
-impl<'a, B: BlockIoAsync> PartitionBlockDevice<'a, B> {
+impl<B, S, T> GblDisk<Disk<B, S>, Gpt<T>>
+where
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    T: DerefMut<Target = [u8]>,
+{
     /// Creates a new instance as a GPT device.
-    pub fn new_gpt(mut blk: AsyncBlockDevice<'a, B>, gpt: GptCache<'a>) -> Self {
-        let info_cache = blk.io().info();
-        Self { blk: (blk, Ok(())).into(), info_cache, partitions: PartitionTable::Gpt(gpt) }
+    pub fn new_gpt(mut disk: Disk<B, S>, gpt: Gpt<T>) -> Self {
+        let info_cache = disk.io().info();
+        Self {
+            disk: (disk, Ok(())).into(),
+            info_cache,
+            partitions: PartitionTable::Gpt(gpt).into(),
+        }
     }
 
     /// Creates a new instance as a raw storage partition.
-    pub fn new_raw(mut blk: AsyncBlockDevice<'a, B>, name: &'a str) -> Result<Self, Error> {
-        let info_cache = blk.io().info();
+    pub fn new_raw(mut disk: Disk<B, S>, name: &CStr) -> Result<Self, Error> {
+        let info_cache = disk.io().info();
         Ok(Self {
-            blk: (blk, Ok(())).into(),
+            disk: (disk, Ok(())).into(),
             info_cache,
-            partitions: PartitionTable::Raw(name, info_cache.total_size()?),
+            partitions: PartitionTable::Raw(RawName::new(name)?, info_cache.total_size()?).into(),
         })
     }
 
@@ -137,58 +167,62 @@ impl<'a, B: BlockIoAsync> PartitionBlockDevice<'a, B> {
 
     /// Gets the block status.
     pub fn status(&self) -> BlockStatus {
-        match self.blk.try_lock() {
+        match self.disk.try_borrow_mut().ok() {
             None => BlockStatus::Pending,
-            Some(v) if v.1.is_err() => BlockStatus::Error,
+            Some(v) if v.1.is_err() => BlockStatus::Error(v.1.unwrap_err()),
             _ => BlockStatus::Idle,
         }
     }
 
+    /// Borrows disk and last_err separately
+    fn get_disk_and_last_err(
+        &self,
+    ) -> Result<(RefMut<'_, Disk<B, S>>, RefMut<'_, Result<(), Error>>), Error> {
+        let res = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
+        Ok(RefMut::map_split(res, |v| (&mut v.0, &mut v.1)))
+    }
+
     /// Gets an instance of `PartitionIo` for a partition.
     ///
     /// If `part` is `None`, an IO for the whole block device is returned.
-    pub fn partition_io(&self, part: Option<&str>) -> Result<PartitionIo<'a, '_, B>, Error> {
+    pub fn partition_io(&self, part: Option<&str>) -> Result<PartitionIo<'_, B>, Error> {
         let (part_start, part_end) = self.find_partition(part)?.absolute_range()?;
-        Ok(PartitionIo { blk: self.blk.try_lock().ok_or(Error::NotReady)?, part_start, part_end })
-    }
-
-    /// Same as `partition_io` except that the method will spin wait asynchronously if the IO is not
-    /// ready.
-    pub async fn wait_partition_io(
-        &self,
-        part: Option<&str>,
-    ) -> Result<PartitionIo<'a, '_, B>, Error> {
-        loop {
-            match self.partition_io(part) {
-                Err(Error::NotReady) => yield_now().await,
-                v => return v,
-            }
-        }
+        let (disk, last_err) = self.get_disk_and_last_err()?;
+        Ok(PartitionIo { disk: Disk::from_ref_mut(disk), last_err, part_start, part_end })
     }
 
     /// Finds a partition.
     ///
     /// * If `part` is none, the method returns an unnamed `Partition` that represents the whole
     //    raw storage.
-    pub fn find_partition(&self, part: Option<&str>) -> Result<Partition<'a>, Error> {
+    pub fn find_partition(&self, part: Option<&str>) -> Result<Partition, Error> {
         let Some(part) = part else {
-            return Ok(Partition::Raw("", self.info_cache.total_size()?));
+            return Ok(Partition::Raw(RawName::new(c"").unwrap(), self.info_cache.total_size()?));
         };
 
-        match &self.partitions {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
             PartitionTable::Gpt(gpt) => Ok(Partition::Gpt(gpt.find_partition(part)?)),
-            PartitionTable::Raw(name, size) if *name == part => Ok(Partition::Raw(name, *size)),
+            PartitionTable::Raw(name, size) if name.to_str() == part => {
+                Ok(Partition::Raw(*name, *size))
+            }
             _ => Err(Error::NotFound),
         }
     }
 
-    /// Gets an iterator to partition entries.
-    pub fn partition_iter(&self) -> impl Iterator<Item = Partition<'a>> + '_ {
-        match &self.partitions {
-            PartitionTable::Gpt(gpt) => PartitionIter::Gpt(gpt.partition_iter()),
-            PartitionTable::Raw(name, size) => {
-                PartitionIter::Raw(Some(Partition::Raw(name, *size)))
-            }
+    /// Get total number of partitions.
+    pub fn num_partitions(&self) -> Result<usize, Error> {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
+            PartitionTable::Raw(_, _) => Ok(1),
+            PartitionTable::Gpt(gpt) => gpt.num_partitions(),
+        }
+    }
+
+    /// Gets a partition by index.
+    pub fn get_partition_by_idx(&self, idx: usize) -> Result<Partition, Error> {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref() {
+            PartitionTable::Raw(name, v) if idx == 0 => Ok(Partition::Raw(*name, *v)),
+            PartitionTable::Gpt(gpt) => Ok(Partition::Gpt(gpt.get_partition(idx)?)),
+            _ => Err(Error::InvalidInput),
         }
     }
 
@@ -196,29 +230,88 @@ impl<'a, B: BlockIoAsync> PartitionBlockDevice<'a, B> {
     ///
     /// # Returns
     ///
-    /// * Returns `Ok(true)` if partition type is GPT and sync is successful.
-    /// * Returns `Ok(false)` if partition type is not GPT.
+    /// * Returns `Ok(Some(sync_res))` if partition type is GPT and disk access is successful, where
+    ///  `sync_res` contains the GPT verification and restoration result.
+    /// * Returns `Ok(None)` if partition type is not GPT.
     /// * Returns `Err` in other cases.
-    pub async fn sync_gpt(&mut self) -> Result<bool, Error> {
-        match &mut self.partitions {
-            PartitionTable::Raw(name, _) => Ok(false),
+    pub async fn sync_gpt(&self) -> Result<Option<GptSyncResult>, Error> {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
+            PartitionTable::Raw(_, _) => Ok(None),
+            PartitionTable::Gpt(ref mut gpt) => {
+                let mut blk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
+                Ok(Some(blk.0.sync_gpt(gpt).await?))
+            }
+        }
+    }
+
+    /// Updates GPT to the block device and sync primary and secondary GPT.
+    ///
+    /// # Args
+    ///
+    /// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
+    /// * `resize`: If set to true, the method updates the last partition to cover the rest of the
+    ///    storage.
+    ///
+    /// # Returns
+    ///
+    /// * Return `Err(Error::NotReady)` if device is busy.
+    /// * Return `Err(Error::Unsupported)` if partition type is not GPT.
+    /// * Return `Ok(())` new GPT is valid and device is updated and synced successfully.
+    pub async fn update_gpt(&self, mbr_primary: &mut [u8], resize: bool) -> Result<(), Error> {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
+            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
+            PartitionTable::Gpt(ref mut gpt) => {
+                let mut blk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
+                blk.0.update_gpt(mbr_primary, resize, gpt).await
+            }
+        }
+    }
+
+    /// Erases GPT on the disk.
+    ///
+    /// # Returns
+    ///
+    /// * Return `Err(Error::NotReady)` if device is busy.
+    /// * Return `Err(Error::Unsupported)` if partition type is not GPT.
+    pub async fn erase_gpt(&self) -> Result<(), Error> {
+        match self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?.deref_mut() {
+            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
             PartitionTable::Gpt(ref mut gpt) => {
-                let mut blk = self.blk.try_lock().ok_or(Error::NotReady)?;
-                blk.0.sync_gpt(gpt).await?;
-                Ok(true)
+                let mut disk = self.disk.try_borrow_mut().map_err(|_| Error::NotReady)?;
+                disk.0.erase_gpt(gpt).await
+            }
+        }
+    }
+
+    /// Creates an instance of GptBuilder.
+    pub fn gpt_builder(
+        &self,
+    ) -> Result<GptBuilder<RefMut<'_, Disk<B, S>>, RefMut<'_, Gpt<T>>>, Error> {
+        let mut parts = self.partitions.try_borrow_mut().map_err(|_| Error::NotReady)?;
+        match parts.deref_mut() {
+            PartitionTable::Raw(_, _) => Err(Error::Unsupported),
+            PartitionTable::Gpt(_) => {
+                let gpt = RefMut::map(parts, |v| match v {
+                    PartitionTable::Gpt(v) => v,
+                    _ => unreachable!(),
+                });
+                let (disk, err) = self.get_disk_and_last_err()?;
+                (*err)?;
+                Ok(GptBuilder::new(disk, gpt)?.0)
             }
         }
     }
 }
 
 /// `PartitionIo` provides read/write APIs to a partition.
-pub struct PartitionIo<'a, 'b, B: BlockIoAsync> {
-    blk: MutexGuard<'b, (AsyncBlockDevice<'a, B>, Result<(), Error>)>,
+pub struct PartitionIo<'a, B: BlockIo> {
+    disk: Disk<RefMut<'a, B>, RefMut<'a, [u8]>>,
+    last_err: RefMut<'a, Result<(), Error>>,
     part_start: u64,
     part_end: u64,
 }
 
-impl<'a, B: BlockIoAsync> PartitionIo<'a, '_, B> {
+impl<'a, B: BlockIo> PartitionIo<'a, B> {
     /// Returns the size of the partition.
     pub fn size(&self) -> u64 {
         // Corrects by construction. Should not fail.
@@ -226,8 +319,8 @@ impl<'a, B: BlockIoAsync> PartitionIo<'a, '_, B> {
     }
 
     /// Gets the block device.
-    pub fn dev(&mut self) -> &mut AsyncBlockDevice<'a, B> {
-        &mut self.blk.0
+    pub fn dev(&mut self) -> &mut Disk<RefMut<'a, B>, RefMut<'a, [u8]>> {
+        &mut self.disk
     }
 
     /// Checks the read/write parameters and returns the absolute offset in the block.
@@ -239,47 +332,41 @@ impl<'a, B: BlockIoAsync> PartitionIo<'a, '_, B> {
         Ok((SafeNum::from(self.part_start) + off).try_into()?)
     }
 
-    /// A helper to do write for simplifying error handling.
-    async fn do_write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
-        self.check_rw_range(off, data.len()).map(|v| self.blk.0.write(v, data))?.await
-    }
-
     /// Writes to the partition.
     pub async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
-        let res = self.do_write(off, data).await;
-        self.blk.1 = res.and(self.blk.1);
+        let res =
+            async { self.disk.write(self.check_rw_range(off, data.len())?, data).await }.await;
+        *self.last_err = res.and(*self.last_err);
         res
     }
 
-    /// A helper to do read for simplifying error handling.
-    async fn do_read(&mut self, off: u64, out: &mut [u8]) -> Result<(), Error> {
-        self.check_rw_range(off, out.len()).map(|v| self.blk.0.read(v, out))?.await
-    }
-
     /// Reads from the partition.
-    pub async fn read(&mut self, off: u64, out: &mut [u8]) -> Result<(), Error> {
-        let res = self.do_read(off, out).await;
-        self.blk.1 = res.and(self.blk.1);
+    pub async fn read(
+        &mut self,
+        off: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<(), Error> {
+        let res = async { self.disk.read(self.check_rw_range(off, out.len())?, out).await }.await;
+        *self.last_err = res.and(*self.last_err);
         res
     }
 
-    /// A helper to do sparse write for simplifying error handling.
-    async fn do_write_sparse(&mut self, off: u64, img: &mut [u8]) -> Result<(), Error> {
-        let off = self.check_rw_range(
-            off,
-            is_sparse_image(img).map_err(|_| Error::InvalidInput)?.data_size(),
-        )?;
-        write_sparse_image(img, &mut (off, &mut self.blk.0))
-            .await
-            .map_err(|_| "Sparse write failed")?;
-        Ok(())
+    /// Writes zeroes to the partition.
+    pub async fn zeroize(&mut self, scratch: &mut [u8]) -> Result<(), Error> {
+        let res = async { self.disk.fill(self.part_start, self.size(), 0, scratch).await }.await;
+        *self.last_err = res.and(*self.last_err);
+        *self.last_err
     }
 
     /// Writes sparse image to the partition.
     pub async fn write_sparse(&mut self, off: u64, img: &mut [u8]) -> Result<(), Error> {
-        let res = self.do_write_sparse(off, img).await;
-        self.blk.1 = res.and(self.blk.1);
-        res
+        let res = async {
+            let sz = is_sparse_image(img).map_err(|_| Error::InvalidInput)?.data_size();
+            write_sparse_image(img, &mut (self.check_rw_range(off, sz)?, &mut self.disk)).await
+        }
+        .await;
+        *self.last_err = res.map(|_| ()).and(*self.last_err);
+        *self.last_err
     }
 
     /// Turns this IO into one for a subrange in the partition.
@@ -293,20 +380,24 @@ impl<'a, B: BlockIoAsync> PartitionIo<'a, '_, B> {
 
     /// Returns the most recent error.
     pub fn last_err(&self) -> Result<(), Error> {
-        self.blk.1
+        *self.last_err
     }
 
     /// Takes the error and resets it.
     pub fn take_err(&mut self) -> Result<(), Error> {
         let mut err = Ok(());
-        swap(&mut self.blk.1, &mut err);
+        swap(&mut self.last_err as _, &mut err);
         err
     }
 }
 
 // Implements `SparseRawWriter` for tuple (<flash offset>, <block device>)
-impl<B: BlockIoAsync> SparseRawWriter for (u64, &mut AsyncBlockDevice<'_, B>) {
-    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), CommandError> {
+impl<B, S> SparseRawWriter for (u64, &mut Disk<B, S>)
+where
+    B: BlockIo,
+    S: DerefMut<Target = [u8]>,
+{
+    async fn write(&mut self, off: u64, data: &mut [u8]) -> Result<(), Error> {
         Ok(self.1.write((SafeNum::from(off) + self.0).try_into()?, data).await?)
     }
 }
@@ -314,10 +405,13 @@ impl<B: BlockIoAsync> SparseRawWriter for (u64, &mut AsyncBlockDevice<'_, B>) {
 /// Checks that a partition is unique.
 ///
 /// Returns a pair `(<block device index>, `Partition`)` if the partition exists and is unique.
-pub fn check_part_unique<'a>(
-    devs: &[PartitionBlockDevice<'a, impl BlockIoAsync>],
+pub fn check_part_unique(
+    devs: &'_ [GblDisk<
+        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+        Gpt<impl DerefMut<Target = [u8]>>,
+    >],
     part: &str,
-) -> Result<(usize, Partition<'a>), Error> {
+) -> Result<(usize, Partition), Error> {
     let mut filtered = devs
         .iter()
         .enumerate()
@@ -331,17 +425,23 @@ pub fn check_part_unique<'a>(
 
 /// Checks that a partition is unique among all block devices and reads from it.
 pub async fn read_unique_partition(
-    devs: &'_ [PartitionBlockDevice<'_, impl BlockIoAsync>],
+    devs: &'_ [GblDisk<
+        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+        Gpt<impl DerefMut<Target = [u8]>>,
+    >],
     part: &str,
     off: u64,
-    out: &mut [u8],
+    out: &mut (impl SliceMaybeUninit + ?Sized),
 ) -> Result<(), Error> {
     devs[check_part_unique(devs, part)?.0].partition_io(Some(part))?.read(off, out).await
 }
 
 /// Checks that a partition is unique among all block devices and writes to it.
 pub async fn write_unique_partition(
-    devs: &'_ [PartitionBlockDevice<'_, impl BlockIoAsync>],
+    devs: &'_ [GblDisk<
+        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+        Gpt<impl DerefMut<Target = [u8]>>,
+    >],
     part: &str,
     off: u64,
     data: &mut [u8],
@@ -351,9 +451,12 @@ pub async fn write_unique_partition(
 
 /// Syncs all GPT type partition devices.
 pub async fn sync_gpt(
-    devs: &'_ mut [PartitionBlockDevice<'_, impl BlockIoAsync>],
+    devs: &'_ [GblDisk<
+        Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+        Gpt<impl DerefMut<Target = [u8]>>,
+    >],
 ) -> Result<(), Error> {
-    for ele in &mut devs[..] {
+    for ele in &devs[..] {
         ele.sync_gpt().await?;
     }
     Ok(())
@@ -362,9 +465,9 @@ pub async fn sync_gpt(
 #[cfg(test)]
 pub(crate) mod test {
     use super::*;
+    use crate::ops::test::{FakeGblOpsStorage, TestGblDisk};
     use core::fmt::Debug;
     use gbl_async::block_on;
-    use gbl_storage_testlib::{TestBlockDevice, TestBlockIo};
 
     /// Absolute start/end offset and size of "boot_a/b" partitions in
     /// "../../libstorage/test/gpt_test_1.bin"
@@ -382,27 +485,24 @@ pub(crate) mod test {
         val.try_into().unwrap()
     }
 
-    /// A helper to convert a `TestBlockDevice` into a raw partition device.
-    pub fn as_raw_part<'a>(
-        test_blk: &'a mut TestBlockDevice,
-        name: &'a str,
-    ) -> PartitionBlockDevice<'a, &'a mut TestBlockIo> {
-        PartitionBlockDevice::new_raw(test_blk.as_blk_dev(), name).unwrap()
+    /// A helper to create a GPT type TestGblDisk
+    fn gpt_disk(data: impl AsRef<[u8]>) -> TestGblDisk {
+        let mut res = FakeGblOpsStorage::default();
+        res.add_gpt_device(data);
+        res.0.pop().unwrap()
     }
 
-    /// A helper to convert a `TestBlockDevice` into a gpt partition device.
-    pub fn as_gpt_part<'a>(
-        test_blk: &'a mut TestBlockDevice,
-    ) -> PartitionBlockDevice<'a, &'a mut TestBlockIo> {
-        let (gpt_blk, gpt) = test_blk.as_gpt_dev().into_blk_and_gpt();
-        PartitionBlockDevice::new_gpt(gpt_blk, gpt)
+    /// A helper to create a raw disk partition type TestGblDisk
+    fn raw_disk(name: &CStr, data: impl AsRef<[u8]>) -> TestGblDisk {
+        let mut res = FakeGblOpsStorage::default();
+        res.add_raw_device(name, data);
+        res.0.pop().unwrap()
     }
 
     #[test]
     fn test_find_partition_gpt() {
-        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
-        assert!(block_on(gpt.sync_gpt()).unwrap());
+        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
 
         let boot_a = gpt.find_partition(Some("boot_a")).unwrap();
         assert_eq!(boot_a.name().unwrap(), "boot_a");
@@ -425,8 +525,7 @@ pub(crate) mod test {
     #[test]
     fn test_find_partition_raw() {
         let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let mut raw = (&disk[..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", &disk);
 
         let raw_part = raw.find_partition(Some("raw")).unwrap();
         assert_eq!(raw_part.name().unwrap(), "raw");
@@ -445,29 +544,28 @@ pub(crate) mod test {
     ///
     /// Tests that the content read at `off..off+sz` is the same as `part_content[off..off+sz]`.
     fn test_part_read(
-        blk: &PartitionBlockDevice<impl BlockIoAsync>,
+        blk: &TestGblDisk,
         part: Option<&str>,
         part_content: &[u8],
         off: u64,
         sz: u64,
     ) {
         let mut out = vec![0u8; to_usize(sz)];
-        block_on(blk.partition_io(part).unwrap().read(off, &mut out)).unwrap();
+        block_on(blk.partition_io(part).unwrap().read(off, &mut out[..])).unwrap();
         assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
 
         // Reads using the `sub()` and then read approach.
         let mut out = vec![0u8; to_usize(sz)];
         let mut io = blk.partition_io(part).unwrap().sub(off, sz).unwrap();
-        block_on(io.read(0, &mut out)).unwrap();
+        block_on(io.read(0, &mut out[..])).unwrap();
         assert_eq!(out, part_content[to_usize(off)..][..out.len()].to_vec());
     }
 
     #[test]
     fn test_read_partition_gpt() {
         let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let mut gpt = (&disk[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
-        assert!(block_on(gpt.sync_gpt()).unwrap());
+        let gpt = gpt_disk(&disk[..]);
+        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
 
         let expect_boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
         test_part_read(&gpt, Some("boot_a"), expect_boot_a, 1, 1024);
@@ -480,22 +578,16 @@ pub(crate) mod test {
     #[test]
     fn test_read_partition_raw() {
         let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let mut raw = (&disk[..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", &disk);
         test_part_read(&raw, Some("raw"), disk, 1, 1024);
         test_part_read(&raw, None, disk, 1, 1024);
     }
 
     /// A helper for testing partition write.
-    fn test_part_write(
-        blk: &PartitionBlockDevice<impl BlockIoAsync>,
-        part: Option<&str>,
-        off: u64,
-        sz: u64,
-    ) {
+    fn test_part_write(blk: &TestGblDisk, part: Option<&str>, off: u64, sz: u64) {
         // Reads the current partition content
         let mut part_content = vec![0u8; to_usize(blk.partition_io(part).unwrap().size())];
-        block_on(blk.partition_io(part).unwrap().read(0, &mut part_content)).unwrap();
+        block_on(blk.partition_io(part).unwrap().read(0, &mut part_content[..])).unwrap();
 
         // Flips all the bits in the target range and writes back.
         let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
@@ -513,9 +605,8 @@ pub(crate) mod test {
 
     #[test]
     fn test_write_partition_gpt() {
-        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
-        assert!(block_on(gpt.sync_gpt()).unwrap());
+        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
         test_part_write(&gpt, Some("boot_a"), 1, 1024);
         test_part_write(&gpt, Some("boot_b"), 1, 1024);
         test_part_write(&gpt, None, 1, 1024);
@@ -523,8 +614,7 @@ pub(crate) mod test {
 
     #[test]
     fn test_write_partition_raw() {
-        let mut raw = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut raw = as_raw_part(&mut raw, "raw");
+        let mut raw = raw_disk(c"raw", include_bytes!("../../libstorage/test/gpt_test_1.bin"));
         test_part_write(&mut raw, Some("raw"), 1, 1024);
         test_part_write(&mut raw, None, 1, 1024);
     }
@@ -532,40 +622,36 @@ pub(crate) mod test {
     #[test]
     fn test_read_write_partition_overflow() {
         let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let mut gpt = (&disk[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
-        assert!(block_on(gpt.sync_gpt()).unwrap());
+        let gpt = gpt_disk(&disk[..]);
+        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
 
         let mut part_io = gpt.partition_io(Some("boot_a")).unwrap();
-        assert!(block_on(part_io.read(BOOT_A_END, &mut vec![0u8; 1])).is_err());
-        assert!(
-            block_on(part_io.read(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1])).is_err()
-        );
-        assert!(block_on(part_io.write(BOOT_A_END, &mut vec![0u8; 1])).is_err());
+        assert!(block_on(part_io.read(BOOT_A_END, &mut vec![0u8; 1][..])).is_err());
+        assert!(block_on(part_io.read(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1][..]))
+            .is_err());
+        assert!(block_on(part_io.write(BOOT_A_END, &mut vec![0u8; 1][..])).is_err());
+        assert!(block_on(part_io.write(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1][..]))
+            .is_err());
+
+        let raw = raw_disk(c"raw", &disk);
+        let mut part_io = raw.partition_io(Some("raw")).unwrap();
+        assert!(block_on(part_io.read(GPT_DISK_1_SZ, &mut vec![0u8; 1][..])).is_err());
+        assert!(block_on(part_io.read(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1][..])).is_err());
+        assert!(block_on(part_io.write(GPT_DISK_1_SZ, &mut vec![0u8; 1][..])).is_err());
         assert!(
-            block_on(part_io.write(BOOT_A_OFF, &mut vec![0u8; to_usize(BOOT_A_SZ) + 1])).is_err()
+            block_on(part_io.write(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1][..])).is_err()
         );
-
-        let mut raw = (&disk[..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
-        let mut part_io = raw.partition_io(Some("raw")).unwrap();
-        assert!(block_on(part_io.read(GPT_DISK_1_SZ, &mut vec![0u8; 1])).is_err());
-        assert!(block_on(part_io.read(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1])).is_err());
-        assert!(block_on(part_io.write(GPT_DISK_1_SZ, &mut vec![0u8; 1])).is_err());
-        assert!(block_on(part_io.write(0, &mut vec![0u8; to_usize(GPT_DISK_1_SZ) + 1])).is_err());
     }
 
     #[test]
     fn test_sub_overflow() {
         let disk = include_bytes!("../../libstorage/test/gpt_test_1.bin");
-        let mut gpt = (&disk[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
-        assert!(block_on(gpt.sync_gpt()).unwrap());
+        let gpt = gpt_disk(&disk[..]);
+        assert_eq!(block_on(gpt.sync_gpt()).unwrap(), Some(GptSyncResult::BothValid));
         assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(0, BOOT_A_SZ + 1).is_err());
         assert!(gpt.partition_io(Some("boot_a")).unwrap().sub(1, BOOT_A_SZ).is_err());
 
-        let mut raw = (&disk[..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", &disk);
         assert!(raw.partition_io(Some("raw")).unwrap().sub(0, GPT_DISK_1_SZ + 1).is_err());
         assert!(raw.partition_io(Some("raw")).unwrap().sub(1, GPT_DISK_1_SZ).is_err());
     }
@@ -575,8 +661,7 @@ pub(crate) mod test {
         let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
         let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
         let raw = &vec![0u8; sparse_raw.len() + 512][..];
-        let mut blk = raw.into();
-        let blk = as_raw_part(&mut blk, "raw");
+        let blk = raw_disk(c"raw", raw);
         block_on(
             blk.partition_io(Some("raw"))
                 .unwrap()
@@ -595,8 +680,7 @@ pub(crate) mod test {
         let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
         let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
         sparse[0] = !sparse[0]; // Corrupt image.
-        let mut raw = (&vec![0u8; sparse_raw.len() + 512][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", vec![0u8; sparse_raw.len() + 512]);
         assert!(
             block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
         );
@@ -607,8 +691,7 @@ pub(crate) mod test {
     fn test_write_sparse_overflow_size() {
         let sparse_raw = include_bytes!("../testdata/sparse_test_raw.bin");
         let mut sparse = include_bytes!("../testdata/sparse_test.bin").to_vec();
-        let mut raw = (&vec![0u8; sparse_raw.len()][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", vec![0u8; sparse_raw.len()]);
         assert!(
             block_on(raw.partition_io(Some("raw")).unwrap().write_sparse(1, &mut sparse)).is_err()
         );
@@ -617,18 +700,16 @@ pub(crate) mod test {
 
     #[test]
     fn test_partiton_last_err_read() {
-        let mut raw = (&vec![0u8; 1024][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", vec![0u8; 1024]);
         let mut part_io = raw.partition_io(Some("raw")).unwrap();
         // Causes some error by read
-        assert!(block_on(part_io.read(1024, &mut [0])).is_err());
+        assert!(block_on(part_io.read(1024, &mut [0][..])).is_err());
         assert!(part_io.last_err().is_err());
     }
 
     #[test]
     fn test_partiton_last_err_write() {
-        let mut raw = (&vec![0u8; 1024][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", vec![0u8; 1024]);
         let mut part_io = raw.partition_io(Some("raw")).unwrap();
         // Causes some error by write
         assert!(block_on(part_io.write(1024, &mut [0])).is_err());
@@ -637,17 +718,16 @@ pub(crate) mod test {
 
     #[test]
     fn test_partiton_last_err_persist_through_operation() {
-        let mut raw = (&vec![0u8; 1024][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
+        let raw = raw_disk(c"raw", vec![0u8; 1024]);
         // Causes some error by read
-        assert!(block_on(raw.partition_io(Some("raw")).unwrap().read(1024, &mut [0])).is_err());
+        assert!(block_on(raw.partition_io(Some("raw")).unwrap().read(1024, &mut [0][..])).is_err());
         // Tracked error should persist regardless of how many times we get partition io.
         assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
         assert!(raw.partition_io(None).unwrap().last_err().is_err());
         // Should persist even after successful operations.
-        block_on(raw.partition_io(Some("raw")).unwrap().read(1023, &mut [0])).unwrap();
+        block_on(raw.partition_io(Some("raw")).unwrap().read(1023, &mut [0][..])).unwrap();
         assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
-        block_on(raw.partition_io(Some("raw")).unwrap().write(1023, &mut [0])).unwrap();
+        block_on(raw.partition_io(Some("raw")).unwrap().write(1023, &mut [0][..])).unwrap();
         assert!(raw.partition_io(Some("raw")).unwrap().last_err().is_err());
         assert!(raw.partition_io(None).unwrap().last_err().is_err());
         // Taking error should reset it.
@@ -657,49 +737,42 @@ pub(crate) mod test {
 
     #[test]
     fn test_partition_iter() {
-        let mut raw = (&vec![0u8; 1024][..]).into();
-        let raw = as_raw_part(&mut raw, "raw");
-        assert_eq!(raw.partition_iter().collect::<Vec<_>>(), [Partition::Raw("raw", 1024)]);
+        let raw = raw_disk(c"raw", vec![0u8; 1024]);
+        assert_eq!(raw.num_partitions().unwrap(), 1);
+        assert_eq!(raw.get_partition_by_idx(0).unwrap().name(), Ok("raw"));
+        assert_eq!(raw.get_partition_by_idx(0).unwrap().size(), Ok(1024));
 
-        let mut gpt = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt = as_gpt_part(&mut gpt);
+        let gpt = gpt_disk(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
         block_on(gpt.sync_gpt()).unwrap();
-        let actual = gpt.partition_iter().collect::<Vec<_>>();
-        assert_eq!(actual.len(), 2);
-        assert_eq!(actual[0].name().unwrap(), "boot_a");
-        assert_eq!(actual[0].size().unwrap(), 0x2000);
-        assert_eq!(actual[1].name().unwrap(), "boot_b");
-        assert_eq!(actual[1].size().unwrap(), 0x3000);
+        assert_eq!(gpt.num_partitions().unwrap(), 2);
+        assert_eq!(gpt.get_partition_by_idx(0).unwrap().name().unwrap(), "boot_a");
+        assert_eq!(gpt.get_partition_by_idx(0).unwrap().size().unwrap(), 0x2000);
+        assert_eq!(gpt.get_partition_by_idx(1).unwrap().name().unwrap(), "boot_b");
+        assert_eq!(gpt.get_partition_by_idx(1).unwrap().size().unwrap(), 0x3000);
     }
 
     /// A test helper for `read_unique_partition`
     /// It verifies that data read from partition `part` at offset `off` is the same as
     /// `part_content[off..off+sz]`.
     fn check_read_partition(
-        devs: &[PartitionBlockDevice<impl BlockIoAsync>],
+        devs: &[TestGblDisk],
         part: &str,
         part_content: &[u8],
         off: u64,
         sz: u64,
     ) {
         let mut out = vec![0u8; to_usize(sz)];
-        block_on(read_unique_partition(devs, part, off, &mut out)).unwrap();
+        block_on(read_unique_partition(devs, part, off, &mut out[..])).unwrap();
         assert_eq!(out, part_content[to_usize(off)..][..out.len()]);
     }
 
     #[test]
     fn test_read_unique_partition() {
-        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_2.bin")[..]).into();
-        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
-        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
-        let mut devs = vec![
-            as_gpt_part(&mut gpt_0),
-            as_gpt_part(&mut gpt_1),
-            as_raw_part(&mut raw_0, "raw_0"),
-            as_raw_part(&mut raw_1, "raw_1"),
-        ];
-        block_on(sync_gpt(&mut devs)).unwrap();
+        let mut devs = FakeGblOpsStorage::default();
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_2.bin"));
+        devs.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        devs.add_raw_device(c"raw_1", [0x55u8; 4 * 1024]);
 
         let boot_a = include_bytes!("../../libstorage/test/boot_a.bin");
         let boot_b = include_bytes!("../../libstorage/test/boot_b.bin");
@@ -720,16 +793,11 @@ pub(crate) mod test {
     }
 
     /// A test helper for `write_unique_partition`
-    fn check_write_partition(
-        devs: &[PartitionBlockDevice<impl BlockIoAsync>],
-        part: &str,
-        off: u64,
-        sz: u64,
-    ) {
+    fn check_write_partition(devs: &[TestGblDisk], part: &str, off: u64, sz: u64) {
         // Reads the current partition content
         let (_, p) = check_part_unique(devs, part).unwrap();
         let mut part_content = vec![0u8; to_usize(p.size().unwrap())];
-        block_on(read_unique_partition(devs, part, 0, &mut part_content)).unwrap();
+        block_on(read_unique_partition(devs, part, 0, &mut part_content[..])).unwrap();
 
         // Flips all the bits in the target range and writes back.
         let seg = &mut part_content[to_usize(off)..][..to_usize(sz)];
@@ -741,17 +809,11 @@ pub(crate) mod test {
 
     #[test]
     fn test_write_unique_partition() {
-        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_2.bin")[..]).into();
-        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
-        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
-        let mut devs = vec![
-            as_gpt_part(&mut gpt_0),
-            as_gpt_part(&mut gpt_1),
-            as_raw_part(&mut raw_0, "raw_0"),
-            as_raw_part(&mut raw_1, "raw_1"),
-        ];
-        block_on(sync_gpt(&mut devs)).unwrap();
+        let mut devs = FakeGblOpsStorage::default();
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_2.bin"));
+        devs.add_raw_device(c"raw_0", [0xaau8; 4 * 1024]);
+        devs.add_raw_device(c"raw_1", [0x55u8; 4 * 1024]);
 
         let off = 512u64;
         let sz = 1024u64;
@@ -765,20 +827,15 @@ pub(crate) mod test {
 
     #[test]
     fn test_rw_fail_with_non_unique_partition() {
-        let mut gpt_0 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut gpt_1 = (&include_bytes!("../../libstorage/test/gpt_test_1.bin")[..]).into();
-        let mut raw_0 = [0xaau8; 4 * 1024].as_slice().into();
-        let mut raw_1 = [0x55u8; 4 * 1024].as_slice().into();
-        let mut devs = vec![
-            as_gpt_part(&mut gpt_0),
-            as_gpt_part(&mut gpt_1),
-            as_raw_part(&mut raw_0, "raw"),
-            as_raw_part(&mut raw_1, "raw"),
-        ];
-        block_on(sync_gpt(&mut devs)).unwrap();
-        assert!(block_on(read_unique_partition(&devs, "boot_a", 0, &mut [],)).is_err());
+        let mut devs = FakeGblOpsStorage::default();
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        devs.add_gpt_device(include_bytes!("../../libstorage/test/gpt_test_1.bin"));
+        devs.add_raw_device(c"raw", [0xaau8; 4 * 1024]);
+        devs.add_raw_device(c"raw", [0x55u8; 4 * 1024]);
+
+        assert!(block_on(read_unique_partition(&devs, "boot_a", 0, &mut [] as &mut [u8],)).is_err());
         assert!(block_on(write_unique_partition(&devs, "boot_a", 0, &mut [],)).is_err());
-        assert!(block_on(read_unique_partition(&devs, "raw", 0, &mut [],)).is_err());
+        assert!(block_on(read_unique_partition(&devs, "raw", 0, &mut [] as &mut [u8],)).is_err());
         assert!(block_on(write_unique_partition(&devs, "raw", 0, &mut [],)).is_err());
     }
 }
diff --git a/gbl/libgbl/src/slots.rs b/gbl/libgbl/src/slots.rs
index c88f380..b96ba13 100644
--- a/gbl/libgbl/src/slots.rs
+++ b/gbl/libgbl/src/slots.rs
@@ -405,24 +405,30 @@ pub trait Manager: private::SlotGet {
     /// This is useful for partition based slot setups,
     /// where we do not write back every interaction in order to coalesce writes
     /// and preserve disk lifetime.
-    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {}
+    fn write_back(&mut self, _: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {}
 }
 
 /// RAII helper object for coalescing changes.
-pub struct Cursor<'a, B: gbl_storage::AsBlockDevice> {
+pub struct Cursor<'a> {
     /// The backing manager for slot metadata.
     pub ctx: &'a mut dyn Manager,
-    /// The backing disk. Used for partition-backed metadata implementations
-    /// and for fastboot.
-    pub block_dev: &'a mut B,
+    /// User provided closure for persisting slot metadata bytes.
+    pub persist: &'a mut dyn FnMut(&mut [u8]) -> Result<(), Error>,
 }
 
-impl<'a, B: gbl_storage::AsBlockDevice> Drop for Cursor<'a, B> {
+impl Drop for Cursor<'_> {
     fn drop(&mut self) {
-        self.ctx.write_back(&mut self.block_dev);
+        self.ctx.write_back(&mut self.persist);
     }
 }
 
+/// Contains information of the platform's slot scheme.
+#[derive(Default, Debug, Copy, Clone)]
+pub struct SlotsMetadata {
+    /// Number of slots on this platform.
+    pub slot_count: usize,
+}
+
 #[cfg(test)]
 mod test {
     use super::*;
diff --git a/gbl/libgbl/src/slots/android.rs b/gbl/libgbl/src/slots/android.rs
index d70faa1..2ce536a 100644
--- a/gbl/libgbl/src/slots/android.rs
+++ b/gbl/libgbl/src/slots/android.rs
@@ -71,6 +71,8 @@ const DEFAULT_RETRIES: u8 = 7;
 #[derive(Copy, Clone, Debug, PartialEq, Eq, AsBytes, FromBytes, FromZeroes)]
 struct SlotMetaData(u16);
 
+#[allow(dead_code)]
+#[allow(missing_docs)]
 impl SlotMetaData {
     const PRIORITY_MASK: u16 = 0b1111;
     const PRIORITY_OFFSET: u16 = 0;
@@ -136,6 +138,8 @@ impl Default for SlotMetaData {
 #[repr(C, packed)]
 struct ControlBits(u16);
 
+#[allow(dead_code)]
+#[allow(missing_docs)]
 impl ControlBits {
     const NB_SLOT_MASK: u16 = 0b111;
     const NB_SLOT_OFFSET: u16 = 0;
@@ -261,7 +265,7 @@ impl MetadataBytes for BootloaderControl {
     }
 }
 
-impl super::private::SlotGet for SlotBlock<'_, BootloaderControl> {
+impl super::private::SlotGet for SlotBlock<BootloaderControl> {
     fn get_slot_by_number(&self, number: usize) -> Result<Slot, Error> {
         let lower_ascii_suffixes = ('a'..='z').map(Suffix);
         let control = self.get_data();
@@ -281,7 +285,7 @@ impl super::private::SlotGet for SlotBlock<'_, BootloaderControl> {
     }
 }
 
-impl Manager for SlotBlock<'_, BootloaderControl> {
+impl Manager for SlotBlock<BootloaderControl> {
     fn slots_iter(&self) -> SlotIterator {
         SlotIterator::new(self)
     }
@@ -376,8 +380,8 @@ impl Manager for SlotBlock<'_, BootloaderControl> {
 
     fn clear_oneshot_status(&mut self) {}
 
-    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
-        self.sync_to_disk(block_dev)
+    fn write_back(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
+        self.sync_to_disk(persist)
     }
 }
 
diff --git a/gbl/libgbl/src/slots/fuchsia.rs b/gbl/libgbl/src/slots/fuchsia.rs
index 9325120..b9e2236 100644
--- a/gbl/libgbl/src/slots/fuchsia.rs
+++ b/gbl/libgbl/src/slots/fuchsia.rs
@@ -160,7 +160,7 @@ impl Default for AbrData {
     }
 }
 
-impl super::private::SlotGet for SlotBlock<'_, AbrData> {
+impl super::private::SlotGet for SlotBlock<AbrData> {
     fn get_slot_by_number(&self, number: usize) -> Result<Slot, Error> {
         let lower_ascii_suffixes = ('a'..='z').map(Suffix);
         let (suffix, &abr_slot) = zip(lower_ascii_suffixes, self.get_data().slot_data.iter())
@@ -177,7 +177,7 @@ impl super::private::SlotGet for SlotBlock<'_, AbrData> {
     }
 }
 
-impl Manager for SlotBlock<'_, AbrData> {
+impl Manager for SlotBlock<AbrData> {
     fn get_boot_target(&self) -> Result<BootTarget, Error> {
         Ok(self
             .slots_iter()
@@ -283,12 +283,12 @@ impl Manager for SlotBlock<'_, AbrData> {
         }
     }
 
-    fn write_back(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
-        self.sync_to_disk(block_dev);
+    fn write_back(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
+        self.sync_to_disk(persist);
     }
 }
 
-impl<'a> SlotBlock<'a, AbrData> {
+impl<'a> SlotBlock<AbrData> {
     fn get_index_and_slot_with_suffix(&self, slot_suffix: Suffix) -> Result<(usize, Slot), Error> {
         self.slots_iter()
             .enumerate()
@@ -301,8 +301,8 @@ impl<'a> SlotBlock<'a, AbrData> {
 mod test {
     use super::*;
     use crate::slots::{partition::CacheStatus, Cursor};
-    use gbl_storage::AsBlockDevice;
-    use gbl_storage_testlib::TestBlockDevice;
+    use gbl_async::block_on;
+    use gbl_storage::{new_gpt_max, Disk, RamBlockIo};
 
     #[test]
     fn test_slot_block_defaults() {
@@ -433,7 +433,6 @@ mod test {
     #[test]
     fn test_slot_mark_tried_recovery() {
         let mut sb: SlotBlock<AbrData> = Default::default();
-        let recovery_tgt = BootTarget::Recovery(RecoveryTarget::Dedicated);
         assert!(sb.set_slot_unbootable('a'.into(), UnbootableReason::UserRequested).is_ok());
         assert!(sb.set_slot_unbootable('b'.into(), UnbootableReason::UserRequested).is_ok());
         assert_eq!(sb.mark_boot_attempt(), Ok(BootToken(())));
@@ -578,12 +577,7 @@ mod test {
         // and lets us verify that the deserialized slot block
         // uses defaulted backing bytes instead of the provided bytes.
         abr_data.slot_data[0].successful = 1;
-        let sb = SlotBlock::<AbrData>::deserialize(
-            abr_data.as_bytes(),
-            "partition_moniker",
-            0,
-            BootToken(()),
-        );
+        let sb = SlotBlock::<AbrData>::deserialize(abr_data.as_bytes(), BootToken(()));
         assert_eq!(sb.cache_status(), CacheStatus::Dirty);
         assert_eq!(
             sb.slots_iter().next().unwrap().bootability,
@@ -599,32 +593,30 @@ mod test {
         // that just means we have a metadata block that stores
         // relevant, non-default information.
         abr_data.crc32.set(abr_data.calculate_crc32());
-        let sb = SlotBlock::<AbrData>::deserialize(
-            abr_data.as_bytes(),
-            "partition_moniker",
-            0,
-            BootToken(()),
-        );
+        let sb = SlotBlock::<AbrData>::deserialize(abr_data.as_bytes(), BootToken(()));
         assert_eq!(sb.cache_status(), CacheStatus::Clean);
         assert_eq!(sb.slots_iter().next().unwrap().bootability, Bootability::Successful);
     }
 
+    type TestDisk = Disk<RamBlockIo<Vec<u8>>, Vec<u8>>;
+
     #[test]
     fn test_writeback() {
         const PARTITION: &str = "test_partition";
         const OFFSET: u64 = 2112; // Deliberately wrong to test propagation of parameter.
-        let mut block_dev: TestBlockDevice =
-            include_bytes!("../../testdata/writeback_test_disk.bin").as_slice().into();
-        assert!(block_dev.sync_gpt().is_ok());
+        let disk = include_bytes!("../../testdata/writeback_test_disk.bin").to_vec();
+        let mut blk = TestDisk::new_ram_alloc(512, 512, disk).unwrap();
+        let mut gpt = new_gpt_max();
+        block_on(blk.sync_gpt(&mut gpt)).unwrap();
         let mut sb: SlotBlock<AbrData> = Default::default();
-        sb.partition = PARTITION;
-        sb.partition_offset = OFFSET;
-
         let mut read_buffer: [u8; size_of::<AbrData>()] = Default::default();
 
         // Clean cache, write_back is a no-op
-        sb.write_back(&mut block_dev);
-        let res = block_dev.read_gpt_partition(PARTITION, OFFSET, &mut read_buffer);
+        sb.write_back(&mut |data: &mut [u8]| {
+            Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
+        });
+        let res =
+            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
         assert!(res.is_ok());
         assert_eq!(read_buffer, [0; std::mem::size_of::<AbrData>()]);
 
@@ -633,8 +625,11 @@ mod test {
         assert_eq!(sb.set_oneshot_status(OneShot::Bootloader), Ok(()));
         assert_eq!(sb.cache_status(), CacheStatus::Dirty);
 
-        sb.write_back(&mut block_dev);
-        let res = block_dev.read_gpt_partition(PARTITION, OFFSET, &mut read_buffer);
+        sb.write_back(&mut |data: &mut [u8]| {
+            Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
+        });
+        let res =
+            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
         assert!(res.is_ok());
         assert_eq!(read_buffer, sb.get_data().as_bytes());
         assert_eq!(sb.cache_status(), CacheStatus::Clean);
@@ -644,22 +639,25 @@ mod test {
     fn test_writeback_with_cursor() {
         const PARTITION: &str = "test_partition";
         const OFFSET: u64 = 2112; // Deliberately wrong to test propagation of parameter.
-        let mut block_dev: TestBlockDevice =
-            include_bytes!("../../testdata/writeback_test_disk.bin").as_slice().into();
-        assert!(block_dev.sync_gpt().is_ok());
+        let disk = include_bytes!("../../testdata/writeback_test_disk.bin").to_vec();
+        let mut blk = TestDisk::new_ram_alloc(512, 512, disk).unwrap();
+        let mut gpt = new_gpt_max();
+        block_on(blk.sync_gpt(&mut gpt)).unwrap();
         let mut read_buffer: [u8; size_of::<AbrData>()] = Default::default();
 
         let mut sb: SlotBlock<AbrData> = Default::default();
-        sb.partition = PARTITION;
-        sb.partition_offset = OFFSET;
 
         // New block to trigger drop on the cursor.
         {
-            let cursor = Cursor { ctx: &mut sb, block_dev: &mut block_dev };
+            let mut persist = |data: &mut [u8]| {
+                Ok(block_on(blk.write_gpt_partition(&mut gpt, PARTITION, OFFSET, data))?)
+            };
+            let cursor = Cursor { ctx: &mut sb, persist: &mut persist };
             assert!(cursor.ctx.set_active_slot('b'.into()).is_ok());
         }
 
-        let res = block_dev.read_gpt_partition(PARTITION, OFFSET, &mut read_buffer);
+        let res =
+            block_on(blk.read_gpt_partition(&mut gpt, PARTITION, OFFSET, &mut read_buffer[..]));
         assert!(res.is_ok());
         assert_eq!(read_buffer, sb.get_data().as_bytes());
     }
diff --git a/gbl/libgbl/src/slots/partition.rs b/gbl/libgbl/src/slots/partition.rs
index d10d8fa..931c942 100644
--- a/gbl/libgbl/src/slots/partition.rs
+++ b/gbl/libgbl/src/slots/partition.rs
@@ -44,12 +44,7 @@ pub trait MetadataBytes: Copy + AsBytes + FromBytes + FromZeroes + Default {
 }
 
 /// Generalized description of a partition-backed ABR metadata structure.
-pub struct SlotBlock<'a, MB: MetadataBytes> {
-    /// The partition the metadata was read from and will be written back to.
-    pub partition: &'a str,
-    /// The offset from the beginning of the partition in bytes.
-    pub partition_offset: u64,
-
+pub struct SlotBlock<MB: MetadataBytes> {
     // Internally tracked cache clean/dirty info
     cache_status: CacheStatus,
     // SlotBlock holds the boot token until mark_boot_attempt gets called.
@@ -58,8 +53,8 @@ pub struct SlotBlock<'a, MB: MetadataBytes> {
     data: MB,
 }
 
-impl<'a, MB: MetadataBytes> SlotBlock<'a, MB> {
-    /// Note to those implementing Manager for SlotBlock<'_, CustomType>:
+impl<'a, MB: MetadataBytes> SlotBlock<MB> {
+    /// Note to those implementing Manager for SlotBlock<CustomType>:
     /// Be very, very careful with custody of the boot token.
     /// If you release it outside of the implementation of Manager::mark_boot_attempt,
     /// mark_boot_attempt will fail and the kernel may boot without tracking the attempt.
@@ -94,12 +89,7 @@ impl<'a, MB: MetadataBytes> SlotBlock<'a, MB> {
     ///                 if there was an internal error.
     ///
     ///                 TODO(b/329116902): errors are logged
-    pub fn deserialize<B: ByteSlice>(
-        buffer: B,
-        partition: &'a str,
-        partition_offset: u64,
-        boot_token: BootToken,
-    ) -> Self {
+    pub fn deserialize<B: ByteSlice>(buffer: B, boot_token: BootToken) -> Self {
         // TODO(b/329116902): log failures
         // validate(buffer)
         // .inspect_err(|e| {
@@ -110,27 +100,28 @@ impl<'a, MB: MetadataBytes> SlotBlock<'a, MB> {
             Err(_) => (Default::default(), CacheStatus::Dirty),
         };
 
-        SlotBlock { cache_status, boot_token: Some(boot_token), data, partition, partition_offset }
+        SlotBlock { cache_status, boot_token: Some(boot_token), data }
     }
 
     /// Write back slot metadata to disk.
-    /// The MetadataBytes type should reestablish any invariants when
-    /// `prepare_for_sync` is called, e.g. recalculating checksums.
+    ///
+    /// The MetadataBytes type should reestablish any invariants when `prepare_for_sync` is called,
+    /// e.g. recalculating checksums.
     ///
     /// Does NOT write back to disk if no changes have been made and the cache is clean.
     /// Panics if the write attempt fails.
-    pub fn sync_to_disk(&mut self, block_dev: &mut dyn gbl_storage::AsBlockDevice) {
+    ///
+    /// # Args
+    ///
+    /// * `persist`: A user provided closure for persisting a given slot metadata bytes to storage.
+    pub fn sync_to_disk(&mut self, persist: &mut dyn FnMut(&mut [u8]) -> Result<(), Error>) {
         if self.cache_status == CacheStatus::Clean {
             return;
         }
 
         self.data.prepare_for_sync();
 
-        match block_dev.write_gpt_partition(
-            self.partition,
-            self.partition_offset,
-            self.get_mut_data().as_bytes_mut(),
-        ) {
+        match persist(self.get_mut_data().as_bytes_mut()) {
             Ok(_) => self.cache_status = CacheStatus::Clean,
             Err(e) => panic!("{}", e),
         };
@@ -138,13 +129,11 @@ impl<'a, MB: MetadataBytes> SlotBlock<'a, MB> {
 }
 
 #[cfg(test)]
-impl<MB: MetadataBytes> Default for SlotBlock<'_, MB> {
+impl<MB: MetadataBytes> Default for SlotBlock<MB> {
     /// Returns a default valued SlotBlock.
     /// Only used in tests because BootToken cannot be constructed out of crate.
     fn default() -> Self {
         Self {
-            partition: "",
-            partition_offset: 0,
             cache_status: CacheStatus::Clean,
             boot_token: Some(BootToken(())),
             data: Default::default(),
diff --git a/gbl/libstorage/BUILD b/gbl/libstorage/BUILD
index bffb4a4..02ff0b9 100644
--- a/gbl/libstorage/BUILD
+++ b/gbl/libstorage/BUILD
@@ -25,6 +25,7 @@ rust_library(
         "src/algorithm.rs",
         "src/gpt.rs",
         "src/lib.rs",
+        "src/ram_block.rs",
     ],
     crate_name = "gbl_storage",
     edition = "2021",
@@ -34,24 +35,7 @@ rust_library(
         "@gbl//libasync",
         "@gbl//liberror",
         "@gbl//libsafemath",
-        "@zerocopy",
-    ],
-)
-
-rust_library(
-    name = "libstorage_testlib",
-    srcs = [
-        "src/testlib.rs",
-    ],
-    crate_name = "gbl_storage_testlib",
-    edition = "2021",
-    rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libstorage",
-        "@crc32fast",
-        "@gbl//libasync",
-        "@gbl//liberror",
-        "@gbl//libsafemath",
+        "@gbl//libutils",
         "@zerocopy",
     ],
 )
@@ -61,15 +45,6 @@ rust_test(
     compile_data = ["@gbl//libstorage/test:test_data"],
     crate = ":libstorage",
     rustc_flags = ANDROID_RUST_LINTS,
-    deps = [
-        ":libstorage_testlib",
-    ],
-)
-
-rust_test(
-    name = "libstorage_testlib_test",
-    crate = ":libstorage_testlib",
-    rustc_flags = ANDROID_RUST_LINTS,
 )
 
 rust_doc_test(
diff --git a/gbl/libstorage/src/algorithm.rs b/gbl/libstorage/src/algorithm.rs
index 79834ee..bff273e 100644
--- a/gbl/libstorage/src/algorithm.rs
+++ b/gbl/libstorage/src/algorithm.rs
@@ -13,17 +13,20 @@
 // limitations under the License.
 
 use crate::{
-    aligned_subslice, check_range, is_aligned, is_buffer_aligned, BlockInfo, BlockIoAsync,
-    BlockIoSync,
+    as_uninit, check_range, is_aligned, is_buffer_aligned, BlockInfo, BlockIo, SliceMaybeUninit,
 };
 use core::cmp::min;
-use gbl_async::block_on;
 use liberror::Result;
+use libutils::aligned_subslice;
 use safemath::SafeNum;
 
 /// Reads from a range at block boundary to an aligned buffer.
-async fn read_aligned_all(io: &mut impl BlockIoAsync, offset: u64, out: &mut [u8]) -> Result<()> {
-    let blk_offset = check_range(io.info(), offset, out)?.try_into()?;
+async fn read_aligned_all(
+    io: &mut impl BlockIo,
+    offset: u64,
+    out: &mut (impl SliceMaybeUninit + ?Sized),
+) -> Result<()> {
+    let blk_offset = check_range(io.info(), offset, out.as_ref())?.try_into()?;
     Ok(io.read_blocks(blk_offset, out).await?)
 }
 
@@ -31,21 +34,21 @@ async fn read_aligned_all(io: &mut impl BlockIoAsync, offset: u64, out: &mut [u8
 ///   |~~~~~~~~~read~~~~~~~~~|
 ///   |---------|---------|---------|
 async fn read_aligned_offset_and_buffer(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
-    out: &mut [u8],
+    out: &mut (impl SliceMaybeUninit + ?Sized),
     scratch: &mut [u8],
 ) -> Result<()> {
     let block_size = SafeNum::from(io.info().block_size);
-    debug_assert!(is_aligned(offset.into(), block_size)?);
-    debug_assert!(is_buffer_aligned(out, io.info().alignment)?);
+    debug_assert!(is_aligned(offset, block_size)?);
+    debug_assert!(is_buffer_aligned(out.as_ref(), io.info().alignment)?);
 
     let aligned_read: usize = SafeNum::from(out.len()).round_down(block_size).try_into()?;
 
     if aligned_read > 0 {
-        read_aligned_all(io, offset, &mut out[..aligned_read]).await?;
+        read_aligned_all(io, offset, out.get_mut(..aligned_read)?).await?;
     }
-    let unaligned = &mut out[aligned_read..];
+    let unaligned = out.get_mut(aligned_read..)?;
     if unaligned.is_empty() {
         return Ok(());
     }
@@ -53,7 +56,7 @@ async fn read_aligned_offset_and_buffer(
     let block_scratch = &mut scratch[..block_size.try_into()?];
     let aligned_offset = SafeNum::from(offset) + aligned_read;
     read_aligned_all(io, aligned_offset.try_into()?, block_scratch).await?;
-    unaligned.clone_from_slice(&block_scratch[..unaligned.len()]);
+    unaligned.clone_from_slice(as_uninit(&block_scratch[..unaligned.len()]));
     Ok(())
 }
 
@@ -65,14 +68,14 @@ async fn read_aligned_offset_and_buffer(
 ///          |~~~read~~~|
 ///        |---------------|--------------|
 async fn read_aligned_buffer(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
-    out: &mut [u8],
+    out: &mut (impl SliceMaybeUninit + ?Sized),
     scratch: &mut [u8],
 ) -> Result<()> {
-    debug_assert!(is_buffer_aligned(out, io.info().alignment)?);
+    debug_assert!(is_buffer_aligned(out.as_ref(), io.info().alignment)?);
 
-    if is_aligned(offset.into(), io.info().block_size.into())? {
+    if is_aligned(offset, io.info().block_size)? {
         return read_aligned_offset_and_buffer(io, offset, out, scratch).await;
     }
     let offset = SafeNum::from(offset);
@@ -81,12 +84,12 @@ async fn read_aligned_buffer(
 
     let aligned_relative_offset: usize = (SafeNum::from(aligned_start) - offset).try_into()?;
     if aligned_relative_offset < out.len() {
-        if is_buffer_aligned(&out[aligned_relative_offset..], io.info().alignment)? {
+        if is_buffer_aligned(&out.get(aligned_relative_offset..)?, io.info().alignment)? {
             // If new output address is aligned, read directly.
             read_aligned_offset_and_buffer(
                 io,
                 aligned_start,
-                &mut out[aligned_relative_offset..],
+                out.get_mut(aligned_relative_offset..)?,
                 scratch,
             )
             .await?;
@@ -95,9 +98,9 @@ async fn read_aligned_buffer(
             // position
             let read_len: usize =
                 (SafeNum::from(out.len()) - aligned_relative_offset).try_into()?;
-            read_aligned_offset_and_buffer(io, aligned_start, &mut out[..read_len], scratch)
+            read_aligned_offset_and_buffer(io, aligned_start, out.get_mut(..read_len)?, scratch)
                 .await?;
-            out.copy_within(..read_len, aligned_relative_offset);
+            out.as_mut().copy_within(..read_len, aligned_relative_offset);
         }
     }
 
@@ -106,11 +109,11 @@ async fn read_aligned_buffer(
     let round_down_offset = offset.round_down(io.info().block_size);
     read_aligned_all(io, round_down_offset.try_into()?, block_scratch).await?;
     let offset_relative = offset - round_down_offset;
-    let unaligned = &mut out[..aligned_relative_offset];
-    unaligned.clone_from_slice(
+    let unaligned = out.get_mut(..aligned_relative_offset)?;
+    unaligned.clone_from_slice(as_uninit(
         &block_scratch
             [offset_relative.try_into()?..(offset_relative + unaligned.len()).try_into()?],
-    );
+    ));
     Ok(())
 }
 
@@ -132,14 +135,14 @@ fn split_scratch<'a>(
 
 /// Read with no alignment requirement.
 pub async fn read_async(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
-    out: &mut [u8],
+    out: &mut (impl SliceMaybeUninit + ?Sized),
     scratch: &mut [u8],
 ) -> Result<()> {
     let (buffer_alignment_scratch, block_alignment_scratch) = split_scratch(io.info(), scratch)?;
 
-    if is_buffer_aligned(out, io.info().alignment)? {
+    if is_buffer_aligned(out.as_ref(), io.info().alignment)? {
         return read_aligned_buffer(io, offset, out, block_alignment_scratch).await;
     }
 
@@ -154,14 +157,14 @@ pub async fn read_async(
     //  |----------------------|---------------------|
     //     io.info().alignment
 
-    let out_addr_value = SafeNum::from(out.as_ptr() as usize);
+    let out_addr_value = SafeNum::from(out.as_mut().as_ptr() as usize);
     let unaligned_read: usize =
         min((out_addr_value.round_up(io.info().alignment) - out_addr_value).try_into()?, out.len());
 
     // Read unaligned part
     let unaligned_out = &mut buffer_alignment_scratch[..unaligned_read];
     read_aligned_buffer(io, offset, unaligned_out, block_alignment_scratch).await?;
-    out[..unaligned_read].clone_from_slice(unaligned_out);
+    out.get_mut(..unaligned_read)?.clone_from_slice(as_uninit(unaligned_out));
 
     if unaligned_read == out.len() {
         return Ok(());
@@ -170,14 +173,14 @@ pub async fn read_async(
     read_aligned_buffer(
         io,
         (SafeNum::from(offset) + unaligned_read).try_into()?,
-        &mut out[unaligned_read..],
+        out.get_mut(unaligned_read..)?,
         block_alignment_scratch,
     )
     .await
 }
 
 /// Write bytes from aligned buffer to a block boundary range.
-async fn write_aligned_all(io: &mut impl BlockIoAsync, offset: u64, data: &mut [u8]) -> Result<()> {
+async fn write_aligned_all(io: &mut impl BlockIo, offset: u64, data: &mut [u8]) -> Result<()> {
     let blk_offset = check_range(io.info(), offset, data)?.try_into()?;
     Ok(io.write_blocks(blk_offset, data).await?)
 }
@@ -186,12 +189,12 @@ async fn write_aligned_all(io: &mut impl BlockIoAsync, offset: u64, data: &mut [
 ///   |~~~~~~~~~size~~~~~~~~~|
 ///   |---------|---------|---------|
 async fn write_aligned_offset_and_buffer(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
     data: &mut [u8],
     scratch: &mut [u8],
 ) -> Result<()> {
-    debug_assert!(is_aligned(offset.into(), io.info().block_size.into())?);
+    debug_assert!(is_aligned(offset, io.info().block_size)?);
     debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
 
     let aligned_write: usize =
@@ -236,7 +239,7 @@ fn rotate_right(slice: &mut [u8], sz: usize, scratch: &mut [u8]) {
 ///          |~~~write~~~|
 ///        |---------------|--------------|
 async fn write_aligned_buffer(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
     data: &mut [u8],
     scratch: &mut [u8],
@@ -244,7 +247,7 @@ async fn write_aligned_buffer(
     debug_assert!(is_buffer_aligned(data, io.info().alignment)?);
 
     let offset = SafeNum::from(offset);
-    if is_aligned(offset, io.info().block_size.into())? {
+    if is_aligned(offset, io.info().block_size)? {
         return write_aligned_offset_and_buffer(io, offset.try_into()?, data, scratch).await;
     }
 
@@ -290,7 +293,7 @@ async fn write_aligned_buffer(
 /// It does internal optimization that temporarily modifies `data` layout to minimize number of
 /// calls to `io.read_blocks()`/`io.write_blocks()` (down to O(1)).
 pub async fn write_async(
-    io: &mut impl BlockIoAsync,
+    io: &mut impl BlockIo,
     offset: u64,
     data: &mut [u8],
     scratch: &mut [u8],
@@ -333,67 +336,3 @@ pub async fn write_async(
     )
     .await
 }
-
-/// `AsyncAsSync` wraps a `BlockIoAsync` trait object and implement `BlockIoSync` interfaces. It
-/// simply blocks until IO completes.
-pub struct AsyncAsSync<T: BlockIoAsync>(T);
-
-impl<T: BlockIoAsync> AsyncAsSync<T> {
-    /// Creates a new instance
-    pub fn new(io: T) -> Self {
-        Self(io)
-    }
-
-    /// Returns the `BlockIoAsync`.
-    pub fn io(&mut self) -> &mut T {
-        &mut self.0
-    }
-}
-
-impl<T: BlockIoAsync> BlockIoSync for AsyncAsSync<T> {
-    fn info(&mut self) -> BlockInfo {
-        self.0.info()
-    }
-
-    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        block_on(self.0.read_blocks(blk_offset, out))
-    }
-
-    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        block_on(self.0.write_blocks(blk_offset, data))
-    }
-}
-
-/// `SyncAsAsync` wraps a `BlockIoSync` and implements `BlockIoAsync` interfaces with blocking
-/// operation under the hood.
-pub struct SyncAsAsync<T: BlockIoSync>(T);
-
-impl<T: BlockIoSync> SyncAsAsync<T> {
-    /// Creates a new instance
-    pub fn new(io: T) -> Self {
-        Self(io)
-    }
-
-    /// Returns the `BlockIoSync`.
-    pub fn io(&mut self) -> &mut T {
-        &mut self.0
-    }
-}
-
-// SAFETY:
-// * Implementation of `read_blocks()` and `write_blocks()` are blocking. It will not keep retaining
-//   the buffer after the function returns.
-// * `Self::check_status(buf)` does not dereference input pointer.
-impl<T: BlockIoSync> BlockIoAsync for SyncAsAsync<T> {
-    fn info(&mut self) -> BlockInfo {
-        self.0.info()
-    }
-
-    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        self.0.read_blocks(blk_offset, out)
-    }
-
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        self.0.write_blocks(blk_offset, data)
-    }
-}
diff --git a/gbl/libstorage/src/gpt.rs b/gbl/libstorage/src/gpt.rs
index d9aa376..26adc21 100644
--- a/gbl/libstorage/src/gpt.rs
+++ b/gbl/libstorage/src/gpt.rs
@@ -12,28 +12,33 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::{aligned_subslice, read_async, write_async, BlockIoAsync, Result};
+use crate::{BlockIo, Disk, Result};
 use core::{
+    array::from_fn,
+    cmp::min,
     convert::TryFrom,
     default::Default,
-    mem::{align_of, size_of},
+    fmt::{Debug, Formatter},
+    mem::size_of,
     num::NonZeroU64,
+    ops::{Deref, DerefMut},
     str::from_utf8,
 };
 use crc32fast::Hasher;
+use gbl_async::block_on;
+use liberror::{Error, GptError};
 use safemath::SafeNum;
-use zerocopy::{AsBytes, FromBytes, FromZeroes, Ref};
+use zerocopy::{AsBytes, ByteSlice, FromBytes, FromZeroes, Ref};
 
-use liberror::Error;
-
-const GPT_GUID_LEN: usize = 16;
+/// Number of bytes in GUID.
+pub const GPT_GUID_LEN: usize = 16;
 /// The maximum number of UTF-16 characters in a GPT partition name, including termination.
 pub const GPT_NAME_LEN_U16: usize = 36;
 const GPT_NAME_LEN_U8: usize = 2 * GPT_GUID_LEN;
 
 /// The top-level GPT header.
 #[repr(C, packed)]
-#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
+#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq, Eq)]
 pub struct GptHeader {
     /// Magic bytes; must be [GPT_MAGIC].
     pub magic: u64,
@@ -66,20 +71,197 @@ pub struct GptHeader {
 }
 
 impl GptHeader {
-    /// Cast a bytes slice into a GptHeader structure.
-    fn from_bytes(bytes: &mut [u8]) -> &mut GptHeader {
+    /// Casts a bytes slice into a mutable GptHeader structure.
+    pub fn from_bytes_mut(bytes: &mut [u8]) -> &mut GptHeader {
         Ref::<_, GptHeader>::new_from_prefix(bytes).unwrap().0.into_mut()
     }
 
+    /// Computes the actual crc32 value.
+    fn calculate_header_crc(&self) -> u32 {
+        let mut hasher = Hasher::new();
+        hasher.update(&self.as_bytes()[..GPT_CRC32_OFFSET]);
+        hasher.update(&[0u8; size_of::<u32>()]);
+        hasher.update(&self.as_bytes()[GPT_CRC32_OFFSET + size_of::<u32>()..]);
+        hasher.finalize()
+    }
+
     /// Update the header crc32 value.
     pub fn update_crc(&mut self) {
-        self.crc32 = 0;
-        self.crc32 = crc32(self.as_bytes());
+        self.crc32 = self.calculate_header_crc();
+    }
+
+    /// Updates entries and header crc according to the given entries buffer.
+    fn update_entries_crc(&mut self, entries: &[u8]) {
+        let size = SafeNum::from(self.entries_count) * self.entries_size;
+        self.entries_crc = crc32(&entries[..size.try_into().unwrap()]);
+        self.update_crc();
+    }
+}
+
+/// Computes the number of blocks for the 128 partition entries reserved space in GPT.
+fn gpt_entries_blk(block_size: u64) -> Result<u64> {
+    let size = u64::try_from(GPT_MAX_NUM_ENTRIES_SIZE).unwrap();
+    match size % block_size {
+        0 => Ok(size / block_size),
+        _ => Err(Error::InvalidInput),
+    }
+}
+
+/// Checks a header against a block device.
+///
+/// # Args
+///
+/// * `io`: An implementation of [BlockIo],
+/// * `header`: The GPT header to verify.
+/// * `is_primary`: If the header is a primary header.
+fn check_header(io: &mut impl BlockIo, header: &GptHeader, is_primary: bool) -> Result<()> {
+    let num_blks = SafeNum::from(io.info().num_blocks);
+    let blk_sz = io.info().block_size;
+
+    // GPT spec requires that at least 128 entries worth of space be reserved.
+    let min_reserved_entries_blk = gpt_entries_blk(blk_sz)?;
+    // Minimum space needed: 2 * (header + entries) + MBR.
+    let min_disk_blks: u64 = ((min_reserved_entries_blk + 1) * 2 + 1).try_into().unwrap();
+    if min_disk_blks > u64::try_from(num_blks).unwrap() {
+        return Err(Error::GptError(GptError::DiskTooSmall));
+    }
+
+    if header.magic != GPT_MAGIC {
+        return Err(Error::GptError(GptError::IncorrectMagic(header.magic)));
+    }
+
+    if header.calculate_header_crc() != header.crc32 {
+        return Err(Error::GptError(GptError::IncorrectHeaderCrc));
+    }
+
+    if header.size != size_of::<GptHeader>().try_into().unwrap() {
+        return Err(Error::GptError(GptError::UnexpectedHeaderSize {
+            actual: header.size,
+            expect: size_of::<GptHeader>(),
+        }));
+    }
+
+    if header.entries_size != size_of::<GptEntry>().try_into().unwrap() {
+        return Err(Error::GptError(GptError::UnexpectedEntrySize {
+            actual: header.entries_size,
+            expect: size_of::<GptEntry>(),
+        }));
+    }
+
+    // Checks first/last usable block.
+    //
+    // Assuming maximum range where partition entries are adjacent to GPT headers.
+    //
+    // Should leave a minimum space for MBR + primary header + primary entries before.
+    let min_first: u64 = (min_reserved_entries_blk + 2).try_into().unwrap();
+    // Should leave a minimum space for secondary header + secondary entries space after.
+    let max_last: u64 = (num_blks - 1 - min_reserved_entries_blk - 1).try_into().unwrap();
+    if header.first > header.last + 1 || header.first < min_first || header.last > max_last {
+        return Err(Error::GptError(GptError::InvalidFirstLastUsableBlock {
+            first: header.first,
+            last: header.last,
+            range: (min_first, max_last),
+        }));
+    }
+
+    // Checks entries starting block.
+    if is_primary {
+        // For primary header, entries must be before first usable block and can hold up to
+        // `GPT_MAX_NUM_ENTRIES` entries
+        let right: u64 =
+            (SafeNum::from(header.first) - min_reserved_entries_blk).try_into().unwrap();
+        if !(header.entries >= 2 && header.entries <= right) {
+            return Err(Error::GptError(GptError::InvalidPrimaryEntriesStart {
+                value: header.entries,
+                expect_range: (2, right),
+            }));
+        }
+    } else {
+        // For secondary header, entries must be after last usable block and can hold up to
+        // `GPT_MAX_NUM_ENTRIES` entries.
+        if !(header.entries > header.last && header.entries <= max_last + 1) {
+            return Err(Error::GptError(GptError::InvalidSecondaryEntriesStart {
+                value: header.entries,
+                expect_range: (header.last + 1, max_last + 1),
+            }));
+        }
+    }
+
+    if header.entries_count > GPT_MAX_NUM_ENTRIES.try_into().unwrap() {
+        return Err(Error::GptError(GptError::NumberOfEntriesOverflow {
+            entries: header.entries_count,
+            max_allowed: GPT_MAX_NUM_ENTRIES,
+        }));
     }
+
+    Ok(())
+}
+
+/// Verifies the given entries against a verifed GPT header.
+///
+/// # Args
+///
+/// * `header`: The verified GPT header corresponding to the entries.
+/// * `entries`: The buffer containing the entries.
+fn check_entries(header: &GptHeader, entries: &[u8]) -> Result<()> {
+    // Checks entries CRC.
+    assert!(header.entries_count <= GPT_MAX_NUM_ENTRIES.try_into().unwrap());
+    let entries_size: usize =
+        (SafeNum::from(header.entries_count) * GPT_ENTRY_SIZE).try_into().unwrap();
+    let entries = entries.get(..entries_size).ok_or(Error::GptError(GptError::EntriesTruncated))?;
+    if header.entries_crc != crc32(entries) {
+        return Err(Error::GptError(GptError::IncorrectEntriesCrc));
+    }
+
+    // Checks each entry.
+    let entries = Ref::<_, [GptEntry]>::new_slice(entries)
+        .ok_or(Error::GptError(GptError::EntriesTruncated))?
+        .into_slice();
+    let entries = &entries[..header.entries_count.try_into().unwrap()];
+    for (idx, ele) in entries.iter().take_while(|v| !v.is_null()).enumerate() {
+        // Error information uses 1-base partition index.
+        let idx = idx.checked_add(1).unwrap();
+        let (first, last) = (ele.first, ele.last);
+        if first > last + 1 || last > header.last || first < header.first {
+            return Err(Error::GptError(GptError::InvalidPartitionRange {
+                idx,
+                part_range: (first, last),
+                usable_range: (header.first, header.last),
+            }));
+        } else if ele.part_type == [0u8; GPT_GUID_LEN] {
+            return Err(Error::GptError(GptError::ZeroPartitionTypeGUID { idx }));
+        } else if ele.guid == [0u8; GPT_GUID_LEN] {
+            return Err(Error::GptError(GptError::ZeroPartitionUniqueGUID { idx }));
+        }
+    }
+
+    // Checks overlap between partition ranges.
+    // Sorts an index array because we don't want to modify input.
+    let mut sorted_indices: [u8; GPT_MAX_NUM_ENTRIES] = from_fn(|i| i.try_into().unwrap());
+    sorted_indices.sort_unstable_by_key(|v| match entries.get(usize::try_from(*v).unwrap()) {
+        Some(v) if !v.is_null() => v.first,
+        _ => u64::MAX,
+    });
+
+    let actual = entries.iter().position(|v| v.is_null()).unwrap_or(entries.len());
+    if actual > 1 {
+        for i in 0..actual - 1 {
+            let prev: usize = sorted_indices[i].try_into().unwrap();
+            let next: usize = sorted_indices[i + 1].try_into().unwrap();
+            if entries[prev].last >= entries[next].first {
+                return Err(Error::GptError(GptError::PartitionRangeOverlap {
+                    prev: (prev + 1, entries[prev].first, entries[prev].last),
+                    next: (next + 1, entries[next].first, entries[next].last),
+                }));
+            }
+        }
+    }
+
+    Ok(())
 }
 
 /// GptEntry is the partition entry data structure in the GPT.
-#[repr(C)]
+#[repr(C, packed)]
 #[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes, PartialEq)]
 pub struct GptEntry {
     /// Partition type GUID.
@@ -128,6 +310,11 @@ impl GptEntry {
         // but it's just an optimization, checked version would be fine also.
         unsafe { Ok(core::str::from_utf8_unchecked(&buffer[..index])) }
     }
+
+    /// Checks if the partition name is the same as the given.
+    pub fn match_name(&self, part: &str) -> Result<bool> {
+        Ok(self.name_to_str(&mut [0u8; GPT_NAME_LEN_U16 * 2][..])? == part)
+    }
 }
 
 impl core::fmt::Display for GptEntry {
@@ -135,19 +322,18 @@ impl core::fmt::Display for GptEntry {
         // Format: partition name: "abc", [first, last]: [123, 456]
         let mut name_conversion_buffer = [0u8; GPT_NAME_LEN_U16 * 2];
         let name = self.name_to_str(&mut name_conversion_buffer).map_err(|_| core::fmt::Error)?;
-        write!(f, "partition name: \"{}\", [first, last]: [{}, {}]", name, self.first, self.last)
+        // Note: The bracket around `{ self.first }` is for forcing a copy of the field because
+        // GptEntry is a packed structure.
+        write!(f, "partition: \"{}\", first: {}, last: {}", name, { self.first }, { self.last })
     }
 }
 
 // core::mem::offset_of!(GptHeader, crc32) is unsatble feature and rejected by the compiler in our
 // settings. We pre-compute the value here.
-const GPT_CRC32_OFFSET: u64 = 16;
-const GPT_ENTRY_ALIGNMENT: u64 = align_of::<GptEntry>() as u64;
-const GPT_ENTRY_SIZE: u64 = size_of::<GptEntry>() as u64;
-const GPT_MAX_NUM_ENTRIES: u64 = 128;
-const GPT_HEADER_SIZE: u64 = size_of::<GptHeader>() as u64; // 92 bytes.
-const GPT_HEADER_SIZE_PADDED: u64 =
-    (GPT_HEADER_SIZE + GPT_ENTRY_ALIGNMENT - 1) / GPT_ENTRY_ALIGNMENT * GPT_ENTRY_ALIGNMENT;
+const GPT_CRC32_OFFSET: usize = 16;
+const GPT_ENTRY_SIZE: usize = size_of::<GptEntry>();
+const GPT_MAX_NUM_ENTRIES: usize = 128;
+const GPT_MAX_NUM_ENTRIES_SIZE: usize = GPT_MAX_NUM_ENTRIES * GPT_ENTRY_SIZE;
 /// GPT header magic bytes ("EFI PART" in ASCII).
 pub const GPT_MAGIC: u64 = 0x5452415020494645;
 
@@ -215,136 +401,205 @@ impl Partition {
 }
 
 /// `PartitionIterator` iterates all GPT partition entries.
-pub struct PartitionIterator<'a, 'b> {
-    gpt_cache: &'b GptCache<'a>,
+pub struct PartitionIterator<'a> {
+    entries: &'a [GptEntry],
+    block_size: u64,
     idx: usize,
 }
 
-impl Iterator for PartitionIterator<'_, '_> {
+impl Iterator for PartitionIterator<'_> {
     type Item = Partition;
 
     fn next(&mut self) -> Option<Self::Item> {
         let res = self
-            .gpt_cache
-            .entries()
-            .ok()?
+            .entries
             .get(self.idx)
-            .map(|v| Partition::new(*v, self.gpt_cache.info.block_size))?;
+            .filter(|v| !v.is_null())
+            .map(|v| Partition::new(*v, self.block_size))?;
         self.idx += 1;
         Some(res)
     }
 }
 
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
-struct GptInfo {
-    // The number of valid entries in the entries array.
-    // May change as partitions are added or removed.
-    num_valid_entries: Option<NonZeroU64>,
-    // The maximum number of elements available in the entries array.
-    // Note: this is GREATER THAN OR EQUAL TO the number of valid entries
-    // and LESS THAN OR EQUAL TO the value of GPT_MAX_NUM_ENTRIES.
-    // Values other than GPT_MAX_NUM_ENTRIES are mostly used in unit tests.
-    max_entries: u64,
-    // Block size of the GPT disk.
-    block_size: u64,
+/// Contains result of GPT syncing/restoration.
+#[derive(Copy, Clone, PartialEq, Debug, Default)]
+pub enum GptSyncResult {
+    /// Both primary and secondary GPT are valid.
+    #[default]
+    BothValid,
+    /// Primary GPT is invalid and restored.
+    PrimaryRestored(Error),
+    /// Secondary GPT is invalid and restored.
+    SecondaryRestored(Error),
+    /// Neither primary or secondary GPT is valid.
+    NoValidGpt {
+        /// Primary GPT verify error.
+        primary: Error,
+        /// Secondary GPT verify error.
+        secondary: Error,
+    },
 }
 
-impl GptInfo {
-    fn from_bytes(bytes: &mut [u8]) -> &mut Self {
-        Ref::<_, GptInfo>::new_from_prefix(bytes).unwrap().0.into_mut()
+impl GptSyncResult {
+    /// Combined into a result
+    pub fn res(&self) -> Result<()> {
+        match self {
+            Self::NoValidGpt { primary: e, .. } => Err(*e),
+            _ => Ok(()),
+        }
     }
+}
+
+impl core::fmt::Display for GptSyncResult {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        match self {
+            Self::BothValid => write!(f, "Found valid GPT."),
+            Self::PrimaryRestored(e) => write!(f, "Primary GPT restored due to {e:?}."),
+            Self::SecondaryRestored(e) => write!(f, "Secondary GPT restored due to {e:?}."),
+            Self::NoValidGpt { primary, secondary } => {
+                write!(f, "No valid GPT. primary: {primary:?}, secondary: {secondary:?}.")
+            }
+        }
+    }
+}
+
+/// A packed wrapper of `Option<NonZeroU64>`
+#[repr(C, packed)]
+#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
+struct BlockSize(Option<NonZeroU64>);
+
+/// Represents the structure of a load buffer for loading/verifying/syncing up to N GPT entries.
+#[repr(C, packed)]
+#[derive(Debug, Copy, Clone, AsBytes, FromBytes, FromZeroes)]
+pub struct GptLoadBufferN<const N: usize> {
+    // GPT doesn't care about block size. But it's easier to have it available for computing offset
+    // and size in bytes for partitions. It's also used as a flag for indicating whether a valid
+    // GPT is loaded.
+    block_size: BlockSize,
+    primary_header: GptHeader,
+    secondary_header: GptHeader,
+    primary_entries: [GptEntry; N],
+    secondary_entries: [GptEntry; N],
+}
+
+impl<const N: usize> Deref for GptLoadBufferN<N> {
+    type Target = [u8];
+
+    fn deref(&self) -> &Self::Target {
+        self.as_bytes()
+    }
+}
 
-    fn num_valid_entries(&self) -> Result<u64> {
-        Ok(self.num_valid_entries.ok_or(Error::InvalidInput)?.get())
+impl<const N: usize> DerefMut for GptLoadBufferN<N> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        self.as_bytes_mut()
     }
 }
 
-/// GptCache contains the GPT header/entries information loaded from storage.
-pub struct GptCache<'a> {
-    info: &'a mut GptInfo,
-    /// Raw bytes of primary GPT header.
-    primary_header: &'a mut [u8],
-    /// Raw bytes of primary GPT entries.
-    primary_entries: &'a mut [u8],
-    /// Raw bytes of secondary GPT header.
-    secondary_header: &'a mut [u8],
-    /// Raw bytes of secondary GPT entries.
-    secondary_entries: &'a mut [u8],
+/// Contains references corresponding to different GPT load entities parsed from a load buffer.
+///
+/// The structure is simply for organizing together the individual references of fields in
+/// `GptLoadBufferN` parsed from a raw buffer. Note that we can't parse a `Ref<B, GptLoadBufferN>`
+/// directly from a buffer because the number of entries (length of [GptEntry]) in this case needs
+/// to be computed at run time based on the buffer size.
+struct LoadBufferRef<B: ByteSlice> {
+    block_size: Ref<B, BlockSize>,
+    primary_header: Ref<B, GptHeader>,
+    secondary_header: Ref<B, GptHeader>,
+    primary_entries: Ref<B, [GptEntry]>,
+    secondary_entries: Ref<B, [GptEntry]>,
 }
 
-impl<'a> GptCache<'a> {
-    /// Create an uninitialized GptCache instance from a provided buffer.
+impl<B: ByteSlice> LoadBufferRef<B> {
+    fn from(buffer: B) -> Self {
+        let n = min(GPT_MAX_NUM_ENTRIES, max_supported_entries(&buffer[..]).unwrap());
+        let (block_size, rest) = Ref::new_from_prefix(buffer).unwrap();
+        let (primary_header, rest) = Ref::new_from_prefix(rest).unwrap();
+        let (secondary_header, rest) = Ref::new_from_prefix(rest).unwrap();
+        let (primary_entries, rest) = Ref::new_slice_from_prefix(rest, n).unwrap();
+        let (secondary_entries, _) = Ref::new_slice_from_prefix(rest, n).unwrap();
+        Self { block_size, primary_header, secondary_header, primary_entries, secondary_entries }
+    }
+
+    /// Unpacks into the secondary GPT header/entries
+    fn secondary(self) -> (Ref<B, GptHeader>, Ref<B, [GptEntry]>) {
+        (self.secondary_header, self.secondary_entries)
+    }
+}
+
+/// The minimum buffer size needed for creating a [Gpt] that can load `entries` number of
+/// partitions.
+///
+/// # Returns
+///
+/// * Returns Ok(size) on success.
+/// * Returns Err(Error::InvalidInput) if max_entries is greater than 128.
+pub fn gpt_buffer_size(entries: usize) -> Result<usize> {
+    match entries > GPT_MAX_NUM_ENTRIES {
+        true => Err(Error::InvalidInput),
+        _ => Ok(size_of::<GptLoadBufferN<0>>() + entries * GPT_ENTRY_SIZE * 2),
+    }
+}
+
+/// Computes the maximum number of entries that can be loaded if using the given buffer for [Gpt].
+fn max_supported_entries(buf: &[u8]) -> Result<usize> {
+    match buf.len() < size_of::<GptLoadBufferN<0>>() {
+        true => Err(Error::BufferTooSmall(Some(size_of::<GptLoadBufferN<0>>()))),
+        _ => Ok((buf.len() - size_of::<GptLoadBufferN<0>>()) / 2 / GPT_ENTRY_SIZE),
+    }
+}
+
+/// [Gpt] manages a buffer for loading, verifying and syncing GPT.
+pub struct Gpt<B> {
+    buffer: B,
+}
+
+impl<B: DerefMut<Target = [u8]>> Gpt<B> {
+    /// Create an uninitialized Gpt instance from a provided buffer.
+    ///
+    /// The created [Gpt] can then be used in `Disk::sync_gpt()` for loading, verifying and syncing
+    /// GPT on disk.
     ///
     /// # Args:
     ///
-    /// * `max_entries`: Maximum number of entries allowed.
+    /// * `buffer`: A buffer to use for loading, verifying and syncing primary and secondary GPT.
+    ///   The size of the buffer determines the maximum number of partition entries that can be
+    ///   loaded. If actual number of partitions, specified by `entries_count` in the GPT header,
+    ///   exceeds it, verification and sync will eventually fail with `Error::BufferTooSmall`.
+    ///   `gpt_buffer_size(num_entries)` can be used to compute the required size of buffer for
+    ///   loading a specific number of entries. Note that most tools and OS fix the `entries_count`
+    ///   value to the max 128 regardless of the actual number of partition entries used. Thus
+    ///   unless you have full control of GPT generation in your entire system where you can always
+    ///   ensure a smaller bound on it, it is recommended to always provide enough buffer for
+    ///   loading 128 entries.
     ///
-    /// * `buffer`: Buffer for creating the object. Must have a size at least
-    ///   `GptCache::required_buffer_size(max_entries)`.
-    pub fn from_uninit(max_entries: u64, buffer: &'a mut [u8]) -> Result<GptCache<'a>> {
-        if max_entries > GPT_MAX_NUM_ENTRIES
-            || buffer.len() < Self::required_buffer_size(max_entries)?
-        {
-            return Err(Error::InvalidInput);
-        }
-        let buffer = aligned_subslice(buffer, GPT_ENTRY_ALIGNMENT)?;
-        *GptInfo::from_bytes(buffer) =
-            GptInfo { num_valid_entries: None, max_entries, block_size: 0 };
-        Self::from_existing(buffer)
+    /// # Returns
+    ///
+    /// * Returns Ok(Self) on success.
+    /// * Returns Err(Error::BufferTooSmall) if buffer is less than the minimum size.
+    pub fn new(mut buffer: B) -> Result<Self> {
+        max_supported_entries(&buffer[..])?;
+        LoadBufferRef::from(&mut buffer[..]).block_size.0 = None;
+        Ok(Self { buffer })
     }
 
-    /// Reconstructs an existing GptCache struct from a buffer previously created with
-    /// `Self::from_uninit()` and that has been initialized with `AsyncBlockDevice::sync_gpt()`.
-    ///
-    /// The method simply partitions the input buffer and populate the `GptInfo` struct and
-    /// primary/secondary header/entries slices. It assumes that the buffer contains a valid
-    /// GptInfo struct.
-    pub fn from_existing(buffer: &'a mut [u8]) -> Result<GptCache<'a>> {
-        let buffer = aligned_subslice(buffer, GPT_ENTRY_ALIGNMENT)?;
-        let (info, remain) = Ref::<_, GptInfo>::new_from_prefix(buffer).unwrap();
-        let entries_size = SafeNum::from(info.max_entries) * GPT_ENTRY_SIZE;
-        let header_size: usize = SafeNum::from(GPT_HEADER_SIZE_PADDED).try_into()?;
-        let split_pos = entries_size + header_size;
-        let (primary, secondary) = remain.split_at_mut(split_pos.try_into()?);
-        let (primary_header, primary_entries) = primary.split_at_mut(header_size);
-        let (secondary_header, secondary_entries) = secondary.split_at_mut(header_size);
-
-        Ok(Self {
-            info: info.into_mut(),
-            primary_header,
-            primary_entries,
-            secondary_header,
-            secondary_entries: &mut secondary_entries[..entries_size.try_into()?],
-        })
-    }
-
-    /// Creates a new `GptCache` instance that borrows the internal data of this instance.
-    pub fn as_mut_instance(&mut self) -> GptCache<'_> {
-        GptCache {
-            info: &mut self.info,
-            primary_header: &mut self.primary_header,
-            primary_entries: &mut self.primary_entries,
-            secondary_header: &mut self.secondary_header,
-            secondary_entries: &mut self.secondary_entries,
-        }
+    /// Returns the maximum allowed entries.
+    pub fn max_entries(&self) -> usize {
+        max_supported_entries(&self.buffer[..]).unwrap()
     }
 
-    /// Returns an iterator to GPT partition entries.
-    pub fn partition_iter(&self) -> PartitionIterator {
-        PartitionIterator { gpt_cache: self, idx: 0 }
+    /// Creates an instance of `Gpt<&mut [u8]>` that borrows the internal GPT buffer.
+    pub fn as_borrowed(&mut self) -> Gpt<&mut [u8]> {
+        Gpt { buffer: &mut self.buffer[..] }
     }
 
-    /// The minimum buffer size needed for `Self::from_uninit()`
-    pub fn required_buffer_size(max_entries: u64) -> Result<usize> {
-        let entries_size = SafeNum::from(max_entries) * GPT_ENTRY_SIZE;
-        usize::try_from(
-            ((entries_size + GPT_HEADER_SIZE_PADDED) * 2)
-                + size_of::<GptInfo>()
-                + GPT_ENTRY_ALIGNMENT
-                - 1,
-        )
-        .map_err(Into::<Error>::into)
+    /// Returns an iterator to GPT partition entries.
+    ///
+    /// If the object does not contain a valid GPT, the method returns Error.
+    pub fn partition_iter(&self) -> Result<PartitionIterator> {
+        let block_size = self.check_valid()?;
+        let entries = LoadBufferRef::from(&self.buffer[..]).primary_entries.into_slice();
+        Ok(PartitionIterator { entries, idx: 0, block_size })
     }
 
     /// Checks if a read/write range into a GPT partition overflows and returns the range's absolute
@@ -355,11 +610,12 @@ impl<'a> GptCache<'a> {
 
     /// Return the list of GPT entries.
     ///
-    /// If the object does not contain a valid GPT, the method returns Error.
-    fn entries(&self) -> Result<&[GptEntry]> {
+    /// If there is not a valid GPT, the method returns Error.
+    pub fn entries(&self) -> Result<&[GptEntry]> {
         self.check_valid()?;
-        Ok(&Ref::<_, [GptEntry]>::new_slice(&self.primary_entries[..]).unwrap().into_slice()
-            [..usize::try_from(self.info.num_valid_entries()?)?])
+        let entries = LoadBufferRef::from(&self.buffer[..]).primary_entries.into_slice();
+        let n = entries.iter().position(|v| v.is_null()).unwrap_or(entries.len());
+        Ok(&entries[..n])
     }
 
     /// Returns the total number of partitions.
@@ -369,8 +625,9 @@ impl<'a> GptCache<'a> {
 
     /// Gets the `idx`th partition.
     pub fn get_partition(&self, idx: usize) -> Result<Partition> {
+        let block_size = self.check_valid()?;
         let entry = *self.entries()?.get(idx).ok_or(Error::BadIndex(idx))?;
-        Ok(Partition::new(entry, self.info.block_size))
+        Ok(Partition::new(entry, block_size))
     }
 
     /// Returns the `Partition` for a partition.
@@ -379,158 +636,478 @@ impl<'a> GptCache<'a> {
     ///
     /// * `part`: Name of the partition.
     pub fn find_partition(&self, part: &str) -> Result<Partition> {
+        let block_size = self.check_valid()?;
         for entry in self.entries()? {
             let mut name_conversion_buffer = [0u8; GPT_NAME_LEN_U16 * 2];
             if entry.name_to_str(&mut name_conversion_buffer)? != part {
                 continue;
             }
-            return Ok(Partition::new(*entry, self.info.block_size));
+            return Ok(Partition::new(*entry, block_size));
         }
         Err(Error::NotFound)
     }
 
-    /// Checks whether the GptCache has been initialized.
-    fn check_valid(&self) -> Result<()> {
-        self.info.num_valid_entries()?;
-        Ok(())
+    /// Checks whether the Gpt has been initialized and returns the block size.
+    fn check_valid(&self) -> Result<u64> {
+        Ok(LoadBufferRef::from(&self.buffer[..]).block_size.0.ok_or(Error::InvalidState)?.get())
     }
 
     /// Helper function for loading and validating GPT header and entries.
-    async fn validate_gpt(
+    async fn load_and_validate_gpt(
         &mut self,
-        io: &mut impl BlockIoAsync,
-        scratch: &mut [u8],
-        header_type: HeaderType,
-    ) -> Result<bool> {
-        let (header_start, header_bytes, entries) = match header_type {
-            HeaderType::Primary => {
-                (io.info().block_size.into(), &mut self.primary_header, &mut self.primary_entries)
-            }
+        disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+        hdr_type: HeaderType,
+    ) -> Result<()> {
+        let blk_sz = disk.io().info().block_size;
+        let load = LoadBufferRef::from(&mut self.buffer[..]);
+        let (header_start, mut header, mut entries) = match hdr_type {
+            HeaderType::Primary => (blk_sz, load.primary_header, load.primary_entries),
             HeaderType::Secondary => (
-                (SafeNum::from(io.info().num_blocks) - 1) * io.info().block_size,
-                &mut self.secondary_header,
-                &mut self.secondary_entries,
+                ((SafeNum::from(disk.io().info().num_blocks) - 1) * blk_sz).try_into()?,
+                load.secondary_header,
+                load.secondary_entries,
             ),
         };
-        read_async(io, header_start.try_into()?, header_bytes, scratch).await?;
-        let header =
-            Ref::<_, GptHeader>::new_from_prefix(header_bytes.as_bytes()).unwrap().0.into_ref();
-
-        if header.magic != GPT_MAGIC {
-            return Ok(false);
-        }
 
+        // Loads the header
+        disk.read(header_start, header.as_bytes_mut()).await?;
+        // Checks header.
+        check_header(disk.io(), &header, matches!(hdr_type, HeaderType::Primary))?;
+        // Loads the entries.
         let entries_size = SafeNum::from(header.entries_count) * GPT_ENTRY_SIZE;
-        let entries_offset = SafeNum::from(header.entries) * io.info().block_size;
-        if self.info.max_entries < header.entries_count.into()
-            || u64::try_from(entries_size + entries_offset)?
-                > ((SafeNum::from(io.info().num_blocks) - 1) * io.info().block_size).try_into()?
-        {
-            return Ok(false);
-        }
-
-        let crc32_offset = SafeNum::from(GPT_CRC32_OFFSET).try_into()?;
-        let mut hasher = Hasher::new();
-        hasher.update(&header.as_bytes()[..crc32_offset]);
-        hasher.update(&[0u8; size_of::<u32>()]);
-        hasher.update(&header.as_bytes()[crc32_offset + size_of::<u32>()..]);
-        if hasher.finalize() != header.crc32 {
-            return Ok(false);
-        }
-
-        // Load the entries
-        let out = &mut entries[..entries_size.try_into()?];
-        read_async(io, entries_offset.try_into()?, out, scratch).await?;
-        // Validate entries crc32.
-        Ok(header.entries_crc == crc32(out))
+        let entries_offset = SafeNum::from(header.entries) * blk_sz;
+        let out = entries.as_bytes_mut().get_mut(..entries_size.try_into().unwrap()).ok_or(
+            Error::BufferTooSmall(Some(
+                gpt_buffer_size(header.entries_count.try_into().unwrap()).unwrap(),
+            )),
+        )?;
+        disk.read(entries_offset.try_into().unwrap(), out).await?;
+        // Checks entries.
+        check_entries(&header, entries.as_bytes())
     }
 
-    /// Load and sync GPT from a block device.
+    /// Loads and syncs GPT from a block device.
+    ///
+    /// * Returns Ok(sync_result) if disk IO is successful, where `sync_result` contains the GPT
+    ///   verification and restoration result,
+    /// * Returns Err() if disk IO encounters error.
     pub(crate) async fn load_and_sync(
         &mut self,
-        io: &mut impl BlockIoAsync,
-        scratch: &mut [u8],
-    ) -> Result<()> {
-        self.info.num_valid_entries = None;
-
-        let block_size = io.info().block_size;
-        let total_blocks: SafeNum = io.info().num_blocks.into();
+        disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+    ) -> Result<GptSyncResult> {
+        let blk_sz = disk.io().info().block_size;
+        let nonzero_blk_sz = NonZeroU64::new(blk_sz).ok_or(Error::InvalidInput)?;
+        let total_blocks: SafeNum = disk.io().info().num_blocks.into();
 
         let primary_header_blk = 1;
-        let primary_header_pos = block_size;
+        let primary_header_pos = blk_sz;
         let secondary_header_blk = total_blocks - 1;
-        let secondary_header_pos = secondary_header_blk * block_size;
 
         // Entries position for restoring.
         let primary_entries_blk = 2;
-        let primary_entries_pos = SafeNum::from(primary_entries_blk) * block_size;
-        let primary_valid = self.validate_gpt(io, scratch, HeaderType::Primary).await?;
-        let secondary_valid = self.validate_gpt(io, scratch, HeaderType::Secondary).await?;
-
-        let primary_header = GptHeader::from_bytes(self.primary_header);
-        let secondary_header = GptHeader::from_bytes(self.secondary_header);
-        if !primary_valid {
-            if !secondary_valid {
-                return Err(Error::NoGpt);
+        let primary_entries_pos = SafeNum::from(primary_entries_blk) * blk_sz;
+        let primary_res = self.load_and_validate_gpt(disk, HeaderType::Primary).await;
+        let secondary_res = self.load_and_validate_gpt(disk, HeaderType::Secondary).await;
+
+        let LoadBufferRef {
+            mut block_size,
+            mut primary_header,
+            mut secondary_header,
+            mut primary_entries,
+            mut secondary_entries,
+        } = LoadBufferRef::from(&mut self.buffer[..]);
+        block_size.0 = None;
+        let primary_entries = primary_entries.as_bytes_mut();
+        let secondary_entries = secondary_entries.as_bytes_mut();
+        let sync_res = match (primary_res, secondary_res) {
+            (Err(primary), Err(secondary)) => GptSyncResult::NoValidGpt { primary, secondary },
+            (Ok(()), Ok(())) if is_consistent(&primary_header, &secondary_header) => {
+                GptSyncResult::BothValid
+            }
+            (Err(e), Ok(())) => {
+                // Restores to primary
+                primary_header.as_bytes_mut().clone_from_slice(secondary_header.as_bytes());
+                primary_entries.clone_from_slice(&secondary_entries);
+                primary_header.current = primary_header_blk;
+                primary_header.backup = secondary_header_blk.try_into()?;
+                primary_header.entries = primary_entries_blk;
+                primary_header.update_crc();
+
+                disk.write(primary_header_pos, primary_header.as_bytes_mut()).await?;
+                disk.write(primary_entries_pos.try_into()?, primary_entries).await?;
+                GptSyncResult::PrimaryRestored(e)
+            }
+            (Ok(()), v) => {
+                // Restores to secondary
+                let pos = secondary_header_blk * blk_sz;
+                let secondary_entries_pos = pos - GPT_MAX_NUM_ENTRIES_SIZE;
+                let secondary_entries_blk = secondary_entries_pos / blk_sz;
+
+                secondary_header.as_bytes_mut().clone_from_slice(primary_header.as_bytes());
+                secondary_entries.clone_from_slice(primary_entries);
+                secondary_header.current = secondary_header_blk.try_into()?;
+                secondary_header.backup = primary_header_blk;
+                secondary_header.entries = secondary_entries_blk.try_into()?;
+                secondary_header.update_crc();
+
+                disk.write(pos.try_into()?, secondary_header.as_bytes_mut()).await?;
+                disk.write(secondary_entries_pos.try_into()?, secondary_entries).await?;
+
+                GptSyncResult::SecondaryRestored(match v {
+                    Err(e) => e,
+                    _ => Error::GptError(GptError::DifferentFromPrimary),
+                })
             }
-            // Restore to primary
-            primary_header.as_bytes_mut().clone_from_slice(secondary_header.as_bytes());
-            self.primary_entries.clone_from_slice(&self.secondary_entries);
-            primary_header.current = primary_header_blk;
-            primary_header.backup = secondary_header_blk.try_into()?;
-            primary_header.entries = primary_entries_blk;
-            primary_header.update_crc();
-
-            write_async(io, primary_header_pos, primary_header.as_bytes_mut(), scratch).await?;
-            write_async(io, primary_entries_pos.try_into()?, self.primary_entries, scratch).await?
-        } else if !secondary_valid {
-            // Restore to secondary
-            let secondary_entries_pos = secondary_header_pos
-                - (SafeNum::from(self.info.max_entries) * core::mem::size_of::<GptEntry>());
-            let secondary_entries_blk = secondary_entries_pos / block_size;
-
-            secondary_header.as_bytes_mut().clone_from_slice(primary_header.as_bytes());
-            self.secondary_entries.clone_from_slice(&self.primary_entries);
-            secondary_header.current = secondary_header_blk.try_into()?;
-            secondary_header.backup = primary_header_blk;
-            secondary_header.entries = secondary_entries_blk.try_into()?;
-            secondary_header.update_crc();
-
-            write_async(
-                io,
-                secondary_header_pos.try_into()?,
-                secondary_header.as_bytes_mut(),
-                scratch,
-            )
-            .await?;
-            write_async(io, secondary_entries_pos.try_into()?, self.secondary_entries, scratch)
-                .await?;
+        };
+
+        block_size.0 = Some(nonzero_blk_sz);
+        Ok(sync_res)
+    }
+}
+
+/// Checks whether primary and secondary header
+fn is_consistent(primary: &GptHeader, secondary: &GptHeader) -> bool {
+    let mut expected_secondary = *primary;
+    expected_secondary.crc32 = secondary.crc32;
+    expected_secondary.current = secondary.current;
+    expected_secondary.backup = 1;
+    expected_secondary.entries = secondary.entries;
+    &expected_secondary == secondary
+}
+
+/// A [Gpt] that owns a `GptLoadBufferN<N>` and can load up to N partition entries.
+///
+/// Note: The size of this type increases with N and can be expensive to store on stack. It is
+/// typically intended for resource abundant environment such as test.
+pub type GptN<const N: usize> = Gpt<GptLoadBufferN<N>>;
+
+/// Creates an instance of GptN.
+pub fn new_gpt_n<const N: usize>() -> GptN<N> {
+    Gpt::new(GptLoadBufferN::<N>::new_zeroed()).unwrap()
+}
+
+/// A [Gpt] that owns a `GptLoadBufferN<128>` and can load the maximum 128 partition entries.
+///
+/// Note: The size of this type is approximately 34K and can be expensive to store on stack. It
+/// is typically intended for resource abundant environment such as test.
+pub type GptMax = GptN<GPT_MAX_NUM_ENTRIES>;
+
+/// Creates an instance of GptMax.
+pub fn new_gpt_max() -> GptMax {
+    new_gpt_n::<GPT_MAX_NUM_ENTRIES>()
+}
+
+/// Updates GPT on a block device.
+///
+/// # Args
+///
+/// * `io`: An implementation of [BlockIo]
+/// * `scratch`: Scratch buffer for unaligned read write.
+/// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
+/// * `resize`: If set to true, the method updates the last partition to cover the rest of the
+///    storage.
+/// * `gpt`: The output [Gpt] to update.
+pub(crate) async fn update_gpt(
+    disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+    mbr_primary: &mut [u8],
+    resize: bool,
+    gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
+) -> Result<()> {
+    let blk_sz: usize = disk.io().info().block_size.try_into()?;
+    let (header, remain) = mbr_primary
+        .get_mut(blk_sz..)
+        .map(|v| v.split_at_mut_checked(blk_sz))
+        .flatten()
+        .ok_or(Error::BufferTooSmall(Some(blk_sz * 2)))?;
+    let header = Ref::<_, GptHeader>::new_from_prefix(&mut header[..]).unwrap().0.into_mut();
+
+    // Adjusts last usable block according to this device in case the GPT was generated for a
+    // different disk size. If this results in some partition being out of range, it will be
+    // caught during `check_header()`.
+    let entries_blk = SafeNum::from(GPT_MAX_NUM_ENTRIES_SIZE) / blk_sz;
+    // Reserves only secondary GPT header and entries.
+    let num_blks = SafeNum::from(disk.io().info().num_blocks);
+    header.last = (num_blks - entries_blk - 2).try_into().unwrap();
+    header.backup = (num_blks - 1).try_into().unwrap();
+    header.update_crc();
+
+    check_header(disk.io(), &header, true)?;
+    // Computes entries offset in bytes relative to `remain`
+    let entries_off: usize = ((SafeNum::from(header.entries) - 2) * blk_sz).try_into().unwrap();
+    let entries_size: usize =
+        (SafeNum::from(header.entries_count) * header.entries_size).try_into().unwrap();
+    let entries = remain
+        .get_mut(entries_off..)
+        .map(|v| v.get_mut(..entries_size))
+        .flatten()
+        .ok_or(Error::BufferTooSmall(Some(2 * blk_sz + entries_off + entries_size)))?;
+    check_entries(&header, entries)?;
+
+    if resize {
+        // Updates the last entry to cover the rest of the storage.
+        let gpt_entries =
+            Ref::<_, [GptEntry]>::new_slice(&mut entries[..]).unwrap().into_mut_slice();
+        gpt_entries.iter_mut().filter(|e| !e.is_null()).last().map(|v| v.last = header.last);
+        header.update_entries_crc(entries);
+        // Re-verifies everything.
+        check_header(disk.io(), &header, true).unwrap();
+        check_entries(&header, entries).unwrap();
+    }
+
+    disk.write(0, mbr_primary).await?;
+    disk.sync_gpt(gpt).await?.res()
+}
+
+/// Erases GPT if there is one on the device.
+pub(crate) async fn erase_gpt(
+    disk: &mut Disk<impl BlockIo, impl DerefMut<Target = [u8]>>,
+    gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
+) -> Result<()> {
+    match disk.sync_gpt(gpt).await?.res() {
+        Err(_) => Ok(()), // No valid GPT. Nothing to erase.
+        _ => {
+            let blk_sz = disk.block_info().block_size;
+            let mut load = LoadBufferRef::from(&mut gpt.buffer[..]);
+            let entries_size = SafeNum::from(load.primary_header.entries_count) * GPT_ENTRY_SIZE;
+            let scratch = load.primary_entries.as_bytes_mut();
+            // Invalidate GPT first.
+            load.block_size.0 = None;
+            // Erases primary header/entries.
+            let header = load.primary_header.current;
+            let entries = load.primary_header.entries;
+            disk.fill(header * blk_sz, blk_sz, 0, scratch).await?;
+            disk.fill(entries * blk_sz, entries_size.try_into().unwrap(), 0, scratch).await?;
+            // Erases secondary header/entries.
+            let header = load.secondary_header.current;
+            let entries = load.secondary_header.entries;
+            disk.fill(header * blk_sz, blk_sz, 0, scratch).await?;
+            disk.fill(entries * blk_sz, entries_size.try_into().unwrap(), 0, scratch).await?;
+            Ok(())
         }
+    }
+}
 
-        // Calculate actual number of GPT entries by finding the first invalid entry.
-        let entries =
-            Ref::<_, [GptEntry]>::new_slice(&self.primary_entries[..]).unwrap().into_slice();
-        self.info.num_valid_entries =
-            NonZeroU64::new(match entries.iter().position(|e| e.is_null()) {
-                Some(idx) => idx as u64,
-                _ => self.info.max_entries,
-            });
-        self.info.block_size = block_size;
-        Ok(())
+/// Computes the minimum blocks needed for creating a GPT.
+fn min_required_blocks(block_size: u64) -> Result<u64> {
+    // MBR + primary/secondary GPT header block + primary/secondary entries blocks.
+    Ok(1 + (1 + gpt_entries_blk(block_size)?) * 2)
+}
+
+/// `GptBuilder` provides API for modifying/creating GPT partition table on a disk.
+pub struct GptBuilder<D, G> {
+    disk: D,
+    gpt: G,
+}
+
+impl<D: Debug, G: Debug> Debug for GptBuilder<D, G> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {
+        write!(f, "GptBuilder {{ disk: {:?}, gpt: {:?} }}", self.disk, self.gpt)
     }
 }
+// Generic parameters:
+//
+// * T: The type that implement BlockIo.
+// * S: The type for the scratch buffer in `Self::disk`.
+// * B: The type for the GPT buffer in `Self::gpt`.
+// * D: The type for `Self::disk` which can dereference to a Disk<T, S>.
+// * G: The type for `Self::gpt` which can dereference to a Gpt<B>.
+impl<'a, T, S, B, D, G> GptBuilder<D, G>
+where
+    T: BlockIo,
+    S: DerefMut<Target = [u8]>,
+    B: DerefMut<Target = [u8]>,
+    D: DerefMut<Target = Disk<T, S>>,
+    G: DerefMut<Target = Gpt<B>>,
+{
+    /// Creates a new instance.
+    ///
+    /// The method always re-syncs the GPT. If `disk` does not contain a valid GPT, a new GPT is
+    /// started from scratch.
+    ///
+    /// The partition entries will always be sorted when writing back to disk by `Self::persist()`.
+    ///
+    /// # Returns
+    ///
+    /// * Returns Ok((Self, true)) if an instance is created and the disk has a valid GPT.
+    /// * Returns Ok((Self, false)) if an instance is created but disk does not have a valid GPT.
+    /// * Returns Err() otherwise.
+    pub fn new(mut disk: D, mut gpt: G) -> Result<(Self, bool)> {
+        if disk.block_info().num_blocks < min_required_blocks(disk.block_info().block_size)? {
+            return Err(Error::GptError(GptError::DiskTooSmall));
+        }
+        let has_valid_gpt = block_on(disk.sync_gpt(&mut gpt))?.res().is_ok();
+        // Uses the buffer for secondary GPT header/entries as construction buffer, as it is not
+        // used by Gpt once loaded and synced.
+        let (mut header, mut entries) = LoadBufferRef::from(&mut gpt.buffer[..]).secondary();
+        if !has_valid_gpt {
+            header.as_bytes_mut().fill(0);
+            entries.as_bytes_mut().fill(0);
+            let entries_blk = gpt_entries_blk(disk.block_info().block_size).unwrap();
+            // Initializes a secondary header.
+            let num_blks = SafeNum::from(disk.block_info().num_blocks);
+            header.magic = GPT_MAGIC;
+            header.current = (num_blks - 1).try_into().unwrap();
+            header.backup = 1;
+            header.size = size_of::<GptHeader>().try_into().unwrap();
+            header.first = 1 + 1 + entries_blk; // MBR + GPT header blocks + entries block
+            header.last = (num_blks - 1 - entries_blk - 1).try_into().unwrap();
+            header.entries = (num_blks - 1 - entries_blk).try_into().unwrap();
+            header.entries_count = 0;
+            header.entries_size = size_of::<GptEntry>().try_into().unwrap();
+        }
+        // Normalizes `entries_count` to actual valid entries. Some GPT disk fixes `entry_count` to
+        // 128.
+        header.entries_count =
+            entries.iter().position(|v| v.is_null()).unwrap_or(entries.len()).try_into().unwrap();
+        entries.sort_unstable_by_key(|v| match v.is_null() {
+            true => u64::MAX,
+            _ => v.first,
+        });
+        Ok((Self { disk, gpt }, has_valid_gpt))
+    }
+
+    /// Removes a partition.
+    ///
+    /// # Returns
+    ///
+    /// * Returns Ok(true) if found and removed.
+    /// * Returns Ok(false) if not found.
+    /// * Returns Err() otherwise.
+    pub fn remove(&mut self, part: &str) -> Result<bool> {
+        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
+        let entries = &mut entries[..header.entries_count.try_into().unwrap()];
+        match entries.iter().position(|v| v.match_name(part).unwrap_or(false)) {
+            Some(n) => {
+                // Shift the elements behind forward.
+                entries[n..].rotate_left(1);
+                // Zeroizes the last element.
+                entries.last_mut().unwrap().as_bytes_mut().fill(0);
+                header.entries_count -= 1;
+                Ok(true)
+            }
+            _ => Ok(false),
+        }
+    }
+
+    /// Inserts a new partition before a partition.
+    ///
+    /// # Args
+    ///
+    /// * `idx`: Index of the partition to insert before. If index is out of range of valid entries,
+    ///   the partition will be inserted at the last.
+    /// * `name`: Name of the partition.
+    /// * `part_type`: Type GUID.
+    /// * `unique_guid`: Unique GUID.
+    /// * `flags`: Partition flag.
+    /// * `size`: If Some(_), specifies the size in number of bytes for the partition. The method
+    ///   will round it up to multiple of disk block size and check that there is enough space for
+    ///   the partition. If None, the method will insert the partition and consumes all the
+    ///   available space in between.
+    fn insert_before(
+        &mut self,
+        idx: usize,
+        name: &str,
+        part_type: [u8; GPT_GUID_LEN],
+        unique_guid: [u8; GPT_GUID_LEN],
+        flags: u64,
+        size: Option<u64>,
+    ) -> Result<()> {
+        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
+        // Gets position to the first NULL entry.
+        let n = entries.iter().position(|v| v.is_null()).ok_or(Error::OutOfResources)?;
+        let entries = &mut entries[..n + 1];
+        // Caps `idx` to no more than the first NULL entry.
+        let idx = min(n, idx);
+        // Comptues the ending block index (non-inclusive) of the previous partition entry.
+        // Entries are guaranteed sorted in `Self::new()`.
+        let prev_end = match idx {
+            0 => header.first,
+            _ => entries[idx - 1].last + 1,
+        };
+        // Comptues the starting block index (inclusive) of the next partition entry.
+        let next_start = match idx == n {
+            true => header.last + 1,
+            _ => entries[idx].first,
+        };
+        // Computes the size in number of blocks
+        let blk_sz = self.disk.block_info().block_size;
+        let blocks: u64 = match size {
+            Some(v) => (SafeNum::from(v).round_up(blk_sz) / blk_sz).try_into()?,
+            _ => next_start - prev_end, // If not given, uses up all the gap space
+        };
+        // Checks if there is enough space.
+        if next_start - prev_end < blocks {
+            return Err(Error::OutOfResources);
+        }
+        // Inserts the new entry.
+        entries[idx..].rotate_right(1);
+        let entry = &mut entries[idx];
+        assert!(entry.is_null());
+        entry.part_type = part_type;
+        entry.guid = unique_guid;
+        entry.flags = flags;
+        entry.first = prev_end;
+        entry.last = prev_end + blocks - 1;
+        for (idx, ele) in name.encode_utf16().enumerate() {
+            match idx < GPT_NAME_LEN_U16 {
+                true => entry.name[idx] = ele,
+                _ => break,
+            }
+        }
+        header.entries_count += 1;
+        Ok(())
+    }
+
+    /// Adds a partition.
+    ///
+    /// # Args
+    ///
+    /// * `name`: Name of the partition.
+    /// * `part_type`: Type GUID.
+    /// * `unique_guid`: Unique GUID.
+    /// * `flags`: Partition flag.
+    /// * `size`: If Some(_), specifies the size in number of bytes for the partition. The method
+    ///   will round it up to multiple of disk block size and search for the first large enough
+    ///   space in the unused spae for putting the partition. If None, the method will add the
+    ///   partition at the last and have it consume all remaining usable disk space.
+    pub fn add(
+        &mut self,
+        name: &str,
+        part_type: [u8; GPT_GUID_LEN],
+        unique_guid: [u8; GPT_GUID_LEN],
+        flags: u64,
+        size: Option<u64>,
+    ) -> Result<()> {
+        let (header, _) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
+        let entry_count = usize::try_from(header.entries_count).unwrap();
+        let search_start = size.is_some().then_some(0).unwrap_or(entry_count);
+        for i in search_start..entry_count + 1 {
+            if self.insert_before(i, name, part_type, unique_guid, flags, size).is_ok() {
+                return Ok(());
+            }
+        }
+        Err(Error::OutOfResources)
+    }
 
-/// Checks if a read/write range into a GPT partition overflows and returns the range's absolute
-/// offset in the block device.
-pub(crate) fn check_gpt_rw_params(
-    gpt_cache_buffer: &mut [u8],
-    part_name: &str,
-    offset: u64,
-    size: usize,
-) -> Result<u64> {
-    GptCache::from_existing(gpt_cache_buffer)?.check_range(part_name, offset, size)
+    /// Persists the constructed GPT table to the disk and syncs. The builder is consumed.
+    pub async fn persist(mut self) -> Result<()> {
+        let (mut header, mut entries) = LoadBufferRef::from(&mut self.gpt.buffer[..]).secondary();
+        header.update_entries_crc(entries.as_bytes());
+        // Check validity. Should not fail if implementation is correct.
+        check_header(self.disk.io(), &header, false).unwrap();
+        check_entries(&header, entries.as_bytes()).unwrap();
+        let blk_sz = self.disk.block_info().block_size;
+        // Writes to secondary header/ entries
+        self.disk.write(header.current * blk_sz, header.as_bytes_mut()).await?;
+        self.disk.write(header.entries * blk_sz, entries.as_bytes_mut()).await?;
+        // Clears primary header magic
+        self.disk.write(blk_sz, &mut 0u64.to_be_bytes()).await?;
+        // Re-syncs GPT
+        self.disk.sync_gpt(&mut self.gpt).await?.res()
+    }
 }
 
+/// Helper for calculcating the Crc32.
 fn crc32(data: &[u8]) -> u32 {
     let mut hasher = Hasher::new();
     hasher.update(data);
@@ -540,250 +1117,590 @@ fn crc32(data: &[u8]) -> u32 {
 #[cfg(test)]
 pub(crate) mod test {
     use super::*;
-    use gbl_storage_testlib::{
-        alignment_scratch_size, AsBlockDevice, BackingStore, TestBlockDevice,
-        TestBlockDeviceBuilder,
-    };
+    use crate::test::TestDisk;
+    use gbl_async::block_on;
+
+    /// A helper for creating a [TestDisk] from given data.
+    fn test_disk(data: impl AsRef<[u8]>) -> TestDisk {
+        // All tests cases use pre-generated GPT disk of 512 block size.
+        TestDisk::new_ram_alloc(512, 512, data.as_ref().to_vec()).unwrap()
+    }
 
-    /// Helper function to extract the gpt header from a test block device.
-    fn gpt(dev: &mut TestBlockDevice) -> GptCache {
-        let info = dev.info();
-        let (_, gpt) = dev.scratch.split_at_mut(alignment_scratch_size(info).unwrap());
-        GptCache::from_existing(gpt).unwrap()
+    /// A helper for creating a [TestDisk] from given data and a [Gpt] for 128 entries.
+    fn test_disk_and_gpt(data: impl AsRef<[u8]>) -> (TestDisk, GptMax) {
+        (test_disk(data), new_gpt_max())
     }
 
     #[test]
     fn test_load_and_sync() {
-        let mut dev: TestBlockDevice = include_bytes!("../test/gpt_test_1.bin").as_slice().into();
-        dev.sync_gpt().unwrap();
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        block_on(dev.sync_gpt(&mut gpt)).unwrap();
+
+        assert_eq!(gpt.partition_iter().unwrap().count(), 2);
+        gpt.find_partition("boot_a").unwrap();
+        gpt.find_partition("boot_b").unwrap();
+        assert!(gpt.find_partition("boot_c").is_err());
+
+        // Creating a new [Gpt] using the same buffer should reset the valid state.
+        let gpt = Gpt::new(gpt.buffer).unwrap();
+        assert!(gpt.partition_iter().is_err());
+        assert!(gpt.find_partition("boot_a").is_err());
+        assert!(gpt.find_partition("boot_b").is_err());
+    }
 
-        let gpt_cache = gpt(&mut dev);
-        assert_eq!(gpt_cache.partition_iter().count(), 2);
-        gpt_cache.find_partition("boot_a").unwrap();
-        gpt_cache.find_partition("boot_b").unwrap();
-        assert!(gpt_cache.find_partition("boot_c").is_err());
+    #[test]
+    fn test_load_with_unaligned_buffer() {
+        #[repr(align(8))]
+        struct AlignedBuffer([u8; 34 * 1024]);
+        let mut buffer = AlignedBuffer([0u8; 34 * 1024]);
+        let buffer = &mut buffer.0[1..];
+        assert_ne!(buffer.as_ptr() as usize % 2, 0);
+        let mut disk = test_disk(include_bytes!("../test/gpt_test_1.bin"));
+        let mut gpt = Gpt::new(buffer).unwrap();
+        block_on(disk.sync_gpt(&mut gpt)).unwrap();
     }
 
     #[test]
     fn test_gpt_buffer_too_small() {
-        let mut dev: TestBlockDevice = include_bytes!("../test/gpt_test_1.bin").as_slice().into();
-        dev.scratch = vec![0u8; dev.scratch.len() - 1];
-        assert!(dev.sync_gpt().is_err());
+        assert!(Gpt::new(vec![0u8; size_of::<GptLoadBufferN<0>>() - 1]).is_err());
     }
 
     #[test]
-    fn test_gpt_too_many_entries() {
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../test/gpt_test_1.bin"))
-            .set_max_gpt_entries(129)
-            .build();
-        assert!(dev.sync_gpt().is_err());
+    fn test_gpt_buffer_not_enough_for_all_entries() {
+        let mut dev = test_disk(include_bytes!("../test/gpt_test_1.bin"));
+        let mut gpt = new_gpt_n::<127>();
+        assert_eq!(gpt.max_entries(), 127);
+        // Actual entries_count is 128 in the GPT.
+        assert!(block_on(dev.sync_gpt(&mut gpt)).unwrap().res().is_err());
     }
 
     #[test]
-    fn test_load_gpt_primary() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let mut dev: TestBlockDevice = disk.as_slice().into();
-
-        // Corrupt secondary.
-        dev.io.storage[disk.len() - 512..].fill(0);
-        dev.sync_gpt().unwrap();
-
-        let gpt_cache = gpt(&mut dev);
-        assert_eq!(gpt_cache.partition_iter().count(), 2);
-        gpt_cache.find_partition("boot_a").unwrap();
-        gpt_cache.find_partition("boot_b").unwrap();
-        assert!(gpt_cache.find_partition("boot_c").is_err());
+    fn test_good_gpt_no_repair_write() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        assert_eq!(block_on(dev.sync_gpt(&mut gpt)).unwrap(), GptSyncResult::BothValid);
+    }
 
-        // Check that secondary is restored
-        assert_eq!(dev.io.storage, disk);
+    /// A helper for testing restoration of invalid primary/secondary header modified by caller.
+    fn test_gpt_sync_restore<'a>(
+        modify_primary: impl FnOnce(&mut GptHeader, Ref<&mut [u8], [GptEntry]>),
+        modify_secondary: impl FnOnce(&mut GptHeader, Ref<&mut [u8], [GptEntry]>),
+        expect_primary_err: Error,
+        expect_secondary_err: Error,
+    ) {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+
+        // Restores from secondary to primary.
+        let mut disk = disk_orig.to_vec();
+        let (header, entries) = (&mut disk[512..]).split_at_mut(512);
+        let mut header = GptHeader::from_bytes_mut(header);
+        modify_primary(&mut header, Ref::<_, [GptEntry]>::new_slice(entries).unwrap());
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        assert_ne!(dev.io().storage(), disk_orig);
+        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
+        assert_eq!(sync_res, GptSyncResult::PrimaryRestored(expect_primary_err));
+        assert_eq!(dev.io().storage(), disk_orig);
+
+        // Restores from primary to secondary.
+        let mut disk = disk_orig.to_vec();
+        let (entries, header) = (&mut disk[512..]).split_last_chunk_mut::<512>().unwrap();
+        let (_, entries) = entries.split_last_chunk_mut::<{ 512 * 32 }>().unwrap();
+        let mut header = GptHeader::from_bytes_mut(&mut header[..]);
+        modify_secondary(&mut header, Ref::<_, [GptEntry]>::new_slice(&mut entries[..]).unwrap());
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        assert_ne!(dev.io().storage(), disk_orig);
+        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
+        assert_eq!(sync_res, GptSyncResult::SecondaryRestored(expect_secondary_err));
+        assert_eq!(dev.io().storage(), disk_orig);
     }
 
     #[test]
-    fn test_load_gpt_secondary() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let mut dev: TestBlockDevice = disk.as_slice().into();
+    fn test_sync_gpt_incorrect_magic() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.magic = 0x123456;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::IncorrectMagic(0x123456));
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        // Corrupt primary.
-        dev.io.storage[512..1024].fill(0);
-        dev.sync_gpt().unwrap();
+    #[test]
+    fn test_sync_gpt_incorrect_crc() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.crc32 = !hdr.crc32;
+        }
+        let err = Error::GptError(GptError::IncorrectHeaderCrc);
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        let gpt_cache = gpt(&mut dev);
-        assert_eq!(gpt_cache.partition_iter().count(), 2);
-        gpt_cache.find_partition("boot_a").unwrap();
-        gpt_cache.find_partition("boot_b").unwrap();
+    #[test]
+    fn test_sync_gpt_unexpected_header_size() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.size += 1;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::UnexpectedHeaderSize { actual: 93, expect: 92 });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        // Check that primary is restored
-        assert_eq!(dev.io.storage, disk);
+    #[test]
+    fn test_sync_gpt_unexpected_entry_size() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.entries_size += 1;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::UnexpectedEntrySize { actual: 129, expect: 128 });
+        test_gpt_sync_restore(modify, modify, err, err);
     }
 
     #[test]
-    fn test_good_gpt_no_repair_write() {
-        let mut dev: TestBlockDevice = include_bytes!("../test/gpt_test_1.bin").as_slice().into();
-        dev.sync_gpt().unwrap();
+    fn test_sync_gpt_first_usable_gt_last() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.first = hdr.last;
+            hdr.last = hdr.first - 2;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
+            first: 94,
+            last: 92,
+            range: (34, 94),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        assert_eq!(dev.io.num_writes, 0);
+    #[test]
+    fn test_sync_gpt_first_usable_out_of_range() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.first = 33;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
+            first: 33,
+            last: 94,
+            range: (34, 94),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
     }
 
     #[test]
-    fn test_load_gpt_incorrect_magic() {
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let mut dev = TestBlockDeviceBuilder::new().set_data(disk).build();
-        dev.sync_gpt().unwrap();
+    fn test_sync_gpt_last_usable_out_of_range() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.last += 1;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::InvalidFirstLastUsableBlock {
+            first: 34,
+            last: 95,
+            range: (34, 94),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        let gpt = gpt(&mut dev);
-        let primary_header = &mut gpt.primary_header[..GPT_HEADER_SIZE.try_into().unwrap()];
-        let gpt_header = GptHeader::from_bytes(primary_header);
-        gpt_header.magic = 0x123456;
-        gpt_header.update_crc();
-        let primary_header = Vec::from(primary_header);
-        dev.io.storage[512..512 + primary_header.len()].clone_from_slice(&primary_header);
+    #[test]
+    fn test_sync_gpt_primary_entries_out_of_range() {
+        test_gpt_sync_restore(
+            |hdr, _| {
+                hdr.entries = 1;
+                hdr.update_crc();
+            },
+            |hdr, _| {
+                hdr.entries = hdr.last;
+                hdr.update_crc();
+            },
+            Error::GptError(GptError::InvalidPrimaryEntriesStart {
+                value: 1,
+                expect_range: (2, 2),
+            }),
+            Error::GptError(GptError::InvalidSecondaryEntriesStart {
+                value: 94,
+                expect_range: (95, 95),
+            }),
+        );
+    }
 
-        dev.sync_gpt().unwrap();
+    #[test]
+    fn test_sync_gpt_incorrect_entry_crc() {
+        fn modify(hdr: &mut GptHeader, _: Ref<&mut [u8], [GptEntry]>) {
+            hdr.entries_crc = !hdr.entries_crc;
+            hdr.update_crc();
+        }
+        let err = Error::GptError(GptError::IncorrectEntriesCrc);
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        // Check that incorrect magic header is restored
-        assert_eq!(dev.io.storage, disk);
+    #[test]
+    fn test_sync_gpt_partition_range_overflow() {
+        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
+            entries[1].last = hdr.last + 1;
+            hdr.update_entries_crc(entries.as_bytes());
+        }
+        let err = Error::GptError(GptError::InvalidPartitionRange {
+            idx: 2,
+            part_range: (50, 95),
+            usable_range: (34, 94),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
     }
 
     #[test]
-    fn test_load_gpt_exceeds_max_entries() {
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../test/gpt_test_1.bin"))
-            .set_max_gpt_entries(127)
-            .build();
+    fn test_sync_gpt_invalid_partition_range() {
+        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
+            entries[1].first = entries[1].last;
+            entries[1].last = entries[1].first - 2;
+            hdr.update_entries_crc(entries.as_bytes());
+        }
+        let err = Error::GptError(GptError::InvalidPartitionRange {
+            idx: 2,
+            part_range: (73, 71),
+            usable_range: (34, 94),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        assert!(dev.sync_gpt().is_err());
+    #[test]
+    fn test_sync_gpt_partition_overlap() {
+        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
+            entries[0].last = entries[1].first;
+            entries.swap(0, 1);
+            hdr.update_entries_crc(entries.as_bytes());
+        }
+        let err = Error::GptError(GptError::PartitionRangeOverlap {
+            prev: (2, 34, 50),
+            next: (1, 50, 73),
+        });
+        test_gpt_sync_restore(modify, modify, err, err);
     }
 
     #[test]
-    fn test_load_gpt_non_max_entries() {
-        // Create a header with non-max entries_count
-        let disk = include_bytes!("../test/gpt_test_1.bin");
-        let mut dev = TestBlockDeviceBuilder::new().set_data(disk).build();
-        let block_size: usize = dev.io.block_size.try_into().unwrap();
-        dev.sync_gpt().unwrap();
+    fn test_sync_gpt_zero_partition_type_guid() {
+        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
+            entries[1].part_type = [0u8; GPT_GUID_LEN];
+            hdr.update_entries_crc(entries.as_bytes());
+        }
+        let err = Error::GptError(GptError::ZeroPartitionTypeGUID { idx: 2 });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        let gpt = gpt(&mut dev);
-        let primary_header = &mut gpt.primary_header[..GPT_HEADER_SIZE.try_into().unwrap()];
-        let gpt_header = GptHeader::from_bytes(primary_header);
-        gpt_header.entries_count = 2;
-        // Update entries crc32
-        gpt_header.entries_crc =
-            crc32(&gpt.primary_entries[..(2 * GPT_ENTRY_SIZE).try_into().unwrap()]);
-        gpt_header.update_crc();
-        // Update to primary.
-        let primary_header = Vec::from(primary_header);
-        dev.io.storage[block_size..block_size + primary_header.len()]
-            .clone_from_slice(&primary_header);
+    #[test]
+    fn test_sync_gpt_zero_partition_unique_guid() {
+        fn modify(hdr: &mut GptHeader, mut entries: Ref<&mut [u8], [GptEntry]>) {
+            entries[1].guid = [0u8; GPT_GUID_LEN];
+            hdr.update_entries_crc(entries.as_bytes());
+        }
+        let err = Error::GptError(GptError::ZeroPartitionUniqueGUID { idx: 2 });
+        test_gpt_sync_restore(modify, modify, err, err);
+    }
 
-        // Corrupt secondary. Sync ok
-        dev.io.storage[disk.len() - block_size..].fill(0);
-        dev.sync_gpt().unwrap();
+    #[test]
+    fn test_load_gpt_disk_primary_override_secondary() {
+        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
+        // Modifies secondary header.
+        let secondary_hdr = GptHeader::from_bytes_mut(disk.last_chunk_mut::<512>().unwrap());
+        secondary_hdr.revision = !secondary_hdr.revision;
+        secondary_hdr.update_crc();
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        assert_eq!(
+            block_on(dev.sync_gpt(&mut gpt)).unwrap(),
+            GptSyncResult::SecondaryRestored(Error::GptError(GptError::DifferentFromPrimary)),
+        );
+    }
 
-        // Corrup primary. Sync ok
-        dev.io.storage[block_size..(block_size * 2)].fill(0);
-        dev.sync_gpt().unwrap();
+    #[test]
+    fn test_load_gpt_disk_too_small() {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Resizes so that it's not enough to hold a full 128 maximum entries.
+        // MBR + (header + entries) * 2 - 1
+        disk.resize((1 + (32 + 1) * 2 - 1) * 512, 0);
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        let sync_res = block_on(dev.sync_gpt(&mut gpt)).unwrap();
+        let err = Error::GptError(GptError::DiskTooSmall);
+        assert_eq!(sync_res, GptSyncResult::NoValidGpt { primary: err, secondary: err });
     }
 
     #[test]
     fn test_uninitialized_gpt() {
+        let disk = include_bytes!("../test/gpt_test_1.bin");
         // Load a good GPT first.
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../test/gpt_test_1.bin"))
-            .build();
-        dev.sync_gpt().unwrap();
-        dev.io.storage[..64 * 1024].fill(0);
-        // Load a bad GPT. Validate that the valid state is reset.
-        assert!(dev.sync_gpt().is_err());
-        assert!(gpt(&mut dev).find_partition("").is_err());
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        assert_eq!(block_on(dev.sync_gpt(&mut gpt)).unwrap(), GptSyncResult::BothValid);
+        gpt.find_partition("boot_a").unwrap();
+        // Corrupt GPT.
+        block_on(dev.write(0, &mut vec![0u8; disk.len()])).unwrap();
+        assert!(block_on(dev.sync_gpt(&mut gpt)).unwrap().res().is_err());
+        assert!(gpt.find_partition("").is_err());
+    }
+
+    #[test]
+    fn test_update_gpt() {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Erases all GPT headers.
+        disk[512..][..512].fill(0);
+        disk.last_chunk_mut::<512>().unwrap().fill(0);
+
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+
+        assert_ne!(dev.io().storage(), disk_orig);
+        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
+        block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)).unwrap();
+        assert_eq!(dev.io().storage(), disk_orig);
+    }
+
+    #[test]
+    fn test_update_gpt_has_existing_valid_secondary() {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Erases all GPT headers.
+        disk[512..][..512].fill(0);
+        // Leaves a valid but different secondary GPT.
+        let secondary_hdr = GptHeader::from_bytes_mut(disk.last_chunk_mut::<512>().unwrap());
+        secondary_hdr.revision = !secondary_hdr.revision;
+        secondary_hdr.update_crc();
+
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+
+        assert_ne!(dev.io().storage(), disk_orig);
+        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
+        block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)).unwrap();
+        assert_eq!(dev.io().storage(), disk_orig);
     }
 
     #[test]
-    fn test_gpt_read() {
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../test/gpt_test_1.bin"))
-            .build();
-        dev.sync_gpt().unwrap();
+    fn test_update_gpt_last_usable_adjusted() {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Erases all GPT headers.
+        disk[512..][..512].fill(0);
+        disk.last_chunk_mut::<512>().unwrap().fill(0);
+        // Doubles the disk size.
+        disk.resize(disk_orig.len() * 2, 0);
+
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+
+        assert_ne!(dev.io().storage, disk_orig);
+        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
+        block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).unwrap();
+        let expected_last = (disk.len() - GPT_MAX_NUM_ENTRIES_SIZE - 512) / 512 - 1;
+
+        let (primary, secondary) = dev.io().storage().split_last_chunk_mut::<512>().unwrap();
+        let primary_hdr = GptHeader::from_bytes_mut(&mut primary[512..]);
+        let secondary_hdr = GptHeader::from_bytes_mut(secondary);
+        // Header's last usable block is updated.
+        assert_eq!({ primary_hdr.last }, expected_last.try_into().unwrap());
+        assert_eq!({ primary_hdr.backup }, (disk.len() / 512 - 1).try_into().unwrap());
+        assert_eq!({ secondary_hdr.last }, expected_last.try_into().unwrap());
+    }
 
-        let expect_boot_a = include_bytes!("../test/boot_a.bin");
-        let expect_boot_b = include_bytes!("../test/boot_b.bin");
+    #[test]
+    fn test_update_gpt_resize() {
+        let disk_orig = include_bytes!("../test/gpt_test_1.bin");
+        let mut disk = disk_orig.to_vec();
+        // Erases all GPT headers.
+        disk[512..][..512].fill(0);
+        disk.last_chunk_mut::<512>().unwrap().fill(0);
+        // Doubles the disk size.
+        disk.resize(disk_orig.len() * 2, 0);
+
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+
+        assert_ne!(dev.io().storage, disk_orig);
+        let mut mbr_primary = disk_orig[..34 * 512].to_vec();
+        block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).unwrap();
+        // Last entry is extended.
+        let expected_last = (disk.len() - GPT_MAX_NUM_ENTRIES_SIZE - 512) / 512 - 1;
+        assert_eq!({ gpt.entries().unwrap()[1].last }, expected_last.try_into().unwrap());
+    }
 
-        let mut actual_boot_a = vec![0u8; expect_boot_a.len()];
-        let mut actual_boot_b = vec![0u8; expect_boot_b.len()];
+    #[test]
+    fn test_update_gpt_new_partition_out_of_range() {
+        // `gpt_test_1.bin` has a 8k "boot_a" and a 12k "boot_b". Thus partitions space is 40
+        // blocks (512 bytes block size) and in total the GPT disk needs (40 + 1 + (33) * 2) = 107
+        // blocks.
+        let (mut dev, mut gpt) = test_disk_and_gpt(&vec![0u8; 106 * 512]);
+        let mut mbr_primary = include_bytes!("../test/gpt_test_1.bin")[..34 * 512].to_vec();
+        assert!(block_on(dev.update_gpt(&mut mbr_primary, true, &mut gpt)).is_err());
+    }
 
-        dev.read_gpt_partition("boot_a", 0, &mut actual_boot_a).unwrap();
-        assert_eq!(expect_boot_a.to_vec(), actual_boot_a);
-        // partial read
-        actual_boot_a = actual_boot_a[1..].to_vec();
-        dev.read_gpt_partition("boot_a", 1, &mut actual_boot_a).unwrap();
-        assert_eq!(expect_boot_a[1..].to_vec(), actual_boot_a);
+    #[test]
+    fn test_update_gpt_buffer_truncated() {
+        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+
+        // Less than 1 MBR block.
+        assert_eq!(
+            block_on(dev.update_gpt(&mut disk[..511], false, &mut gpt)),
+            Err(Error::BufferTooSmall(Some(1024)))
+        );
+
+        // Less than MBR + GPT header.
+        assert_eq!(
+            block_on(dev.update_gpt(&mut disk[..1023], false, &mut gpt)),
+            Err(Error::BufferTooSmall(Some(1024)))
+        );
+
+        // Less than MBR + GPT header + entries.
+        assert_eq!(
+            block_on(dev.update_gpt(&mut disk[..34 * 512 - 1], false, &mut gpt)),
+            Err(Error::BufferTooSmall(Some(34 * 512)))
+        );
+    }
 
-        dev.read_gpt_partition("boot_b", 0, &mut actual_boot_b).unwrap();
-        assert_eq!(expect_boot_b.to_vec(), actual_boot_b);
-        // partial read
-        actual_boot_b = actual_boot_b[1..].to_vec();
-        dev.read_gpt_partition("boot_b", 1, &mut actual_boot_b).unwrap();
-        assert_eq!(expect_boot_b[1..].to_vec(), actual_boot_b);
+    #[test]
+    fn test_update_gpt_check_header_fail() {
+        let disk = include_bytes!("../test/gpt_test_1.bin");
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        let mut mbr_primary = disk[..34 * 512].to_vec();
+        // Corrupts the first byte of the GPT header.
+        mbr_primary[512] = !mbr_primary[512];
+        assert_eq!(
+            block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)),
+            Err(Error::GptError(GptError::IncorrectMagic(0x54524150204946BA)))
+        );
     }
 
     #[test]
-    fn test_gpt_write() {
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../test/gpt_test_1.bin"))
-            .build();
-        dev.sync_gpt().unwrap();
+    fn test_update_gpt_check_entries_fail() {
+        let disk = include_bytes!("../test/gpt_test_1.bin");
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        let mut mbr_primary = disk[..34 * 512].to_vec();
+        // Corrupts the first byte of the entries.
+        mbr_primary[1024] = !mbr_primary[1024];
+        assert_eq!(
+            block_on(dev.update_gpt(&mut mbr_primary, false, &mut gpt)),
+            Err(Error::GptError(GptError::IncorrectEntriesCrc))
+        );
+    }
 
-        let mut expect_boot_a = include_bytes!("../test/boot_a.bin").to_vec();
-        expect_boot_a.reverse();
-        let mut expect_boot_b = include_bytes!("../test/boot_b.bin").to_vec();
-        expect_boot_b.reverse();
+    #[test]
+    fn test_erase_gpt_no_gpt() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(&[0u8; 1024 * 1024]);
+        block_on(dev.erase_gpt(&mut gpt)).unwrap();
+    }
 
-        let mut actual_boot_a = vec![0u8; expect_boot_a.len()];
-        let mut actual_boot_b = vec![0u8; expect_boot_b.len()];
+    #[test]
+    fn test_erase_gpt() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        block_on(dev.erase_gpt(&mut gpt)).unwrap();
+        const GPT_SECTOR: usize = 33 * 512;
+        assert_eq!(dev.io().storage[512..][..GPT_SECTOR], vec![0u8; GPT_SECTOR]);
+        assert_eq!(*dev.io().storage.last_chunk::<GPT_SECTOR>().unwrap(), *vec![0u8; GPT_SECTOR]);
+        assert!(matches!(
+            block_on(dev.sync_gpt(&mut gpt)).unwrap(),
+            GptSyncResult::NoValidGpt { .. }
+        ));
+    }
 
-        // "boot_a" partition
-        // Mutable version
-        dev.write_gpt_partition("boot_a", 0, expect_boot_a.as_mut_slice()).unwrap();
-        dev.read_gpt_partition("boot_a", 0, &mut actual_boot_a).unwrap();
-        assert_eq!(expect_boot_a.to_vec(), actual_boot_a);
-        // Mutable version, partial write.
-        dev.write_gpt_partition("boot_a", 1, expect_boot_a[1..].as_mut()).unwrap();
-        dev.read_gpt_partition("boot_a", 1, &mut actual_boot_a[1..]).unwrap();
-        assert_eq!(expect_boot_a[1..], actual_boot_a[1..]);
+    #[test]
+    fn test_zero_partition_size() {
+        let disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        assert_eq!(builder.remove("boot_a"), Ok(true));
+        assert_eq!(builder.remove("boot_b"), Ok(true));
+        builder.add("boot_b", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(0)).unwrap();
+        block_on(builder.persist()).unwrap();
+        assert_eq!(gpt.partition_iter().unwrap().next().unwrap().size().unwrap(), 0);
+    }
 
-        // "boot_b" partition
-        // Mutable version
-        dev.write_gpt_partition("boot_b", 0, expect_boot_b.as_mut_slice()).unwrap();
-        dev.read_gpt_partition("boot_b", 0, &mut actual_boot_b).unwrap();
-        assert_eq!(expect_boot_b.to_vec(), actual_boot_b);
-        // Mutable version, partial write.
-        dev.write_gpt_partition("boot_b", 1, expect_boot_b[1..].as_mut()).unwrap();
-        dev.read_gpt_partition("boot_b", 1, &mut actual_boot_b[1..]).unwrap();
-        assert_eq!(expect_boot_b[1..], actual_boot_b[1..]);
+    #[test]
+    fn test_sync_gpt_non_sorted_entries() {
+        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
+        let (header, entries) = disk[512..].split_at_mut(512);
+        let header = GptHeader::from_bytes_mut(header);
+        let mut entries = Ref::<_, [GptEntry]>::new_slice(entries).unwrap();
+        // Makes partition non-sorted.
+        entries.swap(0, 1);
+        header.update_entries_crc(entries.as_bytes());
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
     }
 
     #[test]
-    fn test_gpt_rw_overflow() {
-        let mut dev = TestBlockDeviceBuilder::new()
-            .set_data(include_bytes!("../../libstorage/test/gpt_test_1.bin"))
-            .build();
-        dev.sync_gpt().unwrap();
+    fn test_gpt_builder_initialize_gpt_if_no_valid_gpt() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(vec![0u8; 1024 * 1024]);
+        let (builder, valid) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        assert!(!valid);
+        block_on(builder.persist()).unwrap();
+        // A new GPT is created.
+        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
+        assert!(gpt.partition_iter().unwrap().next().is_none());
+    }
 
-        let mut boot_a = [0u8; include_bytes!("../test/boot_a.bin").len()];
-        let mut boot_b = [0u8; include_bytes!("../test/boot_b.bin").len()];
+    #[test]
+    fn test_gpt_builder_remove_partition() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        let (mut builder, valid) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        assert!(valid);
+        assert_eq!(builder.remove("boot_b"), Ok(true));
+        assert_eq!(builder.remove("non-existent"), Ok(false));
+        block_on(builder.persist()).unwrap();
+        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
+        let part_iter = gpt.partition_iter().unwrap();
+        assert_eq!(
+            part_iter.map(|v| v.name().unwrap().into()).collect::<Vec<String>>(),
+            ["boot_a"]
+        );
+    }
 
-        assert!(dev.read_gpt_partition("boot_a", 1, &mut boot_a).is_err());
-        assert!(dev.write_gpt_partition("boot_a", 1, boot_a.as_mut_slice()).is_err());
+    #[test]
+    fn test_gpt_builder_add_partition_find_first() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        assert!(builder.remove("boot_a").unwrap());
+        // Adds at the beginning.
+        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
+        // Adds following "new_0"
+        builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1)).unwrap();
+        block_on(builder.persist()).unwrap();
+        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
+        assert_eq!(gpt.find_partition("new_0").unwrap().absolute_range().unwrap(), (17408, 18432));
+        assert_eq!(gpt.find_partition("new_1").unwrap().absolute_range().unwrap(), (18432, 18944));
+        assert_eq!(gpt.find_partition("boot_b").unwrap().absolute_range().unwrap(), (25600, 37888));
+    }
 
-        assert!(dev.read_gpt_partition("boot_b", 1, &mut boot_b).is_err());
-        assert!(dev.write_gpt_partition("boot_b", 1, boot_b.as_mut_slice()).is_err());
+    #[test]
+    fn test_gpt_builder_non_sorted_add_partition() {
+        let mut disk = include_bytes!("../test/gpt_test_1.bin").to_vec();
+        let (mut dev, mut gpt) = test_disk_and_gpt(&disk);
+        let (header, entries) = disk[512..].split_at_mut(512);
+        let header = GptHeader::from_bytes_mut(header);
+        let mut entries = Ref::<_, [GptEntry]>::new_slice(entries).unwrap();
+        // Makes partition non-sorted.
+        entries.swap(0, 1);
+        header.update_entries_crc(entries.as_bytes());
+
+        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        // Adds following boot_b.
+        builder.add("new", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
+        block_on(builder.persist()).unwrap();
+        assert_eq!(gpt.find_partition("boot_a").unwrap().absolute_range().unwrap(), (17408, 25600));
+        assert_eq!(gpt.find_partition("boot_b").unwrap().absolute_range().unwrap(), (25600, 37888));
+        assert_eq!(gpt.find_partition("new").unwrap().absolute_range().unwrap(), (37888, 38912));
     }
 
     #[test]
-    fn test_zero_partition_size() {
-        let mut dev =
-            TestBlockDeviceBuilder::new().add_partition("zero_size", BackingStore::Size(0)).build();
-        dev.sync_gpt().unwrap();
-        assert_eq!(gpt(&mut dev).partition_iter().next().unwrap().size().unwrap(), 0);
+    fn test_gpt_builder_add_partition_append() {
+        let (mut dev, mut gpt) = test_disk_and_gpt(include_bytes!("../test/gpt_test_1.bin"));
+        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        assert!(builder.remove("boot_b").unwrap());
+        // Adds following "boot_a".
+        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
+        // Consumes the rest of the space.
+        builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).unwrap();
+        block_on(builder.persist()).unwrap();
+        block_on(dev.sync_gpt(&mut gpt)).unwrap().res().unwrap();
+        assert_eq!(gpt.find_partition("boot_a").unwrap().absolute_range().unwrap(), (17408, 25600));
+        assert_eq!(gpt.find_partition("new_0").unwrap().absolute_range().unwrap(), (25600, 26624));
+        assert_eq!(gpt.find_partition("new_1").unwrap().absolute_range().unwrap(), (26624, 48640));
+    }
+
+    #[test]
+    fn test_gpt_builder_not_enough_resource() {
+        // Create a Gpt that can only load 1 entry.
+        let mut gpt = new_gpt_n::<1>();
+        let mut dev = test_disk(vec![0u8; 64 * 1024]);
+        let (mut builder, _) = GptBuilder::new(&mut dev, &mut gpt).unwrap();
+        builder.add("new_0", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, Some(1024)).unwrap();
+        assert!(builder.add("new_1", [1u8; GPT_GUID_LEN], [1u8; GPT_GUID_LEN], 0, None).is_err());
     }
 }
diff --git a/gbl/libstorage/src/lib.rs b/gbl/libstorage/src/lib.rs
index 13a7922..1f4c8b7 100644
--- a/gbl/libstorage/src/lib.rs
+++ b/gbl/libstorage/src/lib.rs
@@ -12,112 +12,36 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-//! APIs for reading/writing with non-block-aligned ranges and unaligned buffer.
-//!
-//! Most block devices require reading/writing in the unit of block and that the input/output
-//! buffer satisfies certain alignment (i.e. DMA). This library provides APIs that build on top
-//! of them and relax these constraints. The library supports reading/writing raw block content
-//! as well as parsing/reading/writing GPT partitions.
-//!
-//! # Examples
-//!
-//! ```rust
-//! use gbl_storage::{
-//!     AsBlockDevice, BlockIoSync, BlockDevice, required_scratch_size, BlockInfo,
-//! };
-//!
-//! /// Mocks a block device using a buffer.
-//! pub struct RamBlockIo {
-//!     storage: std::vec::Vec<u8>,
-//! }
-//!
-//! use liberror::Error;
-//!
-//! impl BlockIoSync for RamBlockIo {
-//!
-//!     fn info(&mut self) -> BlockInfo {
-//!         BlockInfo {
-//!             block_size: 512,
-//!             num_blocks: self.storage.len() as u64 / 512,
-//!             alignment: 64,
-//!         }
-//!     }
-//!
-//!     fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<(), Error> {
-//!         let start = blk_offset * self.info().block_size;
-//!         let end = start + out.len() as u64;
-//!         out.clone_from_slice(&self.storage[start as usize..end as usize]);
-//!         Ok(())
-//!     }
-//!
-//!     fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
-//!         let start = blk_offset * self.info().block_size;
-//!         let end = start + data.len() as u64;
-//!         self.storage[start as usize..end as usize].clone_from_slice(&data);
-//!         Ok(())
-//!     }
-//! }
-//!
-//! const MAX_GPT_ENTRIES: u64 = 128;
-//!
-//! let mut ram_block_io = RamBlockIo { storage: vec![0u8; 64 * 1024] };
-//! // Prepare a scratch buffer, size calculated with `required_scratch_size()`.
-//! let mut scratch =
-//!     vec![0u8; required_scratch_size(ram_block_io.info(), MAX_GPT_ENTRIES).unwrap()];
-//! // Create a `BlockDevice`
-//! let mut ram_block_dev =
-//!     BlockDevice::new(&mut ram_block_io, &mut scratch[..], MAX_GPT_ENTRIES);
-//!
-//! // Read/write with arbitrary range and buffer without worrying about alignment.
-//! let mut out = vec![0u8; 1234];
-//! ram_block_dev.read(4321, &mut out[..]).unwrap();
-//! let mut data = vec![0u8; 5678];
-//! // Mutable input. More efficient
-//! ram_block_dev.write(8765, data.as_mut_slice()).unwrap();
-//!
-//! // Sync GPT
-//! let _ = ram_block_dev.sync_gpt();
-//! // Access GPT entries
-//! let _ = ram_block_dev.find_partition("some-partition");
-//! // Read/Write GPT partitions with arbitrary offset, size, buffer
-//! let _ = ram_block_dev.read_gpt_partition("partition", 4321, &mut out[..]);
-//! let _ = ram_block_dev.write_gpt_partition("partition", 8765, data.as_mut_slice());
-//!
-//! // Alterantively, you can also define a custom type that internally owns and binds the
-//! // implementation of `BlockIoSync` and scratch buffer together, and then implement the
-//! // `AsBlockDevice` trait. This gives a cleaner management of resources.
-//! pub struct OwnedBlockDevice {
-//!     io: RamBlockIo,
-//!     scratch: std::vec::Vec<u8>,
-//! }
-//!
-//! impl AsBlockDevice for OwnedBlockDevice {
-//!     fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
-//!         f(&mut self.io, &mut self.scratch[..], MAX_GPT_ENTRIES)
-//!     }
-//! }
-//!
-//! // `owned_block_dev` has the same APIs as `BlockDevice`.
-//! let mut owned_block_dev = OwnedBlockDevice { io: ram_block_io, scratch: scratch };
-//! ```
+//! The library provides APIs for reading/writing with block devices with arbitrary alignment,
+//! ranges and parsing and manipulation GPT.
 
 #![cfg_attr(not(test), no_std)]
 #![allow(async_fn_in_trait)]
 
-use gbl_async::block_on;
+use core::{
+    cell::RefMut,
+    cmp::{max, min},
+    mem::{size_of_val, MaybeUninit},
+    ops::DerefMut,
+    slice::SliceIndex,
+};
+use liberror::{Error, Result};
+use libutils::aligned_subslice;
+use safemath::SafeNum;
 
 // Selective export of submodule types.
 mod gpt;
-use gpt::check_gpt_rw_params;
 pub use gpt::{
-    GptCache, GptEntry, GptHeader, Partition, PartitionIterator, GPT_MAGIC, GPT_NAME_LEN_U16,
+    gpt_buffer_size, new_gpt_max, new_gpt_n, Gpt, GptBuilder, GptEntry, GptHeader, GptLoadBufferN,
+    GptMax, GptN, GptSyncResult, Partition, PartitionIterator, GPT_GUID_LEN, GPT_MAGIC,
+    GPT_NAME_LEN_U16,
 };
-use safemath::SafeNum;
 
 mod algorithm;
-pub use algorithm::{read_async, write_async, AsyncAsSync, SyncAsAsync};
+pub use algorithm::{read_async, write_async};
 
-use liberror::{Error, Result};
+pub mod ram_block;
+pub use ram_block::RamBlockIo;
 
 /// `BlockInfo` contains information for a block device.
 #[derive(Clone, Copy, Debug)]
@@ -139,8 +63,14 @@ impl BlockInfo {
     }
 }
 
-/// `BlockIoAsync` provides interfaces for asynchronous read and write.
-pub trait BlockIoAsync {
+/// `BlockIo` provides interfaces for reading and writing block storage medium.
+///
+/// SAFETY:
+/// `read_blocks` method must guarantee `out` to be fully initialized on success. Otherwise error
+/// must be returned.
+/// This is necessary because unsafe code that uses BlockIo assumes `out` to be fully initialized to
+/// work with it as with `&mut [u8]`.
+pub unsafe trait BlockIo {
     /// Returns the `BlockInfo` for this block device.
     fn info(&mut self) -> BlockInfo;
 
@@ -156,7 +86,11 @@ pub trait BlockIoAsync {
     /// # Returns
     ///
     /// Returns true if exactly out.len() number of bytes are read. Otherwise false.
-    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()>;
+    async fn read_blocks(
+        &mut self,
+        blk_offset: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()>;
 
     /// Write blocks of data to the block device
     ///
@@ -173,29 +107,45 @@ pub trait BlockIoAsync {
     async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()>;
 }
 
-impl<T: BlockIoAsync> BlockIoAsync for &mut T {
+// SAFETY:
+// `read_blocks` method has same guaranties as `BlockIo` implementation of referenced type T.
+// Which guaranties `out` to be fully initialized on success.
+unsafe impl<T: DerefMut> BlockIo for T
+where
+    T::Target: BlockIo,
+{
     fn info(&mut self) -> BlockInfo {
-        (*self).info()
+        self.deref_mut().info()
     }
 
-    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        (*self).read_blocks(blk_offset, out).await
+    async fn read_blocks(
+        &mut self,
+        blk_offset: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
+        self.deref_mut().read_blocks(blk_offset, out).await
     }
 
     async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        (*self).write_blocks(blk_offset, data).await
+        self.deref_mut().write_blocks(blk_offset, data).await
     }
 }
 
-/// An implementation of `BlockIoAsync` of where all required methods are `unimplemented!()`
+/// An implementation of `BlockIo` of where all required methods are `unimplemented!()`
 pub struct BlockIoNull {}
 
-impl BlockIoAsync for BlockIoNull {
+// SAFETY:
+// `read_blocks` never succeeds since it is not implemented and will panic.
+unsafe impl BlockIo for BlockIoNull {
     fn info(&mut self) -> BlockInfo {
         unimplemented!();
     }
 
-    async fn read_blocks(&mut self, _: u64, _: &mut [u8]) -> Result<()> {
+    async fn read_blocks(
+        &mut self,
+        _: u64,
+        _: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
         unimplemented!();
     }
 
@@ -204,327 +154,27 @@ impl BlockIoAsync for BlockIoNull {
     }
 }
 
-/// `BlockIoSync` provide interfaces for synchronous read and write.
-pub trait BlockIoSync {
-    /// Gets the `BlockInfo` for this block device
-    fn info(&mut self) -> BlockInfo;
-
-    /// Read blocks of data from the block device
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    ///
-    /// * `out`: Buffer to store the read data. Callers of this method ensure that it is
-    ///   aligned according to alignment() and `out.len()` is multiples of `block_size()`.
-    ///
-    /// # Returns
-    ///
-    /// Returns true if exactly out.len() number of bytes are read. Otherwise false.
-    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()>;
-
-    /// Write blocks of data to the block device
-    ///
-    /// # Args
-    ///
-    /// * `blk_offset`: Offset in number of blocks.
-    ///
-    /// * `data`: Data to write. Callers of this method ensure that it is aligned according to
-    ///   `alignment()` and `data.len()` is multiples of `block_size()`.
-    ///
-    /// # Returns
-    ///
-    /// Returns true if exactly data.len() number of bytes are written. Otherwise false.
-    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()>;
-}
-
-impl BlockIoSync for &mut dyn BlockIoSync {
-    fn info(&mut self) -> BlockInfo {
-        (*self).info()
-    }
-
-    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        (*self).read_blocks(blk_offset, out)
-    }
-
-    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        (*self).write_blocks(blk_offset, data)
-    }
-}
-
-impl<T: BlockIoAsync> BlockIoSync for T {
-    fn info(&mut self) -> BlockInfo {
-        (*self).info()
-    }
-
-    fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        block_on((*self).read_blocks(blk_offset, out))
-    }
-
-    fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        block_on((*self).write_blocks(blk_offset, data))
-    }
-}
-
-/// `AsBlockDevice` provides APIs for synchronous read/write of raw block storage or GPT
-/// partitions.
-///
-/// Users that need to perform asynchronous non-blocking read/write should use
-/// `read_async`, `write_async` APIs instead.
-pub trait AsBlockDevice {
-    /// Runs the provided closure `f` with the following parameters:
-    ///
-    ///   1. An implementation of block IO `&mut dyn BlockIoSync`.
-    ///   2. A scratch buffer `&mut [u8]`.
-    ///   3. A `u64` specifying the maximum allowed number of GPT entries.
-    ///
-    /// * The scratch buffer is internally used for two purposes: 1. to handle read/write with
-    ///   offset, size that are not multiples of block size or input/output buffer that are not
-    ///   aligned, and 2. to load and sync GPT headers.
-    ///
-    /// * The necessary size for the scratch buffer depends on `BlockInfo::alignment`,
-    ///   `BlockInfo::block_size` and maximum allowed GPT entries. It can be computed using the
-    ///   helper API `required_scratch_size()`. If maximum allowed GPT entries is 0, GPT is
-    ///   considered unavailable and no buffer will be reserved for GPT headers. If additionally,
-    ///   `BlockIoSync` has no alignment requirement, i.e. both alignment and block size are 1, the
-    ///   total required scratch size is 0.
-    ///
-    /// * GPT headers will be cached in the scratch buffer after calling `Self::sync_gpt()` and
-    ///   returning success. Subsequent call of `Self:read_gpt_partiton()`,
-    ///   `Self::write_gpt_partition()`, and `Self::write_gpt_partition()`
-    ///   will look up partition entries from the cached GPT header.
-    ///   Thus callers should make sure to always return the same scratch buffer and avoid
-    ///   modifying its content.
-    ///
-    /// * A smaller value of maximum allowed GPT entries gives smaller required scratch buffer
-    ///   size. However if the `entries_count` field in the GPT header is greater than this value,
-    ///   GPT parsing will fail. Note that most tools and OS fix the `entries_count` value to the
-    ///   max value 128 regardless of the actual number of partition entries used. Thus unless you
-    ///   have full control of GPT generation in your entire system where you can always ensure a
-    ///   smaller bound on it, it is recommended to always return 128.
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64));
-
-    /// Returns the `BlockInfo` of the provided Block IO.
-    fn info(&mut self) -> BlockInfo {
-        let mut res = None;
-        self.with(&mut |io, _, _| res = Some(io.info()));
-        res.unwrap()
-    }
-
-    /// Read data from the block device.
-    ///
-    /// # Args
-    ///
-    /// * `offset`: Offset in number of bytes.
-    ///
-    /// * `out`: Buffer to store the read data.
-    ///
-    /// * Returns success when exactly `out.len()` number of bytes are read.
-    fn read(&mut self, offset: u64, out: &mut [u8]) -> Result<()> {
-        with_partitioned_scratch(self, |io, alignment, _, _| {
-            block_on(AsyncBlockDevice::new(SyncAsAsync::new(io), alignment)?.read(offset, out))
-        })?
-    }
-
-    /// Write data to the device.
-    ///
-    /// # Args
-    ///
-    /// * `offset`: Offset in number of bytes.
-    ///
-    /// * `data`: Data to write.
-    ///
-    /// * The API enables an optimization which temporarily changes `data` layout internally and
-    ///   reduces the number of calls to `Self::write_blocks()` down to O(1) regardless of input's
-    ///   alignment. This is the recommended usage.
-    ///
-    /// * Returns success when exactly `data.len()` number of bytes are written.
-    fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        with_partitioned_scratch(self, |io, alignment, _, _| {
-            block_on(AsyncBlockDevice::new(SyncAsAsync::new(io), alignment)?.write(offset, data))
-        })?
-    }
-
-    /// Parse and sync GPT from a block device.
-    ///
-    /// The API validates and restores primary/secondary GPT header.
-    ///
-    /// # Returns
-    ///
-    /// Returns success if GPT is loaded/restored successfully.
-    fn sync_gpt(&mut self) -> Result<()> {
-        with_partitioned_scratch(self, |io, alignment_scratch, gpt_buffer, max_entries| {
-            block_on(
-                AsyncBlockDevice::new(SyncAsAsync::new(io), alignment_scratch)?
-                    .sync_gpt(&mut GptCache::from_uninit(max_entries, gpt_buffer)?),
-            )
-        })?
-    }
-
-    /// Returns the `Partition` for a partition.
-    ///
-    /// # Args
-    ///
-    /// * `part`: Name of the partition.
-    fn find_partition(&mut self, part: &str) -> Result<Partition> {
-        with_partitioned_scratch(self, |_, _, gpt_buffer, _| {
-            GptCache::from_existing(gpt_buffer)?.find_partition(part)
-        })?
-    }
-
-    /// Read a GPT partition on a block device
-    ///
-    /// # Args
-    ///
-    /// * `part_name`: Name of the partition.
-    ///
-    /// * `offset`: Offset in number of bytes into the partition.
-    ///
-    /// * `out`: Buffer to store the read data.
-    ///
-    /// # Returns
-    ///
-    /// Returns success when exactly `out.len()` of bytes are read successfully.
-    fn read_gpt_partition(&mut self, part_name: &str, offset: u64, out: &mut [u8]) -> Result<()> {
-        let offset = with_partitioned_scratch(self, |_, _, gpt_buffer, _| {
-            check_gpt_rw_params(gpt_buffer, part_name, offset, out.len())
-        })??;
-        self.read(offset, out)
-    }
-
-    /// Write a GPT partition on a block device.
-    /// Optimization for mutable buffers.
-    /// See `AsBlockDevice::write` for details on alignment requirements
-    /// for optimized performance.
-    ///
-    /// # Args
-    ///
-    /// * `part_name`: Name of the partition.
-    ///
-    /// * `offset`: Offset in number of bytes into the partition.
-    ///
-    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
-    ///
-    /// # Returns
-    ///
-    /// Returns success when exactly `data.len()` of bytes are written successfully.
-    fn write_gpt_partition(&mut self, part_name: &str, offset: u64, data: &mut [u8]) -> Result<()> {
-        let offset = with_partitioned_scratch(self, |_, _, gpt_buffer, _| {
-            check_gpt_rw_params(gpt_buffer, part_name, offset, data.len())
-        })??;
-        self.write(offset, data)
-    }
-}
-
-impl<T: ?Sized + AsBlockDevice> AsBlockDevice for &mut T {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
-        (*self).with(f)
-    }
-}
-
-/// `BlockDevice` borrows a `BlockIoSync`, scratch buffer and implements `AsBlockDevice`.
-pub struct BlockDevice<'a, 'b> {
-    io: &'a mut dyn BlockIoSync,
-    scratch: &'b mut [u8],
-    max_gpt_entries: u64,
-}
-
-impl<'a, 'b> BlockDevice<'a, 'b> {
-    /// Creates a new [BlockDevice].
-    ///
-    /// # Arguments
-    /// * `io`: the [BlockIoSync] implementation to use.
-    /// * `scratch`: scratch buffer to use; if this is smaller than the size indicated by
-    ///              [required_scratch_size], operations on the returned device may return
-    ///              [Error::BufferTooSmall].
-    /// * `max_gpt_entries`: the maximum GPT entries to support.
-    pub fn new(io: &'a mut dyn BlockIoSync, scratch: &'b mut [u8], max_gpt_entries: u64) -> Self {
-        Self { io, scratch, max_gpt_entries }
-    }
-}
-
-impl AsBlockDevice for BlockDevice<'_, '_> {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
-        f(self.io, self.scratch, self.max_gpt_entries)
-    }
-}
-
-/// Iterates all partitions in a `AsBlockDevice`.
-pub fn for_each_partition<F: FnMut(&Partition) -> Result<()>>(
-    dev: &mut dyn AsBlockDevice,
-    mut f: F,
-) -> Result<Result<()>> {
-    with_partitioned_scratch(dev, |_, _, gpt_buffer, _| {
-        for ele in GptCache::from_existing(gpt_buffer)?.partition_iter() {
-            match f(&ele) {
-                Err(e) => return Ok(Err(e)),
-                _ => {}
-            }
-        }
-        Ok(Ok(()))
-    })?
-}
-
-/// Calculates the required scratch buffer size given a `BlockInfo` and maximum GPT entries.
-pub fn required_scratch_size(info: BlockInfo, max_gpt_entries: u64) -> Result<usize> {
-    let alignment_size: SafeNum = alignment_scratch_size(info)?.into();
-    let gpt_buffer_size = match max_gpt_entries {
-        0 => 0,
-        v => GptCache::required_buffer_size(v)?,
-    };
-    (alignment_size + gpt_buffer_size).try_into().map_err(Into::into)
-}
-
-/// Partitions a raw buffer into scratch buffer and GPT cache buffer.
-fn partition_scratch(
-    info: BlockInfo,
-    max_gpt_entries: u64,
-    buffer: &mut [u8],
-) -> Result<(&mut [u8], &mut [u8])> {
-    let scratch_size = required_scratch_size(info, max_gpt_entries)?;
-    if buffer.len() < scratch_size {
-        return Err(Error::BufferTooSmall(Some(scratch_size)));
-    }
-    Ok(buffer.split_at_mut(alignment_scratch_size(info)?))
-}
-
-/// A helper that wraps `AsBlockDevice::with` and additionally partitions the scratch buffer into
-/// alignment scratch and GPT buffers.
-fn with_partitioned_scratch<F, R>(dev: &mut (impl AsBlockDevice + ?Sized), mut f: F) -> Result<R>
-where
-    F: FnMut(&mut dyn BlockIoSync, &mut [u8], &mut [u8], u64) -> R,
-{
-    let mut res: Result<R> = Err(Error::InvalidInput);
-    dev.with(&mut |io, scratch, max_entries| {
-        res = (|| {
-            let (alignment, gpt) = partition_scratch(io.info(), max_entries, scratch)?;
-            Ok(f(io, alignment, gpt, max_entries))
-        })();
-    });
-    res
-}
-
 /// Check if `value` is aligned to (multiples of) `alignment`
 /// It can fail if the remainider calculation fails overflow check.
-pub fn is_aligned(value: SafeNum, alignment: SafeNum) -> Result<bool> {
-    Ok(u64::try_from(value % alignment)? == 0)
+pub fn is_aligned(value: impl Into<SafeNum>, alignment: impl Into<SafeNum>) -> Result<bool> {
+    Ok(u64::try_from(value.into() % alignment.into())? == 0)
 }
 
 /// Check if `buffer` address is aligned to `alignment`
 /// It can fail if the remainider calculation fails overflow check.
-pub fn is_buffer_aligned(buffer: &[u8], alignment: u64) -> Result<bool> {
-    is_aligned((buffer.as_ptr() as usize).into(), alignment.into())
+pub fn is_buffer_aligned<T>(buffer: &[T], alignment: u64) -> Result<bool> {
+    is_aligned(buffer.as_ptr() as usize, alignment)
 }
 
 /// Check read/write range and calculate offset in number of blocks.
-fn check_range(info: BlockInfo, offset: u64, buffer: &[u8]) -> Result<SafeNum> {
+fn check_range<T>(info: BlockInfo, offset: u64, buffer: &[T]) -> Result<SafeNum> {
     let offset: SafeNum = offset.into();
     let block_size: SafeNum = info.block_size.into();
     debug_assert!(is_aligned(offset, block_size)?, "{:?}, {:?}", offset, block_size);
-    debug_assert!(is_aligned(buffer.len().into(), block_size)?);
+    debug_assert!(is_aligned(size_of_val(buffer), block_size)?);
     debug_assert!(is_buffer_aligned(buffer, info.alignment)?);
     let blk_offset = offset / block_size;
-    let blk_count = SafeNum::from(buffer.len()) / block_size;
+    let blk_count = SafeNum::from(size_of_val(buffer)) / block_size;
     let end: u64 = (blk_offset + blk_count).try_into()?;
     match end <= info.num_blocks {
         true => Ok(blk_offset),
@@ -532,57 +182,72 @@ fn check_range(info: BlockInfo, offset: u64, buffer: &[u8]) -> Result<SafeNum> {
     }
 }
 
-/// Calculates the necessary scratch buffer size for handling block and buffer misalignment.
-pub fn alignment_scratch_size(info: BlockInfo) -> Result<usize> {
+/// Computes the required scratch size for initializing a [AsyncBlockDevice].
+pub fn scratch_size(io: &mut impl BlockIo) -> Result<usize> {
+    let info = io.info();
     let block_alignment = match info.block_size {
         1 => 0,
         v => v,
     };
-    ((SafeNum::from(info.alignment) - 1) * 2 + block_alignment).try_into().map_err(Into::into)
-}
-
-/// Gets a subslice of the given slice with aligned address according to `alignment`
-fn aligned_subslice(buffer: &mut [u8], alignment: u64) -> Result<&mut [u8]> {
-    let addr = SafeNum::from(buffer.as_ptr() as usize);
-    Ok(&mut buffer[(addr.round_up(alignment) - addr).try_into()?..])
+    Ok(((SafeNum::from(info.alignment) - 1) * 2 + block_alignment).try_into()?)
 }
 
-/// `AsyncBlockDevice` provides APIs for asynchronous read/write of raw block or GPT partitions.
-pub struct AsyncBlockDevice<'a, T: BlockIoAsync> {
+/// `Disk` contains a BlockIO and scratch buffer and provides APIs for reading/writing with
+/// arbitrary ranges and alignment.
+pub struct Disk<T, S> {
     io: T,
-    scratch: &'a mut [u8],
+    scratch: S,
 }
 
-impl<'a, T: BlockIoAsync> AsyncBlockDevice<'a, T> {
-    /// Creates a new instance with the given IO, scratch buffer and maximum GPT entries.
+impl<T: BlockIo, S: DerefMut<Target = [u8]>> Disk<T, S> {
+    /// Creates a new instance with the given IO and scratch buffer.
     ///
     /// * The scratch buffer is internally used for handling partial block read/write and unaligned
     ///   input/output user buffers.
     ///
     /// * The necessary size for the scratch buffer depends on `BlockInfo::alignment`,
-    ///   `BlockInfo::block_size`. It can be computed using the helper API
-    ///   `Self::required_scratch_size()`. If the block device has no alignment requirement,
-    ///   i.e. both alignment and block size are 1, the total required scratch size is 0.
-    pub fn new(mut io: T, scratch: &'a mut [u8]) -> Result<Self> {
-        let scratch_size = Self::required_scratch_size(&mut io)?;
-        match scratch.len() < scratch_size {
-            true => Err(Error::BufferTooSmall(Some(scratch_size))),
+    ///   `BlockInfo::block_size`. It can be computed using the helper API `scratch_size()`. If the
+    ///   block device has no alignment requirement, i.e. both alignment and block size are 1, the
+    ///   total required scratch size is 0.
+    pub fn new(mut io: T, scratch: S) -> Result<Self> {
+        let sz = scratch_size(&mut io)?;
+        match scratch.len() < sz {
+            true => Err(Error::BufferTooSmall(Some(sz))),
             _ => Ok(Self { io, scratch }),
         }
     }
 
-    /// Creates a new `AsyncBlockDevice` instance that borrows the internal data of this instance.
-    pub fn as_mut_instance(&mut self) -> AsyncBlockDevice<'_, &'_ mut T> {
-        AsyncBlockDevice::<&mut T>::new(&mut self.io, &mut self.scratch[..]).unwrap()
+    /// Same as `Self::new()` but allocates the necessary scratch buffer.
+    ///
+    /// T must implement Extend<u8> and Default. It should typically be a vector like type.
+    ///
+    /// Allocation is done by extending T one element at a time. In most cases, we don't expect
+    /// block size or alignment to be large values and this is only done once. thus this should be
+    /// low cost. However if that is not the case, it is recommended to use `Self::new()` with
+    /// pre-allocated scratch buffer.
+    pub fn new_alloc_scratch(mut io: T) -> Result<Self>
+    where
+        S: Extend<u8> + Default,
+    {
+        let mut scratch = S::default();
+        // Extends the scratch buffer to the required size.
+        // Can call `extend_reserve()` first once it becomes stable.
+        (0..max(scratch.len(), scratch_size(&mut io)?) - scratch.len())
+            .for_each(|_| scratch.extend([0u8]));
+        Self::new(io, scratch)
+    }
+
+    /// Creates a `Disk<&mut T, &mut [u8]>` instance that borrows the internal fields.
+    pub fn as_borrowed(&mut self) -> Disk<&mut T, &mut [u8]> {
+        Disk::new(&mut self.io, &mut self.scratch[..]).unwrap()
     }
 
-    /// Computes the required scratch size.
-    pub fn required_scratch_size<B: BlockIoAsync>(io: &mut B) -> Result<usize> {
-        // `AsyncBlockDevice` doesn't manage GPT internally, thus max_entries passed here is 0.
-        required_scratch_size(io.info(), 0)
+    /// Gets the [BlockInfo]
+    pub fn block_info(&mut self) -> BlockInfo {
+        self.io.info()
     }
 
-    /// Returns the IO
+    /// Gets the underlying BlockIo implementation.
     pub fn io(&mut self) -> &mut T {
         &mut self.io
     }
@@ -594,8 +259,12 @@ impl<'a, T: BlockIoAsync> AsyncBlockDevice<'a, T> {
     /// * `offset`: Offset in number of bytes.
     /// * `out`: Buffer to store the read data.
     /// * Returns success when exactly `out.len()` number of bytes are read.
-    pub async fn read(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        read_async(&mut self.io, offset, data, self.scratch).await
+    pub async fn read(
+        &mut self,
+        offset: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<()> {
+        read_async(&mut self.io, offset, out, &mut self.scratch).await
     }
 
     /// Writes data to the device.
@@ -604,135 +273,109 @@ impl<'a, T: BlockIoAsync> AsyncBlockDevice<'a, T> {
     ///
     /// * `offset`: Offset in number of bytes.
     /// * `data`: Data to write.
-    /// * The API enables an optimization which temporarily changes `data` layout internally and
-    ///   reduces the number of calls to `Self::write_blocks()` down to O(1) regardless of input's
-    ///   alignment. This is the recommended usage.
+    ///
+    /// # Returns
+    ///
     /// * Returns success when exactly `data.len()` number of bytes are written.
     pub async fn write(&mut self, offset: u64, data: &mut [u8]) -> Result<()> {
-        write_async(&mut self.io, offset, data, self.scratch).await
+        write_async(&mut self.io, offset, data, &mut self.scratch).await
     }
 
-    /// Loads and syncs GPT from a block device.
+    /// Fills a disk range with the given byte value
     ///
-    /// The API validates and restores primary/secondary GPT header.
+    /// # Args
+    ///
+    /// * `offset`: Offset in number of bytes.
+    /// * `size`: Number of bytes to fill.
+    /// * `val`: Fill value.
+    /// * `scratch`: A scratch buffer that will be used for writing `val` in batches.
     ///
     /// # Returns
     ///
-    /// Returns success if GPT is loaded/restored successfully.
-    pub async fn sync_gpt(&mut self, gpt_cache: &mut GptCache<'_>) -> Result<()> {
-        gpt_cache.load_and_sync(&mut self.io, self.scratch).await
+    /// * Returns Err(Error::InvalidInput) if size of `scratch` is 0.
+    pub async fn fill(
+        &mut self,
+        mut offset: u64,
+        size: u64,
+        val: u8,
+        scratch: &mut [u8],
+    ) -> Result<()> {
+        if scratch.is_empty() {
+            return Err(Error::InvalidInput);
+        }
+        let blk_sz = usize::try_from(self.block_info().block_size)?;
+        // Optimizes by trying to get an aligned and multi-block-size buffer.
+        let buf = match aligned_subslice(scratch, self.block_info().alignment) {
+            Ok(v) => match v.len() / blk_sz {
+                b if b > 0 => &mut v[..b * blk_sz],
+                _ => v,
+            },
+            _ => scratch,
+        };
+        let sz = min(size, buf.len().try_into()?);
+        buf[..usize::try_from(sz).unwrap()].fill(val);
+        let end: u64 = (SafeNum::from(offset) + size).try_into()?;
+        while offset < end {
+            let to_write = min(sz, end - offset);
+            self.write(offset, &mut buf[..usize::try_from(to_write).unwrap()]).await?;
+            offset += to_write;
+        }
+        Ok(())
     }
 
-    /// Reads a GPT partition on a block device
-    ///
-    /// # Args
+    /// Loads and syncs GPT from a block device.
     ///
-    /// * `gpt_cache`: A `GptCache` initialized with `Self::sync_gpt()`.
-    /// * `part_name`: Name of the partition.
-    /// * `offset`: Offset in number of bytes into the partition.
-    /// * `out`: Buffer to store the read data.
+    /// The API validates and restores primary/secondary GPT header.
     ///
     /// # Returns
     ///
-    /// Returns success when exactly `out.len()` of bytes are read successfully.
-    pub async fn read_gpt_partition(
+    /// * Returns Ok(sync_result) if disk IO is successful, where `sync_result` contains the GPT
+    ///   verification and restoration result.
+    /// * Returns Err() if disk IO encounters errors.
+    pub async fn sync_gpt(
         &mut self,
-        gpt_cache: &GptCache<'_>,
-        part_name: &str,
-        offset: u64,
-        out: &mut [u8],
-    ) -> Result<()> {
-        let offset = gpt_cache.check_range(part_name, offset, out.len())?;
-        self.read(offset, out).await
+        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
+    ) -> Result<GptSyncResult> {
+        gpt.load_and_sync(self).await
     }
 
-    /// Writes a GPT partition on a block device.
-    ///
+    /// Updates GPT to the block device and sync primary and secondary GPT.
     ///
     /// # Args
     ///
-    /// * `gpt_cache`: A `GptCache` initialized with `Self::sync_gpt()`.
-    /// * `part_name`: Name of the partition.
-    /// * `offset`: Offset in number of bytes into the partition.
-    /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
+    /// * `mbr_primary`: A buffer containing the MBR block, primary GPT header and entries.
+    /// * `resize`: If set to true, the method updates the last partition to cover the rest of the
+    ///    storage.
+    /// * `gpt`: The GPT to update.
     ///
     /// # Returns
     ///
-    /// Returns success when exactly `data.len()` of bytes are written successfully.
-    pub async fn write_gpt_partition(
+    /// * Return `Ok(())` if new GPT is valid and device is updated and synced successfully.
+    pub async fn update_gpt(
         &mut self,
-        gpt_cache: &GptCache<'_>,
-        part_name: &str,
-        offset: u64,
-        data: &mut [u8],
+        mbr_primary: &mut [u8],
+        resize: bool,
+        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
     ) -> Result<()> {
-        let offset = gpt_cache.check_range(part_name, offset, data.len())?;
-        self.write(offset, data).await
-    }
-}
-
-/// `AsyncGptDevice` wraps a `AsyncBlockDevice` and `GptCache` and provides simpler APIs for
-/// reading/writing GPT partitions.
-pub struct AsyncGptDevice<'a, T: BlockIoAsync> {
-    blk: AsyncBlockDevice<'a, T>,
-    gpt_cache: GptCache<'a>,
-}
-
-impl<'a, T: BlockIoAsync> AsyncGptDevice<'a, T> {
-    /// Creates a new instance.
-    pub fn new(blk: AsyncBlockDevice<'a, T>, gpt_cache: GptCache<'a>) -> Self {
-        Self { blk, gpt_cache }
+        gpt::update_gpt(self, mbr_primary, resize, gpt).await
     }
 
-    /// Creates a new instance from a raw `BlockIoAsync` and a raw buffer. The API will attempt to
-    /// partition the `buffer` into scratch buffer and GPT cache buffer.
-    pub fn new_from_monotonic_buffer(
-        mut io: T,
-        buffer: &'a mut [u8],
-        max_gpt_entries: u64,
-    ) -> Result<Self> {
-        let (scratch, gpt) = partition_scratch(io.info(), max_gpt_entries, buffer)?;
-        Ok(Self::new(
-            AsyncBlockDevice::new(io, scratch)?,
-            GptCache::from_uninit(max_gpt_entries, gpt)?,
-        ))
-    }
-
-    /// Returns the `AsyncBlockDevice`.
-    pub fn blk(&mut self) -> &mut AsyncBlockDevice<'a, T> {
-        &mut self.blk
-    }
-
-    /// Returns the `GptCache`.
-    pub fn gpt_cache(&self) -> &GptCache<'a> {
-        &self.gpt_cache
-    }
-
-    /// Creates a new `AsyncGptDevice` instance that borrows the internal data of this instance.
-    pub fn as_mut_instance(&mut self) -> AsyncGptDevice<'_, &'_ mut T> {
-        AsyncGptDevice::new(self.blk.as_mut_instance(), self.gpt_cache.as_mut_instance())
-    }
-
-    /// Unpacks into an `AsyncBlockDevice` and `GptCache`
-    pub fn into_blk_and_gpt(self) -> (AsyncBlockDevice<'a, T>, GptCache<'a>) {
-        (self.blk, self.gpt_cache)
-    }
-
-    /// Loads and syncs GPT from a block device.
+    /// Erases GPT if the disk has one.
     ///
-    /// The API validates and restores primary/secondary GPT header.
+    /// The method will first perform a GPT sync and makes sure that all valid entries are wiped.
     ///
-    /// # Returns
+    /// # Args
     ///
-    /// Returns success if GPT is loaded/restored successfully.
-    pub async fn sync_gpt(&mut self) -> Result<()> {
-        self.blk.sync_gpt(&mut self.gpt_cache).await
+    /// * `gpt`: An instance of GPT.
+    pub async fn erase_gpt(&mut self, gpt: &mut Gpt<impl DerefMut<Target = [u8]>>) -> Result<()> {
+        gpt::erase_gpt(self, gpt).await
     }
 
     /// Reads a GPT partition on a block device
     ///
     /// # Args
     ///
+    /// * `gpt`: A `GptCache` initialized with `Self::sync_gpt()`.
     /// * `part_name`: Name of the partition.
     /// * `offset`: Offset in number of bytes into the partition.
     /// * `out`: Buffer to store the read data.
@@ -742,11 +385,13 @@ impl<'a, T: BlockIoAsync> AsyncGptDevice<'a, T> {
     /// Returns success when exactly `out.len()` of bytes are read successfully.
     pub async fn read_gpt_partition(
         &mut self,
+        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
         part_name: &str,
         offset: u64,
-        out: &mut [u8],
+        out: &mut (impl SliceMaybeUninit + ?Sized),
     ) -> Result<()> {
-        self.blk.read_gpt_partition(&mut self.gpt_cache, part_name, offset, out).await
+        let offset = gpt.check_range(part_name, offset, out.len())?;
+        self.read(offset, out).await
     }
 
     /// Writes a GPT partition on a block device.
@@ -754,6 +399,7 @@ impl<'a, T: BlockIoAsync> AsyncGptDevice<'a, T> {
     ///
     /// # Args
     ///
+    /// * `gpt`: A `GptCache` initialized with `Self::sync_gpt()`.
     /// * `part_name`: Name of the partition.
     /// * `offset`: Offset in number of bytes into the partition.
     /// * `data`: Data to write. See `data` passed to `BlockIoSync::write()` for details.
@@ -763,83 +409,121 @@ impl<'a, T: BlockIoAsync> AsyncGptDevice<'a, T> {
     /// Returns success when exactly `data.len()` of bytes are written successfully.
     pub async fn write_gpt_partition(
         &mut self,
+        gpt: &mut Gpt<impl DerefMut<Target = [u8]>>,
         part_name: &str,
         offset: u64,
         data: &mut [u8],
     ) -> Result<()> {
-        self.blk.write_gpt_partition(&mut self.gpt_cache, part_name, offset, data).await
+        let offset = gpt.check_range(part_name, offset, data.len())?;
+        self.write(offset, data).await
     }
 }
 
-/// `AsAsyncGptDeviceIter` defines an iterface for getting an iterator of `AsyncGptDevice`.
-pub trait AsAsyncGptDeviceIter {
-    /// The type that implements the `BlockIoAsync` trait for `AsyncGptDevice`.
-    type BlockIo<'a>: BlockIoAsync
-    where
-        Self: 'a;
+impl<'a, T: BlockIo> Disk<RefMut<'a, T>, RefMut<'a, [u8]>> {
+    /// Converts a `RefMut<Disk<T, S>>` to `Disk<RefMut<T>, RefMut<[u8]>>`. The scratch buffer
+    /// generic type is eliminated in the return.
+    pub fn from_ref_mut(val: RefMut<'a, Disk<T, impl DerefMut<Target = [u8]>>>) -> Self {
+        let (io, scratch) = RefMut::map_split(val, |v| (&mut v.io, &mut v.scratch[..]));
+        Disk::new(io, scratch).unwrap()
+    }
+}
 
-    /// Gets an iterator for `AsyncGptDevice`.
-    fn iter(&mut self) -> impl IntoIterator<Item = AsyncGptDevice<'_, Self::BlockIo<'_>>>;
+impl<T, S> Disk<RamBlockIo<T>, S>
+where
+    T: DerefMut<Target = [u8]>,
+    S: DerefMut<Target = [u8]> + Extend<u8> + Default,
+{
+    /// Creates a new ram disk instance with allocated scratch buffer.
+    pub fn new_ram_alloc(block_size: u64, alignment: u64, storage: T) -> Result<Self> {
+        let ram_blk = RamBlockIo::new(block_size, alignment, storage);
+        Self::new_alloc_scratch(ram_blk)
+    }
 }
 
-// Built-in implementation for an array of `AsyncGptDevice`.
-impl<B: BlockIoAsync> AsAsyncGptDeviceIter for [AsyncGptDevice<'_, B>] {
-    type BlockIo<'a> = &'a mut B where Self: 'a;
+/// Helper trait to implement common logic working with MaybeUninit slices.
+/// Implemented for [u8] and [MaybeUninit<u8>].
+///
+/// Read functions treats buffer as not initialized using this trait.
+// AsRef,AsMut implementation added here. Since it is not possible to implement trait from other
+// crate for trait in this trait. It is possible to implement other trait for `dyn` object of local
+// trait. But it introduces other issues with lifetime and casting boilerplate.
+//
+// Alternatively we considered using wrapper type, which works but requires `into()` call either on
+// function call. Or inside functions if they accept `impl Into<Wrapper>`.
+// Using traits seems to be cleaner and potentially more effective.
+pub trait SliceMaybeUninit {
+    /// Get `&[MaybeUninit<u8>]` representation
+    fn as_ref(&self) -> &[MaybeUninit<u8>];
+
+    // AsMut implementation
+    /// Get `&mut [MaybeUninit<u8>]` representation
+    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>];
 
-    fn iter(&mut self) -> impl IntoIterator<Item = AsyncGptDevice<'_, Self::BlockIo<'_>>> {
-        self.iter_mut().map(move |v| v.as_mut_instance())
+    /// Get slice length
+    fn len(&self) -> usize {
+        self.as_ref().len()
+    }
+
+    /// Returns reference to element or subslice, or Error if index is out of bounds
+    fn get<I>(&mut self, index: I) -> Result<&<I>::Output>
+    where
+        I: SliceIndex<[MaybeUninit<u8>]>,
+    {
+        self.as_ref().get(index).ok_or(Error::BufferTooSmall(None))
+    }
+
+    /// Returns mutable reference to element or subslice, or Error if index is out of bounds
+    fn get_mut<I>(&mut self, index: I) -> Result<&mut <I>::Output>
+    where
+        I: SliceIndex<[MaybeUninit<u8>]>,
+    {
+        self.as_mut().get_mut(index).ok_or(Error::BufferTooSmall(None))
+    }
+
+    /// Clone from slice
+    fn clone_from_slice(&mut self, src: &[u8]) {
+        self.as_mut().clone_from_slice(as_uninit(src))
     }
 }
 
-/// Checks that a partition exists and is unique.
-///
-/// On Success, returns the offset of the block device in the list, the `Partition` and the
-/// corresponding `AsyncGptDevice<'a, B>`.
-pub fn check_part_unique<'a, B: BlockIoAsync>(
-    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
-    part: &str,
-) -> Result<(usize, Partition, AsyncGptDevice<'a, B>)> {
-    let mut idx = 0usize;
-    let mut res = Err(Error::NotFound);
-    for dev in devs.iter() {
-        res = match dev.gpt_cache().find_partition(part).map(|v| (idx, v, dev)) {
-            Ok(_) if res.is_ok() => return Err(Error::NotUnique),
-            v => v.or(res),
-        };
-        idx += 1;
+impl SliceMaybeUninit for [u8] {
+    fn as_ref(&self) -> &[MaybeUninit<u8>] {
+        as_uninit(self)
+    }
+    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
+        as_uninit_mut(self)
+    }
+}
+
+impl SliceMaybeUninit for [MaybeUninit<u8>] {
+    fn as_ref(&self) -> &[MaybeUninit<u8>] {
+        self
+    }
+    fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
+        self
     }
-    res
 }
 
-/// Checks that a partition is unique among a list of GPT devices and reads from it
-pub async fn read_unique_gpt_partition<'a, B: BlockIoAsync>(
-    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
-    part: &str,
-    off: u64,
-    out: &mut [u8],
-) -> Result<()> {
-    check_part_unique(devs, part)?.2.read_gpt_partition(part, off, out).await
+/// Present initialized `&mut [u8]` buffer as `&mut [MaybeUninit<u8>]`
+pub fn as_uninit_mut(buf: &mut [u8]) -> &mut [MaybeUninit<u8>] {
+    // SAFETY:
+    // MaybeUninit<u8> has same size and alignment as u8.
+    // `data` is valid pointer to initialised u8 slice of size `buf.len()`
+    unsafe { core::slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut MaybeUninit<u8>, buf.len()) }
 }
 
-/// Checks that a partition is unique among a list of GPT devices and writes to it.
-pub async fn write_unique_gpt_partition<'a, B: BlockIoAsync>(
-    devs: &'a mut (impl AsAsyncGptDeviceIter<BlockIo<'a> = B> + ?Sized),
-    part: &str,
-    off: u64,
-    data: &mut [u8],
-) -> Result<()> {
-    check_part_unique(devs, part)?.2.write_gpt_partition(part, off, data).await
+/// Present initialized `&mut [u8]` buffer as `&mut [MaybeUninit<u8>]`
+pub fn as_uninit(buf: &[u8]) -> &[MaybeUninit<u8>] {
+    // SAFETY:
+    // MaybeUninit<u8> has same size and alignment as u8.
+    // `data` is valid pointer to initialised u8 slice of size `buf.len()`
+    unsafe { core::slice::from_raw_parts(buf.as_ptr() as *const MaybeUninit<u8>, buf.len()) }
 }
 
 #[cfg(test)]
 mod test {
-    use core::mem::size_of;
+    use super::*;
     use gbl_async::block_on;
-    use gbl_storage_testlib::{
-        read_unique_gpt_partition, required_scratch_size, write_unique_gpt_partition,
-        AsBlockDevice, AsyncGptDevice, TestBlockDevice, TestBlockDeviceBuilder, TestBlockIo,
-        TestMultiBlockDevices,
-    };
     use safemath::SafeNum;
 
     #[derive(Debug)]
@@ -899,65 +583,46 @@ mod test {
     /// Analysis is similar for `fn write_async()`.
     const READ_WRITE_BLOCKS_UPPER_BOUND: usize = 6;
 
+    // Type alias of the [Disk] type used by unittests.
+    pub(crate) type TestDisk = Disk<RamBlockIo<Vec<u8>>, Vec<u8>>;
+
     fn read_test_helper(case: &TestCase) {
         let data = (0..case.storage_size).map(|v| v as u8).collect::<Vec<_>>();
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(case.alignment)
-            .set_block_size(case.block_size)
-            .set_data(&data)
-            .build();
+        let mut disk = TestDisk::new_ram_alloc(case.alignment, case.block_size, data).unwrap();
         // Make an aligned buffer. A misaligned version is created by taking a sub slice that
         // starts at an unaligned offset. Because of this we need to allocate
         // `case.misalignment` more to accommodate it.
         let mut aligned_buf = AlignedBuffer::new(case.alignment, case.rw_size + case.misalignment);
-        let misalignment = SafeNum::from(case.misalignment);
-        let out = &mut aligned_buf.get()
-            [misalignment.try_into().unwrap()..(misalignment + case.rw_size).try_into().unwrap()];
-        blk.read(case.rw_offset, out).unwrap();
-        let rw_offset = SafeNum::from(case.rw_offset);
-        assert_eq!(
-            out.to_vec(),
-            blk.io.storage
-                [rw_offset.try_into().unwrap()..(rw_offset + case.rw_size).try_into().unwrap()]
-                .to_vec(),
-            "Failed. Test case {:?}",
-            case,
-        );
-
-        assert!(blk.io.num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-    }
-
-    fn write_test_helper(case: &TestCase, write_func: fn(&mut TestBlockDevice, u64, &mut [u8])) {
+        let misalignment = usize::try_from(case.misalignment).unwrap();
+        let rw_sz = usize::try_from(case.rw_size).unwrap();
+        let out = &mut aligned_buf.get()[misalignment..][..rw_sz];
+        block_on(disk.read(case.rw_offset, out)).unwrap();
+        let rw_off = usize::try_from(case.rw_offset).unwrap();
+        assert_eq!(out, &disk.io().storage()[rw_off..][..rw_sz], "Failed. Test case {:?}", case);
+        assert!(disk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
+    }
+
+    fn write_test_helper(
+        case: &TestCase,
+        mut write_func: impl FnMut(&mut TestDisk, u64, &mut [u8]),
+    ) {
         let data = (0..case.storage_size).map(|v| v as u8).collect::<Vec<_>>();
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(case.alignment)
-            .set_block_size(case.block_size)
-            .set_data(&data)
-            .build();
         // Write a reverse version of the current data.
-        let rw_offset = SafeNum::from(case.rw_offset);
-        let mut expected = blk.io.storage
-            [rw_offset.try_into().unwrap()..(rw_offset + case.rw_size).try_into().unwrap()]
-            .to_vec();
+        let rw_off = usize::try_from(case.rw_offset).unwrap();
+        let rw_sz = usize::try_from(case.rw_size).unwrap();
+        let mut expected = data[rw_off..][..rw_sz].to_vec();
         expected.reverse();
+        let mut disk = TestDisk::new_ram_alloc(case.alignment, case.block_size, data).unwrap();
         // Make an aligned buffer. A misaligned version is created by taking a sub slice that
         // starts at an unaligned offset. Because of this we need to allocate
         // `case.misalignment` more to accommodate it.
-        let misalignment = SafeNum::from(case.misalignment);
         let mut aligned_buf = AlignedBuffer::new(case.alignment, case.rw_size + case.misalignment);
-        let data = &mut aligned_buf.get()
-            [misalignment.try_into().unwrap()..(misalignment + case.rw_size).try_into().unwrap()];
+        let misalignment = usize::try_from(case.misalignment).unwrap();
+        let data = &mut aligned_buf.get()[misalignment..][..rw_sz];
         data.clone_from_slice(&expected);
-        write_func(&mut blk, case.rw_offset, data);
-        let rw_offset = SafeNum::from(case.rw_offset);
-        assert_eq!(
-            expected,
-            blk.io.storage
-                [rw_offset.try_into().unwrap()..(rw_offset + case.rw_size).try_into().unwrap()]
-                .to_vec(),
-            "Failed. Test case {:?}",
-            case,
-        );
+        write_func(&mut disk, case.rw_offset, data);
+        let written = &disk.io().storage()[rw_off..][..rw_sz];
+        assert_eq!(expected, written, "Failed. Test case {:?}", case);
         // Check that input is not modified.
         assert_eq!(expected, data, "Input is modified. Test case {:?}", case,);
     }
@@ -983,12 +648,14 @@ mod test {
                 // Input bytes slice is a mutable reference
                 #[test]
                 fn write_mut_test() {
-                    let func = |blk: &mut TestBlockDevice, offset: u64, data: &mut [u8]| {
-                        blk.write(offset, data).unwrap();
-                        assert!(blk.io.num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                        assert!(blk.io.num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                    };
-                    write_test_helper(&TestCase::new($x0, $x1, $x2, $x3, $x4, $x5), func);
+                    write_test_helper(
+                        &TestCase::new($x0, $x1, $x2, $x3, $x4, $x5),
+                        |blk, offset, data| {
+                            block_on(blk.write(offset, data)).unwrap();
+                            assert!(blk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
+                            assert!(blk.io().num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
+                        },
+                    );
                 }
 
                 #[test]
@@ -996,12 +663,14 @@ mod test {
                     // Scaled all parameters by double and test again.
                     let (x0, x1, x2, x3, x4, x5) =
                         (2 * $x0, 2 * $x1, 2 * $x2, 2 * $x3, 2 * $x4, 2 * $x5);
-                    let func = |blk: &mut TestBlockDevice, offset: u64, data: &mut [u8]| {
-                        blk.write(offset, data).unwrap();
-                        assert!(blk.io.num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                        assert!(blk.io.num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
-                    };
-                    write_test_helper(&TestCase::new(x0, x1, x2, x3, x4, x5), func);
+                    write_test_helper(
+                        &TestCase::new(x0, x1, x2, x3, x4, x5),
+                        |blk, offset, data| {
+                            block_on(blk.write(offset, data)).unwrap();
+                            assert!(blk.io().num_reads <= READ_WRITE_BLOCKS_UPPER_BOUND);
+                            assert!(blk.io().num_writes <= READ_WRITE_BLOCKS_UPPER_BOUND);
+                        },
+                    );
                 }
             }
         };
@@ -1232,175 +901,40 @@ mod test {
 
     #[test]
     fn test_no_alignment_require_zero_size_scratch() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_max_gpt_entries(0)
-            .set_size(1)
-            .build();
-        assert_eq!(required_scratch_size(blk.info(), 0).unwrap(), 0);
+        let mut io = RamBlockIo::new(1, 1, vec![]);
+        assert_eq!(scratch_size(&mut io).unwrap(), 0);
     }
 
     #[test]
     fn test_scratch_too_small() {
-        let storage_size = (TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE * 3) as usize;
-        let scratch_size =
-            TestBlockDeviceBuilder::new().set_size(storage_size).build().scratch.len() - 1;
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_size(storage_size)
-            .set_scratch_size(scratch_size)
-            .build();
-        let block_size = TestBlockDeviceBuilder::DEFAULT_BLOCK_SIZE;
-        assert!(blk.read(0, &mut vec![0u8; block_size.try_into().unwrap()]).is_err());
+        let mut io = RamBlockIo::new(512, 512, vec![]);
+        let scratch = vec![0u8; scratch_size(&mut io).unwrap() - 1];
+        assert!(TestDisk::new(io, scratch).is_err());
     }
 
     #[test]
     fn test_read_overflow() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_max_gpt_entries(0)
-            .set_size(512)
-            .build();
-        assert!(blk.read(512, &mut vec![0u8; 1]).is_err());
-        assert!(blk.read(0, &mut vec![0u8; 513]).is_err());
+        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
+        assert!(block_on(disk.read(512, &mut vec![0u8; 1][..])).is_err());
+        assert!(block_on(disk.read(0, &mut vec![0u8; 513][..])).is_err());
     }
 
     #[test]
     fn test_read_arithmetic_overflow() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_max_gpt_entries(0)
-            .set_size(512)
-            .build();
-        assert!(blk.read(u64::MAX, &mut vec![0u8; 1]).is_err());
+        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
+        assert!(block_on(disk.read(u64::MAX, &mut vec![0u8; 1][..])).is_err());
     }
 
     #[test]
     fn test_write_overflow() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_max_gpt_entries(0)
-            .set_size(512)
-            .build();
-        assert!(blk.write(512, vec![0u8; 1].as_mut_slice()).is_err());
-        assert!(blk.write(0, vec![0u8; 513].as_mut_slice()).is_err());
+        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
+        assert!(block_on(disk.write(512, &mut vec![0u8; 1])).is_err());
+        assert!(block_on(disk.write(0, &mut vec![0u8; 513])).is_err());
     }
 
     #[test]
     fn test_write_arithmetic_overflow() {
-        let mut blk = TestBlockDeviceBuilder::new()
-            .set_alignment(1)
-            .set_block_size(1)
-            .set_max_gpt_entries(0)
-            .set_size(512)
-            .build();
-        assert!(blk.write(u64::MAX, vec![0u8; 1].as_mut_slice()).is_err());
-    }
-
-    #[test]
-    fn test_u64_not_narrower_than_usize() {
-        // If this ever fails we need to adjust all code for >64 bit pointers and size.
-        assert!(size_of::<u64>() >= size_of::<*const u8>());
-        assert!(size_of::<u64>() >= size_of::<usize>());
-    }
-
-    /// A test helper for `read_unique_gpt_partition`
-    /// It verifies that data read partition `part` at offset `off` is the same as
-    /// `expected`.
-    fn check_read_partition(
-        devs: &mut [AsyncGptDevice<&mut TestBlockIo>],
-        part: &str,
-        off: usize,
-        expected: &[u8],
-    ) {
-        let mut out = vec![0u8; expected.len()];
-        block_on(read_unique_gpt_partition(devs, part, off.try_into().unwrap(), &mut out)).unwrap();
-        assert_eq!(out, expected.to_vec());
-    }
-
-    #[test]
-    fn test_multi_block_gpt_read() {
-        let off = 512usize; // Randomly selected offset.
-
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        let mut devs = devs.as_gpt_devs();
-        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
-
-        let expect_boot_a = include_bytes!("../test/boot_a.bin");
-        let expect_boot_b = include_bytes!("../test/boot_b.bin");
-
-        check_read_partition(&mut devs, "boot_a", off, &expect_boot_a[off..]);
-        check_read_partition(&mut devs, "boot_b", off, &expect_boot_b[off..]);
-
-        let expect_vendor_boot_a = include_bytes!("../test/vendor_boot_a.bin");
-        let expect_vendor_boot_b = include_bytes!("../test/vendor_boot_b.bin");
-
-        check_read_partition(&mut devs, "vendor_boot_a", off, &expect_vendor_boot_a[off..]);
-        check_read_partition(&mut devs, "vendor_boot_b", off, &expect_vendor_boot_b[off..]);
-    }
-
-    /// A test helper for `write_unique_gpt_partition`
-    /// It verifies that `data` is correctly written to partition `part` at offset `off`.
-    fn check_write_partition(
-        devs: &mut [AsyncGptDevice<&mut TestBlockIo>],
-        part: &str,
-        off: usize,
-        to_write: &mut [u8],
-    ) {
-        block_on(write_unique_gpt_partition(devs, part, off.try_into().unwrap(), to_write))
-            .unwrap();
-        check_read_partition(devs, part, off, &to_write);
-
-        to_write.reverse();
-        block_on(write_unique_gpt_partition(devs, part, off.try_into().unwrap(), to_write))
-            .unwrap();
-        check_read_partition(devs, part, off, &to_write);
-    }
-
-    #[test]
-    fn test_multi_block_gpt_write() {
-        let off = 512usize; // Randomly selected offset.
-
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_2.bin").as_slice().into(),
-        ]);
-        let mut devs = devs.as_gpt_devs();
-        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
-
-        let expect_boot_a = &mut include_bytes!("../test/boot_a.bin").to_vec();
-        let expect_boot_b = &mut include_bytes!("../test/boot_b.bin").to_vec();
-
-        expect_boot_a.reverse();
-        expect_boot_b.reverse();
-        check_write_partition(&mut devs, "boot_a", off, &mut expect_boot_a[off..]);
-        check_write_partition(&mut devs, "boot_b", off, &mut expect_boot_b[off..]);
-
-        let expect_vendor_boot_a = &mut include_bytes!("../test/vendor_boot_a.bin").to_vec();
-        let expect_vendor_boot_b = &mut include_bytes!("../test/vendor_boot_b.bin").to_vec();
-
-        expect_boot_a.reverse();
-        expect_boot_b.reverse();
-        check_write_partition(&mut devs, "vendor_boot_a", off, &mut expect_vendor_boot_a[off..]);
-        check_write_partition(&mut devs, "vendor_boot_b", off, &mut expect_vendor_boot_b[off..]);
-    }
-
-    #[test]
-    fn test_none_block_id_fail_with_non_unique_partition() {
-        let mut devs = TestMultiBlockDevices(vec![
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-            include_bytes!("../test/gpt_test_1.bin").as_slice().into(),
-        ]);
-        let mut devs = devs.as_gpt_devs();
-        let devs = devs.as_mut_slice();
-        devs.iter_mut().for_each(|v| block_on(v.sync_gpt()).unwrap());
-        assert!(block_on(read_unique_gpt_partition(devs, "boot_a", 0, &mut [],)).is_err());
-        assert!(block_on(write_unique_gpt_partition(devs, "boot_a", 0, &mut [],)).is_err())
+        let mut disk = TestDisk::new_ram_alloc(512, 512, vec![0u8; 512]).unwrap();
+        assert!(block_on(disk.write(u64::MAX, &mut vec![0u8; 1])).is_err());
     }
 }
diff --git a/gbl/libstorage/src/ram_block.rs b/gbl/libstorage/src/ram_block.rs
new file mode 100644
index 0000000..21e0a15
--- /dev/null
+++ b/gbl/libstorage/src/ram_block.rs
@@ -0,0 +1,97 @@
+// Copyright 2023, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! This module provides an implementation of [BlockIo] backed by RAM.
+
+use crate::{is_aligned, is_buffer_aligned, BlockInfo, BlockIo, SliceMaybeUninit};
+use core::ops::DerefMut;
+use gbl_async::yield_now;
+use liberror::Error;
+use safemath::SafeNum;
+
+/// `RamBlockIo` implements [BlockIo] backed by user provided buffer.
+pub struct RamBlockIo<T> {
+    /// The storage block size in bytes.
+    pub block_size: u64,
+    /// The storage access alignment in bytes.
+    pub alignment: u64,
+    /// The backing storage data.
+    pub storage: T,
+    /// The number of successful write calls.
+    pub num_writes: usize,
+    /// The number of successful read calls.
+    pub num_reads: usize,
+    /// Injected error to be returned by the next read/write IO.
+    pub error: Option<Error>,
+}
+
+impl<T: DerefMut<Target = [u8]>> RamBlockIo<T> {
+    /// Creates an new instance.
+    pub fn new(block_size: u64, alignment: u64, storage: T) -> Self {
+        assert_eq!(
+            storage.len() % usize::try_from(block_size).unwrap(),
+            0,
+            "storage size is not multiple of block size, {}, {}",
+            storage.len(),
+            block_size
+        );
+        Self { block_size, alignment, storage, num_writes: 0, num_reads: 0, error: None }
+    }
+
+    /// Gets the underlying ramdisk storage.
+    pub fn storage(&mut self) -> &mut [u8] {
+        &mut self.storage[..]
+    }
+
+    /// Checks injected error, simulates async waiting, checks read/write parameters and returns the
+    /// offset in number of bytes.
+    async fn checks(
+        &mut self,
+        blk_offset: u64,
+        buf: &(impl SliceMaybeUninit + ?Sized),
+    ) -> Result<usize, Error> {
+        assert!(is_buffer_aligned(buf.as_ref(), self.alignment).unwrap_or(false));
+        assert!(is_aligned(buf.len(), self.block_size).unwrap_or(false));
+        yield_now().await;
+        self.error.take().map(|e| Err(e)).unwrap_or(Ok(()))?;
+        Ok((SafeNum::from(blk_offset) * self.block_size).try_into().unwrap())
+    }
+}
+
+// SAFETY:
+// `read_blocks` clones `out.len()` bytes to output which initializes all elements in `out`
+unsafe impl<T: DerefMut<Target = [u8]>> BlockIo for RamBlockIo<T> {
+    fn info(&mut self) -> BlockInfo {
+        BlockInfo {
+            block_size: self.block_size,
+            num_blocks: u64::try_from(self.storage.len()).unwrap() / self.block_size,
+            alignment: self.alignment,
+        }
+    }
+
+    async fn read_blocks(
+        &mut self,
+        blk_offset: u64,
+        out: &mut (impl SliceMaybeUninit + ?Sized),
+    ) -> Result<(), Error> {
+        let offset = self.checks(blk_offset, out).await?;
+        let out_len = out.len();
+        Ok(out.clone_from_slice(&self.storage[offset..][..out_len]))
+    }
+
+    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<(), Error> {
+        let offset = self.checks(blk_offset, &mut *data).await?;
+        Ok(self.storage[offset..][..data.len()].clone_from_slice(data))
+    }
+}
diff --git a/gbl/libstorage/src/testlib.rs b/gbl/libstorage/src/testlib.rs
deleted file mode 100644
index 246dd3f..0000000
--- a/gbl/libstorage/src/testlib.rs
+++ /dev/null
@@ -1,465 +0,0 @@
-// Copyright (C) 2024  Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Utilities for writing tests with libstorage, e.g. creating fake block devices.
-
-use crc32fast::Hasher;
-use gbl_async::yield_now;
-pub use gbl_storage::*;
-use liberror::{Error, Result};
-use safemath::SafeNum;
-use std::collections::{BTreeMap, VecDeque};
-use zerocopy::AsBytes;
-
-/// Helper `gbl_storage::BlockIoSync` struct for TestBlockDevice.
-pub struct TestBlockIo {
-    /// The storage block size in bytes.
-    pub block_size: u64,
-    /// The storage access alignment in bytes.
-    pub alignment: u64,
-    /// The backing storage data.
-    pub storage: Vec<u8>,
-    /// The number of successful write calls.
-    pub num_writes: usize,
-    /// The number of successful read calls.
-    pub num_reads: usize,
-    /// Injected errors.
-    pub errors: VecDeque<Error>,
-}
-
-impl TestBlockIo {
-    /// Creates a new [TestBlockIo].
-    pub fn new(block_size: u64, alignment: u64, data: Vec<u8>) -> Self {
-        Self {
-            block_size,
-            alignment,
-            storage: data,
-            num_writes: 0,
-            num_reads: 0,
-            errors: Default::default(),
-        }
-    }
-
-    fn check_alignment(&mut self, buffer: &[u8]) -> bool {
-        matches!(is_buffer_aligned(buffer, self.alignment), Ok(true))
-            && matches!(is_aligned(buffer.len().into(), self.block_size.into()), Ok(true))
-    }
-}
-
-impl BlockIoAsync for TestBlockIo {
-    /// Returns a `BlockInfo` for the block device.
-    fn info(&mut self) -> BlockInfo {
-        BlockInfo {
-            block_size: self.block_size,
-            num_blocks: u64::try_from(self.storage.len()).unwrap() / self.block_size,
-            alignment: self.alignment,
-        }
-    }
-
-    async fn read_blocks(&mut self, blk_offset: u64, out: &mut [u8]) -> Result<()> {
-        assert!(self.check_alignment(out));
-        let offset = (SafeNum::from(blk_offset) * self.block_size).try_into().unwrap();
-        yield_now().await; // yield once to simulate IO pending.
-        match self.errors.pop_front() {
-            Some(e) => Err(e),
-            _ => Ok(out.clone_from_slice(&self.storage[offset..][..out.len()])),
-        }
-    }
-
-    async fn write_blocks(&mut self, blk_offset: u64, data: &mut [u8]) -> Result<()> {
-        assert!(self.check_alignment(data));
-        let offset = (SafeNum::from(blk_offset) * self.block_size).try_into().unwrap();
-        yield_now().await; // yield once to simulate IO pending.
-        match self.errors.pop_front() {
-            Some(e) => Err(e),
-            _ => Ok(self.storage[offset..][..data.len()].clone_from_slice(data)),
-        }
-    }
-}
-
-/// Simple RAM based block device used by unit tests.
-pub struct TestBlockDevice {
-    /// The mock block device.
-    pub io: TestBlockIo,
-    /// In-memory backing store.
-    pub scratch: Vec<u8>,
-    max_gpt_entries: u64,
-}
-
-impl From<&[u8]> for TestBlockDevice {
-    fn from(data: &[u8]) -> Self {
-        TestBlockDeviceBuilder::new().set_data(data).build()
-    }
-}
-
-impl AsBlockDevice for TestBlockDevice {
-    fn with(&mut self, f: &mut dyn FnMut(&mut dyn BlockIoSync, &mut [u8], u64)) {
-        f(&mut self.io, &mut self.scratch[..], self.max_gpt_entries)
-    }
-}
-
-impl Default for TestBlockDevice {
-    fn default() -> Self {
-        TestBlockDeviceBuilder::new().build()
-    }
-}
-
-impl TestBlockDevice {
-    /// Creates an instance of `AsyncGptDevice`
-    pub fn as_gpt_dev(&mut self) -> AsyncGptDevice<'_, &mut TestBlockIo> {
-        AsyncGptDevice::<&mut TestBlockIo>::new_from_monotonic_buffer(
-            &mut self.io,
-            &mut self.scratch[..],
-            self.max_gpt_entries,
-        )
-        .unwrap()
-    }
-
-    /// Creates an instance of `AsyncBlockDevice`
-    pub fn as_blk_dev(&mut self) -> AsyncBlockDevice<'_, &mut TestBlockIo> {
-        self.as_gpt_dev().into_blk_and_gpt().0
-    }
-}
-
-/// A description of the backing data store for a block device or partition.
-/// Can either describe explicit data the device or partition is initialized with
-/// OR a size in bytes if the device or partition can be initialized in a blank state.
-#[derive(Copy, Clone)]
-pub enum BackingStore<'a> {
-    /// Exact data to use for the storage.
-    Data(&'a [u8]),
-    /// Data size to use, will be initialized as zeros.
-    Size(usize),
-}
-
-impl<'a> BackingStore<'a> {
-    fn size(&self) -> usize {
-        match self {
-            Self::Data(slice) => slice.len(),
-            Self::Size(size) => *size,
-        }
-    }
-}
-
-enum DiskDescription<'a> {
-    Disk(BackingStore<'a>),
-    Partitions(BTreeMap<&'static str, BackingStore<'a>>),
-}
-
-/// Builder struct for TestBlockDevice.
-/// Most tests will want either:
-/// 1) A blank device of a reasonable size OR
-/// 2) A device with specific initial data.
-/// Other customizations include block size,
-/// the maximum number of GPT entries,
-/// the alignment requirements,
-/// and the size of the scratch buffer.
-///
-/// Note: setting the storage size or storage data is generally safe,
-///       as long as the backing store is large enough,
-///       but customizing other attributes may generate a block device
-///       that cannot successfully complete any operations.
-///       This may be exactly the intention, but be warned that it can be tricky
-///       to customize the device and generate something that works without errors.
-pub struct TestBlockDeviceBuilder<'a> {
-    block_size: u64,
-    max_gpt_entries: u64,
-    alignment: u64,
-    disk_description: DiskDescription<'a>,
-    scratch_size: Option<usize>,
-}
-
-impl<'a> TestBlockDeviceBuilder<'a> {
-    /// The default access alignment in bytes.
-    pub const DEFAULT_ALIGNMENT: u64 = 64;
-    /// The default block size in bytes.
-    pub const DEFAULT_BLOCK_SIZE: u64 = 512;
-    /// The default maximum number of GPT entries.
-    pub const MAX_GPT_ENTRIES: u64 = 128;
-
-    /// Creates a new TestBlockDeviceBuilder with defaults for all attributes.
-    pub fn new() -> Self {
-        Self {
-            block_size: Self::DEFAULT_BLOCK_SIZE,
-            max_gpt_entries: Self::MAX_GPT_ENTRIES,
-            alignment: Self::DEFAULT_ALIGNMENT,
-            disk_description: DiskDescription::Disk(BackingStore::Size(
-                (Self::DEFAULT_BLOCK_SIZE * 32) as usize,
-            )),
-            scratch_size: None,
-        }
-    }
-
-    /// Set the block size of the block device in bytes.
-    /// The default is `DEFAULT_BLOCK_SIZE`.
-    pub fn set_block_size(mut self, block_size: u64) -> Self {
-        self.block_size = block_size;
-        self
-    }
-
-    /// Set the maximum number of GPT entries for the GPT header.
-    /// The default is `MAX_GPT_ENTRIES`.
-    /// Note: setting too large a number of entries will make a device
-    ///       that fails to sync its GPT.
-    pub fn set_max_gpt_entries(mut self, max_gpt_entries: u64) -> Self {
-        self.max_gpt_entries = max_gpt_entries;
-        self
-    }
-
-    /// Set the required alignment for the TestBlockDevice.
-    /// An alignment of `0` means there are no alignment requirements.
-    /// The default is `DEFAULT_ALIGNMENT`.
-    pub fn set_alignment(mut self, alignment: u64) -> Self {
-        self.alignment = alignment;
-        self
-    }
-
-    /// Set the size of TestBlockDevice in bytes.
-    /// When built, the TestBlockDevice will have a blank backing store of size `size`.
-    /// The default is `DEFAULT_BLOCK_SIZE` * 32.
-    ///
-    /// Note: This option is mutually exclusive with `set_data` and `add_partition`.
-    ///       If `set_data` or `add_partition` have been called, `set_size` overrides
-    ///       those customizations.
-    pub fn set_size(mut self, size: usize) -> Self {
-        self.disk_description = DiskDescription::Disk(BackingStore::Size(size));
-        self
-    }
-
-    /// Sets the block device's backing data to the provided slice.
-    ///
-    /// Note: This option is mutually exclusive with `set_size` and `add_partition`.
-    ///       If `set_size` or `add_partition` have been called, `set_data` overrides
-    ///       those customizations.
-    pub fn set_data(mut self, data: &'a [u8]) -> Self {
-        self.disk_description = DiskDescription::Disk(BackingStore::Data(data));
-        self
-    }
-
-    /// Adds a partition description.
-    /// Partitions can be defined either with a specific backing store
-    /// from a slice OR from a specific size in bytes.
-    /// Partition sizes are rounded up to full blocks.
-    /// If the same partition name is added multiple times,
-    /// the last definition is used.
-    ///
-    /// Note: explicitly added partitions are mutually exclusive with
-    ///       `set_size` and `set_data`.
-    ///       If either have been called, `add_partition` overrides that customization.
-    pub fn add_partition(mut self, name: &'static str, backing: BackingStore<'a>) -> Self {
-        match self.disk_description {
-            DiskDescription::Disk(_) => {
-                let mut map = BTreeMap::new();
-                map.insert(name, backing);
-                self.disk_description = DiskDescription::Partitions(map);
-            }
-            DiskDescription::Partitions(ref mut map) => {
-                map.insert(name, backing);
-            }
-        };
-        self
-    }
-
-    /// Customize the size of the block device's scratch buffer.
-    /// The default size is a known safe minimum calculated when `build()` is called.
-    ///
-    /// Note: Too small a scratch buffer will generate errors.
-    ///       Unless a test is specifically interested in a non-default
-    ///       scratch size, it's better to rely on the default size.
-    pub fn set_scratch_size(mut self, scratch_size: usize) -> Self {
-        self.scratch_size = Some(scratch_size);
-        self
-    }
-
-    /// Consumes the builder and generates a TestBlockDevice
-    /// with the desired customizations.
-    pub fn build(self) -> TestBlockDevice {
-        let storage = match self.disk_description {
-            DiskDescription::Disk(BackingStore::Data(slice)) => Vec::from(slice),
-            DiskDescription::Disk(BackingStore::Size(size)) => vec![0u8; size],
-            DiskDescription::Partitions(partitions) => {
-                partitions_to_disk_data(&partitions, self.block_size as usize)
-            }
-        };
-        assert_eq!(storage.len() % (self.block_size as usize), 0);
-        let mut io = TestBlockIo::new(self.block_size, self.alignment, storage);
-        let scratch_size = match self.scratch_size {
-            Some(s) => s,
-            None => {
-                required_scratch_size(BlockIoSync::info(&mut io), self.max_gpt_entries).unwrap()
-            }
-        };
-        TestBlockDevice {
-            io,
-            scratch: vec![0u8; scratch_size],
-            max_gpt_entries: self.max_gpt_entries,
-        }
-    }
-}
-
-fn str_to_utf16_entry_name(name: &str) -> [u16; GPT_NAME_LEN_U16] {
-    assert!(name.len() < GPT_NAME_LEN_U16);
-    let mut data = [0; GPT_NAME_LEN_U16];
-    let tmp: Vec<u16> = name.encode_utf16().collect();
-    for (d, t) in std::iter::zip(data.iter_mut(), tmp) {
-        *d = t;
-    }
-    data
-}
-
-fn pad_to_block_size(store: &mut Vec<u8>, block_size: usize) {
-    let delta = (block_size - store.len() % block_size) % block_size;
-    for _ in 0..delta {
-        store.push(0);
-    }
-}
-
-fn add_blocks(store: &mut Vec<u8>, data: &[u8], block_size: usize) {
-    store.extend(data.iter());
-    pad_to_block_size(store, block_size);
-}
-
-fn pad_bytes(store: &mut Vec<u8>, size: usize, block_size: usize) {
-    for _ in 0..size {
-        store.push(0);
-    }
-    pad_to_block_size(store, block_size);
-}
-
-fn partitions_to_disk_data(
-    partitions: &BTreeMap<&'static str, BackingStore>,
-    block_size: usize,
-) -> Vec<u8> {
-    let gpt_max_entries = 128;
-    assert!(partitions.len() <= gpt_max_entries);
-    let entry_blocks: u64 = ((SafeNum::from(partitions.len()) * std::mem::size_of::<GptEntry>())
-        .round_up(block_size)
-        / block_size)
-        .try_into()
-        .unwrap();
-    let mut block = entry_blocks
-        + 1  // Protective MBR
-        + 1 // Primary GPT header
-        ;
-    // Leading mbr
-    let mut store = vec![0; block_size];
-    let mut header = GptHeader {
-        magic: GPT_MAGIC,
-        current: 1,
-        size: std::mem::size_of::<GptHeader>() as u32,
-        first: block,
-        entries: 2,
-        entries_count: std::cmp::min(partitions.len(), gpt_max_entries) as u32,
-        entries_size: std::mem::size_of::<GptEntry>() as u32,
-        ..Default::default()
-    };
-
-    // Define gpt entry structures
-    let entries: Vec<GptEntry> = partitions
-        .iter()
-        .take(gpt_max_entries)
-        .map(|(k, v)| {
-            let last = (SafeNum::from(v.size()).round_up(block_size) / block_size + block - 1)
-                .try_into()
-                .unwrap();
-            let mut entry = GptEntry {
-                part_type: Default::default(),
-                guid: Default::default(),
-                first: block,
-                last,
-                flags: 0,
-                name: str_to_utf16_entry_name(k),
-            };
-            entry.guid[0] = block as u8;
-            block = last + 1;
-            entry
-        })
-        .collect();
-
-    // Patch last fields of header
-    header.last = block - 1;
-    header.backup = block + entry_blocks;
-    header.entries_crc = entries
-        .iter()
-        .fold(Hasher::new(), |mut h, e| {
-            h.update(e.as_bytes());
-            h
-        })
-        .finalize();
-    header.update_crc();
-
-    // Primary header
-    add_blocks(&mut store, header.as_bytes(), block_size);
-
-    // Primary entries
-    for e in &entries {
-        store.extend(e.as_bytes());
-    }
-    pad_to_block_size(&mut store, block_size);
-
-    // Partition store
-    for p in partitions.values() {
-        match p {
-            BackingStore::Data(d) => add_blocks(&mut store, d, block_size),
-            BackingStore::Size(s) => pad_bytes(&mut store, *s, block_size),
-        };
-    }
-
-    // Backup entries
-    let backup_entries_block = store.len() / block_size;
-    for e in entries {
-        store.extend(e.as_bytes());
-    }
-    pad_to_block_size(&mut store, block_size);
-    // Tweak header to make it the backup.
-    header.current = header.backup;
-    header.backup = 1;
-    header.entries = backup_entries_block.try_into().unwrap();
-    header.update_crc();
-    add_blocks(&mut store, header.as_bytes(), block_size);
-
-    store
-}
-
-/// Simple RAM based multi-block device used for unit tests.
-pub struct TestMultiBlockDevices(pub Vec<TestBlockDevice>);
-
-impl TestMultiBlockDevices {
-    /// Creates a vector of `AsyncGptDevice`;
-    pub fn as_gpt_devs(&mut self) -> Vec<AsyncGptDevice<&mut TestBlockIo>> {
-        self.0.iter_mut().map(|v| v.as_gpt_dev()).collect::<Vec<_>>()
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_builder_partitions() {
-        let data: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];
-        let mut actual: [u8; 8] = Default::default();
-        let mut block_dev = TestBlockDeviceBuilder::new()
-            .add_partition("squid", BackingStore::Data(&data))
-            .add_partition("clam", BackingStore::Size(28))
-            .build();
-
-        assert!(block_dev.sync_gpt().is_ok());
-        assert!(block_dev.read_gpt_partition("squid", 0, actual.as_mut_slice()).is_ok());
-        assert_eq!(actual, data);
-
-        assert!(block_dev.read_gpt_partition("clam", 0, actual.as_mut_slice()).is_ok());
-        assert_eq!(actual, [0u8; 8]);
-    }
-}
diff --git a/gbl/libbootconfig/BUILD b/gbl/libutils/BUILD
similarity index 76%
rename from gbl/libbootconfig/BUILD
rename to gbl/libutils/BUILD
index 8ad14b8..fe7e4f0 100644
--- a/gbl/libbootconfig/BUILD
+++ b/gbl/libutils/BUILD
@@ -1,4 +1,4 @@
-# Copyright (C) 2023 The Android Open Source Project
+# Copyright (C) 2024 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -15,23 +15,22 @@
 load("@gbl//toolchain:gbl_workspace_util.bzl", "ANDROID_RUST_LINTS")
 load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
 
-package(
-    default_visibility = ["//visibility:public"],
-)
-
 rust_library(
-    name = "libbootconfig",
-    srcs = ["src/lib.rs"],
-    crate_name = "bootconfig",
+    name = "libutils",
+    srcs = [
+        "src/lib.rs",
+    ],
     edition = "2021",
     rustc_flags = ANDROID_RUST_LINTS,
+    visibility = ["//visibility:public"],
     deps = [
         "@gbl//liberror",
+        "@gbl//libsafemath",
     ],
 )
 
 rust_test(
-    name = "libbootconfig_test",
-    crate = ":libbootconfig",
+    name = "test",
+    crate = ":libutils",
     rustc_flags = ANDROID_RUST_LINTS,
 )
diff --git a/gbl/libutils/src/lib.rs b/gbl/libutils/src/lib.rs
new file mode 100644
index 0000000..ad5932e
--- /dev/null
+++ b/gbl/libutils/src/lib.rs
@@ -0,0 +1,134 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Low-level utilities shared across multiple GBL libraries.
+
+#![cfg_attr(not(test), no_std)]
+
+use liberror::{Error, Result};
+use safemath::SafeNum;
+
+/// Returns the largest aligned subslice.
+///
+/// This function drops as many bytes as needed from the front of the given slice to ensure the
+/// result is properly-aligned. It does not truncate bytes from the end, so the resulting size may
+/// not be a multiple of `alignment`.
+///
+/// If the next `alignment` boundary would be directly following the last byte, this returns the
+/// 0-length slice at that alignment rather than an error, to match standard slicing behavior.
+///
+/// # Arguments
+/// * `bytes`: the byte slice to align
+/// * `alignment`: the desired starting alignment
+///
+/// # Returns
+/// * The subslice on success
+/// * [Error::ArithmeticOverflow] if `bytes` overflows when finding the next `alignment`
+/// * [Error::BufferTooSmall] if `bytes` is not large enough to reach the next `alignment`. The
+///   error will contain the size that would have been needed to reach `alignment`.
+pub fn aligned_subslice<T>(bytes: &mut [u8], alignment: T) -> Result<&mut [u8]>
+where
+    T: Copy + Into<SafeNum>,
+{
+    let addr = bytes.as_ptr() as usize;
+    let aligned_offset = (SafeNum::from(addr).round_up(alignment) - addr).try_into()?;
+    Ok(bytes.get_mut(aligned_offset..).ok_or(Error::BufferTooSmall(Some(aligned_offset)))?)
+}
+
+/// A helper for getting the offset of the first byte with and aligned address.
+///
+/// # Arguments
+/// * `bytes`: the byte slice
+/// * `alignment`: the desired starting alignment.
+///
+/// # Returns
+///
+/// * Returns Ok(offset) on success, Err() on integer overflow.
+pub fn aligned_offset<T>(buffer: &[u8], alignment: T) -> Result<usize>
+where
+    T: Copy + Into<SafeNum>,
+{
+    let addr = SafeNum::from(buffer.as_ptr() as usize);
+    (addr.round_up(alignment) - addr).try_into().map_err(From::from)
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    // A byte array that's always at least 8-byte aligned for testing.
+    #[repr(align(8))]
+    struct AlignedBytes<const N: usize>([u8; N]);
+
+    #[test]
+    fn aligned_subslice_already_aligned() {
+        let mut bytes = AlignedBytes([0u8; 16]);
+        let bytes = &mut bytes.0;
+
+        // AlignedBytes is `align(8)`, so must be 1/2/4/8-aligned.
+        assert_eq!(aligned_subslice(bytes, 1).unwrap().as_ptr_range(), bytes.as_ptr_range());
+        assert_eq!(aligned_subslice(bytes, 2).unwrap().as_ptr_range(), bytes.as_ptr_range());
+        assert_eq!(aligned_subslice(bytes, 4).unwrap().as_ptr_range(), bytes.as_ptr_range());
+        assert_eq!(aligned_subslice(bytes, 8).unwrap().as_ptr_range(), bytes.as_ptr_range());
+    }
+
+    #[test]
+    fn aligned_subslice_unaligned() {
+        let mut bytes = AlignedBytes([0u8; 16]);
+        let bytes = &mut bytes.0;
+
+        // AlignedBytes is 8-aligned, so offsetting by <8 should snap to the next 8-alignment.
+        assert_eq!(
+            aligned_subslice(&mut bytes[1..], 8).unwrap().as_ptr_range(),
+            bytes[8..].as_ptr_range()
+        );
+        assert_eq!(
+            aligned_subslice(&mut bytes[4..], 8).unwrap().as_ptr_range(),
+            bytes[8..].as_ptr_range()
+        );
+        assert_eq!(
+            aligned_subslice(&mut bytes[7..], 8).unwrap().as_ptr_range(),
+            bytes[8..].as_ptr_range()
+        );
+    }
+
+    #[test]
+    fn aligned_subslice_empty_slice() {
+        let mut bytes = AlignedBytes([0u8; 16]);
+        let bytes = &mut bytes.0;
+
+        // If the next alignment is just past the input, return the empty slice.
+        assert_eq!(
+            aligned_subslice(&mut bytes[9..], 8).unwrap().as_ptr_range(),
+            bytes[16..].as_ptr_range()
+        );
+    }
+
+    #[test]
+    fn aligned_subslice_buffer_overflow() {
+        let mut bytes = AlignedBytes([0u8; 7]); // 7 bytes; can't reach the next 8-alignment.
+        let bytes = &mut bytes.0;
+
+        assert_eq!(aligned_subslice(&mut bytes[1..], 8), Err(Error::BufferTooSmall(Some(7))));
+        assert_eq!(aligned_subslice(&mut bytes[6..], 8), Err(Error::BufferTooSmall(Some(2))));
+    }
+
+    #[test]
+    fn aligned_subslice_alignment_overflow() {
+        let mut bytes = AlignedBytes([0u8; 16]);
+        let bytes = &mut bytes.0;
+
+        assert!(matches!(aligned_subslice(bytes, SafeNum::MAX), Err(Error::ArithmeticOverflow(_))));
+    }
+}
diff --git a/gbl/rewrite_rust_project_path.py b/gbl/rewrite_rust_project_path.py
new file mode 100644
index 0000000..220e0bb
--- /dev/null
+++ b/gbl/rewrite_rust_project_path.py
@@ -0,0 +1,73 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import json
+import os
+import logging
+import tempfile
+
+# To generate rust-project.json from bazel, run
+# bazel run @rules_rust//tools/rust_analyzer:gen_rust_project --norepository_disable_download @gbl//efi:main
+# However, this yields incorrect source path.
+# Your source file
+# /usr/local/google/home/zhangkelvin/uefi-gbl-mainline/bootable/libbootloader/gbl/efi/src/main.rs
+# would turn into
+# /usr/local/google/home/uefi-gbl-mainline/out/bazel/output_user_root/e14d642d361d598c63507c64a56ecbc7/execroot/_main/external/gbl/efi/src/main.rs
+# and this confuses the rust-analyzer. This script will resolve the right
+# source path for you by checking if any of the parent path is a symlink,
+# and resolve all symlinks to final destination.
+
+
+def traverse(obj: dict):
+  if isinstance(obj, dict):
+    for (key, val) in obj.items():
+      if key == "root_module" or key == "CARGO_MANIFEST_DIR":
+        obj[key] = os.path.realpath(val)
+        continue
+      elif key == "include_dirs" or key == "exclude_dirs":
+        obj[key] = [os.path.realpath(d) for d in val]
+        continue
+      elif key == "cfg" and isinstance(val, list):
+        obj[key] = [o for o in val if o != "test"]
+        continue
+      traverse(val)
+  elif isinstance(obj, list):
+    for item in obj:
+      traverse(item)
+
+
+def main(argv):
+  logging.basicConfig(level=logging.INFO)
+  rust_project_json_path = "rust-project.json"
+  if len(argv) == 2:
+    rust_project_json_path = argv[1]
+  rust_project_json_path = os.path.realpath(rust_project_json_path)
+  project_root_path = os.path.dirname(rust_project_json_path)
+  logging.info("Using %s as project root path", project_root_path)
+  with open(rust_project_json_path, "r") as fp:
+    data = json.load(fp)
+    traverse(data)
+
+  with tempfile.NamedTemporaryFile("w+") as fp:
+    json.dump(data, fp.file, indent=True)
+    os.rename(fp.name, rust_project_json_path)
+    # create the tempfile again so deleting it works after exiting this scope
+    with open(fp.name, "w"):
+      pass
+
+
+if __name__ == "__main__":
+  import sys
+
+  main(sys.argv)
diff --git a/gbl/smoltcp/BUILD.smoltcp.bazel b/gbl/smoltcp/BUILD.smoltcp.bazel
index 147567b..81598ab 100644
--- a/gbl/smoltcp/BUILD.smoltcp.bazel
+++ b/gbl/smoltcp/BUILD.smoltcp.bazel
@@ -97,6 +97,7 @@ rust_library(
         "socket",
         "socket-tcp",
         "socket-icmp",
+        "socket-udp",
     ],
     crate_root = "src/crate_root.rs",
     data = [
diff --git a/gbl/tests/BUILD b/gbl/tests/BUILD
index a20eccd..26dc38f 100644
--- a/gbl/tests/BUILD
+++ b/gbl/tests/BUILD
@@ -20,8 +20,8 @@ test_suite(
         "@gbl//libabr:libabr_tests",
         "@gbl//libasync:cyclic_executor_test",
         "@gbl//libasync:libasync_test",
-        "@gbl//libbootconfig:libbootconfig_test",
         "@gbl//libbootimg:libbootimg_test",
+        "@gbl//libbootparams:test",
         "@gbl//libc:libc_test",
         "@gbl//libdttable:libdttable_test",
         "@gbl//libefi:libefi_test",
@@ -35,7 +35,7 @@ test_suite(
         "@gbl//libsafemath:libsafemath_test",
         "@gbl//libstorage:libstorage_doc_test",
         "@gbl//libstorage:libstorage_test",
-        "@gbl//libstorage:libstorage_testlib_test",
-        "@gbl//third_party/libzbi:libzbi_test",
+        "@gbl//libutils:test",
+        "@zbi//:zbi_test",
     ],
 )
diff --git a/gbl/third_party/libzbi/Android.bp b/gbl/third_party/libzbi/Android.bp
deleted file mode 100644
index f2631cf..0000000
--- a/gbl/third_party/libzbi/Android.bp
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2023, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    default_applicable_licenses: ["Android-Apache-2.0"],
-}
-
-rust_defaults {
-    name: "libzbi_defaults",
-    crate_name: "zbi",
-    edition: "2021",
-    features: [],
-    srcs: ["src/lib.rs"],
-    rustlibs: ["libbitflags"],
-}
-
-rust_library {
-    name: "libzbi",
-    host_supported: true,
-    defaults: ["libzbi_defaults"],
-    rustlibs: ["libzerocopy"],
-}
-
-rust_library_rlib {
-    name: "libzbi_nostd",
-    defaults: ["libzbi_defaults"],
-    no_stdlibs: true,
-    prefer_rlib: true,
-    rustlibs: ["libzerocopy_nostd_noalloc"],
-}
-
-// libzbi unit tests to run on host.
-rust_test_host {
-    name: "libzbi_host_test",
-    defaults: ["libzbi_defaults"],
-    rustlibs: [
-        "libzerocopy",
-        "libhex",
-    ],
-}
-
-// libzbi unit tests to run on devices.
-rust_test {
-    name: "libzbi_device_test",
-    defaults: ["libzbi_defaults"],
-    rustlibs: [
-        "libzerocopy",
-        "libhex",
-    ],
-    test_suites: ["general-tests"],
-}
diff --git a/gbl/third_party/libzbi/BUILD b/gbl/third_party/libzbi/BUILD
deleted file mode 100644
index cb9a3d1..0000000
--- a/gbl/third_party/libzbi/BUILD
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
-
-rust_library(
-    name = "libzbi",
-    srcs = [
-        "src/lib.rs",
-        "src/zbi_format.rs",
-    ],
-    crate_name = "zbi",
-    edition = "2021",
-    visibility = ["//visibility:public"],
-    deps = [
-        "@bitflags",
-        "@zerocopy",
-    ],
-)
-
-rust_test(
-    name = "libzbi_test",
-    crate = ":libzbi",
-    deps = [
-        "@bitflags",
-        "@hex",
-        "@zerocopy",
-    ],
-)
diff --git a/gbl/third_party/libzbi/OWNERS b/gbl/third_party/libzbi/OWNERS
deleted file mode 100644
index 1f6cb1c..0000000
--- a/gbl/third_party/libzbi/OWNERS
+++ /dev/null
@@ -1,3 +0,0 @@
-sergiip@google.com
-dpursell@google.com
-rammuthiah@google.com
diff --git a/gbl/third_party/libzbi/README.md b/gbl/third_party/libzbi/README.md
deleted file mode 100644
index f659781..0000000
--- a/gbl/third_party/libzbi/README.md
+++ /dev/null
@@ -1,30 +0,0 @@
-# Rust ZBI lib
-
-Rust version of [C library](src/firmware/lib/zbi) to work with ZBI format.
-
-See Rust documentation for `zbi` for library details.
-
-# Notes
-
-Currently [`sdk/lib/zbi-format`](sdk/lib/zbi-format) is not ready to provide Rust bindings from FIDL.
-So we are using `buildgen` generated version from C headers: [`src/firmware/lib/zbi-rs/src/zbi_format.rs`](src/firmware/lib/zbi-rs/src/zbi_format.rs)
-
-Another alternative is manually created version: [`src/sys/lib/fuchsia-zbi/abi`](src/sys/lib/fuchsia-zbi/abi).
-
-# Dev flow
-
-This is temporary approach until butter way is found (http://b/297795783).
-
-Source of truth is considered Fuchsia version. To make any changes start with submitting it to Fuchsia tree, then copying to AOSP.
-
-Current version is copied for following revision: [commit](https://cs.opensource.google/fuchsia/fuchsia/+/74345229e91646568d27c481e24ae53efb280dca)
-
-To get just `zbi-rs` from Fuchsia following commands can be used:
-```
-git clone -n --depth=1 --filter=tree:0 sso://fuchsia/fuchsia
-cd fuchsia/
-git sparse-checkout set --no-clone src/firmware/lib/zbi-rs
-git checkout 5f37c4635b672076b289dec4f01b7bd4bf147640
-```
-
-Changing Licence in source files is required at the moment.
diff --git a/gbl/third_party/libzbi/TEST_MAPPING b/gbl/third_party/libzbi/TEST_MAPPING
deleted file mode 100644
index a28762f..0000000
--- a/gbl/third_party/libzbi/TEST_MAPPING
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "presubmit": [
-    {
-       "name": "libzbi_device_test"
-    }
-  ],
-  "postsubmit": [
-    {
-       "name": "libzbi_device_test"
-    }
-  ]
-}
diff --git a/gbl/third_party/libzbi/src/lib.rs b/gbl/third_party/libzbi/src/lib.rs
deleted file mode 100644
index 69e941f..0000000
--- a/gbl/third_party/libzbi/src/lib.rs
+++ /dev/null
@@ -1,2892 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![cfg_attr(not(any(test, android_dylib)), no_std)]
-
-//! ZBI Processing Library
-//!
-//! This library is meant to be a generic processing library for the ZBI format
-//! defined in sdk/lib/zbi-format/include/lib/zbi-format/zbi.h.
-//!
-//! Mainly it provides [`ZbiContainer`] that can create ([`ZbiContainer::new`]) valid container in
-//! the provided buffer. Or parses and checks ([`ZbiContainer::parse`]) existing container in the
-//! buffer. In both cases it provides iterator to walk thorough the items in container.
-//!
-//! Note: in both cases provided buffer must be properly aligned to [`ZBI_ALIGNMENT_USIZE`].
-//! Using [`align_buffer`] would do proper alignment for you.
-//!
-//! ```
-//! use zbi::{ZbiContainer, ZbiFlags, ZbiType, align_buffer};
-//!
-//! let mut buffer = [0; 200];
-//! let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-//! let mut container = ZbiContainer::new(buffer).unwrap();
-//! container.create_entry(ZbiType::DebugData, 0, ZbiFlags::default(), 10).unwrap();
-//! container.create_entry_with_payload(ZbiType::DebugData, 0, ZbiFlags::default(), &[]).unwrap();
-//!
-//! assert_eq!(container.iter().count(), 2);
-//!
-//! let mut it = container.iter();
-//! assert_eq!(it.next().unwrap().header.length, 10);
-//! assert_eq!(it.next().unwrap().header.length, 0);
-//! assert_eq!(it.next(), None);
-//! ```
-
-mod zbi_format;
-
-use bitflags::bitflags;
-use core::fmt::{Debug, Display, Formatter};
-use core::mem::{size_of, take};
-use core::ops::DerefMut;
-use zbi_format::*;
-use zerocopy::{AsBytes, ByteSlice, ByteSliceMut, Ref};
-
-type ZbiResult<T> = Result<T, ZbiError>;
-
-/// [`ZbiContainer`] requires buffer and each entry to be aligned to this amount of bytes.
-/// [`align_buffer`] can be used to adjust buffer alignment to match this requirement.
-// ZBI_ALIGNMENT is u32 and it is not productive to `try_into()` to usize all the time.
-// Expectation is that value should always fit in `u32` and `usize`, which we test.
-pub const ZBI_ALIGNMENT_USIZE: usize = ZBI_ALIGNMENT as usize;
-
-#[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
-const ZBI_ARCH_KERNEL_TYPE: ZbiType = ZbiType::KernelArm64;
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-const ZBI_ARCH_KERNEL_TYPE: ZbiType = ZbiType::KernelX64;
-#[cfg(any(target_arch = "riscv", target_arch = "riscv64"))]
-const ZBI_ARCH_KERNEL_TYPE: ZbiType = ZbiType::KernelRiscv64;
-
-/// Aligns provided slice to [`ZBI_ALIGNMENT_USIZE`] bytes.
-///
-/// # Returns
-///
-/// * `Ok(aligned_slice)` - on success, which can have `length == 0`
-/// * [`ZbiError::TooBig`] - returned if there is not enough space to align the slice
-pub fn align_buffer<B: ByteSlice>(buffer: B) -> ZbiResult<B> {
-    let tail_offset = get_align_buffer_offset(&buffer[..])?;
-    let (_, aligned_buffer) = buffer.split_at(tail_offset);
-    Ok(aligned_buffer)
-}
-
-/// ZbiItem is element representation in [`ZbiContainer`]
-///
-/// It contains of `header` and `payload`. Both contain references to actual location in buffer.
-/// And `payload` goes right after `header` in the buffer.
-///
-/// Header must be [`ZBI_ALIGNMENT_USIZE`] aligned in the buffer.
-/// The length field specifies the actual payload length and does not include the size of padding.
-/// Since all headers in [`ZbiContainer`] are [`ZBI_ALIGNMENT_USIZE`] aligned payload may be followed by padding,
-/// which is included in [`ZbiContainer`] length, but not in each [`ZbiItem`]
-#[derive(Debug)]
-pub struct ZbiItem<B: ByteSlice> {
-    /// ZBI header
-    pub header: Ref<B, ZbiHeader>,
-    /// Payload corresponding to ZBI header
-    pub payload: B,
-}
-
-impl<B: ByteSlice, C: ByteSlice> PartialEq<ZbiItem<C>> for ZbiItem<B> {
-    fn eq(&self, other: &ZbiItem<C>) -> bool {
-        self.header.as_bytes() == other.header.as_bytes()
-            && self.payload.as_bytes() == other.payload.as_bytes()
-    }
-}
-
-impl<B: ByteSlice + PartialEq> ZbiItem<B> {
-    /// Attempts to parse provided buffer.
-    ///
-    /// # Arguments
-    /// * `buffer` - buffer to parse (can be mutable if further changes to element is required)
-    ///
-    /// # Returns
-    ///
-    /// * `Ok((ZbiItem, tail))` - if parsing was successful function returns `ZbiItem` and tail of
-    ///                           buffer that wasn't used.
-    /// * `Err(ZbiError)` - if parsing fails Err is returned.
-    ///
-    /// # Example
-    ///
-    /// ```
-    /// use zbi::ZbiItem;
-    ///
-    /// # const LEN: usize = 100;
-    /// # #[repr(align(8))]
-    /// # struct ZbiAligned([u8; LEN]);
-    /// # let buffer = ZbiAligned(core::array::from_fn::<_, LEN, _>(|_| 0u8));
-    /// # let buffer = &buffer.0[..];
-    /// let (zbi_item, tail) = ZbiItem::parse(buffer).unwrap();
-    /// println!("{}", zbi_item.header.type_);
-    /// println!("{}", tail.len());
-    /// assert_eq!(zbi_item.header.length, zbi_item.payload.len() as u32);
-    /// ```
-    pub fn parse(buffer: B) -> ZbiResult<(ZbiItem<B>, B)> {
-        is_zbi_aligned(&buffer)?;
-
-        let (hdr, payload) = Ref::<B, ZbiHeader>::new_from_prefix(buffer).ok_or(ZbiError::Error)?;
-
-        let item_payload_len =
-            usize::try_from(hdr.length).map_err(|_| ZbiError::PlatformBadLength)?;
-        if payload.len() < item_payload_len {
-            return Err(ZbiError::TooBig);
-        }
-
-        let (item_payload, tail) = payload.split_at(item_payload_len);
-        let item = ZbiItem { header: hdr, payload: item_payload };
-        Ok((item, tail))
-    }
-
-    /// Validates `ZbiItem` header values.
-    ///
-    /// # Example
-    ///
-    /// ```
-    /// use zbi::{ZbiItem, ZbiError};
-    ///
-    /// # const LEN: usize = 100;
-    /// # #[repr(align(8))]
-    /// # struct ZbiAligned([u8; LEN]);
-    /// # let buffer = ZbiAligned(core::array::from_fn::<_, LEN, _>(|_| 0u8));
-    /// # let buffer = &buffer.0[..];
-    /// // E.g. if `header.magic = 0` this is invalid value.
-    /// let (zbi_item, tail) = ZbiItem::parse(buffer).unwrap();
-    /// assert_eq!(zbi_item.header.magic, 0);
-    /// assert_eq!(zbi_item.is_valid(), Err(ZbiError::BadMagic));
-    /// ```
-    pub fn is_valid(&self) -> ZbiResult<()> {
-        if self.header.magic != ZBI_ITEM_MAGIC {
-            Err(ZbiError::BadMagic)
-        } else if !self.header.get_flags().contains(ZbiFlags::VERSION) {
-            Err(ZbiError::BadVersion)
-        } else if !self.header.get_flags().contains(ZbiFlags::CRC32)
-            && (self.header.crc32 != ZBI_ITEM_NO_CRC32)
-        {
-            Err(ZbiError::BadCrc)
-        } else {
-            Ok(())
-        }
-    }
-}
-
-impl<B: ByteSliceMut + PartialEq> ZbiItem<B> {
-    /// Create `ZbiItem` with provided information and payload length.
-    ///
-    ///
-    /// # Result
-    ///
-    /// * `(ZbiItem, tail)` - returned on success. `ZbiItem` would have payload of requested
-    ///                       length. And tail would be remaining part of the `buffer` that wasn't
-    ///                       used.
-    /// * `ZbiError::BadAlignment` - if buffer wasn't aligned.
-    /// * `ZbiError::TooBig` - if buffer is not long enough to hold
-    ///                        [`ZbiHeader`] + `payload` of `payload_len`.
-    /// * `ZbiError::PlatformBadLength` - if `payload_len` value is bigger than `u32::MAX`
-    ///
-    /// # Example
-    /// ```
-    /// use zbi::{ZbiItem, ZbiFlags, ZbiType};
-    ///
-    /// # const LEN: usize = 100;
-    /// # #[repr(align(8))]
-    /// # struct ZbiAligned([u8; LEN]);
-    /// # let mut buffer = ZbiAligned(core::array::from_fn::<_, LEN, _>(|_| 0u8));
-    /// # let mut buffer = &mut buffer.0[..];
-    /// let (item, _tail) = ZbiItem::new(
-    ///     &mut buffer[..],
-    ///     ZbiType::KernelX64,
-    ///     0,
-    ///     ZbiFlags::default(),
-    ///     2,
-    /// ).unwrap();
-    /// assert_eq!(item.header.length, 2);
-    /// assert_eq!(item.payload.len(), 2);
-    /// ```
-    pub fn new(
-        buffer: B,
-        type_: ZbiType,
-        extra: u32,
-        flags: ZbiFlags,
-        payload_len: usize,
-    ) -> ZbiResult<(ZbiItem<B>, B)> {
-        if buffer.len() < core::mem::size_of::<ZbiHeader>()
-            || buffer.len() - core::mem::size_of::<ZbiHeader>() < payload_len
-        {
-            return Err(ZbiError::TooBig);
-        }
-
-        is_zbi_aligned(&buffer)?;
-
-        // Need to convert payload_len to u32 type to put in structure
-        let payload_len_u32 =
-            u32::try_from(payload_len).map_err(|_| ZbiError::PlatformBadLength)?;
-
-        let (mut header, item_tail) =
-            Ref::<B, ZbiHeader>::new_from_prefix(buffer).ok_or(ZbiError::Error)?;
-        header.type_ = type_ as u32;
-        header.length = payload_len_u32;
-        header.extra = extra;
-        header.set_flags(&flags);
-        header.reserved0 = 0;
-        header.reserved1 = 0;
-        header.magic = ZBI_ITEM_MAGIC;
-        header.crc32 = ZBI_ITEM_NO_CRC32;
-
-        // It is safe to do split because we checked if input buffer big enough to contain header
-        // and requested payload size.
-        let (payload, tail) = item_tail.split_at(payload_len);
-
-        Ok((ZbiItem { header, payload }, tail))
-    }
-}
-
-/// Main structure to work with ZBI format.
-///
-/// It allows to create valid buffer as well as parse existing one.
-/// Both cases would allow to iterate over elements in the container via [`ZbiContainer::iter`] or
-/// [`ZbiContainer::iter_mut`].
-#[derive(Debug, PartialEq)]
-pub struct ZbiContainer<B: ByteSlice> {
-    /// Container specific [`ZbiHeader`], witch would be first element if ZBI buffer.
-    ///
-    /// `header.length` would show how many bytes after this header is used for ZBI elements and
-    /// padding.
-    ///
-    /// `header.type_` is always [`ZbiType::Container`]
-    pub header: Ref<B, ZbiHeader>,
-
-    // Same as header.header.length, but for convenience is `usize` to avoid use of try_into and
-    // returning ZbiError if we need to use it.
-    // Use getters and setters to access length:
-    //  - set_payload_length_usize()
-    //  - get_payload_length_u32()
-    //  - get_payload_length_usize()
-    payload_length: usize,
-
-    // Buffer that follows `header`. It contains ZbiItems + padding if any and remaining tail for
-    // possible growth.
-    buffer: B,
-}
-
-impl<B: ByteSlice> ZbiContainer<B> {
-    // Helper to construct [`ZbiContainer`] which handles `paload_length` value, which should be
-    // in sync with `header.length`.
-    fn construct(header: Ref<B, ZbiHeader>, buffer: B) -> ZbiResult<Self> {
-        Ok(Self {
-            payload_length: usize::try_from(header.length)
-                .map_err(|_| ZbiError::PlatformBadLength)?,
-            header,
-            buffer,
-        })
-    }
-
-    /// Returns current container length as `u32`. Length doesn't include container header, only
-    /// items and padding.
-    pub fn get_payload_length_u32(&self) -> u32 {
-        self.header.length
-    }
-
-    /// Returns current container length as `usize`. Length doesn't include container header, only
-    /// items and padding.
-    pub fn get_payload_length_usize(&self) -> usize {
-        self.payload_length
-    }
-
-    /// Returns the total size including the ZBI container header, payload length after padding.
-    pub fn container_size(&self) -> usize {
-        self.get_payload_length_usize() + size_of::<ZbiHeader>()
-    }
-
-    /// Immutable iterator over ZBI elements. First element is first ZBI element after
-    /// container header. Container header is not available via iterator.
-    pub fn iter(&self) -> ZbiContainerIterator<impl ByteSlice + Default + Debug + PartialEq + '_> {
-        ZbiContainerIterator {
-            state: Ok(()),
-            buffer: &self.buffer[..self.get_payload_length_usize()],
-        }
-    }
-
-    /// Validates if ZBI is bootable for the target platform.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(item)` - if bootable, where `item` is the ZBI kernel item.
-    /// * Err([`ZbiError::IncompleteKernel`]) - if first element in container has type not bootable
-    ///                                         on target platform.
-    /// * Err([`ZbiError::Truncated`]) - if container is empty
-    pub fn is_bootable(
-        &self,
-    ) -> ZbiResult<ZbiItem<impl ByteSlice + Default + Debug + PartialEq + '_>> {
-        let hdr = &self.header;
-        if hdr.length == 0 {
-            return Err(ZbiError::Truncated);
-        }
-
-        match self.iter().next() {
-            Some(v) if v.header.type_ == ZBI_ARCH_KERNEL_TYPE as u32 => Ok(v),
-            Some(_) => Err(ZbiError::IncompleteKernel),
-            None => Err(ZbiError::Truncated),
-        }
-    }
-
-    /// Returns the ZBI kernel `entry` and `reserved_memory_size` field value if the container is a
-    /// bootable ZBI kernel.
-    ///
-    /// # Returns
-    ///
-    /// * Returns `Ok((entry, reserved_memory_size))` on success.
-    /// * Returns `Err` if container is not a bootable ZBI kernel or is truncated.
-    pub fn get_kernel_entry_and_reserved_memory_size(&self) -> ZbiResult<(u64, u64)> {
-        let kernel = self.is_bootable()?;
-        let vals = Ref::<_, [u64]>::new_slice_from_prefix(kernel.payload, 2)
-            .ok_or(ZbiError::IncompleteKernel)?
-            .0
-            .into_slice();
-        Ok((vals[0], vals[1]))
-    }
-
-    /// Computes the required buffer size needed for relocating this ZBI kernel.
-    ///
-    /// # Returns
-    ///
-    /// * Returns `Ok(size)` on success.
-    /// * Returns `Err` if container is not a valid bootable ZBI kernel.
-    pub fn get_buffer_size_for_kernel_relocation(&self) -> ZbiResult<usize> {
-        let kernel = self.is_bootable()?;
-        let (_, reserve_memory_size) = self.get_kernel_entry_and_reserved_memory_size()?;
-        let kernel_size = 2 * size_of::<ZbiHeader>() + kernel.payload.as_bytes().len();
-        let reserve_memory_size =
-            usize::try_from(reserve_memory_size).map_err(|_| ZbiError::LengthOverflow)?;
-        kernel_size.checked_add(reserve_memory_size).ok_or(ZbiError::LengthOverflow)
-    }
-
-    /// Creates `ZbiContainer` from provided buffer.
-    ///
-    /// Buffer must be aligned to [`ZBI_ALIGNMENT_USIZE`] ([`align_buffer`] could be
-    /// used for that). If buffer is mutable than container can be mutable.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(ZbiContainer)` - if buffer is aligned and contain valid buffer.
-    /// * Err([`ZbiError`]) - if error occurred.
-    pub fn parse(buffer: B) -> ZbiResult<Self> {
-        is_zbi_aligned(&buffer)?;
-
-        let (header, payload) =
-            Ref::<B, ZbiHeader>::new_from_prefix(buffer).ok_or(ZbiError::Error)?;
-
-        let length: usize = header.length.try_into().map_err(|_| ZbiError::TooBig)?;
-        if length > payload.len() {
-            return Err(ZbiError::Truncated);
-        }
-
-        if header.type_ != ZbiType::Container as u32 {
-            return Err(ZbiError::BadType);
-        } else if header.extra != ZBI_CONTAINER_MAGIC || header.magic != ZBI_ITEM_MAGIC {
-            return Err(ZbiError::BadMagic);
-        } else if !header.get_flags().contains(ZbiFlags::VERSION) {
-            return Err(ZbiError::BadVersion);
-        } else if !header.get_flags().contains(ZbiFlags::CRC32) && header.crc32 != ZBI_ITEM_NO_CRC32
-        {
-            return Err(ZbiError::BadCrc);
-        }
-
-        let res = Self::construct(header, payload)?;
-        // Compiler thinks it is still borrowed when we reach Ok(res), so adding scope for it
-        {
-            let mut it = res.iter();
-            for b in &mut it {
-                b.is_valid()?;
-            }
-
-            // Check if there were item parsing errors
-            it.state?;
-        }
-        Ok(res)
-    }
-}
-
-impl<B: ByteSliceMut + PartialEq> ZbiContainer<B> {
-    fn set_payload_length_usize(&mut self, len: usize) -> ZbiResult<()> {
-        if self.buffer.len() < len {
-            return Err(ZbiError::Truncated);
-        }
-        self.header.length = u32::try_from(len).map_err(|_| ZbiError::PlatformBadLength)?;
-        self.payload_length = len;
-        Ok(())
-    }
-
-    /// Creates new empty `ZbiContainer` using provided buffer.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(ZbiContainer)` - on success
-    /// * Err([`ZbiError`]) - on error
-    pub fn new(buffer: B) -> ZbiResult<Self> {
-        let (item, buffer) =
-            ZbiItem::new(buffer, ZbiType::Container, ZBI_CONTAINER_MAGIC, ZbiFlags::default(), 0)?;
-
-        Self::construct(item.header, buffer)
-    }
-
-    fn align_tail(&mut self) -> ZbiResult<()> {
-        let length = self.get_payload_length_usize();
-        let align_offset = get_align_buffer_offset(&self.buffer[length..])?;
-        let new_length = length + align_offset;
-        self.set_payload_length_usize(new_length)?;
-        Ok(())
-    }
-
-    /// Get payload slice for the next ZBI entry Next.
-    ///
-    /// Next entry should be added using [`ZbiContainer::create_entry`].
-    ///
-    /// This is useful when it's non-trivial to determine the length of a payload ahead of time -
-    /// for example, loading a variable-length string from persistent storage.
-    ///
-    /// Rather than loading the payload into a temporary buffer, determining the length, then
-    /// copying it into the ZBI, this function allows loading data directly into the ZBI. Since this
-    /// buffer is currently unused area, loading data here does not affect the ZBI until
-    /// zbi_create_entry() is called.
-    ///
-    /// # Example
-    ///
-    /// ```
-    /// # use zbi::{ZbiContainer, ZbiFlags, ZbiType, align_buffer};
-    /// #
-    /// # let mut buffer = [0; 100];
-    /// # let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-    /// # let mut container = ZbiContainer::new(buffer).unwrap();
-    /// #
-    /// # let payload_to_use = [1, 2, 3, 4];
-    /// let next_payload = container.get_next_payload().unwrap();
-    /// next_payload[..payload_to_use.len()].copy_from_slice(&payload_to_use[..]);
-    ///
-    /// container
-    ///     .create_entry(ZbiType::KernelX64, 0, ZbiFlags::default(), payload_to_use.len())
-    ///     .unwrap();
-    ///
-    /// assert_eq!(container.iter().count(), 1);
-    /// assert_eq!(&*container.iter().next().unwrap().payload, &payload_to_use[..]);
-    /// ```
-    ///
-    /// # Returns:
-    /// `Ok(&mut [u8])` - on success; slice of buffer where next entries payload would be located.
-    /// Err([`ZbiError::TooBig`]) - if buffer is not big enough for new element without payload.
-    pub fn get_next_payload(&mut self) -> ZbiResult<&mut [u8]> {
-        let length = self.get_payload_length_usize();
-        let align_payload_offset = length
-            .checked_add(size_of::<ZbiHeader>())
-            .ok_or(ZbiError::LengthOverflow)?
-            .checked_add(get_align_buffer_offset(&self.buffer[length..])?)
-            .ok_or(ZbiError::LengthOverflow)?;
-        if self.buffer.len() < align_payload_offset {
-            return Err(ZbiError::TooBig);
-        }
-        Ok(&mut self.buffer[align_payload_offset..])
-    }
-
-    /// Creates a new ZBI entry with the provided payload.
-    ///
-    /// The new entry is aligned to [`ZBI_ALIGNMENT_USIZE`]. The capacity of the base ZBI must
-    /// be large enough to fit the new entry.
-    ///
-    /// The [`ZbiFlags::VERSION`] is unconditionally set for the new entry.
-    ///
-    /// The [`ZbiFlags::CRC32`] flag yields an error because CRC computation is not yet
-    /// supported.
-    ///
-    /// # Arguments
-    ///   * `type_` - The new entry's type
-    ///   * `extra` - The new entry's type-specific data
-    ///   * `flags` - The new entry's flags
-    ///   * `payload` - The payload, copied into the new entry
-    ///
-    /// # Returns:
-    ///   * Ok(()) - on success
-    ///   * Err([`ZbiError::TooBig`]) - if buffer is not big enough for new element with payload
-    ///   * Err([`ZbiError::Crc32NotSupported`]) - if unsupported [`ZbiFlags::CRC32`] is set
-    ///   * Err([`ZbiError`]) - if other errors occurred
-    ///
-    /// # Example
-    /// ```
-    /// # use zbi::{ZbiContainer, ZbiFlags, ZbiType, align_buffer};
-    /// #
-    /// # let mut buffer = [0; 100];
-    /// # let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-    /// # let mut container = ZbiContainer::new(buffer).unwrap();
-    /// #
-    /// container
-    ///     .create_entry_with_payload(ZbiType::KernelX64, 0, ZbiFlags::default(), &[1, 2, 3, 4])
-    ///     .unwrap();
-    /// assert_eq!(container.iter().count(), 1);
-    /// assert_eq!(&*container.iter().next().unwrap().payload, &[1, 2, 3, 4]);
-    /// ```
-    pub fn create_entry_with_payload(
-        &mut self,
-        type_: ZbiType,
-        extra: u32,
-        flags: ZbiFlags,
-        payload: &[u8],
-    ) -> ZbiResult<()> {
-        self.get_next_payload()?[..payload.len()].copy_from_slice(payload);
-        self.create_entry(type_, extra, flags, payload.len())
-    }
-
-    /// Creates a new ZBI entry and returns a pointer to the payload.
-    ///
-    /// The new entry is aligned to [`ZBI_ALIGNMENT_USIZE`]. The capacity of the base ZBI must
-    /// be large enough to fit the new entry.
-    ///
-    /// The [`ZbiFlags::VERSION`] is unconditionally set for the new entry.
-    ///
-    /// The [`ZbiFlags::CRC32`] flag yields an error because CRC computation is not yet
-    /// supported.
-    ///
-    /// # Arguments
-    ///   * `type_` - The new entry's type.
-    ///   * `extra` - The new entry's type-specific data.
-    ///   * `flags` - The new entry's flags.
-    ///   * `payload_length` - The length of the new entry's payload.
-    ///
-    /// # Returns
-    ///   * Ok(()) - On success.
-    ///   * Err([`ZbiError::TooBig`]) - if buffer is not big enough for new element with payload
-    ///   * Err([`ZbiError::Crc32NotSupported`]) - if unsupported [`ZbiFlags::CRC32`] is set
-    ///   * Err([`ZbiError`]) - if other errors occurred
-    ///
-    /// # Example
-    /// ```
-    /// # use zbi::{ZbiContainer, ZbiFlags, ZbiType, align_buffer};
-    /// #
-    /// # let mut buffer = [0; 100];
-    /// # let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-    /// # let mut container = ZbiContainer::new(buffer).unwrap();
-    /// #
-    /// # let payload_to_use = [1, 2, 3, 4];
-    /// let next_payload = container.get_next_payload().unwrap();
-    /// next_payload[..payload_to_use.len()].copy_from_slice(&payload_to_use[..]);
-    ///
-    /// container
-    ///     .create_entry(ZbiType::KernelX64, 0, ZbiFlags::default(), payload_to_use.len())
-    ///     .unwrap();
-    ///
-    /// assert_eq!(container.iter().count(), 1);
-    /// assert_eq!(&*container.iter().next().unwrap().payload, &payload_to_use[..]);
-    /// ```
-    pub fn create_entry(
-        &mut self,
-        type_: ZbiType,
-        extra: u32,
-        flags: ZbiFlags,
-        payload_length: usize,
-    ) -> ZbiResult<()> {
-        // We don't support CRC computation (yet?)
-        if flags.contains(ZbiFlags::CRC32) {
-            return Err(ZbiError::Crc32NotSupported);
-        }
-
-        let length = self.get_payload_length_usize();
-        let (item, _) =
-            ZbiItem::new(&mut self.buffer[length..], type_, extra, flags, payload_length)?;
-        let used = length
-            .checked_add(core::mem::size_of::<ZbiHeader>())
-            .ok_or(ZbiError::LengthOverflow)?
-            .checked_add(item.payload.len())
-            .ok_or(ZbiError::LengthOverflow)?;
-        self.set_payload_length_usize(used)?;
-        self.align_tail()?;
-        Ok(())
-    }
-
-    /// Extends a ZBI container with another container's payload.
-    ///
-    /// # Arguments
-    ///   * `other` - The container to copy the payload from.
-    ///
-    /// # Returns
-    ///   * `Ok(())` - On success.
-    ///   * Err([`ZbiError::TooBig`]) - If container is too small.
-    ///
-    /// # Example
-    /// ```
-    /// # use zbi::{ZbiContainer, ZbiType, ZbiFlags, align_buffer};
-    /// #
-    /// # let mut buffer = [0; 200];
-    /// # let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-    /// let mut container_0 = ZbiContainer::new(&mut buffer[..]).unwrap();
-    /// container_0
-    ///     .create_entry_with_payload(ZbiType::DebugData, 0, ZbiFlags::default(), &[0, 1])
-    ///     .unwrap();
-    ///
-    /// # let mut buffer = [0; 200];
-    /// # let mut buffer = align_buffer(&mut buffer[..]).unwrap();
-    /// let mut container_1 = ZbiContainer::new(&mut buffer[..]).unwrap();
-    /// container_1
-    ///     .create_entry_with_payload(ZbiType::KernelX64, 0, ZbiFlags::default(), &[0, 1, 3, 4])
-    ///     .unwrap();
-    ///
-    /// container_0.extend(&container_1).unwrap();
-    ///
-    /// assert_eq!(container_0.iter().count(), 2);
-    /// # let cont0_element_1 = &container_0
-    /// #     .iter()
-    /// #     .enumerate()
-    /// #     .filter_map(|(i, e)| if i == 1 { Some(e) } else { None })
-    /// #     .collect::<Vec<_>>()[0];
-    /// # let cont1_element_0 = &container_1.iter().next().unwrap();
-    /// # assert_eq!(cont0_element_1, cont1_element_0);
-    /// ```
-    pub fn extend(&mut self, other: &ZbiContainer<impl ByteSlice + PartialEq>) -> ZbiResult<()> {
-        let new_length = self
-            .get_payload_length_usize()
-            .checked_add(other.get_payload_length_usize())
-            .ok_or(ZbiError::LengthOverflow)?;
-        if self.buffer.len() < new_length {
-            return Err(ZbiError::TooBig);
-        }
-
-        for b in other.iter() {
-            let start = self.get_payload_length_usize();
-            let end = start + core::mem::size_of::<ZbiHeader>();
-            self.buffer[start..end].clone_from_slice(b.header.bytes());
-            let start = end;
-            let end = start + b.payload.len();
-            self.buffer[start..end].clone_from_slice(&b.payload);
-            self.set_payload_length_usize(end)?;
-            self.align_tail()?;
-        }
-        Ok(())
-    }
-
-    /// Extends with another ZBI container stored on a potentially unaligned buffer.
-    ///
-    /// The method copies `other` into the unused space first before checking validity and
-    /// extending. Thus if `other.len()` is greater than the remaining space in the container, it
-    /// it will be rejected, regardless of the actual container size.
-    pub fn extend_unaligned(&mut self, other: &[u8]) -> ZbiResult<()> {
-        let sz = self.get_payload_length_usize();
-        let remains = &mut self.buffer[sz..];
-        // Copies `other` to `dst` which is guaranteed aligned.
-        let dst = remains.get_mut(..other.len()).ok_or(ZbiError::TooBig)?;
-        dst.clone_from_slice(other);
-        // Checks the incoming container and extracts payload length (without padding).
-        let new_payload_len = ZbiContainer::parse(&mut dst[..])?.header.length;
-        // Shifts forward the payload to remove the ZBI header. This effectively appends the
-        // payload.
-        dst.copy_within(size_of::<ZbiHeader>().., 0);
-        self.set_payload_length_usize(
-            sz + usize::try_from(new_payload_len).map_err(|_| ZbiError::LengthOverflow)?,
-        )?;
-        self.align_tail()
-    }
-}
-
-impl<B: ByteSlice + PartialEq + DerefMut> ZbiContainer<B> {
-    /// Mutable iterator over ZBI elements. First element is first ZBI element after
-    /// container header. Container header is not available via iterator.
-    pub fn iter_mut(
-        &mut self,
-    ) -> ZbiContainerIterator<impl ByteSliceMut + Debug + Default + PartialEq + '_> {
-        let length = self.get_payload_length_usize();
-        ZbiContainerIterator { state: Ok(()), buffer: &mut self.buffer[..length] }
-    }
-}
-
-/// Container iterator
-// State is required to check elements are valid during parsing.
-// During this parsing can fail and we need to check if iterator returned `None` because there are
-// no more elements left or because there was an error.
-// If container object already exist state should never contain error, since container was already
-// verified.
-pub struct ZbiContainerIterator<B> {
-    state: ZbiResult<()>,
-    buffer: B,
-}
-
-impl<B: ByteSlice + PartialEq + Default + Debug> Iterator for ZbiContainerIterator<B> {
-    type Item = ZbiItem<B>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        // Align buffer before parsing
-        match align_buffer(take(&mut self.buffer)) {
-            Ok(v) => self.buffer = v,
-            Err(_) => {
-                self.state = Err(ZbiError::Truncated);
-                return None;
-            }
-        };
-
-        if self.buffer.is_empty() {
-            return None;
-        }
-
-        match ZbiItem::<B>::parse(take(&mut self.buffer)) {
-            Ok((item, mut tail)) => {
-                // Remove item that was just parsed from the buffer for next
-                // iteration before returning it.
-                core::mem::swap(&mut tail, &mut self.buffer);
-                Some(item)
-            }
-            Err(e) => {
-                // If there was an error during item parsing,
-                // make sure to set state to error, before signalling end of iteration.
-                self.state = Err(e);
-                None
-            }
-        }
-    }
-}
-
-#[repr(u32)]
-#[derive(AsBytes, Clone, Copy, Debug, Eq, PartialEq)]
-/// All possible [`ZbiHeader`]`.type` values.
-pub enum ZbiType {
-    /// Each ZBI starts with a container header.
-    /// * `length`: Total size of the image after this header. This includes all item headers,
-    ///             payloads, and padding. It does not include the container header itself.
-    ///             Must be a multiple of [`ZBI_ALIGNMENT_USIZE`].
-    /// * `extra`:  Must be `ZBI_CONTAINER_MAGIC`.
-    /// * `flags`:  Must be [`ZbiFlags::VERSION`] and no other flags.
-    Container = ZBI_TYPE_CONTAINER,
-
-    /// x86-64 kernel. See [`ZbiKernel`] for a payload description.
-    //
-    // 'KRNL'
-    KernelX64 = ZBI_TYPE_KERNEL_X64,
-
-    /// ARM64 kernel. See [`ZbiKernel`] for a payload description.
-    //
-    // KRN8
-    KernelArm64 = ZBI_TYPE_KERNEL_ARM64,
-
-    /// RISC-V kernel. See [`ZbiKernel`] for a payload description.
-    //
-    // 'KRNV'
-    KernelRiscv64 = ZBI_TYPE_KERNEL_RISCV64,
-
-    /// A discarded item that should just be ignored.  This is used for an
-    /// item that was already processed and should be ignored by whatever
-    /// stage is now looking at the ZBI.  An earlier stage already "consumed"
-    /// this information, but avoided copying data around to remove it from
-    /// the ZBI item stream.
-    //
-    // 'SKIP'
-    Discard = ZBI_TYPE_DISCARD,
-
-    /// A virtual disk image.  This is meant to be treated as if it were a
-    /// storage device.  The payload (after decompression) is the contents of
-    /// the storage device, in whatever format that might be.
-    //
-    // 'RDSK'
-    StorageRamdisk = ZBI_TYPE_STORAGE_RAMDISK,
-
-    /// The /boot filesystem in BOOTFS format, specified in
-    /// <lib/zbi-format/internal/bootfs.h>.  This represents an internal
-    /// contract between Zircon userboot (//docs/userboot.md), which handles
-    /// the contents of this filesystem, and platform tooling, which prepares
-    /// them.
-    //
-    // 'BFSB'
-    StorageBootFs = ZBI_TYPE_STORAGE_BOOTFS,
-
-    /// Storage used by the kernel (such as a compressed image containing the
-    /// actual kernel).  The meaning and format of the data is specific to the
-    /// kernel, though it always uses the standard (private) storage
-    /// compression protocol. Each particular `ZbiType::Kernel{ARCH}` item image and its
-    /// `StorageKernel` item image are intimately tied and one cannot work
-    /// without the exact correct corresponding other.
-    //
-    // 'KSTR'
-    StorageKernel = ZBI_TYPE_STORAGE_KERNEL,
-
-    /// Device-specific factory data, stored in BOOTFS format.
-    //
-    // TODO(fxbug.dev/42109921): This should not use the "STORAGE" infix.
-    //
-    // 'BFSF'
-    StorageBootFsFactory = ZBI_TYPE_STORAGE_BOOTFS_FACTORY,
-
-    /// A kernel command line fragment, a UTF-8 string that need not be
-    /// NULL-terminated.  The kernel's own option parsing accepts only printable
-    /// 'ASCI'I and treats all other characters as equivalent to whitespace. Multiple
-    /// `ZbiType::CmdLine` items can appear.  They are treated as if concatenated with
-    /// ' ' between each item, in the order they appear: first items in the bootable
-    /// ZBI containing the kernel; then items in the ZBI synthesized by the boot
-    /// loader.  The kernel interprets the [whole command line](../../../../docs/kernel_cmdline.md).
-    //
-    // 'CMDL'
-    CmdLine = ZBI_TYPE_CMDLINE,
-
-    /// The crash log from the previous boot, a UTF-8 string.
-    //
-    // 'BOOM'
-    CrashLog = ZBI_TYPE_CRASHLOG,
-
-    /// Physical memory region that will persist across warm boots. See `zbi_nvram_t`
-    /// for payload description.
-    //
-    // 'NVLL'
-    Nvram = ZBI_TYPE_NVRAM,
-
-    /// Platform ID Information.
-    //
-    // 'PLID'
-    PlatformId = ZBI_TYPE_PLATFORM_ID,
-
-    /// Board-specific information.
-    //
-    // mBSI
-    DrvBoardInfo = ZBI_TYPE_DRV_BOARD_INFO,
-
-    /// CPU configuration. See `zbi_topology_node_t` for a description of the payload.
-    CpuTopology = ZBI_TYPE_CPU_TOPOLOGY,
-
-    /// Device memory configuration. See `zbi_mem_range_t` for a description of the payload.
-    //
-    // 'MEMC'
-    MemConfig = ZBI_TYPE_MEM_CONFIG,
-
-    /// Kernel driver configuration.  The `ZbiHeader.extra` field gives a
-    /// ZBI_KERNEL_DRIVER_* type that determines the payload format.
-    /// See <lib/zbi-format/driver-config.h> for details.
-    //
-    // 'KDRV'
-    KernelDriver = ZBI_TYPE_KERNEL_DRIVER,
-
-    /// 'ACPI' Root Table Pointer, a `u64` physical address.
-    //
-    // 'RSDP'
-    AcpiRsdp = ZBI_TYPE_ACPI_RSDP,
-
-    /// 'SMBI'OS entry point, a [u64] physical address.
-    //
-    // 'SMBI'
-    Smbios = ZBI_TYPE_SMBIOS,
-
-    /// EFI system table, a [u64] physical address.
-    //
-    // 'EFIS'
-    EfiSystemTable = ZBI_TYPE_EFI_SYSTEM_TABLE,
-
-    /// EFI memory attributes table. An example of this format can be found in UEFI 2.10
-    /// section 4.6.4, but the consumer of this item is responsible for interpreting whatever
-    /// the bootloader supplies (in particular the "version" field may differ as the format
-    /// evolves).
-    //
-    // 'EMAT'
-    EfiMemoryAttributesTable = ZBI_TYPE_EFI_MEMORY_ATTRIBUTES_TABLE,
-
-    /// Framebuffer parameters, a `zbi_swfb_t` entry.
-    //
-    // 'SWFB'
-    FrameBuffer = ZBI_TYPE_FRAMEBUFFER,
-
-    /// The image arguments, data is a trivial text format of one "key=value" per line
-    /// with leading whitespace stripped and "#" comment lines and blank lines ignored.
-    /// It is processed by bootsvc and parsed args are shared to others via Arguments service.
-    /// TODO: the format can be streamlined after the /config/additional_boot_args compat support is
-    /// removed.
-    //
-    // 'IARG'
-    ImageArgs = ZBI_TYPE_IMAGE_ARGS,
-
-    /// A copy of the boot version stored within the sysconfig partition
-    //
-    // 'BVRS'
-    BootVersion = ZBI_TYPE_BOOT_VERSION,
-
-    /// MAC address for Ethernet, Wifi, Bluetooth, etc.  `ZbiHeader.extra`
-    /// is a board-specific index to specify which device the MAC address
-    /// applies to.  `ZbiHeader.length` gives the size in bytes, which
-    /// varies depending on the type of address appropriate for the device.
-    //
-    // mMAC
-    DrvMacAddress = ZBI_TYPE_DRV_MAC_ADDRESS,
-
-    /// A partition map for a storage device, a `zbi_partition_map_t` header
-    /// followed by one or more `zbi_partition_t` entries.  `ZbiHeader.extra`
-    /// is a board-specific index to specify which device this applies to.
-    //
-    // mPRT
-    DrvPartitionMap = ZBI_TYPE_DRV_PARTITION_MAP,
-
-    /// Private information for the board driver.
-    //
-    // mBOR
-    DrvBoardPrivate = ZBI_TYPE_DRV_BOARD_PRIVATE,
-
-    /// Information about reboot
-    // 'HWRB'
-    HwRebootReason = ZBI_TYPE_HW_REBOOT_REASON,
-
-    /// The serial number, an unterminated ASCII string of printable non-whitespace
-    /// characters with length `ZbiHeader.length`.
-    //
-    // 'SRLN'
-    SerialNumber = ZBI_TYPE_SERIAL_NUMBER,
-
-    /// This type specifies a binary file passed in by the bootloader.
-    /// The first byte specifies the length of the filename without a NUL terminator.
-    /// The filename starts on the second byte.
-    /// The file contents are located immediately after the filename.
-    /// ```none
-    /// Layout: | name_len |        name       |   payload
-    ///           ^(1 byte)  ^(name_len bytes)     ^(length of file)
-    /// ```
-    //
-    // 'BTFL'
-    BootloaderFile = ZBI_TYPE_BOOTLOADER_FILE,
-
-    /// The devicetree blob from the legacy boot loader, if any.  This is used only
-    /// for diagnostic and development purposes.  Zircon kernel and driver
-    /// configuration is entirely driven by specific ZBI items from the boot
-    /// loader.  The boot shims for legacy boot loaders pass the raw devicetree
-    /// along for development purposes, but extract information from it to populate
-    /// specific ZBI items such as [`ZbiType::KernelDriver`] et al.
-    DeviceTree = ZBI_TYPE_DEVICETREE,
-
-    /// An arbitrary number of random bytes attested to have high entropy.  Any
-    /// number of items of any size can be provided, but no data should be provided
-    /// that is not true entropy of cryptographic quality.  This is used to seed
-    /// secure cryptographic pseudo-random number generators.
-    //
-    // 'RAND'
-    SecureEntropy = ZBI_TYPE_SECURE_ENTROPY,
-
-    /// This provides a data dump and associated logging from a boot loader,
-    /// shim, or earlier incarnation that wants its data percolated up by the
-    /// booting Zircon kernel. See `zbi_debugdata_t` for a description of the
-    /// payload.
-    //
-    // 'DBGD'
-    DebugData = ZBI_TYPE_DEBUGDATA,
-}
-
-impl ZbiType {
-    /// Checks if [`ZbiType`] is a Kernel type. (E.g. [`ZbiType::KernelX64`])
-    /// ```
-    /// # use zbi::ZbiType;
-    /// assert!(ZbiType::KernelX64.is_kernel());
-    /// ```
-    pub fn is_kernel(&self) -> bool {
-        ((*self as u32) & ZBI_TYPE_KERNEL_MASK) == ZBI_TYPE_KERNEL_PREFIX
-    }
-
-    /// Checks if [`ZbiType`] is a Driver Metadata type. (E.g. [`ZbiType::DrvBoardInfo`])
-    /// ```
-    /// # use zbi::ZbiType;
-    /// assert!(ZbiType::DrvBoardInfo.is_driver_metadata());
-    /// ```
-    pub fn is_driver_metadata(&self) -> bool {
-        ((*self as u32) & ZBI_TYPE_DRIVER_METADATA_MASK) == ZBI_TYPE_DRIVER_METADATA_PREFIX
-    }
-}
-
-impl From<ZbiType> for u32 {
-    fn from(val: ZbiType) -> Self {
-        val as u32
-    }
-}
-
-impl TryFrom<u32> for ZbiType {
-    type Error = ZbiError;
-    fn try_from(val: u32) -> Result<Self, Self::Error> {
-        match val {
-            ZBI_TYPE_KERNEL_X64 => Ok(Self::KernelX64),
-            ZBI_TYPE_KERNEL_ARM64 => Ok(Self::KernelArm64),
-            ZBI_TYPE_KERNEL_RISCV64 => Ok(Self::KernelRiscv64),
-            ZBI_TYPE_CONTAINER => Ok(Self::Container),
-            ZBI_TYPE_DISCARD => Ok(Self::Discard),
-            ZBI_TYPE_STORAGE_RAMDISK => Ok(Self::StorageRamdisk),
-            ZBI_TYPE_STORAGE_BOOTFS => Ok(Self::StorageBootFs),
-            ZBI_TYPE_STORAGE_KERNEL => Ok(Self::StorageKernel),
-            ZBI_TYPE_STORAGE_BOOTFS_FACTORY => Ok(Self::StorageBootFsFactory),
-            ZBI_TYPE_CMDLINE => Ok(Self::CmdLine),
-            ZBI_TYPE_CRASHLOG => Ok(Self::CrashLog),
-            ZBI_TYPE_NVRAM => Ok(Self::Nvram),
-            ZBI_TYPE_PLATFORM_ID => Ok(Self::PlatformId),
-            ZBI_TYPE_DRV_BOARD_INFO => Ok(Self::DrvBoardInfo),
-            ZBI_TYPE_CPU_TOPOLOGY => Ok(Self::CpuTopology),
-            ZBI_TYPE_MEM_CONFIG => Ok(Self::MemConfig),
-            ZBI_TYPE_KERNEL_DRIVER => Ok(Self::KernelDriver),
-            ZBI_TYPE_ACPI_RSDP => Ok(Self::AcpiRsdp),
-            ZBI_TYPE_SMBIOS => Ok(Self::Smbios),
-            ZBI_TYPE_EFI_SYSTEM_TABLE => Ok(Self::EfiSystemTable),
-            ZBI_TYPE_EFI_MEMORY_ATTRIBUTES_TABLE => Ok(Self::EfiMemoryAttributesTable),
-            ZBI_TYPE_FRAMEBUFFER => Ok(Self::FrameBuffer),
-            ZBI_TYPE_IMAGE_ARGS => Ok(Self::ImageArgs),
-            ZBI_TYPE_BOOT_VERSION => Ok(Self::BootVersion),
-            ZBI_TYPE_DRV_MAC_ADDRESS => Ok(Self::DrvMacAddress),
-            ZBI_TYPE_DRV_PARTITION_MAP => Ok(Self::DrvPartitionMap),
-            ZBI_TYPE_DRV_BOARD_PRIVATE => Ok(Self::DrvBoardPrivate),
-            ZBI_TYPE_HW_REBOOT_REASON => Ok(Self::HwRebootReason),
-            ZBI_TYPE_SERIAL_NUMBER => Ok(Self::SerialNumber),
-            ZBI_TYPE_BOOTLOADER_FILE => Ok(Self::BootloaderFile),
-            ZBI_TYPE_DEVICETREE => Ok(Self::DeviceTree),
-            ZBI_TYPE_SECURE_ENTROPY => Ok(Self::SecureEntropy),
-            ZBI_TYPE_DEBUGDATA => Ok(Self::DebugData),
-            _ => Err(ZbiError::BadType),
-        }
-    }
-}
-
-bitflags! {
-    /// Flags associated with an item.
-    ///
-    /// A valid flags value must always include [`ZbiFlags::VERSION`].
-    /// Values should also contain [`ZbiFlags::CRC32`] for any item
-    /// where it's feasible to compute the [`ZbiFlags::CRC32`] at build time.
-    /// Other flags are specific to each type.
-    ///
-    /// Matches C-reference `zbi_flags_t` which is `uint32_t`.
-    pub struct ZbiFlags: u32 {
-        /// This flag is always required.
-        const VERSION = ZBI_FLAGS_VERSION;
-        /// ZBI items with the `CRC32` flag must have a valid `crc32`.
-        /// Otherwise their `crc32` field must contain `ZBI_ITEM_NO_CRC32`
-        const CRC32 = ZBI_FLAGS_CRC32;
-    }
-}
-
-/// A valid flags must always include [`ZbiFlags::VERSION`].
-impl Default for ZbiFlags {
-    fn default() -> ZbiFlags {
-        ZbiFlags::VERSION
-    }
-}
-
-/// Rust type generated from C-reference structure `zbi_header_t`.
-///
-/// It must correspond to following definition:
-/// ```c++
-/// typedef struct {
-///   // ZBI_TYPE_* constant.
-///   zbi_type_t type;
-///
-///   // Size of the payload immediately following this header.  This
-///   // does not include the header itself nor any alignment padding
-///   // after the payload.
-///   uint32_t length;
-///
-///   // Type-specific extra data.  Each type specifies the use of this
-///   // field.  When not explicitly specified, it should be zero.
-///   uint32_t extra;
-///
-///   // Flags for this item.
-///   zbi_flags_t flags;
-///
-///   // For future expansion.  Set to 0.
-///   uint32_t reserved0;
-///   uint32_t reserved1;
-///
-///   // Must be ZBI_ITEM_MAGIC.
-///   uint32_t magic;
-///
-///   // Must be the CRC32 of payload if ZBI_FLAGS_CRC32 is set,
-///   // otherwise must be ZBI_ITEM_NO_CRC32.
-///   uint32_t crc32;
-/// } zbi_header_t;
-/// ```
-pub type ZbiHeader = zbi_header_t;
-
-impl ZbiHeader {
-    /// Helper function to get `ZbiHeader.flags: u32` as `ZbiFlags`.
-    pub fn get_flags(&self) -> ZbiFlags {
-        ZbiFlags::from_bits_truncate(self.flags)
-    }
-    /// Helper function to set `ZbiHeader.flags: u32` from `ZbiFlags`.
-    pub fn set_flags(&mut self, flags: &ZbiFlags) {
-        self.flags = flags.bits();
-    }
-}
-
-/// The kernel image.
-///
-/// In a bootable ZBI this item must always be first,
-/// immediately after the [`ZbiType::Container`] header.  The contiguous memory
-/// image of the kernel is formed from the [`ZbiType::Container`] header, the
-/// `ZbiType::Kernel{ARCH}` header, and the payload.
-///
-/// The boot loader loads the whole image starting with the container header
-/// through to the end of the kernel item's payload into contiguous physical
-/// memory.  It then constructs a partial ZBI elsewhere in memory, which has
-/// a [`ZbiType::Container`] header of its own followed by all the other items
-/// that were in the booted ZBI plus other items synthesized by the boot
-/// loader to describe the machine.  This partial ZBI must be placed at an
-/// address (where the container header is found) that is aligned to the
-/// machine's page size.  The precise protocol for transferring control to
-/// the kernel's entry point varies by machine.
-///
-/// On all machines, the kernel requires some amount of scratch memory to be
-/// available immediately after the kernel image at boot.  It needs this
-/// space for early setup work before it has a chance to read any memory-map
-/// information from the boot loader.  The `reserve_memory_size` field tells
-/// the boot loader how much space after the kernel's load image it must
-/// leave available for the kernel's use.  The boot loader must place its
-/// constructed ZBI or other reserved areas at least this many bytes after
-/// the kernel image.
-///
-/// # x86-64
-///
-/// The kernel assumes it was loaded at a fixed physical address of
-/// 0x100000 (1MB).  `ZbiKernel.entry` is the absolute physical address
-/// of the PC location where the kernel will start.
-/// TODO(https://fxbug.dev/42098994): Perhaps this will change??
-/// The processor is in 64-bit mode with direct virtual to physical
-/// mapping covering the physical memory where the kernel and
-/// bootloader-constructed ZBI were loaded.
-/// The %rsi register holds the physical address of the
-/// bootloader-constructed ZBI.
-/// All other registers are unspecified.
-///
-/// # ARM64
-///
-/// `ZbiKernel.entry` is an offset from the beginning of the image
-/// (i.e., the [`ZbiType::Container`] header before the [`ZbiType::KernelArm64`]
-/// header) to the PC location in the image where the kernel will
-/// start.  The processor is in physical address mode at EL1 or
-/// above.  The kernel image and the bootloader-constructed ZBI each
-/// can be loaded anywhere in physical memory.  The x0 register
-/// holds the physical address of the bootloader-constructed ZBI.
-/// All other registers are unspecified.
-///
-/// # RISCV64
-///
-/// `ZbiKernel.entry` is an offset from the beginning of the image (i.e.,
-/// the [`ZbiType::Container`] header before the [`ZbiType::KernelRiscv64`] header)
-/// to the PC location in the image where the kernel will start.  The
-/// processor is in S mode, satp is zero, sstatus.SIE is zero.  The kernel
-/// image and the bootloader-constructed ZBI each can be loaded anywhere in
-/// physical memory, aligned to 4KiB.  The a0 register holds the HART ID,
-/// and the a1 register holds the 4KiB-aligned physical address of the
-/// bootloader-constructed ZBI.  All other registers are unspecified.
-///
-/// # C-reference type
-/// ```c
-/// typedef struct {
-///   // Entry-point address.  The interpretation of this differs by machine.
-///   uint64_t entry;
-///
-///   // Minimum amount (in bytes) of scratch memory that the kernel requires
-///   // immediately after its load image.
-///   uint64_t reserve_memory_size;
-/// } zbi_kernel_t;
-/// ```
-pub type ZbiKernel = zbi_kernel_t;
-
-#[derive(Debug, PartialEq, Eq)]
-/// Error values that can be returned by function in this library
-pub enum ZbiError {
-    /// Generic error
-    Error,
-    /// Bad type
-    BadType,
-    /// Bad magic
-    BadMagic,
-    /// Bad version
-    BadVersion,
-    /// Bad CRC
-    BadCrc,
-    /// Bad Alignment
-    BadAlignment,
-    /// Truncaded error
-    Truncated,
-    /// Too big
-    TooBig,
-    /// Incomplete Kernel
-    IncompleteKernel,
-    /// Bad ZBI length for this platform
-    PlatformBadLength,
-    /// CRC32 is not supported yet
-    Crc32NotSupported,
-    /// Length type overflow
-    LengthOverflow,
-}
-
-// Unfortunately thiserror is not available in `no_std` world.
-// Thus `Display` implementation is required.
-impl Display for ZbiError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
-        let str = match self {
-            ZbiError::Error => "Generic error",
-            ZbiError::BadType => "Bad type",
-            ZbiError::BadMagic => "Bad magic",
-            ZbiError::BadVersion => "Bad version",
-            ZbiError::BadCrc => "Bad CRC",
-            ZbiError::BadAlignment => "Bad Alignment",
-            ZbiError::Truncated => "Truncaded error",
-            ZbiError::TooBig => "Too big",
-            ZbiError::IncompleteKernel => "Incomplete Kernel",
-            ZbiError::PlatformBadLength => "Bad ZBI length for this platform",
-            ZbiError::Crc32NotSupported => "CRC32 is not supported yet",
-            ZbiError::LengthOverflow => "Length type overflow",
-        };
-        write!(f, "{str}")
-    }
-}
-
-// Returns offset/idx of the first buffer element that will be aligned to `ZBI_ALIGNMENT`
-fn get_align_buffer_offset(buffer: impl ByteSlice) -> ZbiResult<usize> {
-    let addr = buffer.as_ptr() as usize;
-    match addr % ZBI_ALIGNMENT_USIZE {
-        0 => Ok(0),
-        rem => {
-            let tail_offset = ZBI_ALIGNMENT_USIZE - rem;
-            if tail_offset > buffer.len() {
-                return Err(ZbiError::TooBig);
-            }
-            Ok(tail_offset)
-        }
-    }
-}
-
-// Check if buffer is ZbiAligned
-fn is_zbi_aligned(buffer: &impl ByteSlice) -> ZbiResult<()> {
-    match (buffer.as_ptr() as usize) % ZBI_ALIGNMENT_USIZE {
-        0 => Ok(()),
-        _ => Err(ZbiError::BadAlignment),
-    }
-}
-
-/// Merges two ZBI containers stored on the same buffer.
-///
-/// A typical use scenario is when the caller wants to append ZBI items that need to borrow the
-/// existing container in order to be created, but wants to resuse the unused buffer for memory
-/// optimization. The caller can split out the unused buffer, borrow the existing container,
-/// creates a new container in the unused buffer, and then use this API to merge them together.
-///
-/// # Args:
-///
-/// * `buffer`: The buffer that contains the two ZBI containers. The first container must start
-///   from the beginning.
-/// * `second_start`: The offset to the second container in the buffer. The offset must be aligned
-///   to `ZBI_ALIGNMENT_USIZE`.
-///
-/// # Returns
-///
-/// * On success returns an instance of `ZbiContainer` representing the merged container.
-pub fn merge_within(buffer: &mut [u8], second_start: usize) -> ZbiResult<ZbiContainer<&mut [u8]>> {
-    let first_container_size = ZbiContainer::parse(&mut buffer[..])?.container_size();
-    if first_container_size > second_start {
-        return Err(ZbiError::Error);
-    }
-    let second_payload_len =
-        ZbiContainer::parse(&mut buffer[second_start..])?.get_payload_length_usize();
-    // Copies the payload part directly to the end of the first container.
-    let second_payload_start = second_start + size_of::<ZbiHeader>();
-    let second_payload_end = second_payload_start + second_payload_len;
-    buffer.copy_within(second_payload_start..second_payload_end, first_container_size);
-    // Updates first ZBI header length
-    let hdr = Ref::<_, ZbiHeader>::new_from_prefix(&mut buffer[..]).unwrap().0.into_mut();
-    hdr.length = hdr
-        .length
-        .checked_add(u32::try_from(second_payload_len).unwrap())
-        .ok_or(ZbiError::LengthOverflow)?;
-    ZbiContainer::parse(buffer)
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[derive(Debug, PartialEq, Default)]
-    struct TestZbiBuilder<'a> {
-        buffer: &'a mut [u8],
-        tail_offset: usize,
-    }
-    impl<'a> TestZbiBuilder<'a> {
-        pub fn new(buffer: &'a mut [u8]) -> TestZbiBuilder<'a> {
-            TestZbiBuilder { buffer, tail_offset: 0 }
-        }
-        pub fn add<T: AsBytes>(mut self, t: T) -> Self {
-            t.write_to_prefix(&mut self.buffer[self.tail_offset..]).unwrap();
-            self.tail_offset += size_of::<T>();
-            self
-        }
-        pub fn add_slice(mut self, buf: &'a [u8]) -> Self {
-            self.buffer[self.tail_offset..self.tail_offset + buf.len()].copy_from_slice(buf);
-            self.tail_offset += buf.len();
-            self
-        }
-        pub fn get_header_default() -> ZbiHeader {
-            ZbiHeader {
-                type_: ZbiType::KernelX64 as u32,
-                length: 0,
-                extra: ZBI_ITEM_MAGIC,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            }
-        }
-        pub fn item_default(self, payload: &'a [u8]) -> Self {
-            self.item(
-                ZbiHeader {
-                    length: payload.len().try_into().unwrap(),
-                    ..Self::get_header_default()
-                },
-                payload,
-            )
-        }
-        pub fn item(self, header: ZbiHeader, payload: &'a [u8]) -> Self {
-            self.add(header).add_slice(&payload[..payload.len()])
-        }
-        pub fn container_hdr(self, payload_len: usize) -> Self {
-            self.item(
-                ZbiHeader {
-                    type_: ZBI_TYPE_CONTAINER,
-                    length: payload_len.try_into().unwrap(),
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: ZbiFlags::default().bits(),
-                    magic: ZBI_ITEM_MAGIC,
-                    crc32: ZBI_ITEM_NO_CRC32,
-                    ..Default::default()
-                },
-                &[],
-            )
-        }
-        pub fn padding(mut self, val: u8, bytes: usize) -> Self {
-            self.buffer[self.tail_offset..self.tail_offset + bytes].fill(val);
-            self.tail_offset += bytes;
-            self
-        }
-        pub fn align(mut self) -> Self {
-            let rem = self.tail_offset % ZBI_ALIGNMENT_USIZE;
-            if rem != 0 {
-                self.tail_offset += ZBI_ALIGNMENT_USIZE - rem;
-            }
-            self
-        }
-        // Assumption is that first item in buffer is container header/item
-        pub fn update_container_length(self) -> Self {
-            let payload_length = self.tail_offset - size_of::<ZbiHeader>();
-            let item = ZbiHeader {
-                type_: ZBI_TYPE_CONTAINER,
-                length: payload_length.try_into().unwrap(),
-                extra: ZBI_CONTAINER_MAGIC,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            };
-            item.write_to_prefix(&mut self.buffer[..]).unwrap();
-            self
-        }
-        pub fn build(self) -> &'a mut [u8] {
-            &mut self.buffer[..self.tail_offset]
-        }
-    }
-
-    const ZBI_HEADER_SIZE: usize = core::mem::size_of::<ZbiHeader>();
-    const ALIGNED_8_SIZE: usize = ZBI_HEADER_SIZE * 20;
-    #[repr(align(8))]
-    struct ZbiAligned([u8; ALIGNED_8_SIZE]);
-    impl Default for ZbiAligned {
-        fn default() -> Self {
-            ZbiAligned(core::array::from_fn::<_, ALIGNED_8_SIZE, _>(|_| 0u8))
-        }
-    }
-
-    #[test]
-    fn test_zbi_align_overflow() {
-        assert!(usize::MAX > ZBI_ALIGNMENT.try_into().unwrap());
-        assert_eq!(u32::try_from(ZBI_ALIGNMENT_USIZE).unwrap(), ZBI_ALIGNMENT);
-    }
-
-    #[test]
-    fn test_zbi_item_new() {
-        let mut buffer = ZbiAligned::default();
-        let expect = get_test_zbi_headers(1)[0];
-
-        let (item, _) = ZbiItem::new(
-            &mut buffer.0[..],
-            expect.type_.try_into().unwrap(),
-            expect.extra,
-            expect.get_flags(),
-            expect.length.try_into().unwrap(),
-        )
-        .unwrap();
-
-        assert_eq!(*item.header, expect);
-        assert_eq!(item.payload.len(), expect.length.try_into().unwrap());
-
-        let u32_array =
-            Ref::<&[u8], [u32]>::new_slice_from_prefix(&buffer.0[..ZBI_HEADER_SIZE], 8).unwrap().0;
-        assert_eq!(u32_array[0], expect.type_);
-        assert_eq!(u32_array[1], expect.length);
-        assert_eq!(u32_array[2], expect.extra);
-        assert_eq!(u32_array[3], expect.flags);
-        // u32_array[4..5] - reserved
-        assert_eq!(u32_array[6], expect.magic);
-        assert_eq!(u32_array[7], expect.crc32);
-    }
-
-    #[test]
-    fn test_zbi_item_new_too_small() {
-        let mut buffer = ZbiAligned::default();
-
-        assert_eq!(
-            ZbiItem::new(
-                &mut buffer.0[..ZBI_HEADER_SIZE - 1],
-                ZbiType::Container,
-                0,
-                ZbiFlags::default(),
-                0
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_item_new_not_aligned() {
-        let mut buffer = ZbiAligned::default();
-        for offset in [1, 2, 4] {
-            assert_eq!(
-                ZbiItem::new(
-                    &mut buffer.0[offset..ZBI_HEADER_SIZE + offset],
-                    ZbiType::Container,
-                    0,
-                    ZbiFlags::default(),
-                    0
-                ),
-                Err(ZbiError::BadAlignment)
-            );
-        }
-    }
-
-    #[test]
-    fn test_zbi_item_parse() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
-        let buffer_hdr_extra_expected =
-            Ref::<&[u8], [u32]>::new_slice_from_prefix(&buffer[8..12], 1).unwrap().0[0];
-
-        let (zbi_item, _tail) = ZbiItem::parse(buffer).unwrap();
-
-        assert_eq!(zbi_item.header.extra, buffer_hdr_extra_expected);
-    }
-
-    #[test]
-    fn test_zbi_item_edit() {
-        let mut buffer = ZbiAligned::default();
-        let buffer_build = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
-        let buffer_hdr_type =
-            Ref::<&[u8], [u32]>::new_slice_from_prefix(&buffer_build[0..4], 1).unwrap().0[0];
-        assert_eq!(buffer_hdr_type, ZBI_TYPE_CONTAINER);
-
-        let (mut zbi_item, _tail) = ZbiItem::parse(&mut buffer_build[..]).unwrap();
-        zbi_item.header.type_ = ZBI_TYPE_KERNEL_X64;
-        let buffer_hdr_type =
-            Ref::<&[u8], [u32]>::new_slice_from_prefix(&buffer_build[0..4], 1).unwrap().0[0];
-        assert_eq!(buffer_hdr_type, ZBI_TYPE_KERNEL_X64);
-    }
-
-    #[test]
-    fn test_zbi_container_new() {
-        let mut buffer = ZbiAligned::default();
-        let _container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let expect_hdr = ZbiHeader {
-            type_: ZBI_TYPE_CONTAINER,
-            length: 0,
-            extra: ZBI_CONTAINER_MAGIC,
-            flags: ZbiFlags::default().bits(),
-            magic: ZBI_ITEM_MAGIC,
-            crc32: ZBI_ITEM_NO_CRC32,
-            ..Default::default()
-        };
-
-        let (item, _) = ZbiItem::parse(&buffer.0[..]).unwrap();
-        assert_eq!(*item.header, expect_hdr);
-        assert_eq!(item.payload.len(), 0);
-    }
-
-    #[test]
-    fn test_zbi_container_new_too_small() {
-        let mut buffer = ZbiAligned::default();
-        assert_eq!(ZbiContainer::new(&mut buffer.0[..ZBI_HEADER_SIZE - 1]), Err(ZbiError::TooBig));
-    }
-
-    #[test]
-    fn test_zbi_container_new_unaligned() {
-        let mut buffer = ZbiAligned::default();
-        for offset in [1, 2, 3, 4, 5, 6, 7] {
-            assert_eq!(
-                ZbiContainer::new(&mut buffer.0[offset..ZBI_HEADER_SIZE + offset]),
-                Err(ZbiError::BadAlignment)
-            );
-        }
-    }
-
-    #[test]
-    fn test_zbi_container_parse_empty() {
-        let mut buffer = ZbiAligned::default();
-        let _container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let expect_hdr = ZbiHeader {
-            type_: ZBI_TYPE_CONTAINER,
-            length: 0,
-            extra: ZBI_CONTAINER_MAGIC,
-            flags: ZbiFlags::default().bits(),
-            magic: ZBI_ITEM_MAGIC,
-            crc32: ZBI_ITEM_NO_CRC32,
-            ..Default::default()
-        };
-
-        let ZbiContainer { header, buffer: _, payload_length } =
-            ZbiContainer::parse(&buffer.0[..]).unwrap();
-        assert_eq!(*header, expect_hdr);
-        assert_eq!(payload_length, 0);
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_type() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .item(
-                ZbiHeader {
-                    type_: 0,
-                    length: 0,
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: ZbiFlags::default().bits(),
-                    magic: ZBI_ITEM_MAGIC,
-                    crc32: ZBI_ITEM_NO_CRC32,
-                    ..Default::default()
-                },
-                &[],
-            )
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadType))
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_magic() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .item(
-                ZbiHeader {
-                    type_: ZBI_TYPE_CONTAINER,
-                    length: 0,
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: ZbiFlags::default().bits(),
-                    magic: 0,
-                    crc32: ZBI_ITEM_NO_CRC32,
-                    ..Default::default()
-                },
-                &[],
-            )
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadMagic))
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_version() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .item(
-                ZbiHeader {
-                    type_: ZBI_TYPE_CONTAINER,
-                    length: 0,
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: (ZbiFlags::default() & !ZbiFlags::VERSION).bits(),
-                    magic: ZBI_ITEM_MAGIC,
-                    crc32: ZBI_ITEM_NO_CRC32,
-                    ..Default::default()
-                },
-                &[],
-            )
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadVersion))
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_crc32() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .item(
-                ZbiHeader {
-                    type_: ZBI_TYPE_CONTAINER,
-                    length: 0,
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: (ZbiFlags::default() & !ZbiFlags::CRC32).bits(),
-                    magic: ZBI_ITEM_MAGIC,
-                    crc32: 0,
-                    ..Default::default()
-                },
-                &[],
-            )
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadCrc))
-    }
-
-    #[test]
-    fn test_zbi_container_parse_entries_bad_magic() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .item(
-                ZbiHeader {
-                    type_: ZBI_TYPE_CONTAINER,
-                    length: 0,
-                    extra: ZBI_CONTAINER_MAGIC,
-                    flags: (ZbiFlags::default() & !ZbiFlags::CRC32).bits(),
-                    magic: ZBI_ITEM_MAGIC,
-                    crc32: 0,
-                    ..Default::default()
-                },
-                &[],
-            )
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadCrc))
-    }
-
-    #[test]
-    fn test_zbi_container_parse() {
-        let expected_payloads: [&[u8]; 9] = [
-            &[1],
-            &[1, 2],
-            &[1, 2, 3],
-            &[1, 2, 3, 4],
-            &[1, 2, 3, 4, 5],
-            &[1, 2, 3, 4, 5, 6],
-            &[1, 2, 3, 4, 5, 6, 7],
-            &[1, 2, 3, 4, 5, 6, 7, 8],
-            &[1, 2, 3, 4, 5, 6, 7, 8, 9],
-        ];
-        let expected_items = expected_payloads.map(|x| {
-            (
-                ZbiHeader {
-                    length: x.len().try_into().unwrap(),
-                    ..TestZbiBuilder::get_header_default()
-                },
-                x,
-            )
-        });
-        let mut buffer = ZbiAligned::default();
-        let mut builder = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0);
-        for payloads in expected_payloads {
-            builder = builder.align().item_default(payloads).align()
-        }
-        let buffer = builder.update_container_length().build();
-
-        let zbi_container = ZbiContainer::parse(&*buffer).unwrap();
-
-        let mut it = zbi_container.iter();
-        for (expected_hdr, expected_payload) in expected_items.iter() {
-            let Some(item) = it.next() else { panic!("expecting iterator with value") };
-            assert_eq!(item.header.into_ref(), expected_hdr);
-            assert_eq!(&item.payload[..], *expected_payload);
-        }
-        assert!(it.next().is_none());
-    }
-
-    #[test]
-    fn test_zbi_container_parse_unaligned() {
-        let buffer = ZbiAligned::default();
-        for offset in [1, 2, 3, 4, 5, 6, 7] {
-            assert_eq!(ZbiContainer::parse(&buffer.0[offset..]), Err(ZbiError::BadAlignment));
-        }
-    }
-
-    #[test]
-    fn test_zbi_container_parse_without_last_padding_fail_truncated() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1])
-            .align()
-            .item_default(&[1, 2])
-            .update_container_length()
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&*buffer), Err(ZbiError::Truncated));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_error_payload_truncated() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .add_slice(&[1])
-            .update_container_length()
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer[..buffer.len() - 1]), Err(ZbiError::Truncated));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_error_truncated() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .padding(0, 1)
-            .update_container_length()
-            .build();
-
-        assert_eq!(ZbiContainer::parse(&buffer[..buffer.len() - 1]), Err(ZbiError::Truncated));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_first_entry_marked() {
-        let mut buffer = get_test_creference_buffer();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        container
-            .iter_mut()
-            .filter(|e| {
-                [ZbiType::CmdLine as u32, ZbiType::StorageRamdisk as u32].contains(&e.header.type_)
-            })
-            .for_each(|mut e| e.header.magic = 0);
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadMagic));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_entry_magic() {
-        let mut buffer = get_test_creference_buffer();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        container
-            .iter_mut()
-            .filter(|e| ZbiType::CmdLine as u32 == e.header.type_)
-            .for_each(|mut e| e.header.magic = 0);
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadMagic));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_entry_version() {
-        let mut buffer = get_test_creference_buffer();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        container
-            .iter_mut()
-            .filter(|e| ZbiType::CmdLine as u32 == e.header.type_)
-            .for_each(|mut e| e.header.flags &= (!ZbiFlags::VERSION).bits());
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadVersion));
-    }
-
-    #[test]
-    fn test_zbi_container_parse_bad_entry_crc() {
-        let mut buffer = get_test_creference_buffer();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        container.iter_mut().filter(|e| ZbiType::CmdLine as u32 == e.header.type_).for_each(
-            |mut e| {
-                e.header.flags &= (!ZbiFlags::CRC32).bits();
-                e.header.crc32 = 0;
-            },
-        );
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]), Err(ZbiError::BadCrc));
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry() {
-        let mut buffer = ZbiAligned::default();
-        let new_entries = get_test_entries_all();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        for (e, payload) in &new_entries {
-            container.get_next_payload().unwrap()[..payload.len()].copy_from_slice(payload);
-            container
-                .create_entry(e.type_.try_into().unwrap(), e.extra, e.get_flags(), payload.len())
-                .unwrap();
-        }
-
-        let container = ZbiContainer::parse(&buffer.0[..]).unwrap();
-        check_container_made_of(&container, &new_entries);
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_crc32_not_supported() {
-        let mut buffer = ZbiAligned::default();
-        let (new_entry, payload) = get_test_entry_nonempty_payload();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        assert_eq!(
-            container.create_entry_with_payload(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                ZbiFlags::default() | ZbiFlags::CRC32,
-                payload,
-            ),
-            Err(ZbiError::Crc32NotSupported)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_no_space_left() {
-        let mut buffer = ZbiAligned::default();
-        let new_entry = get_test_entry_empty_payload().0;
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-
-        for _ in 1..(ALIGNED_8_SIZE / ZBI_HEADER_SIZE) {
-            container
-                .create_entry(
-                    new_entry.type_.try_into().unwrap(),
-                    new_entry.extra,
-                    new_entry.get_flags(),
-                    new_entry.length.try_into().unwrap(),
-                )
-                .unwrap();
-        }
-
-        // Now there is not enough space and it should fail
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                new_entry.length.try_into().unwrap(),
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_no_space_for_header() {
-        let mut buffer = ZbiAligned::default();
-        let new_entry = get_test_entry_empty_payload().0;
-
-        let buf_len = 2 * core::mem::size_of::<ZbiHeader>() - 1;
-        let mut container = ZbiContainer::new(&mut buffer.0[..buf_len]).unwrap();
-
-        // Now there is not enough space for header and it should fail
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                0,
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_no_space_for_payload() {
-        let mut buffer = ZbiAligned::default();
-        let (new_entry, payload) = get_test_entry_nonempty_payload();
-
-        let buf_len = 2 * core::mem::size_of::<ZbiHeader>() + payload.len() - 1;
-        let mut container = ZbiContainer::new(&mut buffer.0[..buf_len]).unwrap();
-
-        // Now there is not enough space for header and it should fail
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                new_entry.length.try_into().unwrap(),
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_with_payload_just_enough_to_fit_no_align() {
-        let mut buffer = ZbiAligned::default();
-        let (new_entry, _payload) = get_test_entry_empty_payload();
-        let payload = [0; ZBI_ALIGNMENT_USIZE];
-        let buf_len = 2 * core::mem::size_of::<ZbiHeader>()
-            + payload.len()
-            + (/*alignment*/ZBI_ALIGNMENT_USIZE - payload.len());
-        let mut container = ZbiContainer::new(&mut buffer.0[..buf_len]).unwrap();
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                payload.len(),
-            ),
-            Ok(())
-        );
-    }
-    #[test]
-    fn test_zbi_container_new_entry_with_payload_just_enough_to_fit_with_alignment() {
-        let mut buffer = ZbiAligned::default();
-        let (new_entry, payload) = get_test_entry_nonempty_payload();
-        let buf_len = 2 * core::mem::size_of::<ZbiHeader>()
-            + payload.len()
-            + (ZBI_ALIGNMENT_USIZE - payload.len()/*alignment*/);
-        let mut container = ZbiContainer::new(&mut buffer.0[..buf_len]).unwrap();
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                new_entry.length.try_into().unwrap(),
-            ),
-            Ok(())
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_payload_too_big() {
-        let mut buffer = ZbiAligned::default();
-        let (new_entry, _payload) = get_test_entry_nonempty_payload();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                usize::MAX,
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_no_space_left_unaligned() {
-        let mut buffer = ZbiAligned::default();
-        let new_entry = get_test_entry_empty_payload().0;
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-
-        for _ in 1..(ALIGNED_8_SIZE / ZBI_HEADER_SIZE) {
-            container
-                .create_entry(
-                    new_entry.type_.try_into().unwrap(),
-                    new_entry.extra,
-                    new_entry.get_flags(),
-                    new_entry.length.try_into().unwrap(),
-                )
-                .unwrap();
-        }
-
-        // Now there is not enough space and it should fail
-        assert_eq!(
-            container.create_entry(
-                new_entry.type_.try_into().unwrap(),
-                new_entry.extra,
-                new_entry.get_flags(),
-                new_entry.length.try_into().unwrap(),
-            ),
-            Err(ZbiError::TooBig)
-        );
-    }
-
-    #[test]
-    fn test_zbi_container_extend_new() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1])
-            .align()
-            .update_container_length()
-            .build();
-        let container_0 = ZbiContainer::parse(buffer).unwrap();
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1, 2])
-            .align()
-            .update_container_length()
-            .build();
-        let container_1 = ZbiContainer::parse(buffer).unwrap();
-
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        container.extend(&container_0).unwrap();
-        container.extend(&container_1).unwrap();
-
-        let container_check = ZbiContainer::parse(&buffer.0[..]).unwrap();
-        assert_eq!(container_check.iter().count(), 2);
-        assert_eq!(container_0.iter().count(), 1);
-        assert_eq!(container_1.iter().count(), 1);
-        let mut it = container_check.iter();
-        assert_eq!(it.next().unwrap(), container_0.iter().next().unwrap());
-        assert_eq!(it.next().unwrap(), container_1.iter().next().unwrap());
-        assert!(it.next().is_none());
-    }
-
-    #[test]
-    fn test_zbi_container_extend_unaligned() {
-        let mut buffer_0 = ZbiAligned::default();
-        let mut container_0 = ZbiContainer::new(&mut buffer_0.0[..]).unwrap();
-        container_0
-            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"0")
-            .unwrap();
-        let container_size_0 = container_0.container_size();
-        // Copies to unaligned address.
-        let mut unaligned_0 = ZbiAligned::default();
-        let unaligned_0 = &mut unaligned_0.0[1..][..container_size_0];
-        unaligned_0.clone_from_slice(&buffer_0.0[..unaligned_0.len()]);
-
-        let mut buffer_1 = ZbiAligned::default();
-        let mut container_1 = ZbiContainer::new(&mut buffer_1.0[..]).unwrap();
-        container_1
-            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"1")
-            .unwrap();
-        let container_size_1 = container_1.container_size();
-        // Copies to unaligned address.
-        let mut unaligned_1 = ZbiAligned::default();
-        let unaligned_1 = &mut unaligned_1.0[1..][..container_size_1];
-        unaligned_1.clone_from_slice(&buffer_1.0[..unaligned_1.len()]);
-
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let container_0 = ZbiContainer::parse(&mut buffer_0.0[..]).unwrap();
-        let container_1 = ZbiContainer::parse(&mut buffer_1.0[..]).unwrap();
-        container.extend_unaligned(unaligned_0).unwrap();
-        container.extend_unaligned(unaligned_1).unwrap();
-        let mut it = container.iter();
-        assert_eq!(it.next().unwrap(), container_0.iter().next().unwrap());
-        assert_eq!(it.next().unwrap(), container_1.iter().next().unwrap());
-        assert!(it.next().is_none());
-    }
-
-    #[test]
-    fn test_zbi_container_extend_unaligned_too_big() {
-        let mut buffer = ZbiAligned::default();
-        let buffer_len = buffer.0.len();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let remains = buffer_len - container.container_size();
-        let mut extend = ZbiAligned::default();
-        ZbiContainer::new(&mut extend.0[..]).unwrap();
-        container.extend_unaligned(&extend.0[..remains]).unwrap();
-        // Should fail since there is not enough space to copy the incoming buffer first, despite
-        // that the container to extend has zero payload.
-        assert!(container.extend_unaligned(&extend.0[..remains + 1]).is_err());
-    }
-
-    #[test]
-    fn test_zbi_container_extend_unaligned_invalid_container() {
-        let mut buffer = ZbiAligned::default();
-        let buffer_len = buffer.0.len();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let remains = buffer_len - container.container_size();
-        assert!(container.extend_unaligned(&vec![0u8; remains][..]).is_err());
-    }
-
-    #[test]
-    fn test_zbi_container_extend_with_empty() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1])
-            .align()
-            .update_container_length()
-            .build();
-        let mut container_0 = ZbiContainer::parse(&mut buffer[..]).unwrap();
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
-        let container_1 = ZbiContainer::parse(&mut buffer[..]).unwrap();
-
-        assert_eq!(container_0.iter().count(), 1);
-        container_0.extend(&container_1).unwrap();
-        assert_eq!(container_0.iter().count(), 1);
-    }
-
-    #[test]
-    fn test_zbi_container_extend_full() {
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .update_container_length()
-            .build();
-        let mut container_full = ZbiContainer::parse(&mut buffer[..]).unwrap();
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1, 2])
-            .align()
-            .update_container_length()
-            .build();
-        let container = ZbiContainer::parse(buffer).unwrap();
-
-        assert_eq!(container_full.extend(&container), Err(ZbiError::TooBig));
-    }
-
-    #[test]
-    fn test_zbi_container_extend_1_byte_short() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .update_container_length()
-            .build();
-        let mut container_small =
-            ZbiContainer::parse(&mut buffer.0[..ZBI_HEADER_SIZE * 2 + ZBI_ALIGNMENT_USIZE - 1])
-                .unwrap();
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1, 2])
-            .align()
-            .update_container_length()
-            .build();
-        let container = ZbiContainer::parse(buffer).unwrap();
-
-        assert_eq!(container_small.extend(&container), Err(ZbiError::TooBig));
-    }
-
-    #[test]
-    fn test_zbi_container_extend_use_all_buffer() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .update_container_length()
-            .build();
-        let mut container_full = ZbiContainer::parse(
-            &mut buffer.0[..ZBI_HEADER_SIZE + ZBI_HEADER_SIZE + ZBI_ALIGNMENT_USIZE],
-        )
-        .unwrap();
-        let mut buffer = ZbiAligned::default();
-        let buffer = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1, 2])
-            .align()
-            .update_container_length()
-            .build();
-        let container = ZbiContainer::parse(buffer).unwrap();
-
-        assert!(container_full.extend(&container).is_ok());
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_with_payload() {
-        let mut buffer = ZbiAligned::default();
-        let new_entries = get_test_entries_all();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        for (e, payload) in &new_entries {
-            container
-                .create_entry_with_payload(
-                    e.type_.try_into().unwrap(),
-                    e.extra,
-                    e.get_flags(),
-                    payload,
-                )
-                .unwrap();
-        }
-
-        let container = ZbiContainer::parse(&buffer.0[..]).unwrap();
-        check_container_made_of(&container, &new_entries);
-    }
-
-    fn check_container_made_of<B: ByteSlice + PartialEq>(
-        container: &ZbiContainer<B>,
-        expected_items: &[(ZbiHeader, &[u8])],
-    ) {
-        // Check container header length
-        assert_eq!(
-            container.get_payload_length_usize(),
-            expected_items.len() * ZBI_HEADER_SIZE // add header len
-                + expected_items // add payloads
-                    .iter()
-                    .map(|(_, payload)| -> usize {
-                        payload.len() +
-                        match payload.len() % ZBI_ALIGNMENT_USIZE{
-                            0 => 0,
-                            rem => ZBI_ALIGNMENT_USIZE- rem,
-                        }
-                    })
-                    .sum::<usize>()
-        );
-        assert_eq!(
-            container.container_size(),
-            container.get_payload_length_usize() + size_of::<ZbiHeader>()
-        );
-
-        // Check if container elements match provided items
-        let mut it = expected_items.iter();
-        for b in container.iter() {
-            let (header, payload) = it.next().unwrap();
-            assert_eq!(*b.header, *header);
-            assert_eq!(b.payload.len(), payload.len());
-            assert!(b.payload.iter().zip(payload.iter()).all(|(a, b)| a == b))
-        }
-    }
-
-    #[test]
-    fn test_zbi_container_get_next_paylad() {
-        let mut buffer = ZbiAligned::default();
-        let new_entries = get_test_entries_all();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-
-        for (e, payload) in &new_entries {
-            let next_payload: &mut [u8] = container.get_next_payload().unwrap();
-            next_payload[..payload.len()].copy_from_slice(payload);
-            container
-                .create_entry(e.type_.try_into().unwrap(), e.extra, e.get_flags(), payload.len())
-                .unwrap();
-        }
-
-        let container = ZbiContainer::parse(&buffer.0[..]).unwrap();
-        check_container_made_of(&container, &new_entries);
-    }
-
-    #[test]
-    fn test_zbi_container_get_next_paylad_length() {
-        let mut buffer = ZbiAligned::default();
-        // Expected payload length is same as buffer - container header - item header
-        let expected_payload_len = buffer.0.len() - 2 * core::mem::size_of::<ZbiHeader>();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let next_payload: &mut [u8] = container.get_next_payload().unwrap();
-
-        assert_eq!(next_payload.len(), expected_payload_len);
-    }
-
-    #[test]
-    fn test_zbi_container_get_next_paylad_only_header_can_fit() {
-        let mut buffer = ZbiAligned::default();
-        // Buffer length that only fits container and item header.
-        let len = 2 * core::mem::size_of::<ZbiHeader>();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..len]).unwrap();
-        let next_payload: &mut [u8] = container.get_next_payload().unwrap();
-
-        assert_eq!(next_payload.len(), 0);
-    }
-
-    #[test]
-    fn test_zbi_container_get_next_paylad_header_cant_fit() {
-        let mut buffer = ZbiAligned::default();
-        // Buffer length that only fits container but not item header.
-        let len = 2 * core::mem::size_of::<ZbiHeader>() - 1;
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..len]).unwrap();
-        assert_eq!(container.get_next_payload(), Err(ZbiError::TooBig));
-    }
-
-    #[test]
-    fn test_zbi_container_get_next_paylad_length_overflow() {
-        let mut buffer = ZbiAligned::default();
-        // Buffer length that only fits container but not item header.
-        let len = 2 * core::mem::size_of::<ZbiHeader>() - 1;
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..len]).unwrap();
-        container.payload_length = usize::MAX; // Pretend that length is too big and cause
-                                               // overflow in following functions
-        assert_eq!(container.get_next_payload(), Err(ZbiError::LengthOverflow));
-    }
-
-    /* Binary blob for parsing container was generated from C implementation, running following
-     * test:
-     * --- a/src/firmware/lib/zbi/test/zbi.cc
-     * +++ b/src/firmware/lib/zbi/test/zbi.cc
-     * @@ -926,3 +926,21 @@ TEST(ZbiTests, ZbiTestNoOverflow) {
-     *
-     *    ASSERT_NE(zbi_extend(dst_buffer, kUsableBufferSize, src_buffer), ZBI_RESULT_OK);
-     *  }
-     * +
-     * +TEST(ZbiTests, ZbiTestGenDataForRustTest) {
-     * +  const size_t kExtraBytes = 10;
-     * +  uint8_t* buffer = get_test_zbi_extra(kExtraBytes);
-     * +  // Based on `get_test_zbi_extra()` implementation this is buffer size
-     * +  const size_t kBufferSize = sizeof(test_zbi_t) + kExtraBytes;
-     * +
-     * +  printf("buffer length = %zu\n", kBufferSize);
-     * +  printf("----BEGIN----\n");
-     * +  for (size_t i = 0; i < kBufferSize; i++) {
-     * +    if (i % 16 == 0) {
-     * +      printf("\n");
-     * +    }
-     * +    printf("%02x", buffer[i]);
-     * +  }
-     * +  printf("\n");
-     * +  printf("-----END-----\n");
-     * +}
-     */
-    #[test]
-    fn test_zbi_container_parse_c_reference() {
-        let ref_buffer = get_test_creference_buffer_vec();
-        let expected_container_hdr = ZbiHeader {
-            type_: ZBI_TYPE_CONTAINER,
-            extra: ZBI_CONTAINER_MAGIC,
-            length: 184,
-            magic: ZBI_ITEM_MAGIC,
-            crc32: ZBI_ITEM_NO_CRC32,
-            flags: ZbiFlags::default().bits(),
-            ..Default::default()
-        };
-        // Reference C implementation test uses cstrings for payload. That is why we need '\0' at
-        // the end of the string.
-        let expected_entries = get_test_entries_creference();
-
-        let mut buffer = ZbiAligned::default();
-        buffer.0[..ref_buffer.len()].clone_from_slice(&ref_buffer);
-
-        let container = ZbiContainer::parse(&buffer.0[..ref_buffer.len()]).unwrap();
-        assert_eq!(*container.header, expected_container_hdr);
-        check_container_made_of(&container, &expected_entries);
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_iterate() {
-        let mut buffer = ZbiAligned::default();
-        let new_entry = get_test_entry_nonempty_payload();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let (e, payload) = new_entry;
-        container
-            .create_entry_with_payload(e.type_.try_into().unwrap(), e.extra, e.get_flags(), payload)
-            .unwrap();
-
-        assert_eq!(container.iter().count(), 1);
-        let mut it = container.iter();
-        let item = it.next().unwrap();
-        assert_eq!(*item.header, e);
-        assert_eq!(&item.payload[..], payload);
-        assert!(it.next().is_none());
-    }
-
-    #[test]
-    fn test_zbi_container_new_entry_mut_iterate() {
-        let mut buffer = ZbiAligned::default();
-        let new_entry = get_test_entry_nonempty_payload();
-
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let (e, payload) = new_entry;
-        container
-            .create_entry_with_payload(e.type_.try_into().unwrap(), e.extra, e.get_flags(), payload)
-            .unwrap();
-
-        {
-            let mut item = container.iter_mut().next().unwrap();
-            assert_ne!(item.header.type_, ZbiType::DebugData.into());
-            item.header.type_ = ZbiType::DebugData.into();
-        }
-        {
-            let item = container.iter().next().unwrap();
-            assert_eq!(item.header.type_, ZbiType::DebugData.into());
-        }
-    }
-
-    #[test]
-    fn test_zbi_container_parse_new_entry_mut_iterate() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(&[1, 2])
-            .align()
-            .update_container_length()
-            .build();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-        let new_entry = get_test_entry_nonempty_payload();
-
-        let (e, payload) = new_entry;
-        container
-            .create_entry_with_payload(e.type_.try_into().unwrap(), e.extra, e.get_flags(), payload)
-            .unwrap();
-
-        assert_eq!(container.iter().count(), 2);
-        for mut item in container.iter_mut() {
-            assert_ne!(item.header.type_, ZbiType::DebugData.into());
-            item.header.type_ = ZbiType::DebugData.into();
-        }
-
-        for item in container.iter() {
-            assert_eq!(item.header.type_, ZbiType::DebugData.into());
-        }
-    }
-
-    #[test]
-    fn test_zbi_container_iterate_empty() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0).build();
-
-        assert_eq!(ZbiContainer::parse(&buffer.0[..]).unwrap().iter().count(), 0);
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-        assert_eq!(container.iter().count(), 0);
-        assert_eq!(container.iter_mut().count(), 0);
-    }
-
-    fn byteslice_cmp(byteslice: impl ByteSlice, slice: &[u8]) -> bool {
-        byteslice.len() == slice.len() && byteslice.iter().zip(slice.iter()).all(|(a, b)| a == b)
-    }
-
-    #[test]
-    fn test_zbi_container_iterate_ref() {
-        let mut buffer = get_test_creference_buffer();
-        let container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        assert_eq!(container.iter().count(), 4);
-        assert!(container.iter().zip(get_test_entries_creference().iter()).all(
-            |(it, (entry, payload))| { *it.header == *entry && byteslice_cmp(it.payload, payload) }
-        ));
-    }
-
-    #[test]
-    fn test_zbi_container_iterate_modify() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item_default(b"A")
-            .align()
-            .item_default(b"BB")
-            .align()
-            .item_default(b"CCC")
-            .align()
-            .update_container_length()
-            .build();
-        let mut container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-
-        container.iter_mut().for_each(|mut item| item.payload[0] = b'D');
-
-        assert!(container.iter().all(|b| b.payload[0] == b'D'));
-    }
-
-    #[test]
-    fn test_zbi_bad_type() {
-        assert_eq!(ZbiType::try_from(0), Err(ZbiError::BadType));
-    }
-
-    fn get_all_zbi_type_values() -> Vec<ZbiType> {
-        // strum and enum-iterator crates are not available at the moment, so just hard coding
-        // values
-        vec![
-            ZbiType::KernelX64,
-            ZbiType::KernelArm64,
-            ZbiType::KernelRiscv64,
-            ZbiType::Container,
-            ZbiType::Discard,
-            ZbiType::StorageRamdisk,
-            ZbiType::StorageBootFs,
-            ZbiType::StorageKernel,
-            ZbiType::StorageBootFsFactory,
-            ZbiType::CmdLine,
-            ZbiType::CrashLog,
-            ZbiType::Nvram,
-            ZbiType::PlatformId,
-            ZbiType::DrvBoardInfo,
-            ZbiType::CpuTopology,
-            ZbiType::MemConfig,
-            ZbiType::KernelDriver,
-            ZbiType::AcpiRsdp,
-            ZbiType::Smbios,
-            ZbiType::EfiSystemTable,
-            ZbiType::EfiMemoryAttributesTable,
-            ZbiType::FrameBuffer,
-            ZbiType::ImageArgs,
-            ZbiType::BootVersion,
-            ZbiType::DrvMacAddress,
-            ZbiType::DrvPartitionMap,
-            ZbiType::DrvBoardPrivate,
-            ZbiType::HwRebootReason,
-            ZbiType::SerialNumber,
-            ZbiType::BootloaderFile,
-            ZbiType::DeviceTree,
-            ZbiType::SecureEntropy,
-            ZbiType::DebugData,
-        ]
-    }
-
-    fn get_kernel_zbi_types() -> Vec<ZbiType> {
-        vec![ZbiType::KernelRiscv64, ZbiType::KernelX64, ZbiType::KernelArm64]
-    }
-    fn get_metadata_zbi_types() -> Vec<ZbiType> {
-        vec![
-            ZbiType::DrvBoardInfo,
-            ZbiType::DrvMacAddress,
-            ZbiType::DrvPartitionMap,
-            ZbiType::DrvBoardPrivate,
-        ]
-    }
-
-    #[test]
-    fn test_zbi_type_is_kernel() {
-        assert!(get_kernel_zbi_types().iter().all(|t| t.is_kernel()))
-    }
-
-    #[test]
-    fn test_zbi_type_is_not_kernel() {
-        assert!(get_all_zbi_type_values()
-            .iter()
-            .filter(|v| !get_kernel_zbi_types().contains(v))
-            .all(|v| !v.is_kernel()));
-    }
-
-    #[test]
-    fn test_zbi_type_is_driver_metadata() {
-        assert!(get_metadata_zbi_types().iter().all(|t| t.is_driver_metadata()));
-    }
-
-    #[test]
-    fn test_zbi_type_is_not_driver_metadata() {
-        assert!(get_all_zbi_type_values()
-            .iter()
-            .filter(|v| !get_metadata_zbi_types().contains(v))
-            .all(|v| !v.is_driver_metadata()));
-    }
-
-    #[test]
-    fn test_zbi_default_type_has_version() {
-        assert!(ZbiFlags::default().contains(ZbiFlags::VERSION));
-    }
-
-    #[test]
-    fn test_zbi_is_bootable() {
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-
-        container
-            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &[])
-            .unwrap();
-
-        assert!(container.is_bootable().is_ok());
-    }
-
-    #[cfg(target_arch = "x86_64")]
-    #[test]
-    fn test_zbi_is_bootable_reference() {
-        let ref_buffer = get_test_creference_buffer_vec();
-        let mut buffer = ZbiAligned::default();
-        buffer.0[..ref_buffer.len()].clone_from_slice(&ref_buffer);
-        let container = ZbiContainer::parse(&buffer.0[..]).unwrap();
-        assert!(container.is_bootable().is_ok());
-    }
-
-    #[test]
-    fn test_zbi_is_bootable_empty_container() {
-        let mut buffer = ZbiAligned::default();
-        let container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        assert_eq!(container.is_bootable(), Err(ZbiError::Truncated));
-    }
-
-    #[test]
-    fn test_zbi_is_bootable_wrong_arch() {
-        let mut buffer = ZbiAligned::default();
-        let _ = TestZbiBuilder::new(&mut buffer.0[..])
-            .container_hdr(0)
-            .align()
-            .item(ZbiHeader { type_: 0, ..TestZbiBuilder::get_header_default() }, &[])
-            .align()
-            .update_container_length()
-            .build();
-        let container = ZbiContainer::parse(&mut buffer.0[..]).unwrap();
-        assert_eq!(container.is_bootable(), Err(ZbiError::IncompleteKernel));
-    }
-
-    #[test]
-    fn test_zbi_is_bootable_not_first_item_fail() {
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-
-        container
-            .create_entry_with_payload(ZbiType::DebugData, 0, ZbiFlags::default(), &[])
-            .unwrap();
-        container
-            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &[])
-            .unwrap();
-
-        assert_eq!(container.is_bootable(), Err(ZbiError::IncompleteKernel));
-    }
-
-    #[test]
-    fn test_zbi_get_kernel_entry_and_reserved_memory_size() {
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let bytes = [1u64.to_le_bytes(), 2u64.to_le_bytes()].concat();
-        container
-            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &bytes)
-            .unwrap();
-        assert_eq!(container.get_kernel_entry_and_reserved_memory_size().unwrap(), (1, 2));
-    }
-
-    #[test]
-    fn test_zbi_get_kernel_entry_and_reserved_memory_size_truncated() {
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        container
-            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &[])
-            .unwrap();
-        assert!(container.get_kernel_entry_and_reserved_memory_size().is_err());
-    }
-
-    #[test]
-    fn zbi_get_buffer_size_for_kernel_relocation() {
-        let mut buffer = ZbiAligned::default();
-        let mut container = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let bytes = [0u64.to_le_bytes(), 1024u64.to_le_bytes()].concat();
-        container
-            .create_entry_with_payload(ZBI_ARCH_KERNEL_TYPE, 0, ZbiFlags::default(), &bytes)
-            .unwrap();
-        assert_eq!(
-            container.get_buffer_size_for_kernel_relocation().unwrap(),
-            container.container_size() + 1024
-        );
-    }
-
-    #[test]
-    fn test_zbi_header_alignment() {
-        assert_eq!(core::mem::size_of::<ZbiHeader>() & ZBI_ALIGNMENT_USIZE, 0);
-    }
-
-    fn get_test_payloads_all() -> Vec<&'static [u8]> {
-        vec![
-            &[],
-            &[1],
-            &[1, 2],
-            &[1, 2, 3, 4, 5],
-            // This 4 elements are for C reference binary testing
-            b"4567\0",
-            b"0123\0",
-            b"0123456789\0",
-            b"abcdefghijklmnopqrs\0",
-        ]
-    }
-
-    fn get_test_zbi_headers_all() -> Vec<ZbiHeader> {
-        let test_payloads = get_test_payloads_all();
-        vec![
-            ZbiHeader {
-                type_: ZBI_TYPE_KERNEL_RISCV64,
-                length: test_payloads[0].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_KERNEL_ARM64,
-                length: test_payloads[1].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_KERNEL_RISCV64,
-                length: test_payloads[2].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_KERNEL_X64,
-                length: test_payloads[3].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_KERNEL_X64,
-                length: test_payloads[4].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_CMDLINE,
-                length: test_payloads[5].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_STORAGE_RAMDISK,
-                length: test_payloads[6].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-            ZbiHeader {
-                type_: ZBI_TYPE_STORAGE_BOOTFS,
-                length: test_payloads[7].len().try_into().unwrap(),
-                extra: 0,
-                flags: ZbiFlags::default().bits(),
-                magic: ZBI_ITEM_MAGIC,
-                crc32: ZBI_ITEM_NO_CRC32,
-                ..Default::default()
-            },
-        ]
-    }
-
-    fn get_test_zbi_headers(num: usize) -> Vec<ZbiHeader> {
-        get_test_zbi_headers_all()[..num].to_vec()
-    }
-
-    fn get_test_entries_all() -> Vec<(ZbiHeader, &'static [u8])> {
-        let headers = get_test_zbi_headers_all();
-        let payloads = get_test_payloads_all();
-        assert_eq!(headers.len(), payloads.len());
-        headers.iter().cloned().zip(payloads.iter().cloned()).collect()
-    }
-
-    fn get_test_entries(num: usize) -> Vec<(ZbiHeader, &'static [u8])> {
-        get_test_entries_all()[..num].to_vec()
-    }
-
-    fn get_test_entry_empty_payload() -> (ZbiHeader, &'static [u8]) {
-        get_test_entries(1)[0]
-    }
-
-    fn get_test_entry_nonempty_payload() -> (ZbiHeader, &'static [u8]) {
-        get_test_entries(2)[1]
-    }
-
-    fn get_test_entries_creference() -> Vec<(ZbiHeader, &'static [u8])> {
-        let entries = get_test_entries_all();
-        entries[entries.len() - 4..].to_vec()
-    }
-
-    fn get_test_creference_buffer() -> ZbiAligned {
-        let entries = get_test_entries_creference();
-        let mut buffer = ZbiAligned::default();
-        let mut builder = TestZbiBuilder::new(&mut buffer.0[..]).container_hdr(0);
-        for entry in entries {
-            builder = builder.item(entry.0, entry.1).align();
-        }
-        let _ = builder.update_container_length().padding(0xab_u8, 10).build();
-        buffer
-    }
-
-    fn get_test_creference_buffer_vec() -> Vec<u8> {
-        hex::decode(
-            "424f4f54b8000000e6f78c8600000100\
-            0000000000000000291778b5d6e8874a\
-            4b524e4c050000000000000000000100\
-            0000000000000000291778b5d6e8874a\
-            3435363700000000434d444c05000000\
-            00000000000001000000000000000000\
-            291778b5d6e8874a3031323300000000\
-            5244534b0b0000000000000000000100\
-            0000000000000000291778b5d6e8874a\
-            30313233343536373839000000000000\
-            42465342140000000000000000000100\
-            0000000000000000291778b5d6e8874a\
-            6162636465666768696a6b6c6d6e6f70\
-            7172730000000000abababababababab\
-            abab",
-        )
-        .unwrap()
-    }
-
-    #[test]
-    fn test_creference_buffer_generation() {
-        let ref_buffer = get_test_creference_buffer_vec();
-        let buffer = get_test_creference_buffer();
-        assert_eq!(&ref_buffer[..ref_buffer.len()], &buffer.0[..ref_buffer.len()]);
-    }
-
-    #[test]
-    fn test_zbi_zbi_error() {
-        let e = ZbiError::Error;
-        println!("{e}");
-        println!("{e:?}");
-        println!("{e:#?}");
-    }
-
-    #[test]
-    fn test_zbi_container_align_buffer() {
-        let buffer = ZbiAligned::default();
-        let original_len = buffer.0.len();
-        let buffer = align_buffer(&buffer.0[1..]).unwrap();
-        assert_eq!(buffer.as_ptr() as usize % ZBI_ALIGNMENT_USIZE, 0);
-        assert_eq!(buffer.len(), original_len - ZBI_ALIGNMENT_USIZE);
-    }
-
-    #[test]
-    fn test_zbi_container_align_buffer_empty() {
-        let buffer = ZbiAligned::default();
-        let buffer = align_buffer(&buffer.0[..0]).unwrap();
-        assert_eq!(buffer.as_ptr() as usize % ZBI_ALIGNMENT_USIZE, 0);
-        assert_eq!(buffer.len(), 0);
-    }
-
-    #[test]
-    fn test_zbi_container_align_buffer_too_short() {
-        let buffer = ZbiAligned::default();
-        assert_eq!(align_buffer(&buffer.0[1..ZBI_ALIGNMENT_USIZE - 1]), Err(ZbiError::TooBig));
-    }
-
-    #[test]
-    fn test_zbi_container_align_buffer_just_enough() {
-        let buffer = ZbiAligned::default();
-        let buffer = align_buffer(&buffer.0[1..ZBI_ALIGNMENT_USIZE]).unwrap();
-        assert_eq!(buffer.as_ptr() as usize % ZBI_ALIGNMENT_USIZE, 0);
-        assert_eq!(buffer.len(), 0);
-    }
-
-    #[test]
-    fn test_merge_within() {
-        let mut buffer = vec![0u8; 1024];
-        let buffer = align_buffer(&mut buffer[..]).unwrap();
-
-        let mut container_0 = ZbiContainer::new(&mut buffer[..]).unwrap();
-        container_0
-            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"0")
-            .unwrap();
-        let container_size_0 = container_0.container_size();
-        let mut container_1 = ZbiContainer::new(&mut buffer[container_size_0..]).unwrap();
-        container_1
-            .create_entry_with_payload(ZbiType::CmdLine, 0, ZbiFlags::default(), b"1")
-            .unwrap();
-
-        // Makes a copy of the buffer for performing the merge.
-        let mut copy = buffer.to_vec();
-        let merged = merge_within(&mut copy[..], container_size_0).unwrap();
-
-        let (buffer_0, buffer_1) = buffer.split_at_mut(container_size_0);
-        let container_0 = ZbiContainer::parse(buffer_0).unwrap();
-        let container_1 = ZbiContainer::parse(buffer_1).unwrap();
-        let mut it = merged.iter();
-        assert_eq!(it.next().unwrap(), container_0.iter().next().unwrap());
-        assert_eq!(it.next().unwrap(), container_1.iter().next().unwrap());
-        assert!(it.next().is_none());
-    }
-
-    #[test]
-    fn test_merge_within_invalid_second_start() {
-        let mut buffer = ZbiAligned::default();
-        ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        assert!(merge_within(&mut buffer.0[..], 0).is_err());
-    }
-
-    #[test]
-    fn test_merge_within_invalid_first_container() {
-        let mut buffer = ZbiAligned::default();
-        ZbiContainer::new(&mut buffer.0[2 * ZBI_ALIGNMENT_USIZE..]).unwrap();
-        assert!(merge_within(&mut buffer.0[..], 2 * ZBI_ALIGNMENT_USIZE).is_err());
-    }
-
-    #[test]
-    fn test_merge_within_invalid_second_container() {
-        let mut buffer = ZbiAligned::default();
-        let first = ZbiContainer::new(&mut buffer.0[..]).unwrap();
-        let first_sz = first.container_size();
-        assert!(merge_within(&mut buffer.0[..], first_sz).is_err());
-    }
-}
diff --git a/gbl/third_party/libzbi/src/zbi_format.rs b/gbl/third_party/libzbi/src/zbi_format.rs
deleted file mode 100644
index 534994e..0000000
--- a/gbl/third_party/libzbi/src/zbi_format.rs
+++ /dev/null
@@ -1,511 +0,0 @@
-// Copyright 2024, The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Generated by ./bindgen.sh using bindgen 0.70.1
-
-// Allow non-conventional naming for imports from C/C++.
-#![allow(non_camel_case_types)]
-#![allow(non_snake_case)]
-#![allow(clippy::undocumented_unsafe_blocks)]
-// Allow unused definitions
-#![allow(dead_code)]
-// Allow unused return values for buildtime tests
-#![allow(unused_must_use)]
-
-use zerocopy::{AsBytes, FromBytes, FromZeroes};
-
-// Configure linkage for MacOS.
-#[cfg(target_os = "macos")]
-#[link(name = "IOKit", kind = "framework")]
-#[link(name = "CoreFoundation", kind = "framework")]
-extern "C" {}
-
-pub const ZBI_BOARD_NAME_LEN: u64 = 32;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_platform_id_t {
-    pub vid: u32,
-    pub pid: u32,
-    pub board_name: [::core::ffi::c_char; 32usize],
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_board_info_t {
-    pub revision: u32,
-}
-pub const ZBI_MAX_SMT: u64 = 4;
-pub type zbi_topology_processor_flags_t = u16;
-pub const ZBI_TOPOLOGY_PROCESSOR_FLAGS_PRIMARY: zbi_topology_processor_flags_t = 1;
-pub const ZBI_TOPOLOGY_PROCESSOR_FLAGS_INTERRUPT: zbi_topology_processor_flags_t = 2;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_arm64_info_t {
-    pub cluster_1_id: u8,
-    pub cluster_2_id: u8,
-    pub cluster_3_id: u8,
-    pub cpu_id: u8,
-    pub gic_id: u8,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_x64_info_t {
-    pub apic_ids: [u32; 4usize],
-    pub apic_id_count: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_riscv64_info_t {
-    pub hart_id: u64,
-    pub isa_strtab_index: u32,
-    pub reserved: u32,
-}
-pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_ARM64: u64 = 1;
-pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_X64: u64 = 2;
-pub const ZBI_TOPOLOGY_ARCHITECTURE_INFO_RISCV64: u64 = 3;
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub struct zbi_topology_architecture_info_t {
-    pub discriminant: u64,
-    pub __bindgen_anon_1: zbi_topology_architecture_info_t__bindgen_ty_1,
-}
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub union zbi_topology_architecture_info_t__bindgen_ty_1 {
-    pub arm64: zbi_topology_arm64_info_t,
-    pub x64: zbi_topology_x64_info_t,
-    pub riscv64: zbi_topology_riscv64_info_t,
-}
-impl Default for zbi_topology_architecture_info_t__bindgen_ty_1 {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_architecture_info_t__bindgen_ty_1 {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(f, "zbi_topology_architecture_info_t__bindgen_ty_1 {{ union }}")
-    }
-}
-impl Default for zbi_topology_architecture_info_t {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_architecture_info_t {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(
-            f,
-            "zbi_topology_architecture_info_t {{ __bindgen_anon_1: {:?} }}",
-            self.__bindgen_anon_1
-        )
-    }
-}
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub struct zbi_topology_processor_t {
-    pub architecture_info: zbi_topology_architecture_info_t,
-    pub flags: zbi_topology_processor_flags_t,
-    pub logical_ids: [u16; 4usize],
-    pub logical_id_count: u8,
-}
-impl Default for zbi_topology_processor_t {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_processor_t {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(
-            f,
-            "zbi_topology_processor_t {{ architecture_info: {:?}, logical_ids: {:?} }}",
-            self.architecture_info, self.logical_ids
-        )
-    }
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_cluster_t {
-    pub performance_class: u8,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_cache_t {
-    pub cache_id: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_die_t {
-    pub reserved: u64,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_socket_t {
-    pub reserved: u64,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_topology_numa_region_t {
-    pub start: u64,
-    pub size: u64,
-}
-pub const ZBI_TOPOLOGY_ENTITY_PROCESSOR: u64 = 1;
-pub const ZBI_TOPOLOGY_ENTITY_CLUSTER: u64 = 2;
-pub const ZBI_TOPOLOGY_ENTITY_CACHE: u64 = 3;
-pub const ZBI_TOPOLOGY_ENTITY_DIE: u64 = 4;
-pub const ZBI_TOPOLOGY_ENTITY_SOCKET: u64 = 5;
-pub const ZBI_TOPOLOGY_ENTITY_NUMA_REGION: u64 = 6;
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub struct zbi_topology_entity_t {
-    pub discriminant: u64,
-    pub __bindgen_anon_1: zbi_topology_entity_t__bindgen_ty_1,
-}
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub union zbi_topology_entity_t__bindgen_ty_1 {
-    pub processor: zbi_topology_processor_t,
-    pub cluster: zbi_topology_cluster_t,
-    pub cache: zbi_topology_cache_t,
-    pub die: zbi_topology_die_t,
-    pub socket: zbi_topology_socket_t,
-    pub numa_region: zbi_topology_numa_region_t,
-}
-impl Default for zbi_topology_entity_t__bindgen_ty_1 {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_entity_t__bindgen_ty_1 {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(f, "zbi_topology_entity_t__bindgen_ty_1 {{ union }}")
-    }
-}
-impl Default for zbi_topology_entity_t {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_entity_t {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(f, "zbi_topology_entity_t {{ __bindgen_anon_1: {:?} }}", self.__bindgen_anon_1)
-    }
-}
-pub const ZBI_TOPOLOGY_NO_PARENT: u16 = 65535;
-#[repr(C)]
-#[derive(Copy, Clone)]
-pub struct zbi_topology_node_t {
-    pub entity: zbi_topology_entity_t,
-    pub parent_index: u16,
-}
-impl Default for zbi_topology_node_t {
-    fn default() -> Self {
-        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
-        unsafe {
-            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
-            s.assume_init()
-        }
-    }
-}
-impl ::core::fmt::Debug for zbi_topology_node_t {
-    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
-        write!(f, "zbi_topology_node_t {{ entity: {:?} }}", self.entity)
-    }
-}
-pub type zbi_kernel_driver_t = u32;
-pub const ZBI_KERNEL_DRIVER_ARM_PSCI: zbi_kernel_driver_t = 1229149008;
-pub const ZBI_KERNEL_DRIVER_ARM_GIC_V2: zbi_kernel_driver_t = 843270471;
-pub const ZBI_KERNEL_DRIVER_ARM_GIC_V3: zbi_kernel_driver_t = 860047687;
-pub const ZBI_KERNEL_DRIVER_ARM_GENERIC_TIMER: zbi_kernel_driver_t = 1296651329;
-pub const ZBI_KERNEL_DRIVER_PL011_UART: zbi_kernel_driver_t = 1429228624;
-pub const ZBI_KERNEL_DRIVER_AMLOGIC_UART: zbi_kernel_driver_t = 1431063873;
-pub const ZBI_KERNEL_DRIVER_AMLOGIC_HDCP: zbi_kernel_driver_t = 1212960065;
-pub const ZBI_KERNEL_DRIVER_DW8250_UART: zbi_kernel_driver_t = 1146566741;
-pub const ZBI_KERNEL_DRIVER_AMLOGIC_RNG_V1: zbi_kernel_driver_t = 1212960082;
-pub const ZBI_KERNEL_DRIVER_AMLOGIC_RNG_V2: zbi_kernel_driver_t = 1380732225;
-pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG: zbi_kernel_driver_t = 842220631;
-pub const ZBI_KERNEL_DRIVER_GENI_UART: zbi_kernel_driver_t = 1229866311;
-pub const ZBI_KERNEL_DRIVER_I8250_PIO_UART: zbi_kernel_driver_t = 808792632;
-pub const ZBI_KERNEL_DRIVER_I8250_MMIO32_UART: zbi_kernel_driver_t = 1295331896;
-pub const ZBI_KERNEL_DRIVER_I8250_MMIO8_UART: zbi_kernel_driver_t = 1110782520;
-pub const ZBI_KERNEL_DRIVER_MOTMOT_UART: zbi_kernel_driver_t = 1296913493;
-pub const ZBI_KERNEL_DRIVER_MOTMOT_POWER: zbi_kernel_driver_t = 1296913488;
-pub const ZBI_KERNEL_DRIVER_AS370_POWER: zbi_kernel_driver_t = 1345337139;
-pub const ZBI_KERNEL_DRIVER_IMX_UART: zbi_kernel_driver_t = 1431850313;
-pub const ZBI_KERNEL_DRIVER_RISCV_PLIC: zbi_kernel_driver_t = 1128877136;
-pub const ZBI_KERNEL_DRIVER_RISCV_GENERIC_TIMER: zbi_kernel_driver_t = 1296651346;
-pub const ZBI_KERNEL_DRIVER_PXA_UART: zbi_kernel_driver_t = 1347961173;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_simple_t {
-    pub mmio_phys: u64,
-    pub irq: u32,
-    pub flags: u32,
-}
-pub type zbi_kernel_driver_irq_flags_t = u32;
-pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_EDGE_TRIGGERED: zbi_kernel_driver_irq_flags_t = 1;
-pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_LEVEL_TRIGGERED: zbi_kernel_driver_irq_flags_t = 2;
-pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_POLARITY_LOW: zbi_kernel_driver_irq_flags_t = 4;
-pub const ZBI_KERNEL_DRIVER_IRQ_FLAGS_POLARITY_HIGH: zbi_kernel_driver_irq_flags_t = 8;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_simple_pio_t {
-    pub base: u16,
-    pub reserved: u16,
-    pub irq: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_arm_psci_driver_t {
-    pub use_hvc: u8,
-    pub reserved: [u8; 7usize],
-    pub shutdown_args: [u64; 3usize],
-    pub reboot_args: [u64; 3usize],
-    pub reboot_bootloader_args: [u64; 3usize],
-    pub reboot_recovery_args: [u64; 3usize],
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_arm_gic_v2_driver_t {
-    pub mmio_phys: u64,
-    pub msi_frame_phys: u64,
-    pub gicd_offset: u64,
-    pub gicc_offset: u64,
-    pub gich_offset: u64,
-    pub gicv_offset: u64,
-    pub ipi_base: u32,
-    pub optional: u8,
-    pub use_msi: u8,
-    pub reserved: u16,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_arm_gic_v3_driver_t {
-    pub mmio_phys: u64,
-    pub gicd_offset: u64,
-    pub gicr_offset: u64,
-    pub gicr_stride: u64,
-    pub reserved0: u64,
-    pub ipi_base: u32,
-    pub optional: u8,
-    pub reserved1: [u8; 3usize],
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_arm_generic_timer_driver_t {
-    pub irq_phys: u32,
-    pub irq_virt: u32,
-    pub irq_sphys: u32,
-    pub freq_override: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_amlogic_hdcp_driver_t {
-    pub preset_phys: u64,
-    pub hiu_phys: u64,
-    pub hdmitx_phys: u64,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_amlogic_rng_driver_t {
-    pub rng_data_phys: u64,
-    pub rng_status_phys: u64,
-    pub rng_refresh_interval_usec: u64,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_generic32_watchdog_action_t {
-    pub addr: u64,
-    pub clr_mask: u32,
-    pub set_mask: u32,
-}
-pub type zbi_kernel_driver_generic32_watchdog_flags_t = u32;
-pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG_FLAGS_ENABLED:
-    zbi_kernel_driver_generic32_watchdog_flags_t = 1;
-pub const ZBI_KERNEL_DRIVER_GENERIC32_WATCHDOG_MIN_PERIOD: i64 = 1000000;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_generic32_watchdog_t {
-    pub pet_action: zbi_dcfg_generic32_watchdog_action_t,
-    pub enable_action: zbi_dcfg_generic32_watchdog_action_t,
-    pub disable_action: zbi_dcfg_generic32_watchdog_action_t,
-    pub watchdog_period_nsec: i64,
-    pub flags: zbi_kernel_driver_generic32_watchdog_flags_t,
-    pub reserved: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_riscv_plic_driver_t {
-    pub mmio_phys: u64,
-    pub num_irqs: u32,
-    pub reserved: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_dcfg_riscv_generic_timer_driver_t {
-    pub freq_hz: u32,
-    pub reserved: u32,
-}
-pub type zbi_pixel_format_t = u32;
-pub const ZBI_PIXEL_FORMAT_NONE: zbi_pixel_format_t = 0;
-pub const ZBI_PIXEL_FORMAT_RGB_565: zbi_pixel_format_t = 131073;
-pub const ZBI_PIXEL_FORMAT_RGB_332: zbi_pixel_format_t = 65538;
-pub const ZBI_PIXEL_FORMAT_RGB_2220: zbi_pixel_format_t = 65539;
-pub const ZBI_PIXEL_FORMAT_ARGB_8888: zbi_pixel_format_t = 262148;
-pub const ZBI_PIXEL_FORMAT_RGB_X888: zbi_pixel_format_t = 262149;
-pub const ZBI_PIXEL_FORMAT_MONO_8: zbi_pixel_format_t = 65543;
-pub const ZBI_PIXEL_FORMAT_NV12: zbi_pixel_format_t = 65544;
-pub const ZBI_PIXEL_FORMAT_I420: zbi_pixel_format_t = 65545;
-pub const ZBI_PIXEL_FORMAT_RGB_888: zbi_pixel_format_t = 196617;
-pub const ZBI_PIXEL_FORMAT_ABGR_8888: zbi_pixel_format_t = 262154;
-pub const ZBI_PIXEL_FORMAT_BGR_888_X: zbi_pixel_format_t = 262155;
-pub const ZBI_PIXEL_FORMAT_ARGB_2_10_10_10: zbi_pixel_format_t = 262156;
-pub const ZBI_PIXEL_FORMAT_ABGR_2_10_10_10: zbi_pixel_format_t = 262157;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_swfb_t {
-    pub base: u64,
-    pub width: u32,
-    pub height: u32,
-    pub stride: u32,
-    pub format: zbi_pixel_format_t,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_kernel_t {
-    pub entry: u64,
-    pub reserve_memory_size: u64,
-}
-pub type zbi_mem_type_t = u32;
-pub const ZBI_MEM_TYPE_RAM: zbi_mem_type_t = 1;
-pub const ZBI_MEM_TYPE_PERIPHERAL: zbi_mem_type_t = 2;
-pub const ZBI_MEM_TYPE_RESERVED: zbi_mem_type_t = 3;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_mem_range_t {
-    pub paddr: u64,
-    pub length: u64,
-    pub type_: zbi_mem_type_t,
-    pub reserved: u32,
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_nvram_t {
-    pub base: u64,
-    pub length: u64,
-}
-pub const ZBI_PARTITION_NAME_LEN: u64 = 32;
-pub const ZBI_PARTITION_GUID_LEN: u64 = 16;
-pub type zbi_partition_guid_t = [u8; 16usize];
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_partition_t {
-    pub type_guid: zbi_partition_guid_t,
-    pub uniq_guid: zbi_partition_guid_t,
-    pub first_block: u64,
-    pub last_block: u64,
-    pub flags: u64,
-    pub name: [::core::ffi::c_char; 32usize],
-}
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq)]
-pub struct zbi_partition_map_t {
-    pub block_count: u64,
-    pub block_size: u64,
-    pub partition_count: u32,
-    pub reserved: u32,
-    pub guid: zbi_partition_guid_t,
-}
-pub type zbi_hw_reboot_reason_t = u32;
-pub const ZBI_HW_REBOOT_REASON_UNDEFINED: zbi_hw_reboot_reason_t = 0;
-pub const ZBI_HW_REBOOT_REASON_COLD: zbi_hw_reboot_reason_t = 1;
-pub const ZBI_HW_REBOOT_REASON_WARM: zbi_hw_reboot_reason_t = 2;
-pub const ZBI_HW_REBOOT_REASON_BROWNOUT: zbi_hw_reboot_reason_t = 3;
-pub const ZBI_HW_REBOOT_REASON_WATCHDOG: zbi_hw_reboot_reason_t = 4;
-pub const ZBI_ALIGNMENT: u32 = 8;
-pub const ZBI_TYPE_KERNEL_PREFIX: u32 = 5132875;
-pub const ZBI_TYPE_KERNEL_MASK: u32 = 16777215;
-pub const ZBI_TYPE_DRIVER_METADATA_PREFIX: u32 = 109;
-pub const ZBI_TYPE_DRIVER_METADATA_MASK: u32 = 255;
-pub type zbi_type_t = u32;
-pub const ZBI_TYPE_CONTAINER: zbi_type_t = 1414483778;
-pub const ZBI_TYPE_KERNEL_X64: zbi_type_t = 1280201291;
-pub const ZBI_TYPE_KERNEL_ARM64: zbi_type_t = 944656971;
-pub const ZBI_TYPE_KERNEL_RISCV64: zbi_type_t = 1447973451;
-pub const ZBI_TYPE_DISCARD: zbi_type_t = 1346980691;
-pub const ZBI_TYPE_STORAGE_RAMDISK: zbi_type_t = 1263748178;
-pub const ZBI_TYPE_STORAGE_BOOTFS: zbi_type_t = 1112753730;
-pub const ZBI_TYPE_STORAGE_KERNEL: zbi_type_t = 1381258059;
-pub const ZBI_TYPE_STORAGE_BOOTFS_FACTORY: zbi_type_t = 1179862594;
-pub const ZBI_TYPE_CMDLINE: zbi_type_t = 1279544643;
-pub const ZBI_TYPE_CRASHLOG: zbi_type_t = 1297043266;
-pub const ZBI_TYPE_NVRAM: zbi_type_t = 1280071246;
-pub const ZBI_TYPE_PLATFORM_ID: zbi_type_t = 1145654352;
-pub const ZBI_TYPE_DRV_BOARD_INFO: zbi_type_t = 1230193261;
-pub const ZBI_TYPE_CPU_TOPOLOGY: zbi_type_t = 1129338163;
-pub const ZBI_TYPE_MEM_CONFIG: zbi_type_t = 1129137485;
-pub const ZBI_TYPE_KERNEL_DRIVER: zbi_type_t = 1448232011;
-pub const ZBI_TYPE_ACPI_RSDP: zbi_type_t = 1346655058;
-pub const ZBI_TYPE_SMBIOS: zbi_type_t = 1229081939;
-pub const ZBI_TYPE_EFI_SYSTEM_TABLE: zbi_type_t = 1397311045;
-pub const ZBI_TYPE_EFI_MEMORY_ATTRIBUTES_TABLE: zbi_type_t = 1413565765;
-pub const ZBI_TYPE_FRAMEBUFFER: zbi_type_t = 1111906131;
-pub const ZBI_TYPE_IMAGE_ARGS: zbi_type_t = 1196573001;
-pub const ZBI_TYPE_BOOT_VERSION: zbi_type_t = 1397904962;
-pub const ZBI_TYPE_DRV_MAC_ADDRESS: zbi_type_t = 1128353133;
-pub const ZBI_TYPE_DRV_PARTITION_MAP: zbi_type_t = 1414680685;
-pub const ZBI_TYPE_DRV_BOARD_PRIVATE: zbi_type_t = 1380926061;
-pub const ZBI_TYPE_HW_REBOOT_REASON: zbi_type_t = 1112692552;
-pub const ZBI_TYPE_SERIAL_NUMBER: zbi_type_t = 1313624659;
-pub const ZBI_TYPE_BOOTLOADER_FILE: zbi_type_t = 1279677506;
-pub const ZBI_TYPE_DEVICETREE: zbi_type_t = 3490578157;
-pub const ZBI_TYPE_SECURE_ENTROPY: zbi_type_t = 1145979218;
-pub const ZBI_TYPE_DEBUGDATA: zbi_type_t = 1145520708;
-pub const ZBI_TYPE_RISCV64_ISA_STRTAB: zbi_type_t = 1095977302;
-pub const ZBI_CONTAINER_MAGIC: u32 = 2257385446;
-pub const ZBI_ITEM_MAGIC: u32 = 3044546345;
-pub type zbi_flags_t = u32;
-pub const ZBI_FLAGS_VERSION: zbi_flags_t = 65536;
-pub const ZBI_FLAGS_CRC32: zbi_flags_t = 131072;
-pub const ZBI_ITEM_NO_CRC32: u32 = 1250420950;
-#[repr(C)]
-#[derive(Debug, Default, Copy, Clone, PartialEq, FromBytes, AsBytes, FromZeroes)]
-pub struct zbi_header_t {
-    pub type_: zbi_type_t,
-    pub length: u32,
-    pub extra: u32,
-    pub flags: zbi_flags_t,
-    pub reserved0: u32,
-    pub reserved1: u32,
-    pub magic: u32,
-    pub crc32: u32,
-}
diff --git a/gbl/toolchain/gbl_workspace_util.bzl b/gbl/toolchain/gbl_workspace_util.bzl
index 38ac1b3..9751ad4 100644
--- a/gbl/toolchain/gbl_workspace_util.bzl
+++ b/gbl/toolchain/gbl_workspace_util.bzl
@@ -127,7 +127,7 @@ gbl_llvm_prebuilts = repository_rule(
 
 # The current rust version used by GBL. This needs to be manually updated when new version of
 # prebuilts is uploaded to https://android.googlesource.com/platform/prebuilts/rust/
-GBL_RUST_VERSION = "1.80.1"
+GBL_RUST_VERSION = "1.81.0"
 
 def _android_rust_prebuilts_impl(repo_ctx):
     """Assemble a rust toolchain repo from the Android rust prebuilts repo.
diff --git a/vts/VtsBootconfigTest.cpp b/vts/VtsBootconfigTest.cpp
index 705940a..8f1d205 100644
--- a/vts/VtsBootconfigTest.cpp
+++ b/vts/VtsBootconfigTest.cpp
@@ -22,14 +22,15 @@
 class VtsBootconfigTest : public testing::Test {};
 
 TEST_F(VtsBootconfigTest, ProcCmdlineAndroidbootTest) {
-  // This was supported in Android S with kernel version 5.10+, but really only
-  // required by Android T because Android still needs to support
-  // Android S devices that launched with 4.19 for as long as it supports
-  // Android S.
+  // This is supported and required in Android S with kernel version
+  // 5.10+. Devices are allowed to launch with kernels < 5.10
+  // through Android T so the expectation from the Android framework, and the
+  // enforcement of this requirement, can only be on devices launched with
+  // Android U and beyond.
   int first_api_level = android::base::GetIntProperty(
         "ro.board.first_api_level",
         android::base::GetIntProperty("ro.vendor.api_level", 1000000));
-  if (first_api_level < __ANDROID_API_T__) {
+  if (first_api_level < __ANDROID_API_U__) {
     GTEST_SKIP() << "Bootconfig requirements do not apply";
   }
 
```

