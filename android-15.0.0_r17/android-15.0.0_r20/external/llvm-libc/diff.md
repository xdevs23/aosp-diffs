```diff
diff --git a/Android.bp b/Android.bp
index aa0d17f..80048b7 100644
--- a/Android.bp
+++ b/Android.bp
@@ -2,20 +2,21 @@
 
 cc_defaults {
     name: "llvmlibc_defaults",
+    defaults: [
+        // b/379681564: Bionic's dependencies all must support linux-bionic,
+        // which is not an enabled target by default.
+        "linux_bionic_supported",
+    ],
     cppflags: [
         // Necessary to build.
         "-DLIBC_NAMESPACE=llvmlibc",
     ],
     arch: {
-        // TODO: https://github.com/llvm/llvm-project/issues/93709
-        // llvm-libc does not (yet) support 32b x86.
-        x86: {
-            enabled: false,
-        },
         // TODO: https://github.com/llvm/llvm-project/issues/93738
         // llvm-libc does not (yet) support --target=armv7a-linux -mthumb
+        // Build in ARM mode, but perhaps revisit this in the future.
         arm: {
-            cppflags: ["-marm"],
+            instruction_set: "arm",
         },
     },
 }
@@ -31,10 +32,16 @@ cc_library_static {
     ],
     srcs: [
         "src/stdlib/bsearch.cpp",
+        "src/string/memrchr.cpp",
+        "src/string/strlcat.cpp",
+        "src/string/strlcpy.cpp",
     ],
     cppflags: [
         // Necessary for non-namespaced exports.
         "-DLIBC_COPT_PUBLIC_PACKAGING",
+        // TODO: remove when https://github.com/llvm/llvm-project/pull/116686 is
+        // integrated.
+        "-DLLVM_LIBC_FUNCTION_ATTR=__attribute__((visibility(\"default\")))",
     ],
     // No C++ runtime.
     stl: "none",
@@ -56,6 +63,28 @@ cc_library_static {
 
     // When llvm-libc includes <stdlib.h>, use bionic's headers for these.
     header_libs: ["libc_headers"],
+
+    // TODO(b/378117947): push these into non-arch-specific `srcs` as llvm-libc
+    // functions are rolled out.
+    arch: {
+        arm64: {
+            // These have optimized baseline and vectorized impls from
+            // arm-optimized-routines, and aren't yet heavily optimized by
+            // llvm-libc.
+            exclude_srcs: [
+                "src/string/memrchr.cpp",
+            ],
+        },
+        x86_64: {
+            srcs: [
+                "src/string/memchr.cpp",
+                "src/string/strchr.cpp",
+                "src/string/strchrnul.cpp",
+                "src/string/strnlen.cpp",
+                "src/string/strrchr.cpp",
+            ],
+        },
+    },
 }
 
 cc_test_library {
@@ -86,7 +115,33 @@ cc_defaults {
 }
 
 cc_test {
+    // TODO: rename test to simply llvmlibc_tests. Needs to go through a post
+    // submit cycle before can be renamed for presubmit.
     name: "llvmlibc_stdlib_bsearch_test",
     defaults: ["llvmlibc_test_defaults"],
-    srcs: ["test/src/stdlib/bsearch_test.cpp"],
+    srcs: [
+        "test/src/stdlib/bsearch_test.cpp",
+        "test/src/string/memrchr_test.cpp",
+        "test/src/string/strlcat_test.cpp",
+        "test/src/string/strlcpy_test.cpp",
+    ],
+    arch: {
+        arm64: {
+            // Match exclusions in ':llvmlibc' for arm64.
+            exclude_srcs: [
+                "test/src/string/memrchr_test.cpp",
+            ],
+        },
+        x86_64: {
+            // TODO(b/378117947): push these into non-arch-specific `srcs` as
+            // llvm-libc functions are rolled out.
+            srcs: [
+                "test/src/string/memchr_test.cpp",
+                "test/src/string/strchr_test.cpp",
+                "test/src/string/strchrnul_test.cpp",
+                "test/src/string/strnlen_test.cpp",
+                "test/src/string/strrchr_test.cpp",
+            ],
+        },
+    },
 }
diff --git a/hdr/errno_macros.h b/hdr/errno_macros.h
index 198b523..27ea499 100644
--- a/hdr/errno_macros.h
+++ b/hdr/errno_macros.h
@@ -14,9 +14,9 @@
 #ifdef __linux__
 #include <linux/errno.h>
 
-#include "llvm-libc-macros/error-number-macros.h"
+#include "include/llvm-libc-macros/error-number-macros.h"
 #else // __linux__
-#include "llvm-libc-macros/generic-error-number-macros.h"
+#include "include/llvm-libc-macros/generic-error-number-macros.h"
 #endif
 
 #else // Overlay mode
diff --git a/hdr/fcntl_macros.h b/hdr/fcntl_macros.h
index 828cb98..3a1ddeb 100644
--- a/hdr/fcntl_macros.h
+++ b/hdr/fcntl_macros.h
@@ -15,7 +15,7 @@
 
 #else // Overlay mode
 
-#include <fcntl.h>
+#include "hdr/fcntl_overlay.h"
 
 #endif // LLVM_LIBC_FULL_BUILD
 
diff --git a/hdr/fcntl_overlay.h b/hdr/fcntl_overlay.h
new file mode 100644
index 0000000..c1cc98b
--- /dev/null
+++ b/hdr/fcntl_overlay.h
@@ -0,0 +1,37 @@
+//===-- Including fcntl.h in overlay mode ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_FCNTL_OVERLAY_H
+#define LLVM_LIBC_HDR_FCNTL_OVERLAY_H
+
+#ifdef LIBC_FULL_BUILD
+#error "This header should only be included in overlay mode"
+#endif
+
+// Overlay mode
+
+// glibc <fcntl.h> header might provide extern inline definitions for few
+// functions, causing external alias errors.  They are guarded by
+// `__USE_FORTIFY_LEVEL`, which will be temporarily disabled
+// with `_FORTIFY_SOURCE`.
+
+#ifdef __USE_FORTIFY_LEVEL
+#define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
+#include <fcntl.h>
+
+#ifdef LIBC_OLD_USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
+#undef LIBC_OLD_USE_FORTIFY_LEVEL
+#endif
+
+#endif // LLVM_LIBC_HDR_FCNTL_OVERLAY_H
diff --git a/hdr/fenv_macros.h b/hdr/fenv_macros.h
index a2e4462..3f0bd89 100644
--- a/hdr/fenv_macros.h
+++ b/hdr/fenv_macros.h
@@ -19,7 +19,6 @@
 
 // In some environment, FE_ALL_EXCEPT is set to 0 and the remaining exceptions
 // FE_* are missing.
-#if (FE_ALL_EXCEPT == 0)
 #ifndef FE_DIVBYZERO
 #define FE_DIVBYZERO 0
 #endif // FE_DIVBYZERO
@@ -39,12 +38,6 @@
 #ifndef FE_UNDERFLOW
 #define FE_UNDERFLOW 0
 #endif // FE_UNDERFLOW
-#else
-// If this is not provided by the system, define it for use internally.
-#ifndef __FE_DENORM
-#define __FE_DENORM (1 << 6)
-#endif
-#endif
 
 // Rounding mode macros might be missing.
 #ifndef FE_DOWNWARD
diff --git a/hdr/func/aligned_alloc.h b/hdr/func/aligned_alloc.h
new file mode 100644
index 0000000..b3436df
--- /dev/null
+++ b/hdr/func/aligned_alloc.h
@@ -0,0 +1,22 @@
+//===-- Definition of the aligned_alloc.h proxy ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_FUNC_ALIGNED_ALLOC_H
+#define LLVM_LIBC_HDR_FUNC_ALIGNED_ALLOC_H
+
+#ifdef LIBC_FULL_BUILD
+#include "hdr/types/size_t.h"
+extern "C" void *aligned_alloc(size_t, size_t);
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif
+
+#endif
diff --git a/hdr/func/free.h b/hdr/func/free.h
new file mode 100644
index 0000000..b1190a7
--- /dev/null
+++ b/hdr/func/free.h
@@ -0,0 +1,21 @@
+//===-- Definition of the free.h proxy ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_FUNC_FREE_H
+#define LLVM_LIBC_HDR_FUNC_FREE_H
+
+#ifdef LIBC_FULL_BUILD
+extern "C" void free(void *);
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif
+
+#endif
diff --git a/hdr/func/malloc.h b/hdr/func/malloc.h
new file mode 100644
index 0000000..b395f41
--- /dev/null
+++ b/hdr/func/malloc.h
@@ -0,0 +1,22 @@
+//===-- Definition of the malloc.h proxy ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_FUNC_MALLOC_H
+#define LLVM_LIBC_HDR_FUNC_MALLOC_H
+
+#ifdef LIBC_FULL_BUILD
+#include "hdr/types/size_t.h"
+extern "C" void *malloc(size_t);
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif
+
+#endif
diff --git a/hdr/func/realloc.h b/hdr/func/realloc.h
new file mode 100644
index 0000000..0096045
--- /dev/null
+++ b/hdr/func/realloc.h
@@ -0,0 +1,22 @@
+//===-- Definition of the realloc.h proxy ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_FUNC_REALLOC_H
+#define LLVM_LIBC_HDR_FUNC_REALLOC_H
+
+#ifdef LIBC_FULL_BUILD
+#include "hdr/types/size_t.h"
+extern "C" void *realloc(void *ptr, size_t new_size);
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif
+
+#endif
diff --git a/hdr/limits_macros.h b/hdr/limits_macros.h
new file mode 100644
index 0000000..2dc13b0
--- /dev/null
+++ b/hdr/limits_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from limits.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_LIMITS_MACROS_H
+#define LLVM_LIBC_HDR_LIMITS_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/limits-macros.h"
+
+#else // Overlay mode
+
+#include <limits.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_LIMITS_MACROS_H
diff --git a/hdr/link_macros.h b/hdr/link_macros.h
new file mode 100644
index 0000000..8a78a86
--- /dev/null
+++ b/hdr/link_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from link.h ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_LINK_MACROS_H
+#define LLVM_LIBC_HDR_LINK_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/link-macros.h"
+
+#else // Overlay mode
+
+#include <link.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_LINK_MACROS_H
diff --git a/hdr/math_function_macros.h b/hdr/math_function_macros.h
new file mode 100644
index 0000000..48dec82
--- /dev/null
+++ b/hdr/math_function_macros.h
@@ -0,0 +1,27 @@
+//===-- Definition of macros from math.h ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_MATH_FUNCTION_MACROS_H
+#define LLVM_LIBC_HDR_MATH_FUNCTION_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#else // Overlay mode
+
+// GCC will include CXX headers when __cplusplus is defined. This behavior
+// can be suppressed by defining _GLIBCXX_INCLUDE_NEXT_C_HEADERS.
+#if defined(__GNUC__) && !defined(__clang__)
+#define _GLIBCXX_INCLUDE_NEXT_C_HEADERS
+#endif
+#include <math.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_MATH_MACROS_H
diff --git a/hdr/math_macros.h b/hdr/math_macros.h
index d13c5ff..8634511 100644
--- a/hdr/math_macros.h
+++ b/hdr/math_macros.h
@@ -15,6 +15,11 @@
 
 #else // Overlay mode
 
+// GCC will include CXX headers when __cplusplus is defined. This behavior
+// can be suppressed by defining _GLIBCXX_INCLUDE_NEXT_C_HEADERS.
+#if defined(__GNUC__) && !defined(__clang__)
+#define _GLIBCXX_INCLUDE_NEXT_C_HEADERS
+#endif
 #include <math.h>
 
 // Some older math.h header does not have FP_INT_* constants yet.
diff --git a/hdr/stdio_macros.h b/hdr/stdio_macros.h
new file mode 100644
index 0000000..a4d6a97
--- /dev/null
+++ b/hdr/stdio_macros.h
@@ -0,0 +1,23 @@
+//===-- Definition of macros from stdio.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_STDIO_MACROS_H
+#define LLVM_LIBC_HDR_STDIO_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/file-seek-macros.h"
+#include "include/llvm-libc-macros/stdio-macros.h"
+
+#else // Overlay mode
+
+#include "stdio_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_STDIO_MACROS_H
diff --git a/hdr/stdio_overlay.h b/hdr/stdio_overlay.h
new file mode 100644
index 0000000..aef8c44
--- /dev/null
+++ b/hdr/stdio_overlay.h
@@ -0,0 +1,69 @@
+//===-- Including stdio.h in overlay mode ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_STDIO_OVERLAY_H
+#define LLVM_LIBC_HDR_STDIO_OVERLAY_H
+
+#ifdef LIBC_FULL_BUILD
+#error "This header should only be included in overlay mode"
+#endif
+
+// Overlay mode
+
+// glibc <stdio.h> header might provide extern inline definitions for few
+// functions, causing external alias errors.  They are guarded by
+// `__USE_EXTERN_INLINES` macro.  We temporarily disable `__USE_EXTERN_INLINES`
+// macro by defining `__NO_INLINE__` before including <stdio.h>.
+// And the same with `__USE_FORTIFY_LEVEL`, which will be temporarily disabled
+// with `_FORTIFY_SOURCE`.
+
+#ifdef _FORTIFY_SOURCE
+#define LIBC_OLD_FORTIFY_SOURCE _FORTIFY_SOURCE
+#undef _FORTIFY_SOURCE
+#endif
+
+#ifdef __USE_EXTERN_INLINES
+#define LIBC_OLD_USE_EXTERN_INLINES
+#undef __USE_EXTERN_INLINES
+#endif
+
+#ifdef __USE_FORTIFY_LEVEL
+#define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
+#ifndef __NO_INLINE__
+#define __NO_INLINE__ 1
+#define LIBC_SET_NO_INLINE
+#endif
+
+#include <stdio.h>
+
+#ifdef LIBC_OLD_FORTIFY_SOURCE
+#define _FORTIFY_SOURCE LIBC_OLD_FORTIFY_SOURCE
+#undef LIBC_OLD_FORTIFY_SOURCE
+#endif
+
+#ifdef LIBC_SET_NO_INLINE
+#undef __NO_INLINE__
+#undef LIBC_SET_NO_INLINE
+#endif
+
+#ifdef LIBC_OLD_USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
+#undef LIBC_OLD_USE_FORTIFY_LEVEL
+#endif
+
+#ifdef LIBC_OLD_USE_EXTERN_INLINES
+#define __USE_EXTERN_INLINES
+#undef LIBC_OLD_USE_EXTERN_INLINES
+#endif
+
+#endif // LLVM_LIBC_HDR_STDIO_OVERLAY_H
diff --git a/hdr/stdlib_macros.h b/hdr/stdlib_macros.h
new file mode 100644
index 0000000..3faeb3a
--- /dev/null
+++ b/hdr/stdlib_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from stdlib.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_STDLIB_MACROS_H
+#define LLVM_LIBC_HDR_STDLIB_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/stdlib-macros.h"
+
+#else // Overlay mode
+
+#include "stdlib_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_STDLIB_MACROS_H
diff --git a/hdr/stdlib_overlay.h b/hdr/stdlib_overlay.h
new file mode 100644
index 0000000..f095caf
--- /dev/null
+++ b/hdr/stdlib_overlay.h
@@ -0,0 +1,36 @@
+//===-- Including stdlib.h in overlay mode --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_STDLIB_OVERLAY_H
+#define LLVM_LIBC_HDR_STDLIB_OVERLAY_H
+
+#ifdef LIBC_FULL_BUILD
+#error "This header should only be included in overlay mode"
+#endif
+
+// Overlay mode
+
+// glibc <stdlib.h> header might provide extern inline definitions for few
+// functions, causing external alias errors.  They are guarded by
+// `__USE_FORTIFY_LEVEL`, which will be temporarily disabled.
+
+#ifdef __USE_FORTIFY_LEVEL
+#define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
+#include <stdlib.h>
+
+#ifdef LIBC_OLD_USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
+#undef LIBC_OLD_USE_FORTIFY_LEVEL
+#endif
+
+#endif
diff --git a/hdr/sys_auxv_macros.h b/hdr/sys_auxv_macros.h
new file mode 100644
index 0000000..c04011b
--- /dev/null
+++ b/hdr/sys_auxv_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from sys/auxv.h ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_SYS_AUXV_MACROS_H
+#define LLVM_LIBC_HDR_SYS_AUXV_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/sys-auxv-macros.h"
+
+#else // Overlay mode
+
+#include <sys/auxv.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_SYS_AUXV_MACROS_H
diff --git a/hdr/sys_stat_macros.h b/hdr/sys_stat_macros.h
new file mode 100644
index 0000000..cb58d62
--- /dev/null
+++ b/hdr/sys_stat_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from sys/stat.h ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_SYS_STAT_MACROS_H
+#define LLVM_LIBC_HDR_SYS_STAT_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/sys-stat-macros.h"
+
+#else // Overlay mode
+
+#include <sys/stat.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_SYS_STAT_MACROS_H
diff --git a/hdr/types/FILE.h b/hdr/types/FILE.h
new file mode 100644
index 0000000..ecb52b7
--- /dev/null
+++ b/hdr/types/FILE.h
@@ -0,0 +1,22 @@
+//===-- Proxy for FILE ----------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_FILE_H
+#define LLVM_LIBC_HDR_TYPES_FILE_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/FILE.h"
+
+#else // Overlay mode
+
+#include "hdr/stdio_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_FILE_H
diff --git a/hdr/types/atexithandler_t.h b/hdr/types/atexithandler_t.h
index 4275e44..6d829fe 100644
--- a/hdr/types/atexithandler_t.h
+++ b/hdr/types/atexithandler_t.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_HDR_ATEXITHANDLER_T_H
-#define LLVM_LIBC_HDR_ATEXITHANDLER_T_H
+#ifndef LLVM_LIBC_HDR_TYPES_ATEXITHANDLER_T_H
+#define LLVM_LIBC_HDR_TYPES_ATEXITHANDLER_T_H
 
 #ifdef LIBC_FULL_BUILD
 
@@ -19,4 +19,4 @@
 
 #endif // LLVM_LIBC_FULL_BUILD
 
-#endif // LLVM_LIBC_HDR_ATEXITHANDLER_T_H
+#endif // LLVM_LIBC_HDR_TYPES_ATEXITHANDLER_T_H
diff --git a/hdr/types/cookie_io_functions_t.h b/hdr/types/cookie_io_functions_t.h
new file mode 100644
index 0000000..7323a05
--- /dev/null
+++ b/hdr/types/cookie_io_functions_t.h
@@ -0,0 +1,22 @@
+//===-- Proxy for cookie_io_functions_t -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_COOKIE_IO_FUNCTIONS_T_H
+#define LLVM_LIBC_HDR_TYPES_COOKIE_IO_FUNCTIONS_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/cookie_io_functions_t.h"
+
+#else // Overlay mode
+
+#include "hdr/stdio_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_COOKIE_IO_FUNCTIONS_T_H
diff --git a/hdr/types/div_t.h b/hdr/types/div_t.h
new file mode 100644
index 0000000..29c355f
--- /dev/null
+++ b/hdr/types/div_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from div_t.h ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_DIV_T_H
+#define LLVM_LIBC_HDR_TYPES_DIV_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/div_t.h"
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_DIV_T_H
diff --git a/hdr/types/fenv_t.h b/hdr/types/fenv_t.h
index dc2dd02..ddfb08c 100644
--- a/hdr/types/fenv_t.h
+++ b/hdr/types/fenv_t.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_HDR_FENV_T_H
-#define LLVM_LIBC_HDR_FENV_T_H
+#ifndef LLVM_LIBC_HDR_TYPES_FENV_T_H
+#define LLVM_LIBC_HDR_TYPES_FENV_T_H
 
 #ifdef LIBC_FULL_BUILD
 
@@ -19,4 +19,4 @@
 
 #endif // LLVM_LIBC_FULL_BUILD
 
-#endif // LLVM_LIBC_HDR_FENV_T_H
+#endif // LLVM_LIBC_HDR_TYPES_FENV_T_H
diff --git a/hdr/types/fexcept_t.h b/hdr/types/fexcept_t.h
index 7a67025..761f125 100644
--- a/hdr/types/fexcept_t.h
+++ b/hdr/types/fexcept_t.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_HDR_FEXCEPT_T_H
-#define LLVM_LIBC_HDR_FEXCEPT_T_H
+#ifndef LLVM_LIBC_HDR_TYPES_FEXCEPT_T_H
+#define LLVM_LIBC_HDR_TYPES_FEXCEPT_T_H
 
 #ifdef LIBC_FULL_BUILD
 
@@ -19,4 +19,4 @@
 
 #endif // LLVM_LIBC_FULL_BUILD
 
-#endif // LLVM_LIBC_HDR_FENV_T_H
+#endif // LLVM_LIBC_HDR_TYPES_FEXCEPT_T_H
diff --git a/hdr/types/jmp_buf.h b/hdr/types/jmp_buf.h
new file mode 100644
index 0000000..3fa1de8
--- /dev/null
+++ b/hdr/types/jmp_buf.h
@@ -0,0 +1,22 @@
+//===-- Definition of jmp_buf.h ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apahce License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_JMP_BUF_H
+#define LLVM_LIBC_HDR_TYPES_JMP_BUF_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/jmp_buf.h"
+
+#else // overlay mode
+
+#include <setjmp.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_JMP_BUF_H
diff --git a/hdr/types/ldiv_t.h b/hdr/types/ldiv_t.h
new file mode 100644
index 0000000..c7023f5
--- /dev/null
+++ b/hdr/types/ldiv_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from ldiv_t.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_LDIV_T_H
+#define LLVM_LIBC_HDR_TYPES_LDIV_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/ldiv_t.h"
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_LDIV_T_H
diff --git a/hdr/types/lldiv_t.h b/hdr/types/lldiv_t.h
new file mode 100644
index 0000000..cd41886
--- /dev/null
+++ b/hdr/types/lldiv_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from lldiv_t.h -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_LLDIV_T_H
+#define LLVM_LIBC_HDR_TYPES_LLDIV_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/lldiv_t.h"
+
+#else // Overlay mode
+
+#include "hdr/stdlib_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_LLDIV_T_H
diff --git a/hdr/types/locale_t.h b/hdr/types/locale_t.h
new file mode 100644
index 0000000..be12d12
--- /dev/null
+++ b/hdr/types/locale_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from locale_t.h ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_LOCALE_T_H
+#define LLVM_LIBC_HDR_TYPES_LOCALE_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/locale_t.h"
+
+#else // overlay mode
+
+#error "type not available in overlay mode"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_LOCALE_T_H
diff --git a/hdr/types/mode_t.h b/hdr/types/mode_t.h
new file mode 100644
index 0000000..3f36a19
--- /dev/null
+++ b/hdr/types/mode_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from mode_t.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_MODE_T_H
+#define LLVM_LIBC_HDR_TYPES_MODE_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/mode_t.h"
+
+#else // Overlay mode
+
+#include "hdr/fcntl_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_MODE_T_H
diff --git a/hdr/types/off_t.h b/hdr/types/off_t.h
new file mode 100644
index 0000000..52337e5
--- /dev/null
+++ b/hdr/types/off_t.h
@@ -0,0 +1,22 @@
+//===-- Proxy for off_t ---------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_OFF_T_H
+#define LLVM_LIBC_HDR_TYPES_OFF_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/off_t.h"
+
+#else // Overlay mode
+
+#include "hdr/stdio_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_OFF_T_H
diff --git a/hdr/types/sighandler_t.h b/hdr/types/sighandler_t.h
new file mode 100644
index 0000000..bc40dd8
--- /dev/null
+++ b/hdr/types/sighandler_t.h
@@ -0,0 +1,24 @@
+//===-- Definition of macros from __sighandler_t.h ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
+#define LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/__sighandler_t.h"
+
+using sighandler_t = __sighandler_t;
+
+#else // overlay mode
+
+#include <signal.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
diff --git a/hdr/types/size_t.h b/hdr/types/size_t.h
new file mode 100644
index 0000000..1d9f26d
--- /dev/null
+++ b/hdr/types/size_t.h
@@ -0,0 +1,23 @@
+//===-- Proxy for size_t --------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_SIZE_T_H
+#define LLVM_LIBC_HDR_TYPES_SIZE_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/size_t.h"
+
+#else
+
+#define __need_size_t
+#include <stddef.h>
+#undef __need_size_t
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_SIZE_T_H
diff --git a/hdr/types/socklen_t.h b/hdr/types/socklen_t.h
new file mode 100644
index 0000000..79a6b9c
--- /dev/null
+++ b/hdr/types/socklen_t.h
@@ -0,0 +1,21 @@
+//===-- Proxy for socklen_t -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_SOCKLEN_T_H
+#define LLVM_LIBC_HDR_TYPES_SOCKLEN_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/socklen_t.h"
+
+#else
+
+#include <signal.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_SOCKLEN_T_H
diff --git a/hdr/types/ssize_t.h b/hdr/types/ssize_t.h
new file mode 100644
index 0000000..4d20007
--- /dev/null
+++ b/hdr/types/ssize_t.h
@@ -0,0 +1,23 @@
+//===-- Proxy for ssize_t -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_SSIZE_T_H
+#define LLVM_LIBC_HDR_TYPES_SSIZE_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/ssize_t.h"
+
+#else
+
+#define __need_ssize_t
+#include <stddef.h>
+#undef __need_ssize_t
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_SSIZE_T_H
diff --git a/hdr/types/stack_t.h b/hdr/types/stack_t.h
new file mode 100644
index 0000000..42dad3a
--- /dev/null
+++ b/hdr/types/stack_t.h
@@ -0,0 +1,23 @@
+//===-- Definition of stack_t.h -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_STACK_T_H
+#define LLVM_LIBC_HDR_TYPES_STACK_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/stack_t.h"
+
+#else // overlay mode
+
+#include <signal.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STACK_T_H
diff --git a/hdr/types/struct_msghdr.h b/hdr/types/struct_msghdr.h
new file mode 100644
index 0000000..6a36af7
--- /dev/null
+++ b/hdr/types/struct_msghdr.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct msghdr  ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_MSGHDR_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_MSGHDR_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_msghdr.h"
+
+#else
+
+#include <sys/socket.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_MSGHDR_H
diff --git a/hdr/types/struct_sigaction.h b/hdr/types/struct_sigaction.h
new file mode 100644
index 0000000..60f6cae
--- /dev/null
+++ b/hdr/types/struct_sigaction.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct sigaction  ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_SIGACTION_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_SIGACTION_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_sigaction.h"
+
+#else
+
+#include <signal.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_SIGACTION_H
diff --git a/hdr/types/struct_sockaddr.h b/hdr/types/struct_sockaddr.h
new file mode 100644
index 0000000..0fc31d5
--- /dev/null
+++ b/hdr/types/struct_sockaddr.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct sockaddr  ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_SOCKADDR_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_SOCKADDR_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_sockaddr.h"
+
+#else
+
+#include <sys/socket.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_SOCKADDR_H
diff --git a/hdr/types/suseconds_t.h b/hdr/types/suseconds_t.h
index 72e54a9..f60168c 100644
--- a/hdr/types/suseconds_t.h
+++ b/hdr/types/suseconds_t.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_HDR_TIMES_SUSECONDS_T_H
-#define LLVM_LIBC_HDR_TIMES_SUSECONDS_T_H
+#ifndef LLVM_LIBC_HDR_TYPES_SUSECONDS_T_H
+#define LLVM_LIBC_HDR_TYPES_SUSECONDS_T_H
 
 #ifdef LIBC_FULL_BUILD
 
@@ -19,4 +19,4 @@
 
 #endif // LLVM_LIBC_FULL_BUILD
 
-#endif // #ifndef LLVM_LIBC_HDR_TIMES_SUSECONDS_T_H
+#endif // #ifndef LLVM_LIBC_HDR_TYPES_SUSECONDS_T_H
diff --git a/hdr/types/wchar_t.h b/hdr/types/wchar_t.h
new file mode 100644
index 0000000..75e9452
--- /dev/null
+++ b/hdr/types/wchar_t.h
@@ -0,0 +1,23 @@
+//===-- Definition of wchar_t.h -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_WCHAR_T_H
+#define LLVM_LIBC_HDR_TYPES_WCHAR_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/wchar_t.h"
+
+#else // overlay mode
+
+#include "hdr/wchar_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_WCHAR_T_H
diff --git a/hdr/types/wint_t.h b/hdr/types/wint_t.h
new file mode 100644
index 0000000..6b91859
--- /dev/null
+++ b/hdr/types/wint_t.h
@@ -0,0 +1,23 @@
+//===-- Definition of wint_t.h --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_WINT_T_H
+#define LLVM_LIBC_HDR_TYPES_WINT_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/wint_t.h"
+
+#else // overlay mode
+
+#include "hdr/wchar_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_WINT_T_H
diff --git a/hdr/unistd_macros.h b/hdr/unistd_macros.h
new file mode 100644
index 0000000..132e123
--- /dev/null
+++ b/hdr/unistd_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from unistd.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_UNISTD_MACROS_H
+#define LLVM_LIBC_HDR_UNISTD_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/unistd-macros.h"
+
+#else // Overlay mode
+
+#include <unistd.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_UNISTD_MACROS_H
diff --git a/hdr/wchar_macros.h b/hdr/wchar_macros.h
new file mode 100644
index 0000000..8b90768
--- /dev/null
+++ b/hdr/wchar_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from wchar.h ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_WCHAR_MACROS_H
+#define LLVM_LIBC_HDR_WCHAR_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/wchar-macros.h"
+
+#else // Overlay mode
+
+#include "hdr/wchar_overlay.h"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_WCHAR_MACROS_H
diff --git a/hdr/wchar_overlay.h b/hdr/wchar_overlay.h
new file mode 100644
index 0000000..99a7089
--- /dev/null
+++ b/hdr/wchar_overlay.h
@@ -0,0 +1,69 @@
+//===-- Including wchar.h in overlay mode ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_WCHAR_OVERLAY_H
+#define LLVM_LIBC_HDR_WCHAR_OVERLAY_H
+
+#ifdef LIBC_FULL_BUILD
+#error "This header should only be included in overlay mode"
+#endif
+
+// Overlay mode
+
+// glibc <wchar.h header might provide extern inline definitions for few
+// functions, causing external alias errors.  They are guarded by
+// `__USE_EXTERN_INLINES` macro.  We temporarily disable `__USE_EXTERN_INLINES`
+// macro by defining `__NO_INLINE__` before including <wchar.h>.
+// And the same with `__USE_FORTIFY_LEVEL`, which will be temporarily disabled
+// with `_FORTIFY_SOURCE`.
+
+#ifdef _FORTIFY_SOURCE
+#define LIBC_OLD_FORTIFY_SOURCE _FORTIFY_SOURCE
+#undef _FORTIFY_SOURCE
+#endif
+
+#ifndef __NO_INLINE__
+#define __NO_INLINE__ 1
+#define LIBC_SET_NO_INLINE
+#endif
+
+#ifdef __USE_EXTERN_INLINES
+#define LIBC_OLD_USE_EXTERN_INLINES
+#undef __USE_EXTERN_INLINES
+#endif
+
+#ifdef __USE_FORTIFY_LEVEL
+#define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
+#include <wchar.h>
+
+#ifdef LIBC_OLD_FORTIFY_SOURCE
+#define _FORTIFY_SOURCE LIBC_OLD_FORTIFY_SOURCE
+#undef LIBC_OLD_FORTIFY_SOURCE
+#endif
+
+#ifdef LIBC_SET_NO_INLINE
+#undef __NO_INLINE__
+#undef LIBC_SET_NO_INLINE
+#endif
+
+#ifdef LIBC_OLD_USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
+#undef LIBC_OLD_USE_FORTIFY_LEVEL
+#endif
+
+#ifdef LIBC_OLD_USE_EXTERN_INLINES
+#define __USE_EXTERN_INLINES
+#undef LIBC_OLD_USE_EXTERN_INLINES
+#endif
+
+#endif // LLVM_LIBC_HDR_WCHAR_OVERLAY_H
diff --git a/include/__llvm-libc-common.h b/include/__llvm-libc-common.h
index 3af0b08..e0e29bb 100644
--- a/include/__llvm-libc-common.h
+++ b/include/__llvm-libc-common.h
@@ -17,6 +17,12 @@
 #undef __END_C_DECLS
 #define __END_C_DECLS }
 
+// Standard C++ doesn't have C99 restrict but GNU C++ has it with __ spelling.
+#undef __restrict
+#ifndef __GNUC__
+#define __restrict
+#endif
+
 #undef _Noreturn
 #define _Noreturn [[noreturn]]
 
diff --git a/include/llvm-libc-macros/complex-macros.h b/include/llvm-libc-macros/complex-macros.h
new file mode 100644
index 0000000..427c68d
--- /dev/null
+++ b/include/llvm-libc-macros/complex-macros.h
@@ -0,0 +1,24 @@
+//===-- Definition of macros to be used with complex functions ------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef __LLVM_LIBC_MACROS_COMPLEX_MACROS_H
+#define __LLVM_LIBC_MACROS_COMPLEX_MACROS_H
+
+#ifndef __STDC_NO_COMPLEX__
+
+#define __STDC_VERSION_COMPLEX_H__ 202311L
+
+#define complex _Complex
+#define _Complex_I ((_Complex float)1.0fi)
+#define I _Complex_I
+
+// TODO: Add imaginary macros once GCC or Clang support _Imaginary builtin-type.
+
+#endif
+
+#endif // __LLVM_LIBC_MACROS_COMPLEX_MACROS_H
diff --git a/include/llvm-libc-macros/containerof-macro.h b/include/llvm-libc-macros/containerof-macro.h
index 592acd6..debf441 100644
--- a/include/llvm-libc-macros/containerof-macro.h
+++ b/include/llvm-libc-macros/containerof-macro.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_MACROS_CONTAINEROF_MACRO_H
 #define LLVM_LIBC_MACROS_CONTAINEROF_MACRO_H
 
-#include "llvm-libc-macros/offsetof-macro.h"
+#include "offsetof-macro.h"
 
 #define __containerof(ptr, type, member)                                       \
   ({                                                                           \
diff --git a/include/llvm-libc-macros/dlfcn-macros.h b/include/llvm-libc-macros/dlfcn-macros.h
new file mode 100644
index 0000000..dcd202b
--- /dev/null
+++ b/include/llvm-libc-macros/dlfcn-macros.h
@@ -0,0 +1,23 @@
+//===-- Definition of macros from dlfcn.h ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_DLFCN_MACROS_H
+#define LLVM_LIBC_MACROS_DLFCN_MACROS_H
+
+#define RTLD_LAZY 0x00001
+#define RTLD_NOW 0x00002
+#define RTLD_GLOBAL 0x00100
+#define RTLD_LOCAL 0
+
+// Non-standard stuff here
+#define RTLD_BINDING_MASK 0x3
+#define RTLD_NOLOAD 0x00004
+#define RTLD_DEEPBIND 0x00008
+#define RTLD_NODELETE 0x01000
+
+#endif // LLVM_LIBC_MACROS_DLFCN_MACROS_H
diff --git a/include/llvm-libc-macros/elf-macros.h b/include/llvm-libc-macros/elf-macros.h
new file mode 100644
index 0000000..fa4442a
--- /dev/null
+++ b/include/llvm-libc-macros/elf-macros.h
@@ -0,0 +1,18 @@
+//===-- Definition of macros from elf.h -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_ELF_MACROS_H
+#define LLVM_LIBC_MACROS_ELF_MACROS_H
+
+#if __has_include(<linux/elf.h>)
+#include <linux/elf.h>
+#else
+#error "cannot use <sys/elf.h> without proper system headers."
+#endif
+
+#endif // LLVM_LIBC_MACROS_ELF_MACROS_H
diff --git a/include/llvm-libc-macros/float-macros.h b/include/llvm-libc-macros/float-macros.h
index 81c1df8..a25ef60 100644
--- a/include/llvm-libc-macros/float-macros.h
+++ b/include/llvm-libc-macros/float-macros.h
@@ -161,6 +161,18 @@
 #define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__
 #endif // LDBL_MAX_10_EXP
 
+#ifndef FLT_HAS_SUBNORM
+#define FLT_HAS_SUBNORM __FLT_HAS_DENORM__
+#endif // FLT_HAS_SUBNORM
+
+#ifndef DBL_HAS_SUBNORM
+#define DBL_HAS_SUBNORM __DBL_HAS_DENORM__
+#endif // DBL_HAS_SUBNORM
+
+#ifndef LDBL_HAS_SUBNORM
+#define LDBL_HAS_SUBNORM __LDBL_HAS_DENORM__
+#endif // LDBL_HAS_SUBNORM
+
 // TODO: Add FLT16 and FLT128 constants.
 
 #endif // LLVM_LIBC_MACROS_FLOAT_MACROS_H
diff --git a/include/llvm-libc-macros/float16-macros.h b/include/llvm-libc-macros/float16-macros.h
index e7d8d93..229e3e6 100644
--- a/include/llvm-libc-macros/float16-macros.h
+++ b/include/llvm-libc-macros/float16-macros.h
@@ -9,10 +9,19 @@
 #ifndef LLVM_LIBC_MACROS_FLOAT16_MACROS_H
 #define LLVM_LIBC_MACROS_FLOAT16_MACROS_H
 
+#include "../llvm-libc-types/float128.h"
+
 #if defined(__FLT16_MANT_DIG__) &&                                             \
     (!defined(__GNUC__) || __GNUC__ >= 13 || defined(__clang__)) &&            \
-    !defined(__arm__) && !defined(_M_ARM) && !defined(__riscv)
+    !defined(__arm__) && !defined(_M_ARM) && !defined(__riscv) &&              \
+    !defined(_WIN32)
 #define LIBC_TYPES_HAS_FLOAT16
+
+// TODO: This would no longer be required if HdrGen let us guard function
+// declarations with multiple macros.
+#ifdef LIBC_TYPES_HAS_FLOAT128
+#define LIBC_TYPES_HAS_FLOAT16_AND_FLOAT128
+#endif // LIBC_TYPES_HAS_FLOAT128
 #endif
 
 #endif // LLVM_LIBC_MACROS_FLOAT16_MACROS_H
diff --git a/include/llvm-libc-macros/generic-error-number-macros.h b/include/llvm-libc-macros/generic-error-number-macros.h
index 59b121e..199a862 100644
--- a/include/llvm-libc-macros/generic-error-number-macros.h
+++ b/include/llvm-libc-macros/generic-error-number-macros.h
@@ -43,5 +43,6 @@
 #define EPIPE 32
 #define EDOM 33
 #define ERANGE 34
+#define EILSEQ 84
 
 #endif // LLVM_LIBC_MACROS_GENERIC_ERROR_NUMBER_MACROS_H
diff --git a/include/llvm-libc-macros/gpu/signal-macros.h b/include/llvm-libc-macros/gpu/signal-macros.h
new file mode 100644
index 0000000..2d81592
--- /dev/null
+++ b/include/llvm-libc-macros/gpu/signal-macros.h
@@ -0,0 +1,28 @@
+//===-- Definition of GPU signal number macros ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_GPU_SIGNAL_MACROS_H
+#define LLVM_LIBC_MACROS_GPU_SIGNAL_MACROS_H
+
+#define SIGINT 2
+#define SIGILL 4
+#define SIGABRT 6
+#define SIGFPE 8
+#define SIGSEGV 11
+#define SIGTERM 15
+
+#define SIG_DFL ((__sighandler_t)(0))
+#define SIG_IGN ((__sighandler_t)(1))
+#define SIG_ERR ((__sighandler_t)(-1))
+
+// Max signal number
+#define NSIG 64
+
+#define __NSIGSET_WORDS NSIG
+
+#endif // LLVM_LIBC_MACROS_GPU_SIGNAL_MACROS_H
diff --git a/include/llvm-libc-macros/gpu/time-macros.h b/include/llvm-libc-macros/gpu/time-macros.h
index c3dc812..7142a3e 100644
--- a/include/llvm-libc-macros/gpu/time-macros.h
+++ b/include/llvm-libc-macros/gpu/time-macros.h
@@ -9,6 +9,9 @@
 #ifndef LLVM_LIBC_MACROS_GPU_TIME_MACROS_H
 #define LLVM_LIBC_MACROS_GPU_TIME_MACROS_H
 
+#define CLOCK_REALTIME 0
+#define CLOCK_MONOTONIC 1
+
 #define CLOCKS_PER_SEC 1000000
 
 #endif // LLVM_LIBC_MACROS_GPU_TIME_MACROS_H
diff --git a/include/llvm-libc-macros/limits-macros.h b/include/llvm-libc-macros/limits-macros.h
index 3fab996..d4aa7ae 100644
--- a/include/llvm-libc-macros/limits-macros.h
+++ b/include/llvm-libc-macros/limits-macros.h
@@ -19,12 +19,10 @@
 #endif // __CHAR_BIT__
 #endif // CHAR_BIT
 
-// TODO: https://github.com/llvm/llvm-project/issues/79358
-//   Define MB_LEN_MAX if missing.
-//     clang: MB_LEN_MAX = 1 -
-// https://github.com/llvm/llvm-project/blob/main/clang/lib/Headers/limits.h#L64
-//     glibc: MB_LEN_MAX = 16 -
-// https://github.com/bminor/glibc/blob/master/include/limits.h#L32
+#ifndef MB_LEN_MAX
+// Represents a single UTF-32 wide character in the default locale.
+#define MB_LEN_MAX 4
+#endif // MB_LEN_MAX
 
 // *_WIDTH macros
 
@@ -225,4 +223,16 @@
 #define ULLONG_MIN 0ULL
 #endif // ULLONG_MIN
 
+#ifndef _POSIX_MAX_CANON
+#define _POSIX_MAX_CANON 255
+#endif
+
+#ifndef _POSIX_MAX_INPUT
+#define _POSIX_MAX_INPUT 255
+#endif
+
+#ifndef _POSIX_NAME_MAX
+#define _POSIX_PATH_MAX 256
+#endif
+
 #endif // LLVM_LIBC_MACROS_LIMITS_MACROS_H
diff --git a/include/llvm-libc-macros/link-macros.h b/include/llvm-libc-macros/link-macros.h
new file mode 100644
index 0000000..89e7bb5
--- /dev/null
+++ b/include/llvm-libc-macros/link-macros.h
@@ -0,0 +1,20 @@
+//===-- Definition of macros to for extra dynamic linker functionality ----===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_LINK_MACROS_H
+#define LLVM_LIBC_MACROS_LINK_MACROS_H
+
+#include "elf-macros.h"
+
+#ifdef __LP64__
+#define ElfW(type) Elf64_##type
+#else
+#define ElfW(type) Elf32_##type
+#endif
+
+#endif
diff --git a/include/llvm-libc-macros/linux/error-number-macros.h b/include/llvm-libc-macros/linux/error-number-macros.h
index 1643a70..9a7304f 100644
--- a/include/llvm-libc-macros/linux/error-number-macros.h
+++ b/include/llvm-libc-macros/linux/error-number-macros.h
@@ -21,4 +21,12 @@
 #define EHWPOISON 133
 #endif // EHWPOISON
 
+#ifndef EOPNOTSUPP
+#define EOPNOTSUPP 95
+#endif
+
+#ifndef ENOTSUP
+#define ENOTSUP EOPNOTSUPP
+#endif
+
 #endif // LLVM_LIBC_MACROS_LINUX_ERROR_NUMBER_MACROS_H
diff --git a/include/llvm-libc-macros/linux/fcntl-macros.h b/include/llvm-libc-macros/linux/fcntl-macros.h
index 8ee9586..aec8a0d 100644
--- a/include/llvm-libc-macros/linux/fcntl-macros.h
+++ b/include/llvm-libc-macros/linux/fcntl-macros.h
@@ -88,6 +88,9 @@
 // Close on succesful
 #define F_CLOEXEC 1
 
+// Close on execute for fcntl.
+#define FD_CLOEXEC 1
+
 #define F_RDLCK 0
 #define F_WRLCK 1
 #define F_UNLCK 2
diff --git a/include/llvm-libc-macros/linux/signal-macros.h b/include/llvm-libc-macros/linux/signal-macros.h
index e379fc4..0b7317e 100644
--- a/include/llvm-libc-macros/linux/signal-macros.h
+++ b/include/llvm-libc-macros/linux/signal-macros.h
@@ -76,15 +76,12 @@
 #define SS_ONSTACK 0x1
 #define SS_DISABLE 0x2
 
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__i386__) || defined(__riscv)
 #define MINSIGSTKSZ 2048
 #define SIGSTKSZ 8192
 #elif defined(__aarch64__)
 #define MINSIGSTKSZ 5120
 #define SIGSTKSZ 16384
-#elif defined(__riscv)
-#define MINSIGSTKSZ 2048
-#define SIGSTKSZ 8192
 #else
 #error "Signal stack sizes not defined for your platform."
 #endif
diff --git a/include/llvm-libc-macros/linux/unistd-macros.h b/include/llvm-libc-macros/linux/unistd-macros.h
index c5109df..a4c8e3c 100644
--- a/include/llvm-libc-macros/linux/unistd-macros.h
+++ b/include/llvm-libc-macros/linux/unistd-macros.h
@@ -18,6 +18,33 @@
 #define _SC_PAGESIZE 1
 #define _SC_PAGE_SIZE _SC_PAGESIZE
 
+#define _PC_FILESIZEBITS 0
+#define _PC_LINK_MAX 1
+#define _PC_MAX_CANON 2
+#define _PC_MAX_INPUT 3
+#define _PC_NAME_MAX 4
+#define _PC_PATH_MAX 5
+#define _PC_PIPE_BUF 6
+#define _PC_2_SYMLINKS 7
+#define _PC_ALLOC_SIZE_MIN 8
+#define _PC_REC_INCR_XFER_SIZE 9
+#define _PC_REC_MAX_XFER_SIZE 10
+#define _PC_REC_MIN_XFER_SIZE 11
+#define _PC_REC_XFER_ALIGN 12
+#define _PC_SYMLINK_MAX 13
+#define _PC_CHOWN_RESTRICTED 14
+#define _PC_NO_TRUNC 15
+#define _PC_VDISABLE 16
+#define _PC_ASYNC_IO 17
+#define _PC_PRIO_IO 18
+#define _PC_SYNC_IO 19
+
+// TODO: Move these limit macros to a separate file
+#define _POSIX_CHOWN_RESTRICTED 1
+#define _POSIX_PIPE_BUF 512
+#define _POSIX_NO_TRUNC 1
+#define _POSIX_VDISABLE '\0'
+
 // Macro to set up the call to the __llvm_libc_syscall function
 // This is to prevent the call from having fewer than 6 arguments, since six
 // arguments are always passed to the syscall. Unnecessary arguments are
diff --git a/include/llvm-libc-macros/locale-macros.h b/include/llvm-libc-macros/locale-macros.h
new file mode 100644
index 0000000..892f8b6
--- /dev/null
+++ b/include/llvm-libc-macros/locale-macros.h
@@ -0,0 +1,32 @@
+//===-- Definition of macros from locale.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_LOCALE_MACROS_H
+#define LLVM_LIBC_MACROS_LOCALE_MACROS_H
+
+#include "../llvm-libc-types/locale_t.h"
+
+#define LC_CTYPE 0
+#define LC_NUMERIC 1
+#define LC_TIME 2
+#define LC_COLLATE 3
+#define LC_MONETARY 4
+#define LC_MESSAGES 5
+#define LC_ALL 6
+
+#define LC_GLOBAL_LOCALE ((locale_t)(-1))
+
+#define LC_CTYPE_MASK (1 << LC_CTYPE)
+#define LC_NUMERIC_MASK (1 << LC_NUMERIC)
+#define LC_TIME_MASK (1 << LC_TIME)
+#define LC_COLLATE_MASK (1 << LC_COLLATE)
+#define LC_MONETARY_MASK (1 << LC_MONETARY)
+#define LC_MESSAGES_MASK (1 << LC_MESSAGES)
+#define LC_ALL_MASK 0x7fffffff
+
+#endif // LLVM_LIBC_MACROS_LOCALE_MACROS_H
diff --git a/include/llvm-libc-macros/malloc-macros.h b/include/llvm-libc-macros/malloc-macros.h
new file mode 100644
index 0000000..65eddfc
--- /dev/null
+++ b/include/llvm-libc-macros/malloc-macros.h
@@ -0,0 +1,17 @@
+//===-- Definition of macros to be used with malloc functions -------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_MALLOC_MACROS_H
+#define LLVM_LIBC_MACROS_MALLOC_MACROS_H
+
+// Note: these values only make sense when Scudo is used as the memory
+// allocator.
+#define M_PURGE (-101)
+#define M_PURGE_ALL (-104)
+
+#endif // LLVM_LIBC_MACROS_MALLOC_MACROS_H
diff --git a/include/llvm-libc-macros/math-function-macros.h b/include/llvm-libc-macros/math-function-macros.h
new file mode 100644
index 0000000..21d09f1
--- /dev/null
+++ b/include/llvm-libc-macros/math-function-macros.h
@@ -0,0 +1,37 @@
+//===-- Definition of function macros from math.h -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_MATH_FUNCTION_MACROS_H
+#define LLVM_LIBC_MACROS_MATH_FUNCTION_MACROS_H
+
+#include "math-macros.h"
+
+#ifndef __cplusplus
+#define issignaling(x)                                                         \
+  _Generic((x),                                                                \
+      float: issignalingf,                                                     \
+      double: issignaling,                                                     \
+      long double: issignalingl)(x)
+#define iscanonical(x)                                                         \
+  _Generic((x),                                                                \
+      float: iscanonicalf,                                                     \
+      double: iscanonical,                                                     \
+      long double: iscanonicall)(x)
+#endif
+
+#define isfinite(x) __builtin_isfinite(x)
+#define isinf(x) __builtin_isinf(x)
+#define isnan(x) __builtin_isnan(x)
+#define signbit(x) __builtin_signbit(x)
+#define iszero(x) (x == 0)
+#define fpclassify(x)                                                          \
+  __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)
+#define isnormal(x) __builtin_isnormal(x)
+#define issubnormal(x) (fpclassify(x) == FP_SUBNORMAL)
+
+#endif // LLVM_LIBC_MACROS_MATH_FUNCTION_MACROS_H
diff --git a/include/llvm-libc-macros/math-macros.h b/include/llvm-libc-macros/math-macros.h
index 4783896..2f05d75 100644
--- a/include/llvm-libc-macros/math-macros.h
+++ b/include/llvm-libc-macros/math-macros.h
@@ -27,7 +27,8 @@
 #define MATH_ERREXCEPT 2
 
 #define HUGE_VAL __builtin_huge_val()
-#define INFINITY __builtin_inf()
+#define HUGE_VALF __builtin_huge_valf()
+#define INFINITY __builtin_inff()
 #define NAN __builtin_nanf("")
 
 #define FP_ILOGB0 (-INT_MAX - 1)
@@ -41,19 +42,12 @@
 #define FP_LLOGBNAN LONG_MAX
 #endif
 
-#ifdef __FAST_MATH__
+#if defined(__NVPTX__) || defined(__AMDGPU__) || defined(__FAST_MATH__)
 #define math_errhandling 0
 #elif defined(__NO_MATH_ERRNO__)
 #define math_errhandling (MATH_ERREXCEPT)
-#elif defined(__NVPTX__) || defined(__AMDGPU__)
-#define math_errhandling (MATH_ERRNO)
 #else
 #define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)
 #endif
 
-// TODO: Move generic functional math macros to a separate header file.
-#define isfinite(x) __builtin_isfinite(x)
-#define isinf(x) __builtin_isinf(x)
-#define isnan(x) __builtin_isnan(x)
-
 #endif // LLVM_LIBC_MACROS_MATH_MACROS_H
diff --git a/include/llvm-libc-macros/signal-macros.h b/include/llvm-libc-macros/signal-macros.h
index 7ab605b..fbe929a 100644
--- a/include/llvm-libc-macros/signal-macros.h
+++ b/include/llvm-libc-macros/signal-macros.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_MACROS_SIGNAL_MACROS_H
 #define LLVM_LIBC_MACROS_SIGNAL_MACROS_H
 
-#ifdef __linux__
+#if defined(__linux__)
 #include "linux/signal-macros.h"
+#elif defined(__NVPTX__) || defined(__AMDGPU__)
+#include "gpu/signal-macros.h"
 #endif
 
 #endif // LLVM_LIBC_MACROS_SIGNAL_MACROS_H
diff --git a/include/llvm-libc-macros/stdckdint-macros.h b/include/llvm-libc-macros/stdckdint-macros.h
index 6944122..17e4ccd 100644
--- a/include/llvm-libc-macros/stdckdint-macros.h
+++ b/include/llvm-libc-macros/stdckdint-macros.h
@@ -10,8 +10,10 @@
 #define LLVM_LIBC_MACROS_STDCKDINT_MACROS_H
 
 // We need to use __builtin_*_overflow from GCC/Clang to implement the overflow
-// macros. Check __GNUC__ for availability of such builtins.
-#ifdef __GNUC__
+// macros. Check __GNUC__ or __clang__ for availability of such builtins.
+// Note that clang-cl defines __clang__ only and does not define __GNUC__ so we
+// have to check for both.
+#if defined(__GNUC__) || defined(__clang__)
 // clang/gcc overlay may provides similar macros, we need to avoid redefining
 // them.
 #ifndef __STDC_VERSION_STDCKDINT_H__
diff --git a/include/llvm-libc-macros/stdio-macros.h b/include/llvm-libc-macros/stdio-macros.h
index 4664801..96f0e69 100644
--- a/include/llvm-libc-macros/stdio-macros.h
+++ b/include/llvm-libc-macros/stdio-macros.h
@@ -9,10 +9,50 @@
 #ifndef LLVM_LIBC_MACROS_STDIO_MACROS_H
 #define LLVM_LIBC_MACROS_STDIO_MACROS_H
 
+#include "../llvm-libc-types/FILE.h"
+
+#ifdef __cplusplus
+extern "C" FILE *stdin;
+extern "C" FILE *stdout;
+extern "C" FILE *stderr;
+#else
+extern FILE *stdin;
+extern FILE *stdout;
+extern FILE *stderr;
+#endif
+
+#ifndef stdin
+#define stdin stdin
+#endif
+
+#ifndef stdout
+#define stdout stdout
+#endif
+
+#ifndef stderr
+#define stderr stderr
+#endif
+
 #ifndef EOF
 #define EOF (-1)
 #endif
 
 #define BUFSIZ 1024
 
+#define _IONBF 2
+#define _IOLBF 1
+#define _IOFBF 0
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif
+
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif
+
+#ifndef SEEK_END
+#define SEEK_END 2
+#endif
+
 #endif // LLVM_LIBC_MACROS_STDIO_MACROS_H
diff --git a/include/llvm-libc-macros/stdlib-macros.h b/include/llvm-libc-macros/stdlib-macros.h
index 5fcbfef..2565c76 100644
--- a/include/llvm-libc-macros/stdlib-macros.h
+++ b/include/llvm-libc-macros/stdlib-macros.h
@@ -17,6 +17,11 @@
 #define EXIT_SUCCESS 0
 #define EXIT_FAILURE 1
 
+#ifndef MB_CUR_MAX
+// We only support the "C" locale right now, so this is a constant byte.
+#define MB_CUR_MAX 1
+#endif // MB_CUR_MAX
+
 #define RAND_MAX 2147483647
 
 #endif // LLVM_LIBC_MACROS_STDLIB_MACROS_H
diff --git a/include/llvm-libc-macros/sys-queue-macros.h b/include/llvm-libc-macros/sys-queue-macros.h
index 089b6ab..21e80f4 100644
--- a/include/llvm-libc-macros/sys-queue-macros.h
+++ b/include/llvm-libc-macros/sys-queue-macros.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_MACROS_SYS_QUEUE_MACROS_H
 #define LLVM_LIBC_MACROS_SYS_QUEUE_MACROS_H
 
-#include "llvm-libc-macros/containerof-macro.h"
-#include "llvm-libc-macros/null-macro.h"
+#include "containerof-macro.h"
+#include "null-macro.h"
 
 #ifdef __cplusplus
 #define QUEUE_TYPEOF(type) type
diff --git a/include/llvm-libc-types/__lsearchcompare_t.h b/include/llvm-libc-types/__lsearchcompare_t.h
new file mode 100644
index 0000000..08dc2db
--- /dev/null
+++ b/include/llvm-libc-types/__lsearchcompare_t.h
@@ -0,0 +1,14 @@
+//===-- Definition of type __lsearchcompare_t -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES___LSEARCHCOMPARE_T_H
+#define LLVM_LIBC_TYPES___LSEARCHCOMPARE_T_H
+
+typedef int (*__lsearchcompare_t)(const void *, const void *);
+
+#endif // LLVM_LIBC_TYPES___LSEARCHCOMPARE_T_H
diff --git a/include/llvm-libc-types/__mutex_type.h b/include/llvm-libc-types/__mutex_type.h
index 3779c78..8355616 100644
--- a/include/llvm-libc-types/__mutex_type.h
+++ b/include/llvm-libc-types/__mutex_type.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES___MUTEX_TYPE_H
 #define LLVM_LIBC_TYPES___MUTEX_TYPE_H
 
-#include "llvm-libc-types/__futex_word.h"
+#include "__futex_word.h"
 
 typedef struct {
   unsigned char __timed;
diff --git a/include/llvm-libc-types/cfloat128.h b/include/llvm-libc-types/cfloat128.h
new file mode 100644
index 0000000..a371671
--- /dev/null
+++ b/include/llvm-libc-types/cfloat128.h
@@ -0,0 +1,41 @@
+//===-- Definition of cfloat128 type --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_CFLOAT128_H
+#define LLVM_LIBC_TYPES_CFLOAT128_H
+
+#include "../llvm-libc-macros/float-macros.h" // LDBL_MANT_DIG
+
+// Currently, the complex variant of C23 `_Float128` type is only defined as a
+// built-in type in GCC 7 or later, for C and in GCC 13 or later, for C++. For
+// clang, the complex variant of `__float128` is defined instead, and only on
+// x86-64 targets for clang 11 or later.
+//
+// TODO: Update the complex variant of C23 `_Float128` type detection again when
+// clang supports it.
+#if defined(__STDC_IEC_60559_COMPLEX__) && !defined(__clang__)
+#if !defined(__cplusplus)
+#define LIBC_TYPES_HAS_CFLOAT128
+typedef _Complex _Float128 cfloat128;
+#elif defined(__GNUC__) && __GNUC__ >= 13
+#define LIBC_TYPES_HAS_CFLOAT128
+typedef _Complex _Float128 cfloat128;
+#endif
+#elif __clang_major__ >= 11 &&                                                 \
+    (defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__))
+// Use _Complex __float128 type. clang uses __SIZEOF_FLOAT128__ or __FLOAT128__
+// macro to notify the availability of __float128 type:
+// https://reviews.llvm.org/D15120
+#define LIBC_TYPES_HAS_CFLOAT128
+typedef _Complex __float128 cfloat128;
+#elif (LDBL_MANT_DIG == 113)
+#define LIBC_TYPES_HAS_CFLOAT128
+typedef _Complex long double cfloat128;
+#endif
+
+#endif // LLVM_LIBC_TYPES_CFLOAT128_H
diff --git a/include/llvm-libc-types/cfloat16.h b/include/llvm-libc-types/cfloat16.h
new file mode 100644
index 0000000..2d4cef7
--- /dev/null
+++ b/include/llvm-libc-types/cfloat16.h
@@ -0,0 +1,21 @@
+//===-- Definition of cfloat16 type ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_CFLOAT16_H
+#define LLVM_LIBC_TYPES_CFLOAT16_H
+
+#if defined(__FLT16_MANT_DIG__) &&                                             \
+    (!defined(__GNUC__) || __GNUC__ >= 13 ||                                   \
+     (defined(__clang__) && __clang_major__ >= 14)) &&                         \
+    !defined(__arm__) && !defined(_M_ARM) && !defined(__riscv) &&              \
+    !defined(_WIN32)
+#define LIBC_TYPES_HAS_CFLOAT16
+typedef _Complex _Float16 cfloat16;
+#endif
+
+#endif // LLVM_LIBC_TYPES_CFLOAT16_H
diff --git a/include/llvm-libc-types/cnd_t.h b/include/llvm-libc-types/cnd_t.h
index 266dfbb..77ec583 100644
--- a/include/llvm-libc-types/cnd_t.h
+++ b/include/llvm-libc-types/cnd_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_CND_T_H
 #define LLVM_LIBC_TYPES_CND_T_H
 
-#include "llvm-libc-types/__futex_word.h"
+#include "__futex_word.h"
 
 typedef struct {
   void *__qfront;
diff --git a/include/llvm-libc-types/cookie_io_functions_t.h b/include/llvm-libc-types/cookie_io_functions_t.h
index a3e7c32..d1eea8f 100644
--- a/include/llvm-libc-types/cookie_io_functions_t.h
+++ b/include/llvm-libc-types/cookie_io_functions_t.h
@@ -9,9 +9,9 @@
 #ifndef LLVM_LIBC_TYPES_COOKIE_IO_FUNCTIONS_T_H
 #define LLVM_LIBC_TYPES_COOKIE_IO_FUNCTIONS_T_H
 
-#include "llvm-libc-types/off64_t.h"
-#include "llvm-libc-types/size_t.h"
-#include "llvm-libc-types/ssize_t.h"
+#include "off64_t.h"
+#include "size_t.h"
+#include "ssize_t.h"
 
 typedef ssize_t cookie_read_function_t(void *, char *, size_t);
 typedef ssize_t cookie_write_function_t(void *, const char *, size_t);
diff --git a/include/llvm-libc-types/fd_set.h b/include/llvm-libc-types/fd_set.h
index fd1bde2..52b7161 100644
--- a/include/llvm-libc-types/fd_set.h
+++ b/include/llvm-libc-types/fd_set.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_FD_SET_H
 #define LLVM_LIBC_TYPES_FD_SET_H
 
-#include "llvm-libc-macros/sys-select-macros.h" // FD_SETSIZE
+#include "../llvm-libc-macros/sys-select-macros.h" // __FD_SET_WORD_TYPE, __FD_SET_ARRAYSIZE
 
 typedef struct {
   __FD_SET_WORD_TYPE __set[__FD_SET_ARRAYSIZE];
diff --git a/include/llvm-libc-types/fexcept_t.h b/include/llvm-libc-types/fexcept_t.h
index 60687bd..5aa09fb 100644
--- a/include/llvm-libc-types/fexcept_t.h
+++ b/include/llvm-libc-types/fexcept_t.h
@@ -9,6 +9,10 @@
 #ifndef LLVM_LIBC_TYPES_FEXCEPT_T_H
 #define LLVM_LIBC_TYPES_FEXCEPT_T_H
 
-typedef int fexcept_t;
+#if defined(__x86_64__) || defined(__i386__)
+typedef unsigned short int fexcept_t;
+#else
+typedef unsigned int fexcept_t;
+#endif
 
 #endif // LLVM_LIBC_TYPES_FEXCEPT_T_H
diff --git a/include/llvm-libc-types/fsblkcnt_t.h b/include/llvm-libc-types/fsblkcnt_t.h
index 88a53d3..8c7d330 100644
--- a/include/llvm-libc-types/fsblkcnt_t.h
+++ b/include/llvm-libc-types/fsblkcnt_t.h
@@ -9,6 +9,6 @@
 #ifndef LLVM_LIBC_TYPES_FSBLKCNT_T_H
 #define LLVM_LIBC_TYPES_FSBLKCNT_T_H
 
-typedef __SIZE_TYPE__ fsblkcnt_t;
+typedef __UINT64_TYPE__ fsblkcnt_t;
 
 #endif // LLVM_LIBC_TYPES_FSBLKCNT_T_H
diff --git a/include/llvm-libc-types/fsfilcnt_t.h b/include/llvm-libc-types/fsfilcnt_t.h
index c569359..1269783 100644
--- a/include/llvm-libc-types/fsfilcnt_t.h
+++ b/include/llvm-libc-types/fsfilcnt_t.h
@@ -9,6 +9,6 @@
 #ifndef LLVM_LIBC_TYPES_FSFILCNT_T_H
 #define LLVM_LIBC_TYPES_FSFILCNT_T_H
 
-typedef __SIZE_TYPE__ fsfilcnt_t;
+typedef __UINT64_TYPE__ fsfilcnt_t;
 
 #endif // LLVM_LIBC_TYPES_FSFILCNT_T_H
diff --git a/include/llvm-libc-types/jmp_buf.h b/include/llvm-libc-types/jmp_buf.h
index 8949be9..f246e64 100644
--- a/include/llvm-libc-types/jmp_buf.h
+++ b/include/llvm-libc-types/jmp_buf.h
@@ -19,6 +19,13 @@ typedef struct {
   __UINT64_TYPE__ r15;
   __UINTPTR_TYPE__ rsp;
   __UINTPTR_TYPE__ rip;
+#elif defined(__i386__)
+  long ebx;
+  long esi;
+  long edi;
+  long ebp;
+  long esp;
+  long eip;
 #elif defined(__riscv)
   /* Program counter.  */
   long int __pc;
@@ -35,6 +42,11 @@ typedef struct {
 #elif defined(__arm__)
   // r4, r5, r6, r7, r8, r9, r10, r11, r12, lr
   long opaque[10];
+#elif defined(__aarch64__)
+  long opaque[14]; // x19-x29, lr, sp, optional x18
+#if __ARM_FP
+  long fopaque[8]; // d8-d15
+#endif
 #else
 #error "__jmp_buf not available for your target architecture."
 #endif
diff --git a/include/llvm-libc-types/locale_t.h b/include/llvm-libc-types/locale_t.h
new file mode 100644
index 0000000..6d78300
--- /dev/null
+++ b/include/llvm-libc-types/locale_t.h
@@ -0,0 +1,22 @@
+//===-- Definition of type locale_t ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_LOCALE_T_H
+#define LLVM_LIBC_TYPES_LOCALE_T_H
+
+#define NUM_LOCALE_CATEGORIES 6
+
+struct __locale_data;
+
+struct __locale_t {
+  struct __locale_data *data[NUM_LOCALE_CATEGORIES];
+};
+
+typedef struct __locale_t *locale_t;
+
+#endif // LLVM_LIBC_TYPES_LOCALE_T_H
diff --git a/include/llvm-libc-types/mtx_t.h b/include/llvm-libc-types/mtx_t.h
index ebf7987..56e41bd 100644
--- a/include/llvm-libc-types/mtx_t.h
+++ b/include/llvm-libc-types/mtx_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_MTX_T_H
 #define LLVM_LIBC_TYPES_MTX_T_H
 
-#include "llvm-libc-types/__mutex_type.h"
+#include "__mutex_type.h"
 
 typedef __mutex_type mtx_t;
 
diff --git a/include/llvm-libc-types/once_flag.h b/include/llvm-libc-types/once_flag.h
index f80d35e..b3b7e0d 100644
--- a/include/llvm-libc-types/once_flag.h
+++ b/include/llvm-libc-types/once_flag.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_ONCE_FLAG_H
 #define LLVM_LIBC_TYPES_ONCE_FLAG_H
 
-#include "llvm-libc-types/__futex_word.h"
+#include "__futex_word.h"
 
 #ifdef __linux__
 typedef __futex_word once_flag;
diff --git a/include/llvm-libc-types/pthread_attr_t.h b/include/llvm-libc-types/pthread_attr_t.h
index 7512193..e686ac9 100644
--- a/include/llvm-libc-types/pthread_attr_t.h
+++ b/include/llvm-libc-types/pthread_attr_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_PTHREAD_ATTR_T_H
 #define LLVM_LIBC_TYPES_PTHREAD_ATTR_T_H
 
-#include "llvm-libc-types/size_t.h"
+#include "size_t.h"
 
 typedef struct {
   int __detachstate;
diff --git a/include/llvm-libc-types/pthread_mutex_t.h b/include/llvm-libc-types/pthread_mutex_t.h
index cf2194d..1535cba 100644
--- a/include/llvm-libc-types/pthread_mutex_t.h
+++ b/include/llvm-libc-types/pthread_mutex_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_PTHREAD_MUTEX_T_H
 #define LLVM_LIBC_TYPES_PTHREAD_MUTEX_T_H
 
-#include "llvm-libc-types/__mutex_type.h"
+#include "__mutex_type.h"
 
 typedef __mutex_type pthread_mutex_t;
 
diff --git a/include/llvm-libc-types/pthread_once_t.h b/include/llvm-libc-types/pthread_once_t.h
index 8ea926f..12a8150 100644
--- a/include/llvm-libc-types/pthread_once_t.h
+++ b/include/llvm-libc-types/pthread_once_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_PTHREAD_ONCE_T_H
 #define LLVM_LIBC_TYPES_PTHREAD_ONCE_T_H
 
-#include "llvm-libc-types/__futex_word.h"
+#include "__futex_word.h"
 
 #ifdef __linux__
 typedef __futex_word pthread_once_t;
diff --git a/include/llvm-libc-types/pthread_rwlock_t.h b/include/llvm-libc-types/pthread_rwlock_t.h
index da49a15..4a7c6c7 100644
--- a/include/llvm-libc-types/pthread_rwlock_t.h
+++ b/include/llvm-libc-types/pthread_rwlock_t.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_PTHREAD_RWLOCK_T_H
 #define LLVM_LIBC_TYPES_PTHREAD_RWLOCK_T_H
 
-#include "llvm-libc-types/__futex_word.h"
-#include "llvm-libc-types/pid_t.h"
+#include "__futex_word.h"
+#include "pid_t.h"
 typedef struct {
   unsigned __is_pshared : 1;
   unsigned __preference : 1;
diff --git a/include/llvm-libc-types/pthread_spinlock_t.h b/include/llvm-libc-types/pthread_spinlock_t.h
new file mode 100644
index 0000000..afb4fe9
--- /dev/null
+++ b/include/llvm-libc-types/pthread_spinlock_t.h
@@ -0,0 +1,17 @@
+//===-- Definition of pthread_spinlock_t type -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_PTHREAD_SPINLOCK_T_H
+#define LLVM_LIBC_TYPES_PTHREAD_SPINLOCK_T_H
+#include "pid_t.h"
+typedef struct {
+  unsigned char __lockword;
+  pid_t __owner;
+} pthread_spinlock_t;
+
+#endif // LLVM_LIBC_TYPES_PTHREAD_SPINLOCK_T_H
diff --git a/include/llvm-libc-types/pthread_t.h b/include/llvm-libc-types/pthread_t.h
index 63cc0d7..f64887b 100644
--- a/include/llvm-libc-types/pthread_t.h
+++ b/include/llvm-libc-types/pthread_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_PTHREAD_T_H
 #define LLVM_LIBC_TYPES_PTHREAD_T_H
 
-#include "llvm-libc-types/__thread_type.h"
+#include "__thread_type.h"
 
 typedef __thread_type pthread_t;
 
diff --git a/include/llvm-libc-types/rpc_opcodes_t.h b/include/llvm-libc-types/rpc_opcodes_t.h
deleted file mode 100644
index faed7b5..0000000
--- a/include/llvm-libc-types/rpc_opcodes_t.h
+++ /dev/null
@@ -1,40 +0,0 @@
-//===-- Definition of RPC opcodes -----------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_TYPES_RPC_OPCODES_T_H
-#define LLVM_LIBC_TYPES_RPC_OPCODES_T_H
-
-typedef enum {
-  RPC_NOOP = 0,
-  RPC_EXIT,
-  RPC_WRITE_TO_STDOUT,
-  RPC_WRITE_TO_STDERR,
-  RPC_WRITE_TO_STREAM,
-  RPC_WRITE_TO_STDOUT_NEWLINE,
-  RPC_READ_FROM_STREAM,
-  RPC_READ_FGETS,
-  RPC_OPEN_FILE,
-  RPC_CLOSE_FILE,
-  RPC_MALLOC,
-  RPC_FREE,
-  RPC_HOST_CALL,
-  RPC_ABORT,
-  RPC_FEOF,
-  RPC_FERROR,
-  RPC_CLEARERR,
-  RPC_FSEEK,
-  RPC_FTELL,
-  RPC_FFLUSH,
-  RPC_UNGETC,
-  RPC_PRINTF_TO_STDOUT,
-  RPC_PRINTF_TO_STDERR,
-  RPC_PRINTF_TO_STREAM,
-  RPC_LAST = 0xFFFF,
-} rpc_opcode_t;
-
-#endif // LLVM_LIBC_TYPES_RPC_OPCODES_T_H
diff --git a/include/llvm-libc-types/siginfo_t.h b/include/llvm-libc-types/siginfo_t.h
index dafe9c1..20fdd46 100644
--- a/include/llvm-libc-types/siginfo_t.h
+++ b/include/llvm-libc-types/siginfo_t.h
@@ -9,10 +9,10 @@
 #ifndef LLVM_LIBC_TYPES_SIGINFO_T_H
 #define LLVM_LIBC_TYPES_SIGINFO_T_H
 
-#include "llvm-libc-types/clock_t.h"
-#include "llvm-libc-types/pid_t.h"
-#include "llvm-libc-types/uid_t.h"
-#include "llvm-libc-types/union_sigval.h"
+#include "clock_t.h"
+#include "pid_t.h"
+#include "uid_t.h"
+#include "union_sigval.h"
 
 #define SI_MAX_SIZE 128
 
diff --git a/include/llvm-libc-types/sigset_t.h b/include/llvm-libc-types/sigset_t.h
index 5c3e4e6..1f60148 100644
--- a/include/llvm-libc-types/sigset_t.h
+++ b/include/llvm-libc-types/sigset_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_SIGSET_T_H
 #define LLVM_LIBC_TYPES_SIGSET_T_H
 
-#include "llvm-libc-macros/signal-macros.h"
+#include "../llvm-libc-macros/signal-macros.h" // __NSIGSET_WORDS
 
 // This definition can be adjusted/specialized for different targets and
 // platforms as necessary. This definition works for Linux on most targets.
diff --git a/include/llvm-libc-types/stack_t.h b/include/llvm-libc-types/stack_t.h
index 9156425..92d0305 100644
--- a/include/llvm-libc-types/stack_t.h
+++ b/include/llvm-libc-types/stack_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STACK_T_H
 #define LLVM_LIBC_TYPES_STACK_T_H
 
-#include "llvm-libc-types/size_t.h"
+#include "size_t.h"
 
 typedef struct {
   // The order of the fields declared here should match the kernel definition
diff --git a/include/llvm-libc-types/stdfix-types.h b/include/llvm-libc-types/stdfix-types.h
new file mode 100644
index 0000000..542d45e
--- /dev/null
+++ b/include/llvm-libc-types/stdfix-types.h
@@ -0,0 +1,25 @@
+//===-- Definition of stdfix integer types --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_STDFIX_TYPES_H
+#define LLVM_LIBC_TYPES_STDFIX_TYPES_H
+
+typedef signed char int_hr_t;
+typedef signed short int int_r_t;
+typedef signed int int_lr_t;
+typedef signed short int_hk_t;
+typedef signed int int_k_t;
+typedef signed long long int_lk_t;
+typedef unsigned char uint_uhr_t;
+typedef unsigned short int uint_ur_t;
+typedef unsigned int uint_ulr_t;
+typedef unsigned short int uint_uhk_t;
+typedef unsigned int uint_uk_t;
+typedef unsigned long long uint_ulk_t;
+
+#endif // LLVM_LIBC_TYPES_STDFIX_TYPES_H
diff --git a/include/llvm-libc-types/struct_dirent.h b/include/llvm-libc-types/struct_dirent.h
index 0bb71b9..f950869 100644
--- a/include/llvm-libc-types/struct_dirent.h
+++ b/include/llvm-libc-types/struct_dirent.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_DIRENT_H
 #define LLVM_LIBC_TYPES_STRUCT_DIRENT_H
 
-#include "llvm-libc-types/ino_t.h"
-#include "llvm-libc-types/off_t.h"
+#include "ino_t.h"
+#include "off_t.h"
 
 struct dirent {
   ino_t d_ino;
diff --git a/include/llvm-libc-types/struct_epoll_event.h b/include/llvm-libc-types/struct_epoll_event.h
index b7685df..f95fd1a 100644
--- a/include/llvm-libc-types/struct_epoll_event.h
+++ b/include/llvm-libc-types/struct_epoll_event.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_EPOLL_EVENT_H
 #define LLVM_LIBC_TYPES_STRUCT_EPOLL_EVENT_H
 
-#include "llvm-libc-types/struct_epoll_data.h"
+#include "struct_epoll_data.h"
 
 typedef struct
 #ifdef __x86_64__
diff --git a/include/llvm-libc-types/struct_f_owner_ex.h b/include/llvm-libc-types/struct_f_owner_ex.h
index c9cc85f..87d4b89 100644
--- a/include/llvm-libc-types/struct_f_owner_ex.h
+++ b/include/llvm-libc-types/struct_f_owner_ex.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_F_OWNER_EX_H
 #define LLVM_LIBC_TYPES_STRUCT_F_OWNER_EX_H
 
-#include "llvm-libc-types/pid_t.h"
+#include "pid_t.h"
 
 enum pid_type {
   F_OWNER_TID = 0,
diff --git a/include/llvm-libc-types/struct_flock.h b/include/llvm-libc-types/struct_flock.h
index 51c9d27..d4bde09 100644
--- a/include/llvm-libc-types/struct_flock.h
+++ b/include/llvm-libc-types/struct_flock.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_FLOCK_H
 #define LLVM_LIBC_TYPES_STRUCT_FLOCK_H
 
-#include "llvm-libc-types/off_t.h"
-#include "llvm-libc-types/pid_t.h"
+#include "off_t.h"
+#include "pid_t.h"
 
 #include <stdint.h>
 
diff --git a/include/llvm-libc-types/struct_flock64.h b/include/llvm-libc-types/struct_flock64.h
index ac50003..8e485d7 100644
--- a/include/llvm-libc-types/struct_flock64.h
+++ b/include/llvm-libc-types/struct_flock64.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_FLOCK64_H
 #define LLVM_LIBC_TYPES_STRUCT_FLOCK64_H
 
-#include "llvm-libc-types/off64_t.h"
-#include "llvm-libc-types/pid_t.h"
+#include "off64_t.h"
+#include "pid_t.h"
 
 #include <stdint.h>
 
diff --git a/include/llvm-libc-types/struct_iovec.h b/include/llvm-libc-types/struct_iovec.h
new file mode 100644
index 0000000..db2ca64
--- /dev/null
+++ b/include/llvm-libc-types/struct_iovec.h
@@ -0,0 +1,19 @@
+//===-- Definition of struct iovec ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_STRUCT_IOVEC_H
+#define LLVM_LIBC_TYPES_STRUCT_IOVEC_H
+
+#include "size_t.h"
+
+struct iovec {
+  void *iov_base;
+  size_t iov_len;
+};
+
+#endif // LLVM_LIBC_TYPES_STRUCT_IOVEC_H
diff --git a/include/llvm-libc-types/struct_lconv.h b/include/llvm-libc-types/struct_lconv.h
new file mode 100644
index 0000000..9d69f05
--- /dev/null
+++ b/include/llvm-libc-types/struct_lconv.h
@@ -0,0 +1,39 @@
+//===-- Definition of type lconv ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_LCONV_H
+#define LLVM_LIBC_TYPES_LCONV_H
+
+struct lconv {
+  char *decimal_point;
+  char *thousands_sep;
+  char *grouping;
+  char *mon_decimal_point;
+  char *mon_thousands_sep;
+  char *mon_grouping;
+  char *positive_sign;
+  char *negative_sign;
+  char *currency_symbol;
+  char frac_digits;
+  char p_cs_precedes;
+  char n_cs_precedes;
+  char p_sep_by_space;
+  char n_sep_by_space;
+  char p_sign_posn;
+  char n_sign_posn;
+  char *int_curr_symbol;
+  char int_frac_digits;
+  char int_p_cs_precedes;
+  char int_n_cs_precedes;
+  char int_p_sep_by_space;
+  char int_n_sep_by_space;
+  char int_p_sign_posn;
+  char int_n_sign_posn;
+};
+
+#endif // LLVM_LIBC_TYPES_LCONV_H
diff --git a/include/llvm-libc-types/struct_msghdr.h b/include/llvm-libc-types/struct_msghdr.h
new file mode 100644
index 0000000..7933de1
--- /dev/null
+++ b/include/llvm-libc-types/struct_msghdr.h
@@ -0,0 +1,26 @@
+//===-- Definition of struct msghdr ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_STRUCT_MSGHDR_H
+#define LLVM_LIBC_TYPES_STRUCT_MSGHDR_H
+
+#include "size_t.h"
+#include "socklen_t.h"
+#include "struct_iovec.h"
+
+struct msghdr {
+  void *msg_name;        /* Optional address */
+  socklen_t msg_namelen; /* Size of address */
+  struct iovec *msg_iov; /* Scatter/gather array */
+  size_t msg_iovlen;     /* # elements in msg_iov */
+  void *msg_control;     /* Ancillary data, see below */
+  size_t msg_controllen; /* Ancillary data buffer len */
+  int msg_flags;         /* Flags (unused) */
+};
+
+#endif // LLVM_LIBC_TYPES_STRUCT_MSGHDR_H
diff --git a/include/llvm-libc-types/struct_rlimit.h b/include/llvm-libc-types/struct_rlimit.h
index 11e6bee..15d8c0e 100644
--- a/include/llvm-libc-types/struct_rlimit.h
+++ b/include/llvm-libc-types/struct_rlimit.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_RLIMIT_H
 #define LLVM_LIBC_TYPES_STRUCT_RLIMIT_H
 
-#include "llvm-libc-types/rlim_t.h"
+#include "rlim_t.h"
 
 struct rlimit {
   rlim_t rlim_cur;
diff --git a/include/llvm-libc-types/struct_rusage.h b/include/llvm-libc-types/struct_rusage.h
index ed838d3..59fe9f7 100644
--- a/include/llvm-libc-types/struct_rusage.h
+++ b/include/llvm-libc-types/struct_rusage.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_RUSAGE_H
 #define LLVM_LIBC_TYPES_STRUCT_RUSAGE_H
 
-#include "llvm-libc-types/struct_timeval.h"
+#include "struct_timeval.h"
 
 struct rusage {
   struct timeval ru_utime;
diff --git a/include/llvm-libc-types/struct_sched_param.h b/include/llvm-libc-types/struct_sched_param.h
index 86209ac..e44a00b 100644
--- a/include/llvm-libc-types/struct_sched_param.h
+++ b/include/llvm-libc-types/struct_sched_param.h
@@ -9,9 +9,9 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_SCHED_PARAM_H
 #define LLVM_LIBC_TYPES_STRUCT_SCHED_PARAM_H
 
-#include "llvm-libc-types/pid_t.h"
-#include "llvm-libc-types/struct_timespec.h"
-#include "llvm-libc-types/time_t.h"
+#include "pid_t.h"
+#include "struct_timespec.h"
+#include "time_t.h"
 
 struct sched_param {
   // Process or thread execution scheduling priority.
diff --git a/include/llvm-libc-types/struct_sigaction.h b/include/llvm-libc-types/struct_sigaction.h
index ffce04d..4257cfe 100644
--- a/include/llvm-libc-types/struct_sigaction.h
+++ b/include/llvm-libc-types/struct_sigaction.h
@@ -9,15 +9,15 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_SIGACTION_H
 #define LLVM_LIBC_TYPES_STRUCT_SIGACTION_H
 
-#include "llvm-libc-types/siginfo_t.h"
-#include "llvm-libc-types/sigset_t.h"
+#include "siginfo_t.h"
+#include "sigset_t.h"
 
 struct sigaction {
   union {
     void (*sa_handler)(int);
     void (*sa_sigaction)(int, siginfo_t *, void *);
   };
-  sigset_t sa_mask;
+  struct sigset_t sa_mask;
   int sa_flags;
 #ifdef __linux__
   // This field is present on linux for most targets.
diff --git a/include/llvm-libc-types/struct_sockaddr.h b/include/llvm-libc-types/struct_sockaddr.h
index a986063..b7579e9 100644
--- a/include/llvm-libc-types/struct_sockaddr.h
+++ b/include/llvm-libc-types/struct_sockaddr.h
@@ -9,13 +9,13 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_SOCKADDR_H
 #define LLVM_LIBC_TYPES_STRUCT_SOCKADDR_H
 
-#include "llvm-libc-types/sa_family_t.h"
+#include "sa_family_t.h"
 
 struct sockaddr {
   sa_family_t sa_family;
   // sa_data is a variable length array. It is provided with a length of one
   // here as a placeholder.
-  char sa_data[];
+  char sa_data[1];
 };
 
 #endif // LLVM_LIBC_TYPES_STRUCT_SOCKADDR_H
diff --git a/include/llvm-libc-types/struct_sockaddr_un.h b/include/llvm-libc-types/struct_sockaddr_un.h
index 3c0362c..5ed31a4 100644
--- a/include/llvm-libc-types/struct_sockaddr_un.h
+++ b/include/llvm-libc-types/struct_sockaddr_un.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_SOCKADDR_UN_H
 #define LLVM_LIBC_TYPES_STRUCT_SOCKADDR_UN_H
 
-#include "llvm-libc-types/sa_family_t.h"
+#include "sa_family_t.h"
 
 // This is the sockaddr specialization for AF_UNIX or AF_LOCAL sockets, as
 // defined by posix.
diff --git a/include/llvm-libc-types/struct_stat.h b/include/llvm-libc-types/struct_stat.h
index d8ae9dd..4026679 100644
--- a/include/llvm-libc-types/struct_stat.h
+++ b/include/llvm-libc-types/struct_stat.h
@@ -9,16 +9,16 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_STAT_H
 #define LLVM_LIBC_TYPES_STRUCT_STAT_H
 
-#include "llvm-libc-types/blkcnt_t.h"
-#include "llvm-libc-types/blksize_t.h"
-#include "llvm-libc-types/dev_t.h"
-#include "llvm-libc-types/gid_t.h"
-#include "llvm-libc-types/ino_t.h"
-#include "llvm-libc-types/mode_t.h"
-#include "llvm-libc-types/nlink_t.h"
-#include "llvm-libc-types/off_t.h"
-#include "llvm-libc-types/struct_timespec.h"
-#include "llvm-libc-types/uid_t.h"
+#include "blkcnt_t.h"
+#include "blksize_t.h"
+#include "dev_t.h"
+#include "gid_t.h"
+#include "ino_t.h"
+#include "mode_t.h"
+#include "nlink_t.h"
+#include "off_t.h"
+#include "struct_timespec.h"
+#include "uid_t.h"
 
 struct stat {
   dev_t st_dev;
diff --git a/include/llvm-libc-types/struct_statvfs.h b/include/llvm-libc-types/struct_statvfs.h
index f467cfd..9c649af 100644
--- a/include/llvm-libc-types/struct_statvfs.h
+++ b/include/llvm-libc-types/struct_statvfs.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_STATVFS_H
 #define LLVM_LIBC_TYPES_STRUCT_STATVFS_H
 
-#include <llvm-libc-types/fsblkcnt_t.h>
-#include <llvm-libc-types/fsfilcnt_t.h>
+#include "fsblkcnt_t.h"
+#include "fsfilcnt_t.h"
 
 struct statvfs {
   unsigned long f_bsize;   /* Filesystem block size */
diff --git a/include/llvm-libc-types/struct_termios.h b/include/llvm-libc-types/struct_termios.h
index 5124119..e3c5f28 100644
--- a/include/llvm-libc-types/struct_termios.h
+++ b/include/llvm-libc-types/struct_termios.h
@@ -9,9 +9,9 @@
 #ifndef __LLVM_LIBC_TYPES_STRUCT_TERMIOS_H__
 #define __LLVM_LIBC_TYPES_STRUCT_TERMIOS_H__
 
-#include "llvm-libc-types/cc_t.h"
-#include "llvm-libc-types/speed_t.h"
-#include "llvm-libc-types/tcflag_t.h"
+#include "cc_t.h"
+#include "speed_t.h"
+#include "tcflag_t.h"
 
 struct termios {
   tcflag_t c_iflag; // Input mode flags
diff --git a/include/llvm-libc-types/struct_timespec.h b/include/llvm-libc-types/struct_timespec.h
index 4baab07..28b5a57 100644
--- a/include/llvm-libc-types/struct_timespec.h
+++ b/include/llvm-libc-types/struct_timespec.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_TIMESPEC_H
 #define LLVM_LIBC_TYPES_STRUCT_TIMESPEC_H
 
-#include "llvm-libc-types/time_t.h"
+#include "time_t.h"
 
 struct timespec {
   time_t tv_sec; /* Seconds.  */
diff --git a/include/llvm-libc-types/struct_timeval.h b/include/llvm-libc-types/struct_timeval.h
index 365b835..9595d85 100644
--- a/include/llvm-libc-types/struct_timeval.h
+++ b/include/llvm-libc-types/struct_timeval.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_TYPES_STRUCT_TIMEVAL_H
 #define LLVM_LIBC_TYPES_STRUCT_TIMEVAL_H
 
-#include "llvm-libc-types/suseconds_t.h"
-#include "llvm-libc-types/time_t.h"
+#include "suseconds_t.h"
+#include "time_t.h"
 
 struct timeval {
   time_t tv_sec;       // Seconds
diff --git a/include/llvm-libc-types/thrd_t.h b/include/llvm-libc-types/thrd_t.h
index 751ea5b..d5f3106 100644
--- a/include/llvm-libc-types/thrd_t.h
+++ b/include/llvm-libc-types/thrd_t.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_TYPES_THRD_T_H
 #define LLVM_LIBC_TYPES_THRD_T_H
 
-#include "llvm-libc-types/__thread_type.h"
+#include "__thread_type.h"
 
 typedef __thread_type thrd_t;
 
diff --git a/include/llvm-libc-types/time_t.h b/include/llvm-libc-types/time_t.h
index 59953b3..76920dc 100644
--- a/include/llvm-libc-types/time_t.h
+++ b/include/llvm-libc-types/time_t.h
@@ -1,4 +1,4 @@
-//===-- Definition of the type time_t -------------------------------------===//
+//===-- Definition of the type time_t, for use during the libc build ------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -9,10 +9,10 @@
 #ifndef LLVM_LIBC_TYPES_TIME_T_H
 #define LLVM_LIBC_TYPES_TIME_T_H
 
-#if (defined(__arm__) || defined(_M_ARM))
-typedef __INTPTR_TYPE__ time_t;
+#ifdef LIBC_TYPES_TIME_T_IS_32_BIT
+#include "time_t_32.h"
 #else
-typedef __INT64_TYPE__ time_t;
+#include "time_t_64.h"
 #endif
 
 #endif // LLVM_LIBC_TYPES_TIME_T_H
diff --git a/include/llvm-libc-types/time_t_32.h b/include/llvm-libc-types/time_t_32.h
new file mode 100644
index 0000000..2c415f6
--- /dev/null
+++ b/include/llvm-libc-types/time_t_32.h
@@ -0,0 +1,14 @@
+//===-- Definition of the type time_t -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_TIME_T_32_H
+#define LLVM_LIBC_TYPES_TIME_T_32_H
+
+typedef __INT32_TYPE__ time_t;
+
+#endif // LLVM_LIBC_TYPES_TIME_T_32_H
diff --git a/include/llvm-libc-types/time_t_64.h b/include/llvm-libc-types/time_t_64.h
new file mode 100644
index 0000000..8f7fd32
--- /dev/null
+++ b/include/llvm-libc-types/time_t_64.h
@@ -0,0 +1,14 @@
+//===-- Definition of the type time_t -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_TIME_T_64_H
+#define LLVM_LIBC_TYPES_TIME_T_64_H
+
+typedef __INT64_TYPE__ time_t;
+
+#endif // LLVM_LIBC_TYPES_TIME_T_64_H
diff --git a/include/llvm-libc-types/wchar_t.h b/include/llvm-libc-types/wchar_t.h
index 3e9a70b..bf2633a 100644
--- a/include/llvm-libc-types/wchar_t.h
+++ b/include/llvm-libc-types/wchar_t.h
@@ -9,11 +9,11 @@
 #ifndef LLVM_LIBC_TYPES_WCHAR_T_H
 #define LLVM_LIBC_TYPES_WCHAR_T_H
 
-// Since __need_wchar_t is defined, we get the definition of wchar_t from the
-// standalone C header stddef.h. Also, because __need_wchar_t is defined,
-// including stddef.h will pull only the type wchar_t and nothing else.
-#define __need_wchar_t
-#include <stddef.h>
-#undef __need_wchar_t
+// wchar_t is a fundamental type in C++.
+#ifndef __cplusplus
+
+typedef __WCHAR_TYPE__ wchar_t;
+
+#endif
 
 #endif // LLVM_LIBC_TYPES_WCHAR_T_H
diff --git a/include/llvm-libc-types/wint_t.h b/include/llvm-libc-types/wint_t.h
index 2758685..a53c6e3 100644
--- a/include/llvm-libc-types/wint_t.h
+++ b/include/llvm-libc-types/wint_t.h
@@ -9,11 +9,6 @@
 #ifndef LLVM_LIBC_TYPES_WINT_T_H
 #define LLVM_LIBC_TYPES_WINT_T_H
 
-// Since __need_wint_t is defined, we get the definition of wint_t from the
-// standalone C header stddef.h. Also, because __need_wint_t is defined,
-// including stddef.h will pull only the type wint_t and nothing else.
-#define __need_wint_t
-#include <stddef.h>
-#undef __need_wint_t
+typedef __WINT_TYPE__ wint_t;
 
 #endif // LLVM_LIBC_TYPES_WINT_T_H
diff --git a/include/sys/queue.h b/include/sys/queue.h
index cca53c1..fc739b4 100644
--- a/include/sys/queue.h
+++ b/include/sys/queue.h
@@ -9,6 +9,6 @@
 #ifndef SYS_QUEUE_H
 #define SYS_QUEUE_H
 
-#include "llvm-libc-macros/sys-queue-macros.h"
+#include "../llvm-libc-macros/sys-queue-macros.h"
 
 #endif // SYS_QUEUE_H
diff --git a/libc/shared/fp_bits.h b/libc/shared/fp_bits.h
new file mode 100644
index 0000000..2898c50
--- /dev/null
+++ b/libc/shared/fp_bits.h
@@ -0,0 +1,22 @@
+//===-- Floating point number utils -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_FP_BITS_H
+#define LLVM_LIBC_SHARED_FP_BITS_H
+
+#include "src/__support/FPUtil/FPBits.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace shared {
+
+using fputil::FPBits;
+
+} // namespace shared
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SHARED_FP_BITS_H
diff --git a/src/__support/RPC/rpc.h b/libc/shared/rpc.h
similarity index 65%
rename from src/__support/RPC/rpc.h
rename to libc/shared/rpc.h
index 05506c0..3f58674 100644
--- a/src/__support/RPC/rpc.h
+++ b/libc/shared/rpc.h
@@ -15,21 +15,40 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC___SUPPORT_RPC_RPC_H
-#define LLVM_LIBC_SRC___SUPPORT_RPC_RPC_H
+#ifndef LLVM_LIBC_SHARED_RPC_H
+#define LLVM_LIBC_SHARED_RPC_H
 
 #include "rpc_util.h"
-#include "src/__support/CPP/algorithm.h" // max
-#include "src/__support/CPP/atomic.h"
-#include "src/__support/CPP/functional.h"
-#include "src/__support/CPP/optional.h"
-#include "src/__support/GPU/utils.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+#ifndef RPC_INLINE
+#define RPC_INLINE inline
+#endif
+
 namespace rpc {
 
+/// Use scoped atomic variants if they are available for the target.
+#if !__has_builtin(__scoped_atomic_load_n)
+#define __scoped_atomic_load_n(src, ord, scp) __atomic_load_n(src, ord)
+#define __scoped_atomic_store_n(dst, src, ord, scp)                            \
+  __atomic_store_n(dst, src, ord)
+#define __scoped_atomic_fetch_or(src, val, ord, scp)                           \
+  __atomic_fetch_or(src, val, ord)
+#define __scoped_atomic_fetch_and(src, val, ord, scp)                          \
+  __atomic_fetch_and(src, val, ord)
+#endif
+#if !__has_builtin(__scoped_atomic_thread_fence)
+#define __scoped_atomic_thread_fence(ord, scp) __atomic_thread_fence(ord)
+#endif
+
+/// Generic codes that can be used whem implementing the server.
+enum Status {
+  SUCCESS = 0x0,
+  ERROR = 0x1000,
+  UNHANDLED_OPCODE = 0x1001,
+};
+
 /// A fixed size channel used to communicate between the RPC client and server.
 struct Buffer {
   uint64_t data[8];
@@ -40,11 +59,11 @@ static_assert(sizeof(Buffer) == 64, "Buffer size mismatch");
 /// perform and which threads are active in the slots.
 struct Header {
   uint64_t mask;
-  uint16_t opcode;
+  uint32_t opcode;
 };
 
 /// The maximum number of parallel ports that the RPC interface can support.
-constexpr uint64_t MAX_PORT_COUNT = 4096;
+constexpr static uint64_t MAX_PORT_COUNT = 4096;
 
 /// A common process used to synchronize communication between a client and a
 /// server. The process contains a read-only inbox and a write-only outbox used
@@ -59,26 +78,26 @@ constexpr uint64_t MAX_PORT_COUNT = 4096;
 ///   - The server will always start with a 'recv' operation.
 ///   - Every 'send' or 'recv' call is mirrored by the other process.
 template <bool Invert> struct Process {
-  LIBC_INLINE Process() = default;
-  LIBC_INLINE Process(const Process &) = delete;
-  LIBC_INLINE Process &operator=(const Process &) = delete;
-  LIBC_INLINE Process(Process &&) = default;
-  LIBC_INLINE Process &operator=(Process &&) = default;
-  LIBC_INLINE ~Process() = default;
-
-  uint32_t port_count = 0;
-  cpp::Atomic<uint32_t> *inbox = nullptr;
-  cpp::Atomic<uint32_t> *outbox = nullptr;
-  Header *header = nullptr;
-  Buffer *packet = nullptr;
+  RPC_INLINE Process() = default;
+  RPC_INLINE Process(const Process &) = delete;
+  RPC_INLINE Process &operator=(const Process &) = delete;
+  RPC_INLINE Process(Process &&) = default;
+  RPC_INLINE Process &operator=(Process &&) = default;
+  RPC_INLINE ~Process() = default;
+
+  const uint32_t port_count = 0;
+  const uint32_t *const inbox = nullptr;
+  uint32_t *const outbox = nullptr;
+  Header *const header = nullptr;
+  Buffer *const packet = nullptr;
 
   static constexpr uint64_t NUM_BITS_IN_WORD = sizeof(uint32_t) * 8;
-  cpp::Atomic<uint32_t> lock[MAX_PORT_COUNT / NUM_BITS_IN_WORD] = {0};
+  uint32_t lock[MAX_PORT_COUNT / NUM_BITS_IN_WORD] = {0};
 
-  LIBC_INLINE Process(uint32_t port_count, void *buffer)
-      : port_count(port_count), inbox(reinterpret_cast<cpp::Atomic<uint32_t> *>(
+  RPC_INLINE Process(uint32_t port_count, void *buffer)
+      : port_count(port_count), inbox(reinterpret_cast<uint32_t *>(
                                     advance(buffer, inbox_offset(port_count)))),
-        outbox(reinterpret_cast<cpp::Atomic<uint32_t> *>(
+        outbox(reinterpret_cast<uint32_t *>(
             advance(buffer, outbox_offset(port_count)))),
         header(reinterpret_cast<Header *>(
             advance(buffer, header_offset(port_count)))),
@@ -94,69 +113,68 @@ template <bool Invert> struct Process {
   ///   Header header[port_count];
   ///   Buffer packet[port_count][lane_size];
   /// };
-  LIBC_INLINE static constexpr uint64_t allocation_size(uint32_t port_count,
-                                                        uint32_t lane_size) {
+  RPC_INLINE static constexpr uint64_t allocation_size(uint32_t port_count,
+                                                       uint32_t lane_size) {
     return buffer_offset(port_count) + buffer_bytes(port_count, lane_size);
   }
 
   /// Retrieve the inbox state from memory shared between processes.
-  LIBC_INLINE uint32_t load_inbox(uint64_t lane_mask, uint32_t index) const {
-    return gpu::broadcast_value(
-        lane_mask,
-        inbox[index].load(cpp::MemoryOrder::RELAXED, cpp::MemoryScope::SYSTEM));
+  RPC_INLINE uint32_t load_inbox(uint64_t lane_mask, uint32_t index) const {
+    return rpc::broadcast_value(
+        lane_mask, __scoped_atomic_load_n(&inbox[index], __ATOMIC_RELAXED,
+                                          __MEMORY_SCOPE_SYSTEM));
   }
 
   /// Retrieve the outbox state from memory shared between processes.
-  LIBC_INLINE uint32_t load_outbox(uint64_t lane_mask, uint32_t index) const {
-    return gpu::broadcast_value(lane_mask,
-                                outbox[index].load(cpp::MemoryOrder::RELAXED,
-                                                   cpp::MemoryScope::SYSTEM));
+  RPC_INLINE uint32_t load_outbox(uint64_t lane_mask, uint32_t index) const {
+    return rpc::broadcast_value(
+        lane_mask, __scoped_atomic_load_n(&outbox[index], __ATOMIC_RELAXED,
+                                          __MEMORY_SCOPE_SYSTEM));
   }
 
   /// Signal to the other process that this one is finished with the buffer.
   /// Equivalent to loading outbox followed by store of the inverted value
   /// The outbox is write only by this warp and tracking the value locally is
   /// cheaper than calling load_outbox to get the value to store.
-  LIBC_INLINE uint32_t invert_outbox(uint32_t index, uint32_t current_outbox) {
+  RPC_INLINE uint32_t invert_outbox(uint32_t index, uint32_t current_outbox) {
     uint32_t inverted_outbox = !current_outbox;
-    atomic_thread_fence(cpp::MemoryOrder::RELEASE);
-    outbox[index].store(inverted_outbox, cpp::MemoryOrder::RELAXED,
-                        cpp::MemoryScope::SYSTEM);
+    __scoped_atomic_thread_fence(__ATOMIC_RELEASE, __MEMORY_SCOPE_SYSTEM);
+    __scoped_atomic_store_n(&outbox[index], inverted_outbox, __ATOMIC_RELAXED,
+                            __MEMORY_SCOPE_SYSTEM);
     return inverted_outbox;
   }
 
   // Given the current outbox and inbox values, wait until the inbox changes
   // to indicate that this thread owns the buffer element.
-  LIBC_INLINE void wait_for_ownership(uint64_t lane_mask, uint32_t index,
-                                      uint32_t outbox, uint32_t in) {
+  RPC_INLINE void wait_for_ownership(uint64_t lane_mask, uint32_t index,
+                                     uint32_t outbox, uint32_t in) {
     while (buffer_unavailable(in, outbox)) {
       sleep_briefly();
       in = load_inbox(lane_mask, index);
     }
-    atomic_thread_fence(cpp::MemoryOrder::ACQUIRE);
+    __scoped_atomic_thread_fence(__ATOMIC_ACQUIRE, __MEMORY_SCOPE_SYSTEM);
   }
 
   /// The packet is a linearly allocated array of buffers used to communicate
   /// with the other process. This function returns the appropriate slot in this
   /// array such that the process can operate on an entire warp or wavefront.
-  LIBC_INLINE Buffer *get_packet(uint32_t index, uint32_t lane_size) {
+  RPC_INLINE Buffer *get_packet(uint32_t index, uint32_t lane_size) {
     return &packet[index * lane_size];
   }
 
   /// Determines if this process needs to wait for ownership of the buffer. We
   /// invert the condition on one of the processes to indicate that if one
   /// process owns the buffer then the other does not.
-  LIBC_INLINE static bool buffer_unavailable(uint32_t in, uint32_t out) {
+  RPC_INLINE static bool buffer_unavailable(uint32_t in, uint32_t out) {
     bool cond = in != out;
     return Invert ? !cond : cond;
   }
 
   /// Attempt to claim the lock at index. Return true on lock taken.
   /// lane_mask is a bitmap of the threads in the warp that would hold the
-  /// single lock on success, e.g. the result of gpu::get_lane_mask()
+  /// single lock on success, e.g. the result of rpc::get_lane_mask()
   /// The lock is held when the n-th bit of the lock bitfield is set.
-  [[clang::convergent]] LIBC_INLINE bool try_lock(uint64_t lane_mask,
-                                                  uint32_t index) {
+  RPC_INLINE bool try_lock(uint64_t lane_mask, uint32_t index) {
     // On amdgpu, test and set to the nth lock bit and a sync_lane would suffice
     // On volta, need to handle differences between the threads running and
     // the threads that were detected in the previous call to get_lane_mask()
@@ -165,12 +183,12 @@ template <bool Invert> struct Process {
     // There may be threads active which are not in lane mask which must not
     // succeed in taking the lock, as otherwise it will leak. This is handled
     // by making threads which are not in lane_mask or with 0, a no-op.
-    uint32_t id = gpu::get_lane_id();
+    uint32_t id = rpc::get_lane_id();
     bool id_in_lane_mask = lane_mask & (1ul << id);
 
     // All threads in the warp call fetch_or. Possibly at the same time.
     bool before = set_nth(lock, index, id_in_lane_mask);
-    uint64_t packed = gpu::ballot(lane_mask, before);
+    uint64_t packed = rpc::ballot(lane_mask, before);
 
     // If every bit set in lane_mask is also set in packed, every single thread
     // in the warp failed to get the lock. Ballot returns unset for threads not
@@ -190,101 +208,87 @@ template <bool Invert> struct Process {
     // inlining the current function.
     bool holding_lock = lane_mask != packed;
     if (holding_lock)
-      atomic_thread_fence(cpp::MemoryOrder::ACQUIRE);
+      __scoped_atomic_thread_fence(__ATOMIC_ACQUIRE, __MEMORY_SCOPE_DEVICE);
     return holding_lock;
   }
 
   /// Unlock the lock at index. We need a lane sync to keep this function
   /// convergent, otherwise the compiler will sink the store and deadlock.
-  [[clang::convergent]] LIBC_INLINE void unlock(uint64_t lane_mask,
-                                                uint32_t index) {
+  RPC_INLINE void unlock(uint64_t lane_mask, uint32_t index) {
     // Do not move any writes past the unlock.
-    atomic_thread_fence(cpp::MemoryOrder::RELEASE);
+    __scoped_atomic_thread_fence(__ATOMIC_RELEASE, __MEMORY_SCOPE_DEVICE);
 
     // Use exactly one thread to clear the nth bit in the lock array Must
     // restrict to a single thread to avoid one thread dropping the lock, then
     // an unrelated warp claiming the lock, then a second thread in this warp
     // dropping the lock again.
-    clear_nth(lock, index, gpu::is_first_lane(lane_mask));
-    gpu::sync_lane(lane_mask);
+    clear_nth(lock, index, rpc::is_first_lane(lane_mask));
+    rpc::sync_lane(lane_mask);
   }
 
   /// Number of bytes to allocate for an inbox or outbox.
-  LIBC_INLINE static constexpr uint64_t mailbox_bytes(uint32_t port_count) {
-    return port_count * sizeof(cpp::Atomic<uint32_t>);
+  RPC_INLINE static constexpr uint64_t mailbox_bytes(uint32_t port_count) {
+    return port_count * sizeof(uint32_t);
   }
 
   /// Number of bytes to allocate for the buffer containing the packets.
-  LIBC_INLINE static constexpr uint64_t buffer_bytes(uint32_t port_count,
-                                                     uint32_t lane_size) {
+  RPC_INLINE static constexpr uint64_t buffer_bytes(uint32_t port_count,
+                                                    uint32_t lane_size) {
     return port_count * lane_size * sizeof(Buffer);
   }
 
   /// Offset of the inbox in memory. This is the same as the outbox if inverted.
-  LIBC_INLINE static constexpr uint64_t inbox_offset(uint32_t port_count) {
+  RPC_INLINE static constexpr uint64_t inbox_offset(uint32_t port_count) {
     return Invert ? mailbox_bytes(port_count) : 0;
   }
 
   /// Offset of the outbox in memory. This is the same as the inbox if inverted.
-  LIBC_INLINE static constexpr uint64_t outbox_offset(uint32_t port_count) {
+  RPC_INLINE static constexpr uint64_t outbox_offset(uint32_t port_count) {
     return Invert ? 0 : mailbox_bytes(port_count);
   }
 
   /// Offset of the buffer containing the packets after the inbox and outbox.
-  LIBC_INLINE static constexpr uint64_t header_offset(uint32_t port_count) {
+  RPC_INLINE static constexpr uint64_t header_offset(uint32_t port_count) {
     return align_up(2 * mailbox_bytes(port_count), alignof(Header));
   }
 
   /// Offset of the buffer containing the packets after the inbox and outbox.
-  LIBC_INLINE static constexpr uint64_t buffer_offset(uint32_t port_count) {
+  RPC_INLINE static constexpr uint64_t buffer_offset(uint32_t port_count) {
     return align_up(header_offset(port_count) + port_count * sizeof(Header),
                     alignof(Buffer));
   }
 
   /// Conditionally set the n-th bit in the atomic bitfield.
-  LIBC_INLINE static constexpr uint32_t set_nth(cpp::Atomic<uint32_t> *bits,
-                                                uint32_t index, bool cond) {
+  RPC_INLINE static constexpr uint32_t set_nth(uint32_t *bits, uint32_t index,
+                                               bool cond) {
     uint32_t slot = index / NUM_BITS_IN_WORD;
     uint32_t bit = index % NUM_BITS_IN_WORD;
-    return bits[slot].fetch_or(static_cast<uint32_t>(cond) << bit,
-                               cpp::MemoryOrder::RELAXED,
-                               cpp::MemoryScope::DEVICE) &
+    return __scoped_atomic_fetch_or(&bits[slot],
+                                    static_cast<uint32_t>(cond) << bit,
+                                    __ATOMIC_RELAXED, __MEMORY_SCOPE_DEVICE) &
            (1u << bit);
   }
 
   /// Conditionally clear the n-th bit in the atomic bitfield.
-  LIBC_INLINE static constexpr uint32_t clear_nth(cpp::Atomic<uint32_t> *bits,
-                                                  uint32_t index, bool cond) {
+  RPC_INLINE static constexpr uint32_t clear_nth(uint32_t *bits, uint32_t index,
+                                                 bool cond) {
     uint32_t slot = index / NUM_BITS_IN_WORD;
     uint32_t bit = index % NUM_BITS_IN_WORD;
-    return bits[slot].fetch_and(~0u ^ (static_cast<uint32_t>(cond) << bit),
-                                cpp::MemoryOrder::RELAXED,
-                                cpp::MemoryScope::DEVICE) &
+    return __scoped_atomic_fetch_and(&bits[slot],
+                                     ~0u ^ (static_cast<uint32_t>(cond) << bit),
+                                     __ATOMIC_RELAXED, __MEMORY_SCOPE_DEVICE) &
            (1u << bit);
   }
 };
 
 /// Invokes a function accross every active buffer across the total lane size.
-static LIBC_INLINE void invoke_rpc(cpp::function<void(Buffer *)> fn,
-                                   uint32_t lane_size, uint64_t lane_mask,
-                                   Buffer *slot) {
+template <typename F>
+RPC_INLINE static void invoke_rpc(F &&fn, uint32_t lane_size,
+                                  uint64_t lane_mask, Buffer *slot) {
   if constexpr (is_process_gpu()) {
-    fn(&slot[gpu::get_lane_id()]);
+    fn(&slot[rpc::get_lane_id()], rpc::get_lane_id());
   } else {
-    for (uint32_t i = 0; i < lane_size; i += gpu::get_lane_size())
-      if (lane_mask & (1ul << i))
-        fn(&slot[i]);
-  }
-}
-
-/// Alternate version that also provides the index of the current lane.
-static LIBC_INLINE void invoke_rpc(cpp::function<void(Buffer *, uint32_t)> fn,
-                                   uint32_t lane_size, uint64_t lane_mask,
-                                   Buffer *slot) {
-  if constexpr (is_process_gpu()) {
-    fn(&slot[gpu::get_lane_id()], gpu::get_lane_id());
-  } else {
-    for (uint32_t i = 0; i < lane_size; i += gpu::get_lane_size())
+    for (uint32_t i = 0; i < lane_size; i += rpc::get_num_lanes())
       if (lane_mask & (1ul << i))
         fn(&slot[i], i);
   }
@@ -294,42 +298,42 @@ static LIBC_INLINE void invoke_rpc(cpp::function<void(Buffer *, uint32_t)> fn,
 /// processes. A port is conceptually an index into the memory provided by the
 /// underlying process that is guarded by a lock bit.
 template <bool T> struct Port {
-  LIBC_INLINE Port(Process<T> &process, uint64_t lane_mask, uint32_t lane_size,
-                   uint32_t index, uint32_t out)
+  RPC_INLINE Port(Process<T> &process, uint64_t lane_mask, uint32_t lane_size,
+                  uint32_t index, uint32_t out)
       : process(process), lane_mask(lane_mask), lane_size(lane_size),
         index(index), out(out), receive(false), owns_buffer(true) {}
-  LIBC_INLINE ~Port() = default;
+  RPC_INLINE ~Port() = default;
 
 private:
-  LIBC_INLINE Port(const Port &) = delete;
-  LIBC_INLINE Port &operator=(const Port &) = delete;
-  LIBC_INLINE Port(Port &&) = default;
-  LIBC_INLINE Port &operator=(Port &&) = default;
+  RPC_INLINE Port(const Port &) = delete;
+  RPC_INLINE Port &operator=(const Port &) = delete;
+  RPC_INLINE Port(Port &&) = default;
+  RPC_INLINE Port &operator=(Port &&) = default;
 
   friend struct Client;
   friend struct Server;
-  friend class cpp::optional<Port<T>>;
+  friend class rpc::optional<Port<T>>;
 
 public:
-  template <typename U> LIBC_INLINE void recv(U use);
-  template <typename F> LIBC_INLINE void send(F fill);
+  template <typename U> RPC_INLINE void recv(U use);
+  template <typename F> RPC_INLINE void send(F fill);
   template <typename F, typename U>
-  LIBC_INLINE void send_and_recv(F fill, U use);
-  template <typename W> LIBC_INLINE void recv_and_send(W work);
-  LIBC_INLINE void send_n(const void *const *src, uint64_t *size);
-  LIBC_INLINE void send_n(const void *src, uint64_t size);
+  RPC_INLINE void send_and_recv(F fill, U use);
+  template <typename W> RPC_INLINE void recv_and_send(W work);
+  RPC_INLINE void send_n(const void *const *src, uint64_t *size);
+  RPC_INLINE void send_n(const void *src, uint64_t size);
   template <typename A>
-  LIBC_INLINE void recv_n(void **dst, uint64_t *size, A &&alloc);
+  RPC_INLINE void recv_n(void **dst, uint64_t *size, A &&alloc);
 
-  LIBC_INLINE uint16_t get_opcode() const {
+  RPC_INLINE uint32_t get_opcode() const {
     return process.header[index].opcode;
   }
 
-  LIBC_INLINE uint16_t get_index() const { return index; }
+  RPC_INLINE uint32_t get_index() const { return index; }
 
-  LIBC_INLINE void close() {
+  RPC_INLINE void close() {
     // Wait for all lanes to finish using the port.
-    gpu::sync_lane(lane_mask);
+    rpc::sync_lane(lane_mask);
 
     // The server is passive, if it own the buffer when it closes we need to
     // give ownership back to the client.
@@ -350,41 +354,38 @@ private:
 
 /// The RPC client used to make requests to the server.
 struct Client {
-  LIBC_INLINE Client() = default;
-  LIBC_INLINE Client(const Client &) = delete;
-  LIBC_INLINE Client &operator=(const Client &) = delete;
-  LIBC_INLINE ~Client() = default;
+  RPC_INLINE Client() = default;
+  RPC_INLINE Client(const Client &) = delete;
+  RPC_INLINE Client &operator=(const Client &) = delete;
+  RPC_INLINE ~Client() = default;
 
-  LIBC_INLINE Client(uint32_t port_count, void *buffer)
+  RPC_INLINE Client(uint32_t port_count, void *buffer)
       : process(port_count, buffer) {}
 
   using Port = rpc::Port<false>;
-  template <uint16_t opcode> LIBC_INLINE Port open();
+  template <uint32_t opcode> RPC_INLINE Port open();
 
 private:
   Process<false> process;
 };
-static_assert(cpp::is_trivially_copyable<Client>::value &&
-                  sizeof(Process<true>) == sizeof(Process<false>),
-              "The client is not trivially copyable from the server");
 
 /// The RPC server used to respond to the client.
 struct Server {
-  LIBC_INLINE Server() = default;
-  LIBC_INLINE Server(const Server &) = delete;
-  LIBC_INLINE Server &operator=(const Server &) = delete;
-  LIBC_INLINE ~Server() = default;
+  RPC_INLINE Server() = default;
+  RPC_INLINE Server(const Server &) = delete;
+  RPC_INLINE Server &operator=(const Server &) = delete;
+  RPC_INLINE ~Server() = default;
 
-  LIBC_INLINE Server(uint32_t port_count, void *buffer)
+  RPC_INLINE Server(uint32_t port_count, void *buffer)
       : process(port_count, buffer) {}
 
   using Port = rpc::Port<true>;
-  LIBC_INLINE cpp::optional<Port> try_open(uint32_t lane_size,
-                                           uint32_t start = 0);
-  LIBC_INLINE Port open(uint32_t lane_size);
+  RPC_INLINE rpc::optional<Port> try_open(uint32_t lane_size,
+                                          uint32_t start = 0);
+  RPC_INLINE Port open(uint32_t lane_size);
 
-  LIBC_INLINE static uint64_t allocation_size(uint32_t lane_size,
-                                              uint32_t port_count) {
+  RPC_INLINE static uint64_t allocation_size(uint32_t lane_size,
+                                             uint32_t port_count) {
     return Process<true>::allocation_size(port_count, lane_size);
   }
 
@@ -393,7 +394,7 @@ private:
 };
 
 /// Applies \p fill to the shared buffer and initiates a send operation.
-template <bool T> template <typename F> LIBC_INLINE void Port<T>::send(F fill) {
+template <bool T> template <typename F> RPC_INLINE void Port<T>::send(F fill) {
   uint32_t in = owns_buffer ? out ^ T : process.load_inbox(lane_mask, index);
 
   // We need to wait until we own the buffer before sending.
@@ -408,7 +409,7 @@ template <bool T> template <typename F> LIBC_INLINE void Port<T>::send(F fill) {
 }
 
 /// Applies \p use to the shared buffer and acknowledges the send.
-template <bool T> template <typename U> LIBC_INLINE void Port<T>::recv(U use) {
+template <bool T> template <typename U> RPC_INLINE void Port<T>::recv(U use) {
   // We only exchange ownership of the buffer during a receive if we are waiting
   // for a previous receive to finish.
   if (receive) {
@@ -431,7 +432,7 @@ template <bool T> template <typename U> LIBC_INLINE void Port<T>::recv(U use) {
 /// Combines a send and receive into a single function.
 template <bool T>
 template <typename F, typename U>
-LIBC_INLINE void Port<T>::send_and_recv(F fill, U use) {
+RPC_INLINE void Port<T>::send_and_recv(F fill, U use) {
   send(fill);
   recv(use);
 }
@@ -441,15 +442,15 @@ LIBC_INLINE void Port<T>::send_and_recv(F fill, U use) {
 /// the copy back.
 template <bool T>
 template <typename W>
-LIBC_INLINE void Port<T>::recv_and_send(W work) {
+RPC_INLINE void Port<T>::recv_and_send(W work) {
   recv(work);
-  send([](Buffer *) { /* no-op */ });
+  send([](Buffer *, uint32_t) { /* no-op */ });
 }
 
 /// Helper routine to simplify the interface when sending from the GPU using
 /// thread private pointers to the underlying value.
 template <bool T>
-LIBC_INLINE void Port<T>::send_n(const void *src, uint64_t size) {
+RPC_INLINE void Port<T>::send_n(const void *src, uint64_t size) {
   const void **src_ptr = &src;
   uint64_t *size_ptr = &size;
   send_n(src_ptr, size_ptr);
@@ -458,12 +459,12 @@ LIBC_INLINE void Port<T>::send_n(const void *src, uint64_t size) {
 /// Sends an arbitrarily sized data buffer \p src across the shared channel in
 /// multiples of the packet length.
 template <bool T>
-LIBC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
+RPC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
   uint64_t num_sends = 0;
   send([&](Buffer *buffer, uint32_t id) {
     reinterpret_cast<uint64_t *>(buffer->data)[0] = lane_value(size, id);
     num_sends = is_process_gpu() ? lane_value(size, id)
-                                 : cpp::max(lane_value(size, id), num_sends);
+                                 : rpc::max(lane_value(size, id), num_sends);
     uint64_t len =
         lane_value(size, id) > sizeof(Buffer::data) - sizeof(uint64_t)
             ? sizeof(Buffer::data) - sizeof(uint64_t)
@@ -472,7 +473,7 @@ LIBC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
   });
   uint64_t idx = sizeof(Buffer::data) - sizeof(uint64_t);
   uint64_t mask = process.header[index].mask;
-  while (gpu::ballot(mask, idx < num_sends)) {
+  while (rpc::ballot(mask, idx < num_sends)) {
     send([=](Buffer *buffer, uint32_t id) {
       uint64_t len = lane_value(size, id) - idx > sizeof(Buffer::data)
                          ? sizeof(Buffer::data)
@@ -489,14 +490,14 @@ LIBC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
 /// size of the data so that we can initialize the size of the \p dst buffer.
 template <bool T>
 template <typename A>
-LIBC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
+RPC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
   uint64_t num_recvs = 0;
   recv([&](Buffer *buffer, uint32_t id) {
     lane_value(size, id) = reinterpret_cast<uint64_t *>(buffer->data)[0];
     lane_value(dst, id) =
         reinterpret_cast<uint8_t *>(alloc(lane_value(size, id)));
     num_recvs = is_process_gpu() ? lane_value(size, id)
-                                 : cpp::max(lane_value(size, id), num_recvs);
+                                 : rpc::max(lane_value(size, id), num_recvs);
     uint64_t len =
         lane_value(size, id) > sizeof(Buffer::data) - sizeof(uint64_t)
             ? sizeof(Buffer::data) - sizeof(uint64_t)
@@ -505,7 +506,7 @@ LIBC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
   });
   uint64_t idx = sizeof(Buffer::data) - sizeof(uint64_t);
   uint64_t mask = process.header[index].mask;
-  while (gpu::ballot(mask, idx < num_recvs)) {
+  while (rpc::ballot(mask, idx < num_recvs)) {
     recv([=](Buffer *buffer, uint32_t id) {
       uint64_t len = lane_value(size, id) - idx > sizeof(Buffer::data)
                          ? sizeof(Buffer::data)
@@ -523,17 +524,16 @@ LIBC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
 /// port. Each port instance uses an associated \p opcode to tell the server
 /// what to do. The Client interface provides the appropriate lane size to the
 /// port using the platform's returned value.
-template <uint16_t opcode>
-[[clang::convergent]] LIBC_INLINE Client::Port Client::open() {
+template <uint32_t opcode> RPC_INLINE Client::Port Client::open() {
   // Repeatedly perform a naive linear scan for a port that can be opened to
   // send data.
-  for (uint32_t index = gpu::get_cluster_id();; ++index) {
+  for (uint32_t index = 0;; ++index) {
     // Start from the beginning if we run out of ports to check.
     if (index >= process.port_count)
       index = 0;
 
     // Attempt to acquire the lock on this index.
-    uint64_t lane_mask = gpu::get_lane_mask();
+    uint64_t lane_mask = rpc::get_lane_mask();
     if (!process.try_lock(lane_mask, index))
       continue;
 
@@ -547,22 +547,22 @@ template <uint16_t opcode>
       continue;
     }
 
-    if (gpu::is_first_lane(lane_mask)) {
+    if (rpc::is_first_lane(lane_mask)) {
       process.header[index].opcode = opcode;
       process.header[index].mask = lane_mask;
     }
-    gpu::sync_lane(lane_mask);
-    return Port(process, lane_mask, gpu::get_lane_size(), index, out);
+    rpc::sync_lane(lane_mask);
+    return Port(process, lane_mask, rpc::get_num_lanes(), index, out);
   }
 }
 
 /// Attempts to open a port to use as the server. The server can only open a
 /// port if it has a pending receive operation
-[[clang::convergent]] LIBC_INLINE cpp::optional<typename Server::Port>
+RPC_INLINE rpc::optional<typename Server::Port>
 Server::try_open(uint32_t lane_size, uint32_t start) {
   // Perform a naive linear scan for a port that has a pending request.
   for (uint32_t index = start; index < process.port_count; ++index) {
-    uint64_t lane_mask = gpu::get_lane_mask();
+    uint64_t lane_mask = rpc::get_lane_mask();
     uint32_t in = process.load_inbox(lane_mask, index);
     uint32_t out = process.load_outbox(lane_mask, index);
 
@@ -585,18 +585,27 @@ Server::try_open(uint32_t lane_size, uint32_t start) {
 
     return Port(process, lane_mask, lane_size, index, out);
   }
-  return cpp::nullopt;
+  return rpc::nullopt;
 }
 
-LIBC_INLINE Server::Port Server::open(uint32_t lane_size) {
+RPC_INLINE Server::Port Server::open(uint32_t lane_size) {
   for (;;) {
-    if (cpp::optional<Server::Port> p = try_open(lane_size))
-      return cpp::move(p.value());
+    if (rpc::optional<Server::Port> p = try_open(lane_size))
+      return rpc::move(p.value());
     sleep_briefly();
   }
 }
 
+#if !__has_builtin(__scoped_atomic_load_n)
+#undef __scoped_atomic_load_n
+#undef __scoped_atomic_store_n
+#undef __scoped_atomic_fetch_or
+#undef __scoped_atomic_fetch_and
+#endif
+#if !__has_builtin(__scoped_atomic_thread_fence)
+#undef __scoped_atomic_thread_fence
+#endif
+
 } // namespace rpc
-} // namespace LIBC_NAMESPACE
 
-#endif
+#endif // LLVM_LIBC_SHARED_RPC_H
diff --git a/libc/shared/rpc_opcodes.h b/libc/shared/rpc_opcodes.h
new file mode 100644
index 0000000..e7ec0e7
--- /dev/null
+++ b/libc/shared/rpc_opcodes.h
@@ -0,0 +1,59 @@
+//===-- Definition of RPC opcodes -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_RPC_OPCODES_H
+#define LLVM_LIBC_SHARED_RPC_OPCODES_H
+
+#include "rpc.h"
+
+#define LLVM_LIBC_RPC_BASE 'c'
+#define LLVM_LIBC_OPCODE(n) (LLVM_LIBC_RPC_BASE << 24 | n)
+
+typedef enum {
+  RPC_NOOP = LLVM_LIBC_OPCODE(0),
+  RPC_EXIT = LLVM_LIBC_OPCODE(1),
+  RPC_WRITE_TO_STDOUT = LLVM_LIBC_OPCODE(2),
+  RPC_WRITE_TO_STDERR = LLVM_LIBC_OPCODE(3),
+  RPC_WRITE_TO_STREAM = LLVM_LIBC_OPCODE(4),
+  RPC_WRITE_TO_STDOUT_NEWLINE = LLVM_LIBC_OPCODE(5),
+  RPC_READ_FROM_STREAM = LLVM_LIBC_OPCODE(6),
+  RPC_READ_FGETS = LLVM_LIBC_OPCODE(7),
+  RPC_OPEN_FILE = LLVM_LIBC_OPCODE(8),
+  RPC_CLOSE_FILE = LLVM_LIBC_OPCODE(9),
+  RPC_MALLOC = LLVM_LIBC_OPCODE(10),
+  RPC_FREE = LLVM_LIBC_OPCODE(11),
+  RPC_HOST_CALL = LLVM_LIBC_OPCODE(12),
+  RPC_ABORT = LLVM_LIBC_OPCODE(13),
+  RPC_FEOF = LLVM_LIBC_OPCODE(14),
+  RPC_FERROR = LLVM_LIBC_OPCODE(15),
+  RPC_CLEARERR = LLVM_LIBC_OPCODE(16),
+  RPC_FSEEK = LLVM_LIBC_OPCODE(17),
+  RPC_FTELL = LLVM_LIBC_OPCODE(18),
+  RPC_FFLUSH = LLVM_LIBC_OPCODE(19),
+  RPC_UNGETC = LLVM_LIBC_OPCODE(20),
+  RPC_PRINTF_TO_STDOUT = LLVM_LIBC_OPCODE(21),
+  RPC_PRINTF_TO_STDERR = LLVM_LIBC_OPCODE(22),
+  RPC_PRINTF_TO_STREAM = LLVM_LIBC_OPCODE(23),
+  RPC_PRINTF_TO_STDOUT_PACKED = LLVM_LIBC_OPCODE(24),
+  RPC_PRINTF_TO_STDERR_PACKED = LLVM_LIBC_OPCODE(25),
+  RPC_PRINTF_TO_STREAM_PACKED = LLVM_LIBC_OPCODE(26),
+  RPC_REMOVE = LLVM_LIBC_OPCODE(27),
+  RPC_RENAME = LLVM_LIBC_OPCODE(28),
+  RPC_SYSTEM = LLVM_LIBC_OPCODE(29),
+  RPC_LAST = 0xFFFFFFFF,
+} rpc_opcode_t;
+
+#undef LLVM_LIBC_OPCODE
+
+namespace rpc {
+// The implementation of this function currently lives in the utility directory
+// at 'utils/gpu/server/rpc_server.cpp'.
+rpc::Status handle_libc_opcodes(rpc::Server::Port &port, uint32_t num_lanes);
+} // namespace rpc
+
+#endif // LLVM_LIBC_SHARED_RPC_OPCODES_H
diff --git a/libc/shared/rpc_util.h b/libc/shared/rpc_util.h
new file mode 100644
index 0000000..bb0177c
--- /dev/null
+++ b/libc/shared/rpc_util.h
@@ -0,0 +1,269 @@
+//===-- Shared memory RPC client / server utilities -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_RPC_UTIL_H
+#define LLVM_LIBC_SHARED_RPC_UTIL_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#if defined(__NVPTX__) || defined(__AMDGPU__)
+#include <gpuintrin.h>
+#define RPC_TARGET_IS_GPU
+#endif
+
+// Workaround for missing __has_builtin in < GCC 10.
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+#ifndef RPC_INLINE
+#define RPC_INLINE inline
+#endif
+
+namespace rpc {
+
+template <typename T> struct type_identity {
+  using type = T;
+};
+
+template <class T, T v> struct type_constant {
+  static inline constexpr T value = v;
+};
+
+template <class T> struct remove_reference : type_identity<T> {};
+template <class T> struct remove_reference<T &> : type_identity<T> {};
+template <class T> struct remove_reference<T &&> : type_identity<T> {};
+
+template <class T> struct is_const : type_constant<bool, false> {};
+template <class T> struct is_const<const T> : type_constant<bool, true> {};
+
+/// Freestanding implementation of std::move.
+template <class T>
+RPC_INLINE constexpr typename remove_reference<T>::type &&move(T &&t) {
+  return static_cast<typename remove_reference<T>::type &&>(t);
+}
+
+/// Freestanding implementation of std::forward.
+template <typename T>
+RPC_INLINE constexpr T &&forward(typename remove_reference<T>::type &value) {
+  return static_cast<T &&>(value);
+}
+template <typename T>
+RPC_INLINE constexpr T &&forward(typename remove_reference<T>::type &&value) {
+  return static_cast<T &&>(value);
+}
+
+struct in_place_t {
+  RPC_INLINE explicit in_place_t() = default;
+};
+
+struct nullopt_t {
+  RPC_INLINE constexpr explicit nullopt_t() = default;
+};
+
+constexpr inline in_place_t in_place{};
+constexpr inline nullopt_t nullopt{};
+
+/// Freestanding and minimal implementation of std::optional.
+template <typename T> class optional {
+  template <typename U> struct OptionalStorage {
+    union {
+      char empty;
+      U stored_value;
+    };
+
+    bool in_use = false;
+
+    RPC_INLINE ~OptionalStorage() { reset(); }
+
+    RPC_INLINE constexpr OptionalStorage() : empty() {}
+
+    template <typename... Args>
+    RPC_INLINE constexpr explicit OptionalStorage(in_place_t, Args &&...args)
+        : stored_value(forward<Args>(args)...) {}
+
+    RPC_INLINE constexpr void reset() {
+      if (in_use)
+        stored_value.~U();
+      in_use = false;
+    }
+  };
+
+  OptionalStorage<T> storage;
+
+public:
+  RPC_INLINE constexpr optional() = default;
+  RPC_INLINE constexpr optional(nullopt_t) {}
+
+  RPC_INLINE constexpr optional(const T &t) : storage(in_place, t) {
+    storage.in_use = true;
+  }
+  RPC_INLINE constexpr optional(const optional &) = default;
+
+  RPC_INLINE constexpr optional(T &&t) : storage(in_place, move(t)) {
+    storage.in_use = true;
+  }
+  RPC_INLINE constexpr optional(optional &&O) = default;
+
+  RPC_INLINE constexpr optional &operator=(T &&t) {
+    storage = move(t);
+    return *this;
+  }
+  RPC_INLINE constexpr optional &operator=(optional &&) = default;
+
+  RPC_INLINE constexpr optional &operator=(const T &t) {
+    storage = t;
+    return *this;
+  }
+  RPC_INLINE constexpr optional &operator=(const optional &) = default;
+
+  RPC_INLINE constexpr void reset() { storage.reset(); }
+
+  RPC_INLINE constexpr const T &value() const & { return storage.stored_value; }
+
+  RPC_INLINE constexpr T &value() & { return storage.stored_value; }
+
+  RPC_INLINE constexpr explicit operator bool() const { return storage.in_use; }
+  RPC_INLINE constexpr bool has_value() const { return storage.in_use; }
+  RPC_INLINE constexpr const T *operator->() const {
+    return &storage.stored_value;
+  }
+  RPC_INLINE constexpr T *operator->() { return &storage.stored_value; }
+  RPC_INLINE constexpr const T &operator*() const & {
+    return storage.stored_value;
+  }
+  RPC_INLINE constexpr T &operator*() & { return storage.stored_value; }
+
+  RPC_INLINE constexpr T &&value() && { return move(storage.stored_value); }
+  RPC_INLINE constexpr T &&operator*() && { return move(storage.stored_value); }
+};
+
+/// Suspend the thread briefly to assist the thread scheduler during busy loops.
+RPC_INLINE void sleep_briefly() {
+#if defined(__NVPTX__)
+  if (__nvvm_reflect("__CUDA_ARCH") >= 700)
+    asm("nanosleep.u32 64;" ::: "memory");
+#elif defined(__AMDGPU__)
+  __builtin_amdgcn_s_sleep(2);
+#elif __has_builtin(__builtin_ia32_pause)
+  __builtin_ia32_pause();
+#elif __has_builtin(__builtin_arm_isb)
+  __builtin_arm_isb(0xf);
+#else
+  // Simply do nothing if sleeping isn't supported on this platform.
+#endif
+}
+
+/// Conditional to indicate if this process is running on the GPU.
+RPC_INLINE constexpr bool is_process_gpu() {
+#ifdef RPC_TARGET_IS_GPU
+  return true;
+#else
+  return false;
+#endif
+}
+
+/// Wait for all lanes in the group to complete.
+RPC_INLINE void sync_lane(uint64_t lane_mask) {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_sync_lane(lane_mask);
+#endif
+}
+
+/// Copies the value from the first active thread to the rest.
+RPC_INLINE uint32_t broadcast_value(uint64_t lane_mask, uint32_t x) {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_read_first_lane_u32(lane_mask, x);
+#else
+  return x;
+#endif
+}
+
+/// Returns the number lanes that participate in the RPC interface.
+RPC_INLINE uint32_t get_num_lanes() {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_num_lanes();
+#else
+  return 1;
+#endif
+}
+
+/// Returns the id of the thread inside of an AMD wavefront executing together.
+RPC_INLINE uint64_t get_lane_mask() {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_lane_mask();
+#else
+  return 1;
+#endif
+}
+
+/// Returns the id of the thread inside of an AMD wavefront executing together.
+RPC_INLINE uint32_t get_lane_id() {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_lane_id();
+#else
+  return 0;
+#endif
+}
+
+/// Conditional that is only true for a single thread in a lane.
+RPC_INLINE bool is_first_lane(uint64_t lane_mask) {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_is_first_in_lane(lane_mask);
+#else
+  return true;
+#endif
+}
+
+/// Returns a bitmask of threads in the current lane for which \p x is true.
+RPC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
+#ifdef RPC_TARGET_IS_GPU
+  return __gpu_ballot(lane_mask, x);
+#else
+  return x;
+#endif
+}
+
+/// Return \p val aligned "upwards" according to \p align.
+template <typename V, typename A>
+RPC_INLINE constexpr V align_up(V val, A align) {
+  return ((val + V(align) - 1) / V(align)) * V(align);
+}
+
+/// Utility to provide a unified interface between the CPU and GPU's memory
+/// model. On the GPU stack variables are always private to a lane so we can
+/// simply use the variable passed in. On the CPU we need to allocate enough
+/// space for the whole lane and index into it.
+template <typename V> RPC_INLINE V &lane_value(V *val, uint32_t id) {
+  if constexpr (is_process_gpu())
+    return *val;
+  return val[id];
+}
+
+/// Advance the \p p by \p bytes.
+template <typename T, typename U> RPC_INLINE T *advance(T *ptr, U bytes) {
+  if constexpr (is_const<T>::value)
+    return reinterpret_cast<T *>(reinterpret_cast<const uint8_t *>(ptr) +
+                                 bytes);
+  else
+    return reinterpret_cast<T *>(reinterpret_cast<uint8_t *>(ptr) + bytes);
+}
+
+/// Wrapper around the optimal memory copy implementation for the target.
+RPC_INLINE void rpc_memcpy(void *dst, const void *src, size_t count) {
+  __builtin_memcpy(dst, src, count);
+}
+
+template <class T> RPC_INLINE constexpr const T &max(const T &a, const T &b) {
+  return (a < b) ? b : a;
+}
+
+} // namespace rpc
+
+#endif // LLVM_LIBC_SHARED_RPC_UTIL_H
diff --git a/libc/shared/str_to_float.h b/libc/shared/str_to_float.h
new file mode 100644
index 0000000..b133a28
--- /dev/null
+++ b/libc/shared/str_to_float.h
@@ -0,0 +1,27 @@
+//===-- String to float conversion utils ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_STR_TO_FLOAT_H
+#define LLVM_LIBC_SHARED_STR_TO_FLOAT_H
+
+#include "src/__support/str_to_float.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace shared {
+
+using internal::ExpandedFloat;
+using internal::FloatConvertReturn;
+using internal::RoundDirection;
+
+using internal::binary_exp_to_float;
+using internal::decimal_exp_to_float;
+
+} // namespace shared
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SHARED_STR_TO_FLOAT_H
diff --git a/libc/shared/str_to_integer.h b/libc/shared/str_to_integer.h
new file mode 100644
index 0000000..15bee69
--- /dev/null
+++ b/libc/shared/str_to_integer.h
@@ -0,0 +1,24 @@
+//===-- String to int conversion utils --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_STR_TO_INTEGER_H
+#define LLVM_LIBC_SHARED_STR_TO_INTEGER_H
+
+#include "src/__support/str_to_integer.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace shared {
+
+using LIBC_NAMESPACE::StrToNumResult;
+
+using internal::strtointeger;
+
+} // namespace shared
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SHARED_STR_TO_INTEGER_H
diff --git a/src/__support/CPP/algorithm.h b/src/__support/CPP/algorithm.h
index 5120fa0..f5dc906 100644
--- a/src/__support/CPP/algorithm.h
+++ b/src/__support/CPP/algorithm.h
@@ -13,8 +13,9 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_ALGORITHM_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 template <class T> LIBC_INLINE constexpr const T &max(const T &a, const T &b) {
@@ -41,6 +42,6 @@ LIBC_INLINE constexpr bool all_of(InputIt first, InputIt last, UnaryPred p) {
 }
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_ALGORITHM_H
diff --git a/src/__support/CPP/array.h b/src/__support/CPP/array.h
index 4e69ba0..db0a986 100644
--- a/src/__support/CPP/array.h
+++ b/src/__support/CPP/array.h
@@ -11,9 +11,10 @@
 
 #include "src/__support/CPP/iterator.h" // reverse_iterator
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 template <class T, size_t N> struct array {
@@ -74,6 +75,6 @@ template <class T, size_t N> struct array {
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_ARRAY_H
diff --git a/src/__support/CPP/atomic.h b/src/__support/CPP/atomic.h
index e273d99..72e7f2a 100644
--- a/src/__support/CPP/atomic.h
+++ b/src/__support/CPP/atomic.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_ATOMIC_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #include "type_traits.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 enum class MemoryOrder : int {
@@ -211,6 +212,6 @@ LIBC_INLINE void atomic_signal_fence([[maybe_unused]] MemoryOrder mem_ord) {
 }
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_ATOMIC_H
diff --git a/src/__support/CPP/bit.h b/src/__support/CPP/bit.h
index 4aea066..adcd047 100644
--- a/src/__support/CPP/bit.h
+++ b/src/__support/CPP/bit.h
@@ -14,11 +14,13 @@
 #include "src/__support/CPP/limits.h" // numeric_limits
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 #if __has_builtin(__builtin_memcpy_inline)
 #define LLVM_LIBC_HAS_BUILTIN_MEMCPY_INLINE
@@ -290,6 +292,7 @@ ADD_SPECIALIZATION(unsigned long long, __builtin_popcountll)
 #endif // __builtin_popcountg
 #undef ADD_SPECIALIZATION
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_BIT_H
diff --git a/src/__support/CPP/bitset.h b/src/__support/CPP/bitset.h
index 30a7fa7..db193f4 100644
--- a/src/__support/CPP/bitset.h
+++ b/src/__support/CPP/bitset.h
@@ -10,9 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_BITSET_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 template <size_t NumberOfBits> struct bitset {
   static_assert(NumberOfBits != 0,
@@ -86,6 +88,7 @@ private:
   size_t Data[NUMBER_OF_UNITS] = {0};
 };
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_BITSET_H
diff --git a/src/__support/CPP/cstddef.h b/src/__support/CPP/cstddef.h
index 1da51fd..ed6c9d0 100644
--- a/src/__support/CPP/cstddef.h
+++ b/src/__support/CPP/cstddef.h
@@ -10,9 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_CSTDDEF_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "type_traits.h" // For enable_if_t, is_integral_v.
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 enum class byte : unsigned char {};
 
@@ -66,6 +68,7 @@ to_integer(byte b) noexcept {
   return static_cast<IntegerType>(b);
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_CSTDDEF_H
diff --git a/src/__support/CPP/expected.h b/src/__support/CPP/expected.h
index c35f0a1..8a93091 100644
--- a/src/__support/CPP/expected.h
+++ b/src/__support/CPP/expected.h
@@ -10,8 +10,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_EXPECTED_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // This is used to hold an unexpected value so that a different constructor is
 // selected.
@@ -52,6 +54,7 @@ public:
   LIBC_INLINE constexpr const T *operator->() const { return &exp; }
 };
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_EXPECTED_H
diff --git a/src/__support/CPP/functional.h b/src/__support/CPP/functional.h
index 16283a2..50cfa25 100644
--- a/src/__support/CPP/functional.h
+++ b/src/__support/CPP/functional.h
@@ -17,10 +17,11 @@
 #include "src/__support/CPP/type_traits/remove_reference.h"
 #include "src/__support/CPP/utility/forward.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 /// A function type adapted from LLVM's function_ref.
@@ -65,6 +66,6 @@ public:
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_FUNCTIONAL_H
diff --git a/src/__support/CPP/iterator.h b/src/__support/CPP/iterator.h
index b0fd5c9..168a269 100644
--- a/src/__support/CPP/iterator.h
+++ b/src/__support/CPP/iterator.h
@@ -13,8 +13,9 @@
 #include "src/__support/CPP/type_traits/is_convertible.h"
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 template <typename T> struct iterator_traits;
@@ -93,6 +94,6 @@ public:
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_ITERATOR_H
diff --git a/src/__support/CPP/limits.h b/src/__support/CPP/limits.h
index 5b9b3e7..cf4beb9 100644
--- a/src/__support/CPP/limits.h
+++ b/src/__support/CPP/limits.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_LIMITS_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_LIMITS_H
 
-#include "include/llvm-libc-macros/limits-macros.h" // CHAR_BIT
+#include "hdr/limits_macros.h" // CHAR_BIT
 #include "src/__support/CPP/type_traits/is_integral.h"
 #include "src/__support/CPP/type_traits/is_signed.h"
-#include "src/__support/macros/attributes.h"       // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 namespace internal {
@@ -86,6 +87,6 @@ struct numeric_limits<__uint128_t>
 #endif
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_LIMITS_H
diff --git a/src/__support/CPP/mutex.h b/src/__support/CPP/mutex.h
index ff9c9f4..8a31024 100644
--- a/src/__support/CPP/mutex.h
+++ b/src/__support/CPP/mutex.h
@@ -9,7 +9,9 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_MUTEX_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_MUTEX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 // Assume the calling thread has already obtained mutex ownership.
@@ -44,6 +46,6 @@ public:
 template <typename T> lock_guard(T &) -> lock_guard<T>;
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_MUTEX_H
diff --git a/src/__support/CPP/new.cpp b/src/__support/CPP/new.cpp
index 5a40d4a..65f80de 100644
--- a/src/__support/CPP/new.cpp
+++ b/src/__support/CPP/new.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "new.h"
-#include <stdlib.h>
+#include "hdr/func/free.h"
 
 void operator delete(void *mem) noexcept { ::free(mem); }
 
@@ -16,15 +16,29 @@ void operator delete(void *mem, std::align_val_t) noexcept { ::free(mem); }
 void operator delete(void *mem, size_t) noexcept { ::free(mem); }
 
 void operator delete(void *mem, size_t, std::align_val_t) noexcept {
+#ifdef LIBC_TARGET_OS_IS_WINDOWS
+  ::_aligned_free(mem);
+#else
   ::free(mem);
+#endif
 }
 
 void operator delete[](void *mem) noexcept { ::free(mem); }
 
-void operator delete[](void *mem, std::align_val_t) noexcept { ::free(mem); }
+void operator delete[](void *mem, std::align_val_t) noexcept {
+#ifdef LIBC_TARGET_OS_IS_WINDOWS
+  ::_aligned_free(mem);
+#else
+  ::free(mem);
+#endif
+}
 
 void operator delete[](void *mem, size_t) noexcept { ::free(mem); }
 
 void operator delete[](void *mem, size_t, std::align_val_t) noexcept {
+#ifdef LIBC_TARGET_OS_IS_WINDOWS
+  ::_aligned_free(mem);
+#else
   ::free(mem);
+#endif
 }
diff --git a/src/__support/CPP/new.h b/src/__support/CPP/new.h
index 72187b7..8694d9c 100644
--- a/src/__support/CPP/new.h
+++ b/src/__support/CPP/new.h
@@ -9,10 +9,14 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_NEW_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_NEW_H
 
+#include "hdr/func/aligned_alloc.h"
+#include "hdr/func/free.h"
+#include "hdr/func/malloc.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/os.h"
 
 #include <stddef.h> // For size_t
-#include <stdlib.h> // For malloc, free etc.
 
 // Defining members in the std namespace is not preferred. But, we do it here
 // so that we can use it to define the operator new which takes std::align_val_t
@@ -23,7 +27,7 @@ enum class align_val_t : size_t {};
 
 } // namespace std
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 class AllocChecker {
   bool success = false;
@@ -46,13 +50,21 @@ public:
 
   LIBC_INLINE static void *aligned_alloc(size_t s, std::align_val_t align,
                                          AllocChecker &ac) {
+#ifdef LIBC_TARGET_OS_IS_WINDOWS
+    // std::aligned_alloc is not available on Windows because std::free on
+    // Windows cannot deallocate any over-aligned memory. Microsoft provides an
+    // alternative for std::aligned_alloc named _aligned_malloc, but it must be
+    // paired with _aligned_free instead of std::free.
+    void *mem = ::_aligned_malloc(static_cast<size_t>(align), s);
+#else
     void *mem = ::aligned_alloc(static_cast<size_t>(align), s);
+#endif
     ac = (mem != nullptr);
     return mem;
   }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 LIBC_INLINE void *operator new(size_t size,
                                LIBC_NAMESPACE::AllocChecker &ac) noexcept {
diff --git a/src/__support/CPP/optional.h b/src/__support/CPP/optional.h
index 2c0f639..aed2269 100644
--- a/src/__support/CPP/optional.h
+++ b/src/__support/CPP/optional.h
@@ -12,8 +12,9 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/CPP/utility.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 // Trivial nullopt_t struct.
@@ -133,6 +134,6 @@ public:
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_OPTIONAL_H
diff --git a/src/__support/CPP/span.h b/src/__support/CPP/span.h
index a8c1353..e9e3dbf 100644
--- a/src/__support/CPP/span.h
+++ b/src/__support/CPP/span.h
@@ -11,11 +11,13 @@
 #include <stddef.h> // For size_t
 
 #include "array.h"       // For array
+#include "src/__support/macros/config.h"
 #include "type_traits.h" // For remove_cv_t, enable_if_t, is_same_v, is_const_v
 
 #include "src/__support/macros/attributes.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // A trimmed down implementation of std::span.
 // Missing features:
@@ -119,6 +121,7 @@ private:
   size_t span_size;
 };
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_SPAN_H
diff --git a/src/__support/CPP/string.h b/src/__support/CPP/string.h
index cb794e0..dbc0ae0 100644
--- a/src/__support/CPP/string.h
+++ b/src/__support/CPP/string.h
@@ -9,16 +9,19 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_STRING_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_STRING_H
 
+#include "hdr/func/free.h"
+#include "hdr/func/malloc.h"
+#include "hdr/func/realloc.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/integer_to_string.h" // IntegerToString
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/memory_utils/inline_memset.h"
 #include "src/string/string_utils.h" // string_length
 
 #include <stddef.h> // size_t
-#include <stdlib.h> // malloc, free
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 // This class mimics std::string but does not intend to be a full fledged
@@ -225,6 +228,6 @@ LIBC_INLINE string to_string(unsigned long long value) {
 // LIBC_INLINE string to_string(long double value);
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_STRING_H
diff --git a/src/__support/CPP/string_view.h b/src/__support/CPP/string_view.h
index 8aa96fa..745c62c 100644
--- a/src/__support/CPP/string_view.h
+++ b/src/__support/CPP/string_view.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_STRING_VIEW_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 // This is very simple alternate of the std::string_view class. There is no
@@ -30,8 +31,8 @@ private:
 
   LIBC_INLINE static int compareMemory(const char *Lhs, const char *Rhs,
                                        size_t Length) {
-    for (size_t I = 0; I < Length; ++I)
-      if (int Diff = (int)Lhs[I] - (int)Rhs[I])
+    for (size_t i = 0; i < Length; ++i)
+      if (int Diff = (int)Lhs[i] - (int)Rhs[i])
         return Diff;
     return 0;
   }
@@ -214,6 +215,6 @@ public:
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_STRING_VIEW_H
diff --git a/src/__support/CPP/stringstream.h b/src/__support/CPP/stringstream.h
index c8eb59c..a16084c 100644
--- a/src/__support/CPP/stringstream.h
+++ b/src/__support/CPP/stringstream.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_STRINGSTREAM_H
 
 #include "span.h"
+#include "src/__support/macros/config.h"
 #include "string_view.h"
 #include "type_traits.h"
 
 #include "src/__support/integer_to_string.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace cpp {
 
 // This class is to be used to write simple strings into a user provided buffer
@@ -90,6 +91,6 @@ public:
 };
 
 } // namespace cpp
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_STRINGSTREAM_H
diff --git a/src/__support/CPP/type_traits/add_lvalue_reference.h b/src/__support/CPP/type_traits/add_lvalue_reference.h
index 2bca626..6f5fc6b 100644
--- a/src/__support/CPP/type_traits/add_lvalue_reference.h
+++ b/src/__support/CPP/type_traits/add_lvalue_reference.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ADD_LVALUE_REFERENCE_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // add_lvalue_reference
 namespace detail {
@@ -25,6 +27,7 @@ struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {
 template <class T>
 using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ADD_LVALUE_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/add_pointer.h b/src/__support/CPP/type_traits/add_pointer.h
index 1257033..2568a35 100644
--- a/src/__support/CPP/type_traits/add_pointer.h
+++ b/src/__support/CPP/type_traits/add_pointer.h
@@ -10,8 +10,10 @@
 
 #include "src/__support/CPP/type_traits/remove_reference.h"
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // add_pointer
 namespace detail {
@@ -22,6 +24,7 @@ template <class T> auto try_add_pointer(...) -> cpp::type_identity<T>;
 template <class T>
 struct add_pointer : decltype(detail::try_add_pointer<T>(0)) {};
 template <class T> using add_pointer_t = typename add_pointer<T>::type;
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ADD_POINTER_H
diff --git a/src/__support/CPP/type_traits/add_rvalue_reference.h b/src/__support/CPP/type_traits/add_rvalue_reference.h
index 76db671..f51ebf4 100644
--- a/src/__support/CPP/type_traits/add_rvalue_reference.h
+++ b/src/__support/CPP/type_traits/add_rvalue_reference.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ADD_RVALUE_REFERENCE_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // add_rvalue_reference
 namespace detail {
@@ -24,6 +26,7 @@ struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) {
 template <class T>
 using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ADD_RVALUE_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/aligned_storage.h b/src/__support/CPP/type_traits/aligned_storage.h
index 574b114..69ad4cc 100644
--- a/src/__support/CPP/type_traits/aligned_storage.h
+++ b/src/__support/CPP/type_traits/aligned_storage.h
@@ -9,9 +9,11 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ALIGNED_STORAGE_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ALIGNED_STORAGE_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 template <size_t Len, size_t Align> struct aligned_storage {
   struct type {
@@ -22,6 +24,7 @@ template <size_t Len, size_t Align> struct aligned_storage {
 template <size_t Len, size_t Align>
 using aligned_storage_t = typename aligned_storage<Len, Align>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ALIGNED_STORAGE_H
diff --git a/src/__support/CPP/type_traits/always_false.h b/src/__support/CPP/type_traits/always_false.h
index a86e926..218eb9d 100644
--- a/src/__support/CPP/type_traits/always_false.h
+++ b/src/__support/CPP/type_traits/always_false.h
@@ -10,8 +10,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ALWAYS_FALSE_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // This is technically not part of the standard but it come often enough that
 // it's convenient to have around.
@@ -24,6 +26,7 @@ namespace LIBC_NAMESPACE::cpp {
 // Usage `static_assert(cpp::always_false<T>, "error message");`
 template <typename...> LIBC_INLINE_VAR constexpr bool always_false = false;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ALWAYS_FALSE_H
diff --git a/src/__support/CPP/type_traits/bool_constant.h b/src/__support/CPP/type_traits/bool_constant.h
index 72eeaf2..e61a81a 100644
--- a/src/__support/CPP/type_traits/bool_constant.h
+++ b/src/__support/CPP/type_traits/bool_constant.h
@@ -9,12 +9,15 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_BOOL_CONSTANT_H
 
 #include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // bool_constant
 template <bool V> using bool_constant = cpp::integral_constant<bool, V>;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_BOOL_CONSTANT_H
diff --git a/src/__support/CPP/type_traits/conditional.h b/src/__support/CPP/type_traits/conditional.h
index 4fa65a0..effcda0 100644
--- a/src/__support/CPP/type_traits/conditional.h
+++ b/src/__support/CPP/type_traits/conditional.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_CONDITIONAL_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // conditional
 template <bool B, typename T, typename F>
@@ -20,6 +22,7 @@ struct conditional<false, T, F> : type_identity<F> {};
 template <bool B, typename T, typename F>
 using conditional_t = typename conditional<B, T, F>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_CONDITIONAL_H
diff --git a/src/__support/CPP/type_traits/decay.h b/src/__support/CPP/type_traits/decay.h
index f1a1200..c07e9e8 100644
--- a/src/__support/CPP/type_traits/decay.h
+++ b/src/__support/CPP/type_traits/decay.h
@@ -17,8 +17,10 @@
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/CPP/type_traits/remove_extent.h"
 #include "src/__support/CPP/type_traits/remove_reference.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // decay
 template <class T> class decay {
@@ -32,6 +34,7 @@ public:
 };
 template <class T> using decay_t = typename decay<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_DECAY_H
diff --git a/src/__support/CPP/type_traits/enable_if.h b/src/__support/CPP/type_traits/enable_if.h
index cda9189..a2ce203 100644
--- a/src/__support/CPP/type_traits/enable_if.h
+++ b/src/__support/CPP/type_traits/enable_if.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ENABLE_IF_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // enable_if
 template <bool B, typename T = void> struct enable_if;
@@ -18,6 +20,7 @@ template <typename T> struct enable_if<true, T> : type_identity<T> {};
 template <bool B, typename T = void>
 using enable_if_t = typename enable_if<B, T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_ENABLE_IF_H
diff --git a/src/__support/CPP/type_traits/false_type.h b/src/__support/CPP/type_traits/false_type.h
index 97c041c..65934b9 100644
--- a/src/__support/CPP/type_traits/false_type.h
+++ b/src/__support/CPP/type_traits/false_type.h
@@ -9,12 +9,15 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_FALSE_TYPE_H
 
 #include "src/__support/CPP/type_traits/bool_constant.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // false_type
 using false_type = cpp::bool_constant<false>;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_FALSE_TYPE_H
diff --git a/src/__support/CPP/type_traits/integral_constant.h b/src/__support/CPP/type_traits/integral_constant.h
index 7b5b6c2..931a9b9 100644
--- a/src/__support/CPP/type_traits/integral_constant.h
+++ b/src/__support/CPP/type_traits/integral_constant.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_INTEGRAL_CONSTANT_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE_VAR
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // integral_constant
 template <typename T, T v> struct integral_constant {
@@ -18,6 +20,7 @@ template <typename T, T v> struct integral_constant {
   LIBC_INLINE_VAR static constexpr T value = v;
 };
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_INTEGRAL_CONSTANT_H
diff --git a/src/__support/CPP/type_traits/invoke.h b/src/__support/CPP/type_traits/invoke.h
index 94351d8..e4d9be7 100644
--- a/src/__support/CPP/type_traits/invoke.h
+++ b/src/__support/CPP/type_traits/invoke.h
@@ -17,8 +17,10 @@
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/CPP/utility/forward.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 namespace detail {
 
@@ -59,6 +61,7 @@ decltype(auto) invoke(Function &&fun, Args &&...args) {
       cpp::forward<Function>(fun), cpp::forward<Args>(args)...);
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_INVOKE_H
diff --git a/src/__support/CPP/type_traits/invoke_result.h b/src/__support/CPP/type_traits/invoke_result.h
index a6e522f..71d848b 100644
--- a/src/__support/CPP/type_traits/invoke_result.h
+++ b/src/__support/CPP/type_traits/invoke_result.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/invoke.h"
 #include "src/__support/CPP/type_traits/type_identity.h"
 #include "src/__support/CPP/utility/declval.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 template <class F, class... Args>
 struct invoke_result : cpp::type_identity<decltype(cpp::invoke(
@@ -21,6 +23,7 @@ struct invoke_result : cpp::type_identity<decltype(cpp::invoke(
 template <class F, class... Args>
 using invoke_result_t = typename invoke_result<F, Args...>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_INVOKE_RESULT_H
diff --git a/src/__support/CPP/type_traits/is_arithmetic.h b/src/__support/CPP/type_traits/is_arithmetic.h
index 53bb212..33671b0 100644
--- a/src/__support/CPP/type_traits/is_arithmetic.h
+++ b/src/__support/CPP/type_traits/is_arithmetic.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/is_floating_point.h"
 #include "src/__support/CPP/type_traits/is_integral.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_arithmetic
 template <typename T>
@@ -22,6 +24,7 @@ struct is_arithmetic : cpp::bool_constant<(cpp::is_integral_v<T> ||
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_ARITHMETIC_H
diff --git a/src/__support/CPP/type_traits/is_array.h b/src/__support/CPP/type_traits/is_array.h
index 14360b1..f0ab100 100644
--- a/src/__support/CPP/type_traits/is_array.h
+++ b/src/__support/CPP/type_traits/is_array.h
@@ -11,10 +11,12 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h> // For size_t
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_array
 template <class T> struct is_array : false_type {};
@@ -23,6 +25,7 @@ template <class T, size_t N> struct is_array<T[N]> : true_type {};
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_array_v = is_array<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_ARRAY_H
diff --git a/src/__support/CPP/type_traits/is_base_of.h b/src/__support/CPP/type_traits/is_base_of.h
index 47fb568..2efd1bf 100644
--- a/src/__support/CPP/type_traits/is_base_of.h
+++ b/src/__support/CPP/type_traits/is_base_of.h
@@ -14,8 +14,10 @@
 #include "src/__support/CPP/type_traits/remove_all_extents.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_base_of
 namespace detail {
@@ -39,6 +41,7 @@ struct is_base_of
 template <typename Base, typename Derived>
 LIBC_INLINE_VAR constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_BASE_OF_H
diff --git a/src/__support/CPP/type_traits/is_class.h b/src/__support/CPP/type_traits/is_class.h
index 83ebaea..fe12f7d 100644
--- a/src/__support/CPP/type_traits/is_class.h
+++ b/src/__support/CPP/type_traits/is_class.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/is_union.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_class
 namespace detail {
@@ -24,6 +26,7 @@ template <class T> struct is_class : decltype(detail::test<T>(nullptr)) {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_class_v = is_class<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_CLASS_H
diff --git a/src/__support/CPP/type_traits/is_complex.h b/src/__support/CPP/type_traits/is_complex.h
new file mode 100644
index 0000000..23f05c0
--- /dev/null
+++ b/src/__support/CPP/type_traits/is_complex.h
@@ -0,0 +1,53 @@
+//===-- is_complex type_traits ----------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COMPLEX_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COMPLEX_H
+
+#include "src/__support/CPP/type_traits/is_same.h"
+#include "src/__support/CPP/type_traits/remove_cv.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+// LIBC_TYPES_HAS_CFLOAT16 && LIBC_TYPES_HAS_CFLOAT128
+#include "src/__support/macros/properties/complex_types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+// is_complex
+template <typename T> struct is_complex {
+private:
+  template <typename Head, typename... Args>
+  LIBC_INLINE_VAR static constexpr bool __is_unqualified_any_of() {
+    return (... || is_same_v<remove_cv_t<Head>, Args>);
+  }
+
+public:
+  LIBC_INLINE_VAR static constexpr bool value =
+      __is_unqualified_any_of<T, _Complex float, _Complex double,
+                              _Complex long double
+#ifdef LIBC_TYPES_HAS_CFLOAT16
+                              ,
+                              cfloat16
+#endif
+#ifdef LIBC_TYPES_HAS_CFLOAT128
+                              ,
+                              cfloat128
+#endif
+                              >();
+};
+template <typename T>
+LIBC_INLINE_VAR constexpr bool is_complex_v = is_complex<T>::value;
+template <typename T1, typename T2>
+LIBC_INLINE_VAR constexpr bool is_complex_type_same() {
+  return is_same_v<remove_cv_t<T1>, T2>;
+}
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COMPLEX_H
diff --git a/src/__support/CPP/type_traits/is_const.h b/src/__support/CPP/type_traits/is_const.h
index 8e56a9a..b8e60f7 100644
--- a/src/__support/CPP/type_traits/is_const.h
+++ b/src/__support/CPP/type_traits/is_const.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_const
 template <class T> struct is_const : cpp::false_type {};
@@ -20,6 +22,7 @@ template <class T> struct is_const<const T> : cpp::true_type {};
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_const_v = is_const<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_CONST_H
diff --git a/src/__support/CPP/type_traits/is_constant_evaluated.h b/src/__support/CPP/type_traits/is_constant_evaluated.h
index 93cfd07..0bb2d08 100644
--- a/src/__support/CPP/type_traits/is_constant_evaluated.h
+++ b/src/__support/CPP/type_traits/is_constant_evaluated.h
@@ -9,13 +9,16 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_CONSTANT_EVALUATED_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 LIBC_INLINE constexpr bool is_constant_evaluated() {
   return __builtin_is_constant_evaluated();
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_CONSTANT_EVALUATED_H
diff --git a/src/__support/CPP/type_traits/is_convertible.h b/src/__support/CPP/type_traits/is_convertible.h
index d419443..a9f94cb 100644
--- a/src/__support/CPP/type_traits/is_convertible.h
+++ b/src/__support/CPP/type_traits/is_convertible.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/is_void.h"
 #include "src/__support/CPP/utility/declval.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_convertible
 namespace detail {
@@ -40,6 +42,7 @@ template <class From, class To>
 LIBC_INLINE_VAR constexpr bool is_convertible_v =
     is_convertible<From, To>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_CONVERTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_destructible.h b/src/__support/CPP/type_traits/is_destructible.h
index f94fe30..830f22e 100644
--- a/src/__support/CPP/type_traits/is_destructible.h
+++ b/src/__support/CPP/type_traits/is_destructible.h
@@ -16,8 +16,10 @@
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/CPP/type_traits/type_identity.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_destructible
 #if __has_builtin(__is_destructible)
@@ -60,6 +62,7 @@ template <> struct is_destructible<void> : public false_type {};
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_destructible_v = is_destructible<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_DESTRUCTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_enum.h b/src/__support/CPP/type_traits/is_enum.h
index 8d55a1c..623ae07 100644
--- a/src/__support/CPP/type_traits/is_enum.h
+++ b/src/__support/CPP/type_traits/is_enum.h
@@ -10,14 +10,17 @@
 
 #include "src/__support/CPP/type_traits/bool_constant.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_enum
 template <typename T> struct is_enum : bool_constant<__is_enum(T)> {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_enum_v = is_enum<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_ENUM_H
diff --git a/src/__support/CPP/type_traits/is_fixed_point.h b/src/__support/CPP/type_traits/is_fixed_point.h
index 025268b..9df2a77 100644
--- a/src/__support/CPP/type_traits/is_fixed_point.h
+++ b/src/__support/CPP/type_traits/is_fixed_point.h
@@ -13,8 +13,10 @@
 #include "src/__support/macros/attributes.h"
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_fixed_point
 #ifdef LIBC_COMPILER_HAS_FIXED_POINT
@@ -41,6 +43,7 @@ template <typename T> struct is_fixed_point : false_type {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_fixed_point_v = is_fixed_point<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_FIXED_POINT_H
diff --git a/src/__support/CPP/type_traits/is_floating_point.h b/src/__support/CPP/type_traits/is_floating_point.h
index 49b51dc..11ffbfa 100644
--- a/src/__support/CPP/type_traits/is_floating_point.h
+++ b/src/__support/CPP/type_traits/is_floating_point.h
@@ -11,9 +11,11 @@
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_FLOAT128
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_floating_point
 template <typename T> struct is_floating_point {
@@ -40,6 +42,7 @@ template <typename T>
 LIBC_INLINE_VAR constexpr bool is_floating_point_v =
     is_floating_point<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_FLOATING_POINT_H
diff --git a/src/__support/CPP/type_traits/is_function.h b/src/__support/CPP/type_traits/is_function.h
index 0eba586..f7717f0 100644
--- a/src/__support/CPP/type_traits/is_function.h
+++ b/src/__support/CPP/type_traits/is_function.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/is_const.h"
 #include "src/__support/CPP/type_traits/is_reference.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_function
 #if __has_builtin(__is_function)
@@ -27,6 +29,7 @@ struct is_function
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_function_v = is_function<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_FUNCTION_H
diff --git a/src/__support/CPP/type_traits/is_integral.h b/src/__support/CPP/type_traits/is_integral.h
index 68e16ff..96ba09a 100644
--- a/src/__support/CPP/type_traits/is_integral.h
+++ b/src/__support/CPP/type_traits/is_integral.h
@@ -11,9 +11,11 @@
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_integral
 template <typename T> struct is_integral {
@@ -35,6 +37,7 @@ public:
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_integral_v = is_integral<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_INTEGRAL_H
diff --git a/src/__support/CPP/type_traits/is_lvalue_reference.h b/src/__support/CPP/type_traits/is_lvalue_reference.h
index 1dff57f..e0bfbeb 100644
--- a/src/__support/CPP/type_traits/is_lvalue_reference.h
+++ b/src/__support/CPP/type_traits/is_lvalue_reference.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_lvalue_reference
 #if __has_builtin(__is_lvalue_reference)
@@ -27,6 +29,7 @@ template <class T>
 LIBC_INLINE_VAR constexpr bool is_lvalue_reference_v =
     is_lvalue_reference<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_LVALUE_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/is_member_pointer.h b/src/__support/CPP/type_traits/is_member_pointer.h
index f1f362f..f445670 100644
--- a/src/__support/CPP/type_traits/is_member_pointer.h
+++ b/src/__support/CPP/type_traits/is_member_pointer.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_member_pointer
 template <class T> struct is_member_pointer_helper : cpp::false_type {};
@@ -25,6 +27,7 @@ template <class T>
 LIBC_INLINE_VAR constexpr bool is_member_pointer_v =
     is_member_pointer<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MEMBER_POINTER_H
diff --git a/src/__support/CPP/type_traits/is_null_pointer.h b/src/__support/CPP/type_traits/is_null_pointer.h
index 1445243..acf3413 100644
--- a/src/__support/CPP/type_traits/is_null_pointer.h
+++ b/src/__support/CPP/type_traits/is_null_pointer.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_null_pointer
 using nullptr_t = decltype(nullptr);
@@ -21,6 +23,7 @@ struct is_null_pointer : cpp::is_same<cpp::nullptr_t, cpp::remove_cv_t<T>> {};
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_NULL_POINTER_H
diff --git a/src/__support/CPP/type_traits/is_object.h b/src/__support/CPP/type_traits/is_object.h
index a23bebc..16799fb 100644
--- a/src/__support/CPP/type_traits/is_object.h
+++ b/src/__support/CPP/type_traits/is_object.h
@@ -14,8 +14,10 @@
 #include "src/__support/CPP/type_traits/is_scalar.h"
 #include "src/__support/CPP/type_traits/is_union.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_object
 template <class T>
@@ -25,6 +27,7 @@ struct is_object
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_object_v = is_object<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_OBJECT_H
diff --git a/src/__support/CPP/type_traits/is_pointer.h b/src/__support/CPP/type_traits/is_pointer.h
index 177f8e5..606c8e9 100644
--- a/src/__support/CPP/type_traits/is_pointer.h
+++ b/src/__support/CPP/type_traits/is_pointer.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_pointer
 template <typename T> struct is_pointer : cpp::false_type {};
@@ -23,6 +25,7 @@ template <typename T> struct is_pointer<T *const volatile> : cpp::true_type {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_pointer_v = is_pointer<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_POINTER_H
diff --git a/src/__support/CPP/type_traits/is_reference.h b/src/__support/CPP/type_traits/is_reference.h
index bbfb2b7..12da817 100644
--- a/src/__support/CPP/type_traits/is_reference.h
+++ b/src/__support/CPP/type_traits/is_reference.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_reference
 #if __has_builtin(__is_reference)
@@ -26,6 +28,7 @@ template <typename T> struct is_reference<T &&> : public true_type {};
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_reference_v = is_reference<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/is_rvalue_reference.h b/src/__support/CPP/type_traits/is_rvalue_reference.h
index 3efbbe6..998b635 100644
--- a/src/__support/CPP/type_traits/is_rvalue_reference.h
+++ b/src/__support/CPP/type_traits/is_rvalue_reference.h
@@ -12,8 +12,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_rvalue_reference
 #if __has_builtin(__is_rvalue_reference)
@@ -27,6 +29,7 @@ template <class T>
 LIBC_INLINE_VAR constexpr bool is_rvalue_reference_v =
     is_rvalue_reference<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_RVALUE_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/is_same.h b/src/__support/CPP/type_traits/is_same.h
index eb73952..306d16b 100644
--- a/src/__support/CPP/type_traits/is_same.h
+++ b/src/__support/CPP/type_traits/is_same.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/false_type.h"
 #include "src/__support/CPP/type_traits/true_type.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_same
 template <typename T, typename U> struct is_same : cpp::false_type {};
@@ -20,6 +22,7 @@ template <typename T> struct is_same<T, T> : cpp::true_type {};
 template <typename T, typename U>
 LIBC_INLINE_VAR constexpr bool is_same_v = is_same<T, U>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_SAME_H
diff --git a/src/__support/CPP/type_traits/is_scalar.h b/src/__support/CPP/type_traits/is_scalar.h
index 1f71cde..7f8a750 100644
--- a/src/__support/CPP/type_traits/is_scalar.h
+++ b/src/__support/CPP/type_traits/is_scalar.h
@@ -15,8 +15,10 @@
 #include "src/__support/CPP/type_traits/is_null_pointer.h"
 #include "src/__support/CPP/type_traits/is_pointer.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_scalar
 template <class T>
@@ -27,6 +29,7 @@ struct is_scalar
 template <class T>
 LIBC_INLINE_VAR constexpr bool is_scalar_v = is_scalar<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_SCALAR_H
diff --git a/src/__support/CPP/type_traits/is_signed.h b/src/__support/CPP/type_traits/is_signed.h
index 971fe69..3f56fb3 100644
--- a/src/__support/CPP/type_traits/is_signed.h
+++ b/src/__support/CPP/type_traits/is_signed.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/bool_constant.h"
 #include "src/__support/CPP/type_traits/is_arithmetic.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_signed
 template <typename T>
@@ -23,6 +25,7 @@ struct is_signed : bool_constant<(is_arithmetic_v<T> && (T(-1) < T(0)))> {
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_signed_v = is_signed<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_SIGNED_H
diff --git a/src/__support/CPP/type_traits/is_trivially_constructible.h b/src/__support/CPP/type_traits/is_trivially_constructible.h
index be97b22..b801911 100644
--- a/src/__support/CPP/type_traits/is_trivially_constructible.h
+++ b/src/__support/CPP/type_traits/is_trivially_constructible.h
@@ -9,14 +9,17 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_TRIVIALLY_CONSTRUCTIBLE_H
 
 #include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_trivially_constructible
 template <class T, class... Args>
 struct is_trivially_constructible
     : integral_constant<bool, __is_trivially_constructible(T, Args...)> {};
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_TRIVIALLY_CONSTRUCTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_trivially_copyable.h b/src/__support/CPP/type_traits/is_trivially_copyable.h
index b4c825d..68e56c8 100644
--- a/src/__support/CPP/type_traits/is_trivially_copyable.h
+++ b/src/__support/CPP/type_traits/is_trivially_copyable.h
@@ -9,14 +9,17 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_TRIVIALLY_COPYABLE_H
 
 #include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_trivially_copyable
 template <class T>
 struct is_trivially_copyable
     : public integral_constant<bool, __is_trivially_copyable(T)> {};
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_TRIVIALLY_COPYABLE_H
diff --git a/src/__support/CPP/type_traits/is_trivially_destructible.h b/src/__support/CPP/type_traits/is_trivially_destructible.h
index 37e0e86..d727a0e 100644
--- a/src/__support/CPP/type_traits/is_trivially_destructible.h
+++ b/src/__support/CPP/type_traits/is_trivially_destructible.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/bool_constant.h"
 #include "src/__support/CPP/type_traits/is_destructible.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_trivially_destructible
 #if __has_builtin(__is_trivially_destructible)
@@ -29,6 +31,7 @@ template <typename T>
 LIBC_INLINE_VAR constexpr bool is_trivially_destructible_v =
     is_trivially_destructible<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_TRIVIALLY_DESTRUCTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_union.h b/src/__support/CPP/type_traits/is_union.h
index 04e78a8..00ca11a 100644
--- a/src/__support/CPP/type_traits/is_union.h
+++ b/src/__support/CPP/type_traits/is_union.h
@@ -10,14 +10,17 @@
 
 #include "src/__support/CPP/type_traits/bool_constant.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_union
 template <class T> struct is_union : bool_constant<__is_union(T)> {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_union_v = is_union<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_UNION_H
diff --git a/src/__support/CPP/type_traits/is_unsigned.h b/src/__support/CPP/type_traits/is_unsigned.h
index f089c2b..eed519b 100644
--- a/src/__support/CPP/type_traits/is_unsigned.h
+++ b/src/__support/CPP/type_traits/is_unsigned.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/bool_constant.h"
 #include "src/__support/CPP/type_traits/is_arithmetic.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_unsigned
 template <typename T>
@@ -23,6 +25,7 @@ struct is_unsigned : bool_constant<(is_arithmetic_v<T> && (T(-1) > T(0)))> {
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_unsigned_v = is_unsigned<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_UNSIGNED_H
diff --git a/src/__support/CPP/type_traits/is_void.h b/src/__support/CPP/type_traits/is_void.h
index 040dc83..30459dc 100644
--- a/src/__support/CPP/type_traits/is_void.h
+++ b/src/__support/CPP/type_traits/is_void.h
@@ -11,14 +11,17 @@
 #include "src/__support/CPP/type_traits/is_same.h"
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // is_void
 template <typename T> struct is_void : is_same<void, remove_cv_t<T>> {};
 template <typename T>
 LIBC_INLINE_VAR constexpr bool is_void_v = is_void<T>::value;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_VOID_H
diff --git a/src/__support/CPP/type_traits/make_signed.h b/src/__support/CPP/type_traits/make_signed.h
index 4652d8b..00bc6be 100644
--- a/src/__support/CPP/type_traits/make_signed.h
+++ b/src/__support/CPP/type_traits/make_signed.h
@@ -9,9 +9,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_MAKE_SIGNED_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // make_signed
 template <typename T> struct make_signed;
@@ -33,6 +35,7 @@ template <> struct make_signed<__uint128_t> : type_identity<__int128_t> {};
 #endif
 template <typename T> using make_signed_t = typename make_signed<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_MAKE_SIGNED_H
diff --git a/src/__support/CPP/type_traits/make_unsigned.h b/src/__support/CPP/type_traits/make_unsigned.h
index 1e814ae..e5f60ae 100644
--- a/src/__support/CPP/type_traits/make_unsigned.h
+++ b/src/__support/CPP/type_traits/make_unsigned.h
@@ -9,9 +9,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_MAKE_UNSIGNED_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // make_unsigned
 
@@ -38,6 +40,7 @@ template <> struct make_unsigned<__uint128_t> : type_identity<__uint128_t> {};
 #endif
 template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_MAKE_UNSIGNED_H
diff --git a/src/__support/CPP/type_traits/remove_all_extents.h b/src/__support/CPP/type_traits/remove_all_extents.h
index 5941b82..bc577ca 100644
--- a/src/__support/CPP/type_traits/remove_all_extents.h
+++ b/src/__support/CPP/type_traits/remove_all_extents.h
@@ -9,10 +9,12 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_ALL_EXTENTS_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // remove_all_extents
 #if __has_builtin(__remove_all_extents)
@@ -33,6 +35,7 @@ template <typename T>
 using remove_all_extents_t = typename remove_all_extents<T>::type;
 #endif
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_ALL_EXTENTS_H
diff --git a/src/__support/CPP/type_traits/remove_cv.h b/src/__support/CPP/type_traits/remove_cv.h
index 3cd7e59..2e843e0 100644
--- a/src/__support/CPP/type_traits/remove_cv.h
+++ b/src/__support/CPP/type_traits/remove_cv.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_CV_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // remove_cv
 template <class T> struct remove_cv : cpp::type_identity<T> {};
@@ -20,6 +22,7 @@ template <class T>
 struct remove_cv<const volatile T> : cpp::type_identity<T> {};
 template <class T> using remove_cv_t = typename remove_cv<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_CV_H
diff --git a/src/__support/CPP/type_traits/remove_cvref.h b/src/__support/CPP/type_traits/remove_cvref.h
index 6b410bb..2759178 100644
--- a/src/__support/CPP/type_traits/remove_cvref.h
+++ b/src/__support/CPP/type_traits/remove_cvref.h
@@ -10,8 +10,10 @@
 
 #include "src/__support/CPP/type_traits/remove_cv.h"
 #include "src/__support/CPP/type_traits/remove_reference.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // remove_cvref
 template <typename T> struct remove_cvref {
@@ -19,6 +21,7 @@ template <typename T> struct remove_cvref {
 };
 template <typename T> using remove_cvref_t = typename remove_cvref<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_CVREF_H
diff --git a/src/__support/CPP/type_traits/remove_extent.h b/src/__support/CPP/type_traits/remove_extent.h
index 3c0759d..4f5ffd3 100644
--- a/src/__support/CPP/type_traits/remove_extent.h
+++ b/src/__support/CPP/type_traits/remove_extent.h
@@ -9,9 +9,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_EXTENT_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 #include "stddef.h" // size_t
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // remove_extent
 template <class T> struct remove_extent : cpp::type_identity<T> {};
@@ -20,6 +22,7 @@ template <class T, size_t N>
 struct remove_extent<T[N]> : cpp::type_identity<T> {};
 template <class T> using remove_extent_t = typename remove_extent<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_EXTENT_H
diff --git a/src/__support/CPP/type_traits/remove_reference.h b/src/__support/CPP/type_traits/remove_reference.h
index 02a0bd6..26ded08 100644
--- a/src/__support/CPP/type_traits/remove_reference.h
+++ b/src/__support/CPP/type_traits/remove_reference.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_REFERENCE_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // remove_reference
 template <class T> struct remove_reference : cpp::type_identity<T> {};
@@ -19,6 +21,7 @@ template <class T> struct remove_reference<T &&> : cpp::type_identity<T> {};
 template <class T>
 using remove_reference_t = typename remove_reference<T>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_REMOVE_REFERENCE_H
diff --git a/src/__support/CPP/type_traits/true_type.h b/src/__support/CPP/type_traits/true_type.h
index 60ffc8a..55f8a53 100644
--- a/src/__support/CPP/type_traits/true_type.h
+++ b/src/__support/CPP/type_traits/true_type.h
@@ -9,12 +9,15 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_TRUE_TYPE_H
 
 #include "src/__support/CPP/type_traits/bool_constant.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // true_type
 using true_type = cpp::bool_constant<true>;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_TRUE_TYPE_H
diff --git a/src/__support/CPP/type_traits/type_identity.h b/src/__support/CPP/type_traits/type_identity.h
index f33a43a..304a1ed 100644
--- a/src/__support/CPP/type_traits/type_identity.h
+++ b/src/__support/CPP/type_traits/type_identity.h
@@ -8,13 +8,17 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_TYPE_IDENTITY_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_TYPE_IDENTITY_H
 
-namespace LIBC_NAMESPACE::cpp {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // type_identity
 template <typename T> struct type_identity {
   using type = T;
 };
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_TYPE_IDENTITY_H
diff --git a/src/__support/CPP/type_traits/void_t.h b/src/__support/CPP/type_traits/void_t.h
index babdacc..9018860 100644
--- a/src/__support/CPP/type_traits/void_t.h
+++ b/src/__support/CPP/type_traits/void_t.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_VOID_T_H
 
 #include "src/__support/CPP/type_traits/type_identity.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // void_t
 
@@ -21,6 +23,7 @@ template <typename... Ts> struct make_void : cpp::type_identity<void> {};
 template <typename... Ts>
 using void_t = typename detail::make_void<Ts...>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_VOID_T_H
diff --git a/src/__support/CPP/utility/declval.h b/src/__support/CPP/utility/declval.h
index 0d00aa6..9b963b9 100644
--- a/src/__support/CPP/utility/declval.h
+++ b/src/__support/CPP/utility/declval.h
@@ -10,8 +10,10 @@
 
 #include "src/__support/CPP/type_traits/add_rvalue_reference.h"
 #include "src/__support/CPP/type_traits/always_false.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // declval
 template <typename T> cpp::add_rvalue_reference_t<T> declval() {
@@ -19,6 +21,7 @@ template <typename T> cpp::add_rvalue_reference_t<T> declval() {
                 "declval not allowed in an evaluated context");
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_DECLVAL_H
diff --git a/src/__support/CPP/utility/forward.h b/src/__support/CPP/utility/forward.h
index 891097e..085b3d1 100644
--- a/src/__support/CPP/utility/forward.h
+++ b/src/__support/CPP/utility/forward.h
@@ -11,8 +11,10 @@
 #include "src/__support/CPP/type_traits/is_lvalue_reference.h"
 #include "src/__support/CPP/type_traits/remove_reference.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // forward
 template <typename T>
@@ -27,6 +29,7 @@ LIBC_INLINE constexpr T &&forward(remove_reference_t<T> &&value) {
   return static_cast<T &&>(value);
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_FORWARD_H
diff --git a/src/__support/CPP/utility/in_place.h b/src/__support/CPP/utility/in_place.h
index 3aace22..3967eb1 100644
--- a/src/__support/CPP/utility/in_place.h
+++ b/src/__support/CPP/utility/in_place.h
@@ -9,10 +9,12 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_IN_PLACE_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE, LIBC_INLINE_VAR
+#include "src/__support/macros/config.h"
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // in_place
 struct in_place_t {
@@ -25,12 +27,13 @@ template <class T> struct in_place_type_t {
 };
 template <class T> LIBC_INLINE_VAR constexpr in_place_type_t<T> in_place_type{};
 
-template <size_t I> struct in_place_index_t {
+template <size_t IDX> struct in_place_index_t {
   LIBC_INLINE explicit in_place_index_t() = default;
 };
-template <size_t I>
-LIBC_INLINE_VAR constexpr in_place_index_t<I> in_place_index{};
+template <size_t IDX>
+LIBC_INLINE_VAR constexpr in_place_index_t<IDX> in_place_index{};
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_IN_PLACE_H
diff --git a/src/__support/CPP/utility/integer_sequence.h b/src/__support/CPP/utility/integer_sequence.h
index 2ed26df..06643d5 100644
--- a/src/__support/CPP/utility/integer_sequence.h
+++ b/src/__support/CPP/utility/integer_sequence.h
@@ -9,8 +9,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_INTEGER_SEQUENCE_H
 
 #include "src/__support/CPP/type_traits/is_integral.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // integer_sequence
 template <typename T, T... Ints> struct integer_sequence {
@@ -32,6 +34,7 @@ template <typename T, int N>
 using make_integer_sequence =
     typename detail::make_integer_sequence<T, N - 1>::type;
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_INTEGER_SEQUENCE_H
diff --git a/src/__support/CPP/utility/move.h b/src/__support/CPP/utility/move.h
index 4fec5e6..b61f723 100644
--- a/src/__support/CPP/utility/move.h
+++ b/src/__support/CPP/utility/move.h
@@ -10,8 +10,10 @@
 
 #include "src/__support/CPP/type_traits/remove_reference.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 // move
 template <class T>
@@ -19,6 +21,7 @@ LIBC_INLINE constexpr cpp::remove_reference_t<T> &&move(T &&t) {
   return static_cast<typename cpp::remove_reference_t<T> &&>(t);
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CPP_UTILITY_MOVE_H
diff --git a/src/__support/FPUtil/BasicOperations.h b/src/__support/FPUtil/BasicOperations.h
index 17eee7b..2357b05 100644
--- a/src/__support/FPUtil/BasicOperations.h
+++ b/src/__support/FPUtil/BasicOperations.h
@@ -11,14 +11,18 @@
 
 #include "FEnvImpl.h"
 #include "FPBits.h"
+#include "dyadic_float.h"
 
-#include "FEnvImpl.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/big_int.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+#include "src/__support/macros/properties/architectures.h"
+#include "src/__support/macros/properties/types.h"
 #include "src/__support/uint128.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -26,6 +30,90 @@ LIBC_INLINE T abs(T x) {
   return FPBits<T>(x).abs().get_val();
 }
 
+namespace internal {
+
+template <typename T>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<T>, T> max(T x, T y) {
+  FPBits<T> x_bits(x);
+  FPBits<T> y_bits(y);
+
+  // To make sure that fmax(+0, -0) == +0 == fmax(-0, +0), whenever x and y
+  // have different signs and both are not NaNs, we return the number with
+  // positive sign.
+  if (x_bits.sign() != y_bits.sign())
+    return x_bits.is_pos() ? x : y;
+  return x > y ? x : y;
+}
+
+#ifdef LIBC_TYPES_HAS_FLOAT16
+#if defined(__LIBC_USE_BUILTIN_FMAXF16_FMINF16)
+template <> LIBC_INLINE float16 max(float16 x, float16 y) {
+  return __builtin_fmaxf16(x, y);
+}
+#elif !defined(LIBC_TARGET_ARCH_IS_AARCH64)
+template <> LIBC_INLINE float16 max(float16 x, float16 y) {
+  FPBits<float16> x_bits(x);
+  FPBits<float16> y_bits(y);
+
+  int16_t xi = static_cast<int16_t>(x_bits.uintval());
+  int16_t yi = static_cast<int16_t>(y_bits.uintval());
+  return ((xi > yi) != (xi < 0 && yi < 0)) ? x : y;
+}
+#endif
+#endif // LIBC_TYPES_HAS_FLOAT16
+
+#if defined(__LIBC_USE_BUILTIN_FMAX_FMIN) && !defined(LIBC_TARGET_ARCH_IS_X86)
+template <> LIBC_INLINE float max(float x, float y) {
+  return __builtin_fmaxf(x, y);
+}
+
+template <> LIBC_INLINE double max(double x, double y) {
+  return __builtin_fmax(x, y);
+}
+#endif
+
+template <typename T>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<T>, T> min(T x, T y) {
+  FPBits<T> x_bits(x);
+  FPBits<T> y_bits(y);
+
+  // To make sure that fmin(+0, -0) == -0 == fmin(-0, +0), whenever x and y have
+  // different signs and both are not NaNs, we return the number with negative
+  // sign.
+  if (x_bits.sign() != y_bits.sign())
+    return x_bits.is_neg() ? x : y;
+  return x < y ? x : y;
+}
+
+#ifdef LIBC_TYPES_HAS_FLOAT16
+#if defined(__LIBC_USE_BUILTIN_FMAXF16_FMINF16)
+template <> LIBC_INLINE float16 min(float16 x, float16 y) {
+  return __builtin_fminf16(x, y);
+}
+#elif !defined(LIBC_TARGET_ARCH_IS_AARCH64)
+template <> LIBC_INLINE float16 min(float16 x, float16 y) {
+  FPBits<float16> x_bits(x);
+  FPBits<float16> y_bits(y);
+
+  int16_t xi = static_cast<int16_t>(x_bits.uintval());
+  int16_t yi = static_cast<int16_t>(y_bits.uintval());
+  return ((xi < yi) != (xi < 0 && yi < 0)) ? x : y;
+}
+#endif
+#endif // LIBC_TYPES_HAS_FLOAT16
+
+#if defined(__LIBC_USE_BUILTIN_FMAX_FMIN) && !defined(LIBC_TARGET_ARCH_IS_X86)
+template <> LIBC_INLINE float min(float x, float y) {
+  return __builtin_fminf(x, y);
+}
+
+template <> LIBC_INLINE double min(double x, double y) {
+  return __builtin_fmin(x, y);
+}
+#endif
+
+} // namespace internal
+
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
 LIBC_INLINE T fmin(T x, T y) {
   const FPBits<T> bitx(x), bity(y);
@@ -34,12 +122,7 @@ LIBC_INLINE T fmin(T x, T y) {
     return y;
   if (bity.is_nan())
     return x;
-  if (bitx.sign() != bity.sign())
-    // To make sure that fmin(+0, -0) == -0 == fmin(-0, +0), whenever x and
-    // y has different signs and both are not NaNs, we return the number
-    // with negative sign.
-    return bitx.is_neg() ? x : y;
-  return x < y ? x : y;
+  return internal::min(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -50,12 +133,7 @@ LIBC_INLINE T fmax(T x, T y) {
     return y;
   if (bity.is_nan())
     return x;
-  if (bitx.sign() != bity.sign())
-    // To make sure that fmax(+0, -0) == +0 == fmax(-0, +0), whenever x and
-    // y has different signs and both are not NaNs, we return the number
-    // with positive sign.
-    return bitx.is_neg() ? y : x;
-  return x > y ? x : y;
+  return internal::max(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -66,9 +144,7 @@ LIBC_INLINE T fmaximum(T x, T y) {
     return x;
   if (bity.is_nan())
     return y;
-  if (bitx.sign() != bity.sign())
-    return (bitx.is_neg() ? y : x);
-  return x > y ? x : y;
+  return internal::max(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -79,9 +155,7 @@ LIBC_INLINE T fminimum(T x, T y) {
     return x;
   if (bity.is_nan())
     return y;
-  if (bitx.sign() != bity.sign())
-    return (bitx.is_neg()) ? x : y;
-  return x < y ? x : y;
+  return internal::min(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -96,9 +170,7 @@ LIBC_INLINE T fmaximum_num(T x, T y) {
     return y;
   if (bity.is_nan())
     return x;
-  if (bitx.sign() != bity.sign())
-    return (bitx.is_neg() ? y : x);
-  return x > y ? x : y;
+  return internal::max(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -113,9 +185,7 @@ LIBC_INLINE T fminimum_num(T x, T y) {
     return y;
   if (bity.is_nan())
     return x;
-  if (bitx.sign() != bity.sign())
-    return (bitx.is_neg() ? x : y);
-  return x < y ? x : y;
+  return internal::min(x, y);
 }
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -177,6 +247,13 @@ LIBC_INLINE T fdim(T x, T y) {
   return (x > y ? x - y : 0);
 }
 
+// Avoid reusing `issignaling` macro.
+template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int issignaling_impl(const T &x) {
+  FPBits<T> sx(x);
+  return sx.is_signaling_nan();
+}
+
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
 LIBC_INLINE int canonicalize(T &cx, const T &x) {
   FPBits<T> sx(x);
@@ -251,12 +328,8 @@ totalorder(T x, T y) {
   StorageType x_u = x_bits.uintval();
   StorageType y_u = y_bits.uintval();
 
-  using signed_t = cpp::make_signed_t<StorageType>;
-  signed_t x_signed = static_cast<signed_t>(x_u);
-  signed_t y_signed = static_cast<signed_t>(y_u);
-
-  bool both_neg = (x_u & y_u & FPBits::SIGN_MASK) != 0;
-  return x_signed == y_signed || ((x_signed <= y_signed) != both_neg);
+  bool has_neg = ((x_u | y_u) & FPBits::SIGN_MASK) != 0;
+  return x_u == y_u || ((x_u < y_u) != has_neg);
 }
 
 template <typename T>
@@ -268,12 +341,21 @@ totalordermag(T x, T y) {
 template <typename T>
 LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<T>, T> getpayload(T x) {
   using FPBits = FPBits<T>;
+  using StorageType = typename FPBits::StorageType;
   FPBits x_bits(x);
 
   if (!x_bits.is_nan())
     return T(-1.0);
 
-  return T(x_bits.uintval() & (FPBits::FRACTION_MASK >> 1));
+  StorageType payload = x_bits.uintval() & (FPBits::FRACTION_MASK >> 1);
+
+  if constexpr (is_big_int_v<StorageType>) {
+    DyadicFloat<FPBits::STORAGE_LEN> payload_dfloat(Sign::POS, 0, payload);
+
+    return static_cast<T>(payload_dfloat);
+  } else {
+    return static_cast<T>(payload);
+  }
 }
 
 template <bool IsSignaling, typename T>
@@ -298,7 +380,8 @@ setpayload(T &res, T pl) {
   }
 
   using StorageType = typename FPBits::StorageType;
-  StorageType v(pl_bits.get_explicit_mantissa() >> (FPBits::SIG_LEN - pl_exp));
+  StorageType v(pl_bits.get_explicit_mantissa() >>
+                (FPBits::FRACTION_LEN - pl_exp));
 
   if constexpr (IsSignaling)
     res = FPBits::signaling_nan(Sign::POS, v).get_val();
@@ -308,6 +391,6 @@ setpayload(T &res, T pl) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_BASICOPERATIONS_H
diff --git a/src/__support/FPUtil/DivisionAndRemainderOperations.h b/src/__support/FPUtil/DivisionAndRemainderOperations.h
index eee05c6..fda3387 100644
--- a/src/__support/FPUtil/DivisionAndRemainderOperations.h
+++ b/src/__support/FPUtil/DivisionAndRemainderOperations.h
@@ -15,8 +15,9 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 static constexpr int QUOTIENT_LSB_BITS = 3;
@@ -115,6 +116,6 @@ LIBC_INLINE T remquo(T x, T y, int &q) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_DIVISIONANDREMAINDEROPERATIONS_H
diff --git a/src/__support/FPUtil/FEnvImpl.h b/src/__support/FPUtil/FEnvImpl.h
index 13e668b..1c5a110 100644
--- a/src/__support/FPUtil/FEnvImpl.h
+++ b/src/__support/FPUtil/FEnvImpl.h
@@ -13,6 +13,7 @@
 #include "hdr/math_macros.h"
 #include "hdr/types/fenv_t.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/errno/libc_errno.h"
 
@@ -30,11 +31,12 @@
 #include "x86_64/FEnvImpl.h"
 #elif defined(LIBC_TARGET_ARCH_IS_ARM) && defined(__ARM_FP)
 #include "arm/FEnvImpl.h"
-#elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
+#elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV) && defined(__riscv_flen)
 #include "riscv/FEnvImpl.h"
 #else
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
 
 // All dummy functions silently succeed.
 
@@ -62,10 +64,18 @@ LIBC_INLINE int get_env(fenv_t *) { return 0; }
 
 LIBC_INLINE int set_env(const fenv_t *) { return 0; }
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 #endif
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
+
+LIBC_INLINE int clear_except_if_required(int excepts) {
+  if (math_errhandling & MATH_ERREXCEPT)
+    return clear_except(excepts);
+  return 0;
+}
 
 LIBC_INLINE int set_except_if_required(int excepts) {
   if (math_errhandling & MATH_ERREXCEPT)
@@ -84,6 +94,7 @@ LIBC_INLINE void set_errno_if_required(int err) {
     libc_errno = err;
 }
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_FENVIMPL_H
diff --git a/src/__support/FPUtil/FMA.h b/src/__support/FPUtil/FMA.h
index cf01a31..807d685 100644
--- a/src/__support/FPUtil/FMA.h
+++ b/src/__support/FPUtil/FMA.h
@@ -11,10 +11,11 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/generic/FMA.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <typename OutType, typename InType>
@@ -33,6 +34,6 @@ template <> LIBC_INLINE double fma(double x, double y, double z) {
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_FMA_H
diff --git a/src/__support/FPUtil/FPBits.h b/src/__support/FPUtil/FPBits.h
index 559ecde..90b6e40 100644
--- a/src/__support/FPUtil/FPBits.h
+++ b/src/__support/FPUtil/FPBits.h
@@ -6,6 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This file is shared with libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
+
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_FPBITS_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_FPBITS_H
 
@@ -14,6 +20,7 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"       // LIBC_ASSERT
 #include "src/__support/macros/attributes.h" // LIBC_INLINE, LIBC_INLINE_VAR
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_FLOAT128
 #include "src/__support/math_extras.h"             // mask_trailing_ones
 #include "src/__support/sign.h"                    // Sign
@@ -21,7 +28,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 // The supported floating point types.
@@ -120,7 +127,11 @@ template <> struct FPLayout<FPType::IEEE754_Binary128> {
 };
 
 template <> struct FPLayout<FPType::X86_Binary80> {
+#if __SIZEOF_LONG_DOUBLE__ == 12
+  using StorageType = UInt<__SIZEOF_LONG_DOUBLE__ * CHAR_BIT>;
+#else
   using StorageType = UInt128;
+#endif
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int EXP_LEN = 15;
   LIBC_INLINE_VAR static constexpr int SIG_LEN = 64;
@@ -794,6 +805,12 @@ template <typename T> LIBC_INLINE static constexpr FPType get_fp_type() {
     static_assert(cpp::always_false<UnqualT>, "Unsupported type");
 }
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
 // A generic class to manipulate C++ floating point formats.
 // It derives its functionality to FPRepImpl above.
 template <typename T>
@@ -824,6 +841,6 @@ struct FPBits final : public internal::FPRepImpl<get_fp_type<T>(), FPBits<T>> {
 };
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_FPBITS_H
diff --git a/src/__support/FPUtil/Hypot.h b/src/__support/FPUtil/Hypot.h
index 76b1f07..6aa8084 100644
--- a/src/__support/FPUtil/Hypot.h
+++ b/src/__support/FPUtil/Hypot.h
@@ -16,9 +16,10 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/uint128.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 namespace internal {
@@ -108,45 +109,39 @@ LIBC_INLINE T hypot(T x, T y) {
   using StorageType = typename FPBits<T>::StorageType;
   using DStorageType = typename DoubleLength<StorageType>::Type;
 
-  FPBits_t x_bits(x), y_bits(y);
+  FPBits_t x_abs = FPBits_t(x).abs();
+  FPBits_t y_abs = FPBits_t(y).abs();
 
-  if (x_bits.is_inf() || y_bits.is_inf()) {
-    return FPBits_t::inf().get_val();
-  }
-  if (x_bits.is_nan()) {
-    return x;
-  }
-  if (y_bits.is_nan()) {
+  bool x_abs_larger = x_abs.uintval() >= y_abs.uintval();
+
+  FPBits_t a_bits = x_abs_larger ? x_abs : y_abs;
+  FPBits_t b_bits = x_abs_larger ? y_abs : x_abs;
+
+  if (LIBC_UNLIKELY(a_bits.is_inf_or_nan())) {
+    if (x_abs.is_signaling_nan() || y_abs.is_signaling_nan()) {
+      fputil::raise_except_if_required(FE_INVALID);
+      return FPBits_t::quiet_nan().get_val();
+    }
+    if (x_abs.is_inf() || y_abs.is_inf())
+      return FPBits_t::inf().get_val();
+    if (x_abs.is_nan())
+      return x;
+    // y is nan
     return y;
   }
 
-  uint16_t x_exp = x_bits.get_biased_exponent();
-  uint16_t y_exp = y_bits.get_biased_exponent();
-  uint16_t exp_diff = (x_exp > y_exp) ? (x_exp - y_exp) : (y_exp - x_exp);
+  uint16_t a_exp = a_bits.get_biased_exponent();
+  uint16_t b_exp = b_bits.get_biased_exponent();
 
-  if ((exp_diff >= FPBits_t::FRACTION_LEN + 2) || (x == 0) || (y == 0)) {
-    return abs(x) + abs(y);
-  }
+  if ((a_exp - b_exp >= FPBits_t::FRACTION_LEN + 2) || (x == 0) || (y == 0))
+    return x_abs.get_val() + y_abs.get_val();
 
-  uint16_t a_exp, b_exp, out_exp;
-  StorageType a_mant, b_mant;
+  uint64_t out_exp = a_exp;
+  StorageType a_mant = a_bits.get_mantissa();
+  StorageType b_mant = b_bits.get_mantissa();
   DStorageType a_mant_sq, b_mant_sq;
   bool sticky_bits;
 
-  if (abs(x) >= abs(y)) {
-    a_exp = x_exp;
-    a_mant = x_bits.get_mantissa();
-    b_exp = y_exp;
-    b_mant = y_bits.get_mantissa();
-  } else {
-    a_exp = y_exp;
-    a_mant = y_bits.get_mantissa();
-    b_exp = x_exp;
-    b_mant = x_bits.get_mantissa();
-  }
-
-  out_exp = a_exp;
-
   // Add an extra bit to simplify the final rounding bit computation.
   constexpr StorageType ONE = StorageType(1) << (FPBits_t::FRACTION_LEN + 1);
 
@@ -164,11 +159,10 @@ LIBC_INLINE T hypot(T x, T y) {
     a_exp = 1;
   }
 
-  if (b_exp != 0) {
+  if (b_exp != 0)
     b_mant |= ONE;
-  } else {
+  else
     b_exp = 1;
-  }
 
   a_mant_sq = static_cast<DStorageType>(a_mant) * a_mant;
   b_mant_sq = static_cast<DStorageType>(b_mant) * b_mant;
@@ -259,10 +253,14 @@ LIBC_INLINE T hypot(T x, T y) {
   }
 
   y_new |= static_cast<StorageType>(out_exp) << FPBits_t::FRACTION_LEN;
+
+  if (!(round_bit || sticky_bits || (r != 0)))
+    fputil::clear_except_if_required(FE_INEXACT);
+
   return cpp::bit_cast<T>(y_new);
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_HYPOT_H
diff --git a/src/__support/FPUtil/ManipulationFunctions.h b/src/__support/FPUtil/ManipulationFunctions.h
index 97c4312..9c10011 100644
--- a/src/__support/FPUtil/ManipulationFunctions.h
+++ b/src/__support/FPUtil/ManipulationFunctions.h
@@ -12,6 +12,7 @@
 #include "FPBits.h"
 #include "NearestIntegerOperations.h"
 #include "NormalFloat.h"
+#include "cast.h"
 #include "dyadic_float.h"
 #include "rounding_mode.h"
 
@@ -21,16 +22,25 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
 LIBC_INLINE T frexp(T x, int &exp) {
   FPBits<T> bits(x);
-  if (bits.is_inf_or_nan())
+  if (bits.is_inf_or_nan()) {
+#ifdef LIBC_FREXP_INF_NAN_EXPONENT
+    // The value written back to the second parameter when calling
+    // frexp/frexpf/frexpl` with `+/-Inf`/`NaN` is unspecified in the standard.
+    // Set the exp value for Inf/NaN inputs explicitly to
+    // LIBC_FREXP_INF_NAN_EXPONENT if it is defined.
+    exp = LIBC_FREXP_INF_NAN_EXPONENT;
+#endif // LIBC_FREXP_INF_NAN_EXPONENT
     return x;
+  }
   if (bits.is_zero()) {
     exp = 0;
     return x;
@@ -191,7 +201,8 @@ ldexp(T x, U exp) {
   // For all other values, NormalFloat to T conversion handles it the right way.
   DyadicFloat<FPBits<T>::STORAGE_LEN> normal(bits.get_val());
   normal.exponent += static_cast<int>(exp);
-  return static_cast<T>(normal);
+  // TODO: Add tests for exceptions.
+  return normal.template as<T, /*ShouldRaiseExceptions=*/true>();
 }
 
 template <typename T, typename U,
@@ -206,17 +217,17 @@ LIBC_INLINE T nextafter(T from, U to) {
 
   FPBits<U> to_bits(to);
   if (to_bits.is_nan())
-    return static_cast<T>(to);
+    return cast<T>(to);
 
   // NOTE: This would work only if `U` has a greater or equal precision than
   // `T`. Otherwise `from` could loose its precision and the following statement
   // could incorrectly evaluate to `true`.
-  if (static_cast<U>(from) == to)
-    return static_cast<T>(to);
+  if (cast<U>(from) == to)
+    return cast<T>(to);
 
   using StorageType = typename FPBits<T>::StorageType;
   if (from != T(0)) {
-    if ((static_cast<U>(from) < to) == (from > T(0))) {
+    if ((cast<U>(from) < to) == (from > T(0))) {
       from_bits = FPBits<T>(StorageType(from_bits.uintval() + 1));
     } else {
       from_bits = FPBits<T>(StorageType(from_bits.uintval() - 1));
@@ -258,7 +269,7 @@ LIBC_INLINE constexpr T nextupdown(T x) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #ifdef LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 #include "x86_64/NextAfterLongDouble.h"
diff --git a/src/__support/FPUtil/NearestIntegerOperations.h b/src/__support/FPUtil/NearestIntegerOperations.h
index 741e24a..9316661 100644
--- a/src/__support/FPUtil/NearestIntegerOperations.h
+++ b/src/__support/FPUtil/NearestIntegerOperations.h
@@ -16,8 +16,9 @@
 #include "hdr/math_macros.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
@@ -75,15 +76,17 @@ LIBC_INLINE T ceil(T x) {
   }
 
   uint32_t trim_size = FPBits<T>::FRACTION_LEN - exponent;
-  StorageType trunc_mantissa =
-      static_cast<StorageType>((bits.get_mantissa() >> trim_size) << trim_size);
-  bits.set_mantissa(trunc_mantissa);
-  T trunc_value = bits.get_val();
+  StorageType x_u = bits.uintval();
+  StorageType trunc_u =
+      static_cast<StorageType>((x_u >> trim_size) << trim_size);
 
   // If x is already an integer, return it.
-  if (trunc_value == x)
+  if (trunc_u == x_u)
     return x;
 
+  bits.set_uintval(trunc_u);
+  T trunc_value = bits.get_val();
+
   // If x is negative, the ceil operation is equivalent to the trunc operation.
   if (is_neg)
     return trunc_value;
@@ -130,15 +133,17 @@ LIBC_INLINE T round(T x) {
   uint32_t trim_size = FPBits<T>::FRACTION_LEN - exponent;
   bool half_bit_set =
       bool(bits.get_mantissa() & (StorageType(1) << (trim_size - 1)));
-  StorageType trunc_mantissa =
-      static_cast<StorageType>((bits.get_mantissa() >> trim_size) << trim_size);
-  bits.set_mantissa(trunc_mantissa);
-  T trunc_value = bits.get_val();
+  StorageType x_u = bits.uintval();
+  StorageType trunc_u =
+      static_cast<StorageType>((x_u >> trim_size) << trim_size);
 
   // If x is already an integer, return it.
-  if (trunc_value == x)
+  if (trunc_u == x_u)
     return x;
 
+  bits.set_uintval(trunc_u);
+  T trunc_value = bits.get_val();
+
   if (!half_bit_set) {
     // Franctional part is less than 0.5 so round value is the
     // same as the trunc value.
@@ -188,18 +193,20 @@ round_using_specific_rounding_mode(T x, int rnd) {
   }
 
   uint32_t trim_size = FPBits<T>::FRACTION_LEN - exponent;
-  FPBits<T> new_bits = bits;
-  StorageType trunc_mantissa =
-      static_cast<StorageType>((bits.get_mantissa() >> trim_size) << trim_size);
-  new_bits.set_mantissa(trunc_mantissa);
-  T trunc_value = new_bits.get_val();
+  StorageType x_u = bits.uintval();
+  StorageType trunc_u =
+      static_cast<StorageType>((x_u >> trim_size) << trim_size);
 
   // If x is already an integer, return it.
-  if (trunc_value == x)
+  if (trunc_u == x_u)
     return x;
 
+  FPBits<T> new_bits(trunc_u);
+  T trunc_value = new_bits.get_val();
+
   StorageType trim_value =
-      bits.get_mantissa() & ((StorageType(1) << trim_size) - 1);
+      bits.get_mantissa() &
+      static_cast<StorageType>(((StorageType(1) << trim_size) - 1));
   StorageType half_value =
       static_cast<StorageType>((StorageType(1) << (trim_size - 1)));
   // If exponent is 0, trimSize will be equal to the mantissa width, and
@@ -339,13 +346,14 @@ fromfpx(T x, int rnd, unsigned int width) {
 
 namespace internal {
 
-template <typename F, typename I,
-          cpp::enable_if_t<cpp::is_floating_point_v<F> && cpp::is_integral_v<I>,
+template <typename FloatType, typename IntType,
+          cpp::enable_if_t<cpp::is_floating_point_v<FloatType> &&
+                               cpp::is_integral_v<IntType>,
                            int> = 0>
-LIBC_INLINE I rounded_float_to_signed_integer(F x) {
-  constexpr I INTEGER_MIN = (I(1) << (sizeof(I) * 8 - 1));
-  constexpr I INTEGER_MAX = -(INTEGER_MIN + 1);
-  FPBits<F> bits(x);
+LIBC_INLINE IntType rounded_float_to_signed_integer(FloatType x) {
+  constexpr IntType INTEGER_MIN = (IntType(1) << (sizeof(IntType) * 8 - 1));
+  constexpr IntType INTEGER_MAX = -(INTEGER_MIN + 1);
+  FPBits<FloatType> bits(x);
   auto set_domain_error_and_raise_invalid = []() {
     set_errno_if_required(EDOM);
     raise_except_if_required(FE_INVALID);
@@ -357,7 +365,7 @@ LIBC_INLINE I rounded_float_to_signed_integer(F x) {
   }
 
   int exponent = bits.get_exponent();
-  constexpr int EXPONENT_LIMIT = sizeof(I) * 8 - 1;
+  constexpr int EXPONENT_LIMIT = sizeof(IntType) * 8 - 1;
   if (exponent > EXPONENT_LIMIT) {
     set_domain_error_and_raise_invalid();
     return bits.is_neg() ? INTEGER_MIN : INTEGER_MAX;
@@ -367,33 +375,37 @@ LIBC_INLINE I rounded_float_to_signed_integer(F x) {
       return bits.is_neg() ? INTEGER_MIN : INTEGER_MAX;
     }
     // If the control reaches here, then it means that the rounded
-    // value is the most negative number for the signed integer type I.
+    // value is the most negative number for the signed integer type IntType.
   }
 
-  // For all other cases, if `x` can fit in the integer type `I`,
+  // For all other cases, if `x` can fit in the integer type `IntType`,
   // we just return `x`. static_cast will convert the floating
   // point value to the exact integer value.
-  return static_cast<I>(x);
+  return static_cast<IntType>(x);
 }
 
 } // namespace internal
 
-template <typename F, typename I,
-          cpp::enable_if_t<cpp::is_floating_point_v<F> && cpp::is_integral_v<I>,
+template <typename FloatType, typename IntType,
+          cpp::enable_if_t<cpp::is_floating_point_v<FloatType> &&
+                               cpp::is_integral_v<IntType>,
                            int> = 0>
-LIBC_INLINE I round_to_signed_integer(F x) {
-  return internal::rounded_float_to_signed_integer<F, I>(round(x));
+LIBC_INLINE IntType round_to_signed_integer(FloatType x) {
+  return internal::rounded_float_to_signed_integer<FloatType, IntType>(
+      round(x));
 }
 
-template <typename F, typename I,
-          cpp::enable_if_t<cpp::is_floating_point_v<F> && cpp::is_integral_v<I>,
+template <typename FloatType, typename IntType,
+          cpp::enable_if_t<cpp::is_floating_point_v<FloatType> &&
+                               cpp::is_integral_v<IntType>,
                            int> = 0>
-LIBC_INLINE I round_to_signed_integer_using_current_rounding_mode(F x) {
-  return internal::rounded_float_to_signed_integer<F, I>(
+LIBC_INLINE IntType
+round_to_signed_integer_using_current_rounding_mode(FloatType x) {
+  return internal::rounded_float_to_signed_integer<FloatType, IntType>(
       round_using_current_rounding_mode(x));
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_NEARESTINTEGEROPERATIONS_H
diff --git a/src/__support/FPUtil/NormalFloat.h b/src/__support/FPUtil/NormalFloat.h
index 413d204..b4cbb50 100644
--- a/src/__support/FPUtil/NormalFloat.h
+++ b/src/__support/FPUtil/NormalFloat.h
@@ -13,10 +13,11 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 // A class which stores the normalized form of a floating point value.
@@ -267,6 +268,6 @@ template <> LIBC_INLINE NormalFloat<long double>::operator long double() const {
 #endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_NORMALFLOAT_H
diff --git a/src/__support/FPUtil/PolyEval.h b/src/__support/FPUtil/PolyEval.h
index 7a63845..4110462 100644
--- a/src/__support/FPUtil/PolyEval.h
+++ b/src/__support/FPUtil/PolyEval.h
@@ -12,6 +12,7 @@
 #include "multiply_add.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 // Evaluate polynomial using Horner's Scheme:
 // With polyeval(x, a_0, a_1, ..., a_n) = a_n * x^n + ... + a_1 * x + a_0, we
@@ -20,7 +21,7 @@
 // Example: to evaluate x^3 + 2*x^2 + 3*x + 4, call
 //   polyeval( x, 4.0, 3.0, 2.0, 1.0 )
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <typename T>
@@ -48,6 +49,6 @@ polyeval(T x, T a0, Ts... a) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_POLYEVAL_H
diff --git a/src/__support/FPUtil/aarch64/FEnvImpl.h b/src/__support/FPUtil/aarch64/FEnvImpl.h
index cd8a597..3cea977 100644
--- a/src/__support/FPUtil/aarch64/FEnvImpl.h
+++ b/src/__support/FPUtil/aarch64/FEnvImpl.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_FENVIMPL_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_AARCH64) || defined(__APPLE__)
@@ -23,7 +24,7 @@
 #include "hdr/types/fenv_t.h"
 #include "src/__support/FPUtil/FPBits.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 struct FEnv {
@@ -279,6 +280,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_FENVIMPL_H
diff --git a/src/__support/FPUtil/aarch64/fenv_darwin_impl.h b/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
index feb48e3..969e707 100644
--- a/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
+++ b/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_FENV_DARWIN_IMPL_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_AARCH64) || !defined(__APPLE__)
@@ -23,7 +24,7 @@
 #include "hdr/types/fenv_t.h"
 #include "src/__support/FPUtil/FPBits.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 struct FEnv {
@@ -284,6 +285,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_FENV_DARWIN_IMPL_H
diff --git a/src/__support/FPUtil/aarch64/nearest_integer.h b/src/__support/FPUtil/aarch64/nearest_integer.h
index ca07630..d5ea067 100644
--- a/src/__support/FPUtil/aarch64/nearest_integer.h
+++ b/src/__support/FPUtil/aarch64/nearest_integer.h
@@ -10,13 +10,14 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_NEAREST_INTEGER_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_AARCH64)
 #error "Invalid include"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 LIBC_INLINE float nearest_integer(float x) {
@@ -32,6 +33,6 @@ LIBC_INLINE double nearest_integer(double x) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_NEAREST_INTEGER_H
diff --git a/src/__support/FPUtil/aarch64/sqrt.h b/src/__support/FPUtil/aarch64/sqrt.h
index bad7e31..b69267f 100644
--- a/src/__support/FPUtil/aarch64/sqrt.h
+++ b/src/__support/FPUtil/aarch64/sqrt.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_SQRT_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_AARCH64)
@@ -18,7 +19,7 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <> LIBC_INLINE float sqrt<float>(float x) {
@@ -34,6 +35,6 @@ template <> LIBC_INLINE double sqrt<double>(double x) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_AARCH64_SQRT_H
diff --git a/src/__support/FPUtil/arm/FEnvImpl.h b/src/__support/FPUtil/arm/FEnvImpl.h
index cb8d31d..aaf37c0 100644
--- a/src/__support/FPUtil/arm/FEnvImpl.h
+++ b/src/__support/FPUtil/arm/FEnvImpl.h
@@ -13,9 +13,10 @@
 #include "hdr/types/fenv_t.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/macros/attributes.h" // For LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 struct FEnv {
@@ -260,6 +261,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_ARM_FENVIMPL_H
diff --git a/src/__support/FPUtil/cast.h b/src/__support/FPUtil/cast.h
new file mode 100644
index 0000000..126f385
--- /dev/null
+++ b/src/__support/FPUtil/cast.h
@@ -0,0 +1,65 @@
+//===-- Conversion between floating-point types -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_CAST_H
+#define LLVM_LIBC_SRC___SUPPORT_FPUTIL_CAST_H
+
+#include "FPBits.h"
+#include "dyadic_float.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/algorithm.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE::fputil {
+
+template <typename OutType, typename InType>
+LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                           cpp::is_floating_point_v<InType>,
+                                       OutType>
+cast(InType x) {
+#if defined(LIBC_TYPES_HAS_FLOAT16) && !defined(__LIBC_USE_FLOAT16_CONVERSION)
+  if constexpr (cpp::is_same_v<OutType, float16> ||
+                cpp::is_same_v<InType, float16>) {
+    using InFPBits = FPBits<InType>;
+    using InStorageType = typename InFPBits::StorageType;
+    using OutFPBits = FPBits<OutType>;
+    using OutStorageType = typename OutFPBits::StorageType;
+
+    InFPBits x_bits(x);
+
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        raise_except_if_required(FE_INVALID);
+        return OutFPBits::quiet_nan().get_val();
+      }
+
+      InStorageType x_mant = x_bits.get_mantissa();
+      if (InFPBits::FRACTION_LEN > OutFPBits::FRACTION_LEN)
+        x_mant >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+      return OutFPBits::quiet_nan(x_bits.sign(),
+                                  static_cast<OutStorageType>(x_mant))
+          .get_val();
+    }
+
+    if (x_bits.is_inf())
+      return OutFPBits::inf(x_bits.sign()).get_val();
+
+    constexpr size_t MAX_FRACTION_LEN =
+        cpp::max(OutFPBits::FRACTION_LEN, InFPBits::FRACTION_LEN);
+    DyadicFloat<cpp::bit_ceil(MAX_FRACTION_LEN)> xd(x);
+    return xd.template as<OutType, /*ShouldSignalExceptions=*/true>();
+  }
+#endif
+
+  return static_cast<OutType>(x);
+}
+
+} // namespace LIBC_NAMESPACE::fputil
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_CAST_H
diff --git a/src/__support/FPUtil/double_double.h b/src/__support/FPUtil/double_double.h
index b9490b5..db3c2c8 100644
--- a/src/__support/FPUtil/double_double.h
+++ b/src/__support/FPUtil/double_double.h
@@ -11,22 +11,36 @@
 
 #include "multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 #include "src/__support/number_pair.h"
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
+
+#define DEFAULT_DOUBLE_SPLIT 27
 
 using DoubleDouble = LIBC_NAMESPACE::NumberPair<double>;
 
 // The output of Dekker's FastTwoSum algorithm is correct, i.e.:
 //   r.hi + r.lo = a + b exactly
 //   and |r.lo| < eps(r.lo)
-// if ssumption: |a| >= |b|, or a = 0.
+// Assumption: |a| >= |b|, or a = 0.
+template <bool FAST2SUM = true>
 LIBC_INLINE constexpr DoubleDouble exact_add(double a, double b) {
   DoubleDouble r{0.0, 0.0};
-  r.hi = a + b;
-  double t = r.hi - a;
-  r.lo = b - t;
+  if constexpr (FAST2SUM) {
+    r.hi = a + b;
+    double t = r.hi - a;
+    r.lo = b - t;
+  } else {
+    r.hi = a + b;
+    double t1 = r.hi - a;
+    double t2 = r.hi - t1;
+    double t3 = b - t1;
+    double t4 = a - t2;
+    r.lo = t3 + t4;
+  }
   return r;
 }
 
@@ -40,15 +54,21 @@ LIBC_INLINE constexpr DoubleDouble add(const DoubleDouble &a,
 
 // Assumption: |a.hi| >= |b|
 LIBC_INLINE constexpr DoubleDouble add(const DoubleDouble &a, double b) {
-  DoubleDouble r = exact_add(a.hi, b);
+  DoubleDouble r = exact_add<false>(a.hi, b);
   return exact_add(r.hi, r.lo + a.lo);
 }
 
-// Velkamp's Splitting for double precision.
+// Veltkamp's Splitting for double precision.
+// Note: This is proved to be correct for all rounding modes:
+//   Zimmermann, P., "Note on the Veltkamp/Dekker Algorithms with Directed
+//   Roundings," https://inria.hal.science/hal-04480440.
+// Default splitting constant = 2^ceil(prec(double)/2) + 1 = 2^27 + 1.
+template <size_t N = DEFAULT_DOUBLE_SPLIT>
 LIBC_INLINE constexpr DoubleDouble split(double a) {
   DoubleDouble r{0.0, 0.0};
-  // Splitting constant = 2^ceil(prec(double)/2) + 1 = 2^27 + 1.
-  constexpr double C = 0x1.0p27 + 1.0;
+  // CN = 2^N.
+  constexpr double CN = static_cast<double>(1 << N);
+  constexpr double C = CN + 1.0;
   double t1 = C * a;
   double t2 = a - t1;
   r.hi = t1 + t2;
@@ -56,6 +76,30 @@ LIBC_INLINE constexpr DoubleDouble split(double a) {
   return r;
 }
 
+// Helper for non-fma exact mult where the first number is already split.
+template <size_t SPLIT_B = DEFAULT_DOUBLE_SPLIT>
+LIBC_INLINE DoubleDouble exact_mult(const DoubleDouble &as, double a,
+                                    double b) {
+  DoubleDouble bs = split<SPLIT_B>(b);
+  DoubleDouble r{0.0, 0.0};
+
+  r.hi = a * b;
+  double t1 = as.hi * bs.hi - r.hi;
+  double t2 = as.hi * bs.lo + t1;
+  double t3 = as.lo * bs.hi + t2;
+  r.lo = as.lo * bs.lo + t3;
+
+  return r;
+}
+
+// Note: When FMA instruction is not available, the `exact_mult` function is
+// only correct for round-to-nearest mode.  See:
+//   Zimmermann, P., "Note on the Veltkamp/Dekker Algorithms with Directed
+//   Roundings," https://inria.hal.science/hal-04480440.
+// Using Theorem 1 in the paper above, without FMA instruction, if we restrict
+// the generated constants to precision <= 51, and splitting it by 2^28 + 1,
+// then a * b = r.hi + r.lo is exact for all rounding modes.
+template <size_t SPLIT_B = 27>
 LIBC_INLINE DoubleDouble exact_mult(double a, double b) {
   DoubleDouble r{0.0, 0.0};
 
@@ -65,12 +109,8 @@ LIBC_INLINE DoubleDouble exact_mult(double a, double b) {
 #else
   // Dekker's Product.
   DoubleDouble as = split(a);
-  DoubleDouble bs = split(b);
-  r.hi = a * b;
-  double t1 = as.hi * bs.hi - r.hi;
-  double t2 = as.hi * bs.lo + t1;
-  double t3 = as.lo * bs.hi + t2;
-  r.lo = as.lo * bs.lo + t3;
+
+  r = exact_mult<SPLIT_B>(as, a, b);
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
   return r;
@@ -82,9 +122,10 @@ LIBC_INLINE DoubleDouble quick_mult(double a, const DoubleDouble &b) {
   return r;
 }
 
+template <size_t SPLIT_B = 27>
 LIBC_INLINE DoubleDouble quick_mult(const DoubleDouble &a,
                                     const DoubleDouble &b) {
-  DoubleDouble r = exact_mult(a.hi, b.hi);
+  DoubleDouble r = exact_mult<SPLIT_B>(a.hi, b.hi);
   double t1 = multiply_add(a.hi, b.lo, r.lo);
   double t2 = multiply_add(a.lo, b.hi, t1);
   r.lo = t2;
@@ -99,6 +140,43 @@ LIBC_INLINE DoubleDouble multiply_add<DoubleDouble>(const DoubleDouble &a,
   return add(c, quick_mult(a, b));
 }
 
-} // namespace LIBC_NAMESPACE::fputil
+// Accurate double-double division, following Karp-Markstein's trick for
+// division, implemented in the CORE-MATH project at:
+// https://gitlab.inria.fr/core-math/core-math/-/blob/master/src/binary64/tan/tan.c#L1855
+//
+// Error bounds:
+// Let a = ah + al, b = bh + bl.
+// Let r = rh + rl be the approximation of (ah + al) / (bh + bl).
+// Then:
+//   (ah + al) / (bh + bl) - rh =
+// = ((ah - bh * rh) + (al - bl * rh)) / (bh + bl)
+// = (1 + O(bl/bh)) * ((ah - bh * rh) + (al - bl * rh)) / bh
+// Let q = round(1/bh), then the above expressions are approximately:
+// = (1 + O(bl / bh)) * (1 + O(2^-52)) * q * ((ah - bh * rh) + (al - bl * rh))
+// So we can compute:
+//   rl = q * (ah - bh * rh) + q * (al - bl * rh)
+// as accurate as possible, then the error is bounded by:
+//   |(ah + al) / (bh + bl) - (rh + rl)| < O(bl/bh) * (2^-52 + al/ah + bl/bh)
+LIBC_INLINE DoubleDouble div(const DoubleDouble &a, const DoubleDouble &b) {
+  DoubleDouble r;
+  double q = 1.0 / b.hi;
+  r.hi = a.hi * q;
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+  double e_hi = fputil::multiply_add(b.hi, -r.hi, a.hi);
+  double e_lo = fputil::multiply_add(b.lo, -r.hi, a.lo);
+#else
+  DoubleDouble b_hi_r_hi = fputil::exact_mult(b.hi, -r.hi);
+  DoubleDouble b_lo_r_hi = fputil::exact_mult(b.lo, -r.hi);
+  double e_hi = (a.hi + b_hi_r_hi.hi) + b_hi_r_hi.lo;
+  double e_lo = (a.lo + b_lo_r_hi.hi) + b_lo_r_hi.lo;
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+  r.lo = q * (e_hi + e_lo);
+  return r;
+}
+
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_DOUBLE_DOUBLE_H
diff --git a/src/__support/FPUtil/dyadic_float.h b/src/__support/FPUtil/dyadic_float.h
index 63cb983..289fd01 100644
--- a/src/__support/FPUtil/dyadic_float.h
+++ b/src/__support/FPUtil/dyadic_float.h
@@ -9,15 +9,22 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_DYADIC_FLOAT_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_DYADIC_FLOAT_H
 
+#include "FEnvImpl.h"
 #include "FPBits.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
 #include "multiply_add.h"
+#include "rounding_mode.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/big_int.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+#include "src/__support/macros/properties/types.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
 
 // A generic class to perform computations of high precision floating points.
 // We store the value in dyadic format, including 3 fields:
@@ -66,16 +73,26 @@ template <size_t Bits> struct DyadicFloat {
   }
 
   // Used for aligning exponents.  Output might not be normalized.
-  LIBC_INLINE constexpr DyadicFloat &shift_left(int shift_length) {
-    exponent -= shift_length;
-    mantissa <<= static_cast<size_t>(shift_length);
+  LIBC_INLINE constexpr DyadicFloat &shift_left(unsigned shift_length) {
+    if (shift_length < Bits) {
+      exponent -= static_cast<int>(shift_length);
+      mantissa <<= shift_length;
+    } else {
+      exponent = 0;
+      mantissa = MantissaType(0);
+    }
     return *this;
   }
 
   // Used for aligning exponents.  Output might not be normalized.
-  LIBC_INLINE constexpr DyadicFloat &shift_right(int shift_length) {
-    exponent += shift_length;
-    mantissa >>= static_cast<size_t>(shift_length);
+  LIBC_INLINE constexpr DyadicFloat &shift_right(unsigned shift_length) {
+    if (shift_length < Bits) {
+      exponent += static_cast<int>(shift_length);
+      mantissa >>= shift_length;
+    } else {
+      exponent = 0;
+      mantissa = MantissaType(0);
+    }
     return *this;
   }
 
@@ -84,13 +101,120 @@ template <size_t Bits> struct DyadicFloat {
     return exponent + (Bits - 1);
   }
 
-  // Assume that it is already normalized.
-  // Output is rounded correctly with respect to the current rounding mode.
-  template <typename T,
+#ifdef LIBC_TYPES_HAS_FLOAT16
+  template <typename T, bool ShouldSignalExceptions>
+  LIBC_INLINE constexpr cpp::enable_if_t<
+      cpp::is_floating_point_v<T> && (FPBits<T>::FRACTION_LEN < Bits), T>
+  generic_as() const {
+    using FPBits = FPBits<float16>;
+    using StorageType = typename FPBits::StorageType;
+
+    constexpr int EXTRA_FRACTION_LEN = Bits - 1 - FPBits::FRACTION_LEN;
+
+    if (mantissa == 0)
+      return FPBits::zero(sign).get_val();
+
+    int unbiased_exp = get_unbiased_exponent();
+
+    if (unbiased_exp + FPBits::EXP_BIAS >= FPBits::MAX_BIASED_EXPONENT) {
+      if constexpr (ShouldSignalExceptions) {
+        set_errno_if_required(ERANGE);
+        raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+      }
+
+      switch (quick_get_round()) {
+      case FE_TONEAREST:
+        return FPBits::inf(sign).get_val();
+      case FE_TOWARDZERO:
+        return FPBits::max_normal(sign).get_val();
+      case FE_DOWNWARD:
+        if (sign.is_pos())
+          return FPBits::max_normal(Sign::POS).get_val();
+        return FPBits::inf(Sign::NEG).get_val();
+      case FE_UPWARD:
+        if (sign.is_neg())
+          return FPBits::max_normal(Sign::NEG).get_val();
+        return FPBits::inf(Sign::POS).get_val();
+      default:
+        __builtin_unreachable();
+      }
+    }
+
+    StorageType out_biased_exp = 0;
+    StorageType out_mantissa = 0;
+    bool round = false;
+    bool sticky = false;
+    bool underflow = false;
+
+    if (unbiased_exp < -FPBits::EXP_BIAS - FPBits::FRACTION_LEN) {
+      sticky = true;
+      underflow = true;
+    } else if (unbiased_exp == -FPBits::EXP_BIAS - FPBits::FRACTION_LEN) {
+      round = true;
+      MantissaType sticky_mask = (MantissaType(1) << (Bits - 1)) - 1;
+      sticky = (mantissa & sticky_mask) != 0;
+    } else {
+      int extra_fraction_len = EXTRA_FRACTION_LEN;
+
+      if (unbiased_exp < 1 - FPBits::EXP_BIAS) {
+        underflow = true;
+        extra_fraction_len += 1 - FPBits::EXP_BIAS - unbiased_exp;
+      } else {
+        out_biased_exp =
+            static_cast<StorageType>(unbiased_exp + FPBits::EXP_BIAS);
+      }
+
+      MantissaType round_mask = MantissaType(1) << (extra_fraction_len - 1);
+      round = (mantissa & round_mask) != 0;
+      MantissaType sticky_mask = round_mask - 1;
+      sticky = (mantissa & sticky_mask) != 0;
+
+      out_mantissa = static_cast<StorageType>(mantissa >> extra_fraction_len);
+    }
+
+    bool lsb = (out_mantissa & 1) != 0;
+
+    StorageType result =
+        FPBits::create_value(sign, out_biased_exp, out_mantissa).uintval();
+
+    switch (quick_get_round()) {
+    case FE_TONEAREST:
+      if (round && (lsb || sticky))
+        ++result;
+      break;
+    case FE_DOWNWARD:
+      if (sign.is_neg() && (round || sticky))
+        ++result;
+      break;
+    case FE_UPWARD:
+      if (sign.is_pos() && (round || sticky))
+        ++result;
+      break;
+    default:
+      break;
+    }
+
+    if (ShouldSignalExceptions && (round || sticky)) {
+      int excepts = FE_INEXACT;
+      if (FPBits(result).is_inf()) {
+        set_errno_if_required(ERANGE);
+        excepts |= FE_OVERFLOW;
+      } else if (underflow) {
+        set_errno_if_required(ERANGE);
+        excepts |= FE_UNDERFLOW;
+      }
+      raise_except_if_required(excepts);
+    }
+
+    return FPBits(result).get_val();
+  }
+#endif // LIBC_TYPES_HAS_FLOAT16
+
+  template <typename T, bool ShouldSignalExceptions,
             typename = cpp::enable_if_t<cpp::is_floating_point_v<T> &&
                                             (FPBits<T>::FRACTION_LEN < Bits),
                                         void>>
-  LIBC_INLINE explicit constexpr operator T() const {
+  LIBC_INLINE constexpr T fast_as() const {
     if (LIBC_UNLIKELY(mantissa.is_zero()))
       return FPBits<T>::zero(sign).get_val();
 
@@ -107,7 +231,17 @@ template <size_t Bits> struct DyadicFloat {
       T d_hi =
           FPBits<T>::create_value(sign, 2 * FPBits<T>::EXP_BIAS, IMPLICIT_MASK)
               .get_val();
-      return T(2) * d_hi;
+      // volatile prevents constant propagation that would result in infinity
+      // always being returned no matter the current rounding mode.
+      volatile T two = static_cast<T>(2.0);
+      T r = two * d_hi;
+
+      // TODO: Whether rounding down the absolute value to max_normal should
+      // also raise FE_OVERFLOW and set ERANGE is debatable.
+      if (ShouldSignalExceptions && FPBits<T>(r).is_inf())
+        set_errno_if_required(ERANGE);
+
+      return r;
     }
 
     bool denorm = false;
@@ -145,13 +279,13 @@ template <size_t Bits> struct DyadicFloat {
       // d_lo is denormal, but the output is normal.
       int scale_up_exponent = 1 - exp_lo;
       T scale_up_factor =
-          FPBits<T>::create_value(sign,
+          FPBits<T>::create_value(Sign::POS,
                                   static_cast<output_bits_t>(
                                       FPBits<T>::EXP_BIAS + scale_up_exponent),
                                   IMPLICIT_MASK)
               .get_val();
       T scale_down_factor =
-          FPBits<T>::create_value(sign,
+          FPBits<T>::create_value(Sign::POS,
                                   static_cast<output_bits_t>(
                                       FPBits<T>::EXP_BIAS - scale_up_exponent),
                                   IMPLICIT_MASK)
@@ -179,10 +313,20 @@ template <size_t Bits> struct DyadicFloat {
       output_bits_t clear_exp = static_cast<output_bits_t>(
           output_bits_t(exp_hi) << FPBits<T>::SIG_LEN);
       output_bits_t r_bits = FPBits<T>(r).uintval() - clear_exp;
+
       if (!(r_bits & FPBits<T>::EXP_MASK)) {
         // Output is denormal after rounding, clear the implicit bit for 80-bit
         // long double.
         r_bits -= IMPLICIT_MASK;
+
+        // TODO: IEEE Std 754-2019 lets implementers choose whether to check for
+        // "tininess" before or after rounding for base-2 formats, as long as
+        // the same choice is made for all operations. Our choice to check after
+        // rounding might not be the same as the hardware's.
+        if (ShouldSignalExceptions && round_and_sticky) {
+          set_errno_if_required(ERANGE);
+          raise_except_if_required(FE_UNDERFLOW);
+        }
       }
 
       return FPBits<T>(r_bits).get_val();
@@ -191,7 +335,29 @@ template <size_t Bits> struct DyadicFloat {
     return r;
   }
 
-  LIBC_INLINE explicit constexpr operator MantissaType() const {
+  // Assume that it is already normalized.
+  // Output is rounded correctly with respect to the current rounding mode.
+  template <typename T, bool ShouldSignalExceptions,
+            typename = cpp::enable_if_t<cpp::is_floating_point_v<T> &&
+                                            (FPBits<T>::FRACTION_LEN < Bits),
+                                        void>>
+  LIBC_INLINE constexpr T as() const {
+#if defined(LIBC_TYPES_HAS_FLOAT16) && !defined(__LIBC_USE_FLOAT16_CONVERSION)
+    if constexpr (cpp::is_same_v<T, float16>)
+      return generic_as<T, ShouldSignalExceptions>();
+#endif
+    return fast_as<T, ShouldSignalExceptions>();
+  }
+
+  template <typename T,
+            typename = cpp::enable_if_t<cpp::is_floating_point_v<T> &&
+                                            (FPBits<T>::FRACTION_LEN < Bits),
+                                        void>>
+  LIBC_INLINE explicit constexpr operator T() const {
+    return as<T, /*ShouldSignalExceptions=*/false>();
+  }
+
+  LIBC_INLINE constexpr MantissaType as_mantissa_type() const {
     if (mantissa.is_zero())
       return 0;
 
@@ -232,9 +398,9 @@ LIBC_INLINE constexpr DyadicFloat<Bits> quick_add(DyadicFloat<Bits> a,
 
   // Align exponents
   if (a.exponent > b.exponent)
-    b.shift_right(a.exponent - b.exponent);
+    b.shift_right(static_cast<unsigned>(a.exponent - b.exponent));
   else if (b.exponent > a.exponent)
-    a.shift_right(b.exponent - a.exponent);
+    a.shift_right(static_cast<unsigned>(b.exponent - a.exponent));
 
   DyadicFloat<Bits> result;
 
@@ -278,11 +444,11 @@ LIBC_INLINE constexpr DyadicFloat<Bits> quick_add(DyadicFloat<Bits> a,
 // don't need to normalize the inputs again in this function.  If the inputs are
 // not normalized, the results might lose precision significantly.
 template <size_t Bits>
-LIBC_INLINE constexpr DyadicFloat<Bits> quick_mul(DyadicFloat<Bits> a,
-                                                  DyadicFloat<Bits> b) {
+LIBC_INLINE constexpr DyadicFloat<Bits> quick_mul(const DyadicFloat<Bits> &a,
+                                                  const DyadicFloat<Bits> &b) {
   DyadicFloat<Bits> result;
   result.sign = (a.sign != b.sign) ? Sign::NEG : Sign::POS;
-  result.exponent = a.exponent + b.exponent + int(Bits);
+  result.exponent = a.exponent + b.exponent + static_cast<int>(Bits);
 
   if (!(a.mantissa.is_zero() || b.mantissa.is_zero())) {
     result.mantissa = a.mantissa.quick_mul_hi(b.mantissa);
@@ -309,7 +475,7 @@ multiply_add(const DyadicFloat<Bits> &a, const DyadicFloat<Bits> &b,
 // Simple exponentiation implementation for printf. Only handles positive
 // exponents, since division isn't implemented.
 template <size_t Bits>
-LIBC_INLINE constexpr DyadicFloat<Bits> pow_n(DyadicFloat<Bits> a,
+LIBC_INLINE constexpr DyadicFloat<Bits> pow_n(const DyadicFloat<Bits> &a,
                                               uint32_t power) {
   DyadicFloat<Bits> result = 1.0;
   DyadicFloat<Bits> cur_power = a;
@@ -325,13 +491,14 @@ LIBC_INLINE constexpr DyadicFloat<Bits> pow_n(DyadicFloat<Bits> a,
 }
 
 template <size_t Bits>
-LIBC_INLINE constexpr DyadicFloat<Bits> mul_pow_2(DyadicFloat<Bits> a,
+LIBC_INLINE constexpr DyadicFloat<Bits> mul_pow_2(const DyadicFloat<Bits> &a,
                                                   int32_t pow_2) {
   DyadicFloat<Bits> result = a;
   result.exponent += pow_2;
   return result;
 }
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_DYADIC_FLOAT_H
diff --git a/src/__support/FPUtil/except_value_utils.h b/src/__support/FPUtil/except_value_utils.h
index 1e03811..f8e4e92 100644
--- a/src/__support/FPUtil/except_value_utils.h
+++ b/src/__support/FPUtil/except_value_utils.h
@@ -11,11 +11,15 @@
 
 #include "FEnvImpl.h"
 #include "FPBits.h"
+#include "cast.h"
 #include "rounding_mode.h"
 #include "src/__support/CPP/optional.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h"
+#include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace fputil {
 
@@ -112,8 +116,23 @@ template <typename T> LIBC_INLINE T round_result_slightly_up(T value_rn) {
   return tmp;
 }
 
+#if defined(LIBC_TYPES_HAS_FLOAT16) &&                                         \
+    !defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+template <> LIBC_INLINE float16 round_result_slightly_down(float16 value_rn) {
+  volatile float tmp = value_rn;
+  tmp -= FPBits<float16>::min_normal().get_val();
+  return cast<float16>(tmp);
+}
+
+template <> LIBC_INLINE float16 round_result_slightly_up(float16 value_rn) {
+  volatile float tmp = value_rn;
+  tmp += FPBits<float16>::min_normal().get_val();
+  return cast<float16>(tmp);
+}
+#endif
+
 } // namespace fputil
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_EXCEPT_VALUE_UTILS_H
diff --git a/src/__support/FPUtil/fpbits_str.h b/src/__support/FPUtil/fpbits_str.h
index 9768986..9298191 100644
--- a/src/__support/FPUtil/fpbits_str.h
+++ b/src/__support/FPUtil/fpbits_str.h
@@ -14,8 +14,9 @@
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace details {
 
@@ -70,6 +71,6 @@ template <typename T> LIBC_INLINE cpp::string str(fputil::FPBits<T> x) {
   return s;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_FPBITS_STR_H
diff --git a/src/__support/FPUtil/generic/FMA.h b/src/__support/FPUtil/generic/FMA.h
index 71b1507..bec312e 100644
--- a/src/__support/FPUtil/generic/FMA.h
+++ b/src/__support/FPUtil/generic/FMA.h
@@ -12,15 +12,19 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/dyadic_float.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/big_int.h"
 #include "src/__support/macros/attributes.h"   // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "hdr/fenv_macros.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 namespace generic {
 
@@ -106,43 +110,86 @@ LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
                                  sizeof(OutType) <= sizeof(InType),
                              OutType>
 fma(InType x, InType y, InType z) {
-  using OutFPBits = fputil::FPBits<OutType>;
+  using OutFPBits = FPBits<OutType>;
   using OutStorageType = typename OutFPBits::StorageType;
-  using InFPBits = fputil::FPBits<InType>;
+  using InFPBits = FPBits<InType>;
   using InStorageType = typename InFPBits::StorageType;
 
   constexpr int IN_EXPLICIT_MANT_LEN = InFPBits::FRACTION_LEN + 1;
   constexpr size_t PROD_LEN = 2 * IN_EXPLICIT_MANT_LEN;
   constexpr size_t TMP_RESULT_LEN = cpp::bit_ceil(PROD_LEN + 1);
   using TmpResultType = UInt<TMP_RESULT_LEN>;
+  using DyadicFloat = DyadicFloat<TMP_RESULT_LEN>;
 
-  constexpr size_t EXTRA_FRACTION_LEN =
-      TMP_RESULT_LEN - 1 - OutFPBits::FRACTION_LEN;
-  constexpr TmpResultType EXTRA_FRACTION_STICKY_MASK =
-      (TmpResultType(1) << (EXTRA_FRACTION_LEN - 1)) - 1;
+  InFPBits x_bits(x), y_bits(y), z_bits(z);
+
+  if (LIBC_UNLIKELY(x_bits.is_nan() || y_bits.is_nan() || z_bits.is_nan())) {
+    if (x_bits.is_nan() || y_bits.is_nan()) {
+      if (x_bits.is_signaling_nan() || y_bits.is_signaling_nan() ||
+          z_bits.is_signaling_nan())
+        raise_except_if_required(FE_INVALID);
+
+      if (x_bits.is_quiet_nan()) {
+        InStorageType x_payload = x_bits.get_mantissa();
+        x_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(x_bits.sign(),
+                                    static_cast<OutStorageType>(x_payload))
+            .get_val();
+      }
+
+      if (y_bits.is_quiet_nan()) {
+        InStorageType y_payload = y_bits.get_mantissa();
+        y_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(y_bits.sign(),
+                                    static_cast<OutStorageType>(y_payload))
+            .get_val();
+      }
+
+      if (z_bits.is_quiet_nan()) {
+        InStorageType z_payload = z_bits.get_mantissa();
+        z_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(z_bits.sign(),
+                                    static_cast<OutStorageType>(z_payload))
+            .get_val();
+      }
+
+      return OutFPBits::quiet_nan().get_val();
+    }
+  }
 
   if (LIBC_UNLIKELY(x == 0 || y == 0 || z == 0))
-    return static_cast<OutType>(x * y + z);
+    return cast<OutType>(x * y + z);
 
   int x_exp = 0;
   int y_exp = 0;
   int z_exp = 0;
 
+  // Denormal scaling = 2^(fraction length).
+  constexpr InStorageType IMPLICIT_MASK =
+      InFPBits::SIG_MASK - InFPBits::FRACTION_MASK;
+
+  constexpr InType DENORMAL_SCALING =
+      InFPBits::create_value(
+          Sign::POS, InFPBits::FRACTION_LEN + InFPBits::EXP_BIAS, IMPLICIT_MASK)
+          .get_val();
+
   // Normalize denormal inputs.
   if (LIBC_UNLIKELY(InFPBits(x).is_subnormal())) {
     x_exp -= InFPBits::FRACTION_LEN;
-    x *= InType(InStorageType(1) << InFPBits::FRACTION_LEN);
+    x *= DENORMAL_SCALING;
   }
   if (LIBC_UNLIKELY(InFPBits(y).is_subnormal())) {
     y_exp -= InFPBits::FRACTION_LEN;
-    y *= InType(InStorageType(1) << InFPBits::FRACTION_LEN);
+    y *= DENORMAL_SCALING;
   }
   if (LIBC_UNLIKELY(InFPBits(z).is_subnormal())) {
     z_exp -= InFPBits::FRACTION_LEN;
-    z *= InType(InStorageType(1) << InFPBits::FRACTION_LEN);
+    z *= DENORMAL_SCALING;
   }
 
-  InFPBits x_bits(x), y_bits(y), z_bits(z);
+  x_bits = InFPBits(x);
+  y_bits = InFPBits(y);
+  z_bits = InFPBits(z);
   const Sign z_sign = z_bits.sign();
   Sign prod_sign = (x_bits.sign() == y_bits.sign()) ? Sign::POS : Sign::NEG;
   x_exp += x_bits.get_biased_exponent();
@@ -152,7 +199,7 @@ fma(InType x, InType y, InType z) {
   if (LIBC_UNLIKELY(x_exp == InFPBits::MAX_BIASED_EXPONENT ||
                     y_exp == InFPBits::MAX_BIASED_EXPONENT ||
                     z_exp == InFPBits::MAX_BIASED_EXPONENT))
-    return static_cast<OutType>(x * y + z);
+    return cast<OutType>(x * y + z);
 
   // Extract mantissa and append hidden leading bits.
   InStorageType x_mant = x_bits.get_explicit_mantissa();
@@ -182,7 +229,6 @@ fma(InType x, InType y, InType z) {
   constexpr int RESULT_MIN_LEN = PROD_LEN - InFPBits::FRACTION_LEN;
   z_mant <<= RESULT_MIN_LEN;
   int z_lsb_exp = z_exp - (InFPBits::FRACTION_LEN + RESULT_MIN_LEN);
-  bool round_bit = false;
   bool sticky_bits = false;
   bool z_shifted = false;
 
@@ -221,89 +267,22 @@ fma(InType x, InType y, InType z) {
     }
   }
 
-  OutStorageType result = 0;
-  int r_exp = 0; // Unbiased exponent of the result
-
-  int round_mode = fputil::quick_get_round();
-
-  // Normalize the result.
-  if (prod_mant != 0) {
-    int lead_zeros = cpp::countl_zero(prod_mant);
-    // Move the leading 1 to the most significant bit.
-    prod_mant <<= lead_zeros;
-    prod_lsb_exp -= lead_zeros;
-    r_exp = prod_lsb_exp + (cpp::numeric_limits<TmpResultType>::digits - 1) -
-            InFPBits::EXP_BIAS + OutFPBits::EXP_BIAS;
-
-    if (r_exp > 0) {
-      // The result is normal.  We will shift the mantissa to the right by the
-      // amount of extra bits compared to the length of the explicit mantissa in
-      // the output type.  The rounding bit then becomes the highest bit that is
-      // shifted out, and the following lower bits are merged into sticky bits.
-      round_bit =
-          (prod_mant & (TmpResultType(1) << (EXTRA_FRACTION_LEN - 1))) != 0;
-      sticky_bits |= (prod_mant & EXTRA_FRACTION_STICKY_MASK) != 0;
-      result = static_cast<OutStorageType>(prod_mant >> EXTRA_FRACTION_LEN);
-    } else {
-      if (r_exp < -OutFPBits::FRACTION_LEN) {
-        // The result is smaller than 1/2 of the smallest denormal number.
-        sticky_bits = true; // since the result is non-zero.
-        result = 0;
-      } else {
-        // The result is denormal.
-        TmpResultType mask = TmpResultType(1) << (EXTRA_FRACTION_LEN - r_exp);
-        round_bit = (prod_mant & mask) != 0;
-        sticky_bits |= (prod_mant & (mask - 1)) != 0;
-        if (r_exp > -OutFPBits::FRACTION_LEN)
-          result = static_cast<OutStorageType>(
-              prod_mant >> (EXTRA_FRACTION_LEN + 1 - r_exp));
-        else
-          result = 0;
-      }
-
-      r_exp = 0;
-    }
-  } else {
+  if (prod_mant == 0) {
     // When there is exact cancellation, i.e., x*y == -z exactly, return -0.0 if
     // rounding downward and +0.0 for other rounding modes.
-    if (round_mode == FE_DOWNWARD)
+    if (quick_get_round() == FE_DOWNWARD)
       prod_sign = Sign::NEG;
     else
       prod_sign = Sign::POS;
   }
 
-  // Finalize the result.
-  if (LIBC_UNLIKELY(r_exp >= OutFPBits::MAX_BIASED_EXPONENT)) {
-    if ((round_mode == FE_TOWARDZERO) ||
-        (round_mode == FE_UPWARD && prod_sign.is_neg()) ||
-        (round_mode == FE_DOWNWARD && prod_sign.is_pos())) {
-      return OutFPBits::max_normal(prod_sign).get_val();
-    }
-    return OutFPBits::inf(prod_sign).get_val();
-  }
-
-  // Remove hidden bit and append the exponent field and sign bit.
-  result = static_cast<OutStorageType>(
-      (result & OutFPBits::FRACTION_MASK) |
-      (static_cast<OutStorageType>(r_exp) << OutFPBits::FRACTION_LEN));
-  if (prod_sign.is_neg())
-    result |= OutFPBits::SIGN_MASK;
-
-  // Rounding.
-  if (round_mode == FE_TONEAREST) {
-    if (round_bit && (sticky_bits || ((result & 1) != 0)))
-      ++result;
-  } else if ((round_mode == FE_UPWARD && prod_sign.is_pos()) ||
-             (round_mode == FE_DOWNWARD && prod_sign.is_neg())) {
-    if (round_bit || sticky_bits)
-      ++result;
-  }
-
-  return cpp::bit_cast<OutType>(result);
+  DyadicFloat result(prod_sign, prod_lsb_exp - InFPBits::EXP_BIAS, prod_mant);
+  result.mantissa |= static_cast<unsigned int>(sticky_bits);
+  return result.template as<OutType, /*ShouldSignalExceptions=*/true>();
 }
 
 } // namespace generic
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_FMA_H
diff --git a/src/__support/FPUtil/generic/FMod.h b/src/__support/FPUtil/generic/FMod.h
index f840a92..30d6472 100644
--- a/src/__support/FPUtil/generic/FMod.h
+++ b/src/__support/FPUtil/generic/FMod.h
@@ -14,9 +14,10 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 namespace generic {
 
@@ -160,7 +161,8 @@ template <typename T> struct FModDivisionInvMultHelper {
 template <typename T, typename U = typename FPBits<T>::StorageType,
           typename DivisionHelper = FModDivisionSimpleHelper<U>>
 class FMod {
-  static_assert(cpp::is_floating_point_v<T> && cpp::is_unsigned_v<U> &&
+  static_assert(cpp::is_floating_point_v<T> &&
+                    is_unsigned_integral_or_big_int_v<U> &&
                     (sizeof(U) * CHAR_BIT > FPBits<T>::FRACTION_LEN),
                 "FMod instantiated with invalid type.");
 
@@ -289,6 +291,6 @@ public:
 
 } // namespace generic
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_FMOD_H
diff --git a/src/__support/FPUtil/generic/add_sub.h b/src/__support/FPUtil/generic/add_sub.h
new file mode 100644
index 0000000..6bc9dcd
--- /dev/null
+++ b/src/__support/FPUtil/generic/add_sub.h
@@ -0,0 +1,212 @@
+//===-- Add and subtract IEEE 754 floating-point numbers --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_ADD_SUB_H
+#define LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_ADD_SUB_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/algorithm.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil::generic {
+
+template <bool IsSub, typename OutType, typename InType>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                 cpp::is_floating_point_v<InType> &&
+                                 sizeof(OutType) <= sizeof(InType),
+                             OutType>
+add_or_sub(InType x, InType y) {
+  using OutFPBits = FPBits<OutType>;
+  using OutStorageType = typename OutFPBits::StorageType;
+  using InFPBits = FPBits<InType>;
+  using InStorageType = typename InFPBits::StorageType;
+
+  constexpr int GUARD_BITS_LEN = 3;
+  constexpr int RESULT_FRACTION_LEN = InFPBits::FRACTION_LEN + GUARD_BITS_LEN;
+  constexpr int RESULT_MANTISSA_LEN = RESULT_FRACTION_LEN + 1;
+
+  using DyadicFloat =
+      DyadicFloat<cpp::bit_ceil(static_cast<size_t>(RESULT_MANTISSA_LEN))>;
+
+  InFPBits x_bits(x);
+  InFPBits y_bits(y);
+
+  bool is_effectively_add = (x_bits.sign() == y_bits.sign()) != IsSub;
+
+  if (LIBC_UNLIKELY(x_bits.is_inf_or_nan() || y_bits.is_inf_or_nan() ||
+                    x_bits.is_zero() || y_bits.is_zero())) {
+    if (x_bits.is_nan() || y_bits.is_nan()) {
+      if (x_bits.is_signaling_nan() || y_bits.is_signaling_nan())
+        raise_except_if_required(FE_INVALID);
+
+      if (x_bits.is_quiet_nan()) {
+        InStorageType x_payload = x_bits.get_mantissa();
+        x_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(x_bits.sign(),
+                                    static_cast<OutStorageType>(x_payload))
+            .get_val();
+      }
+
+      if (y_bits.is_quiet_nan()) {
+        InStorageType y_payload = y_bits.get_mantissa();
+        y_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(y_bits.sign(),
+                                    static_cast<OutStorageType>(y_payload))
+            .get_val();
+      }
+
+      return OutFPBits::quiet_nan().get_val();
+    }
+
+    if (x_bits.is_inf()) {
+      if (y_bits.is_inf()) {
+        if (!is_effectively_add) {
+          raise_except_if_required(FE_INVALID);
+          return OutFPBits::quiet_nan().get_val();
+        }
+
+        return OutFPBits::inf(x_bits.sign()).get_val();
+      }
+
+      return OutFPBits::inf(x_bits.sign()).get_val();
+    }
+
+    if (y_bits.is_inf())
+      return OutFPBits::inf(y_bits.sign()).get_val();
+
+    if (x_bits.is_zero()) {
+      if (y_bits.is_zero()) {
+        switch (quick_get_round()) {
+        case FE_DOWNWARD:
+          return OutFPBits::zero(Sign::NEG).get_val();
+        default:
+          return OutFPBits::zero(Sign::POS).get_val();
+        }
+      }
+
+      // volatile prevents Clang from converting tmp to OutType and then
+      // immediately back to InType before negating it, resulting in double
+      // rounding.
+      volatile InType tmp = y;
+      if constexpr (IsSub)
+        tmp = -tmp;
+      return cast<OutType>(tmp);
+    }
+
+    if (y_bits.is_zero()) {
+      volatile InType tmp = y;
+      if constexpr (IsSub)
+        tmp = -tmp;
+      return cast<OutType>(tmp);
+    }
+  }
+
+  InType x_abs = x_bits.abs().get_val();
+  InType y_abs = y_bits.abs().get_val();
+
+  if (x_abs == y_abs && !is_effectively_add) {
+    switch (quick_get_round()) {
+    case FE_DOWNWARD:
+      return OutFPBits::zero(Sign::NEG).get_val();
+    default:
+      return OutFPBits::zero(Sign::POS).get_val();
+    }
+  }
+
+  Sign result_sign = Sign::POS;
+
+  if (x_abs > y_abs) {
+    result_sign = x_bits.sign();
+  } else if (x_abs < y_abs) {
+    if (is_effectively_add)
+      result_sign = y_bits.sign();
+    else if (y_bits.is_pos())
+      result_sign = Sign::NEG;
+  } else if (is_effectively_add) {
+    result_sign = x_bits.sign();
+  }
+
+  InFPBits max_bits(cpp::max(x_abs, y_abs));
+  InFPBits min_bits(cpp::min(x_abs, y_abs));
+
+  InStorageType result_mant;
+
+  if (max_bits.is_subnormal()) {
+    // min_bits must be subnormal too.
+
+    if (is_effectively_add)
+      result_mant = max_bits.get_mantissa() + min_bits.get_mantissa();
+    else
+      result_mant = max_bits.get_mantissa() - min_bits.get_mantissa();
+
+    result_mant <<= GUARD_BITS_LEN;
+  } else {
+    InStorageType max_mant = max_bits.get_explicit_mantissa() << GUARD_BITS_LEN;
+    InStorageType min_mant = min_bits.get_explicit_mantissa() << GUARD_BITS_LEN;
+    int alignment =
+        max_bits.get_biased_exponent() - min_bits.get_biased_exponent();
+
+    InStorageType aligned_min_mant =
+        min_mant >> cpp::min(alignment, RESULT_MANTISSA_LEN);
+    bool aligned_min_mant_sticky;
+
+    if (alignment <= 3)
+      aligned_min_mant_sticky = false;
+    else if (alignment <= InFPBits::FRACTION_LEN + 3)
+      aligned_min_mant_sticky =
+          (min_mant << (InFPBits::STORAGE_LEN - alignment)) != 0;
+    else
+      aligned_min_mant_sticky = true;
+
+    InStorageType min_mant_sticky(static_cast<int>(aligned_min_mant_sticky));
+
+    if (is_effectively_add)
+      result_mant = max_mant + (aligned_min_mant | min_mant_sticky);
+    else
+      result_mant = max_mant - (aligned_min_mant | min_mant_sticky);
+  }
+
+  int result_exp = max_bits.get_exponent() - RESULT_FRACTION_LEN;
+  DyadicFloat result(result_sign, result_exp, result_mant);
+  return result.template as<OutType, /*ShouldSignalExceptions=*/true>();
+}
+
+template <typename OutType, typename InType>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                 cpp::is_floating_point_v<InType> &&
+                                 sizeof(OutType) <= sizeof(InType),
+                             OutType>
+add(InType x, InType y) {
+  return add_or_sub</*IsSub=*/false, OutType>(x, y);
+}
+
+template <typename OutType, typename InType>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                 cpp::is_floating_point_v<InType> &&
+                                 sizeof(OutType) <= sizeof(InType),
+                             OutType>
+sub(InType x, InType y) {
+  return add_or_sub</*IsSub=*/true, OutType>(x, y);
+}
+
+} // namespace fputil::generic
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_ADD_SUB_H
diff --git a/src/__support/FPUtil/generic/div.h b/src/__support/FPUtil/generic/div.h
new file mode 100644
index 0000000..f0e4057
--- /dev/null
+++ b/src/__support/FPUtil/generic/div.h
@@ -0,0 +1,126 @@
+//===-- Division of IEEE 754 floating-point numbers -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_DIV_H
+#define LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_DIV_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil::generic {
+
+template <typename OutType, typename InType>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                 cpp::is_floating_point_v<InType> &&
+                                 sizeof(OutType) <= sizeof(InType),
+                             OutType>
+div(InType x, InType y) {
+  using OutFPBits = FPBits<OutType>;
+  using OutStorageType = typename OutFPBits::StorageType;
+  using InFPBits = FPBits<InType>;
+  using InStorageType = typename InFPBits::StorageType;
+  using DyadicFloat =
+      DyadicFloat<cpp::bit_ceil(static_cast<size_t>(InFPBits::SIG_LEN + 1))>;
+
+  InFPBits x_bits(x);
+  InFPBits y_bits(y);
+
+  Sign result_sign = x_bits.sign() == y_bits.sign() ? Sign::POS : Sign::NEG;
+
+  if (LIBC_UNLIKELY(x_bits.is_inf_or_nan() || y_bits.is_inf_or_nan() ||
+                    x_bits.is_zero() || y_bits.is_zero())) {
+    if (x_bits.is_nan() || y_bits.is_nan()) {
+      if (x_bits.is_signaling_nan() || y_bits.is_signaling_nan())
+        raise_except_if_required(FE_INVALID);
+
+      if (x_bits.is_quiet_nan()) {
+        InStorageType x_payload = x_bits.get_mantissa();
+        x_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(x_bits.sign(),
+                                    static_cast<OutStorageType>(x_payload))
+            .get_val();
+      }
+
+      if (y_bits.is_quiet_nan()) {
+        InStorageType y_payload = y_bits.get_mantissa();
+        y_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(y_bits.sign(),
+                                    static_cast<OutStorageType>(y_payload))
+            .get_val();
+      }
+
+      return OutFPBits::quiet_nan().get_val();
+    }
+
+    if (x_bits.is_inf()) {
+      if (y_bits.is_inf()) {
+        set_errno_if_required(EDOM);
+        raise_except_if_required(FE_INVALID);
+        return OutFPBits::quiet_nan().get_val();
+      }
+
+      return OutFPBits::inf(result_sign).get_val();
+    }
+
+    if (y_bits.is_inf())
+      return OutFPBits::inf(result_sign).get_val();
+
+    if (y_bits.is_zero()) {
+      if (x_bits.is_zero()) {
+        raise_except_if_required(FE_INVALID);
+        return OutFPBits::quiet_nan().get_val();
+      }
+
+      raise_except_if_required(FE_DIVBYZERO);
+      return OutFPBits::inf(result_sign).get_val();
+    }
+
+    if (x_bits.is_zero())
+      return OutFPBits::zero(result_sign).get_val();
+  }
+
+  DyadicFloat xd(x);
+  DyadicFloat yd(y);
+
+  // Number of iterations = full output precision + 1 rounding bit + 1 potential
+  // leading 0.
+  constexpr int NUM_ITERS = OutFPBits::FRACTION_LEN + 3;
+  int result_exp = xd.exponent - yd.exponent - (NUM_ITERS - 1);
+
+  InStorageType q = 0;
+  InStorageType r = static_cast<InStorageType>(xd.mantissa >> 2);
+  InStorageType yd_mant_in = static_cast<InStorageType>(yd.mantissa >> 1);
+
+  for (int i = 0; i < NUM_ITERS; ++i) {
+    q <<= 1;
+    r <<= 1;
+    if (r >= yd_mant_in) {
+      q += 1;
+      r -= yd_mant_in;
+    }
+  }
+
+  DyadicFloat result(result_sign, result_exp, q);
+  result.mantissa |= static_cast<unsigned int>(r != 0);
+  return result.template as<OutType, /*ShouldSignalExceptions=*/true>();
+}
+
+} // namespace fputil::generic
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_DIV_H
diff --git a/src/__support/FPUtil/generic/mul.h b/src/__support/FPUtil/generic/mul.h
new file mode 100644
index 0000000..20d9a77
--- /dev/null
+++ b/src/__support/FPUtil/generic/mul.h
@@ -0,0 +1,105 @@
+//===-- Multiplication of IEEE 754 floating-point numbers -------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_MUL_H
+#define LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_MUL_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil::generic {
+
+template <typename OutType, typename InType>
+LIBC_INLINE cpp::enable_if_t<cpp::is_floating_point_v<OutType> &&
+                                 cpp::is_floating_point_v<InType> &&
+                                 sizeof(OutType) <= sizeof(InType),
+                             OutType>
+mul(InType x, InType y) {
+  using OutFPBits = FPBits<OutType>;
+  using OutStorageType = typename OutFPBits::StorageType;
+  using InFPBits = FPBits<InType>;
+  using InStorageType = typename InFPBits::StorageType;
+  // The product of two p-digit numbers is a 2p-digit number.
+  using DyadicFloat =
+      DyadicFloat<cpp::bit_ceil(2 * static_cast<size_t>(InFPBits::SIG_LEN))>;
+
+  InFPBits x_bits(x);
+  InFPBits y_bits(y);
+
+  Sign result_sign = x_bits.sign() == y_bits.sign() ? Sign::POS : Sign::NEG;
+
+  if (LIBC_UNLIKELY(x_bits.is_inf_or_nan() || y_bits.is_inf_or_nan() ||
+                    x_bits.is_zero() || y_bits.is_zero())) {
+    if (x_bits.is_nan() || y_bits.is_nan()) {
+      if (x_bits.is_signaling_nan() || y_bits.is_signaling_nan())
+        raise_except_if_required(FE_INVALID);
+
+      if (x_bits.is_quiet_nan()) {
+        InStorageType x_payload = x_bits.get_mantissa();
+        x_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(x_bits.sign(),
+                                    static_cast<OutStorageType>(x_payload))
+            .get_val();
+      }
+
+      if (y_bits.is_quiet_nan()) {
+        InStorageType y_payload = y_bits.get_mantissa();
+        y_payload >>= InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
+        return OutFPBits::quiet_nan(y_bits.sign(),
+                                    static_cast<OutStorageType>(y_payload))
+            .get_val();
+      }
+
+      return OutFPBits::quiet_nan().get_val();
+    }
+
+    if (x_bits.is_inf()) {
+      if (y_bits.is_zero()) {
+        set_errno_if_required(EDOM);
+        raise_except_if_required(FE_INVALID);
+        return OutFPBits::quiet_nan().get_val();
+      }
+
+      return OutFPBits::inf(result_sign).get_val();
+    }
+
+    if (y_bits.is_inf()) {
+      if (x_bits.is_zero()) {
+        set_errno_if_required(EDOM);
+        raise_except_if_required(FE_INVALID);
+        return OutFPBits::quiet_nan().get_val();
+      }
+
+      return OutFPBits::inf(result_sign).get_val();
+    }
+
+    // Now either x or y is zero, and the other one is finite.
+    return OutFPBits::zero(result_sign).get_val();
+  }
+
+  DyadicFloat xd(x);
+  DyadicFloat yd(y);
+
+  DyadicFloat result = quick_mul(xd, yd);
+  return result.template as<OutType, /*ShouldSignalExceptions=*/true>();
+}
+
+} // namespace fputil::generic
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_MUL_H
diff --git a/src/__support/FPUtil/generic/sqrt.h b/src/__support/FPUtil/generic/sqrt.h
index d6e894f..497ebd1 100644
--- a/src/__support/FPUtil/generic/sqrt.h
+++ b/src/__support/FPUtil/generic/sqrt.h
@@ -14,13 +14,15 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/dyadic_float.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/uint128.h"
 
 #include "hdr/fenv_macros.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 namespace internal {
@@ -78,16 +80,14 @@ sqrt(InType x) {
     return x86::sqrt(x);
   } else {
     // IEEE floating points formats.
-    using OutFPBits = typename fputil::FPBits<OutType>;
-    using OutStorageType = typename OutFPBits::StorageType;
-    using InFPBits = typename fputil::FPBits<InType>;
+    using OutFPBits = FPBits<OutType>;
+    using InFPBits = FPBits<InType>;
     using InStorageType = typename InFPBits::StorageType;
+    using DyadicFloat =
+        DyadicFloat<cpp::bit_ceil(static_cast<size_t>(InFPBits::STORAGE_LEN))>;
+
     constexpr InStorageType ONE = InStorageType(1) << InFPBits::FRACTION_LEN;
     constexpr auto FLT_NAN = OutFPBits::quiet_nan().get_val();
-    constexpr int EXTRA_FRACTION_LEN =
-        InFPBits::FRACTION_LEN - OutFPBits::FRACTION_LEN;
-    constexpr InStorageType EXTRA_FRACTION_MASK =
-        (InStorageType(1) << EXTRA_FRACTION_LEN) - 1;
 
     InFPBits bits(x);
 
@@ -97,7 +97,7 @@ sqrt(InType x) {
       // sqrt(-0) = -0
       // sqrt(NaN) = NaN
       // sqrt(-NaN) = -NaN
-      return static_cast<OutType>(x);
+      return cast<OutType>(x);
     } else if (bits.is_neg()) {
       // sqrt(-Inf) = NaN
       // sqrt(-x) = NaN
@@ -135,10 +135,12 @@ sqrt(InType x) {
       InStorageType y = ONE;
       InStorageType r = x_mant - ONE;
 
+      // TODO: Reduce iteration count to OutFPBits::FRACTION_LEN + 2 or + 3.
       for (InStorageType current_bit = ONE >> 1; current_bit;
            current_bit >>= 1) {
         r <<= 1;
-        InStorageType tmp = (y << 1) + current_bit; // 2*y(n - 1) + 2^(-n-1)
+        // 2*y(n - 1) + 2^(-n-1)
+        InStorageType tmp = static_cast<InStorageType>((y << 1) + current_bit);
         if (r >= tmp) {
           r -= tmp;
           y += current_bit;
@@ -146,96 +148,24 @@ sqrt(InType x) {
       }
 
       // We compute one more iteration in order to round correctly.
-      bool lsb = (y & (InStorageType(1) << EXTRA_FRACTION_LEN)) !=
-                 0;    // Least significant bit
-      bool rb = false; // Round bit
       r <<= 2;
-      InStorageType tmp = (y << 2) + 1;
+      y <<= 2;
+      InStorageType tmp = y + 1;
       if (r >= tmp) {
         r -= tmp;
-        rb = true;
-      }
-
-      bool sticky = false;
-
-      if constexpr (EXTRA_FRACTION_LEN > 0) {
-        sticky = rb || (y & EXTRA_FRACTION_MASK) != 0;
-        rb = (y & (InStorageType(1) << (EXTRA_FRACTION_LEN - 1))) != 0;
-      }
-
-      // Remove hidden bit and append the exponent field.
-      x_exp = ((x_exp >> 1) + OutFPBits::EXP_BIAS);
-
-      OutStorageType y_out = static_cast<OutStorageType>(
-          ((y - ONE) >> EXTRA_FRACTION_LEN) |
-          (static_cast<OutStorageType>(x_exp) << OutFPBits::FRACTION_LEN));
-
-      if constexpr (EXTRA_FRACTION_LEN > 0) {
-        if (x_exp >= OutFPBits::MAX_BIASED_EXPONENT) {
-          switch (quick_get_round()) {
-          case FE_TONEAREST:
-          case FE_UPWARD:
-            return OutFPBits::inf().get_val();
-          default:
-            return OutFPBits::max_normal().get_val();
-          }
-        }
-
-        if (x_exp <
-            -OutFPBits::EXP_BIAS - OutFPBits::SIG_LEN + EXTRA_FRACTION_LEN) {
-          switch (quick_get_round()) {
-          case FE_UPWARD:
-            return OutFPBits::min_subnormal().get_val();
-          default:
-            return OutType(0.0);
-          }
-        }
-
-        if (x_exp <= 0) {
-          int underflow_extra_fraction_len = EXTRA_FRACTION_LEN - x_exp + 1;
-          InStorageType underflow_extra_fraction_mask =
-              (InStorageType(1) << underflow_extra_fraction_len) - 1;
-
-          rb = (y & (InStorageType(1) << (underflow_extra_fraction_len - 1))) !=
-               0;
-          OutStorageType subnormal_mant =
-              static_cast<OutStorageType>(y >> underflow_extra_fraction_len);
-          lsb = (subnormal_mant & 1) != 0;
-          sticky = sticky || (y & underflow_extra_fraction_mask) != 0;
-
-          switch (quick_get_round()) {
-          case FE_TONEAREST:
-            if (rb && (lsb || sticky))
-              ++subnormal_mant;
-            break;
-          case FE_UPWARD:
-            if (rb || sticky)
-              ++subnormal_mant;
-            break;
-          }
-
-          return cpp::bit_cast<OutType>(subnormal_mant);
-        }
-      }
-
-      switch (quick_get_round()) {
-      case FE_TONEAREST:
-        // Round to nearest, ties to even
-        if (rb && (lsb || (r != 0)))
-          ++y_out;
-        break;
-      case FE_UPWARD:
-        if (rb || (r != 0) || sticky)
-          ++y_out;
-        break;
+        // Rounding bit.
+        y |= 2;
       }
+      // Sticky bit.
+      y |= static_cast<unsigned int>(r != 0);
 
-      return cpp::bit_cast<OutType>(y_out);
+      DyadicFloat yd(Sign::POS, (x_exp >> 1) - 2 - InFPBits::FRACTION_LEN, y);
+      return yd.template as<OutType, /*ShouldSignalExceptions=*/true>();
     }
   }
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_SQRT_H
diff --git a/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h b/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
index 6308ffe..9492d52 100644
--- a/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
+++ b/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
@@ -14,13 +14,15 @@
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/uint128.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 namespace x86 {
 
-LIBC_INLINE void normalize(int &exponent, UInt128 &mantissa) {
+LIBC_INLINE void normalize(int &exponent,
+                           FPBits<long double>::StorageType &mantissa) {
   const unsigned int shift = static_cast<unsigned int>(
       cpp::countl_zero(static_cast<uint64_t>(mantissa)) -
       (8 * sizeof(uint64_t) - 1 - FPBits<long double>::FRACTION_LEN));
@@ -134,6 +136,6 @@ LIBC_INLINE long double sqrt(long double x) {
 
 } // namespace x86
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_SQRT_80_BIT_LONG_DOUBLE_H
diff --git a/src/__support/FPUtil/multiply_add.h b/src/__support/FPUtil/multiply_add.h
index 622914e..a86067c 100644
--- a/src/__support/FPUtil/multiply_add.h
+++ b/src/__support/FPUtil/multiply_add.h
@@ -11,10 +11,11 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 // Implement a simple wrapper for multiply-add operation:
@@ -34,26 +35,27 @@ multiply_add(T x, T y, T z) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #if defined(LIBC_TARGET_CPU_HAS_FMA)
 
 // FMA instructions are available.
-#include "FMA.h"
+// We use builtins directly instead of including FMA.h to avoid a circular
+// dependency: multiply_add.h -> FMA.h -> generic/FMA.h -> dyadic_float.h.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 LIBC_INLINE float multiply_add(float x, float y, float z) {
-  return fma<float>(x, y, z);
+  return __builtin_fmaf(x, y, z);
 }
 
 LIBC_INLINE double multiply_add(double x, double y, double z) {
-  return fma<double>(x, y, z);
+  return __builtin_fma(x, y, z);
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
diff --git a/src/__support/FPUtil/nearest_integer.h b/src/__support/FPUtil/nearest_integer.h
index bc98667..5d0dedd 100644
--- a/src/__support/FPUtil/nearest_integer.h
+++ b/src/__support/FPUtil/nearest_integer.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_NEAREST_INTEGER_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_NEAREST_INTEGER_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/architectures.h"
 #include "src/__support/macros/properties/cpu_features.h"
@@ -17,9 +18,21 @@
 #include "x86_64/nearest_integer.h"
 #elif defined(LIBC_TARGET_ARCH_IS_AARCH64)
 #include "aarch64/nearest_integer.h"
+#elif defined(LIBC_TARGET_ARCH_IS_GPU)
+
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
+
+LIBC_INLINE float nearest_integer(float x) { return __builtin_rintf(x); }
+
+LIBC_INLINE double nearest_integer(double x) { return __builtin_rint(x); }
+
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
+
 #else
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 // This is a fast implementation for rounding to a nearest integer that.
@@ -60,7 +73,7 @@ LIBC_INLINE double nearest_integer(double x) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_NEAREST_INTEGER_H
diff --git a/src/__support/FPUtil/riscv/FEnvImpl.h b/src/__support/FPUtil/riscv/FEnvImpl.h
index 1de464a..2f525eb 100644
--- a/src/__support/FPUtil/riscv/FEnvImpl.h
+++ b/src/__support/FPUtil/riscv/FEnvImpl.h
@@ -17,7 +17,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 struct FEnv {
@@ -176,6 +176,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_RISCV_FENVIMPL_H
diff --git a/src/__support/FPUtil/riscv/sqrt.h b/src/__support/FPUtil/riscv/sqrt.h
index a1c436d..0363822 100644
--- a/src/__support/FPUtil/riscv/sqrt.h
+++ b/src/__support/FPUtil/riscv/sqrt.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_RISCV_SQRT_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
@@ -18,7 +19,7 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 #ifdef __riscv_flen
@@ -38,6 +39,6 @@ template <> LIBC_INLINE double sqrt<double>(double x) {
 #endif // __riscv_flen
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_RISCV_SQRT_H
diff --git a/src/__support/FPUtil/rounding_mode.h b/src/__support/FPUtil/rounding_mode.h
index aa5e00f..bc66d09 100644
--- a/src/__support/FPUtil/rounding_mode.h
+++ b/src/__support/FPUtil/rounding_mode.h
@@ -11,8 +11,10 @@
 
 #include "hdr/fenv_macros.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
 
 // Quick free-standing test whether fegetround() == FE_UPWARD.
 // Using the following observation:
@@ -73,6 +75,7 @@ LIBC_INLINE int quick_get_round() {
   return (2.0f + y == 2.0f) ? FE_TONEAREST : FE_UPWARD;
 }
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_ROUNDING_MODE_H
diff --git a/src/__support/FPUtil/triple_double.h b/src/__support/FPUtil/triple_double.h
index eafa777..f3ac540 100644
--- a/src/__support/FPUtil/triple_double.h
+++ b/src/__support/FPUtil/triple_double.h
@@ -9,7 +9,10 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_TRIPLE_DOUBLE_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_TRIPLE_DOUBLE_H
 
-namespace LIBC_NAMESPACE::fputil {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
 
 struct TripleDouble {
   double lo = 0.0;
@@ -17,6 +20,7 @@ struct TripleDouble {
   double hi = 0.0;
 };
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_TRIPLE_DOUBLE_H
diff --git a/src/__support/FPUtil/x86_64/FEnvImpl.h b/src/__support/FPUtil/x86_64/FEnvImpl.h
index 2aa6956..b77178e 100644
--- a/src/__support/FPUtil/x86_64/FEnvImpl.h
+++ b/src/__support/FPUtil/x86_64/FEnvImpl.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_FENVIMPL_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_X86)
@@ -21,7 +22,7 @@
 #include "hdr/types/fenv_t.h"
 #include "src/__support/macros/sanitizer.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 namespace internal {
@@ -642,6 +643,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
 #endif
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_FENVIMPL_H
diff --git a/src/__support/FPUtil/x86_64/NextAfterLongDouble.h b/src/__support/FPUtil/x86_64/NextAfterLongDouble.h
index d1c76ba..2e6b297 100644
--- a/src/__support/FPUtil/x86_64/NextAfterLongDouble.h
+++ b/src/__support/FPUtil/x86_64/NextAfterLongDouble.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEXTAFTERLONGDOUBLE_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEXTAFTERLONGDOUBLE_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_X86)
@@ -21,7 +22,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 LIBC_INLINE long double nextafter(long double from, long double to) {
@@ -119,6 +120,6 @@ LIBC_INLINE long double nextafter(long double from, long double to) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEXTAFTERLONGDOUBLE_H
diff --git a/src/__support/FPUtil/x86_64/NextUpDownLongDouble.h b/src/__support/FPUtil/x86_64/NextUpDownLongDouble.h
index 1bc8495..3186997 100644
--- a/src/__support/FPUtil/x86_64/NextUpDownLongDouble.h
+++ b/src/__support/FPUtil/x86_64/NextUpDownLongDouble.h
@@ -11,13 +11,15 @@
 
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_X86)
 #error "Invalid include"
 #endif
 
-namespace LIBC_NAMESPACE::fputil {
+namespace LIBC_NAMESPACE_DECL {
+namespace fputil {
 
 template <bool IsDown>
 LIBC_INLINE constexpr long double nextupdown(long double x) {
@@ -55,6 +57,7 @@ LIBC_INLINE constexpr long double nextupdown(long double x) {
   return xbits.get_val();
 }
 
-} // namespace LIBC_NAMESPACE::fputil
+} // namespace fputil
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEXTUPDOWNLONGDOUBLE_H
diff --git a/src/__support/FPUtil/x86_64/nearest_integer.h b/src/__support/FPUtil/x86_64/nearest_integer.h
index ee31aee..4eae5ff 100644
--- a/src/__support/FPUtil/x86_64/nearest_integer.h
+++ b/src/__support/FPUtil/x86_64/nearest_integer.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEAREST_INTEGER_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if !defined(LIBC_TARGET_ARCH_IS_X86_64)
@@ -22,7 +23,7 @@
 
 #include <immintrin.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 LIBC_INLINE float nearest_integer(float x) {
@@ -40,6 +41,6 @@ LIBC_INLINE double nearest_integer(double x) {
 }
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_NEAREST_INTEGER_H
diff --git a/src/__support/FPUtil/x86_64/sqrt.h b/src/__support/FPUtil/x86_64/sqrt.h
index bfcc5e9..e104477 100644
--- a/src/__support/FPUtil/x86_64/sqrt.h
+++ b/src/__support/FPUtil/x86_64/sqrt.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_SQRT_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/__support/macros/properties/cpu_features.h"
 
@@ -19,7 +20,7 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
 template <> LIBC_INLINE float sqrt<float>(float x) {
@@ -48,6 +49,6 @@ template <> LIBC_INLINE long double sqrt<long double>(long double x) {
 #endif
 
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FPUTIL_X86_64_SQRT_H
diff --git a/src/__support/File/dir.cpp b/src/__support/File/dir.cpp
index e0f7695..21b0106 100644
--- a/src/__support/File/dir.cpp
+++ b/src/__support/File/dir.cpp
@@ -11,9 +11,10 @@
 #include "src/__support/CPP/mutex.h" // lock_guard
 #include "src/__support/CPP/new.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h" // For error macros
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ErrorOr<Dir *> Dir::open(const char *path) {
   auto fd = platform_opendir(path);
@@ -61,4 +62,4 @@ int Dir::close() {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/dir.h b/src/__support/File/dir.h
index 9f8c8db..247ac12 100644
--- a/src/__support/File/dir.h
+++ b/src/__support/File/dir.h
@@ -11,12 +11,12 @@
 
 #include "src/__support/CPP/span.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <dirent.h>
-#include <stdlib.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Platform specific function which will open the directory |name|
 // and return its file descriptor. Upon failure, the error value is returned.
@@ -74,6 +74,6 @@ public:
   LIBC_INLINE int getfd() { return fd; }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FILE_DIR_H
diff --git a/src/__support/File/file.cpp b/src/__support/File/file.cpp
index 58097d0..972249f 100644
--- a/src/__support/File/file.cpp
+++ b/src/__support/File/file.cpp
@@ -8,14 +8,15 @@
 
 #include "file.h"
 
+#include "hdr/func/realloc.h"
+#include "hdr/stdio_macros.h"
+#include "hdr/types/off_t.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/CPP/span.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h" // For error macros
 
-#include <stdio.h>
-#include <stdlib.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 FileIOResult File::write_unlocked(const void *data, size_t len) {
   if (!write_allowed()) {
@@ -282,7 +283,7 @@ int File::ungetc_unlocked(int c) {
   return c;
 }
 
-ErrorOr<int> File::seek(long offset, int whence) {
+ErrorOr<int> File::seek(off_t offset, int whence) {
   FileLock lock(this);
   if (prev_op == FileOp::WRITE && pos > 0) {
 
@@ -305,23 +306,21 @@ ErrorOr<int> File::seek(long offset, int whence) {
   auto result = platform_seek(this, offset, whence);
   if (!result.has_value())
     return Error(result.error());
-  else
-    return 0;
+  return 0;
 }
 
-ErrorOr<long> File::tell() {
+ErrorOr<off_t> File::tell() {
   FileLock lock(this);
   auto seek_target = eof ? SEEK_END : SEEK_CUR;
   auto result = platform_seek(this, 0, seek_target);
   if (!result.has_value() || result.value() < 0)
     return Error(result.error());
-  long platform_offset = result.value();
+  off_t platform_offset = result.value();
   if (prev_op == FileOp::READ)
     return platform_offset - (read_limit - pos);
-  else if (prev_op == FileOp::WRITE)
+  if (prev_op == FileOp::WRITE)
     return platform_offset + pos;
-  else
-    return platform_offset;
+  return platform_offset;
 }
 
 int File::flush_unlocked() {
@@ -433,4 +432,4 @@ File::ModeFlags File::mode_flags(const char *mode) {
   return flags;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/file.h b/src/__support/File/file.h
index 0615487..42e1d11 100644
--- a/src/__support/File/file.h
+++ b/src/__support/File/file.h
@@ -9,15 +9,18 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FILE_FILE_H
 #define LLVM_LIBC_SRC___SUPPORT_FILE_FILE_H
 
+#include "hdr/stdio_macros.h"
+#include "hdr/types/off_t.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/__support/threads/mutex.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct FileIOResult {
   size_t value;
@@ -45,7 +48,7 @@ public:
   using ReadFunc = FileIOResult(File *, void *, size_t);
   // The SeekFunc is expected to return the current offset of the external
   // file position indicator.
-  using SeekFunc = ErrorOr<long>(File *, long, int);
+  using SeekFunc = ErrorOr<off_t>(File *, off_t, int);
   using CloseFunc = int(File *);
 
   using ModeFlags = uint32_t;
@@ -180,9 +183,9 @@ public:
     return read_unlocked(data, len);
   }
 
-  ErrorOr<int> seek(long offset, int whence);
+  ErrorOr<int> seek(off_t offset, int whence);
 
-  ErrorOr<long> tell();
+  ErrorOr<off_t> tell();
 
   // If buffer has data written to it, flush it out. Does nothing if the
   // buffer is currently being used as a read buffer.
@@ -312,6 +315,6 @@ extern File *stdin;
 extern File *stdout;
 extern File *stderr;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FILE_FILE_H
diff --git a/src/__support/File/linux/dir.cpp b/src/__support/File/linux/dir.cpp
index cae545a..5fe44fa 100644
--- a/src/__support/File/linux/dir.cpp
+++ b/src/__support/File/linux/dir.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 
-#include <fcntl.h>       // For open flags
+#include "hdr/fcntl_macros.h" // For open flags
 #include <sys/syscall.h> // For syscall numbers
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ErrorOr<int> platform_opendir(const char *name) {
   int open_flags = O_RDONLY | O_DIRECTORY | O_CLOEXEC;
@@ -56,4 +57,4 @@ int platform_closedir(int fd) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/linux/file.cpp b/src/__support/File/linux/file.cpp
index 00ff938..824c1f2 100644
--- a/src/__support/File/linux/file.cpp
+++ b/src/__support/File/linux/file.cpp
@@ -8,19 +8,21 @@
 
 #include "file.h"
 
+#include "hdr/stdio_macros.h"
+#include "hdr/types/off_t.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/File/file.h"
 #include "src/__support/File/linux/lseekImpl.h"
 #include "src/__support/OSUtil/fcntl.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
-#include "src/errno/libc_errno.h"         // For error macros
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h" // For error macros
 
-#include <fcntl.h> // For mode_t and other flags to the open syscall
-#include <stdio.h>
+#include "hdr/fcntl_macros.h" // For mode_t and other flags to the open syscall
 #include <sys/stat.h>    // For S_IS*, S_IF*, and S_IR* flags.
 #include <sys/syscall.h> // For syscall numbers
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 FileIOResult linux_file_write(File *f, const void *data, size_t size) {
   auto *lf = reinterpret_cast<LinuxFile *>(f);
@@ -42,7 +44,7 @@ FileIOResult linux_file_read(File *f, void *buf, size_t size) {
   return ret;
 }
 
-ErrorOr<long> linux_file_seek(File *f, long offset, int whence) {
+ErrorOr<off_t> linux_file_seek(File *f, off_t offset, int whence) {
   auto *lf = reinterpret_cast<LinuxFile *>(f);
   auto result = internal::lseekimpl(lf->get_fd(), offset, whence);
   if (!result.has_value())
@@ -178,4 +180,4 @@ int get_fileno(File *f) {
   return lf->get_fd();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/linux/file.h b/src/__support/File/linux/file.h
index 7d3770e..16d72a6 100644
--- a/src/__support/File/linux/file.h
+++ b/src/__support/File/linux/file.h
@@ -6,13 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/types/off_t.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 FileIOResult linux_file_write(File *, const void *, size_t);
 FileIOResult linux_file_read(File *, void *, size_t);
-ErrorOr<long> linux_file_seek(File *, long, int);
+ErrorOr<off_t> linux_file_seek(File *, off_t, int);
 int linux_file_close(File *);
 
 class LinuxFile : public File {
@@ -32,4 +34,4 @@ public:
 // Create a File object and associate it with a fd.
 ErrorOr<LinuxFile *> create_file_from_fd(int fd, const char *mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/linux/lseekImpl.h b/src/__support/File/linux/lseekImpl.h
index d1632b7..a034913 100644
--- a/src/__support/File/linux/lseekImpl.h
+++ b/src/__support/File/linux/lseekImpl.h
@@ -9,16 +9,17 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FILE_LINUX_LSEEKIMPL_H
 #define LLVM_LIBC_SRC___SUPPORT_FILE_LINUX_LSEEKIMPL_H
 
+#include "hdr/types/off_t.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
-#include <unistd.h>      // For off_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 LIBC_INLINE ErrorOr<off_t> lseekimpl(int fd, off_t offset, int whence) {
@@ -45,6 +46,6 @@ LIBC_INLINE ErrorOr<off_t> lseekimpl(int fd, off_t offset, int whence) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FILE_LINUX_LSEEKIMPL_H
diff --git a/src/__support/File/linux/stderr.cpp b/src/__support/File/linux/stderr.cpp
index 65d7865..bc17479 100644
--- a/src/__support/File/linux/stderr.cpp
+++ b/src/__support/File/linux/stderr.cpp
@@ -7,16 +7,18 @@
 //===----------------------------------------------------------------------===//
 
 #include "file.h"
-#include <stdio.h>
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr size_t STDERR_BUFFER_SIZE = 0;
 static LinuxFile StdErr(2, nullptr, STDERR_BUFFER_SIZE, _IONBF, false,
                         File::ModeFlags(File::OpenMode::APPEND));
 File *stderr = &StdErr;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 extern "C" {
 FILE *stderr = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::StdErr);
diff --git a/src/__support/File/linux/stdin.cpp b/src/__support/File/linux/stdin.cpp
index c9a363b..e7b6ede 100644
--- a/src/__support/File/linux/stdin.cpp
+++ b/src/__support/File/linux/stdin.cpp
@@ -7,9 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "file.h"
-#include <stdio.h>
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr size_t STDIN_BUFFER_SIZE = 512;
 uint8_t stdin_buffer[STDIN_BUFFER_SIZE];
@@ -17,7 +19,7 @@ static LinuxFile StdIn(0, stdin_buffer, STDIN_BUFFER_SIZE, _IOFBF, false,
                        File::ModeFlags(File::OpenMode::READ));
 File *stdin = &StdIn;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 extern "C" {
 FILE *stdin = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::StdIn);
diff --git a/src/__support/File/linux/stdout.cpp b/src/__support/File/linux/stdout.cpp
index 314692e..0d3b9f3 100644
--- a/src/__support/File/linux/stdout.cpp
+++ b/src/__support/File/linux/stdout.cpp
@@ -7,9 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "file.h"
-#include <stdio.h>
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr size_t STDOUT_BUFFER_SIZE = 1024;
 uint8_t stdout_buffer[STDOUT_BUFFER_SIZE];
@@ -17,7 +19,7 @@ static LinuxFile StdOut(1, stdout_buffer, STDOUT_BUFFER_SIZE, _IOLBF, false,
                         File::ModeFlags(File::OpenMode::APPEND));
 File *stdout = &StdOut;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 extern "C" {
 FILE *stdout = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::StdOut);
diff --git a/src/__support/GPU/allocator.cpp b/src/__support/GPU/allocator.cpp
index a049959..f98e610 100644
--- a/src/__support/GPU/allocator.cpp
+++ b/src/__support/GPU/allocator.cpp
@@ -10,24 +10,26 @@
 
 #include "src/__support/GPU/utils.h"
 #include "src/__support/RPC/rpc_client.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace {
 
 void *rpc_allocate(uint64_t size) {
   void *ptr = nullptr;
   rpc::Client::Port port = rpc::client.open<RPC_MALLOC>();
-  port.send_and_recv([=](rpc::Buffer *buffer) { buffer->data[0] = size; },
-                     [&](rpc::Buffer *buffer) {
-                       ptr = reinterpret_cast<void *>(buffer->data[0]);
-                     });
+  port.send_and_recv(
+      [=](rpc::Buffer *buffer, uint32_t) { buffer->data[0] = size; },
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ptr = reinterpret_cast<void *>(buffer->data[0]);
+      });
   port.close();
   return ptr;
 }
 
 void rpc_free(void *ptr) {
   rpc::Client::Port port = rpc::client.open<RPC_FREE>();
-  port.send([=](rpc::Buffer *buffer) {
+  port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = reinterpret_cast<uintptr_t>(ptr);
   });
   port.close();
@@ -42,4 +44,4 @@ void *allocate(uint64_t size) { return rpc_allocate(size); }
 void deallocate(void *ptr) { rpc_free(ptr); }
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/GPU/allocator.h b/src/__support/GPU/allocator.h
index 99eeb68..466009a 100644
--- a/src/__support/GPU/allocator.h
+++ b/src/__support/GPU/allocator.h
@@ -9,15 +9,16 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_GPU_ALLOCATOR_H
 #define LLVM_LIBC_SRC___SUPPORT_GPU_ALLOCATOR_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
 
 void *allocate(uint64_t size);
 void deallocate(void *ptr);
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_GPU_ALLOCATOR_H
diff --git a/src/__support/GPU/amdgpu/utils.h b/src/__support/GPU/amdgpu/utils.h
index 5f8ad74..6ab9540 100644
--- a/src/__support/GPU/amdgpu/utils.h
+++ b/src/__support/GPU/amdgpu/utils.h
@@ -14,7 +14,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
 
 /// Type aliases to the address spaces used by the AMDGPU backend.
@@ -178,6 +178,6 @@ LIBC_INLINE uint64_t fixed_frequency_clock() {
 LIBC_INLINE uint32_t get_cluster_id() { return 0; }
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif
diff --git a/src/__support/GPU/generic/utils.h b/src/__support/GPU/generic/utils.h
index b6df59f..9461ef0 100644
--- a/src/__support/GPU/generic/utils.h
+++ b/src/__support/GPU/generic/utils.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_GPU_GENERIC_UTILS_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
 
 template <typename T> using Private = T;
@@ -78,6 +79,6 @@ LIBC_INLINE uint64_t fixed_frequency_clock() { return 0; }
 LIBC_INLINE uint32_t get_cluster_id() { return 0; }
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_GPU_GENERIC_UTILS_H
diff --git a/src/__support/GPU/nvptx/utils.h b/src/__support/GPU/nvptx/utils.h
index 88b8ee2..1a43a83 100644
--- a/src/__support/GPU/nvptx/utils.h
+++ b/src/__support/GPU/nvptx/utils.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_GPU_NVPTX_IO_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
 
 /// Type aliases to the address spaces used by the NVPTX backend.
@@ -154,6 +155,6 @@ LIBC_INLINE uint64_t fixed_frequency_clock() {
 LIBC_INLINE uint32_t get_cluster_id() { return __nvvm_read_ptx_sreg_smid(); }
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif
diff --git a/src/__support/GPU/utils.h b/src/__support/GPU/utils.h
index cb04a35..ae52e7a 100644
--- a/src/__support/GPU/utils.h
+++ b/src/__support/GPU/utils.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_GPU_UTILS_H
 #define LLVM_LIBC_SRC___SUPPORT_GPU_UTILS_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
@@ -19,7 +20,7 @@
 #include "generic/utils.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
 /// Get the first active thread inside the lane.
 LIBC_INLINE uint64_t get_first_lane_id(uint64_t lane_mask) {
@@ -51,6 +52,6 @@ LIBC_INLINE uint32_t scan(uint64_t lane_mask, uint32_t x) {
 }
 
 } // namespace gpu
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_GPU_UTILS_H
diff --git a/src/__support/HashTable/bitmask.h b/src/__support/HashTable/bitmask.h
index afdf7c2..3cac481 100644
--- a/src/__support/HashTable/bitmask.h
+++ b/src/__support/HashTable/bitmask.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC___SUPPORT_HASHTABLE_BITMASK_H
 
 #include "src/__support/CPP/bit.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/cpu_features.h"
 #include <stddef.h> // size_t
 #include <stdint.h> // uint8_t, uint64_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // Implementations of the bitmask.
@@ -81,7 +82,7 @@ template <class BitMask> struct IteratableBitMaskAdaptor : public BitMask {
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #if defined(LIBC_TARGET_CPU_HAS_SSE2) && defined(__LIBC_EXPLICIT_SIMD_OPT)
 #include "sse2/bitmask_impl.inc"
diff --git a/src/__support/HashTable/randomness.h b/src/__support/HashTable/randomness.h
index bcc9119..244dd41 100644
--- a/src/__support/HashTable/randomness.h
+++ b/src/__support/HashTable/randomness.h
@@ -12,12 +12,13 @@
 #include "src/__support/common.h"
 #include "src/__support/hash.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #if defined(LIBC_HASHTABLE_USE_GETRANDOM)
 #include "src/errno/libc_errno.h"
 #include "src/sys/random/getrandom.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 namespace randomness {
 // We need an initial state for the hash function. More entropy are to be added
@@ -35,7 +36,7 @@ LIBC_INLINE uint64_t next_random_seed() {
     entropy[1] = reinterpret_cast<uint64_t>(&state);
 #if defined(LIBC_HASHTABLE_USE_GETRANDOM)
     int errno_backup = libc_errno;
-    ssize_t count = sizeof(entropy);
+    size_t count = sizeof(entropy);
     uint8_t *buffer = reinterpret_cast<uint8_t *>(entropy);
     while (count > 0) {
       ssize_t len = getrandom(buffer, count, 0);
@@ -58,5 +59,5 @@ LIBC_INLINE uint64_t next_random_seed() {
 
 } // namespace randomness
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 #endif // LLVM_LIBC_SRC___SUPPORT_HASHTABLE_RANDOMNESS_H
diff --git a/src/__support/HashTable/table.h b/src/__support/HashTable/table.h
index 8f6c588..d50a948 100644
--- a/src/__support/HashTable/table.h
+++ b/src/__support/HashTable/table.h
@@ -15,6 +15,7 @@
 #include "src/__support/HashTable/bitmask.h"
 #include "src/__support/hash.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/memory_size.h"
 #include "src/string/memset.h"
@@ -23,7 +24,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 LIBC_INLINE uint8_t secondary_hash(uint64_t hash) {
@@ -349,6 +350,6 @@ public:
   }
 };
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_HASHTABLE_TABLE_H
diff --git a/src/__support/OSUtil/baremetal/exit.cpp b/src/__support/OSUtil/baremetal/exit.cpp
index 08473f7..64d3862 100644
--- a/src/__support/OSUtil/baremetal/exit.cpp
+++ b/src/__support/OSUtil/baremetal/exit.cpp
@@ -7,12 +7,15 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/OSUtil/exit.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 // This is intended to be provided by the vendor.
 extern "C" [[noreturn]] void __llvm_libc_exit(int status);
 
-namespace LIBC_NAMESPACE::internal {
-
 [[noreturn]] void exit(int status) { __llvm_libc_exit(status); }
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/baremetal/io.cpp b/src/__support/OSUtil/baremetal/io.cpp
index 347c7d4..2a9ef6b 100644
--- a/src/__support/OSUtil/baremetal/io.cpp
+++ b/src/__support/OSUtil/baremetal/io.cpp
@@ -9,14 +9,62 @@
 #include "io.h"
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
-// This is intended to be provided by the vendor.
-extern "C" void __llvm_libc_log_write(const char *msg, size_t len);
+namespace LIBC_NAMESPACE_DECL {
 
-namespace LIBC_NAMESPACE {
+// These are intended to be provided by the vendor.
+//
+// The signature of these types and functions intentionally match `fopencookie`
+// which allows the following:
+//
+// ```
+// struct __llvm_libc_stdio_cookie { ... };
+// ...
+// struct __llvm_libc_stdio_cookie __llvm_libc_stdin_cookie;
+// cookie_io_functions_t stdin_func = { .read = __llvm_libc_stdio_read };
+// FILE *stdin = fopencookie(&__llvm_libc_stdin_cookie, "r", stdin_func);
+// ...
+// struct __llvm_libc_stdio_cookie __llvm_libc_stdout_cookie;
+// cookie_io_functions_t stdout_func = { .write = __llvm_libc_stdio_write };
+// FILE *stdout = fopencookie(&__llvm_libc_stdout_cookie, "w", stdout_func);
+// ...
+// struct __llvm_libc_stdio_cookie __llvm_libc_stderr_cookie;
+// cookie_io_functions_t stderr_func = { .write = __llvm_libc_stdio_write };
+// FILE *stderr = fopencookie(&__llvm_libc_stderr_cookie, "w", stderr_func);
+// ```
+//
+// At the same time, implementation of functions like `printf` and `scanf` can
+// use `__llvm_libc_stdio_read` and `__llvm_libc_stdio_write` directly to avoid
+// the extra indirection.
+//
+// All three symbols `__llvm_libc_stdin_cookie`, `__llvm_libc_stdout_cookie`,
+// and `__llvm_libc_stderr_cookie` must be provided, even if they don't point
+// at anything.
+
+struct __llvm_libc_stdio_cookie;
+
+extern "C" struct __llvm_libc_stdio_cookie __llvm_libc_stdin_cookie;
+extern "C" struct __llvm_libc_stdio_cookie __llvm_libc_stdout_cookie;
+extern "C" struct __llvm_libc_stdio_cookie __llvm_libc_stderr_cookie;
+
+extern "C" ssize_t __llvm_libc_stdio_read(void *cookie, char *buf, size_t size);
+extern "C" ssize_t __llvm_libc_stdio_write(void *cookie, const char *buf,
+                                           size_t size);
+
+ssize_t read_from_stdin(char *buf, size_t size) {
+  return __llvm_libc_stdio_read(static_cast<void *>(&__llvm_libc_stdin_cookie),
+                                buf, size);
+}
+
+void write_to_stdout(cpp::string_view msg) {
+  __llvm_libc_stdio_write(static_cast<void *>(&__llvm_libc_stdout_cookie),
+                          msg.data(), msg.size());
+}
 
 void write_to_stderr(cpp::string_view msg) {
-  __llvm_libc_log_write(msg.data(), msg.size());
+  __llvm_libc_stdio_write(static_cast<void *>(&__llvm_libc_stderr_cookie),
+                          msg.data(), msg.size());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/baremetal/io.h b/src/__support/OSUtil/baremetal/io.h
index 8753464..aed34ec 100644
--- a/src/__support/OSUtil/baremetal/io.h
+++ b/src/__support/OSUtil/baremetal/io.h
@@ -9,12 +9,17 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_BAREMETAL_IO_H
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_BAREMETAL_IO_H
 
+#include "include/llvm-libc-types/size_t.h"
+#include "include/llvm-libc-types/ssize_t.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
+ssize_t read_from_stdin(char *buf, size_t size);
 void write_to_stderr(cpp::string_view msg);
+void write_to_stdout(cpp::string_view msg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_BAREMETAL_IO_H
diff --git a/src/__support/OSUtil/darwin/arm/syscall.h b/src/__support/OSUtil/darwin/arm/syscall.h
index ce10c2a..dc98c07 100644
--- a/src/__support/OSUtil/darwin/arm/syscall.h
+++ b/src/__support/OSUtil/darwin/arm/syscall.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_DARWIN_ARM_SYSCALL_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #define REGISTER_DECL_0                                                        \
   register long x16 __asm__("x16") = number;                                   \
@@ -44,7 +45,7 @@
 #define SYSCALL_INSTR(input_constraint)                                        \
   LIBC_INLINE_ASM("svc 0x80" : "=r"(x0) : input_constraint : "memory", "cc")
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE long syscall_impl(long number) {
   REGISTER_DECL_0;
@@ -91,7 +92,7 @@ LIBC_INLINE long syscall_impl(long number, long arg1, long arg2, long arg3,
   return x0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef REGISTER_DECL_0
 #undef REGISTER_DECL_1
diff --git a/src/__support/OSUtil/darwin/io.h b/src/__support/OSUtil/darwin/io.h
index 9bbc8e1..a5f7ecb 100644
--- a/src/__support/OSUtil/darwin/io.h
+++ b/src/__support/OSUtil/darwin/io.h
@@ -10,15 +10,16 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_DARWIN_IO_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "syscall.h" // For internal syscall function.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE void write_to_stderr(cpp::string_view msg) {
   LIBC_NAMESPACE::syscall_impl(4 /*SYS_write*/, 2 /* stderr */,
                                reinterpret_cast<long>(msg.data()), msg.size());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_DARWIN_IO_H
diff --git a/src/__support/OSUtil/darwin/syscall.h b/src/__support/OSUtil/darwin/syscall.h
index 93b492e..eab9636 100644
--- a/src/__support/OSUtil/darwin/syscall.h
+++ b/src/__support/OSUtil/darwin/syscall.h
@@ -11,6 +11,7 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #ifdef LIBC_TARGET_ARCH_IS_ANY_ARM
@@ -19,7 +20,7 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename R, typename... Ts>
 LIBC_INLINE R syscall_impl(long __number, Ts... ts) {
@@ -27,6 +28,6 @@ LIBC_INLINE R syscall_impl(long __number, Ts... ts) {
   return cpp::bit_or_static_cast<R>(syscall_impl(__number, (long)ts...));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_DARWIN_SYSCALL_H
diff --git a/src/__support/OSUtil/exit.h b/src/__support/OSUtil/exit.h
index f01e4c7..e784ca0 100644
--- a/src/__support/OSUtil/exit.h
+++ b/src/__support/OSUtil/exit.h
@@ -9,10 +9,14 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_EXIT_H
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_EXIT_H
 
-namespace LIBC_NAMESPACE::internal {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 [[noreturn]] void exit(int status);
 
-}
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_EXIT_H
diff --git a/src/__support/OSUtil/fcntl.h b/src/__support/OSUtil/fcntl.h
index d934545..46f7d28 100644
--- a/src/__support/OSUtil/fcntl.h
+++ b/src/__support/OSUtil/fcntl.h
@@ -8,10 +8,14 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_FCNTL_H
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_FCNTL_H
 
-namespace LIBC_NAMESPACE::internal {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 int fcntl(int fd, int cmd, void *arg = nullptr);
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_FCNTL_H
diff --git a/src/__support/OSUtil/fuchsia/io.h b/src/__support/OSUtil/fuchsia/io.h
index f68d734..3953afc 100644
--- a/src/__support/OSUtil/fuchsia/io.h
+++ b/src/__support/OSUtil/fuchsia/io.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_FUCHSIA_IO_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
 #include <iostream>
 #include <zircon/sanitizer.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE void write_to_stderr(cpp::string_view msg) {
 #if defined(LIBC_COPT_TEST_USE_ZXTEST)
@@ -28,6 +29,6 @@ LIBC_INLINE void write_to_stderr(cpp::string_view msg) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_FUCHSIA_IO_H
diff --git a/src/__support/OSUtil/gpu/exit.cpp b/src/__support/OSUtil/gpu/exit.cpp
index 96acb54..0cb266a 100644
--- a/src/__support/OSUtil/gpu/exit.cpp
+++ b/src/__support/OSUtil/gpu/exit.cpp
@@ -8,16 +8,20 @@
 
 #include "src/__support/OSUtil/exit.h"
 
+#include "src/__support/GPU/utils.h"
 #include "src/__support/RPC/rpc_client.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
-namespace LIBC_NAMESPACE::internal {
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 [[noreturn]] void exit(int status) {
   // We want to first make sure the server is listening before we exit.
   rpc::Client::Port port = rpc::client.open<RPC_EXIT>();
-  port.send_and_recv([](rpc::Buffer *) {}, [](rpc::Buffer *) {});
-  port.send([&](rpc::Buffer *buffer) {
+  port.send_and_recv([](rpc::Buffer *, uint32_t) {},
+                     [](rpc::Buffer *, uint32_t) {});
+  port.send([&](rpc::Buffer *buffer, uint32_t) {
     reinterpret_cast<uint32_t *>(buffer->data)[0] = status;
   });
   port.close();
@@ -25,4 +29,5 @@ namespace LIBC_NAMESPACE::internal {
   gpu::end_program();
 }
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/gpu/io.cpp b/src/__support/OSUtil/gpu/io.cpp
index fec4d9f..f70c2e7 100644
--- a/src/__support/OSUtil/gpu/io.cpp
+++ b/src/__support/OSUtil/gpu/io.cpp
@@ -10,14 +10,15 @@
 
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/RPC/rpc_client.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void write_to_stderr(cpp::string_view msg) {
   rpc::Client::Port port = rpc::client.open<RPC_WRITE_TO_STDERR>();
   port.send_n(msg.data(), msg.size());
-  port.recv([](rpc::Buffer *) { /* void */ });
+  port.recv([](rpc::Buffer *, uint32_t) { /* void */ });
   port.close();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/gpu/io.h b/src/__support/OSUtil/gpu/io.h
index e5562eb..e23db8a 100644
--- a/src/__support/OSUtil/gpu/io.h
+++ b/src/__support/OSUtil/gpu/io.h
@@ -11,11 +11,12 @@
 
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void write_to_stderr(cpp::string_view msg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_GPU_IO_H
diff --git a/src/__support/OSUtil/io.h b/src/__support/OSUtil/io.h
index cb7e748..80119da 100644
--- a/src/__support/OSUtil/io.h
+++ b/src/__support/OSUtil/io.h
@@ -19,6 +19,8 @@
 #include "linux/io.h"
 #elif defined(__Fuchsia__)
 #include "fuchsia/io.h"
+#elif defined(_WIN32)
+#include "windows/io.h"
 #elif defined(__ELF__)
 // TODO: Ideally we would have LIBC_TARGET_OS_IS_BAREMETAL.
 #include "baremetal/io.h"
diff --git a/src/__support/OSUtil/linux/aarch64/syscall.h b/src/__support/OSUtil/linux/aarch64/syscall.h
index f6c9a74..f28392d 100644
--- a/src/__support/OSUtil/linux/aarch64/syscall.h
+++ b/src/__support/OSUtil/linux/aarch64/syscall.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_AARCH64_SYSCALL_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #define REGISTER_DECL_0                                                        \
   register long x8 __asm__("x8") = number;                                     \
@@ -42,7 +43,7 @@
 #define SYSCALL_INSTR(input_constraint)                                        \
   LIBC_INLINE_ASM("svc 0" : "=r"(x0) : input_constraint : "memory", "cc")
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE long syscall_impl(long number) {
   REGISTER_DECL_0;
@@ -89,7 +90,7 @@ LIBC_INLINE long syscall_impl(long number, long arg1, long arg2, long arg3,
   return x0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef REGISTER_DECL_0
 #undef REGISTER_DECL_1
diff --git a/src/__support/OSUtil/linux/aarch64/vdso.h b/src/__support/OSUtil/linux/aarch64/vdso.h
new file mode 100644
index 0000000..3c4c620
--- /dev/null
+++ b/src/__support/OSUtil/linux/aarch64/vdso.h
@@ -0,0 +1,37 @@
+//===---------- aarch64 vdso configuration ------------------------* C++ *-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_AARCH64_VDSO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_AARCH64_VDSO_H
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/OSUtil/linux/vdso_sym.h"
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+// translate VDSOSym to symbol names
+// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/kernel/vdso/vdso.lds.S
+LIBC_INLINE constexpr cpp::string_view symbol_name(VDSOSym sym) {
+  switch (sym) {
+  case VDSOSym::RTSigReturn:
+    return "__kernel_rt_sigreturn";
+  case VDSOSym::GetTimeOfDay:
+    return "__kernel_gettimeofday";
+  case VDSOSym::ClockGetTime:
+    return "__kernel_clock_gettime";
+  case VDSOSym::ClockGetRes:
+    return "__kernel_clock_getres";
+  default:
+    return "";
+  }
+}
+
+// symbol versions
+LIBC_INLINE constexpr cpp::string_view symbol_version(VDSOSym) {
+  return "LINUX_2.6.39";
+}
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_AARCH64_VDSO_H
diff --git a/src/__support/OSUtil/linux/arm/syscall.h b/src/__support/OSUtil/linux/arm/syscall.h
index af10074..d1058c8 100644
--- a/src/__support/OSUtil/linux/arm/syscall.h
+++ b/src/__support/OSUtil/linux/arm/syscall.h
@@ -10,16 +10,32 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_ARM_SYSCALL_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #ifdef __thumb__
-#error "The arm syscall implementation does not yet support thumb flavor."
-#endif // __thumb__
+#define R7 long r7 = number
+#define SYSCALL_INSTR(input_constraint)                                        \
+  int temp;                                                                    \
+  LIBC_INLINE_ASM(R"(
+    mov %[temp], r7
+    mov r7, %2
+    svc #0
+    mov r7, %[temp]
+  )"                                                          \
+                  : "=r"(r0), [temp] "=&r"(temp)                               \
+                  : input_constraint                                           \
+                  : "memory", "cc")
+#else
+#define R7 register long r7 asm("r7") = number
+#define SYSCALL_INSTR(input_constraint)                                        \
+  LIBC_INLINE_ASM("svc 0" : "=r"(r0) : input_constraint : "memory", "cc")
+#endif
 
 #define REGISTER_DECL_0                                                        \
-  register long r7 __asm__("r7") = number;                                     \
+  R7;                                                                          \
   register long r0 __asm__("r0");
 #define REGISTER_DECL_1                                                        \
-  register long r7 __asm__("r7") = number;                                     \
+  R7;                                                                          \
   register long r0 __asm__("r0") = arg1;
 #define REGISTER_DECL_2                                                        \
   REGISTER_DECL_1                                                              \
@@ -45,10 +61,7 @@
 #define REGISTER_CONSTRAINT_5 REGISTER_CONSTRAINT_4, "r"(r4)
 #define REGISTER_CONSTRAINT_6 REGISTER_CONSTRAINT_5, "r"(r5)
 
-#define SYSCALL_INSTR(input_constraint)                                        \
-  LIBC_INLINE_ASM("svc 0" : "=r"(r0) : input_constraint : "memory", "cc")
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE long syscall_impl(long number) {
   REGISTER_DECL_0;
@@ -95,7 +108,7 @@ LIBC_INLINE long syscall_impl(long number, long arg1, long arg2, long arg3,
   return r0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef REGISTER_DECL_0
 #undef REGISTER_DECL_1
diff --git a/src/__support/OSUtil/linux/arm/vdso.h b/src/__support/OSUtil/linux/arm/vdso.h
new file mode 100644
index 0000000..3de5860
--- /dev/null
+++ b/src/__support/OSUtil/linux/arm/vdso.h
@@ -0,0 +1,37 @@
+//===---------- arm vdso configuration ----------------------------* C++ *-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_ARM_VDSO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_ARM_VDSO_H
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/OSUtil/linux/vdso_sym.h"
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+// translate VDSOSym to symbol names
+// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/vdso/vdso.lds.S
+LIBC_INLINE constexpr cpp::string_view symbol_name(VDSOSym sym) {
+  switch (sym) {
+  case VDSOSym::ClockGetTime:
+    return "__vdso_clock_gettime";
+  case VDSOSym::GetTimeOfDay:
+    return "__vdso_gettimeofday";
+  case VDSOSym::ClockGetRes:
+    return "__vdso_clock_getres";
+  case VDSOSym::ClockGetTime64:
+    return "__vdso_clock_gettime64";
+  default:
+    return "";
+  }
+}
+
+// symbol versions
+LIBC_INLINE constexpr cpp::string_view symbol_version(VDSOSym) {
+  return "LINUX_2.6";
+}
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_ARM_VDSO_H
diff --git a/src/__support/OSUtil/linux/exit.cpp b/src/__support/OSUtil/linux/exit.cpp
index 4a1d56a..9c64ce4 100644
--- a/src/__support/OSUtil/linux/exit.cpp
+++ b/src/__support/OSUtil/linux/exit.cpp
@@ -7,10 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "syscall.h"     // For internal syscall function.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE::internal {
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 // mark as no_stack_protector for x86 since TLS can be torn down before calling
 // exit so that the stack protector canary cannot be loaded.
@@ -25,4 +27,5 @@ exit(int status) {
   }
 }
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/linux/fcntl.cpp b/src/__support/OSUtil/linux/fcntl.cpp
index b087f89..4742b2a 100644
--- a/src/__support/OSUtil/linux/fcntl.cpp
+++ b/src/__support/OSUtil/linux/fcntl.cpp
@@ -9,20 +9,32 @@
 #include "src/__support/OSUtil/fcntl.h"
 
 #include "hdr/fcntl_macros.h"
+#include "hdr/types/off_t.h"
 #include "hdr/types/struct_f_owner_ex.h"
 #include "hdr/types/struct_flock.h"
 #include "hdr/types/struct_flock64.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <stdarg.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE::internal {
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 int fcntl(int fd, int cmd, void *arg) {
-  switch (cmd) {
+#if SYS_fcntl
+  constexpr auto FCNTL_SYSCALL_ID = SYS_fcntl;
+#elif defined(SYS_fcntl64)
+  constexpr auto FCNTL_SYSCALL_ID = SYS_fcntl64;
+#else
+#error "fcntl and fcntl64 syscalls not available."
+#endif
+
+  int new_cmd = cmd;
+  switch (new_cmd) {
   case F_OFD_SETLKW: {
     struct flock *flk = reinterpret_cast<struct flock *>(arg);
     // convert the struct to a flock64
@@ -33,7 +45,8 @@ int fcntl(int fd, int cmd, void *arg) {
     flk64.l_len = flk->l_len;
     flk64.l_pid = flk->l_pid;
     // create a syscall
-    return LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl, fd, cmd, &flk64);
+    return LIBC_NAMESPACE::syscall_impl<int>(FCNTL_SYSCALL_ID, fd, new_cmd,
+                                             &flk64);
   }
   case F_OFD_GETLK:
   case F_OFD_SETLK: {
@@ -46,7 +59,8 @@ int fcntl(int fd, int cmd, void *arg) {
     flk64.l_len = flk->l_len;
     flk64.l_pid = flk->l_pid;
     // create a syscall
-    int retVal = LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl, fd, cmd, &flk64);
+    int retVal = LIBC_NAMESPACE::syscall_impl<int>(FCNTL_SYSCALL_ID, fd,
+                                                   new_cmd, &flk64);
     // On failure, return
     if (retVal == -1)
       return -1;
@@ -67,28 +81,39 @@ int fcntl(int fd, int cmd, void *arg) {
   }
   case F_GETOWN: {
     struct f_owner_ex fex;
-    int retVal =
-        LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl, fd, F_GETOWN_EX, &fex);
-    if (retVal == -EINVAL)
-      return LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl, fd, cmd,
-                                               reinterpret_cast<void *>(arg));
-    if (static_cast<unsigned long>(retVal) <= -4096UL)
+    int ret = LIBC_NAMESPACE::syscall_impl<int>(FCNTL_SYSCALL_ID, fd,
+                                                F_GETOWN_EX, &fex);
+    if (ret >= 0)
       return fex.type == F_OWNER_PGRP ? -fex.pid : fex.pid;
-
-    libc_errno = -retVal;
+    libc_errno = -ret;
     return -1;
   }
-  // The general case
-  default: {
-    int retVal = LIBC_NAMESPACE::syscall_impl<int>(
-        SYS_fcntl, fd, cmd, reinterpret_cast<void *>(arg));
-    if (retVal >= 0) {
-      return retVal;
-    }
-    libc_errno = -retVal;
-    return -1;
+#ifdef SYS_fcntl64
+  case F_GETLK: {
+    if constexpr (FCNTL_SYSCALL_ID == SYS_fcntl64)
+      new_cmd = F_GETLK64;
+    break;
   }
+  case F_SETLK: {
+    if constexpr (FCNTL_SYSCALL_ID == SYS_fcntl64)
+      new_cmd = F_SETLK64;
+    break;
+  }
+  case F_SETLKW: {
+    if constexpr (FCNTL_SYSCALL_ID == SYS_fcntl64)
+      new_cmd = F_SETLKW64;
+    break;
+  }
+#endif
+  }
+  int retVal = LIBC_NAMESPACE::syscall_impl<int>(FCNTL_SYSCALL_ID, fd, new_cmd,
+                                                 reinterpret_cast<void *>(arg));
+  if (retVal >= 0) {
+    return retVal;
   }
+  libc_errno = -retVal;
+  return -1;
 }
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/linux/i386/syscall.h b/src/__support/OSUtil/linux/i386/syscall.h
new file mode 100644
index 0000000..88d7f2f
--- /dev/null
+++ b/src/__support/OSUtil/linux/i386/syscall.h
@@ -0,0 +1,88 @@
+//===---------- inline implementation of i386 syscalls ------------* C++ *-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_I386_SYSCALL_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_I386_SYSCALL_H
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LIBC_INLINE long syscall_impl(long num) {
+  long ret;
+  LIBC_INLINE_ASM("int $128" : "=a"(ret) : "a"(num) : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1) {
+  long ret;
+  LIBC_INLINE_ASM("int $128" : "=a"(ret) : "a"(num), "b"(arg1) : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1, long arg2) {
+  long ret;
+  LIBC_INLINE_ASM("int $128"
+                  : "=a"(ret)
+                  : "a"(num), "b"(arg1), "c"(arg2)
+                  : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1, long arg2, long arg3) {
+  long ret;
+  LIBC_INLINE_ASM("int $128"
+                  : "=a"(ret)
+                  : "a"(num), "b"(arg1), "c"(arg2), "d"(arg3)
+                  : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1, long arg2, long arg3,
+                              long arg4) {
+  long ret;
+  LIBC_INLINE_ASM("int $128"
+                  : "=a"(ret)
+                  : "a"(num), "b"(arg1), "c"(arg2), "d"(arg3), "S"(arg4)
+                  : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1, long arg2, long arg3,
+                              long arg4, long arg5) {
+  long ret;
+  LIBC_INLINE_ASM("int $128"
+                  : "=a"(ret)
+                  : "a"(num), "b"(arg1), "c"(arg2), "d"(arg3), "S"(arg4),
+                    "D"(arg5)
+                  : "memory");
+  return ret;
+}
+
+LIBC_INLINE long syscall_impl(long num, long arg1, long arg2, long arg3,
+                              long arg4, long arg5, long arg6) {
+  long ret;
+  LIBC_INLINE_ASM(R"(
+    push %[arg6]
+    push %%ebp
+    mov 4(%%esp), %%ebp
+    int $128
+    pop %%ebp
+    add $4, %%esp
+  )"
+                  : "=a"(ret)
+                  : "a"(num), "b"(arg1), "c"(arg2), "d"(arg3), "S"(arg4),
+                    "D"(arg5), [arg6] "m"(arg6)
+                  : "memory");
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_I386_SYSCALL_H
diff --git a/src/__support/OSUtil/linux/i386/vdso.h b/src/__support/OSUtil/linux/i386/vdso.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/__support/OSUtil/linux/io.h b/src/__support/OSUtil/linux/io.h
index fd5d2e1..63e5b12 100644
--- a/src/__support/OSUtil/linux/io.h
+++ b/src/__support/OSUtil/linux/io.h
@@ -10,17 +10,18 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_IO_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "syscall.h" // For internal syscall function.
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE void write_to_stderr(cpp::string_view msg) {
   LIBC_NAMESPACE::syscall_impl<long>(SYS_write, 2 /* stderr */, msg.data(),
                                      msg.size());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_IO_H
diff --git a/src/__support/OSUtil/linux/riscv/syscall.h b/src/__support/OSUtil/linux/riscv/syscall.h
index 4fc716f..e460e9b 100644
--- a/src/__support/OSUtil/linux/riscv/syscall.h
+++ b/src/__support/OSUtil/linux/riscv/syscall.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_RISCV_SYSCALL_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #define REGISTER_DECL_0                                                        \
   register long a7 __asm__("a7") = number;                                     \
@@ -42,7 +43,7 @@
 #define SYSCALL_INSTR(input_constraint)                                        \
   LIBC_INLINE_ASM("ecall\n\t" : "=r"(a0) : input_constraint : "memory")
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE long syscall_impl(long number) {
   REGISTER_DECL_0;
@@ -89,7 +90,7 @@ LIBC_INLINE long syscall_impl(long number, long arg1, long arg2, long arg3,
   return a0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef REGISTER_DECL_0
 #undef REGISTER_DECL_1
diff --git a/src/__support/OSUtil/linux/riscv/vdso.h b/src/__support/OSUtil/linux/riscv/vdso.h
new file mode 100644
index 0000000..24ddb25
--- /dev/null
+++ b/src/__support/OSUtil/linux/riscv/vdso.h
@@ -0,0 +1,43 @@
+//===---------- RISC-V vdso configuration -------------------------* C++ *-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_RISCV_VDSO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_RISCV_VDSO_H
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/OSUtil/linux/vdso_sym.h"
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+// translate VDSOSym to symbol names
+// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kernel/vdso/vdso.lds.S
+LIBC_INLINE constexpr cpp::string_view symbol_name(VDSOSym sym) {
+  switch (sym) {
+  case VDSOSym::RTSigReturn:
+    return "__vdso_rt_sigreturn";
+  case VDSOSym::GetTimeOfDay:
+    return "__vdso_gettimeofday";
+  case VDSOSym::ClockGetTime:
+    return "__vdso_clock_gettime";
+  case VDSOSym::ClockGetRes:
+    return "__vdso_clock_getres";
+  case VDSOSym::GetCpu:
+    return "__vdso_getcpu";
+  case VDSOSym::FlushICache:
+    return "__vdso_flush_icache";
+  case VDSOSym::RiscvHwProbe:
+    return "__vdso_riscv_hwprobe";
+  default:
+    return "";
+  }
+}
+
+// symbol versions
+LIBC_INLINE constexpr cpp::string_view symbol_version(VDSOSym) {
+  return "LINUX_4.15";
+}
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_RISCV_VDSO_H
diff --git a/src/__support/OSUtil/linux/syscall.h b/src/__support/OSUtil/linux/syscall.h
index 2be3cef..24e0fca 100644
--- a/src/__support/OSUtil/linux/syscall.h
+++ b/src/__support/OSUtil/linux/syscall.h
@@ -11,9 +11,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
-#ifdef LIBC_TARGET_ARCH_IS_X86_64
+#ifdef LIBC_TARGET_ARCH_IS_X86_32
+#include "i386/syscall.h"
+#elif defined(LIBC_TARGET_ARCH_IS_X86_64)
 #include "x86_64/syscall.h"
 #elif defined(LIBC_TARGET_ARCH_IS_AARCH64)
 #include "aarch64/syscall.h"
@@ -23,7 +26,7 @@
 #include "riscv/syscall.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename R, typename... Ts>
 LIBC_INLINE R syscall_impl(long __number, Ts... ts) {
@@ -31,6 +34,6 @@ LIBC_INLINE R syscall_impl(long __number, Ts... ts) {
   return cpp::bit_or_static_cast<R>(syscall_impl(__number, (long)ts...));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_SYSCALL_H
diff --git a/src/__support/OSUtil/linux/vdso.cpp b/src/__support/OSUtil/linux/vdso.cpp
new file mode 100644
index 0000000..8c9bd3e
--- /dev/null
+++ b/src/__support/OSUtil/linux/vdso.cpp
@@ -0,0 +1,239 @@
+//===------------- Linux VDSO Implementation --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "src/__support/OSUtil/linux/vdso.h"
+#include "hdr/link_macros.h"
+#include "hdr/sys_auxv_macros.h"
+#include "src/__support/CPP/array.h"
+#include "src/__support/CPP/optional.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/threads/callonce.h"
+#include "src/__support/threads/linux/futex_word.h"
+#include "src/errno/libc_errno.h"
+#include "src/sys/auxv/getauxval.h"
+#include <linux/auxvec.h>
+
+// TODO: This is a temporary workaround to avoid including elf.h
+// Include our own headers for ElfW and friends once we have them.
+namespace LIBC_NAMESPACE_DECL {
+
+namespace vdso {
+
+Symbol::VDSOArray Symbol::global_cache{};
+CallOnceFlag Symbol::once_flag = callonce_impl::NOT_CALLED;
+
+namespace {
+// See https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/symverdefs.html
+struct Verdaux {
+  ElfW(Word) vda_name; /* Version or dependency names */
+  ElfW(Word) vda_next; /* Offset in bytes to next verdaux
+                          entry */
+};
+struct Verdef {
+  ElfW(Half) vd_version; /* Version revision */
+  ElfW(Half) vd_flags;   /* Version information */
+  ElfW(Half) vd_ndx;     /* Version Index */
+  ElfW(Half) vd_cnt;     /* Number of associated aux entries */
+  ElfW(Word) vd_hash;    /* Version name hash value */
+  ElfW(Word) vd_aux;     /* Offset in bytes to verdaux array */
+  ElfW(Word) vd_next;    /* Offset in bytes to next verdef entry */
+  Verdef *next() const {
+    if (vd_next == 0)
+      return nullptr;
+    return reinterpret_cast<Verdef *>(reinterpret_cast<uintptr_t>(this) +
+                                      vd_next);
+  }
+  Verdaux *aux() const {
+    return reinterpret_cast<Verdaux *>(reinterpret_cast<uintptr_t>(this) +
+                                       vd_aux);
+  }
+};
+
+// version search procedure specified by
+// https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/symversion.html#SYMVERTBL
+cpp::string_view find_version(Verdef *verdef, ElfW(Half) * versym,
+                              const char *strtab, size_t idx) {
+#ifndef VER_FLG_BASE
+  constexpr ElfW(Half) VER_FLG_BASE = 0x1;
+#endif
+  if (!versym)
+    return "";
+  ElfW(Half) identifier = versym[idx] & 0x7FFF;
+  // iterate through all version definitions
+  for (Verdef *def = verdef; def != nullptr; def = def->next()) {
+    // skip if this is a file-level version
+    if (def->vd_flags & VER_FLG_BASE)
+      continue;
+    // check if the version identifier matches. Highest bit is used to determine
+    // whether the symbol is local. Only lower 15 bits are used for version
+    // identifier.
+    if ((def->vd_ndx & 0x7FFF) == identifier) {
+      Verdaux *aux = def->aux();
+      return strtab + aux->vda_name;
+    }
+  }
+  return "";
+}
+
+size_t shdr_get_symbol_count(ElfW(Shdr) * vdso_shdr, size_t e_shnum) {
+  if (!vdso_shdr)
+    return 0;
+  // iterate all sections until we locate the dynamic symbol section
+  for (size_t i = 0; i < e_shnum; ++i) {
+    // dynamic symbol section is a table section
+    // therefore, the number of entries can be computed as the ratio
+    // of the section size to the size of a single entry
+    if (vdso_shdr[i].sh_type == SHT_DYNSYM)
+      return vdso_shdr[i].sh_size / vdso_shdr[i].sh_entsize;
+  }
+  return 0;
+}
+
+struct VDSOSymbolTable {
+  const char *strtab;
+  ElfW(Sym) * symtab;
+  // The following can be nullptr if the vDSO does not have versioning
+  ElfW(Half) * versym;
+  Verdef *verdef;
+
+  void populate_symbol_cache(Symbol::VDSOArray &symbol_table,
+                             size_t symbol_count, ElfW(Addr) vdso_addr) {
+    for (size_t i = 0, e = symbol_table.size(); i < e; ++i) {
+      Symbol sym = i;
+      cpp::string_view name = sym.name();
+      cpp::string_view version = sym.version();
+      if (name.empty())
+        continue;
+
+      for (size_t j = 0; j < symbol_count; ++j) {
+        if (name == strtab + symtab[j].st_name) {
+          // we find a symbol with desired name
+          // now we need to check if it has the right version
+          if (versym && verdef &&
+              version != find_version(verdef, versym, strtab, j))
+            continue;
+
+          // put the symbol address into the symbol table
+          symbol_table[i] =
+              reinterpret_cast<void *>(vdso_addr + symtab[j].st_value);
+        }
+      }
+    }
+  }
+};
+
+struct PhdrInfo {
+  ElfW(Addr) vdso_addr;
+  ElfW(Dyn) * vdso_dyn;
+  static cpp::optional<PhdrInfo> from(ElfW(Phdr) * vdso_phdr, size_t e_phnum,
+                                      uintptr_t vdso_ehdr_addr) {
+    constexpr ElfW(Addr) INVALID_ADDR = static_cast<ElfW(Addr)>(-1);
+    ElfW(Addr) vdso_addr = INVALID_ADDR;
+    ElfW(Dyn) *vdso_dyn = nullptr;
+    if (!vdso_phdr)
+      return cpp::nullopt;
+    // iterate through all the program headers until we get the desired pieces
+    for (size_t i = 0; i < e_phnum; ++i) {
+      if (vdso_phdr[i].p_type == PT_DYNAMIC)
+        vdso_dyn = reinterpret_cast<ElfW(Dyn) *>(vdso_ehdr_addr +
+                                                 vdso_phdr[i].p_offset);
+
+      if (vdso_phdr[i].p_type == PT_LOAD)
+        vdso_addr =
+            vdso_ehdr_addr + vdso_phdr[i].p_offset - vdso_phdr[i].p_vaddr;
+
+      if (vdso_addr && vdso_dyn)
+        return PhdrInfo{vdso_addr, vdso_dyn};
+    }
+
+    return cpp::nullopt;
+  }
+
+  cpp::optional<VDSOSymbolTable> populate_symbol_table() {
+    const char *strtab = nullptr;
+    ElfW(Sym) *symtab = nullptr;
+    ElfW(Half) *versym = nullptr;
+    Verdef *verdef = nullptr;
+    for (ElfW(Dyn) *d = vdso_dyn; d->d_tag != DT_NULL; ++d) {
+      switch (d->d_tag) {
+      case DT_STRTAB:
+        strtab = reinterpret_cast<const char *>(vdso_addr + d->d_un.d_ptr);
+        break;
+      case DT_SYMTAB:
+        symtab = reinterpret_cast<ElfW(Sym) *>(vdso_addr + d->d_un.d_ptr);
+        break;
+      case DT_VERSYM:
+        versym = reinterpret_cast<uint16_t *>(vdso_addr + d->d_un.d_ptr);
+        break;
+      case DT_VERDEF:
+        verdef = reinterpret_cast<Verdef *>(vdso_addr + d->d_un.d_ptr);
+        break;
+      }
+      if (strtab && symtab && versym && verdef)
+        break;
+    }
+    if (strtab == nullptr || symtab == nullptr)
+      return cpp::nullopt;
+
+    return VDSOSymbolTable{strtab, symtab, versym, verdef};
+  }
+};
+} // namespace
+
+void Symbol::initialize_vdso_global_cache() {
+  // first clear the symbol table
+  for (auto &i : global_cache)
+    i = nullptr;
+
+  // get the address of the VDSO, protect errno since getauxval may change
+  // it
+  int errno_backup = libc_errno;
+  uintptr_t vdso_ehdr_addr = getauxval(AT_SYSINFO_EHDR);
+  // Get the memory address of the vDSO ELF header.
+  auto vdso_ehdr = reinterpret_cast<ElfW(Ehdr) *>(vdso_ehdr_addr);
+  // leave the table unpopulated if we don't have vDSO
+  if (vdso_ehdr == nullptr) {
+    libc_errno = errno_backup;
+    return;
+  }
+
+  // locate the section header inside the elf using the section header
+  // offset
+  auto vdso_shdr =
+      reinterpret_cast<ElfW(Shdr) *>(vdso_ehdr_addr + vdso_ehdr->e_shoff);
+  size_t symbol_count = shdr_get_symbol_count(vdso_shdr, vdso_ehdr->e_shnum);
+
+  // early return if no symbol is found
+  if (symbol_count == 0)
+    return;
+
+  // We need to find both the loadable segment and the dynamic linking of
+  // the vDSO. compute vdso_phdr as the program header using the program
+  // header offset
+  ElfW(Phdr) *vdso_phdr =
+      reinterpret_cast<ElfW(Phdr) *>(vdso_ehdr_addr + vdso_ehdr->e_phoff);
+  cpp::optional<PhdrInfo> phdr_info =
+      PhdrInfo::from(vdso_phdr, vdso_ehdr->e_phnum, vdso_ehdr_addr);
+  // early return if either the dynamic linking or the loadable segment is
+  // not found
+  if (!phdr_info.has_value())
+    return;
+
+  // now, locate several more tables inside the dynmaic linking section
+  cpp::optional<VDSOSymbolTable> vdso_symbol_table =
+      phdr_info->populate_symbol_table();
+
+  // early return if we can't find any required fields of the symbol table
+  if (!vdso_symbol_table.has_value())
+    return;
+
+  // finally, populate the global symbol table cache
+  vdso_symbol_table->populate_symbol_cache(global_cache, symbol_count,
+                                           phdr_info->vdso_addr);
+}
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/linux/vdso.h b/src/__support/OSUtil/linux/vdso.h
new file mode 100644
index 0000000..a5108b3
--- /dev/null
+++ b/src/__support/OSUtil/linux/vdso.h
@@ -0,0 +1,81 @@
+//===------------- Linux VDSO Header ----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_VDSO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_VDSO_H
+#include "src/__support/CPP/array.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/properties/architectures.h"
+#include "src/__support/threads/callonce.h"
+
+#if defined(LIBC_TARGET_ARCH_IS_X86)
+#include "x86_64/vdso.h"
+#elif defined(LIBC_TARGET_ARCH_IS_AARCH64)
+#include "aarch64/vdso.h"
+#elif defined(LIBC_TARGET_ARCH_IS_ARM)
+#include "arm/vdso.h"
+#elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
+#include "riscv/vdso.h"
+#else
+#error "unknown arch"
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+
+class Symbol {
+  VDSOSym sym;
+
+public:
+  LIBC_INLINE_VAR static constexpr size_t COUNT =
+      static_cast<size_t>(VDSOSym::VDSOSymCount);
+  LIBC_INLINE constexpr explicit Symbol(VDSOSym sym) : sym(sym) {}
+  LIBC_INLINE constexpr Symbol(size_t idx) : sym(static_cast<VDSOSym>(idx)) {}
+  LIBC_INLINE constexpr cpp::string_view name() const {
+    return symbol_name(sym);
+  }
+  LIBC_INLINE constexpr cpp::string_view version() const {
+    return symbol_version(sym);
+  }
+  LIBC_INLINE constexpr operator size_t() const {
+    return static_cast<size_t>(sym);
+  }
+  LIBC_INLINE constexpr bool is_valid() const {
+    return *this < Symbol::global_cache.size();
+  }
+  using VDSOArray = cpp::array<void *, Symbol::COUNT>;
+
+private:
+  static CallOnceFlag once_flag;
+  static VDSOArray global_cache;
+  static void initialize_vdso_global_cache();
+
+  LIBC_INLINE void *get() const {
+    if (name().empty() || !is_valid())
+      return nullptr;
+
+    callonce(&once_flag, Symbol::initialize_vdso_global_cache);
+    return (global_cache[*this]);
+  }
+  template <VDSOSym sym> friend struct TypedSymbol;
+};
+
+template <VDSOSym sym> struct TypedSymbol {
+  LIBC_INLINE constexpr operator VDSOSymType<sym>() const {
+    return cpp::bit_cast<VDSOSymType<sym>>(Symbol{sym}.get());
+  }
+  template <typename... Args>
+  LIBC_INLINE auto operator()(Args &&...args) const {
+    return this->operator VDSOSymType<sym>()(cpp::forward<Args>(args)...);
+  }
+};
+
+} // namespace vdso
+
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_VDSO_H
diff --git a/src/__support/OSUtil/linux/vdso_sym.h b/src/__support/OSUtil/linux/vdso_sym.h
new file mode 100644
index 0000000..968e153
--- /dev/null
+++ b/src/__support/OSUtil/linux/vdso_sym.h
@@ -0,0 +1,70 @@
+//===------------- Linux VDSO Symbols ---------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "hdr/types/clock_t.h"
+#include "hdr/types/clockid_t.h"
+#include "hdr/types/struct_timespec.h"
+#include "hdr/types/struct_timeval.h"
+#include "hdr/types/time_t.h"
+#include "src/__support/common.h"
+#include <stddef.h> // For size_t.
+
+// NOLINTBEGIN(llvmlibc-implementation-in-namespace)
+// TODO: some of the following can be defined via proxy headers.
+struct __kernel_timespec;
+struct timezone;
+struct riscv_hwprobe;
+struct getcpu_cache;
+struct cpu_set_t;
+// NOLINTEND(llvmlibc-implementation-in-namespace)
+
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+
+enum class VDSOSym {
+  ClockGetTime,
+  ClockGetTime64,
+  GetTimeOfDay,
+  GetCpu,
+  Time,
+  ClockGetRes,
+  RTSigReturn,
+  FlushICache,
+  RiscvHwProbe,
+  VDSOSymCount
+};
+
+template <VDSOSym sym> LIBC_INLINE constexpr auto dispatcher() {
+  if constexpr (sym == VDSOSym::ClockGetTime)
+    return static_cast<int (*)(clockid_t, timespec *)>(nullptr);
+  else if constexpr (sym == VDSOSym::ClockGetTime64)
+    return static_cast<int (*)(clockid_t, __kernel_timespec *)>(nullptr);
+  else if constexpr (sym == VDSOSym::GetTimeOfDay)
+    return static_cast<int (*)(timeval *__restrict,
+                               struct timezone *__restrict)>(nullptr);
+  else if constexpr (sym == VDSOSym::GetCpu)
+    return static_cast<int (*)(unsigned *, unsigned *, getcpu_cache *)>(
+        nullptr);
+  else if constexpr (sym == VDSOSym::Time)
+    return static_cast<time_t (*)(time_t *)>(nullptr);
+  else if constexpr (sym == VDSOSym::ClockGetRes)
+    return static_cast<int (*)(clockid_t, timespec *)>(nullptr);
+  else if constexpr (sym == VDSOSym::RTSigReturn)
+    return static_cast<void (*)(void)>(nullptr);
+  else if constexpr (sym == VDSOSym::FlushICache)
+    return static_cast<void (*)(void *, void *, unsigned int)>(nullptr);
+  else if constexpr (sym == VDSOSym::RiscvHwProbe)
+    return static_cast<int (*)(riscv_hwprobe *, size_t, size_t, cpu_set_t *,
+                               unsigned)>(nullptr);
+  else
+    return static_cast<void *>(nullptr);
+}
+
+template <VDSOSym sym> using VDSOSymType = decltype(dispatcher<sym>());
+
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/linux/x86_64/syscall.h b/src/__support/OSUtil/linux/x86_64/syscall.h
index 986db93..ebd7798 100644
--- a/src/__support/OSUtil/linux/x86_64/syscall.h
+++ b/src/__support/OSUtil/linux/x86_64/syscall.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_X86_64_SYSCALL_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #define SYSCALL_CLOBBER_LIST "rcx", "r11", "memory"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE long syscall_impl(long __number) {
   long retcode;
@@ -93,6 +94,6 @@ LIBC_INLINE long syscall_impl(long __number, long __arg1, long __arg2,
 }
 
 #undef SYSCALL_CLOBBER_LIST
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_X86_64_SYSCALL_H
diff --git a/src/__support/OSUtil/linux/x86_64/vdso.h b/src/__support/OSUtil/linux/x86_64/vdso.h
new file mode 100644
index 0000000..abe7c33
--- /dev/null
+++ b/src/__support/OSUtil/linux/x86_64/vdso.h
@@ -0,0 +1,43 @@
+//===---------- x86/x86_64 vdso configuration ---------------------* C++ *-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_X86_64_VDSO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_X86_64_VDSO_H
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/OSUtil/linux/vdso_sym.h"
+namespace LIBC_NAMESPACE_DECL {
+namespace vdso {
+// translate VDSOSym to symbol names
+// On x86, there are symbols defined without the __vdso_ prefix, however,
+// it is suggested that one should use the __vdso_ prefix.
+// Additionally, there is also an __vdso_sgx_enter_enclave, it is for the SGX
+// support, we do not include it here for now.
+// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/vdso/vdso.lds.S
+LIBC_INLINE constexpr cpp::string_view symbol_name(VDSOSym sym) {
+  switch (sym) {
+  case VDSOSym::ClockGetTime:
+    return "__vdso_clock_gettime";
+  case VDSOSym::GetTimeOfDay:
+    return "__vdso_gettimeofday";
+  case VDSOSym::GetCpu:
+    return "__vdso_getcpu";
+  case VDSOSym::Time:
+    return "__vdso_time";
+  case VDSOSym::ClockGetRes:
+    return "__vdso_clock_getres";
+  default:
+    return "";
+  }
+}
+
+// symbol versions
+LIBC_INLINE constexpr cpp::string_view symbol_version(VDSOSym) {
+  return "LINUX_2.6";
+}
+} // namespace vdso
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_LINUX_X86_64_VDSO_H
diff --git a/src/__support/OSUtil/windows/exit.cpp b/src/__support/OSUtil/windows/exit.cpp
new file mode 100644
index 0000000..369b07b
--- /dev/null
+++ b/src/__support/OSUtil/windows/exit.cpp
@@ -0,0 +1,23 @@
+//===-- Windows implementation of an exit function ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
+
+// On Windows we cannot make direct syscalls since Microsoft changes system call
+// IDs periodically. We must rely on functions exported from ntdll.dll or
+// kernel32.dll to invoke system service procedures.
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+[[noreturn]] void exit(int status) { ::ExitProcess(status); }
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/windows/io.cpp b/src/__support/OSUtil/windows/io.cpp
new file mode 100644
index 0000000..af3d1b9
--- /dev/null
+++ b/src/__support/OSUtil/windows/io.cpp
@@ -0,0 +1,25 @@
+//===------------- Windows implementation of IO utils -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "io.h"
+#include "src/__support/macros/config.h"
+
+// On Windows we cannot make direct syscalls since Microsoft changes system call
+// IDs periodically. We must rely on functions exported from ntdll.dll or
+// kernel32.dll to invoke system service procedures.
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+void write_to_stderr(cpp::string_view msg) {
+  ::HANDLE stream = ::GetStdHandle(STD_ERROR_HANDLE);
+  ::WriteFile(stream, msg.data(), msg.size(), nullptr, nullptr);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/windows/io.h b/src/__support/OSUtil/windows/io.h
new file mode 100644
index 0000000..bafc002
--- /dev/null
+++ b/src/__support/OSUtil/windows/io.h
@@ -0,0 +1,21 @@
+//===------------- Windows implementation of IO utils -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_WINDOWS_IO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_WINDOWS_IO_H
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void write_to_stderr(cpp::string_view msg);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_WINDOWS_IO_H
diff --git a/src/__support/RPC/rpc_client.cpp b/src/__support/RPC/rpc_client.cpp
index 8367d54..625e474 100644
--- a/src/__support/RPC/rpc_client.cpp
+++ b/src/__support/RPC/rpc_client.cpp
@@ -7,19 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "rpc_client.h"
-#include "rpc.h"
 
-namespace LIBC_NAMESPACE {
-namespace rpc {
+#include "src/__support/macros/config.h"
 
-/// The libc client instance used to communicate with the server.
-Client client;
+namespace LIBC_NAMESPACE_DECL {
+namespace rpc {
 
-/// Externally visible symbol to signify the usage of an RPC client to
-/// whomever needs to run the server as well as provide a way to initialize
-/// the client with a copy..
-extern "C" [[gnu::visibility("protected")]] const void *__llvm_libc_rpc_client =
-    &client;
+/// The libc client instance used to communicate with the server. Externally
+/// visible symbol to signify the usage of an RPC client to whomever needs to
+/// run the server as well as provide a way to initialize the client.
+[[gnu::visibility("protected")]] Client client;
 
 } // namespace rpc
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/RPC/rpc_client.h b/src/__support/RPC/rpc_client.h
index 6e1827d..199803b 100644
--- a/src/__support/RPC/rpc_client.h
+++ b/src/__support/RPC/rpc_client.h
@@ -9,17 +9,29 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_RPC_RPC_CLIENT_H
 #define LLVM_LIBC_SRC___SUPPORT_RPC_RPC_CLIENT_H
 
-#include "rpc.h"
+#include "shared/rpc.h"
+#include "shared/rpc_opcodes.h"
 
-#include "include/llvm-libc-types/rpc_opcodes_t.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace rpc {
 
+using ::rpc::Buffer;
+using ::rpc::Client;
+using ::rpc::Port;
+using ::rpc::Process;
+using ::rpc::Server;
+
+static_assert(cpp::is_trivially_copyable<Client>::value &&
+                  sizeof(Process<true>) == sizeof(Process<false>),
+              "The client is not trivially copyable from the server");
+
 /// The libc client instance used to communicate with the server.
-extern Client client;
+[[gnu::visibility("protected")]] extern Client client asm("__llvm_rpc_client");
 
 } // namespace rpc
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif
diff --git a/src/__support/RPC/rpc_util.h b/src/__support/RPC/rpc_util.h
deleted file mode 100644
index 7a9901a..0000000
--- a/src/__support/RPC/rpc_util.h
+++ /dev/null
@@ -1,72 +0,0 @@
-//===-- Shared memory RPC client / server utilities -------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_SRC___SUPPORT_RPC_RPC_UTIL_H
-#define LLVM_LIBC_SRC___SUPPORT_RPC_RPC_UTIL_H
-
-#include "src/__support/CPP/type_traits.h"
-#include "src/__support/GPU/utils.h"
-#include "src/__support/macros/attributes.h"
-#include "src/__support/macros/properties/architectures.h"
-#include "src/__support/threads/sleep.h"
-#include "src/string/memory_utils/generic/byte_per_byte.h"
-#include "src/string/memory_utils/inline_memcpy.h"
-
-namespace LIBC_NAMESPACE {
-namespace rpc {
-
-/// Conditional to indicate if this process is running on the GPU.
-LIBC_INLINE constexpr bool is_process_gpu() {
-#if defined(LIBC_TARGET_ARCH_IS_GPU)
-  return true;
-#else
-  return false;
-#endif
-}
-
-/// Return \p val aligned "upwards" according to \p align.
-template <typename V, typename A>
-LIBC_INLINE constexpr V align_up(V val, A align) {
-  return ((val + V(align) - 1) / V(align)) * V(align);
-}
-
-/// Utility to provide a unified interface between the CPU and GPU's memory
-/// model. On the GPU stack variables are always private to a lane so we can
-/// simply use the variable passed in. On the CPU we need to allocate enough
-/// space for the whole lane and index into it.
-template <typename V> LIBC_INLINE V &lane_value(V *val, uint32_t id) {
-  if constexpr (is_process_gpu())
-    return *val;
-  return val[id];
-}
-
-/// Advance the \p p by \p bytes.
-template <typename T, typename U> LIBC_INLINE T *advance(T *ptr, U bytes) {
-  if constexpr (cpp::is_const_v<T>)
-    return reinterpret_cast<T *>(reinterpret_cast<const uint8_t *>(ptr) +
-                                 bytes);
-  else
-    return reinterpret_cast<T *>(reinterpret_cast<uint8_t *>(ptr) + bytes);
-}
-
-/// Wrapper around the optimal memory copy implementation for the target.
-LIBC_INLINE void rpc_memcpy(void *dst, const void *src, size_t count) {
-  // The built-in memcpy prefers to fully unroll loops. We want to minimize
-  // resource usage so we use a single nounroll loop implementation.
-#if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
-  inline_memcpy_byte_per_byte(reinterpret_cast<Ptr>(dst),
-                              reinterpret_cast<CPtr>(src), count);
-#else
-  inline_memcpy(dst, src, count);
-#endif
-}
-
-} // namespace rpc
-} // namespace LIBC_NAMESPACE
-
-#endif // LLVM_LIBC_SRC___SUPPORT_RPC_RPC_UTIL_H
diff --git a/src/__support/StringUtil/error_to_string.cpp b/src/__support/StringUtil/error_to_string.cpp
index 3ea60a6..3b22021 100644
--- a/src/__support/StringUtil/error_to_string.cpp
+++ b/src/__support/StringUtil/error_to_string.cpp
@@ -15,10 +15,11 @@
 #include "src/__support/StringUtil/message_mapper.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 constexpr size_t max_buff_size() {
@@ -44,7 +45,10 @@ constexpr size_t TOTAL_STR_LEN = total_str_len(PLATFORM_ERRORS);
 constexpr size_t ERR_ARRAY_SIZE = max_key_val(PLATFORM_ERRORS) + 1;
 
 constexpr MessageMapper<ERR_ARRAY_SIZE, TOTAL_STR_LEN>
-    error_mapper(PLATFORM_ERRORS);
+    ERROR_MAPPER(PLATFORM_ERRORS);
+
+constexpr MessageMapper<ERR_ARRAY_SIZE, TOTAL_STR_LEN>
+    ERRNO_NAME_MAPPER(PLATFORM_ERRNO_NAMES);
 
 cpp::string_view build_error_string(int err_num, cpp::span<char> buffer) {
   // if the buffer can't hold "Unknown error" + ' ' + num_str, then just
@@ -67,11 +71,15 @@ cpp::string_view get_error_string(int err_num) {
 }
 
 cpp::string_view get_error_string(int err_num, cpp::span<char> buffer) {
-  auto opt_str = internal::error_mapper.get_str(err_num);
+  auto opt_str = internal::ERROR_MAPPER.get_str(err_num);
   if (opt_str)
     return *opt_str;
   else
     return internal::build_error_string(err_num, buffer);
 }
 
-} // namespace LIBC_NAMESPACE
+cpp::optional<cpp::string_view> try_get_errno_name(int err_num) {
+  return internal::ERRNO_NAME_MAPPER.get_str(err_num);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/StringUtil/error_to_string.h b/src/__support/StringUtil/error_to_string.h
index 43cf785..dfbd03f 100644
--- a/src/__support/StringUtil/error_to_string.h
+++ b/src/__support/StringUtil/error_to_string.h
@@ -9,15 +9,19 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_ERROR_TO_STRING_H
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_ERROR_TO_STRING_H
 
+#include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 cpp::string_view get_error_string(int err_num);
 
 cpp::string_view get_error_string(int err_num, cpp::span<char> buffer);
 
-} // namespace LIBC_NAMESPACE
+cpp::optional<cpp::string_view> try_get_errno_name(int err_num);
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_ERROR_TO_STRING_H
diff --git a/src/__support/StringUtil/message_mapper.h b/src/__support/StringUtil/message_mapper.h
index dd91839..df7506a 100644
--- a/src/__support/StringUtil/message_mapper.h
+++ b/src/__support/StringUtil/message_mapper.h
@@ -12,9 +12,10 @@
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct MsgMapping {
   int num;
@@ -98,6 +99,6 @@ constexpr MsgTable<N1 + N2> operator+(const MsgTable<N1> &t1,
   return res;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_MESSAGE_MAPPER_H
diff --git a/src/__support/StringUtil/signal_to_string.cpp b/src/__support/StringUtil/signal_to_string.cpp
index 1fea53a..b67d288 100644
--- a/src/__support/StringUtil/signal_to_string.cpp
+++ b/src/__support/StringUtil/signal_to_string.cpp
@@ -15,11 +15,12 @@
 #include "src/__support/StringUtil/message_mapper.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <signal.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 constexpr size_t max_buff_size() {
@@ -77,4 +78,4 @@ cpp::string_view get_signal_string(int sig_num, cpp::span<char> buffer) {
     return internal::build_signal_string(sig_num, buffer);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/StringUtil/signal_to_string.h b/src/__support/StringUtil/signal_to_string.h
index e27324e..a162486 100644
--- a/src/__support/StringUtil/signal_to_string.h
+++ b/src/__support/StringUtil/signal_to_string.h
@@ -12,13 +12,14 @@
 
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 cpp::string_view get_signal_string(int err_num);
 
 cpp::string_view get_signal_string(int err_num, cpp::span<char> buffer);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_SIGNAL_TO_STRING_H
diff --git a/src/__support/StringUtil/tables/linux_extension_errors.h b/src/__support/StringUtil/tables/linux_extension_errors.h
index f489688..425590f 100644
--- a/src/__support/StringUtil/tables/linux_extension_errors.h
+++ b/src/__support/StringUtil/tables/linux_extension_errors.h
@@ -10,10 +10,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_EXTENSION_ERRORS_H
 
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h> // For error macros
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr MsgTable<52> LINUX_ERRORS = {
     MsgMapping(ENOTBLK, "Block device required"),
@@ -70,6 +70,61 @@ constexpr MsgTable<52> LINUX_ERRORS = {
     MsgMapping(EHWPOISON, "Memory page has hardware error"),
 };
 
-} // namespace LIBC_NAMESPACE
+constexpr MsgTable<52> LINUX_ERRNO_NAMES = {
+    MsgMapping(ENOTBLK, "ENOTBLK"),
+    MsgMapping(ECHRNG, "ECHRNG"),
+    MsgMapping(EL2NSYNC, "EL2NSYNC"),
+    MsgMapping(EL3HLT, "EL3HLT"),
+    MsgMapping(EL3RST, "EL3RST"),
+    MsgMapping(ELNRNG, "ELNRNG"),
+    MsgMapping(EUNATCH, "EUNATCH"),
+    MsgMapping(ENOCSI, "ENOCSI"),
+    MsgMapping(EL2HLT, "EL2HLT"),
+    MsgMapping(EBADE, "EBADE"),
+    MsgMapping(EBADR, "EBADR"),
+    MsgMapping(EXFULL, "EXFULL"),
+    MsgMapping(ENOANO, "ENOANO"),
+    MsgMapping(EBADRQC, "EBADRQC"),
+    MsgMapping(EBADSLT, "EBADSLT"),
+    MsgMapping(EBFONT, "EBFONT"),
+    MsgMapping(ENONET, "ENONET"),
+    MsgMapping(ENOPKG, "ENOPKG"),
+    MsgMapping(EREMOTE, "EREMOTE"),
+    MsgMapping(EADV, "EADV"),
+    MsgMapping(ESRMNT, "ESRMNT"),
+    MsgMapping(ECOMM, "ECOMM"),
+    MsgMapping(EDOTDOT, "EDOTDOT"),
+    MsgMapping(ENOTUNIQ, "ENOTUNIQ"),
+    MsgMapping(EBADFD, "EBADFD"),
+    MsgMapping(EREMCHG, "EREMCHG"),
+    MsgMapping(ELIBACC, "ELIBACC"),
+    MsgMapping(ELIBBAD, "ELIBBAD"),
+    MsgMapping(ELIBSCN, "ELIBSCN"),
+    MsgMapping(ELIBMAX, "ELIBMAX"),
+    MsgMapping(ELIBEXEC, "ELIBEXEC"),
+    MsgMapping(ERESTART, "ERESTART"),
+    MsgMapping(ESTRPIPE, "ESTRPIPE"),
+    MsgMapping(EUSERS, "EUSERS"),
+    MsgMapping(ESOCKTNOSUPPORT, "ESOCKTNOSUPPORT"),
+    MsgMapping(EPFNOSUPPORT, "EPFNOSUPPORT"),
+    MsgMapping(ESHUTDOWN, "ESHUTDOWN"),
+    MsgMapping(ETOOMANYREFS, "ETOOMANYREFS"),
+    MsgMapping(EHOSTDOWN, "EHOSTDOWN"),
+    MsgMapping(EUCLEAN, "EUCLEAN"),
+    MsgMapping(ENOTNAM, "ENOTNAM"),
+    MsgMapping(ENAVAIL, "ENAVAIL"),
+    MsgMapping(EISNAM, "EISNAM"),
+    MsgMapping(EREMOTEIO, "EREMOTEIO"),
+    MsgMapping(ENOMEDIUM, "ENOMEDIUM"),
+    MsgMapping(EMEDIUMTYPE, "EMEDIUMTYPE"),
+    MsgMapping(ENOKEY, "ENOKEY"),
+    MsgMapping(EKEYEXPIRED, "EKEYEXPIRED"),
+    MsgMapping(EKEYREVOKED, "EKEYREVOKED"),
+    MsgMapping(EKEYREJECTED, "EKEYREJECTED"),
+    MsgMapping(ERFKILL, "ERFKILL"),
+    MsgMapping(EHWPOISON, "EHWPOISON"),
+};
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_EXTENSION_ERRORS_H
diff --git a/src/__support/StringUtil/tables/linux_extension_signals.h b/src/__support/StringUtil/tables/linux_extension_signals.h
index 3f9f0c6..c9cb26b 100644
--- a/src/__support/StringUtil/tables/linux_extension_signals.h
+++ b/src/__support/StringUtil/tables/linux_extension_signals.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_EXTENSION_SIGNALS_H
 
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
 
 #include <signal.h> // For signal numbers
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The array being larger than necessary isn't a problem. The MsgMappings will
 // be set to their default state which maps 0 to an empty string. This will get
@@ -28,6 +29,6 @@ LIBC_INLINE_VAR constexpr const MsgTable<3> LINUX_SIGNALS = {
 #endif
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_EXTENSION_SIGNALS_H
diff --git a/src/__support/StringUtil/tables/linux_platform_errors.h b/src/__support/StringUtil/tables/linux_platform_errors.h
index a7bb545..ce5ee38 100644
--- a/src/__support/StringUtil/tables/linux_platform_errors.h
+++ b/src/__support/StringUtil/tables/linux_platform_errors.h
@@ -11,13 +11,17 @@
 
 #include "linux_extension_errors.h"
 #include "posix_errors.h"
+#include "src/__support/macros/config.h"
 #include "stdc_errors.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr auto PLATFORM_ERRORS =
     STDC_ERRORS + POSIX_ERRORS + LINUX_ERRORS;
 
-} // namespace LIBC_NAMESPACE
+LIBC_INLINE_VAR constexpr auto PLATFORM_ERRNO_NAMES =
+    STDC_ERRNO_NAMES + POSIX_ERRNO_NAMES + LINUX_ERRNO_NAMES;
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_PLATFORM_ERRORS_H
diff --git a/src/__support/StringUtil/tables/linux_platform_signals.h b/src/__support/StringUtil/tables/linux_platform_signals.h
index f12d31f..7c816aa 100644
--- a/src/__support/StringUtil/tables/linux_platform_signals.h
+++ b/src/__support/StringUtil/tables/linux_platform_signals.h
@@ -11,13 +11,14 @@
 
 #include "linux_extension_signals.h"
 #include "posix_signals.h"
+#include "src/__support/macros/config.h"
 #include "stdc_signals.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr auto PLATFORM_SIGNALS =
     STDC_SIGNALS + POSIX_SIGNALS + LINUX_SIGNALS;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_LINUX_PLATFORM_SIGNALS_H
diff --git a/src/__support/StringUtil/tables/minimal_platform_errors.h b/src/__support/StringUtil/tables/minimal_platform_errors.h
index c5672c4..a9dcb36 100644
--- a/src/__support/StringUtil/tables/minimal_platform_errors.h
+++ b/src/__support/StringUtil/tables/minimal_platform_errors.h
@@ -9,12 +9,15 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_ERRORS_H
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_ERRORS_H
 
+#include "src/__support/macros/config.h"
 #include "stdc_errors.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr auto PLATFORM_ERRORS = STDC_ERRORS;
 
-} // namespace LIBC_NAMESPACE
+LIBC_INLINE_VAR constexpr auto PLATFORM_ERRNO_NAMES = STDC_ERRNO_NAMES;
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_ERRORS_H
diff --git a/src/__support/StringUtil/tables/minimal_platform_signals.h b/src/__support/StringUtil/tables/minimal_platform_signals.h
index 7fe0dcc..d4cecb3 100644
--- a/src/__support/StringUtil/tables/minimal_platform_signals.h
+++ b/src/__support/StringUtil/tables/minimal_platform_signals.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_SIGNALS_H
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_SIGNALS_H
 
+#include "src/__support/macros/config.h"
 #include "stdc_signals.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr auto PLATFORM_SIGNALS = STDC_SIGNALS;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_MINIMAL_PLATFORM_SIGNALS_H
diff --git a/src/__support/StringUtil/tables/posix_errors.h b/src/__support/StringUtil/tables/posix_errors.h
index 3cb6de3..b21f28f 100644
--- a/src/__support/StringUtil/tables/posix_errors.h
+++ b/src/__support/StringUtil/tables/posix_errors.h
@@ -9,11 +9,11 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_POSIX_ERRORS_H
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_POSIX_ERRORS_H
 
+#include "hdr/errno_macros.h"
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h> // For error macros
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr MsgTable<76> POSIX_ERRORS = {
     MsgMapping(EPERM, "Operation not permitted"),
@@ -94,6 +94,85 @@ LIBC_INLINE_VAR constexpr MsgTable<76> POSIX_ERRORS = {
     MsgMapping(ENOTRECOVERABLE, "State not recoverable"),
 };
 
-} // namespace LIBC_NAMESPACE
+LIBC_INLINE_VAR constexpr MsgTable<76> POSIX_ERRNO_NAMES = {
+    MsgMapping(EPERM, "EPERM"),
+    MsgMapping(ENOENT, "ENOENT"),
+    MsgMapping(ESRCH, "ESRCH"),
+    MsgMapping(EINTR, "EINTR"),
+    MsgMapping(EIO, "EIO"),
+    MsgMapping(ENXIO, "ENXIO"),
+    MsgMapping(E2BIG, "E2BIG"),
+    MsgMapping(ENOEXEC, "ENOEXEC"),
+    MsgMapping(EBADF, "EBADF"),
+    MsgMapping(ECHILD, "ECHILD"),
+    MsgMapping(EAGAIN, "EAGAIN"),
+    MsgMapping(ENOMEM, "ENOMEM"),
+    MsgMapping(EACCES, "EACCES"),
+    MsgMapping(EFAULT, "EFAULT"),
+    MsgMapping(EBUSY, "EBUSY"),
+    MsgMapping(EEXIST, "EEXIST"),
+    MsgMapping(EXDEV, "EXDEV"),
+    MsgMapping(ENODEV, "ENODEV"),
+    MsgMapping(ENOTDIR, "ENOTDIR"),
+    MsgMapping(EISDIR, "EISDIR"),
+    MsgMapping(EINVAL, "EINVAL"),
+    MsgMapping(ENFILE, "ENFILE"),
+    MsgMapping(EMFILE, "EMFILE"),
+    MsgMapping(ENOTTY, "ENOTTY"),
+    MsgMapping(ETXTBSY, "ETXTBSY"),
+    MsgMapping(EFBIG, "EFBIG"),
+    MsgMapping(ENOSPC, "ENOSPC"),
+    MsgMapping(ESPIPE, "ESPIPE"),
+    MsgMapping(EROFS, "EROFS"),
+    MsgMapping(EMLINK, "EMLINK"),
+    MsgMapping(EPIPE, "EPIPE"),
+    MsgMapping(EDEADLK, "EDEADLK"),
+    MsgMapping(ENAMETOOLONG, "ENAMETOOLONG"),
+    MsgMapping(ENOLCK, "ENOLCK"),
+    MsgMapping(ENOSYS, "ENOSYS"),
+    MsgMapping(ENOTEMPTY, "ENOTEMPTY"),
+    MsgMapping(ELOOP, "ELOOP"),
+    MsgMapping(ENOMSG, "ENOMSG"),
+    MsgMapping(EIDRM, "EIDRM"),
+    MsgMapping(ENOSTR, "ENOSTR"),
+    MsgMapping(ENODATA, "ENODATA"),
+    MsgMapping(ETIME, "ETIME"),
+    MsgMapping(ENOSR, "ENOSR"),
+    MsgMapping(ENOLINK, "ENOLINK"),
+    MsgMapping(EPROTO, "EPROTO"),
+    MsgMapping(EMULTIHOP, "EMULTIHOP"),
+    MsgMapping(EBADMSG, "EBADMSG"),
+    MsgMapping(EOVERFLOW, "EOVERFLOW"),
+    MsgMapping(ENOTSOCK, "ENOTSOCK"),
+    MsgMapping(EDESTADDRREQ, "EDESTADDRREQ"),
+    MsgMapping(EMSGSIZE, "EMSGSIZE"),
+    MsgMapping(EPROTOTYPE, "EPROTOTYPE"),
+    MsgMapping(ENOPROTOOPT, "ENOPROTOOPT"),
+    MsgMapping(EPROTONOSUPPORT, "EPROTONOSUPPORT"),
+    MsgMapping(ENOTSUP, "ENOTSUP"),
+    MsgMapping(EAFNOSUPPORT, "EAFNOSUPPORT"),
+    MsgMapping(EADDRINUSE, "EADDRINUSE"),
+    MsgMapping(EADDRNOTAVAIL, "EADDRNOTAVAIL"),
+    MsgMapping(ENETDOWN, "ENETDOWN"),
+    MsgMapping(ENETUNREACH, "ENETUNREACH"),
+    MsgMapping(ENETRESET, "ENETRESET"),
+    MsgMapping(ECONNABORTED, "ECONNABORTED"),
+    MsgMapping(ECONNRESET, "ECONNRESET"),
+    MsgMapping(ENOBUFS, "ENOBUFS"),
+    MsgMapping(EISCONN, "EISCONN"),
+    MsgMapping(ENOTCONN, "ENOTCONN"),
+    MsgMapping(ETIMEDOUT, "ETIMEDOUT"),
+    MsgMapping(ECONNREFUSED, "ECONNREFUSED"),
+    MsgMapping(EHOSTUNREACH, "EHOSTUNREACH"),
+    MsgMapping(EALREADY, "EALREADY"),
+    MsgMapping(EINPROGRESS, "EINPROGRESS"),
+    MsgMapping(ESTALE, "ESTALE"),
+    MsgMapping(EDQUOT, "EDQUOT"),
+    MsgMapping(ECANCELED, "ECANCELED"),
+    MsgMapping(EOWNERDEAD, "EOWNERDEAD"),
+    MsgMapping(ENOTRECOVERABLE, "ENOTRECOVERABLE"),
+};
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_POSIX_ERRORS_H
diff --git a/src/__support/StringUtil/tables/posix_signals.h b/src/__support/StringUtil/tables/posix_signals.h
index b9535cb..7c70f71 100644
--- a/src/__support/StringUtil/tables/posix_signals.h
+++ b/src/__support/StringUtil/tables/posix_signals.h
@@ -11,10 +11,11 @@
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
 
 #include <signal.h> // For signal numbers
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr MsgTable<22> POSIX_SIGNALS = {
     MsgMapping(SIGHUP, "Hangup"),
@@ -41,6 +42,6 @@ LIBC_INLINE_VAR constexpr MsgTable<22> POSIX_SIGNALS = {
     MsgMapping(SIGSYS, "Bad system call"),
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_POSIX_SIGNALS_H
diff --git a/src/__support/StringUtil/tables/signal_table.h b/src/__support/StringUtil/tables/signal_table.h
index d7ffbc6..bfec39b 100644
--- a/src/__support/StringUtil/tables/signal_table.h
+++ b/src/__support/StringUtil/tables/signal_table.h
@@ -12,6 +12,7 @@
 #include "src/__support/StringUtil/message_mapper.h"
 
 #include "posix_signals.h"
+#include "src/__support/macros/config.h"
 #include "stdc_signals.h"
 
 #if defined(__linux__) || defined(__Fuchsia__)
@@ -24,7 +25,8 @@
 #include "linux_extension_signals.h"
 #endif
 
-namespace LIBC_NAMESPACE::internal {
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 LIBC_INLINE_VAR constexpr auto PLATFORM_SIGNALS = []() {
   if constexpr (USE_LINUX_PLATFORM_SIGNALS) {
@@ -34,6 +36,7 @@ LIBC_INLINE_VAR constexpr auto PLATFORM_SIGNALS = []() {
   }
 }();
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_SIGNAL_TABLE_H
diff --git a/src/__support/StringUtil/tables/stdc_errors.h b/src/__support/StringUtil/tables/stdc_errors.h
index 6873d6b..a326616 100644
--- a/src/__support/StringUtil/tables/stdc_errors.h
+++ b/src/__support/StringUtil/tables/stdc_errors.h
@@ -9,18 +9,26 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_STDC_ERRORS_H
 #define LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_STDC_ERRORS_H
 
+#include "hdr/errno_macros.h"
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h> // For error macros
+namespace LIBC_NAMESPACE_DECL {
 
-namespace LIBC_NAMESPACE {
-
-LIBC_INLINE_VAR constexpr const MsgTable<3> STDC_ERRORS = {
+LIBC_INLINE_VAR constexpr const MsgTable<4> STDC_ERRORS = {
     MsgMapping(0, "Success"),
     MsgMapping(EDOM, "Numerical argument out of domain"),
     MsgMapping(ERANGE, "Numerical result out of range"),
+    MsgMapping(EILSEQ, "Invalid or incomplete multibyte or wide character"),
+};
+
+LIBC_INLINE_VAR constexpr const MsgTable<4> STDC_ERRNO_NAMES = {
+    MsgMapping(0, "0"),
+    MsgMapping(EDOM, "EDOM"),
+    MsgMapping(ERANGE, "ERANGE"),
+    MsgMapping(EILSEQ, "EILSEQ"),
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_STDC_ERRORS_H
diff --git a/src/__support/StringUtil/tables/stdc_signals.h b/src/__support/StringUtil/tables/stdc_signals.h
index 7c93b45..094b59b 100644
--- a/src/__support/StringUtil/tables/stdc_signals.h
+++ b/src/__support/StringUtil/tables/stdc_signals.h
@@ -12,8 +12,9 @@
 #include <signal.h> // For signal numbers
 
 #include "src/__support/StringUtil/message_mapper.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE_VAR constexpr const MsgTable<6> STDC_SIGNALS = {
     MsgMapping(SIGINT, "Interrupt"),
@@ -24,6 +25,6 @@ LIBC_INLINE_VAR constexpr const MsgTable<6> STDC_SIGNALS = {
     MsgMapping(SIGTERM, "Terminated"),
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STRINGUTIL_TABLES_STDC_SIGNALS_H
diff --git a/src/__support/arg_list.h b/src/__support/arg_list.h
index 0965e12..66afa67 100644
--- a/src/__support/arg_list.h
+++ b/src/__support/arg_list.h
@@ -10,14 +10,20 @@
 #define LLVM_LIBC_SRC___SUPPORT_ARG_LIST_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdarg.h>
 #include <stddef.h>
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
+template <typename V, typename A>
+LIBC_INLINE constexpr V align_up(V val, A align) {
+  return ((val + V(align) - 1) / V(align)) * V(align);
+}
+
 class ArgList {
   va_list vlist;
 
@@ -54,7 +60,34 @@ public:
   }
 
   template <class T> LIBC_INLINE T next_var() {
-    ++arg_counter;
+    arg_counter++;
+    return T(arg_counter);
+  }
+
+  size_t read_count() const { return arg_counter; }
+};
+
+// Used by the GPU implementation to parse how many bytes need to be read from
+// the variadic argument buffer.
+template <bool packed> class DummyArgList {
+  size_t arg_counter = 0;
+
+public:
+  LIBC_INLINE DummyArgList() = default;
+  LIBC_INLINE DummyArgList(va_list) { ; }
+  LIBC_INLINE DummyArgList(DummyArgList &other) {
+    arg_counter = other.arg_counter;
+  }
+  LIBC_INLINE ~DummyArgList() = default;
+
+  LIBC_INLINE DummyArgList &operator=(DummyArgList &rhs) {
+    arg_counter = rhs.arg_counter;
+    return *this;
+  }
+
+  template <class T> LIBC_INLINE T next_var() {
+    arg_counter = packed ? arg_counter + sizeof(T)
+                         : align_up(arg_counter, alignof(T)) + sizeof(T);
     return T(arg_counter);
   }
 
@@ -63,7 +96,7 @@ public:
 
 // Used for the GPU implementation of `printf`. This models a variadic list as a
 // simple array of pointers that are built manually by the implementation.
-class StructArgList {
+template <bool packed> class StructArgList {
   void *ptr;
   void *end;
 
@@ -85,20 +118,23 @@ public:
   LIBC_INLINE void *get_ptr() const { return ptr; }
 
   template <class T> LIBC_INLINE T next_var() {
-    ptr = reinterpret_cast<void *>(
-        ((reinterpret_cast<uintptr_t>(ptr) + alignof(T) - 1) / alignof(T)) *
-        alignof(T));
-
+    if (!packed)
+      ptr = reinterpret_cast<void *>(
+          align_up(reinterpret_cast<uintptr_t>(ptr), alignof(T)));
     if (ptr >= end)
       return T(-1);
 
-    T val = *reinterpret_cast<T *>(ptr);
-    ptr = reinterpret_cast<unsigned char *>(ptr) + sizeof(T);
+    // Memcpy because pointer alignment may be illegal given a packed struct.
+    T val;
+    __builtin_memcpy(&val, ptr, sizeof(T));
+
+    ptr =
+        reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(ptr) + sizeof(T));
     return val;
   }
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_ARG_LIST_H
diff --git a/src/__support/big_int.h b/src/__support/big_int.h
index 5ce9541..a95ab4f 100644
--- a/src/__support/big_int.h
+++ b/src/__support/big_int.h
@@ -6,15 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC___SUPPORT_UINT_H
-#define LLVM_LIBC_SRC___SUPPORT_UINT_H
+#ifndef LLVM_LIBC_SRC___SUPPORT_BIG_INT_H
+#define LLVM_LIBC_SRC___SUPPORT_BIG_INT_H
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/bit.h" // countl_zero
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/macros/attributes.h"          // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"        // LIBC_UNLIKELY
 #include "src/__support/macros/properties/compiler.h" // LIBC_COMPILER_IS_CLANG
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128, LIBC_TYPES_HAS_INT64
@@ -24,7 +25,7 @@
 #include <stddef.h> // For size_t
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace multiword {
 
@@ -360,17 +361,94 @@ public:
 
   LIBC_INLINE constexpr BigInt(const BigInt &other) = default;
 
-  template <size_t OtherBits, bool OtherSigned>
+  template <size_t OtherBits, bool OtherSigned, typename OtherWordType>
   LIBC_INLINE constexpr BigInt(
-      const BigInt<OtherBits, OtherSigned, WordType> &other) {
-    if (OtherBits >= Bits) { // truncate
-      for (size_t i = 0; i < WORD_COUNT; ++i)
-        val[i] = other[i];
-    } else { // zero or sign extend
-      size_t i = 0;
-      for (; i < OtherBits / WORD_SIZE; ++i)
-        val[i] = other[i];
-      extend(i, Signed && other.is_neg());
+      const BigInt<OtherBits, OtherSigned, OtherWordType> &other) {
+    using BigIntOther = BigInt<OtherBits, OtherSigned, OtherWordType>;
+    const bool should_sign_extend = Signed && other.is_neg();
+
+    static_assert(!(Bits == OtherBits && WORD_SIZE != BigIntOther::WORD_SIZE) &&
+                  "This is currently untested for casting between bigints with "
+                  "the same bit width but different word sizes.");
+
+    if constexpr (BigIntOther::WORD_SIZE < WORD_SIZE) {
+      // OtherWordType is smaller
+      constexpr size_t WORD_SIZE_RATIO = WORD_SIZE / BigIntOther::WORD_SIZE;
+      static_assert(
+          (WORD_SIZE % BigIntOther::WORD_SIZE) == 0 &&
+          "Word types must be multiples of each other for correct conversion.");
+      if constexpr (OtherBits >= Bits) { // truncate
+        // for each big word
+        for (size_t i = 0; i < WORD_COUNT; ++i) {
+          WordType cur_word = 0;
+          // combine WORD_SIZE_RATIO small words into a big word
+          for (size_t j = 0; j < WORD_SIZE_RATIO; ++j)
+            cur_word |= static_cast<WordType>(other[(i * WORD_SIZE_RATIO) + j])
+                        << (BigIntOther::WORD_SIZE * j);
+
+          val[i] = cur_word;
+        }
+      } else { // zero or sign extend
+        size_t i = 0;
+        WordType cur_word = 0;
+        // for each small word
+        for (; i < BigIntOther::WORD_COUNT; ++i) {
+          // combine WORD_SIZE_RATIO small words into a big word
+          cur_word |= static_cast<WordType>(other[i])
+                      << (BigIntOther::WORD_SIZE * (i % WORD_SIZE_RATIO));
+          // if we've completed a big word, copy it into place and reset
+          if ((i % WORD_SIZE_RATIO) == WORD_SIZE_RATIO - 1) {
+            val[i / WORD_SIZE_RATIO] = cur_word;
+            cur_word = 0;
+          }
+        }
+        // Pretend there are extra words of the correct sign extension as needed
+
+        const WordType extension_bits =
+            should_sign_extend ? cpp::numeric_limits<WordType>::max()
+                               : cpp::numeric_limits<WordType>::min();
+        if ((i % WORD_SIZE_RATIO) != 0) {
+          cur_word |= static_cast<WordType>(extension_bits)
+                      << (BigIntOther::WORD_SIZE * (i % WORD_SIZE_RATIO));
+        }
+        // Copy the last word into place.
+        val[(i / WORD_SIZE_RATIO)] = cur_word;
+        extend((i / WORD_SIZE_RATIO) + 1, should_sign_extend);
+      }
+    } else if constexpr (BigIntOther::WORD_SIZE == WORD_SIZE) {
+      if constexpr (OtherBits >= Bits) { // truncate
+        for (size_t i = 0; i < WORD_COUNT; ++i)
+          val[i] = other[i];
+      } else { // zero or sign extend
+        size_t i = 0;
+        for (; i < BigIntOther::WORD_COUNT; ++i)
+          val[i] = other[i];
+        extend(i, should_sign_extend);
+      }
+    } else {
+      // OtherWordType is bigger.
+      constexpr size_t WORD_SIZE_RATIO = BigIntOther::WORD_SIZE / WORD_SIZE;
+      static_assert(
+          (BigIntOther::WORD_SIZE % WORD_SIZE) == 0 &&
+          "Word types must be multiples of each other for correct conversion.");
+      if constexpr (OtherBits >= Bits) { // truncate
+        // for each small word
+        for (size_t i = 0; i < WORD_COUNT; ++i) {
+          // split each big word into WORD_SIZE_RATIO small words
+          val[i] = static_cast<WordType>(other[i / WORD_SIZE_RATIO] >>
+                                         ((i % WORD_SIZE_RATIO) * WORD_SIZE));
+        }
+      } else { // zero or sign extend
+        size_t i = 0;
+        // for each big word
+        for (; i < BigIntOther::WORD_COUNT; ++i) {
+          // split each big word into WORD_SIZE_RATIO small words
+          for (size_t j = 0; j < WORD_SIZE_RATIO; ++j)
+            val[(i * WORD_SIZE_RATIO) + j] =
+                static_cast<WordType>(other[i] >> (j * WORD_SIZE));
+        }
+        extend(i * WORD_SIZE_RATIO, should_sign_extend);
+      }
     }
   }
 
@@ -387,10 +465,11 @@ public:
   }
 
   // Initialize the first word to |v| and the rest to 0.
-  template <typename T, typename = cpp::enable_if_t<cpp::is_integral_v<T>>>
+  template <typename T, typename = cpp::enable_if_t<cpp::is_integral_v<T> &&
+                                                    !cpp::is_same_v<T, bool>>>
   LIBC_INLINE constexpr BigInt(T v) {
     constexpr size_t T_SIZE = sizeof(T) * CHAR_BIT;
-    const bool is_neg = Signed && (v < 0);
+    const bool is_neg = v < 0;
     for (size_t i = 0; i < WORD_COUNT; ++i) {
       if (v == 0) {
         extend(i, is_neg);
@@ -425,6 +504,12 @@ public:
   // TODO: Reuse the Sign type.
   LIBC_INLINE constexpr bool is_neg() const { return SIGNED && get_msb(); }
 
+  template <size_t OtherBits, bool OtherSigned, typename OtherWordType>
+  LIBC_INLINE constexpr explicit
+  operator BigInt<OtherBits, OtherSigned, OtherWordType>() const {
+    return BigInt<OtherBits, OtherSigned, OtherWordType>(this);
+  }
+
   template <typename T> LIBC_INLINE constexpr explicit operator T() const {
     return to<T>();
   }
@@ -440,7 +525,7 @@ public:
     constexpr size_t MAX_COUNT =
         T_SIZE > Bits ? WORD_COUNT : T_SIZE / WORD_SIZE;
     for (size_t i = 1; i < MAX_COUNT; ++i)
-      lo += static_cast<T>(val[i]) << (WORD_SIZE * i);
+      lo += static_cast<T>(static_cast<T>(val[i]) << (WORD_SIZE * i));
     if constexpr (Signed && (T_SIZE > Bits)) {
       // Extend sign for negative numbers.
       constexpr T MASK = (~T(0) << Bits);
@@ -730,6 +815,11 @@ public:
     return *result.div(other);
   }
 
+  LIBC_INLINE constexpr BigInt operator%=(const BigInt &other) {
+    *this = *this % other;
+    return *this;
+  }
+
   LIBC_INLINE constexpr BigInt &operator*=(const BigInt &other) {
     *this = *this * other;
     return *this;
@@ -974,6 +1064,8 @@ struct WordTypeSelector : cpp::type_identity<
 // Except if we request 16 or 32 bits explicitly.
 template <> struct WordTypeSelector<16> : cpp::type_identity<uint16_t> {};
 template <> struct WordTypeSelector<32> : cpp::type_identity<uint32_t> {};
+template <> struct WordTypeSelector<96> : cpp::type_identity<uint32_t> {};
+
 template <size_t Bits>
 using WordTypeSelectorT = typename WordTypeSelector<Bits>::type;
 } // namespace internal
@@ -1287,6 +1379,6 @@ first_trailing_one(T value) {
                                                 : cpp::countr_zero(value) + 1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC___SUPPORT_UINT_H
+#endif // LLVM_LIBC_SRC___SUPPORT_BIG_INT_H
diff --git a/src/__support/block.h b/src/__support/block.h
index 580f20e..9ca3f11 100644
--- a/src/__support/block.h
+++ b/src/__support/block.h
@@ -16,10 +16,12 @@
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace internal {
 // Types of corrupted blocks, and functions to crash with an error message
@@ -63,69 +65,72 @@ using cpp::optional;
 
 /// Memory region with links to adjacent blocks.
 ///
-/// The blocks do not encode their size directly. Instead, they encode offsets
-/// to the next and previous blocks using the type given by the `OffsetType`
-/// template parameter. The encoded offsets are simply the offsets divded by the
-/// minimum block alignment, `ALIGNMENT`.
-///
-/// The `ALIGNMENT` constant provided by the derived block is typically the
-/// minimum value of `alignof(OffsetType)`. Since the addressable range of a
-/// block is given by `std::numeric_limits<OffsetType>::max() *
-/// ALIGNMENT`, it may be advantageous to set a higher alignment if it allows
-/// using a smaller offset type, even if this wastes some bytes in order to
-/// align block headers.
+/// The blocks store their offsets to the previous and next blocks. The latter
+/// is also the block's size.
 ///
 /// Blocks will always be aligned to a `ALIGNMENT` boundary. Block sizes will
 /// always be rounded up to a multiple of `ALIGNMENT`.
 ///
-/// As an example, the diagram below represents two contiguous
-/// `Block<uint32_t, 8>`s. The indices indicate byte offsets:
+/// As an example, the diagram below represents two contiguous `Block`s. The
+/// indices indicate byte offsets:
 ///
 /// @code{.unparsed}
 /// Block 1:
-/// +---------------------+------+--------------+
-/// | Header              | Info | Usable space |
-/// +----------+----------+------+--------------+
-/// | prev     | next     |      |              |
-/// | 0......3 | 4......7 | 8..9 | 10.......280 |
-/// | 00000000 | 00000046 | 8008 |  <app data>  |
-/// +----------+----------+------+--------------+
+/// +---------------------+--------------+
+/// | Header              | Usable space |
+/// +----------+----------+--------------+
+/// | prev     | next     |              |
+/// | 0......3 | 4......7 | 8........227 |
+/// | 00000000 | 00000230 |  <app data>  |
+/// +----------+----------+--------------+
 /// Block 2:
-/// +---------------------+------+--------------+
-/// | Header              | Info | Usable space |
-/// +----------+----------+------+--------------+
-/// | prev     | next     |      |              |
-/// | 0......3 | 4......7 | 8..9 | 10......1056 |
-/// | 00000046 | 00000106 | 2008 | f7f7....f7f7 |
-/// +----------+----------+------+--------------+
+/// +---------------------+--------------+
+/// | Header              | Usable space |
+/// +----------+----------+--------------+
+/// | prev     | next     |              |
+/// | 0......3 | 4......7 | 8........827 |
+/// | 00000230 | 00000830 | f7f7....f7f7 |
+/// +----------+----------+--------------+
 /// @endcode
 ///
-/// The overall size of the block (e.g. 280 bytes) is given by its next offset
-/// multiplied by the alignment (e.g. 0x106 * 4). Also, the next offset of a
-/// block matches the previous offset of its next block. The first block in a
-/// list is denoted by having a previous offset of `0`.
+/// As a space optimization, when a block is allocated, it consumes the prev
+/// field of the following block:
+///
+/// Block 1 (used):
+/// +---------------------+--------------+
+/// | Header              | Usable space |
+/// +----------+----------+--------------+
+/// | prev     | next     |              |
+/// | 0......3 | 4......7 | 8........230 |
+/// | 00000000 | 00000230 |  <app data>  |
+/// +----------+----------+--------------+
+/// Block 2:
+/// +---------------------+--------------+
+/// | B1       | Header   | Usable space |
+/// +----------+----------+--------------+
+/// |          | next     |              |
+/// | 0......3 | 4......7 | 8........827 |
+/// | xxxxxxxx | 00000830 | f7f7....f7f7 |
+/// +----------+----------+--------------+
 ///
-/// @tparam   OffsetType  Unsigned integral type used to encode offsets. Larger
-///                       types can address more memory, but consume greater
-///                       overhead.
-/// @tparam   kAlign      Sets the overall alignment for blocks. Minimum is
-///                       `alignof(OffsetType)` (the default). Larger values can
-///                       address more memory, but consume greater overhead.
-template <typename OffsetType = uintptr_t, size_t kAlign = alignof(OffsetType)>
+/// The next offset of a block matches the previous offset of its next block.
+/// The first block in a list is denoted by having a previous offset of `0`.
 class Block {
-public:
-  using offset_type = OffsetType;
-  static_assert(cpp::is_unsigned_v<offset_type>,
-                "offset type must be unsigned");
+  // Masks for the contents of the next_ field.
+  static constexpr size_t PREV_FREE_MASK = 1 << 0;
+  static constexpr size_t LAST_MASK = 1 << 1;
+  static constexpr size_t SIZE_MASK = ~(PREV_FREE_MASK | LAST_MASK);
 
-  static constexpr size_t ALIGNMENT = cpp::max(kAlign, alignof(offset_type));
-  static constexpr size_t BLOCK_OVERHEAD = align_up(sizeof(Block), ALIGNMENT);
+public:
+  static constexpr size_t ALIGNMENT = cpp::max(alignof(max_align_t), size_t{4});
+  static const size_t BLOCK_OVERHEAD;
 
   // No copy or move.
   Block(const Block &other) = delete;
   Block &operator=(const Block &other) = delete;
 
-  /// Creates the first block for a given memory region.
+  /// Creates the first block for a given memory region, followed by a sentinel
+  /// last block. Returns the first block.
   static optional<Block *> init(ByteSpan region);
 
   /// @returns  A pointer to a `Block`, given a pointer to the start of the
@@ -135,178 +140,213 @@ public:
   ///
   /// @warning  This method does not do any checking; passing a random
   ///           pointer will return a non-null pointer.
-  static Block *from_usable_space(void *usable_space) {
+  LIBC_INLINE static Block *from_usable_space(void *usable_space) {
     auto *bytes = reinterpret_cast<cpp::byte *>(usable_space);
     return reinterpret_cast<Block *>(bytes - BLOCK_OVERHEAD);
   }
-  static const Block *from_usable_space(const void *usable_space) {
+  LIBC_INLINE static const Block *from_usable_space(const void *usable_space) {
     const auto *bytes = reinterpret_cast<const cpp::byte *>(usable_space);
     return reinterpret_cast<const Block *>(bytes - BLOCK_OVERHEAD);
   }
 
   /// @returns The total size of the block in bytes, including the header.
-  size_t outer_size() const { return next_ * ALIGNMENT; }
+  LIBC_INLINE size_t outer_size() const { return next_ & SIZE_MASK; }
+
+  LIBC_INLINE static size_t outer_size(size_t inner_size) {
+    // The usable region includes the prev_ field of the next block.
+    return inner_size - sizeof(prev_) + BLOCK_OVERHEAD;
+  }
+
+  /// @returns The number of usable bytes inside the block were it to be
+  /// allocated.
+  LIBC_INLINE size_t inner_size() const {
+    if (!next())
+      return 0;
+    return inner_size(outer_size());
+  }
 
-  /// @returns The number of usable bytes inside the block.
-  size_t inner_size() const { return outer_size() - BLOCK_OVERHEAD; }
+  /// @returns The number of usable bytes inside a block with the given outer
+  /// size were it to be allocated.
+  LIBC_INLINE static size_t inner_size(size_t outer_size) {
+    // The usable region includes the prev_ field of the next block.
+    return inner_size_free(outer_size) + sizeof(prev_);
+  }
 
-  /// @returns The number of bytes requested using AllocFirst or AllocLast.
-  size_t requested_size() const { return inner_size() - padding_; }
+  /// @returns The number of usable bytes inside the block if it remains free.
+  LIBC_INLINE size_t inner_size_free() const {
+    if (!next())
+      return 0;
+    return inner_size_free(outer_size());
+  }
+
+  /// @returns The number of usable bytes inside a block with the given outer
+  /// size if it remains free.
+  LIBC_INLINE static size_t inner_size_free(size_t outer_size) {
+    return outer_size - BLOCK_OVERHEAD;
+  }
 
   /// @returns A pointer to the usable space inside this block.
-  cpp::byte *usable_space() {
+  LIBC_INLINE cpp::byte *usable_space() {
     return reinterpret_cast<cpp::byte *>(this) + BLOCK_OVERHEAD;
   }
-  const cpp::byte *usable_space() const {
+  LIBC_INLINE const cpp::byte *usable_space() const {
     return reinterpret_cast<const cpp::byte *>(this) + BLOCK_OVERHEAD;
   }
 
-  /// Marks the block as free and merges it with any free neighbors.
-  ///
-  /// This method is static in order to consume and replace the given block
-  /// pointer. If neither member is free, the returned pointer will point to the
-  /// original block. Otherwise, it will point to the new, larger block created
-  /// by merging adjacent free blocks together.
-  static void free(Block *&block);
+  // @returns The region of memory the block manages, including the header.
+  LIBC_INLINE ByteSpan region() {
+    return {reinterpret_cast<cpp::byte *>(this), outer_size()};
+  }
 
   /// Attempts to split this block.
   ///
-  /// If successful, the block will have an inner size of `new_inner_size`,
-  /// rounded up to a `ALIGNMENT` boundary. The remaining space will be
-  /// returned as a new block.
-  ///
-  /// This method may fail if the remaining space is too small to hold a new
-  /// block. If this method fails for any reason, the original block is
-  /// unmodified.
-  ///
-  /// This method is static in order to consume and replace the given block
-  /// pointer with a pointer to the new, smaller block.
-  static optional<Block *> split(Block *&block, size_t new_inner_size);
+  /// If successful, the block will have an inner size of at least
+  /// `new_inner_size`, rounded to ensure that the split point is on an
+  /// ALIGNMENT boundary. The remaining space will be returned as a new block.
+  /// Note that the prev_ field of the next block counts as part of the inner
+  /// size of the returnd block.
+  optional<Block *> split(size_t new_inner_size);
 
   /// Merges this block with the one that comes after it.
-  ///
-  /// This method is static in order to consume and replace the given block
-  /// pointer with a pointer to the new, larger block.
-  static bool merge_next(Block *&block);
-
-  /// Fetches the block immediately after this one.
-  ///
-  /// For performance, this always returns a block pointer, even if the returned
-  /// pointer is invalid. The pointer is valid if and only if `last()` is false.
-  ///
-  /// Typically, after calling `Init` callers may save a pointer past the end of
-  /// the list using `next()`. This makes it easy to subsequently iterate over
-  /// the list:
-  /// @code{.cpp}
-  ///   auto result = Block<>::init(byte_span);
-  ///   Block<>* begin = *result;
-  ///   Block<>* end = begin->next();
-  ///   ...
-  ///   for (auto* block = begin; block != end; block = block->next()) {
-  ///     // Do something which each block.
-  ///   }
-  /// @endcode
-  Block *next() const;
-
-  /// @copydoc `next`.
-  static Block *next_block(const Block *block) {
-    return block == nullptr ? nullptr : block->next();
+  bool merge_next();
+
+  /// @returns The block immediately after this one, or a null pointer if this
+  /// is the last block.
+  LIBC_INLINE Block *next() const {
+    if (next_ & LAST_MASK)
+      return nullptr;
+    return reinterpret_cast<Block *>(reinterpret_cast<uintptr_t>(this) +
+                                     outer_size());
   }
 
-  /// @returns The block immediately before this one, or a null pointer if this
-  /// is the first block.
-  Block *prev() const;
-
-  /// @copydoc `prev`.
-  static Block *prev_block(const Block *block) {
-    return block == nullptr ? nullptr : block->prev();
+  /// @returns The free block immediately before this one, otherwise nullptr.
+  LIBC_INLINE Block *prev_free() const {
+    if (!(next_ & PREV_FREE_MASK))
+      return nullptr;
+    return reinterpret_cast<Block *>(reinterpret_cast<uintptr_t>(this) - prev_);
   }
 
-  /// Returns the current alignment of a block.
-  size_t alignment() const { return used() ? info_.alignment : 1; }
-
-  /// Indicates whether the block is in use.
-  ///
-  /// @returns `true` if the block is in use or `false` if not.
-  bool used() const { return info_.used; }
-
-  /// Indicates whether this block is the last block or not (i.e. whether
-  /// `next()` points to a valid block or not). This is needed because
-  /// `next()` points to the end of this block, whether there is a valid
-  /// block there or not.
-  ///
-  /// @returns `true` is this is the last block or `false` if not.
-  bool last() const { return info_.last; }
+  /// @returns Whether the block is unavailable for allocation.
+  LIBC_INLINE bool used() const { return !next() || !next()->prev_free(); }
 
   /// Marks this block as in use.
-  void mark_used() { info_.used = 1; }
+  LIBC_INLINE void mark_used() {
+    LIBC_ASSERT(next() && "last block is always considered used");
+    next()->next_ &= ~PREV_FREE_MASK;
+  }
 
   /// Marks this block as free.
-  void mark_free() { info_.used = 0; }
-
-  /// Marks this block as the last one in the chain.
-  constexpr void mark_last() { info_.last = 1; }
+  LIBC_INLINE void mark_free() {
+    LIBC_ASSERT(next() && "last block is always considered used");
+    next()->next_ |= PREV_FREE_MASK;
+    // The next block's prev_ field becomes alive, as it is no longer part of
+    // this block's used space.
+    *new (&next()->prev_) size_t = outer_size();
+  }
 
-  /// Clears the last bit from this block.
-  void clear_last() { info_.last = 1; }
+  /// Marks this block as the last one in the chain. Makes next() return
+  /// nullptr.
+  LIBC_INLINE void mark_last() { next_ |= LAST_MASK; }
 
-  /// @brief Checks if a block is valid.
-  ///
-  /// @returns `true` if and only if the following conditions are met:
-  /// * The block is aligned.
-  /// * The prev/next fields match with the previous and next blocks.
-  bool is_valid() const {
-    return check_status() == internal::BlockStatus::VALID;
+  LIBC_INLINE constexpr Block(size_t outer_size) : next_(outer_size) {
+    LIBC_ASSERT(outer_size % ALIGNMENT == 0 && "block sizes must be aligned");
   }
 
-  constexpr Block(size_t prev_outer_size, size_t outer_size);
+  LIBC_INLINE bool is_usable_space_aligned(size_t alignment) const {
+    return reinterpret_cast<uintptr_t>(usable_space()) % alignment == 0;
+  }
 
-private:
-  /// Consumes the block and returns as a span of bytes.
-  static ByteSpan as_bytes(Block *&&block);
+  /// @returns The new inner size of this block that would give the usable
+  /// space of the next block the given alignment.
+  LIBC_INLINE size_t padding_for_alignment(size_t alignment) const {
+    if (is_usable_space_aligned(alignment))
+      return 0;
+
+    // We need to ensure we can always split this block into a "padding" block
+    // and the aligned block. To do this, we need enough extra space for at
+    // least one block.
+    //
+    // |block   |usable_space                          |
+    // |........|......................................|
+    //                            ^
+    //                            Alignment requirement
+    //
+    //
+    // |block   |space   |block   |usable_space        |
+    // |........|........|........|....................|
+    //                            ^
+    //                            Alignment requirement
+    //
+    alignment = cpp::max(alignment, ALIGNMENT);
+    uintptr_t start = reinterpret_cast<uintptr_t>(usable_space());
+    uintptr_t next_usable_space = align_up(start + BLOCK_OVERHEAD, alignment);
+    uintptr_t next_block = next_usable_space - BLOCK_OVERHEAD;
+    return next_block - start + sizeof(prev_);
+  }
 
-  /// Consumes the span of bytes and uses it to construct and return a block.
-  static Block *as_block(size_t prev_outer_size, ByteSpan bytes);
+  // Check that we can `allocate` a block with a given alignment and size from
+  // this existing block.
+  bool can_allocate(size_t alignment, size_t size) const;
+
+  // This is the return type for `allocate` which can split one block into up to
+  // three blocks.
+  struct BlockInfo {
+    // This is the newly aligned block. It will have the alignment requested by
+    // a call to `allocate` and at most `size`.
+    Block *block;
+
+    // If the usable_space in the new block was not aligned according to the
+    // `alignment` parameter, we will need to split into this block and the
+    // `block` to ensure `block` is properly aligned. In this case, `prev` will
+    // be a pointer to this new "padding" block. `prev` will be nullptr if no
+    // new block was created or we were able to merge the block before the
+    // original block with the "padding" block.
+    Block *prev;
+
+    // This is the remainder of the next block after splitting the `block`
+    // according to `size`. This can happen if there's enough space after the
+    // `block`.
+    Block *next;
+  };
+
+  // Divide a block into up to 3 blocks according to `BlockInfo`. This should
+  // only be called if `can_allocate` returns true.
+  static BlockInfo allocate(Block *block, size_t alignment, size_t size);
 
-  /// Returns a `BlockStatus` that is either VALID or indicates the reason why
-  /// the block is invalid.
-  ///
-  /// If the block is invalid at multiple points, this function will only return
-  /// one of the reasons.
-  internal::BlockStatus check_status() const;
+private:
+  /// Construct a block to represent a span of bytes. Overwrites only enough
+  /// memory for the block header; the rest of the span is left alone.
+  LIBC_INLINE static Block *as_block(ByteSpan bytes) {
+    return ::new (bytes.data()) Block(bytes.size());
+  }
 
   /// Like `split`, but assumes the caller has already checked to parameters to
   /// ensure the split will succeed.
-  static Block *split_impl(Block *&block, size_t new_inner_size);
-
-  /// Offset (in increments of the minimum alignment) from this block to the
-  /// previous block. 0 if this is the first block.
-  offset_type prev_ = 0;
-
-  /// Offset (in increments of the minimum alignment) from this block to the
-  /// next block. Valid even if this is the last block, since it equals the
-  /// size of the block.
-  offset_type next_ = 0;
-
-  /// Information about the current state of the block:
-  /// * If the `used` flag is set, the block's usable memory has been allocated
-  ///   and is being used.
-  /// * If the `last` flag is set, the block does not have a next block.
-  /// * If the `used` flag is set, the alignment represents the requested value
-  ///   when the memory was allocated, which may be less strict than the actual
-  ///   alignment.
-  struct {
-    uint16_t used : 1;
-    uint16_t last : 1;
-    uint16_t alignment : 14;
-  } info_;
-
-  /// Number of bytes allocated beyond what was requested. This will be at most
-  /// the minimum alignment, i.e. `alignof(offset_type).`
-  uint16_t padding_ = 0;
-} __attribute__((packed, aligned(kAlign)));
-
-// Public template method implementations.
+  Block *split_impl(size_t new_inner_size);
+
+  /// Offset from this block to the previous block. 0 if this is the first
+  /// block. This field is only alive when the previous block is free;
+  /// otherwise, its memory is reused as part of the previous block's usable
+  /// space.
+  size_t prev_ = 0;
+
+  /// Offset from this block to the next block. Valid even if this is the last
+  /// block, since it equals the size of the block.
+  size_t next_ = 0;
+
+  /// Information about the current state of the block is stored in the two low
+  /// order bits of the next_ value. These are guaranteed free by a minimum
+  /// alignment (and thus, alignment of the size) of 4. The lowest bit is the
+  /// `prev_free` flag, and the other bit is the `last` flag.
+  ///
+  /// * If the `prev_free` flag is set, the block isn't the first and the
+  ///   previous block is free.
+  /// * If the `last` flag is set, the block is the sentinel last block. It is
+  ///   summarily considered used and has no next block.
+} __attribute__((packed, aligned(cpp::max(alignof(max_align_t), size_t{4}))));
+
+inline constexpr size_t Block::BLOCK_OVERHEAD =
+    align_up(sizeof(Block), ALIGNMENT);
 
 LIBC_INLINE ByteSpan get_aligned_subspan(ByteSpan bytes, size_t alignment) {
   if (bytes.data() == nullptr)
@@ -324,161 +364,128 @@ LIBC_INLINE ByteSpan get_aligned_subspan(ByteSpan bytes, size_t alignment) {
                        aligned_end - aligned_start);
 }
 
-template <typename OffsetType, size_t kAlign>
-optional<Block<OffsetType, kAlign> *>
-Block<OffsetType, kAlign>::init(ByteSpan region) {
+LIBC_INLINE
+optional<Block *> Block::init(ByteSpan region) {
   optional<ByteSpan> result = get_aligned_subspan(region, ALIGNMENT);
   if (!result)
     return {};
 
   region = result.value();
-  if (region.size() < BLOCK_OVERHEAD)
+  // Two blocks are allocated: a free block and a sentinel last block.
+  if (region.size() < 2 * BLOCK_OVERHEAD)
     return {};
 
-  if (cpp::numeric_limits<OffsetType>::max() < region.size() / ALIGNMENT)
+  if (cpp::numeric_limits<size_t>::max() < region.size())
     return {};
 
-  Block *block = as_block(0, region);
-  block->mark_last();
+  Block *block = as_block(region.first(region.size() - BLOCK_OVERHEAD));
+  Block *last = as_block(region.last(BLOCK_OVERHEAD));
+  block->mark_free();
+  last->mark_last();
   return block;
 }
 
-template <typename OffsetType, size_t kAlign>
-void Block<OffsetType, kAlign>::free(Block *&block) {
-  if (block == nullptr)
-    return;
-
-  block->mark_free();
-  Block *prev = block->prev();
+LIBC_INLINE
+bool Block::can_allocate(size_t alignment, size_t size) const {
+  if (inner_size() < size)
+    return false;
+  if (is_usable_space_aligned(alignment))
+    return true;
 
-  if (merge_next(prev))
-    block = prev;
+  // Alignment isn't met, so a padding block is needed. Determine amount of
+  // inner_size() consumed by the padding block.
+  size_t padding_size = padding_for_alignment(alignment) - sizeof(prev_);
 
-  merge_next(block);
+  // Check that there is room for the allocation in the following aligned block.
+  size_t aligned_inner_size = inner_size() - padding_size - BLOCK_OVERHEAD;
+  return size <= aligned_inner_size;
 }
 
-template <typename OffsetType, size_t kAlign>
-optional<Block<OffsetType, kAlign> *>
-Block<OffsetType, kAlign>::split(Block *&block, size_t new_inner_size) {
-  if (block == nullptr)
-    return {};
+LIBC_INLINE
+Block::BlockInfo Block::allocate(Block *block, size_t alignment, size_t size) {
+  LIBC_ASSERT(
+      block->can_allocate(alignment, size) &&
+      "Calls to this function for a given alignment and size should only be "
+      "done if `can_allocate` for these parameters returns true.");
+
+  BlockInfo info{block, /*prev=*/nullptr, /*next=*/nullptr};
+
+  if (!info.block->is_usable_space_aligned(alignment)) {
+    Block *original = info.block;
+    optional<Block *> maybe_aligned_block =
+        original->split(info.block->padding_for_alignment(alignment));
+    LIBC_ASSERT(maybe_aligned_block.has_value() &&
+                "This split should always result in a new block. The check in "
+                "`can_allocate` ensures that we have enough space here to make "
+                "two blocks.");
+
+    if (Block *prev = original->prev_free()) {
+      // If there is a free block before this, we can merge the current one with
+      // the newly created one.
+      prev->merge_next();
+    } else {
+      info.prev = original;
+    }
+
+    Block *aligned_block = *maybe_aligned_block;
+    LIBC_ASSERT(aligned_block->is_usable_space_aligned(alignment) &&
+                "The aligned block isn't aligned somehow.");
+    info.block = aligned_block;
+  }
 
-  if (block->used())
-    return {};
+  // Now get a block for the requested size.
+  if (optional<Block *> next = info.block->split(size))
+    info.next = *next;
+
+  return info;
+}
 
-  size_t old_inner_size = block->inner_size();
-  new_inner_size = align_up(new_inner_size, ALIGNMENT);
+LIBC_INLINE
+optional<Block *> Block::split(size_t new_inner_size) {
+  if (used())
+    return {};
+  // The prev_ field of the next block is always available, so there is a
+  // minimum size to a block created through splitting.
+  if (new_inner_size < sizeof(prev_))
+    new_inner_size = sizeof(prev_);
+
+  size_t old_inner_size = inner_size();
+  new_inner_size =
+      align_up(new_inner_size - sizeof(prev_), ALIGNMENT) + sizeof(prev_);
   if (old_inner_size < new_inner_size)
     return {};
 
   if (old_inner_size - new_inner_size < BLOCK_OVERHEAD)
     return {};
 
-  return split_impl(block, new_inner_size);
+  return split_impl(new_inner_size);
 }
 
-template <typename OffsetType, size_t kAlign>
-Block<OffsetType, kAlign> *
-Block<OffsetType, kAlign>::split_impl(Block *&block, size_t new_inner_size) {
-  size_t prev_outer_size = block->prev_ * ALIGNMENT;
-  size_t outer_size1 = new_inner_size + BLOCK_OVERHEAD;
-  bool is_last = block->last();
-  ByteSpan bytes = as_bytes(cpp::move(block));
-  Block *block1 = as_block(prev_outer_size, bytes.subspan(0, outer_size1));
-  Block *block2 = as_block(outer_size1, bytes.subspan(outer_size1));
-
-  if (is_last)
-    block2->mark_last();
-  else
-    block2->next()->prev_ = block2->next_;
-
-  block = cpp::move(block1);
-  return block2;
+LIBC_INLINE
+Block *Block::split_impl(size_t new_inner_size) {
+  size_t outer_size1 = outer_size(new_inner_size);
+  LIBC_ASSERT(outer_size1 % ALIGNMENT == 0 && "new size must be aligned");
+  ByteSpan new_region = region().subspan(outer_size1);
+  next_ &= ~SIZE_MASK;
+  next_ |= outer_size1;
+
+  Block *new_block = as_block(new_region);
+  mark_free(); // Free status for this block is now stored in new_block.
+  new_block->next()->prev_ = new_region.size();
+  return new_block;
 }
 
-template <typename OffsetType, size_t kAlign>
-bool Block<OffsetType, kAlign>::merge_next(Block *&block) {
-  if (block == nullptr)
+LIBC_INLINE
+bool Block::merge_next() {
+  if (used() || next()->used())
     return false;
-
-  if (block->last())
-    return false;
-
-  Block *next = block->next();
-  if (block->used() || next->used())
-    return false;
-
-  size_t prev_outer_size = block->prev_ * ALIGNMENT;
-  bool is_last = next->last();
-  ByteSpan prev_bytes = as_bytes(cpp::move(block));
-  ByteSpan next_bytes = as_bytes(cpp::move(next));
-  size_t outer_size = prev_bytes.size() + next_bytes.size();
-  cpp::byte *merged = ::new (prev_bytes.data()) cpp::byte[outer_size];
-  block = as_block(prev_outer_size, ByteSpan(merged, outer_size));
-
-  if (is_last)
-    block->mark_last();
-  else
-    block->next()->prev_ = block->next_;
-
+  size_t new_size = outer_size() + next()->outer_size();
+  next_ &= ~SIZE_MASK;
+  next_ |= new_size;
+  next()->prev_ = new_size;
   return true;
 }
 
-template <typename OffsetType, size_t kAlign>
-Block<OffsetType, kAlign> *Block<OffsetType, kAlign>::next() const {
-  uintptr_t addr =
-      last() ? 0 : reinterpret_cast<uintptr_t>(this) + outer_size();
-  return reinterpret_cast<Block *>(addr);
-}
-
-template <typename OffsetType, size_t kAlign>
-Block<OffsetType, kAlign> *Block<OffsetType, kAlign>::prev() const {
-  uintptr_t addr =
-      (prev_ == 0) ? 0
-                   : reinterpret_cast<uintptr_t>(this) - (prev_ * ALIGNMENT);
-  return reinterpret_cast<Block *>(addr);
-}
-
-// Private template method implementations.
-
-template <typename OffsetType, size_t kAlign>
-constexpr Block<OffsetType, kAlign>::Block(size_t prev_outer_size,
-                                           size_t outer_size)
-    : info_{} {
-  prev_ = prev_outer_size / ALIGNMENT;
-  next_ = outer_size / ALIGNMENT;
-  info_.used = 0;
-  info_.last = 0;
-  info_.alignment = ALIGNMENT;
-}
-
-template <typename OffsetType, size_t kAlign>
-ByteSpan Block<OffsetType, kAlign>::as_bytes(Block *&&block) {
-  size_t block_size = block->outer_size();
-  cpp::byte *bytes = new (cpp::move(block)) cpp::byte[block_size];
-  return {bytes, block_size};
-}
-
-template <typename OffsetType, size_t kAlign>
-Block<OffsetType, kAlign> *
-Block<OffsetType, kAlign>::as_block(size_t prev_outer_size, ByteSpan bytes) {
-  return ::new (bytes.data()) Block(prev_outer_size, bytes.size());
-}
-
-template <typename OffsetType, size_t kAlign>
-internal::BlockStatus Block<OffsetType, kAlign>::check_status() const {
-  if (reinterpret_cast<uintptr_t>(this) % ALIGNMENT != 0)
-    return internal::BlockStatus::MISALIGNED;
-
-  if (!last() && (this >= next() || this != next()->prev()))
-    return internal::BlockStatus::NEXT_MISMATCHED;
-
-  if (prev() && (this <= prev() || this != prev()->next()))
-    return internal::BlockStatus::PREV_MISMATCHED;
-
-  return internal::BlockStatus::VALID;
-}
-
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_BLOCK_H
diff --git a/src/__support/blockstore.h b/src/__support/blockstore.h
index bcab750..efe2234 100644
--- a/src/__support/blockstore.h
+++ b/src/__support/blockstore.h
@@ -9,13 +9,16 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_BLOCKSTORE_H
 #define LLVM_LIBC_SRC___SUPPORT_BLOCKSTORE_H
 
-#include <src/__support/CPP/new.h>
-#include <src/__support/libc_assert.h>
+#include "src/__support/CPP/array.h"
+#include "src/__support/CPP/new.h"
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The difference between BlockStore a traditional vector types is that,
 // when more capacity is desired, a new block is added instead of allocating
@@ -97,6 +100,16 @@ public:
       return *reinterpret_cast<T *>(block->data + sizeof(T) * true_index);
     }
 
+    LIBC_INLINE Iterator operator+(int i) {
+      LIBC_ASSERT(i >= 0 &&
+                  "BlockStore iterators only support incrementation.");
+      auto other = *this;
+      for (int j = 0; j < i; ++j)
+        ++other;
+
+      return other;
+    }
+
     LIBC_INLINE bool operator==(const Iterator &rhs) const {
       return block == rhs.block && index == rhs.index;
     }
@@ -175,6 +188,47 @@ public:
     else
       return Iterator(current, fill_count);
   }
+
+  // Removes the element at pos, then moves all the objects after back by one to
+  // fill the hole. It's assumed that pos is a valid iterator to somewhere in
+  // this block_store.
+  LIBC_INLINE void erase(Iterator pos) {
+    const Iterator last_item = Iterator(current, fill_count);
+    if (pos == last_item) {
+      pop_back();
+      return;
+    }
+
+    if constexpr (REVERSE_ORDER) {
+      // REVERSE: Iterate from begin to pos
+      const Iterator range_end = pos;
+      Iterator cur = begin();
+      T prev_val = *cur;
+      ++cur;
+      T cur_val = *cur;
+
+      for (; cur != range_end; ++cur) {
+        cur_val = *cur;
+        *cur = prev_val;
+        prev_val = cur_val;
+      }
+      // As long as this isn't the end we will always need to move at least one
+      // item (since we know that pos isn't the last item due to the check
+      // above).
+      if (range_end != end())
+        *cur = prev_val;
+    } else {
+      // FORWARD: Iterate from pos to end
+      const Iterator range_end = end();
+      Iterator cur = pos;
+      Iterator prev = cur;
+      ++cur;
+
+      for (; cur != range_end; prev = cur, ++cur)
+        *prev = *cur;
+    }
+    pop_back();
+  }
 };
 
 template <typename T, size_t BLOCK_SIZE, bool REVERSE_ORDER>
@@ -203,6 +257,6 @@ LIBC_INLINE void BlockStore<T, BLOCK_SIZE, REVERSE_ORDER>::destroy(
 template <typename T, size_t BLOCK_SIZE>
 using ReverseOrderBlockStore = BlockStore<T, BLOCK_SIZE, true>;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_BLOCKSTORE_H
diff --git a/src/__support/c_string.h b/src/__support/c_string.h
index 9049311..11f4132 100644
--- a/src/__support/c_string.h
+++ b/src/__support/c_string.h
@@ -11,8 +11,9 @@
 
 #include "src/__support/CPP/string.h"
 #include "src/__support/macros/attributes.h" // for LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The CString class is a companion to the cpp::string class. Its use case is as
 // a return value for a function that in C would return a char* and a flag for
@@ -31,6 +32,6 @@ public:
   LIBC_INLINE operator const char *() const { return str.c_str(); }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_C_STRING_H
diff --git a/src/__support/char_vector.h b/src/__support/char_vector.h
index d39310e..d0837a8 100644
--- a/src/__support/char_vector.h
+++ b/src/__support/char_vector.h
@@ -9,12 +9,15 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CHARVECTOR_H
 #define LLVM_LIBC_SRC___SUPPORT_CHARVECTOR_H
 
+#include "hdr/func/free.h"
+#include "hdr/func/malloc.h"
+#include "hdr/func/realloc.h"
 #include "src/__support/common.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
 #include <stddef.h> // size_t
-#include <stdlib.h> // malloc, realloc, free
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This is very simple alternate of the std::string class. There is no
 // bounds check performed in any of the methods. The callers are expected to
@@ -73,6 +76,6 @@ public:
   LIBC_INLINE size_t length() { return index; }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_CHARVECTOR_H
diff --git a/src/__support/common.h b/src/__support/common.h
index 53951dc..42e8a79 100644
--- a/src/__support/common.h
+++ b/src/__support/common.h
@@ -14,15 +14,33 @@
 #endif
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #ifndef LLVM_LIBC_FUNCTION_ATTR
 #define LLVM_LIBC_FUNCTION_ATTR
 #endif
 
+// clang-format off
+// Allow each function `func` to have extra attributes specified by defining:
+// `LLVM_LIBC_FUNCTION_ATTR_func` macro, which should always start with
+// "LLVM_LIBC_EMPTY, "
+//
+// For examples:
+// #define LLVM_LIBC_FUNCTION_ATTR_memcpy LLVM_LIBC_EMPTY, [[gnu::weak]]
+// #define LLVM_LIBC_FUNCTION_ATTR_memchr LLVM_LIBC_EMPTY, [[gnu::weak]] [[gnu::visibility("default")]]
+// clang-format on
+#define LLVM_LIBC_EMPTY
+
+#define GET_SECOND(first, second, ...) second
+#define EXPAND_THEN_SECOND(name) GET_SECOND(name, LLVM_LIBC_EMPTY)
+
+#define LLVM_LIBC_ATTR(name) EXPAND_THEN_SECOND(LLVM_LIBC_FUNCTION_ATTR_##name)
+
 // MacOS needs to be excluded because it does not support aliasing.
 #if defined(LIBC_COPT_PUBLIC_PACKAGING) && (!defined(__APPLE__))
 #define LLVM_LIBC_FUNCTION_IMPL(type, name, arglist)                           \
+  LLVM_LIBC_ATTR(name)                                                         \
   LLVM_LIBC_FUNCTION_ATTR decltype(LIBC_NAMESPACE::name)                       \
       __##name##_impl__ __asm__(#name);                                        \
   decltype(LIBC_NAMESPACE::name) name [[gnu::alias(#name)]];                   \
@@ -35,7 +53,7 @@
 #define LLVM_LIBC_FUNCTION(type, name, arglist)                                \
   LLVM_LIBC_FUNCTION_IMPL(type, name, arglist)
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 LIBC_INLINE constexpr bool same_string(char const *lhs, char const *rhs) {
   for (; *lhs || *rhs; ++lhs, ++rhs)
@@ -44,7 +62,7 @@ LIBC_INLINE constexpr bool same_string(char const *lhs, char const *rhs) {
   return true;
 }
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define __LIBC_MACRO_TO_STRING(str) #str
 #define LIBC_MACRO_TO_STRING(str) __LIBC_MACRO_TO_STRING(str)
diff --git a/src/__support/complex_type.h b/src/__support/complex_type.h
new file mode 100644
index 0000000..d6b5eec
--- /dev/null
+++ b/src/__support/complex_type.h
@@ -0,0 +1,20 @@
+//===-- complex type --------------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_COMPLEX_TYPE_H
+#define LLVM_LIBC_SRC___SUPPORT_COMPLEX_TYPE_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+template <typename T> struct Complex {
+  T real;
+  T imag;
+};
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_COMPLEX_TYPE_H
diff --git a/src/__support/ctype_utils.h b/src/__support/ctype_utils.h
index 5fa4777..91f6ce8 100644
--- a/src/__support/ctype_utils.h
+++ b/src/__support/ctype_utils.h
@@ -10,8 +10,9 @@
 #define LLVM_LIBC_SRC___SUPPORT_CTYPE_UTILS_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // ------------------------------------------------------
@@ -55,6 +56,6 @@ LIBC_INLINE static constexpr int tolower(int ch) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC___SUPPORT_CTYPE_UTILS_H
diff --git a/src/__support/detailed_powers_of_ten.h b/src/__support/detailed_powers_of_ten.h
index c8340fd..28741b8 100644
--- a/src/__support/detailed_powers_of_ten.h
+++ b/src/__support/detailed_powers_of_ten.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC___SUPPORT_DETAILED_POWERS_OF_TEN_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // TODO(michaelrj): write a script that will generate this table.
@@ -734,6 +735,6 @@ static constexpr uint64_t DETAILED_POWERS_OF_TEN[696][2] = {
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_DETAILED_POWERS_OF_TEN_H
diff --git a/src/__support/endian.h b/src/__support/endian_internal.h
similarity index 93%
rename from src/__support/endian.h
rename to src/__support/endian_internal.h
index cd083aa..77839ad 100644
--- a/src/__support/endian.h
+++ b/src/__support/endian_internal.h
@@ -6,14 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC___SUPPORT_ENDIAN_H
-#define LLVM_LIBC_SRC___SUPPORT_ENDIAN_H
+#ifndef LLVM_LIBC_SRC___SUPPORT_ENDIAN_INTERNAL_H
+#define LLVM_LIBC_SRC___SUPPORT_ENDIAN_INTERNAL_H
 
 #include "common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // We rely on compiler preprocessor defines to allow for cross compilation.
 #if !defined(__BYTE_ORDER__) || !defined(__ORDER_LITTLE_ENDIAN__) ||           \
@@ -140,6 +141,6 @@ Endian<__ORDER_BIG_ENDIAN__>::to_little_endian<uint64_t>(uint64_t v) {
 
 using Endian = internal::Endian<__BYTE_ORDER__>;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC___SUPPORT_ENDIAN_H
+#endif // LLVM_LIBC_SRC___SUPPORT_ENDIAN_INTERNAL_H
diff --git a/src/__support/error_or.h b/src/__support/error_or.h
index 34c652d..3faaddd 100644
--- a/src/__support/error_or.h
+++ b/src/__support/error_or.h
@@ -10,8 +10,9 @@
 #define LLVM_LIBC_SRC___SUPPORT_ERROR_OR_H
 
 #include "src/__support/CPP/expected.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <class T> using ErrorOr = cpp::expected<T, int>;
 
@@ -34,6 +35,6 @@ using Error = cpp::unexpected<int>;
 //   constexpr operator T() { return value; }
 // };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_ERROR_OR_H
diff --git a/src/__support/fixed_point/fx_bits.h b/src/__support/fixed_point/fx_bits.h
index 53e693d..225ea41 100644
--- a/src/__support/fixed_point/fx_bits.h
+++ b/src/__support/fixed_point/fx_bits.h
@@ -12,7 +12,8 @@
 #include "include/llvm-libc-macros/stdfix-macros.h"
 #include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/macros/attributes.h"   // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/math_extras.h"
 
@@ -20,7 +21,8 @@
 
 #ifdef LIBC_COMPILER_HAS_FIXED_POINT
 
-namespace LIBC_NAMESPACE::fixed_point {
+namespace LIBC_NAMESPACE_DECL {
+namespace fixed_point {
 
 template <typename T> struct FXBits {
 private:
@@ -161,7 +163,8 @@ template <typename T> LIBC_INLINE constexpr T round(T x, int n) {
   return bit_and((x + round_bit), rounding_mask);
 }
 
-} // namespace LIBC_NAMESPACE::fixed_point
+} // namespace fixed_point
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_COMPILER_HAS_FIXED_POINT
 
diff --git a/src/__support/fixed_point/fx_rep.h b/src/__support/fixed_point/fx_rep.h
index f13640a..1869389 100644
--- a/src/__support/fixed_point/fx_rep.h
+++ b/src/__support/fixed_point/fx_rep.h
@@ -12,12 +12,14 @@
 #include "include/llvm-libc-macros/stdfix-macros.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE, LIBC_INLINE_VAR
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
 #ifdef LIBC_COMPILER_HAS_FIXED_POINT
 
-namespace LIBC_NAMESPACE::fixed_point {
+namespace LIBC_NAMESPACE_DECL {
+namespace fixed_point {
 
 namespace internal {
 
@@ -293,7 +295,8 @@ template <> struct FXRep<unsigned sat accum> : FXRep<unsigned accum> {};
 template <>
 struct FXRep<unsigned long sat accum> : FXRep<unsigned long accum> {};
 
-} // namespace LIBC_NAMESPACE::fixed_point
+} // namespace fixed_point
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_COMPILER_HAS_FIXED_POINT
 
diff --git a/src/__support/fixed_point/sqrt.h b/src/__support/fixed_point/sqrt.h
index 982e318..b77319d 100644
--- a/src/__support/fixed_point/sqrt.h
+++ b/src/__support/fixed_point/sqrt.h
@@ -14,13 +14,15 @@
 #include "src/__support/CPP/limits.h" // CHAR_BIT
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/macros/attributes.h"   // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "fx_rep.h"
 
 #ifdef LIBC_COMPILER_HAS_FIXED_POINT
 
-namespace LIBC_NAMESPACE::fixed_point {
+namespace LIBC_NAMESPACE_DECL {
+namespace fixed_point {
 
 namespace internal {
 
@@ -259,7 +261,8 @@ isqrt_fast(T x) {
   return cpp::bit_cast<OutType>(r);
 }
 
-} // namespace LIBC_NAMESPACE::fixed_point
+} // namespace fixed_point
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_COMPILER_HAS_FIXED_POINT
 
diff --git a/src/__support/fixedvector.h b/src/__support/fixedvector.h
index 403b162..7ac0c23 100644
--- a/src/__support/fixedvector.h
+++ b/src/__support/fixedvector.h
@@ -12,8 +12,9 @@
 #include "src/__support/CPP/array.h"
 
 #include "src/__support/CPP/iterator.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // A fixed size data store backed by an underlying cpp::array data structure. It
 // supports vector like API but is not resizable like a vector.
@@ -90,8 +91,13 @@ public:
 
   LIBC_INLINE constexpr iterator begin() { return store.begin(); }
   LIBC_INLINE constexpr iterator end() { return iterator{&store[item_count]}; }
+
+  LIBC_INLINE constexpr const_iterator begin() const { return store.begin(); }
+  LIBC_INLINE constexpr const_iterator end() const {
+    return const_iterator{&store[item_count]};
+  }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FIXEDVECTOR_H
diff --git a/src/__support/float_to_string.h b/src/__support/float_to_string.h
index 09b1332..d5de6f3 100644
--- a/src/__support/float_to_string.h
+++ b/src/__support/float_to_string.h
@@ -19,6 +19,8 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/sign.h"
 
 // This file has 5 compile-time flags to allow the user to configure the float
 // to string behavior. These were used to explore tradeoffs during the design
@@ -105,7 +107,7 @@ constexpr size_t MID_INT_SIZE = 192;
 // Any block that is all 9s adds one to the max block counter and doesn't clear
 // the buffer because they can cause the block above them to be rounded up.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using BlockInt = uint32_t;
 constexpr uint32_t BLOCK_SIZE = 9;
@@ -231,7 +233,7 @@ LIBC_INLINE UInt<MID_INT_SIZE> get_table_positive_df(int exponent, size_t i) {
   if (shift_amount < 0) {
     return 1;
   }
-  fputil::DyadicFloat<INT_SIZE> num(false, 0, 1);
+  fputil::DyadicFloat<INT_SIZE> num(Sign::POS, 0, 1);
   constexpr UInt<INT_SIZE> MOD_SIZE =
       (UInt<INT_SIZE>(EXP10_9)
        << (CALC_SHIFT_CONST + (IDX_SIZE > 1 ? IDX_SIZE : 0)));
@@ -241,16 +243,17 @@ LIBC_INLINE UInt<MID_INT_SIZE> get_table_positive_df(int exponent, size_t i) {
        0x89705f4136b4a597}};
 
   static const fputil::DyadicFloat<INT_SIZE> FIVE_EXP_MINUS_NINE(
-      false, -276, FIVE_EXP_MINUS_NINE_MANT);
+      Sign::POS, -276, FIVE_EXP_MINUS_NINE_MANT);
 
   if (i > 0) {
-    fputil::DyadicFloat<INT_SIZE> fives = fputil::pow_n(FIVE_EXP_MINUS_NINE, i);
+    fputil::DyadicFloat<INT_SIZE> fives =
+        fputil::pow_n(FIVE_EXP_MINUS_NINE, static_cast<uint32_t>(i));
     num = fives;
   }
   num = mul_pow_2(num, shift_amount);
 
   // Adding one is part of the formula.
-  UInt<INT_SIZE> int_num = static_cast<UInt<INT_SIZE>>(num) + 1;
+  UInt<INT_SIZE> int_num = num.as_mantissa_type() + 1;
   if (int_num > MOD_SIZE) {
     auto rem =
         int_num
@@ -338,23 +341,24 @@ LIBC_INLINE UInt<MID_INT_SIZE> get_table_negative_df(int exponent, size_t i) {
 
   int shift_amount = CALC_SHIFT_CONST - exponent;
 
-  fputil::DyadicFloat<INT_SIZE> num(false, 0, 1);
+  fputil::DyadicFloat<INT_SIZE> num(Sign::POS, 0, 1);
   constexpr UInt<INT_SIZE> MOD_SIZE =
       (UInt<INT_SIZE>(EXP10_9)
        << (CALC_SHIFT_CONST + (IDX_SIZE > 1 ? IDX_SIZE : 0)));
 
   constexpr UInt<INT_SIZE> TEN_EXP_NINE_MANT(EXP10_9);
 
-  static const fputil::DyadicFloat<INT_SIZE> TEN_EXP_NINE(false, 0,
+  static const fputil::DyadicFloat<INT_SIZE> TEN_EXP_NINE(Sign::POS, 0,
                                                           TEN_EXP_NINE_MANT);
 
   if (i > 0) {
-    fputil::DyadicFloat<INT_SIZE> tens = fputil::pow_n(TEN_EXP_NINE, i);
+    fputil::DyadicFloat<INT_SIZE> tens =
+        fputil::pow_n(TEN_EXP_NINE, static_cast<uint32_t>(i));
     num = tens;
   }
   num = mul_pow_2(num, shift_amount);
 
-  UInt<INT_SIZE> int_num = static_cast<UInt<INT_SIZE>>(num);
+  UInt<INT_SIZE> int_num = num.as_mantissa_type();
   if (int_num > MOD_SIZE) {
     auto rem =
         int_num
@@ -369,23 +373,12 @@ LIBC_INLINE UInt<MID_INT_SIZE> get_table_negative_df(int exponent, size_t i) {
   return result;
 }
 
-LIBC_INLINE uint32_t fast_uint_mod_1e9(const UInt<MID_INT_SIZE> &val) {
-  // The formula for mult_const is:
-  //  1 + floor((2^(bits in target integer size + log_2(divider))) / divider)
-  // Where divider is 10^9 and target integer size is 128.
-  const UInt<MID_INT_SIZE> mult_const(
-      {0x31680A88F8953031u, 0x89705F4136B4A597u, 0});
-  const auto middle = (mult_const * val);
-  const uint64_t result = static_cast<uint64_t>(middle[2]);
-  const uint64_t shifted = result >> 29;
-  return static_cast<uint32_t>(static_cast<uint32_t>(val) -
-                               (EXP10_9 * shifted));
-}
-
 LIBC_INLINE uint32_t mul_shift_mod_1e9(const FPBits::StorageType mantissa,
                                        const UInt<MID_INT_SIZE> &large,
                                        const int32_t shift_amount) {
-  UInt<MID_INT_SIZE + FPBits::STORAGE_LEN> val(large);
+  // make sure the number of bits is always divisible by 64
+  UInt<internal::div_ceil(MID_INT_SIZE + FPBits::STORAGE_LEN, 64) * 64> val(
+      large);
   val = (val * mantissa) >> shift_amount;
   return static_cast<uint32_t>(
       val.div_uint_half_times_pow_2(static_cast<uint32_t>(EXP10_9), 0).value());
@@ -839,6 +832,6 @@ public:
 #endif // !LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64 &&
        // !LIBC_COPT_FLOAT_TO_STR_NO_SPECIALIZE_LD
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FLOAT_TO_STRING_H
diff --git a/src/__support/freelist.cpp b/src/__support/freelist.cpp
new file mode 100644
index 0000000..bfb90ae
--- /dev/null
+++ b/src/__support/freelist.cpp
@@ -0,0 +1,42 @@
+//===-- Implementation for freelist ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "freelist.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void FreeList::push(Node *node) {
+  if (begin_) {
+    LIBC_ASSERT(Block::from_usable_space(node)->outer_size() ==
+                    begin_->block()->outer_size() &&
+                "freelist entries must have the same size");
+    // Since the list is circular, insert the node immediately before begin_.
+    node->prev = begin_->prev;
+    node->next = begin_;
+    begin_->prev->next = node;
+    begin_->prev = node;
+  } else {
+    begin_ = node->prev = node->next = node;
+  }
+}
+
+void FreeList::remove(Node *node) {
+  LIBC_ASSERT(begin_ && "cannot remove from empty list");
+  if (node == node->next) {
+    LIBC_ASSERT(node == begin_ &&
+                "a self-referential node must be the only element");
+    begin_ = nullptr;
+  } else {
+    node->prev->next = node->next;
+    node->next->prev = node->prev;
+    if (begin_ == node)
+      begin_ = node->next;
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/freelist.h b/src/__support/freelist.h
index 0641ba9..c51f14f 100644
--- a/src/__support/freelist.h
+++ b/src/__support/freelist.h
@@ -1,4 +1,4 @@
-//===-- Interface for freelist_malloc -------------------------------------===//
+//===-- Interface for freelist --------------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -9,182 +9,81 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FREELIST_H
 #define LLVM_LIBC_SRC___SUPPORT_FREELIST_H
 
-#include "src/__support/CPP/array.h"
-#include "src/__support/CPP/cstddef.h"
-#include "src/__support/CPP/new.h"
-#include "src/__support/CPP/span.h"
-#include "src/__support/fixedvector.h"
+#include "block.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-using cpp::span;
-
-/// Basic [freelist](https://en.wikipedia.org/wiki/Free_list) implementation
-/// for an allocator. This implementation buckets by chunk size, with a list
-/// of user-provided buckets. Each bucket is a linked list of storage chunks.
-/// Because this freelist uses the added chunks themselves as list nodes, there
-/// is a lower bound of `sizeof(FreeList.FreeListNode)` bytes for chunks which
-/// can be added to this freelist. There is also an implicit bucket for
-/// "everything else", for chunks which do not fit into a bucket.
-///
-/// Each added chunk will be added to the smallest bucket under which it fits.
-/// If it does not fit into any user-provided bucket, it will be added to the
-/// default bucket.
-///
-/// As an example, assume that the `FreeList` is configured with buckets of
-/// sizes {64, 128, 256, and 512} bytes. The internal state may look like the
-/// following:
+/// A circularly-linked FIFO list storing free Blocks. All Blocks on a list
+/// are the same size. The blocks are referenced by Nodes in the list; the list
+/// refers to these, but it does not own them.
 ///
-/// @code{.unparsed}
-/// bucket[0] (64B) --> chunk[12B] --> chunk[42B] --> chunk[64B] --> NULL
-/// bucket[1] (128B) --> chunk[65B] --> chunk[72B] --> NULL
-/// bucket[2] (256B) --> NULL
-/// bucket[3] (512B) --> chunk[312B] --> chunk[512B] --> chunk[416B] --> NULL
-/// bucket[4] (implicit) --> chunk[1024B] --> chunk[513B] --> NULL
-/// @endcode
-///
-/// Note that added chunks should be aligned to a 4-byte boundary.
-template <size_t NUM_BUCKETS = 6> class FreeList {
+/// Allocating free blocks in FIFO order maximizes the amount of time before a
+/// free block is reused. This in turn maximizes the number of opportunities for
+/// it to be coalesced with an adjacent block, which tends to reduce heap
+/// fragmentation.
+class FreeList {
 public:
-  // Remove copy/move ctors
-  FreeList(const FreeList &other) = delete;
-  FreeList(FreeList &&other) = delete;
-  FreeList &operator=(const FreeList &other) = delete;
-  FreeList &operator=(FreeList &&other) = delete;
-
-  /// Adds a chunk to this freelist.
-  bool add_chunk(cpp::span<cpp::byte> chunk);
-
-  /// Finds an eligible chunk for an allocation of size `size`.
-  ///
-  /// @note This returns the first allocation possible within a given bucket;
-  /// It does not currently optimize for finding the smallest chunk.
-  ///
-  /// @returns
-  /// * On success - A span representing the chunk.
-  /// * On failure (e.g. there were no chunks available for that allocation) -
-  ///   A span with a size of 0.
-  cpp::span<cpp::byte> find_chunk(size_t size) const;
-
-  /// Removes a chunk from this freelist.
-  bool remove_chunk(cpp::span<cpp::byte> chunk);
-
-  /// For a given size, find which index into chunks_ the node should be written
-  /// to.
-  constexpr size_t find_chunk_ptr_for_size(size_t size, bool non_null) const;
-
-  struct FreeListNode {
-    FreeListNode *next;
-    size_t size;
-  };
-
-  constexpr void set_freelist_node(FreeListNode &node,
-                                   cpp::span<cpp::byte> chunk);
-
-  constexpr explicit FreeList(const cpp::array<size_t, NUM_BUCKETS> &sizes)
-      : chunks_(NUM_BUCKETS + 1, 0), sizes_(sizes.begin(), sizes.end()) {}
+  class Node {
+  public:
+    /// @returns The block containing this node.
+    LIBC_INLINE const Block *block() const {
+      return Block::from_usable_space(this);
+    }
 
-private:
-  FixedVector<FreeList::FreeListNode *, NUM_BUCKETS + 1> chunks_;
-  FixedVector<size_t, NUM_BUCKETS> sizes_;
-};
+    /// @returns The block containing this node.
+    LIBC_INLINE Block *block() { return Block::from_usable_space(this); }
 
-template <size_t NUM_BUCKETS>
-constexpr void FreeList<NUM_BUCKETS>::set_freelist_node(FreeListNode &node,
-                                                        span<cpp::byte> chunk) {
-  // Add it to the correct list.
-  size_t chunk_ptr = find_chunk_ptr_for_size(chunk.size(), false);
-  node.size = chunk.size();
-  node.next = chunks_[chunk_ptr];
-  chunks_[chunk_ptr] = &node;
-}
-
-template <size_t NUM_BUCKETS>
-bool FreeList<NUM_BUCKETS>::add_chunk(span<cpp::byte> chunk) {
-  // Check that the size is enough to actually store what we need
-  if (chunk.size() < sizeof(FreeListNode))
-    return false;
-
-  FreeListNode *node = ::new (chunk.data()) FreeListNode;
-  set_freelist_node(*node, chunk);
-
-  return true;
-}
-
-template <size_t NUM_BUCKETS>
-span<cpp::byte> FreeList<NUM_BUCKETS>::find_chunk(size_t size) const {
-  if (size == 0)
-    return span<cpp::byte>();
-
-  size_t chunk_ptr = find_chunk_ptr_for_size(size, true);
-
-  // Check that there's data. This catches the case where we run off the
-  // end of the array
-  if (chunks_[chunk_ptr] == nullptr)
-    return span<cpp::byte>();
-
-  // Now iterate up the buckets, walking each list to find a good candidate
-  for (size_t i = chunk_ptr; i < chunks_.size(); i++) {
-    FreeListNode *node = chunks_[static_cast<unsigned short>(i)];
-
-    while (node != nullptr) {
-      if (node->size >= size)
-        return span<cpp::byte>(reinterpret_cast<cpp::byte *>(node), node->size);
-
-      node = node->next;
-    }
-  }
+    /// @returns The inner size of blocks in the list containing this node.
+    LIBC_INLINE size_t size() const { return block()->inner_size(); }
 
-  // If we get here, we've checked every block in every bucket. There's
-  // nothing that can support this allocation.
-  return span<cpp::byte>();
-}
+  private:
+    // Circularly linked pointers to adjacent nodes.
+    Node *prev;
+    Node *next;
+    friend class FreeList;
+  };
 
-template <size_t NUM_BUCKETS>
-bool FreeList<NUM_BUCKETS>::remove_chunk(span<cpp::byte> chunk) {
-  size_t chunk_ptr = find_chunk_ptr_for_size(chunk.size(), true);
+  LIBC_INLINE constexpr FreeList() : FreeList(nullptr) {}
+  LIBC_INLINE constexpr FreeList(Node *begin) : begin_(begin) {}
 
-  // Check head first.
-  if (chunks_[chunk_ptr] == nullptr)
-    return false;
+  LIBC_INLINE bool empty() const { return !begin_; }
 
-  FreeListNode *node = chunks_[chunk_ptr];
-  if (reinterpret_cast<cpp::byte *>(node) == chunk.data()) {
-    chunks_[chunk_ptr] = node->next;
-    return true;
+  /// @returns The inner size of blocks in the list.
+  LIBC_INLINE size_t size() const {
+    LIBC_ASSERT(begin_ && "empty lists have no size");
+    return begin_->size();
   }
 
-  // No? Walk the nodes.
-  node = chunks_[chunk_ptr];
+  /// @returns The first node in the list.
+  LIBC_INLINE Node *begin() { return begin_; }
 
-  while (node->next != nullptr) {
-    if (reinterpret_cast<cpp::byte *>(node->next) == chunk.data()) {
-      // Found it, remove this node out of the chain
-      node->next = node->next->next;
-      return true;
-    }
+  /// @returns The first block in the list.
+  LIBC_INLINE Block *front() { return begin_->block(); }
 
-    node = node->next;
+  /// Push a block to the back of the list.
+  /// The block must be large enough to contain a node.
+  LIBC_INLINE void push(Block *block) {
+    LIBC_ASSERT(!block->used() &&
+                "only free blocks can be placed on free lists");
+    LIBC_ASSERT(block->inner_size_free() >= sizeof(FreeList) &&
+                "block too small to accomodate free list node");
+    push(new (block->usable_space()) Node);
   }
 
-  return false;
-}
-
-template <size_t NUM_BUCKETS>
-constexpr size_t
-FreeList<NUM_BUCKETS>::find_chunk_ptr_for_size(size_t size,
-                                               bool non_null) const {
-  size_t chunk_ptr = 0;
-  for (chunk_ptr = 0u; chunk_ptr < sizes_.size(); chunk_ptr++) {
-    if (sizes_[chunk_ptr] >= size &&
-        (!non_null || chunks_[chunk_ptr] != nullptr)) {
-      break;
-    }
-  }
+  /// Push an already-constructed node to the back of the list.
+  /// This allows pushing derived node types with additional data.
+  void push(Node *node);
+
+  /// Pop the first node from the list.
+  LIBC_INLINE void pop() { remove(begin_); }
+
+  /// Remove an arbitrary node from the list.
+  void remove(Node *node);
 
-  return chunk_ptr;
-}
+private:
+  Node *begin_;
+};
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FREELIST_H
diff --git a/src/__support/freelist_heap.h b/src/__support/freelist_heap.h
index 3569baf..8fa3625 100644
--- a/src/__support/freelist_heap.h
+++ b/src/__support/freelist_heap.h
@@ -12,168 +12,163 @@
 #include <stddef.h>
 
 #include "block.h"
-#include "freelist.h"
+#include "freestore.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/span.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/math_extras.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/memory_utils/inline_memset.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
+
+extern "C" cpp::byte _end;
+extern "C" cpp::byte __llvm_libc_heap_limit;
 
 using cpp::optional;
 using cpp::span;
 
-static constexpr cpp::array<size_t, 6> DEFAULT_BUCKETS{16,  32,  64,
-                                                       128, 256, 512};
+LIBC_INLINE constexpr bool IsPow2(size_t x) { return x && (x & (x - 1)) == 0; }
 
-template <size_t NUM_BUCKETS = DEFAULT_BUCKETS.size()> class FreeListHeap {
+class FreeListHeap {
 public:
-  using BlockType = Block<>;
-  using FreeListType = FreeList<NUM_BUCKETS>;
-
-  struct HeapStats {
-    size_t total_bytes;
-    size_t bytes_allocated;
-    size_t cumulative_allocated;
-    size_t cumulative_freed;
-    size_t total_allocate_calls;
-    size_t total_free_calls;
-  };
-
-  FreeListHeap(span<cpp::byte> region)
-      : FreeListHeap(&*region.begin(), &*region.end(), region.size()) {
-    auto result = BlockType::init(region);
-    BlockType *block = *result;
-    freelist_.add_chunk(block_to_span(block));
-  }
+  constexpr FreeListHeap() : begin(&_end), end(&__llvm_libc_heap_limit) {}
 
-  constexpr FreeListHeap(void *start, cpp::byte *end, size_t total_bytes)
-      : block_region_start_(start), block_region_end_(end),
-        freelist_(DEFAULT_BUCKETS), heap_stats_{} {
-    heap_stats_.total_bytes = total_bytes;
-  }
+  constexpr FreeListHeap(span<cpp::byte> region)
+      : begin(region.begin()), end(region.end()) {}
 
   void *allocate(size_t size);
+  void *aligned_allocate(size_t alignment, size_t size);
+  // NOTE: All pointers passed to free must come from one of the other
+  // allocation functions: `allocate`, `aligned_allocate`, `realloc`, `calloc`.
   void free(void *ptr);
   void *realloc(void *ptr, size_t size);
   void *calloc(size_t num, size_t size);
 
-  const HeapStats &heap_stats() const { return heap_stats_; }
-  void reset_heap_stats() { heap_stats_ = {}; }
+  cpp::span<cpp::byte> region() const { return {begin, end}; }
 
-  void *region_start() const { return block_region_start_; }
-  size_t region_size() const {
-    return reinterpret_cast<uintptr_t>(block_region_end_) -
-           reinterpret_cast<uintptr_t>(block_region_start_);
-  }
+private:
+  void init();
 
-protected:
-  constexpr void set_freelist_node(typename FreeListType::FreeListNode &node,
-                                   cpp::span<cpp::byte> chunk) {
-    freelist_.set_freelist_node(node, chunk);
-  }
+  void *allocate_impl(size_t alignment, size_t size);
 
-private:
-  span<cpp::byte> block_to_span(BlockType *block) {
+  span<cpp::byte> block_to_span(Block *block) {
     return span<cpp::byte>(block->usable_space(), block->inner_size());
   }
 
-  bool is_valid_ptr(void *ptr) {
-    return ptr >= block_region_start_ && ptr < block_region_end_;
-  }
+  bool is_valid_ptr(void *ptr) { return ptr >= begin && ptr < end; }
 
-  void *block_region_start_;
-  void *block_region_end_;
-  FreeListType freelist_;
-  HeapStats heap_stats_;
+  cpp::byte *begin;
+  cpp::byte *end;
+  bool is_initialized = false;
+  FreeStore free_store;
 };
 
-template <size_t BUFF_SIZE, size_t NUM_BUCKETS = DEFAULT_BUCKETS.size()>
-struct FreeListHeapBuffer : public FreeListHeap<NUM_BUCKETS> {
-  using parent = FreeListHeap<NUM_BUCKETS>;
-  using FreeListNode = typename parent::FreeListType::FreeListNode;
+template <size_t BUFF_SIZE> class FreeListHeapBuffer : public FreeListHeap {
+public:
+  constexpr FreeListHeapBuffer() : FreeListHeap{buffer}, buffer{} {}
 
-  constexpr FreeListHeapBuffer()
-      : FreeListHeap<NUM_BUCKETS>(&block, buffer + sizeof(buffer), BUFF_SIZE),
-        block(0, BUFF_SIZE), node{}, buffer{} {
-    block.mark_last();
+private:
+  cpp::byte buffer[BUFF_SIZE];
+};
 
-    cpp::span<cpp::byte> chunk(buffer, sizeof(buffer));
-    parent::set_freelist_node(node, chunk);
-  }
+LIBC_INLINE void FreeListHeap::init() {
+  LIBC_ASSERT(!is_initialized && "duplicate initialization");
+  auto result = Block::init(region());
+  Block *block = *result;
+  free_store.set_range({0, cpp::bit_ceil(block->inner_size())});
+  free_store.insert(block);
+  is_initialized = true;
+}
 
-  typename parent::BlockType block;
-  FreeListNode node;
-  cpp::byte buffer[BUFF_SIZE - sizeof(block) - sizeof(node)];
-};
+LIBC_INLINE void *FreeListHeap::allocate_impl(size_t alignment, size_t size) {
+  if (size == 0)
+    return nullptr;
 
-template <size_t NUM_BUCKETS>
-void *FreeListHeap<NUM_BUCKETS>::allocate(size_t size) {
-  // Find a chunk in the freelist. Split it if needed, then return
-  auto chunk = freelist_.find_chunk(size);
+  if (!is_initialized)
+    init();
+
+  size_t request_size = size;
+
+  // TODO: usable_space should always be aligned to max_align_t.
+  if (alignment > alignof(max_align_t) ||
+      (Block::BLOCK_OVERHEAD % alignof(max_align_t) != 0)) {
+    // TODO: This bound isn't precisely calculated yet. It assumes one extra
+    // Block::ALIGNMENT to accomodate the possibility for padding block
+    // overhead. (alignment - 1) ensures that there is an aligned point
+    // somewhere in usable_space, but this isn't tight either, since
+    // usable_space is also already somewhat aligned.
+    if (add_overflow(size, (alignment - 1) + Block::ALIGNMENT, request_size))
+      return nullptr;
+  }
 
-  if (chunk.data() == nullptr)
+  Block *block = free_store.remove_best_fit(request_size);
+  if (!block)
     return nullptr;
-  freelist_.remove_chunk(chunk);
 
-  BlockType *chunk_block = BlockType::from_usable_space(chunk.data());
+  LIBC_ASSERT(block->can_allocate(alignment, size) &&
+              "block should always be large enough to allocate at the correct "
+              "alignment");
 
-  // Split that chunk. If there's a leftover chunk, add it to the freelist
-  optional<BlockType *> result = BlockType::split(chunk_block, size);
-  if (result)
-    freelist_.add_chunk(block_to_span(*result));
+  auto block_info = Block::allocate(block, alignment, size);
+  if (block_info.next)
+    free_store.insert(block_info.next);
+  if (block_info.prev)
+    free_store.insert(block_info.prev);
+
+  block_info.block->mark_used();
+  return block_info.block->usable_space();
+}
 
-  chunk_block->mark_used();
+LIBC_INLINE void *FreeListHeap::allocate(size_t size) {
+  return allocate_impl(alignof(max_align_t), size);
+}
+
+LIBC_INLINE void *FreeListHeap::aligned_allocate(size_t alignment,
+                                                 size_t size) {
+  // The alignment must be an integral power of two.
+  if (!IsPow2(alignment))
+    return nullptr;
 
-  heap_stats_.bytes_allocated += size;
-  heap_stats_.cumulative_allocated += size;
-  heap_stats_.total_allocate_calls += 1;
+  // The size parameter must be an integral multiple of alignment.
+  if (size % alignment != 0)
+    return nullptr;
 
-  return chunk_block->usable_space();
+  return allocate_impl(alignment, size);
 }
 
-template <size_t NUM_BUCKETS> void FreeListHeap<NUM_BUCKETS>::free(void *ptr) {
+LIBC_INLINE void FreeListHeap::free(void *ptr) {
   cpp::byte *bytes = static_cast<cpp::byte *>(ptr);
 
   LIBC_ASSERT(is_valid_ptr(bytes) && "Invalid pointer");
 
-  BlockType *chunk_block = BlockType::from_usable_space(bytes);
-
-  size_t size_freed = chunk_block->inner_size();
-  LIBC_ASSERT(chunk_block->used() && "The block is not in-use");
-  chunk_block->mark_free();
+  Block *block = Block::from_usable_space(bytes);
+  LIBC_ASSERT(block->next() && "sentinel last block cannot be freed");
+  LIBC_ASSERT(block->used() && "double free");
+  block->mark_free();
 
   // Can we combine with the left or right blocks?
-  BlockType *prev = chunk_block->prev();
-  BlockType *next = nullptr;
-
-  if (!chunk_block->last())
-    next = chunk_block->next();
-
-  if (prev != nullptr && !prev->used()) {
-    // Remove from freelist and merge
-    freelist_.remove_chunk(block_to_span(prev));
-    chunk_block = chunk_block->prev();
-    BlockType::merge_next(chunk_block);
+  Block *prev_free = block->prev_free();
+  Block *next = block->next();
+
+  if (prev_free != nullptr) {
+    // Remove from free store and merge.
+    free_store.remove(prev_free);
+    block = prev_free;
+    block->merge_next();
   }
-
-  if (next != nullptr && !next->used()) {
-    freelist_.remove_chunk(block_to_span(next));
-    BlockType::merge_next(chunk_block);
+  if (!next->used()) {
+    free_store.remove(next);
+    block->merge_next();
   }
   // Add back to the freelist
-  freelist_.add_chunk(block_to_span(chunk_block));
-
-  heap_stats_.bytes_allocated -= size_freed;
-  heap_stats_.cumulative_freed += size_freed;
-  heap_stats_.total_free_calls += 1;
+  free_store.insert(block);
 }
 
 // Follows constract of the C standard realloc() function
 // If ptr is free'd, will return nullptr.
-template <size_t NUM_BUCKETS>
-void *FreeListHeap<NUM_BUCKETS>::realloc(void *ptr, size_t size) {
+LIBC_INLINE void *FreeListHeap::realloc(void *ptr, size_t size) {
   if (size == 0) {
     free(ptr);
     return nullptr;
@@ -188,10 +183,10 @@ void *FreeListHeap<NUM_BUCKETS>::realloc(void *ptr, size_t size) {
   if (!is_valid_ptr(bytes))
     return nullptr;
 
-  BlockType *chunk_block = BlockType::from_usable_space(bytes);
-  if (!chunk_block->used())
+  Block *block = Block::from_usable_space(bytes);
+  if (!block->used())
     return nullptr;
-  size_t old_size = chunk_block->inner_size();
+  size_t old_size = block->inner_size();
 
   // Do nothing and return ptr if the required memory size is smaller than
   // the current size.
@@ -208,16 +203,18 @@ void *FreeListHeap<NUM_BUCKETS>::realloc(void *ptr, size_t size) {
   return new_ptr;
 }
 
-template <size_t NUM_BUCKETS>
-void *FreeListHeap<NUM_BUCKETS>::calloc(size_t num, size_t size) {
-  void *ptr = allocate(num * size);
+LIBC_INLINE void *FreeListHeap::calloc(size_t num, size_t size) {
+  size_t bytes;
+  if (__builtin_mul_overflow(num, size, &bytes))
+    return nullptr;
+  void *ptr = allocate(bytes);
   if (ptr != nullptr)
-    LIBC_NAMESPACE::inline_memset(ptr, 0, num * size);
+    LIBC_NAMESPACE::inline_memset(ptr, 0, bytes);
   return ptr;
 }
 
-extern FreeListHeap<> *freelist_heap;
+extern FreeListHeap *freelist_heap;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_FREELIST_HEAP_H
diff --git a/src/__support/freestore.h b/src/__support/freestore.h
new file mode 100644
index 0000000..97197dd
--- /dev/null
+++ b/src/__support/freestore.h
@@ -0,0 +1,114 @@
+//===-- Interface for freestore ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FREESTORE_H
+#define LLVM_LIBC_SRC___SUPPORT_FREESTORE_H
+
+#include "freetrie.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+/// A best-fit store of variously-sized free blocks. Blocks can be inserted and
+/// removed in logarithmic time.
+class FreeStore {
+public:
+  FreeStore() = default;
+  FreeStore(const FreeStore &other) = delete;
+  FreeStore &operator=(const FreeStore &other) = delete;
+
+  /// Sets the range of possible block sizes. This can only be called when the
+  /// trie is empty.
+  LIBC_INLINE void set_range(FreeTrie::SizeRange range) {
+    large_trie.set_range(range);
+  }
+
+  /// Insert a free block. If the block is too small to be tracked, nothing
+  /// happens.
+  void insert(Block *block);
+
+  /// Remove a free block. If the block is too small to be tracked, nothing
+  /// happens.
+  void remove(Block *block);
+
+  /// Remove a best-fit free block that can contain the given size when
+  /// allocated. Returns nullptr if there is no such block.
+  Block *remove_best_fit(size_t size);
+
+private:
+  static constexpr size_t ALIGNMENT = alignof(max_align_t);
+  static constexpr size_t MIN_OUTER_SIZE =
+      align_up(Block::BLOCK_OVERHEAD + sizeof(FreeList::Node), ALIGNMENT);
+  static constexpr size_t MIN_LARGE_OUTER_SIZE =
+      align_up(Block::BLOCK_OVERHEAD + sizeof(FreeTrie::Node), ALIGNMENT);
+  static constexpr size_t NUM_SMALL_SIZES =
+      (MIN_LARGE_OUTER_SIZE - MIN_OUTER_SIZE) / ALIGNMENT;
+
+  LIBC_INLINE static bool too_small(Block *block) {
+    return block->outer_size() < MIN_OUTER_SIZE;
+  }
+  LIBC_INLINE static bool is_small(Block *block) {
+    return block->outer_size() < MIN_LARGE_OUTER_SIZE;
+  }
+
+  FreeList &small_list(Block *block);
+  FreeList *find_best_small_fit(size_t size);
+
+  cpp::array<FreeList, NUM_SMALL_SIZES> small_lists;
+  FreeTrie large_trie;
+};
+
+LIBC_INLINE void FreeStore::insert(Block *block) {
+  if (too_small(block))
+    return;
+  if (is_small(block))
+    small_list(block).push(block);
+  else
+    large_trie.push(block);
+}
+
+LIBC_INLINE void FreeStore::remove(Block *block) {
+  if (too_small(block))
+    return;
+  if (is_small(block)) {
+    small_list(block).remove(
+        reinterpret_cast<FreeList::Node *>(block->usable_space()));
+  } else {
+    large_trie.remove(
+        reinterpret_cast<FreeTrie::Node *>(block->usable_space()));
+  }
+}
+
+LIBC_INLINE Block *FreeStore::remove_best_fit(size_t size) {
+  if (FreeList *list = find_best_small_fit(size)) {
+    Block *block = list->front();
+    list->pop();
+    return block;
+  }
+  if (FreeTrie::Node *best_fit = large_trie.find_best_fit(size)) {
+    Block *block = best_fit->block();
+    large_trie.remove(best_fit);
+    return block;
+  }
+  return nullptr;
+}
+
+LIBC_INLINE FreeList &FreeStore::small_list(Block *block) {
+  LIBC_ASSERT(is_small(block) && "only legal for small blocks");
+  return small_lists[(block->outer_size() - MIN_OUTER_SIZE) / ALIGNMENT];
+}
+
+LIBC_INLINE FreeList *FreeStore::find_best_small_fit(size_t size) {
+  for (FreeList &list : small_lists)
+    if (!list.empty() && list.size() >= size)
+      return &list;
+  return nullptr;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FREESTORE_H
diff --git a/src/__support/freetrie.cpp b/src/__support/freetrie.cpp
new file mode 100644
index 0000000..e76efe7
--- /dev/null
+++ b/src/__support/freetrie.cpp
@@ -0,0 +1,64 @@
+//===-- Implementation for freetrie ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "freetrie.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void FreeTrie::remove(Node *node) {
+  LIBC_ASSERT(!empty() && "cannot remove from empty trie");
+  FreeList list = node;
+  list.pop();
+  Node *new_node = static_cast<Node *>(list.begin());
+  if (!new_node) {
+    // The freelist is empty. Replace the subtrie root with an arbitrary leaf.
+    // This is legal because there is no relationship between the size of the
+    // root and its children.
+    Node *leaf = node;
+    while (leaf->lower || leaf->upper)
+      leaf = leaf->lower ? leaf->lower : leaf->upper;
+    if (leaf == node) {
+      // If the root is a leaf, then removing it empties the subtrie.
+      replace_node(node, nullptr);
+      return;
+    }
+
+    replace_node(leaf, nullptr);
+    new_node = leaf;
+  }
+
+  if (!is_head(node))
+    return;
+
+  // Copy the trie links to the new head.
+  new_node->lower = node->lower;
+  new_node->upper = node->upper;
+  new_node->parent = node->parent;
+  replace_node(node, new_node);
+}
+
+void FreeTrie::replace_node(Node *node, Node *new_node) {
+  LIBC_ASSERT(is_head(node) && "only head nodes contain trie links");
+
+  if (node->parent) {
+    Node *&parent_child =
+        node->parent->lower == node ? node->parent->lower : node->parent->upper;
+    LIBC_ASSERT(parent_child == node &&
+                "no reference to child node found in parent");
+    parent_child = new_node;
+  } else {
+    LIBC_ASSERT(root == node && "non-root node had no parent");
+    root = new_node;
+  }
+  if (node->lower)
+    node->lower->parent = new_node;
+  if (node->upper)
+    node->upper->parent = new_node;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/freetrie.h b/src/__support/freetrie.h
new file mode 100644
index 0000000..42363c2
--- /dev/null
+++ b/src/__support/freetrie.h
@@ -0,0 +1,237 @@
+//===-- Interface for freetrie --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_FREETRIE_H
+#define LLVM_LIBC_SRC___SUPPORT_FREETRIE_H
+
+#include "freelist.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+/// A trie of free lists.
+///
+/// This is an unusual little data structure originally from Doug Lea's malloc.
+/// Finding the best fit from a set of differently-sized free list typically
+/// required some kind of ordered map, and these are typically implemented using
+/// a self-balancing binary search tree. Those are notorious for having a
+/// relatively large number of special cases, while this trie has relatively
+/// few, which helps with code size.
+///
+/// Operations on the trie are logarithmic not on the number of nodes within it,
+/// but rather the fixed range of possible sizes that the trie can contain. This
+/// means that the data structure would likely actually perform worse than an
+/// e.g. red-black tree, but its implementation is still much simpler.
+///
+/// Each trie node's children subdivide the range of possible sizes into two
+/// halves: a lower and an upper. The node itself holds a free list of some size
+/// within its range. This makes it possible to summarily replace any node with
+/// any leaf within its subtrie, which makes it very straightforward to remove a
+/// node. Insertion is also simple; the only real complexity lies with finding
+/// the best fit. This can still be done in logarithmic time with only a few
+/// cases to consider.
+///
+/// The trie refers to, but does not own, the Nodes that comprise it.
+class FreeTrie {
+public:
+  /// A trie node that is also a free list. Only the head node of each list is
+  /// actually part of the trie. The subtrie contains a continous SizeRange of
+  /// free lists. The lower and upper subtrie's contain the lower and upper half
+  /// of the subtries range. There is no direct relationship between the size of
+  /// this node's free list and the contents of the lower and upper subtries.
+  class Node : public FreeList::Node {
+    /// The child subtrie covering the lower half of this subtrie's size range.
+    /// Undefined if this is not the head of the list.
+    Node *lower;
+    /// The child subtrie covering the upper half of this subtrie's size range.
+    /// Undefined if this is not the head of the list.
+    Node *upper;
+    /// The parent subtrie. nullptr if this is the root or not the head of the
+    /// list.
+    Node *parent;
+
+    friend class FreeTrie;
+  };
+
+  /// Power-of-two range of sizes covered by a subtrie.
+  struct SizeRange {
+    size_t min;
+    size_t width;
+
+    LIBC_INLINE constexpr SizeRange(size_t min, size_t width)
+        : min(min), width(width) {
+      LIBC_ASSERT(!(width & (width - 1)) && "width must be a power of two");
+    }
+
+    /// @returns The lower half of the size range.
+    LIBC_INLINE SizeRange lower() const { return {min, width / 2}; }
+
+    /// @returns The upper half of the size range.
+    LIBC_INLINE SizeRange upper() const { return {min + width / 2, width / 2}; }
+
+    /// @returns The largest size in this range.
+    LIBC_INLINE size_t max() const { return min + (width - 1); }
+
+    /// @returns Whether the range contains the given size.
+    LIBC_INLINE bool contains(size_t size) const {
+      return min <= size && size < min + width;
+    }
+  };
+
+  LIBC_INLINE constexpr FreeTrie() : FreeTrie(SizeRange{0, 0}) {}
+  LIBC_INLINE constexpr FreeTrie(SizeRange range) : range(range) {}
+
+  /// Sets the range of possible block sizes. This can only be called when the
+  /// trie is empty.
+  LIBC_INLINE void set_range(FreeTrie::SizeRange range) {
+    LIBC_ASSERT(empty() && "cannot change the range of a preexisting trie");
+    this->range = range;
+  }
+
+  /// @returns Whether the trie contains any blocks.
+  LIBC_INLINE bool empty() const { return !root; }
+
+  /// Push a block to the trie.
+  void push(Block *block);
+
+  /// Remove a node from this trie node's free list.
+  void remove(Node *node);
+
+  /// @returns A smallest node that can allocate the given size; otherwise
+  /// nullptr.
+  Node *find_best_fit(size_t size);
+
+private:
+  /// @returns Whether a node is the head of its containing freelist.
+  bool is_head(Node *node) const { return node->parent || node == root; }
+
+  /// Replaces references to one node with another (or nullptr) in all adjacent
+  /// parent and child nodes.
+  void replace_node(Node *node, Node *new_node);
+
+  Node *root = nullptr;
+  SizeRange range;
+};
+
+LIBC_INLINE void FreeTrie::push(Block *block) {
+  LIBC_ASSERT(block->inner_size_free() >= sizeof(Node) &&
+              "block too small to accomodate free trie node");
+  size_t size = block->inner_size();
+  LIBC_ASSERT(range.contains(size) && "requested size out of trie range");
+
+  // Find the position in the tree to push to.
+  Node **cur = &root;
+  Node *parent = nullptr;
+  SizeRange cur_range = range;
+  while (*cur && (*cur)->size() != size) {
+    LIBC_ASSERT(cur_range.contains(size) && "requested size out of trie range");
+    parent = *cur;
+    if (size <= cur_range.lower().max()) {
+      cur = &(*cur)->lower;
+      cur_range = cur_range.lower();
+    } else {
+      cur = &(*cur)->upper;
+      cur_range = cur_range.upper();
+    }
+  }
+
+  Node *node = new (block->usable_space()) Node;
+  FreeList list = *cur;
+  if (list.empty()) {
+    node->parent = parent;
+    node->lower = node->upper = nullptr;
+  } else {
+    node->parent = nullptr;
+  }
+  list.push(node);
+  *cur = static_cast<Node *>(list.begin());
+}
+
+LIBC_INLINE FreeTrie::Node *FreeTrie::find_best_fit(size_t size) {
+  if (empty() || range.max() < size)
+    return nullptr;
+
+  Node *cur = root;
+  SizeRange cur_range = range;
+  Node *best_fit = nullptr;
+  Node *deferred_upper_trie = nullptr;
+  FreeTrie::SizeRange deferred_upper_range{0, 0};
+
+  while (true) {
+    LIBC_ASSERT(cur_range.contains(cur->size()) &&
+                "trie node size out of range");
+    LIBC_ASSERT(cur_range.max() >= size &&
+                "range could not fit requested size");
+    LIBC_ASSERT((!best_fit || cur_range.min < best_fit->size()) &&
+                "range could not contain a best fit");
+
+    // If the current node is an exact fit, it is a best fit.
+    if (cur->size() == size)
+      return cur;
+
+    if (cur->size() > size && (!best_fit || cur->size() < best_fit->size())) {
+      // The current node is a better fit.
+      best_fit = cur;
+
+      // If there is a deferred upper subtrie, then the current node is
+      // somewhere in its lower sibling subtrie. That means that the new best
+      // fit is better than the best fit in the deferred subtrie.
+      LIBC_ASSERT(
+          (!deferred_upper_trie ||
+           deferred_upper_range.min > best_fit->size()) &&
+          "deferred upper subtrie should be outclassed by new best fit");
+      deferred_upper_trie = nullptr;
+    }
+
+    // Determine which subtries might contain the best fit.
+    bool lower_impossible = !cur->lower || cur_range.lower().max() < size;
+    bool upper_impossible =
+        !cur->upper ||
+        // If every node in the lower trie fits
+        (!lower_impossible && cur_range.min >= size) ||
+        // If every node in the upper trie is worse than the current best
+        (best_fit && cur_range.upper().min >= best_fit->size());
+
+    if (lower_impossible && upper_impossible) {
+      if (!deferred_upper_trie)
+        return best_fit;
+      // Scan the deferred upper subtrie and consider whether any element within
+      // provides a better fit.
+      //
+      // This can only ever be reached once. In a deferred upper subtrie, every
+      // node fits, so the higher of two subtries can never contain a best fit.
+      cur = deferred_upper_trie;
+      cur_range = deferred_upper_range;
+      deferred_upper_trie = nullptr;
+      continue;
+    }
+
+    if (lower_impossible) {
+      cur = cur->upper;
+      cur_range = cur_range.upper();
+    } else if (upper_impossible) {
+      cur = cur->lower;
+      cur_range = cur_range.lower();
+    } else {
+      // Both subtries might contain a better fit. Any fit in the lower subtrie
+      // is better than the any fit in the upper subtrie, so scan the lower
+      // and return to the upper only if no better fits were found. (Any better
+      // fit found clears the deferred upper subtrie.)
+      LIBC_ASSERT((!deferred_upper_trie ||
+                   cur_range.upper().max() < deferred_upper_range.min) &&
+                  "old deferred upper subtrie should be outclassed by new");
+      deferred_upper_trie = cur->upper;
+      deferred_upper_range = cur_range.upper();
+      cur = cur->lower;
+      cur_range = cur_range.lower();
+    }
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_FREETRIE_H
diff --git a/src/__support/hash.h b/src/__support/hash.h
index d1218fd..49138b1 100644
--- a/src/__support/hash.h
+++ b/src/__support/hash.h
@@ -12,10 +12,11 @@
 #include "src/__support/CPP/bit.h"           // rotl
 #include "src/__support/CPP/limits.h"        // numeric_limits
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/uint128.h"           // UInt128
-#include <stdint.h>                          // For uint64_t
+#include "src/__support/macros/config.h"
+#include "src/__support/uint128.h" // UInt128
+#include <stdint.h>                // For uint64_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // Folded multiplication.
@@ -33,25 +34,23 @@ LIBC_INLINE uint64_t folded_multiply(uint64_t x, uint64_t y) {
 // Therefore, we use a union to read the value.
 template <typename T> LIBC_INLINE T read_little_endian(const void *ptr) {
   const uint8_t *bytes = static_cast<const uint8_t *>(ptr);
-  union {
-    T value;
-    uint8_t buffer[sizeof(T)];
-  } data;
+  uint8_t buffer[sizeof(T)];
 #if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
-  // Compiler should able to optimize this as a load followed by a byte swap.
-  // On aarch64 (-mbig-endian), this compiles to the following for int:
+  // Compiler should able to optimize this as a load followed by a byte
+  // swap. On aarch64 (-mbig-endian), this compiles to the following for
+  // int:
   //      ldr     w0, [x0]
   //      rev     w0, w0
   //      ret
   for (size_t i = 0; i < sizeof(T); ++i) {
-    data.buffer[i] = bytes[sizeof(T) - i - 1];
+    buffer[i] = bytes[sizeof(T) - i - 1];
   }
 #else
   for (size_t i = 0; i < sizeof(T); ++i) {
-    data.buffer[i] = bytes[i];
+    buffer[i] = bytes[i];
   }
 #endif
-  return data.value;
+  return cpp::bit_cast<T>(buffer);
 }
 
 // Specialized read functions for small values. size must be <= 8.
@@ -160,6 +159,6 @@ public:
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_HASH_H
diff --git a/src/__support/high_precision_decimal.h b/src/__support/high_precision_decimal.h
index 2c5a349..20088d6 100644
--- a/src/__support/high_precision_decimal.h
+++ b/src/__support/high_precision_decimal.h
@@ -6,15 +6,22 @@
 //
 //===----------------------------------------------------------------------===//
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This file is shared with libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
+
 #ifndef LLVM_LIBC_SRC___SUPPORT_HIGH_PRECISION_DECIMAL_H
 #define LLVM_LIBC_SRC___SUPPORT_HIGH_PRECISION_DECIMAL_H
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 struct LShiftTableEntry {
@@ -22,6 +29,11 @@ struct LShiftTableEntry {
   char const *power_of_five;
 };
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 // This is used in both this file and in the main str_to_float.h.
 // TODO: Figure out where to put this.
 enum class RoundDirection { Up, Down, Nearest };
@@ -338,7 +350,8 @@ public:
     if (!saw_dot)
       this->decimal_point = total_digits;
 
-    if (num_cur < num_len && ((num_string[num_cur] | 32) == 'e')) {
+    if (num_cur < num_len &&
+        (num_string[num_cur] == 'e' || num_string[num_cur] == 'E')) {
       ++num_cur;
       if (isdigit(num_string[num_cur]) || num_string[num_cur] == '+' ||
           num_string[num_cur] == '-') {
@@ -409,7 +422,8 @@ public:
       result *= 10;
       ++cur_digit;
     }
-    return result + this->should_round_up(this->decimal_point, round);
+    return result + static_cast<unsigned int>(
+                        this->should_round_up(this->decimal_point, round));
   }
 
   // Extra functions for testing.
@@ -421,6 +435,6 @@ public:
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_HIGH_PRECISION_DECIMAL_H
diff --git a/src/__support/integer_literals.h b/src/__support/integer_literals.h
index 5fb6746..4c5c4c4 100644
--- a/src/__support/integer_literals.h
+++ b/src/__support/integer_literals.h
@@ -15,11 +15,12 @@
 
 #include "src/__support/CPP/limits.h"        // CHAR_BIT
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/uint128.h"           // UInt128
 #include <stddef.h>                          // size_t
 #include <stdint.h>                          // uintxx_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE constexpr uint8_t operator""_u8(unsigned long long value) {
   return static_cast<uint8_t>(value);
@@ -164,6 +165,10 @@ LIBC_INLINE constexpr T parse_with_prefix(const char *ptr) {
 
 } // namespace internal
 
+LIBC_INLINE constexpr UInt<96> operator""_u96(const char *x) {
+  return internal::parse_with_prefix<UInt<96>>(x);
+}
+
 LIBC_INLINE constexpr UInt128 operator""_u128(const char *x) {
   return internal::parse_with_prefix<UInt128>(x);
 }
@@ -182,6 +187,6 @@ template <typename T> LIBC_INLINE constexpr T parse_bigint(const char *ptr) {
   return internal::parse_with_prefix<T>(ptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_INTEGER_LITERALS_H
diff --git a/src/__support/integer_operations.h b/src/__support/integer_operations.h
index 390181f..4ecff70 100644
--- a/src/__support/integer_operations.h
+++ b/src/__support/integer_operations.h
@@ -11,8 +11,9 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename T>
 LIBC_INLINE static constexpr cpp::enable_if_t<cpp::is_integral_v<T>, T>
@@ -27,6 +28,6 @@ integer_rem_quo(T x, T y, T &quot, T &rem) {
   rem = x % y;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_INTEGER_OPERATIONS_H
diff --git a/src/__support/integer_to_string.h b/src/__support/integer_to_string.h
index 375f0e8..40d45a0 100644
--- a/src/__support/integer_to_string.h
+++ b/src/__support/integer_to_string.h
@@ -69,8 +69,9 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/big_int.h" // make_integral_or_big_int_unsigned_t
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace details {
 
@@ -317,6 +318,6 @@ public:
   }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_INTEGER_TO_STRING_H
diff --git a/src/__support/intrusive_list.h b/src/__support/intrusive_list.h
index 69be877..4bbd8a4 100644
--- a/src/__support/intrusive_list.h
+++ b/src/__support/intrusive_list.h
@@ -14,8 +14,9 @@
 #define LLVM_LIBC_SRC___SUPPORT_INTRUSIVE_LIST_H
 
 #include "common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 class IntrusiveList {
@@ -60,6 +61,6 @@ public:
 };
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_INTRUSIVE_LIST_H
diff --git a/src/__support/libc_assert.h b/src/__support/libc_assert.h
index ed06cc3..3db179f 100644
--- a/src/__support/libc_assert.h
+++ b/src/__support/libc_assert.h
@@ -9,7 +9,8 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_LIBC_ASSERT_H
 #define LLVM_LIBC_SRC___SUPPORT_LIBC_ASSERT_H
 
-#ifdef LIBC_COPT_USE_C_ASSERT
+#include "src/__support/macros/config.h"
+#if defined(LIBC_COPT_USE_C_ASSERT) || !defined(LIBC_FULL_BUILD)
 
 // The build is configured to just use the public <assert.h> API
 // for libc's internal assertions.
@@ -23,9 +24,10 @@
 #include "src/__support/OSUtil/exit.h"
 #include "src/__support/OSUtil/io.h"
 #include "src/__support/integer_to_string.h"
-#include "src/__support/macros/attributes.h" // For LIBC_INLINE
+#include "src/__support/macros/attributes.h"   // For LIBC_INLINE
+#include "src/__support/macros/optimization.h" // For LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This is intended to be removed in a future patch to use a similar design to
 // below, but it's necessary for the external assert.
@@ -43,7 +45,7 @@ LIBC_INLINE void report_assertion_failure(const char *assertion,
   write_to_stderr("'\n");
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #ifdef LIBC_ASSERT
 #error "Unexpected: LIBC_ASSERT macro already defined"
@@ -70,7 +72,7 @@ LIBC_INLINE void report_assertion_failure(const char *assertion,
 
 #define LIBC_ASSERT(COND)                                                      \
   do {                                                                         \
-    if (!(COND)) {                                                             \
+    if (LIBC_UNLIKELY(!(COND))) {                                              \
       LIBC_NAMESPACE::write_to_stderr(__FILE__ ":" __LIBC_LINE_STR__           \
                                                ": Assertion failed: '" #COND   \
                                                "' in function: '");            \
diff --git a/src/__support/macros/config.h b/src/__support/macros/config.h
index 6390c79..2ab0fba 100644
--- a/src/__support/macros/config.h
+++ b/src/__support/macros/config.h
@@ -27,4 +27,20 @@
 #define LIBC_HAS_FEATURE(f) 0
 #endif
 
+#ifdef __clang__
+// Declare a LIBC_NAMESPACE with hidden visibility. `namespace
+// LIBC_NAMESPACE_DECL {` should be used around all declarations and definitions
+// for libc internals as opposed to just `namespace LIBC_NAMESPACE {`. This
+// ensures that all declarations within this namespace have hidden
+// visibility, which optimizes codegen for uses of symbols defined in other
+// translation units in ways that can be necessary for correctness by avoiding
+// dynamic relocations. This does not affect the public C symbols which are
+// controlled independently via `LLVM_LIBC_FUNCTION_ATTR`.
+#define LIBC_NAMESPACE_DECL [[gnu::visibility("hidden")]] LIBC_NAMESPACE
+#else
+// TODO(#98548): GCC emits a warning when using the visibility attribute which
+// needs to be diagnosed and addressed.
+#define LIBC_NAMESPACE_DECL LIBC_NAMESPACE
+#endif
+
 #endif // LLVM_LIBC_SRC___SUPPORT_MACROS_CONFIG_H
diff --git a/src/__support/macros/null_check.h b/src/__support/macros/null_check.h
new file mode 100644
index 0000000..400f7d8
--- /dev/null
+++ b/src/__support/macros/null_check.h
@@ -0,0 +1,33 @@
+//===-- Safe nullptr check --------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_MACROS_NULL_CHECK_H
+#define LLVM_LIBC_SRC___SUPPORT_MACROS_NULL_CHECK_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/sanitizer.h"
+
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
+// Use volatile to prevent undefined behavior of dereferencing nullptr.
+// Intentionally crashing with SIGSEGV.
+#define LIBC_CRASH_ON_NULLPTR(PTR)                                             \
+  do {                                                                         \
+    if (LIBC_UNLIKELY(PTR == nullptr)) {                                       \
+      volatile auto *crashing = PTR;                                           \
+      [[maybe_unused]] volatile auto crash = *crashing;                        \
+      __builtin_trap();                                                        \
+    }                                                                          \
+  } while (0)
+#else
+#define LIBC_CRASH_ON_NULLPTR(ptr)                                             \
+  do {                                                                         \
+  } while (0)
+#endif
+
+#endif // LLVM_LIBC_SRC___SUPPORT_MACROS_NULL_CHECK_H
diff --git a/src/__support/macros/optimization.h b/src/__support/macros/optimization.h
index 59886ca..41ecd2b 100644
--- a/src/__support/macros/optimization.h
+++ b/src/__support/macros/optimization.h
@@ -11,16 +11,19 @@
 #define LLVM_LIBC_SRC___SUPPORT_MACROS_OPTIMIZATION_H
 
 #include "src/__support/macros/attributes.h"          // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/compiler.h" // LIBC_COMPILER_IS_CLANG
 
 // We use a template to implement likely/unlikely to make sure that we don't
 // accidentally pass an integer.
-namespace LIBC_NAMESPACE::details {
+namespace LIBC_NAMESPACE_DECL {
+namespace details {
 template <typename T>
 LIBC_INLINE constexpr bool expects_bool_condition(T value, T expected) {
   return __builtin_expect(value, expected);
 }
-} // namespace LIBC_NAMESPACE::details
+} // namespace details
+} // namespace LIBC_NAMESPACE_DECL
 #define LIBC_LIKELY(x) LIBC_NAMESPACE::details::expects_bool_condition(x, true)
 #define LIBC_UNLIKELY(x)                                                       \
   LIBC_NAMESPACE::details::expects_bool_condition(x, false)
@@ -33,4 +36,28 @@ LIBC_INLINE constexpr bool expects_bool_condition(T value, T expected) {
 #error "Unhandled compiler"
 #endif
 
+// Defining optimization options for math functions.
+// TODO: Exporting this to public generated headers?
+#define LIBC_MATH_SKIP_ACCURATE_PASS 0x01
+#define LIBC_MATH_SMALL_TABLES 0x02
+#define LIBC_MATH_NO_ERRNO 0x04
+#define LIBC_MATH_NO_EXCEPT 0x08
+#define LIBC_MATH_FAST                                                         \
+  (LIBC_MATH_SKIP_ACCURATE_PASS | LIBC_MATH_SMALL_TABLES |                     \
+   LIBC_MATH_NO_ERRNO | LIBC_MATH_NO_EXCEPT)
+
+#ifndef LIBC_MATH
+#define LIBC_MATH 0
+#else
+
+#if (LIBC_MATH & LIBC_MATH_SKIP_ACCURATE_PASS)
+#define LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+#endif
+
+#if (LIBC_MATH & LIBC_MATH_SMALL_TABLES)
+#define LIBC_MATH_HAS_SMALL_TABLES
+#endif
+
+#endif // LIBC_MATH
+
 #endif // LLVM_LIBC_SRC___SUPPORT_MACROS_OPTIMIZATION_H
diff --git a/src/__support/macros/properties/complex_types.h b/src/__support/macros/properties/complex_types.h
new file mode 100644
index 0000000..3f4a764
--- /dev/null
+++ b/src/__support/macros/properties/complex_types.h
@@ -0,0 +1,25 @@
+//===-- Complex Types support -----------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+// Complex Types detection and support.
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_MACROS_PROPERTIES_CTYPES_H
+#define LLVM_LIBC_SRC___SUPPORT_MACROS_PROPERTIES_CTYPES_H
+
+#include "include/llvm-libc-types/cfloat128.h"
+#include "include/llvm-libc-types/cfloat16.h"
+#include "types.h"
+
+// -- cfloat16 support --------------------------------------------------------
+// LIBC_TYPES_HAS_CFLOAT16 and 'cfloat16' type is provided by
+// "include/llvm-libc-types/cfloat16.h"
+
+// -- cfloat128 support -------------------------------------------------------
+// LIBC_TYPES_HAS_CFLOAT128 and 'cfloat128' type are provided by
+// "include/llvm-libc-types/cfloat128.h"
+
+#endif // LLVM_LIBC_SRC___SUPPORT_MACROS_PROPERTIES_CTYPES_H
diff --git a/src/__support/macros/properties/cpu_features.h b/src/__support/macros/properties/cpu_features.h
index 80d48be..d2cea36 100644
--- a/src/__support/macros/properties/cpu_features.h
+++ b/src/__support/macros/properties/cpu_features.h
@@ -14,6 +14,10 @@
 
 #include "architectures.h"
 
+#if defined(__ARM_FEATURE_FP16_SCALAR_ARITHMETIC)
+#define LIBC_TARGET_CPU_HAS_FULLFP16
+#endif
+
 #if defined(__SSE2__)
 #define LIBC_TARGET_CPU_HAS_SSE2
 #endif
@@ -49,4 +53,8 @@
 #define LIBC_TARGET_CPU_HAS_NEAREST_INT
 #endif
 
+#if defined(LIBC_TARGET_ARCH_IS_AARCH64) || defined(LIBC_TARGET_ARCH_IS_GPU)
+#define LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS
+#endif
+
 #endif // LLVM_LIBC_SRC___SUPPORT_MACROS_PROPERTIES_CPU_FEATURES_H
diff --git a/src/__support/macros/properties/types.h b/src/__support/macros/properties/types.h
index 69ddc91..30c742c 100644
--- a/src/__support/macros/properties/types.h
+++ b/src/__support/macros/properties/types.h
@@ -27,6 +27,8 @@
 #define LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 #elif (LDBL_MANT_DIG == 113)
 #define LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128
+#elif (LDBL_MANT_DIG == 106)
+#define LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE_DOUBLE
 #endif
 
 // int64 / uint64 support
@@ -35,7 +37,7 @@
 #endif // UINT64_MAX
 
 // int128 / uint128 support
-#if defined(__SIZEOF_INT128__)
+#if defined(__SIZEOF_INT128__) && !defined(LIBC_TARGET_OS_IS_WINDOWS)
 #define LIBC_TYPES_HAS_INT128
 #endif // defined(__SIZEOF_INT128__)
 
diff --git a/src/__support/macros/sanitizer.h b/src/__support/macros/sanitizer.h
index baf44f7..c20412e 100644
--- a/src/__support/macros/sanitizer.h
+++ b/src/__support/macros/sanitizer.h
@@ -12,42 +12,28 @@
 #include "src/__support/macros/config.h" //LIBC_HAS_FEATURE
 
 //-----------------------------------------------------------------------------
-// Properties to check the presence or absence or sanitizers
+// Functions to unpoison memory
 //-----------------------------------------------------------------------------
 
-// MemorySanitizer (MSan) is a detector of uninitialized reads. It consists of
-// a compiler instrumentation module and a run-time library. The
-// MEMORY_SANITIZER macro is deprecated but we will continue to honor it for
-// now.
-#ifdef LIBC_HAVE_MEMORY_SANITIZER
-#error "LIBC_HAVE_MEMORY_SANITIZER cannot be directly set."
-#elif defined(MEMORY_SANITIZER) || defined(__SANITIZE_MEMORY__) ||             \
-    (LIBC_HAS_FEATURE(memory_sanitizer) && !defined(__native_client__))
-#define LIBC_HAVE_MEMORY_SANITIZER
+#if LIBC_HAS_FEATURE(address_sanitizer) || defined(__SANITIZE_ADDRESS__)
+#define LIBC_HAS_ADDRESS_SANITIZER
 #endif
 
-// AddressSanitizer (ASan) is a fast memory error detector. The
-// ADDRESS_SANITIZER macro is deprecated but we will continue to honor it for
-// now.
-#ifdef LIBC_HAVE_ADDRESS_SANITIZER
-#error "LIBC_HAVE_ADDRESS_SANITIZER cannot be directly set."
-#elif defined(ADDRESS_SANITIZER) || defined(__SANITIZE_ADDRESS__) ||           \
-    LIBC_HAS_FEATURE(address_sanitizer)
-#define LIBC_HAVE_ADDRESS_SANITIZER
+#if LIBC_HAS_FEATURE(memory_sanitizer)
+#define LIBC_HAS_MEMORY_SANITIZER
 #endif
 
-// HWAddressSanitizer (HWASan) is a fast, low memory overhead error detector.
-#ifdef LIBC_HAVE_HWADDRESS_SANITIZER
-#error "LIBC_HAVE_HWADDRESS_SANITIZER cannot be directly set."
-#elif LIBC_HAS_FEATURE(hwaddress_sanitizer)
-#define LIBC_HAVE_HWADDRESS_SANITIZER
+#if LIBC_HAS_FEATURE(undefined_behavior_sanitizer)
+#define LIBC_HAS_UNDEFINED_BEHAVIOR_SANITIZER
 #endif
 
-//-----------------------------------------------------------------------------
-// Functions to unpoison memory
-//-----------------------------------------------------------------------------
+#if defined(LIBC_HAS_ADDRESS_SANITIZER) ||                                     \
+    defined(LIBC_HAS_MEMORY_SANITIZER) ||                                      \
+    defined(LIBC_HAS_UNDEFINED_BEHAVIOR_SANITIZER)
+#define LIBC_HAS_SANITIZER
+#endif
 
-#if defined(LIBC_HAVE_MEMORY_SANITIZER)
+#ifdef LIBC_HAS_MEMORY_SANITIZER
 // Only perform MSAN unpoison in non-constexpr context.
 #include <sanitizer/msan_interface.h>
 #define MSAN_UNPOISON(addr, size)                                              \
@@ -59,7 +45,7 @@
 #define MSAN_UNPOISON(ptr, size)
 #endif
 
-#ifdef LIBC_HAVE_ADDRESS_SANITIZER
+#ifdef LIBC_HAS_ADDRESS_SANITIZER
 #include <sanitizer/asan_interface.h>
 #define ASAN_POISON_MEMORY_REGION(addr, size)                                  \
   __asan_poison_memory_region((addr), (size))
diff --git a/src/__support/math_extras.h b/src/__support/math_extras.h
index 4bd8719..6f4a006 100644
--- a/src/__support/math_extras.h
+++ b/src/__support/math_extras.h
@@ -14,8 +14,9 @@
 #include "src/__support/CPP/limits.h"      // CHAR_BIT, numeric_limits
 #include "src/__support/CPP/type_traits.h" // is_unsigned_v, is_constant_evaluated
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Create a bitmask with the count right-most bits set to 1, and all other bits
 // set to 0.  Only unsigned types are allowed.
@@ -155,6 +156,6 @@ count_zeros(T value) {
   return cpp::popcount<T>(static_cast<T>(~value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_MATH_EXTRAS_H
diff --git a/src/__support/memory_size.h b/src/__support/memory_size.h
index 491123b..cdd6a10 100644
--- a/src/__support/memory_size.h
+++ b/src/__support/memory_size.h
@@ -13,10 +13,11 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/string/memory_utils/utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 template <class T> LIBC_INLINE bool mul_overflow(T a, T b, T *res) {
 #if __has_builtin(__builtin_mul_overflow)
@@ -85,6 +86,6 @@ public:
   }
 };
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_MEMORY_SIZE_H
diff --git a/src/__support/number_pair.h b/src/__support/number_pair.h
index 2f713fc..f5e8774 100644
--- a/src/__support/number_pair.h
+++ b/src/__support/number_pair.h
@@ -10,16 +10,17 @@
 #define LLVM_LIBC_SRC___SUPPORT_NUMBER_PAIR_H
 
 #include "CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename T> struct NumberPair {
   T lo = T(0);
   T hi = T(0);
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_NUMBER_PAIR_H
diff --git a/src/__support/sign.h b/src/__support/sign.h
index 28cfae4..4a629e4 100644
--- a/src/__support/sign.h
+++ b/src/__support/sign.h
@@ -11,6 +11,8 @@
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE, LIBC_INLINE_VAR
 
+namespace LIBC_NAMESPACE_DECL {
+
 // A type to interact with signed arithmetic types.
 struct Sign {
   LIBC_INLINE constexpr bool is_pos() const { return !is_negative; }
@@ -37,4 +39,5 @@ private:
 LIBC_INLINE_VAR constexpr Sign Sign::NEG = Sign(true);
 LIBC_INLINE_VAR constexpr Sign Sign::POS = Sign(false);
 
+} // namespace LIBC_NAMESPACE_DECL
 #endif // LLVM_LIBC_SRC___SUPPORT_SIGN_H
diff --git a/src/__support/str_to_float.h b/src/__support/str_to_float.h
index fa466ca..80ea334 100644
--- a/src/__support/str_to_float.h
+++ b/src/__support/str_to_float.h
@@ -6,6 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This file is shared with libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
+
 #ifndef LLVM_LIBC_SRC___SUPPORT_STR_TO_FLOAT_H
 #define LLVM_LIBC_SRC___SUPPORT_STR_TO_FLOAT_H
 
@@ -13,27 +19,40 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/string_view.h"
-#include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/FPUtil/dyadic_float.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
 #include "src/__support/detailed_powers_of_ten.h"
 #include "src/__support/high_precision_decimal.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/null_check.h"
+#include "src/__support/macros/optimization.h"
 #include "src/__support/str_to_integer.h"
 #include "src/__support/str_to_num_result.h"
 #include "src/__support/uint128.h"
 #include "src/errno/libc_errno.h" // For ERANGE
 
-namespace LIBC_NAMESPACE {
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 template <class T> struct ExpandedFloat {
   typename fputil::FPBits<T>::StorageType mantissa;
   int32_t exponent;
 };
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 template <class T> struct FloatConvertReturn {
   ExpandedFloat<T> num = {0, 0};
   int error = 0;
@@ -176,7 +195,10 @@ eisel_lemire(ExpandedFloat<T> init_num,
   return output;
 }
 
-#if !defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
+// TODO: Re-enable eisel-lemire for long double is double double once it's
+// properly supported.
+#if !defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64) &&                             \
+    !defined(LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE_DOUBLE)
 template <>
 LIBC_INLINE cpp::optional<ExpandedFloat<long double>>
 eisel_lemire<long double>(ExpandedFloat<long double> init_num,
@@ -184,7 +206,7 @@ eisel_lemire<long double>(ExpandedFloat<long double> init_num,
   using FPBits = typename fputil::FPBits<long double>;
   using StorageType = typename FPBits::StorageType;
 
-  StorageType mantissa = init_num.mantissa;
+  UInt128 mantissa = init_num.mantissa;
   int32_t exp10 = init_num.exponent;
 
   // Exp10 Range
@@ -203,7 +225,8 @@ eisel_lemire<long double>(ExpandedFloat<long double> init_num,
   }
 
   // Normalization
-  uint32_t clz = cpp::countl_zero<StorageType>(mantissa);
+  uint32_t clz = cpp::countl_zero(mantissa) -
+                 ((sizeof(UInt128) - sizeof(StorageType)) * CHAR_BIT);
   mantissa <<= clz;
 
   int32_t exp2 =
@@ -254,9 +277,8 @@ eisel_lemire<long double>(ExpandedFloat<long double> init_num,
   // Shifting to 65 bits for 80 bit floats and 113 bits for 128 bit floats
   uint32_t msb =
       static_cast<uint32_t>(final_approx_upper >> (FPBits::STORAGE_LEN - 1));
-  StorageType final_mantissa =
-      final_approx_upper >>
-      (msb + FPBits::STORAGE_LEN - (FPBits::FRACTION_LEN + 3));
+  UInt128 final_mantissa = final_approx_upper >> (msb + FPBits::STORAGE_LEN -
+                                                  (FPBits::FRACTION_LEN + 3));
   exp2 -= static_cast<uint32_t>(1 ^ msb); // same as !msb
 
   if (round == RoundDirection::Nearest) {
@@ -293,11 +315,12 @@ eisel_lemire<long double>(ExpandedFloat<long double> init_num,
   }
 
   ExpandedFloat<long double> output;
-  output.mantissa = final_mantissa;
+  output.mantissa = static_cast<StorageType>(final_mantissa);
   output.exponent = exp2;
   return output;
 }
-#endif // !defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
+#endif // !defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64) &&
+       // !defined(LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE_DOUBLE)
 
 // The nth item in POWERS_OF_TWO represents the greatest power of two less than
 // 10^n. This tells us how much we can safely shift without overshooting.
@@ -499,6 +522,18 @@ public:
   static constexpr long double MAX_EXACT_INT =
       10384593717069655257060992658440191.0L;
 };
+#elif defined(LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE_DOUBLE)
+// TODO: Add proper double double type support here, currently using constants
+// for double since it should be safe.
+template <> class ClingerConsts<long double> {
+public:
+  static constexpr double POWERS_OF_TEN_ARRAY[] = {
+      1e0,  1e1,  1e2,  1e3,  1e4,  1e5,  1e6,  1e7,  1e8,  1e9,  1e10, 1e11,
+      1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22};
+  static constexpr int32_t EXACT_POWERS_OF_TEN = 22;
+  static constexpr int32_t DIGITS_IN_MANTISSA = 15;
+  static constexpr double MAX_EXACT_INT = 9007199254740991.0;
+};
 #else
 #error "Unknown long double type"
 #endif
@@ -523,11 +558,10 @@ clinger_fast_path(ExpandedFloat<T> init_num,
 
   FPBits result;
   T float_mantissa;
-  if constexpr (cpp::is_same_v<StorageType, UInt<128>>) {
-    float_mantissa = static_cast<T>(fputil::DyadicFloat<128>(
-        Sign::POS, 0,
-        fputil::DyadicFloat<128>::MantissaType(
-            {uint64_t(mantissa), uint64_t(mantissa >> 64)})));
+  if constexpr (is_big_int_v<StorageType> || sizeof(T) > sizeof(uint64_t)) {
+    float_mantissa =
+        (static_cast<T>(uint64_t(mantissa >> 64)) * static_cast<T>(0x1.0p64)) +
+        static_cast<T>(uint64_t(mantissa));
   } else {
     float_mantissa = static_cast<T>(mantissa);
   }
@@ -591,7 +625,7 @@ clinger_fast_path(ExpandedFloat<T> init_num,
   }
 
   ExpandedFloat<T> output;
-  output.mantissa = result.get_mantissa();
+  output.mantissa = result.get_explicit_mantissa();
   output.exponent = result.get_biased_exponent();
   return output;
 }
@@ -635,6 +669,11 @@ template <> LIBC_INLINE constexpr int32_t get_lower_bound<double>() {
   return -(309 + 15 + 20);
 }
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 // Takes a mantissa and base 10 exponent and converts it into its closest
 // floating point type T equivalient. First we try the Eisel-Lemire algorithm,
 // then if that fails then we fall back to a more accurate algorithm for
@@ -714,6 +753,11 @@ LIBC_INLINE FloatConvertReturn<T> decimal_exp_to_float(
   return output;
 }
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 // Takes a mantissa and base 2 exponent and converts it into its closest
 // floating point type T equivalient. Since the exponent is already in the right
 // form, this is mostly just shifting and rounding. This is used for hexadecimal
@@ -1159,13 +1203,11 @@ LIBC_INLINE StrToNumResult<T> strtofloatingpoint(const char *__restrict src) {
       index += 3;
       StorageType nan_mantissa = 0;
       // this handles the case of `NaN(n-character-sequence)`, where the
-      // n-character-sequence is made of 0 or more letters and numbers in any
-      // order.
+      // n-character-sequence is made of 0 or more letters, numbers, or
+      // underscore characters in any order.
       if (src[index] == '(') {
         size_t left_paren = index;
         ++index;
-        // Apparently it's common for underscores to also be accepted. No idea
-        // why, but it's causing fuzz failures.
         while (isalnum(src[index]) || src[index] == '_')
           ++index;
         if (src[index] == ')') {
@@ -1210,6 +1252,8 @@ template <class T> LIBC_INLINE StrToNumResult<T> strtonan(const char *arg) {
   using FPBits = typename fputil::FPBits<T>;
   using StorageType = typename FPBits::StorageType;
 
+  LIBC_CRASH_ON_NULLPTR(arg);
+
   FPBits result;
   int error = 0;
   StorageType nan_mantissa = 0;
@@ -1226,6 +1270,6 @@ template <class T> LIBC_INLINE StrToNumResult<T> strtonan(const char *arg) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STR_TO_FLOAT_H
diff --git a/src/__support/str_to_integer.h b/src/__support/str_to_integer.h
index 6db851a..86611f9 100644
--- a/src/__support/str_to_integer.h
+++ b/src/__support/str_to_integer.h
@@ -6,18 +6,27 @@
 //
 //===----------------------------------------------------------------------===//
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This file is shared with libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
+
 #ifndef LLVM_LIBC_SRC___SUPPORT_STR_TO_INTEGER_H
 #define LLVM_LIBC_SRC___SUPPORT_STR_TO_INTEGER_H
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/CPP/type_traits/make_unsigned.h"
+#include "src/__support/big_int.h"
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_num_result.h"
 #include "src/__support/uint128.h"
 #include "src/errno/libc_errno.h" // For ERANGE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // Returns a pointer to the first character in src that is not a whitespace
@@ -70,15 +79,18 @@ LIBC_INLINE int infer_base(const char *__restrict src, size_t src_len) {
   return 10;
 }
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 // Takes a pointer to a string and the base to convert to. This function is used
 // as the backend for all of the string to int functions.
 template <class T>
 LIBC_INLINE StrToNumResult<T>
 strtointeger(const char *__restrict src, int base,
              const size_t src_len = cpp::numeric_limits<size_t>::max()) {
-  using ResultType = typename cpp::conditional_t<(cpp::is_same_v<T, UInt128> ||
-                                                  cpp::is_same_v<T, Int128>),
-                                                 UInt128, unsigned long long>;
+  using ResultType = make_integral_or_big_int_unsigned_t<T>;
 
   ResultType result = 0;
 
@@ -114,7 +126,8 @@ strtointeger(const char *__restrict src, int base,
                    : cpp::numeric_limits<T>::max();
   ResultType const abs_max =
       (is_positive ? cpp::numeric_limits<T>::max() : NEGATIVE_MAX);
-  ResultType const abs_max_div_by_base = abs_max / base;
+  ResultType const abs_max_div_by_base =
+      static_cast<ResultType>(abs_max / base);
 
   while (src_cur < src_len && isalnum(src[src_cur])) {
     int cur_digit = b36_char_to_int(src[src_cur]);
@@ -136,13 +149,13 @@ strtointeger(const char *__restrict src, int base,
       result = abs_max;
       error_val = ERANGE;
     } else {
-      result = result * base;
+      result = static_cast<ResultType>(result * base);
     }
     if (result > abs_max - cur_digit) {
       result = abs_max;
       error_val = ERANGE;
     } else {
-      result = result + cur_digit;
+      result = static_cast<ResultType>(result + cur_digit);
     }
   }
 
@@ -155,15 +168,10 @@ strtointeger(const char *__restrict src, int base,
       return {cpp::numeric_limits<T>::min(), str_len, error_val};
   }
 
-  return {
-      is_positive
-          ? static_cast<T>(result)
-          : static_cast<T>(
-                -static_cast<make_integral_or_big_int_unsigned_t<T>>(result)),
-      str_len, error_val};
+  return {static_cast<T>(is_positive ? result : -result), str_len, error_val};
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STR_TO_INTEGER_H
diff --git a/src/__support/str_to_num_result.h b/src/__support/str_to_num_result.h
index b32fbde..48c363c 100644
--- a/src/__support/str_to_num_result.h
+++ b/src/__support/str_to_num_result.h
@@ -6,15 +6,27 @@
 //
 //===----------------------------------------------------------------------===//
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This file is shared with libc++. You should also be careful when adding
+// dependencies to this file, since it needs to build for all libc++ targets.
+// -----------------------------------------------------------------------------
+
 #ifndef LLVM_LIBC_SRC___SUPPORT_STR_TO_NUM_RESULT_H
 #define LLVM_LIBC_SRC___SUPPORT_STR_TO_NUM_RESULT_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
+// -----------------------------------------------------------------------------
+//                               **** WARNING ****
+// This interface is shared with libc++, if you change this interface you need
+// to update it in both libc and libc++.
+// -----------------------------------------------------------------------------
 template <typename T> struct StrToNumResult {
   T value;
   int error;
@@ -31,6 +43,6 @@ template <typename T> struct StrToNumResult {
 
   LIBC_INLINE constexpr operator T() { return value; }
 };
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_STR_TO_NUM_RESULT_H
diff --git a/src/__support/threads/CndVar.h b/src/__support/threads/CndVar.h
index 55f6e02..e42fa14 100644
--- a/src/__support/threads/CndVar.h
+++ b/src/__support/threads/CndVar.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC___SUPPORT_SRC_THREADS_LINUX_CNDVAR_H
 #define LLVM_LIBC___SUPPORT_SRC_THREADS_LINUX_CNDVAR_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/futex_utils.h" // Futex
 #include "src/__support/threads/linux/raw_mutex.h"   // RawMutex
 #include "src/__support/threads/mutex.h"             // Mutex
 
 #include <stdint.h> // uint32_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 class CndVar {
   enum CndWaiterStatus : uint32_t {
@@ -49,6 +50,6 @@ public:
   void broadcast();
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_CNDVAR_H
diff --git a/src/__support/threads/callonce.h b/src/__support/threads/callonce.h
index b3d6813..5392722 100644
--- a/src/__support/threads/callonce.h
+++ b/src/__support/threads/callonce.h
@@ -9,13 +9,33 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_CALLONCE_H
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_CALLONCE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_LIKELY
 
-struct CallOnceFlag;
+// Plaform specific routines, provides:
+// - OnceFlag definition
+// - callonce_impl::callonce_fastpath for fast path check
+// - callonce_impl::callonce_slowpath for slow path execution
+#ifdef __linux__
+#include "src/__support/threads/linux/callonce.h"
+#else
+#error "callonce is not supported on this platform"
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+// Common definitions
 using CallOnceCallback = void(void);
+namespace callonce_impl {
+int callonce_slowpath(CallOnceFlag *flag, CallOnceCallback *callback);
+} // namespace callonce_impl
 
-int callonce(CallOnceFlag *flag, CallOnceCallback *callback);
+LIBC_INLINE int callonce(CallOnceFlag *flag, CallOnceCallback *callback) {
+  if (LIBC_LIKELY(callonce_impl::callonce_fastpath(flag)))
+    return 0;
 
-} // namespace LIBC_NAMESPACE
+  return callonce_impl::callonce_slowpath(flag, callback);
+}
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_CALLONCE_H
diff --git a/src/__support/threads/fork_callbacks.cpp b/src/__support/threads/fork_callbacks.cpp
index 385a2bc..b050b17 100644
--- a/src/__support/threads/fork_callbacks.cpp
+++ b/src/__support/threads/fork_callbacks.cpp
@@ -9,11 +9,12 @@
 #include "fork_callbacks.h"
 
 #include "src/__support/CPP/mutex.h" // lock_guard
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <stddef.h> // For size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -91,4 +92,4 @@ void invoke_prepare_callbacks() { cb_manager.invoke_prepare(); }
 
 void invoke_parent_callbacks() { cb_manager.invoke_parent(); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/threads/fork_callbacks.h b/src/__support/threads/fork_callbacks.h
index 57a4f82..2a06a4a 100644
--- a/src/__support/threads/fork_callbacks.h
+++ b/src/__support/threads/fork_callbacks.h
@@ -9,7 +9,9 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_FORK_CALLBACKS_H
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_FORK_CALLBACKS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 using ForkCallback = void(void);
 
@@ -19,6 +21,6 @@ void invoke_prepare_callbacks();
 void invoke_parent_callbacks();
 void invoke_child_callbacks();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_FORK_CALLBACKS_H
diff --git a/src/__support/threads/gpu/mutex.h b/src/__support/threads/gpu/mutex.h
index 9554083..c8c484e 100644
--- a/src/__support/threads/gpu/mutex.h
+++ b/src/__support/threads/gpu/mutex.h
@@ -10,9 +10,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_GPU_MUTEX_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex_common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 /// Implementation of a simple passthrough mutex which guards nothing. A
 /// complete Mutex locks in general cannot be implemented on the GPU. We simply
@@ -26,6 +27,6 @@ struct Mutex {
   LIBC_INLINE MutexError reset() { return MutexError::NONE; }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_GPU_MUTEX_H
diff --git a/src/__support/threads/identifier.h b/src/__support/threads/identifier.h
new file mode 100644
index 0000000..a570abf
--- /dev/null
+++ b/src/__support/threads/identifier.h
@@ -0,0 +1,50 @@
+//===--- Thread Identifier Header --------------------------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_IDENTIFIER_H
+#define LLVM_LIBC_SRC___SUPPORT_THREADS_IDENTIFIER_H
+
+#ifdef LIBC_FULL_BUILD
+#include "src/__support/threads/thread.h"
+#endif // LIBC_FULL_BUILD
+
+#include "hdr/types/pid_t.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/macros/optimization.h"
+#include <sys/syscall.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+LIBC_INLINE pid_t *get_tid_cache() {
+#ifdef LIBC_FULL_BUILD
+  return &self.attrib->tid;
+#else
+  // in non-full build mode, we do not control the fork routine. Therefore,
+  // we do not cache tid at all.
+  return nullptr;
+#endif
+}
+
+LIBC_INLINE pid_t gettid() {
+  pid_t *cache = get_tid_cache();
+  if (LIBC_UNLIKELY(!cache || *cache <= 0))
+    return syscall_impl<pid_t>(SYS_gettid);
+  return *cache;
+}
+
+LIBC_INLINE void force_set_tid(pid_t tid) {
+  pid_t *cache = get_tid_cache();
+  if (cache)
+    *cache = tid;
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_THREADS_IDENTIFIER_H
diff --git a/src/__support/threads/linux/CndVar.cpp b/src/__support/threads/linux/CndVar.cpp
index 0312532..be74c18 100644
--- a/src/__support/threads/linux/CndVar.cpp
+++ b/src/__support/threads/linux/CndVar.cpp
@@ -9,13 +9,14 @@
 #include "src/__support/threads/CndVar.h"
 #include "src/__support/CPP/mutex.h"
 #include "src/__support/OSUtil/syscall.h"           // syscall_impl
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/futex_word.h" // FutexWordType
 #include "src/__support/threads/linux/raw_mutex.h"  // RawMutex
 #include "src/__support/threads/mutex.h"            // Mutex
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int CndVar::wait(Mutex *m) {
   // The goal is to perform "unlock |m| and wait" in an
@@ -102,4 +103,4 @@ void CndVar::broadcast() {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/threads/linux/callonce.cpp b/src/__support/threads/linux/callonce.cpp
index b48a514..c6e5f2a 100644
--- a/src/__support/threads/linux/callonce.cpp
+++ b/src/__support/threads/linux/callonce.cpp
@@ -7,27 +7,17 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/threads/callonce.h"
-#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/threads/linux/callonce.h"
 #include "src/__support/threads/linux/futex_utils.h"
 
-namespace LIBC_NAMESPACE {
-
-static constexpr FutexWordType NOT_CALLED = 0x0;
-static constexpr FutexWordType START = 0x11;
-static constexpr FutexWordType WAITING = 0x22;
-static constexpr FutexWordType FINISH = 0x33;
-
-int callonce(CallOnceFlag *flag, CallOnceCallback *func) {
+namespace LIBC_NAMESPACE_DECL {
+namespace callonce_impl {
+int callonce_slowpath(CallOnceFlag *flag, CallOnceCallback *func) {
   auto *futex_word = reinterpret_cast<Futex *>(flag);
 
   FutexWordType not_called = NOT_CALLED;
 
-  // Avoid cmpxchg operation if the function has already been called.
-  // The destination operand of cmpxchg may receive a write cycle without
-  // regard to the result of the comparison
-  if (LIBC_LIKELY(futex_word->load(cpp::MemoryOrder::RELAXED) == FINISH))
-    return 0;
-
   // The call_once call can return only after the called function |func|
   // returns. So, we use futexes to synchronize calls with the same flag value.
   if (futex_word->compare_exchange_strong(not_called, START)) {
@@ -46,5 +36,5 @@ int callonce(CallOnceFlag *flag, CallOnceCallback *func) {
 
   return 0;
 }
-
-} // namespace LIBC_NAMESPACE
+} // namespace callonce_impl
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/threads/linux/callonce.h b/src/__support/threads/linux/callonce.h
new file mode 100644
index 0000000..b3ea3a5
--- /dev/null
+++ b/src/__support/threads/linux/callonce.h
@@ -0,0 +1,32 @@
+//===-- Linux callonce fastpath -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_CALLONCE_H
+#define LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_CALLONCE_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/threads/linux/futex_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+using CallOnceFlag = Futex;
+
+namespace callonce_impl {
+static constexpr FutexWordType NOT_CALLED = 0x0;
+static constexpr FutexWordType START = 0x11;
+static constexpr FutexWordType WAITING = 0x22;
+static constexpr FutexWordType FINISH = 0x33;
+
+// Avoid cmpxchg operation if the function has already been called.
+// The destination operand of cmpxchg may receive a write cycle without
+// regard to the result of the comparison.
+LIBC_INLINE bool callonce_fastpath(CallOnceFlag *flag) {
+  return flag->load(cpp::MemoryOrder::RELAXED) == FINISH;
+}
+} // namespace callonce_impl
+
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_CALLONCE_H
diff --git a/src/__support/threads/linux/futex_utils.h b/src/__support/threads/linux/futex_utils.h
index e40ade8..943a99a 100644
--- a/src/__support/threads/linux/futex_utils.h
+++ b/src/__support/threads/linux/futex_utils.h
@@ -14,12 +14,13 @@
 #include "src/__support/CPP/optional.h"
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/futex_word.h"
 #include "src/__support/time/linux/abs_timeout.h"
 #include <linux/errno.h>
 #include <linux/futex.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 class Futex : public cpp::Atomic<FutexWordType> {
 public:
   using Timeout = internal::AbsTimeout;
@@ -82,6 +83,6 @@ public:
 
 static_assert(__is_standard_layout(Futex),
               "Futex must be a standard layout type.");
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_FUTEX_UTILS_H
diff --git a/src/__support/threads/linux/futex_word.h b/src/__support/threads/linux/futex_word.h
index acdd33b..a5a6a0c 100644
--- a/src/__support/threads/linux/futex_word.h
+++ b/src/__support/threads/linux/futex_word.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_FUTEX_WORD_H
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_FUTEX_WORD_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 #include <sys/syscall.h>
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Futexes are 32 bits in size on all platforms, including 64-bit platforms.
 using FutexWordType = uint32_t;
@@ -24,6 +25,6 @@ constexpr auto FUTEX_SYSCALL_ID = SYS_futex_time64;
 #error "futex and futex_time64 syscalls not available."
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_FUTEX_WORD_H
diff --git a/src/__support/threads/linux/mutex.h b/src/__support/threads/linux/mutex.h
index 79506d7..0c4b1ae 100644
--- a/src/__support/threads/linux/mutex.h
+++ b/src/__support/threads/linux/mutex.h
@@ -12,11 +12,12 @@
 #include "hdr/types/pid_t.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/futex_utils.h"
 #include "src/__support/threads/linux/raw_mutex.h"
 #include "src/__support/threads/mutex_common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: support shared/recursive/robust mutexes.
 class Mutex final : private RawMutex {
@@ -84,6 +85,6 @@ public:
   }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_MUTEX_H
diff --git a/src/__support/threads/linux/raw_mutex.h b/src/__support/threads/linux/raw_mutex.h
index 75bd4bd..47f0aa7 100644
--- a/src/__support/threads/linux/raw_mutex.h
+++ b/src/__support/threads/linux/raw_mutex.h
@@ -12,6 +12,8 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
 #include "src/__support/threads/linux/futex_utils.h"
 #include "src/__support/threads/linux/futex_word.h"
 #include "src/__support/threads/sleep.h"
@@ -19,7 +21,6 @@
 
 #ifndef LIBC_COPT_TIMEOUT_ENSURE_MONOTONICITY
 #define LIBC_COPT_TIMEOUT_ENSURE_MONOTONICITY 1
-#warning "LIBC_COPT_TIMEOUT_ENSURE_MONOTONICITY is not defined, defaulting to 1"
 #endif
 
 #if LIBC_COPT_TIMEOUT_ENSURE_MONOTONICITY
@@ -28,11 +29,9 @@
 
 #ifndef LIBC_COPT_RAW_MUTEX_DEFAULT_SPIN_COUNT
 #define LIBC_COPT_RAW_MUTEX_DEFAULT_SPIN_COUNT 100
-#warning                                                                       \
-    "LIBC_COPT_RAW_MUTEX_DEFAULT_SPIN_COUNT is not defined, defaulting to 100"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 // Lock is a simple timable lock for internal usage.
 // This is separated from Mutex because this one does not need to consider
 // robustness and reentrancy. Also, this one has spin optimization for shorter
@@ -125,6 +124,6 @@ public:
   LIBC_INLINE Futex &get_raw_futex() { return futex; }
   LIBC_INLINE void reset() { futex = UNLOCKED; }
 };
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_LINUX_RAW_MUTEX_H
diff --git a/src/__support/threads/linux/rwlock.h b/src/__support/threads/linux/rwlock.h
index 201fe92..57fcc7b 100644
--- a/src/__support/threads/linux/rwlock.h
+++ b/src/__support/threads/linux/rwlock.h
@@ -17,7 +17,9 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
+#include "src/__support/threads/identifier.h"
 #include "src/__support/threads/linux/futex_utils.h"
 #include "src/__support/threads/linux/futex_word.h"
 #include "src/__support/threads/linux/raw_mutex.h"
@@ -36,7 +38,7 @@
 #include "src/__support/time/linux/monotonicity.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 // Forward declaration of the RwLock class.
 class RwLock;
 // A namespace to rwlock specific utilities.
@@ -335,8 +337,6 @@ private:
   LIBC_INLINE Role get_preference() const {
     return static_cast<Role>(preference);
   }
-  // TODO: use cached thread id once implemented.
-  LIBC_INLINE static pid_t gettid() { return syscall_impl<pid_t>(SYS_gettid); }
 
   template <Role role> LIBC_INLINE LockResult try_lock(RwState &old) {
     if constexpr (role == Role::Reader) {
@@ -358,7 +358,7 @@ private:
         if (LIBC_LIKELY(old.compare_exchange_weak_with(
                 state, old.set_writer_bit(), cpp::MemoryOrder::ACQUIRE,
                 cpp::MemoryOrder::RELAXED))) {
-          writer_tid.store(gettid(), cpp::MemoryOrder::RELAXED);
+          writer_tid.store(internal::gettid(), cpp::MemoryOrder::RELAXED);
           return LockResult::Success;
         }
         // Notice that old is updated by the compare_exchange_weak_with
@@ -393,7 +393,7 @@ private:
             unsigned spin_count = LIBC_COPT_RWLOCK_DEFAULT_SPIN_COUNT) {
     // Phase 1: deadlock detection.
     // A deadlock happens if this is a RAW/WAW lock in the same thread.
-    if (writer_tid.load(cpp::MemoryOrder::RELAXED) == gettid())
+    if (writer_tid.load(cpp::MemoryOrder::RELAXED) == internal::gettid())
       return LockResult::Deadlock;
 
 #if LIBC_COPT_TIMEOUT_ENSURE_MONOTONICITY
@@ -519,7 +519,7 @@ public:
     if (old.has_active_writer()) {
       // The lock is held by a writer.
       // Check if we are the owner of the lock.
-      if (writer_tid.load(cpp::MemoryOrder::RELAXED) != gettid())
+      if (writer_tid.load(cpp::MemoryOrder::RELAXED) != internal::gettid())
         return LockResult::PermissionDenied;
       // clear writer tid.
       writer_tid.store(0, cpp::MemoryOrder::RELAXED);
@@ -553,6 +553,6 @@ public:
     return LockResult::Success;
   }
 };
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SUPPORT_THREADS_LINUX_RWLOCK_H
diff --git a/src/__support/threads/linux/thread.cpp b/src/__support/threads/linux/thread.cpp
index 1d986ff..c531d74 100644
--- a/src/__support/threads/linux/thread.cpp
+++ b/src/__support/threads/linux/thread.cpp
@@ -7,13 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/threads/thread.h"
-#include "config/linux/app.h"
+#include "config/app.h"
 #include "src/__support/CPP/atomic.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/CPP/stringstream.h"
 #include "src/__support/OSUtil/syscall.h" // For syscall functions.
 #include "src/__support/common.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/futex_utils.h" // For FutexWordType
 #include "src/errno/libc_errno.h"                    // For error macros
 
@@ -21,7 +22,7 @@
 #include <arm_acle.h>
 #endif
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <linux/param.h> // For EXEC_PAGESIZE.
 #include <linux/prctl.h> // For PR_SET_NAME
 #include <linux/sched.h> // For CLONE_* flags.
@@ -29,7 +30,7 @@
 #include <sys/mman.h>    // For PROT_* and MAP_* definitions.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #ifdef SYS_mmap2
 static constexpr long MMAP_SYSCALL_NUMBER = SYS_mmap2;
@@ -517,4 +518,4 @@ void thread_exit(ThreadReturnValue retval, ThreadStyle style) {
   __builtin_unreachable();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/threads/mutex_common.h b/src/__support/threads/mutex_common.h
index ad8d002..9913f69 100644
--- a/src/__support/threads/mutex_common.h
+++ b/src/__support/threads/mutex_common.h
@@ -9,7 +9,9 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_MUTEX_COMMON_H
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_MUTEX_COMMON_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 enum class MutexError : int {
   NONE,
@@ -19,6 +21,6 @@ enum class MutexError : int {
   BAD_LOCK_STATE,
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_MUTEX_COMMON_H
diff --git a/src/__support/threads/sleep.h b/src/__support/threads/sleep.h
index 9a2dff5..7772833 100644
--- a/src/__support/threads/sleep.h
+++ b/src/__support/threads/sleep.h
@@ -10,8 +10,9 @@
 #define LLVM_LIBC_SRC___SUPPORT_THREADS_SLEEP_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 /// Suspend the thread briefly to assist the thread scheduler during busy loops.
 LIBC_INLINE void sleep_briefly() {
@@ -22,13 +23,15 @@ LIBC_INLINE void sleep_briefly() {
   __builtin_amdgcn_s_sleep(2);
 #elif defined(LIBC_TARGET_ARCH_IS_X86)
   __builtin_ia32_pause();
-#elif defined(LIBC_TARGET_ARCH_IS_AARCH64)
+#elif defined(LIBC_TARGET_ARCH_IS_AARCH64) && __has_builtin(__builtin_arm_isb)
   __builtin_arm_isb(0xf);
+#elif defined(LIBC_TARGET_ARCH_IS_AARCH64)
+  asm volatile("isb\n" ::: "memory");
 #else
   // Simply do nothing if sleeping isn't supported on this platform.
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_SLEEP_H
diff --git a/src/__support/threads/spin_lock.h b/src/__support/threads/spin_lock.h
new file mode 100644
index 0000000..e176ad9
--- /dev/null
+++ b/src/__support/threads/spin_lock.h
@@ -0,0 +1,65 @@
+//===-- TTAS Spin Lock ----------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_THREADS_SPIN_LOCK_H
+#define LLVM_LIBC_SRC___SUPPORT_THREADS_SPIN_LOCK_H
+
+#include "src/__support/CPP/atomic.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/threads/sleep.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+class SpinLock {
+  cpp::Atomic<unsigned char> flag;
+
+public:
+  LIBC_INLINE constexpr SpinLock() : flag{0} {}
+  LIBC_INLINE bool try_lock() {
+    return !flag.exchange(1u, cpp::MemoryOrder::ACQUIRE);
+  }
+  LIBC_INLINE void lock() {
+    // clang-format off
+    // For normal TTAS, this compiles to the following on armv9a and x86_64:
+    //         mov     w8, #1            |          .LBB0_1:
+    // .LBB0_1:                          |                  mov     al, 1
+    //         swpab   w8, w9, [x0]      |                  xchg    byte ptr [rdi], al
+    //         tbnz    w9, #0, .LBB0_3   |                  test    al, 1
+    //         b       .LBB0_4           |                  jne     .LBB0_3
+    // .LBB0_2:                          |                  jmp     .LBB0_4
+    //         isb                       |         .LBB0_2:
+    // .LBB0_3:                          |                  pause
+    //         ldrb    w9, [x0]          |         .LBB0_3:       
+    //         tbnz    w9, #0, .LBB0_2   |                  movzx   eax, byte ptr [rdi]
+    //         b       .LBB0_1           |                  test    al, 1
+    // .LBB0_4:                          |                  jne     .LBB0_2
+    //         ret                       |                  jmp     .LBB0_1
+    //                                   |          .LBB0_4:
+    //                                   |                  ret
+    // clang-format on
+    // Notice that inside the busy loop .LBB0_2 and .LBB0_3, only instructions
+    // with load semantics are used. swpab/xchg is only issued in outer loop
+    // .LBB0_1. This is useful to avoid extra write traffic. The cache
+    // coherence guarantees "write propagation", so even if the inner loop only
+    // reads with relaxed ordering, the thread will evetually see the write.
+    while (!try_lock())
+      while (flag.load(cpp::MemoryOrder::RELAXED))
+        sleep_briefly();
+  }
+  LIBC_INLINE void unlock() { flag.store(0u, cpp::MemoryOrder::RELEASE); }
+  LIBC_INLINE bool is_locked() { return flag.load(cpp::MemoryOrder::ACQUIRE); }
+  LIBC_INLINE bool is_invalid() {
+    return flag.load(cpp::MemoryOrder::ACQUIRE) > 1;
+  }
+  // poison the lock
+  LIBC_INLINE ~SpinLock() { flag.store(0xffu, cpp::MemoryOrder::RELEASE); }
+};
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_THREADS_SPIN_LOCK_H
diff --git a/src/__support/threads/thread.cpp b/src/__support/threads/thread.cpp
index d7bedb8..dad4f75 100644
--- a/src/__support/threads/thread.cpp
+++ b/src/__support/threads/thread.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/threads/thread.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include "src/__support/CPP/array.h"
@@ -15,10 +16,7 @@
 #include "src/__support/fixedvector.h"
 #include "src/__support/macros/attributes.h"
 
-namespace LIBC_NAMESPACE {
-
-LIBC_THREAD_LOCAL Thread self;
-
+namespace LIBC_NAMESPACE_DECL {
 namespace {
 
 using AtExitCallback = void(void *);
@@ -188,4 +186,4 @@ void *get_tss_value(unsigned int key) {
   return u.payload;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/threads/thread.h b/src/__support/threads/thread.h
index acfe338..f2b1f6b 100644
--- a/src/__support/threads/thread.h
+++ b/src/__support/threads/thread.h
@@ -14,14 +14,16 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/CPP/stringstream.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
+// TODO: fix this unguarded linux dep
 #include <linux/param.h> // for exec_pagesize.
 
 #include <stddef.h> // For size_t
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using ThreadRunnerPosix = void *(void *);
 using ThreadRunnerStdc = int(void *);
@@ -43,6 +45,9 @@ union ThreadReturnValue {
      defined(LIBC_TARGET_ARCH_IS_X86_64) ||                                    \
      defined(LIBC_TARGET_ARCH_IS_ANY_RISCV))
 constexpr unsigned int STACK_ALIGNMENT = 16;
+#elif defined(LIBC_TARGET_ARCH_IS_ARM)
+// See Section 6.2.1.2 Stack constraints at a public interface of AAPCS32.
+constexpr unsigned int STACK_ALIGNMENT = 8;
 #endif
 // TODO: Provide stack alignment requirements for other architectures.
 
@@ -93,11 +98,11 @@ struct alignas(STACK_ALIGNMENT) ThreadAttributes {
   //          exits. It will clean up the thread resources once the thread
   //          exits.
   cpp::Atomic<uint32_t> detach_state;
-  void *stack;                  // Pointer to the thread stack
-  unsigned long long stacksize; // Size of the stack
-  unsigned long long guardsize; // Guard size on stack
-  uintptr_t tls;                // Address to the thread TLS memory
-  uintptr_t tls_size;           // The size of area pointed to by |tls|.
+  void *stack;               // Pointer to the thread stack
+  size_t stacksize;          // Size of the stack
+  size_t guardsize;          // Guard size on stack
+  uintptr_t tls;             // Address to the thread TLS memory
+  uintptr_t tls_size;        // The size of area pointed to by |tls|.
   unsigned char owned_stack; // Indicates if the thread owns this stack memory
   int tid;
   ThreadStyle style;
@@ -226,7 +231,7 @@ struct Thread {
   int get_name(cpp::StringStream &name) const;
 };
 
-extern LIBC_THREAD_LOCAL Thread self;
+LIBC_INLINE_VAR LIBC_THREAD_LOCAL Thread self;
 
 // Platforms should implement this function.
 [[noreturn]] void thread_exit(ThreadReturnValue retval, ThreadStyle style);
@@ -247,6 +252,6 @@ void call_atexit_callbacks(ThreadAttributes *attrib);
 
 } // namespace internal
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_THREADS_THREAD_H
diff --git a/src/__support/time/linux/abs_timeout.h b/src/__support/time/linux/abs_timeout.h
index 0097f8a..37e6026 100644
--- a/src/__support/time/linux/abs_timeout.h
+++ b/src/__support/time/linux/abs_timeout.h
@@ -12,9 +12,10 @@
 #include "hdr/time_macros.h"
 #include "hdr/types/struct_timespec.h"
 #include "src/__support/CPP/expected.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/units.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 // We use AbsTimeout to remind ourselves that the timeout is an absolute time.
 // This is a simple wrapper around the timespec struct that also keeps track of
@@ -44,6 +45,6 @@ public:
   }
 };
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_ABS_TIMEOUT_H
diff --git a/src/__support/time/linux/clock_conversion.h b/src/__support/time/linux/clock_conversion.h
index 4a7c8ff..7a52873 100644
--- a/src/__support/time/linux/clock_conversion.h
+++ b/src/__support/time/linux/clock_conversion.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_CONVERSION_H
 #define LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_CONVERSION_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/clock_gettime.h"
 #include "src/__support/time/units.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 LIBC_INLINE timespec convert_clock(timespec input, clockid_t from,
@@ -37,6 +38,6 @@ LIBC_INLINE timespec convert_clock(timespec input, clockid_t from,
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_CONVERSION_H
diff --git a/src/__support/time/linux/clock_gettime.cpp b/src/__support/time/linux/clock_gettime.cpp
new file mode 100644
index 0000000..3a0eca4
--- /dev/null
+++ b/src/__support/time/linux/clock_gettime.cpp
@@ -0,0 +1,62 @@
+//===--- clock_gettime linux implementation ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/time/linux/clock_gettime.h"
+#include "hdr/types/clockid_t.h"
+#include "hdr/types/struct_timespec.h"
+#include "src/__support/OSUtil/linux/vdso.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/common.h"
+#include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
+#include <sys/syscall.h>
+
+#if defined(SYS_clock_gettime64)
+#include <linux/time_types.h>
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts) {
+  using namespace vdso;
+  int ret;
+#if defined(SYS_clock_gettime)
+  TypedSymbol<VDSOSym::ClockGetTime> clock_gettime;
+  if (LIBC_LIKELY(clock_gettime != nullptr))
+    ret = clock_gettime(clockid, ts);
+  else
+    ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_clock_gettime,
+                                            static_cast<long>(clockid),
+                                            reinterpret_cast<long>(ts));
+#elif defined(SYS_clock_gettime64)
+  static_assert(
+      sizeof(time_t) == sizeof(int64_t),
+      "SYS_clock_gettime64 requires struct timespec with 64-bit members.");
+
+  TypedSymbol<VDSOSym::ClockGetTime64> clock_gettime64;
+  __kernel_timespec ts64{};
+  if (LIBC_LIKELY(clock_gettime64 != nullptr))
+    ret = clock_gettime64(clockid, &ts64);
+  else
+    ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_clock_gettime64,
+                                            static_cast<long>(clockid),
+                                            reinterpret_cast<long>(&ts64));
+  if (ret == 0) {
+    ts->tv_sec = static_cast<decltype(ts->tv_sec)>(ts64.tv_sec);
+    ts->tv_nsec = static_cast<decltype(ts->tv_nsec)>(ts64.tv_nsec);
+  }
+#else
+#error "SYS_clock_gettime and SYS_clock_gettime64 syscalls not available."
+#endif
+  if (ret < 0)
+    return Error(-ret);
+  return ret;
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/time/linux/clock_gettime.h b/src/__support/time/linux/clock_gettime.h
index bbdde98..f7f996c 100644
--- a/src/__support/time/linux/clock_gettime.h
+++ b/src/__support/time/linux/clock_gettime.h
@@ -11,34 +11,16 @@
 
 #include "hdr/types/clockid_t.h"
 #include "hdr/types/struct_timespec.h"
-#include "src/__support/OSUtil/syscall.h"
-#include "src/__support/common.h"
 #include "src/__support/error_or.h"
-#include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
-namespace internal {
-LIBC_INLINE ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts) {
-#if SYS_clock_gettime
-  int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_clock_gettime,
-                                              static_cast<long>(clockid),
-                                              reinterpret_cast<long>(ts));
-#elif defined(SYS_clock_gettime64)
-  static_assert(
-      sizeof(time_t) == sizeof(int64_t),
-      "SYS_clock_gettime64 requires struct timespec with 64-bit members.");
-  int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_clock_gettime64,
-                                              static_cast<long>(clockid),
-                                              reinterpret_cast<long>(ts));
-#else
-#error "SYS_clock_gettime and SYS_clock_gettime64 syscalls not available."
+#if defined(SYS_clock_gettime64)
+#include <linux/time_types.h>
 #endif
-  if (ret < 0)
-    return Error(-ret);
-  return ret;
-}
 
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts);
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_GETTIME_H
diff --git a/src/__support/time/linux/monotonicity.h b/src/__support/time/linux/monotonicity.h
index e413275..c7234db 100644
--- a/src/__support/time/linux/monotonicity.h
+++ b/src/__support/time/linux/monotonicity.h
@@ -11,9 +11,10 @@
 
 #include "hdr/time_macros.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/abs_timeout.h"
 #include "src/__support/time/linux/clock_conversion.h"
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 // This function is separated from abs_timeout.
 // This function pulls in the dependency to clock_conversion.h,
@@ -38,6 +39,6 @@ LIBC_INLINE void ensure_monotonicity(AbsTimeout &timeout) {
   }
 }
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_MONOTONICITY_H
diff --git a/src/__support/time/units.h b/src/__support/time/units.h
index ee74af7..ff95199 100644
--- a/src/__support/time/units.h
+++ b/src/__support/time/units.h
@@ -11,8 +11,9 @@
 
 #include "hdr/types/time_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace time_units {
 LIBC_INLINE constexpr time_t operator""_s_ns(unsigned long long s) {
   return static_cast<time_t>(s * 1'000'000'000);
@@ -33,6 +34,6 @@ LIBC_INLINE constexpr time_t operator""_us_ns(unsigned long long us) {
   return static_cast<time_t>(us * 1'000);
 }
 } // namespace time_units
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_TIME_UNITS_H
diff --git a/src/__support/wctype_utils.h b/src/__support/wctype_utils.h
index aa1161c..aa137c2 100644
--- a/src/__support/wctype_utils.h
+++ b/src/__support/wctype_utils.h
@@ -9,14 +9,12 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_WCTYPE_UTILS_H
 #define LLVM_LIBC_SRC___SUPPORT_WCTYPE_UTILS_H
 
+#include "hdr/types/wint_t.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 
-#define __need_wint_t
-#define __need_wchar_t
-#include <stddef.h> // needed for wint_t and wchar_t
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // ------------------------------------------------------
@@ -44,6 +42,6 @@ LIBC_INLINE cpp::optional<wint_t> btowc(int c) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC___SUPPORT_WCTYPE_UTILS_H
diff --git a/src/assert/__assert_fail.h b/src/assert/__assert_fail.h
index 6b9dee2..bbc0aa8 100644
--- a/src/assert/__assert_fail.h
+++ b/src/assert/__assert_fail.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_ASSERT___ASSERT_FAIL_H
 #define LLVM_LIBC_SRC_ASSERT___ASSERT_FAIL_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void __assert_fail(const char *assertion, const char *file,
                                 unsigned line, const char *function);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_ASSERT___ASSERT_FAIL_H
diff --git a/src/assert/assert.h b/src/assert/assert.h
index 6f352af..1ea19ea 100644
--- a/src/assert/assert.h
+++ b/src/assert/assert.h
@@ -18,8 +18,18 @@
 #ifdef NDEBUG
 #define assert(e) (void)0
 #else
+
+#ifdef __has_builtin
+#if __has_builtin(__builtin_expect)
+#define __LIBC_ASSERT_LIKELY(e) __builtin_expect(e, 1)
+#endif
+#endif
+#ifndef __LIBC_ASSERT_LIKELY
+#define __LIBC_ASSERT_LIKELY(e) e
+#endif
+
 #define assert(e)                                                              \
-  ((e) ? (void)0                                                               \
-       : LIBC_NAMESPACE::__assert_fail(#e, __FILE__, __LINE__,                 \
-                                       __PRETTY_FUNCTION__))
+  (__LIBC_ASSERT_LIKELY(e) ? (void)0                                           \
+                           : LIBC_NAMESPACE::__assert_fail(                    \
+                                 #e, __FILE__, __LINE__, __PRETTY_FUNCTION__))
 #endif // NDEBUG
diff --git a/src/assert/generic/__assert_fail.cpp b/src/assert/generic/__assert_fail.cpp
index 4cf914b..8773361 100644
--- a/src/assert/generic/__assert_fail.cpp
+++ b/src/assert/generic/__assert_fail.cpp
@@ -9,9 +9,10 @@
 #include "src/assert/__assert_fail.h"
 #include "src/__support/OSUtil/io.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/abort.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, __assert_fail,
                    (const char *assertion, const char *file, unsigned line,
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(void, __assert_fail,
   LIBC_NAMESPACE::abort();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/assert/gpu/__assert_fail.cpp b/src/assert/gpu/__assert_fail.cpp
index 7621c08..5b77242 100644
--- a/src/assert/gpu/__assert_fail.cpp
+++ b/src/assert/gpu/__assert_fail.cpp
@@ -11,9 +11,10 @@
 #include "src/__support/CPP/atomic.h"
 #include "src/__support/GPU/utils.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/abort.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // A single-use lock to allow only a single thread to print the assertion.
 static cpp::Atomic<uint32_t> lock = 0;
@@ -37,4 +38,4 @@ LLVM_LIBC_FUNCTION(void, __assert_fail,
   LIBC_NAMESPACE::abort();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/compiler/generic/__stack_chk_fail.cpp b/src/compiler/generic/__stack_chk_fail.cpp
index 639204d..c76ec14 100644
--- a/src/compiler/generic/__stack_chk_fail.cpp
+++ b/src/compiler/generic/__stack_chk_fail.cpp
@@ -13,7 +13,7 @@
 extern "C" {
 
 void __stack_chk_fail(void) {
-  LIBC_NAMESPACE::write_to_stderr("stack smashing detected");
+  LIBC_NAMESPACE::write_to_stderr("stack smashing detected\n");
   LIBC_NAMESPACE::abort();
 }
 
diff --git a/src/complex/cimag.h b/src/complex/cimag.h
new file mode 100644
index 0000000..29c9b22
--- /dev/null
+++ b/src/complex/cimag.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cimag -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CIMAG_H
+#define LLVM_LIBC_SRC_COMPLEX_CIMAG_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double cimag(_Complex double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CIMAG_H
diff --git a/src/complex/cimagf.h b/src/complex/cimagf.h
new file mode 100644
index 0000000..577b6ca
--- /dev/null
+++ b/src/complex/cimagf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cimagf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGF_H
+#define LLVM_LIBC_SRC_COMPLEX_CIMAGF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float cimagf(_Complex float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CIMAGF_H
diff --git a/src/complex/cimagf128.h b/src/complex/cimagf128.h
new file mode 100644
index 0000000..ab8f9ac
--- /dev/null
+++ b/src/complex/cimagf128.h
@@ -0,0 +1,27 @@
+//===-- Implementation header for cimagf128 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
+#define LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float128 cimagf128(cfloat128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/cimagf16.h b/src/complex/cimagf16.h
new file mode 100644
index 0000000..5c5de2e
--- /dev/null
+++ b/src/complex/cimagf16.h
@@ -0,0 +1,27 @@
+//===-- Implementation header for cimagf16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
+#define LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 cimagf16(cfloat16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/cimagl.h b/src/complex/cimagl.h
new file mode 100644
index 0000000..966aee0
--- /dev/null
+++ b/src/complex/cimagl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cimagl ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGL_H
+#define LLVM_LIBC_SRC_COMPLEX_CIMAGL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double cimagl(_Complex long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CIMAGL_H
diff --git a/src/complex/creal.h b/src/complex/creal.h
new file mode 100644
index 0000000..3ec5dd0
--- /dev/null
+++ b/src/complex/creal.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for creal -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CREAL_H
+#define LLVM_LIBC_SRC_COMPLEX_CREAL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double creal(_Complex double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CREAL_H
diff --git a/src/complex/crealf.h b/src/complex/crealf.h
new file mode 100644
index 0000000..79dafc1
--- /dev/null
+++ b/src/complex/crealf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for crealf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CREALF_H
+#define LLVM_LIBC_SRC_COMPLEX_CREALF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float crealf(_Complex float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CREALF_H
diff --git a/src/complex/crealf128.h b/src/complex/crealf128.h
new file mode 100644
index 0000000..4922ae7
--- /dev/null
+++ b/src/complex/crealf128.h
@@ -0,0 +1,27 @@
+//===-- Implementation header for crealf128 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CREALF128_H
+#define LLVM_LIBC_SRC_COMPLEX_CREALF128_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float128 crealf128(cfloat128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CREALF128_H
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/crealf16.h b/src/complex/crealf16.h
new file mode 100644
index 0000000..e6098a2
--- /dev/null
+++ b/src/complex/crealf16.h
@@ -0,0 +1,27 @@
+//===-- Implementation header for crealf16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CREALF16_H
+#define LLVM_LIBC_SRC_COMPLEX_CREALF16_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 crealf16(cfloat16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CREALF16_H
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/creall.h b/src/complex/creall.h
new file mode 100644
index 0000000..2a8245f
--- /dev/null
+++ b/src/complex/creall.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for creall ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CREALL_H
+#define LLVM_LIBC_SRC_COMPLEX_CREALL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double creall(_Complex long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CREALL_H
diff --git a/src/complex/generic/cimag.cpp b/src/complex/generic/cimag.cpp
new file mode 100644
index 0000000..6aa5de4
--- /dev/null
+++ b/src/complex/generic/cimag.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of cimag function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cimag.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, cimag, (_Complex double x)) {
+  Complex<double> x_c = cpp::bit_cast<Complex<double>>(x);
+  return x_c.imag;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cimagf.cpp b/src/complex/generic/cimagf.cpp
new file mode 100644
index 0000000..f61808c
--- /dev/null
+++ b/src/complex/generic/cimagf.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of cimagf function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cimagf.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, cimagf, (_Complex float x)) {
+  Complex<float> x_c = cpp::bit_cast<Complex<float>>(x);
+  return x_c.imag;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cimagf128.cpp b/src/complex/generic/cimagf128.cpp
new file mode 100644
index 0000000..c21bd7f
--- /dev/null
+++ b/src/complex/generic/cimagf128.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of cimagf128 function ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cimagf128.h"
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float128, cimagf128, (cfloat128 x)) {
+  Complex<float128> x_c = cpp::bit_cast<Complex<float128>>(x);
+  return x_c.imag;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/generic/cimagf16.cpp b/src/complex/generic/cimagf16.cpp
new file mode 100644
index 0000000..3616879
--- /dev/null
+++ b/src/complex/generic/cimagf16.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of cimagf16 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cimagf16.h"
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, cimagf16, (cfloat16 x)) {
+  Complex<float16> x_c = cpp::bit_cast<Complex<float16>>(x);
+  return x_c.imag;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/generic/cimagl.cpp b/src/complex/generic/cimagl.cpp
new file mode 100644
index 0000000..1f63ad3
--- /dev/null
+++ b/src/complex/generic/cimagl.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of cimagl function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cimagl.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long double, cimagl, (_Complex long double x)) {
+  Complex<long double> x_c = cpp::bit_cast<Complex<long double>>(x);
+  return x_c.imag;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/creal.cpp b/src/complex/generic/creal.cpp
new file mode 100644
index 0000000..e97e1da
--- /dev/null
+++ b/src/complex/generic/creal.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of creal function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/creal.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, creal, (_Complex double x)) {
+  Complex<double> x_c = cpp::bit_cast<Complex<double>>(x);
+  return x_c.real;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/crealf.cpp b/src/complex/generic/crealf.cpp
new file mode 100644
index 0000000..304c743
--- /dev/null
+++ b/src/complex/generic/crealf.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of crealf function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/crealf.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, crealf, (_Complex float x)) {
+  Complex<float> x_c = cpp::bit_cast<Complex<float>>(x);
+  return x_c.real;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/crealf128.cpp b/src/complex/generic/crealf128.cpp
new file mode 100644
index 0000000..e72a778
--- /dev/null
+++ b/src/complex/generic/crealf128.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of crealf128 function ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/crealf128.h"
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float128, crealf128, (cfloat128 x)) {
+  Complex<float128> x_c = cpp::bit_cast<Complex<float128>>(x);
+  return x_c.real;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/generic/crealf16.cpp b/src/complex/generic/crealf16.cpp
new file mode 100644
index 0000000..3514207
--- /dev/null
+++ b/src/complex/generic/crealf16.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of crealf16 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/crealf16.h"
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, crealf16, (cfloat16 x)) {
+  Complex<float16> x_c = cpp::bit_cast<Complex<float16>>(x);
+  return x_c.real;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/generic/creall.cpp b/src/complex/generic/creall.cpp
new file mode 100644
index 0000000..9d43f97
--- /dev/null
+++ b/src/complex/generic/creall.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of creall function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/creall.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_type.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long double, creall, (_Complex long double x)) {
+  Complex<long double> x_c = cpp::bit_cast<Complex<long double>>(x);
+  return x_c.real;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isalnum.cpp b/src/ctype/isalnum.cpp
index 42ed8ea..54a3e35 100644
--- a/src/ctype/isalnum.cpp
+++ b/src/ctype/isalnum.cpp
@@ -10,13 +10,12 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isalnum, (int c)) {
   return static_cast<int>(internal::isalnum(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isalnum.h b/src/ctype/isalnum.h
index 71830c9..6516f2e 100644
--- a/src/ctype/isalnum.h
+++ b/src/ctype/isalnum.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISALNUM_H
 #define LLVM_LIBC_SRC_CTYPE_ISALNUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isalnum(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISALNUM_H
diff --git a/src/ctype/isalnum_l.cpp b/src/ctype/isalnum_l.cpp
new file mode 100644
index 0000000..671d9b7
--- /dev/null
+++ b/src/ctype/isalnum_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isalnum -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isalnum_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isalnum_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isalnum(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isalnum_l.h b/src/ctype/isalnum_l.h
new file mode 100644
index 0000000..5bc892e
--- /dev/null
+++ b/src/ctype/isalnum_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isalnum_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISALNUM_H
+#define LLVM_LIBC_SRC_CTYPE_ISALNUM_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isalnum_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISALNUM_H
diff --git a/src/ctype/isalpha.cpp b/src/ctype/isalpha.cpp
index 2b1bd0e..78b26f6 100644
--- a/src/ctype/isalpha.cpp
+++ b/src/ctype/isalpha.cpp
@@ -10,13 +10,12 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isalpha, (int c)) {
   return static_cast<int>(internal::isalpha(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isalpha.h b/src/ctype/isalpha.h
index b5b07ee..a21c459 100644
--- a/src/ctype/isalpha.h
+++ b/src/ctype/isalpha.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISALPHA_H
 #define LLVM_LIBC_SRC_CTYPE_ISALPHA_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isalpha(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISALPHA_H
diff --git a/src/ctype/isalpha_l.cpp b/src/ctype/isalpha_l.cpp
new file mode 100644
index 0000000..0619d97
--- /dev/null
+++ b/src/ctype/isalpha_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isalpha -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isalpha_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isalpha_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isalpha(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isalpha_l.h b/src/ctype/isalpha_l.h
new file mode 100644
index 0000000..3591f11
--- /dev/null
+++ b/src/ctype/isalpha_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isalpha_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISALPHA_H
+#define LLVM_LIBC_SRC_CTYPE_ISALPHA_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isalpha_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISALPHA_H
diff --git a/src/ctype/isascii.cpp b/src/ctype/isascii.cpp
index 8be3d7e..ef3788d 100644
--- a/src/ctype/isascii.cpp
+++ b/src/ctype/isascii.cpp
@@ -9,11 +9,12 @@
 #include "src/ctype/isascii.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, isascii, (int c)) {
   return static_cast<int>((c & (~0x7f)) == 0);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isascii.h b/src/ctype/isascii.h
index 5a734a2..20473a7 100644
--- a/src/ctype/isascii.h
+++ b/src/ctype/isascii.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISASCII_H
 #define LLVM_LIBC_SRC_CTYPE_ISASCII_H
 
+#include "src/__support/macros/config.h"
 #undef isascii
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int isascii(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISASCII_H
diff --git a/src/ctype/isblank.cpp b/src/ctype/isblank.cpp
index 9ac9d36..e0a2082 100644
--- a/src/ctype/isblank.cpp
+++ b/src/ctype/isblank.cpp
@@ -9,13 +9,12 @@
 #include "src/ctype/isblank.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isblank, (int c)) {
   return static_cast<int>(c == ' ' || c == '\t');
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isblank.h b/src/ctype/isblank.h
index 4cacdb3..3fb69e8 100644
--- a/src/ctype/isblank.h
+++ b/src/ctype/isblank.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISBLANK_H
 #define LLVM_LIBC_SRC_CTYPE_ISBLANK_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isblank(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISBLANK_H
diff --git a/src/math/aarch64/floorf.cpp b/src/ctype/isblank_l.cpp
similarity index 52%
rename from src/math/aarch64/floorf.cpp
rename to src/ctype/isblank_l.cpp
index 8942a9e..4f6b0bf 100644
--- a/src/math/aarch64/floorf.cpp
+++ b/src/ctype/isblank_l.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the floorf function for aarch64 -----------------===//
+//===-- Implementation of isblank -----------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,15 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/floorf.h"
+#include "src/ctype/isblank_l.h"
+
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, floorf, (float x)) {
-  float y;
-  __asm__ __volatile__("frintm %s0, %s1\n\t" : "=w"(y) : "w"(x));
-  return y;
+LLVM_LIBC_FUNCTION(int, isblank_l, (int c, locale_t)) {
+  return static_cast<int>(c == ' ' || c == '\t');
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isblank_l.h b/src/ctype/isblank_l.h
new file mode 100644
index 0000000..61ede30
--- /dev/null
+++ b/src/ctype/isblank_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isblank_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISBLANK_H
+#define LLVM_LIBC_SRC_CTYPE_ISBLANK_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isblank_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISBLANK_H
diff --git a/src/ctype/iscntrl.cpp b/src/ctype/iscntrl.cpp
index b52b86f..2218adf 100644
--- a/src/ctype/iscntrl.cpp
+++ b/src/ctype/iscntrl.cpp
@@ -9,14 +9,13 @@
 #include "src/ctype/iscntrl.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, iscntrl, (int c)) {
   const unsigned ch = static_cast<unsigned>(c);
   return static_cast<int>(ch < 0x20 || ch == 0x7f);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/iscntrl.h b/src/ctype/iscntrl.h
index e0cae0c..ac8e2eb 100644
--- a/src/ctype/iscntrl.h
+++ b/src/ctype/iscntrl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
 #define LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int iscntrl(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
diff --git a/src/ctype/iscntrl_l.cpp b/src/ctype/iscntrl_l.cpp
new file mode 100644
index 0000000..83aa480
--- /dev/null
+++ b/src/ctype/iscntrl_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of iscntrl -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/iscntrl_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, iscntrl_l, (int c, locale_t)) {
+  const unsigned ch = static_cast<unsigned>(c);
+  return static_cast<int>(ch < 0x20 || ch == 0x7f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/iscntrl_l.h b/src/ctype/iscntrl_l.h
new file mode 100644
index 0000000..7dee44f
--- /dev/null
+++ b/src/ctype/iscntrl_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for iscntrl_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
+#define LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscntrl_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISCNTRL_H
diff --git a/src/ctype/isdigit.cpp b/src/ctype/isdigit.cpp
index d4d5d1f..1f71194 100644
--- a/src/ctype/isdigit.cpp
+++ b/src/ctype/isdigit.cpp
@@ -9,13 +9,12 @@
 #include "src/ctype/isdigit.h"
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isdigit, (int c)) {
   return static_cast<int>(internal::isdigit(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isdigit.h b/src/ctype/isdigit.h
index a024cf4..ca8242d 100644
--- a/src/ctype/isdigit.h
+++ b/src/ctype/isdigit.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
 #define LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isdigit(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
diff --git a/src/ctype/isdigit_l.cpp b/src/ctype/isdigit_l.cpp
new file mode 100644
index 0000000..ca98136
--- /dev/null
+++ b/src/ctype/isdigit_l.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of isdigit -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isdigit_l.h"
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isdigit_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isdigit(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isdigit_l.h b/src/ctype/isdigit_l.h
new file mode 100644
index 0000000..abeec34
--- /dev/null
+++ b/src/ctype/isdigit_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isdigit_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
+#define LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isdigit_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISDIGIT_H
diff --git a/src/ctype/isgraph.cpp b/src/ctype/isgraph.cpp
index e195f9f..74bb2e7 100644
--- a/src/ctype/isgraph.cpp
+++ b/src/ctype/isgraph.cpp
@@ -10,13 +10,12 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isgraph, (int c)) {
   return static_cast<int>(internal::isgraph(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isgraph.h b/src/ctype/isgraph.h
index 486c32d..bc9ab7d 100644
--- a/src/ctype/isgraph.h
+++ b/src/ctype/isgraph.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
 #define LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isgraph(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
diff --git a/src/ctype/isgraph_l.cpp b/src/ctype/isgraph_l.cpp
new file mode 100644
index 0000000..cbef6df
--- /dev/null
+++ b/src/ctype/isgraph_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isgraph -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isgraph_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isgraph_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isgraph(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isgraph_l.h b/src/ctype/isgraph_l.h
new file mode 100644
index 0000000..d96a460
--- /dev/null
+++ b/src/ctype/isgraph_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isgraph_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
+#define LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isgraph_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISGRAPH_H
diff --git a/src/ctype/islower.cpp b/src/ctype/islower.cpp
index bd252e5..831aad3 100644
--- a/src/ctype/islower.cpp
+++ b/src/ctype/islower.cpp
@@ -10,13 +10,12 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, islower, (int c)) {
   return static_cast<int>(internal::islower(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/islower.h b/src/ctype/islower.h
index dc59ce9..f279dc7 100644
--- a/src/ctype/islower.h
+++ b/src/ctype/islower.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISLOWER_H
 #define LLVM_LIBC_SRC_CTYPE_ISLOWER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int islower(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISLOWER_H
diff --git a/src/ctype/islower_l.cpp b/src/ctype/islower_l.cpp
new file mode 100644
index 0000000..b9be6ac
--- /dev/null
+++ b/src/ctype/islower_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of islower -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/islower_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, islower_l, (int c, locale_t)) {
+  return static_cast<int>(internal::islower(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/islower_l.h b/src/ctype/islower_l.h
new file mode 100644
index 0000000..7d3e2f1
--- /dev/null
+++ b/src/ctype/islower_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for islower_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISLOWER_H
+#define LLVM_LIBC_SRC_CTYPE_ISLOWER_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int islower_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISLOWER_H
diff --git a/src/ctype/isprint.cpp b/src/ctype/isprint.cpp
index bdf9d08..349aefe 100644
--- a/src/ctype/isprint.cpp
+++ b/src/ctype/isprint.cpp
@@ -9,14 +9,13 @@
 #include "src/ctype/isprint.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isprint, (int c)) {
   const unsigned ch = static_cast<unsigned>(c);
   return static_cast<int>((ch - ' ') < 95);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isprint.h b/src/ctype/isprint.h
index 22c835b..551e2eb 100644
--- a/src/ctype/isprint.h
+++ b/src/ctype/isprint.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISPRINT_H
 #define LLVM_LIBC_SRC_CTYPE_ISPRINT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isprint(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISPRINT_H
diff --git a/src/ctype/isprint_l.cpp b/src/ctype/isprint_l.cpp
new file mode 100644
index 0000000..8f51f7f
--- /dev/null
+++ b/src/ctype/isprint_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isprint -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isprint_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isprint_l, (int c, locale_t)) {
+  const unsigned ch = static_cast<unsigned>(c);
+  return static_cast<int>((ch - ' ') < 95);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isprint_l.h b/src/ctype/isprint_l.h
new file mode 100644
index 0000000..bd2ea93
--- /dev/null
+++ b/src/ctype/isprint_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isprint_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISPRINT_H
+#define LLVM_LIBC_SRC_CTYPE_ISPRINT_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isprint_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISPRINT_H
diff --git a/src/ctype/ispunct.cpp b/src/ctype/ispunct.cpp
index d355c19..0635294 100644
--- a/src/ctype/ispunct.cpp
+++ b/src/ctype/ispunct.cpp
@@ -10,14 +10,13 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, ispunct, (int c)) {
   const unsigned ch = static_cast<unsigned>(c);
   return static_cast<int>(!internal::isalnum(ch) && internal::isgraph(ch));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/ispunct.h b/src/ctype/ispunct.h
index 7eaa83a..96775f4 100644
--- a/src/ctype/ispunct.h
+++ b/src/ctype/ispunct.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
 #define LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int ispunct(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
diff --git a/src/ctype/ispunct_l.cpp b/src/ctype/ispunct_l.cpp
new file mode 100644
index 0000000..e825fbe
--- /dev/null
+++ b/src/ctype/ispunct_l.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of ispunct -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/ispunct_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, ispunct_l, (int c, locale_t)) {
+  const unsigned ch = static_cast<unsigned>(c);
+  return static_cast<int>(!internal::isalnum(ch) && internal::isgraph(ch));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/ispunct_l.h b/src/ctype/ispunct_l.h
new file mode 100644
index 0000000..862daf4
--- /dev/null
+++ b/src/ctype/ispunct_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for ispunct_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
+#define LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int ispunct_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISPUNCT_H
diff --git a/src/ctype/isspace.cpp b/src/ctype/isspace.cpp
index 8c09eda..005bf46 100644
--- a/src/ctype/isspace.cpp
+++ b/src/ctype/isspace.cpp
@@ -10,13 +10,12 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isspace, (int c)) {
   return static_cast<int>(internal::isspace(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isspace.h b/src/ctype/isspace.h
index 56b7057..f76ae17 100644
--- a/src/ctype/isspace.h
+++ b/src/ctype/isspace.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISSPACE_H
 #define LLVM_LIBC_SRC_CTYPE_ISSPACE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isspace(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISSPACE_H
diff --git a/src/ctype/isspace_l.cpp b/src/ctype/isspace_l.cpp
new file mode 100644
index 0000000..5c46dd6
--- /dev/null
+++ b/src/ctype/isspace_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isspace -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isspace_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isspace_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isspace(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isspace_l.h b/src/ctype/isspace_l.h
new file mode 100644
index 0000000..61bbf12
--- /dev/null
+++ b/src/ctype/isspace_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isspace_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISSPACE_H
+#define LLVM_LIBC_SRC_CTYPE_ISSPACE_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isspace_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISSPACE_H
diff --git a/src/ctype/isupper.cpp b/src/ctype/isupper.cpp
index b527e3e..965fa33 100644
--- a/src/ctype/isupper.cpp
+++ b/src/ctype/isupper.cpp
@@ -10,13 +10,12 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isupper, (int c)) {
   return static_cast<int>(internal::isupper(static_cast<unsigned>(c)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isupper.h b/src/ctype/isupper.h
index 8f5ce84..398f653 100644
--- a/src/ctype/isupper.h
+++ b/src/ctype/isupper.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISUPPER_H
 #define LLVM_LIBC_SRC_CTYPE_ISUPPER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isupper(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISUPPER_H
diff --git a/src/ctype/isupper_l.cpp b/src/ctype/isupper_l.cpp
new file mode 100644
index 0000000..3589902
--- /dev/null
+++ b/src/ctype/isupper_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of isupper -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isupper_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isupper_l, (int c, locale_t)) {
+  return static_cast<int>(internal::isupper(static_cast<unsigned>(c)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isupper_l.h b/src/ctype/isupper_l.h
new file mode 100644
index 0000000..9bee7ef
--- /dev/null
+++ b/src/ctype/isupper_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isupper_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISUPPER_H
+#define LLVM_LIBC_SRC_CTYPE_ISUPPER_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isupper_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISUPPER_H
diff --git a/src/ctype/isxdigit.cpp b/src/ctype/isxdigit.cpp
index 79152c9..6b730c3 100644
--- a/src/ctype/isxdigit.cpp
+++ b/src/ctype/isxdigit.cpp
@@ -10,14 +10,13 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, isxdigit, (int c)) {
   const unsigned ch = static_cast<unsigned>(c);
   return static_cast<int>(internal::isdigit(ch) || (ch | 32) - 'a' < 6);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isxdigit.h b/src/ctype/isxdigit.h
index 4966c32..8d0a099 100644
--- a/src/ctype/isxdigit.h
+++ b/src/ctype/isxdigit.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
 #define LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int isxdigit(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
diff --git a/src/ctype/isxdigit_l.cpp b/src/ctype/isxdigit_l.cpp
new file mode 100644
index 0000000..8a5c7d4
--- /dev/null
+++ b/src/ctype/isxdigit_l.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of isxdigit ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/isxdigit_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isxdigit_l, (int c, locale_t)) {
+  const unsigned ch = static_cast<unsigned>(c);
+  return static_cast<int>(internal::isdigit(ch) || (ch | 32) - 'a' < 6);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isxdigit_l.h b/src/ctype/isxdigit_l.h
new file mode 100644
index 0000000..ee847ed
--- /dev/null
+++ b/src/ctype/isxdigit_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for isxdigit_l ----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
+#define LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isxdigit_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_ISXDIGIT_H
diff --git a/src/ctype/toascii.cpp b/src/ctype/toascii.cpp
index 06bf91b..53b26b5 100644
--- a/src/ctype/toascii.cpp
+++ b/src/ctype/toascii.cpp
@@ -9,9 +9,10 @@
 #include "src/ctype/toascii.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, toascii, (int c)) { return (c & 0x7f); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/toascii.h b/src/ctype/toascii.h
index 246580e..d41e585 100644
--- a/src/ctype/toascii.h
+++ b/src/ctype/toascii.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_TOASCII_H
 #define LLVM_LIBC_SRC_CTYPE_TOASCII_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int toascii(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_TOASCII_H
diff --git a/src/ctype/tolower.cpp b/src/ctype/tolower.cpp
index 4e8b96d..3ecad7b 100644
--- a/src/ctype/tolower.cpp
+++ b/src/ctype/tolower.cpp
@@ -10,11 +10,10 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, tolower, (int c)) { return internal::tolower(c); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/tolower.h b/src/ctype/tolower.h
index 8213da9..d26d0b5 100644
--- a/src/ctype/tolower.h
+++ b/src/ctype/tolower.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_TOLOWER_H
 #define LLVM_LIBC_SRC_CTYPE_TOLOWER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int tolower(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_TOLOWER_H
diff --git a/src/ctype/tolower_l.cpp b/src/ctype/tolower_l.cpp
new file mode 100644
index 0000000..7ccf316
--- /dev/null
+++ b/src/ctype/tolower_l.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of tolower -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/tolower_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, tolower_l, (int c, locale_t)) {
+  return internal::tolower(c);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/tolower_l.h b/src/ctype/tolower_l.h
new file mode 100644
index 0000000..6099b8c
--- /dev/null
+++ b/src/ctype/tolower_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for tolower_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_TOLOWER_H
+#define LLVM_LIBC_SRC_CTYPE_TOLOWER_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int tolower_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_TOLOWER_H
diff --git a/src/ctype/toupper.cpp b/src/ctype/toupper.cpp
index 7b0db35..b5a23fc 100644
--- a/src/ctype/toupper.cpp
+++ b/src/ctype/toupper.cpp
@@ -10,15 +10,14 @@
 #include "src/__support/ctype_utils.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// TODO: Currently restricted to default locale.
-// These should be extended using locale information.
 LLVM_LIBC_FUNCTION(int, toupper, (int c)) {
   if (internal::islower(c))
     return c - ('a' - 'A');
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/toupper.h b/src/ctype/toupper.h
index b5d8890..0301687 100644
--- a/src/ctype/toupper.h
+++ b/src/ctype/toupper.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_CTYPE_TOUPPER_H
 #define LLVM_LIBC_SRC_CTYPE_TOUPPER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int toupper(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_CTYPE_TOUPPER_H
diff --git a/src/ctype/toupper_l.cpp b/src/ctype/toupper_l.cpp
new file mode 100644
index 0000000..f536ff3
--- /dev/null
+++ b/src/ctype/toupper_l.cpp
@@ -0,0 +1,23 @@
+//===-- Implementation of toupper_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/ctype/toupper_l.h"
+#include "src/__support/ctype_utils.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, toupper_l, (int c, locale_t)) {
+  if (internal::islower(c))
+    return c - ('a' - 'A');
+  return c;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/toupper_l.h b/src/ctype/toupper_l.h
new file mode 100644
index 0000000..8877c35
--- /dev/null
+++ b/src/ctype/toupper_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for toupper_l -----------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_CTYPE_TOUPPER_H
+#define LLVM_LIBC_SRC_CTYPE_TOUPPER_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int toupper_l(int c, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_CTYPE_TOUPPER_H
diff --git a/src/dirent/closedir.cpp b/src/dirent/closedir.cpp
index 22c27c4..1249ef9 100644
--- a/src/dirent/closedir.cpp
+++ b/src/dirent/closedir.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/File/dir.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, closedir, (::DIR * dir)) {
   auto *d = reinterpret_cast<LIBC_NAMESPACE::Dir *>(dir);
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, closedir, (::DIR * dir)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dirent/closedir.h b/src/dirent/closedir.h
index 6d6b898..14df5fe 100644
--- a/src/dirent/closedir.h
+++ b/src/dirent/closedir.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_DIRENT_CLOSEDIR_H
 #define LLVM_LIBC_SRC_DIRENT_CLOSEDIR_H
 
+#include "src/__support/macros/config.h"
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int closedir(::DIR *dir);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_DIRENT_CLOSEDIR_H
diff --git a/src/dirent/dirfd.cpp b/src/dirent/dirfd.cpp
index 27995f6..e60a62d 100644
--- a/src/dirent/dirfd.cpp
+++ b/src/dirent/dirfd.cpp
@@ -10,14 +10,15 @@
 
 #include "src/__support/File/dir.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, dirfd, (::DIR * dir)) {
   auto *d = reinterpret_cast<LIBC_NAMESPACE::Dir *>(dir);
   return d->getfd();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dirent/dirfd.h b/src/dirent/dirfd.h
index 34acb01..ed037e2 100644
--- a/src/dirent/dirfd.h
+++ b/src/dirent/dirfd.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_DIRENT_DIRFD_H
 #define LLVM_LIBC_SRC_DIRENT_DIRFD_H
 
+#include "src/__support/macros/config.h"
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int dirfd(::DIR *dir);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_DIRENT_DIRFD_H
diff --git a/src/dirent/opendir.cpp b/src/dirent/opendir.cpp
index 56f7bc8..fee14ef 100644
--- a/src/dirent/opendir.cpp
+++ b/src/dirent/opendir.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/File/dir.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(::DIR *, opendir, (const char *name)) {
   auto dir = Dir::open(name);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(::DIR *, opendir, (const char *name)) {
   return reinterpret_cast<DIR *>(dir.value());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dirent/opendir.h b/src/dirent/opendir.h
index 635cb90..a9f3358 100644
--- a/src/dirent/opendir.h
+++ b/src/dirent/opendir.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_DIRENT_OPENDIR_H
 #define LLVM_LIBC_SRC_DIRENT_OPENDIR_H
 
+#include "src/__support/macros/config.h"
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ::DIR *opendir(const char *name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_DIRENT_OPENDIR_H
diff --git a/src/dirent/readdir.cpp b/src/dirent/readdir.cpp
index 448935e..ad460b5 100644
--- a/src/dirent/readdir.cpp
+++ b/src/dirent/readdir.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/File/dir.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(struct ::dirent *, readdir, (::DIR * dir)) {
   auto *d = reinterpret_cast<LIBC_NAMESPACE::Dir *>(dir);
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(struct ::dirent *, readdir, (::DIR * dir)) {
   return dirent_val.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dirent/readdir.h b/src/dirent/readdir.h
index 83c8c56..2dcf536 100644
--- a/src/dirent/readdir.h
+++ b/src/dirent/readdir.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_DIRENT_READDIR_H
 #define LLVM_LIBC_SRC_DIRENT_READDIR_H
 
+#include "src/__support/macros/config.h"
 #include <dirent.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct ::dirent *readdir(DIR *dir);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_DIRENT_READDIR_H
diff --git a/src/dlfcn/dlclose.cpp b/src/dlfcn/dlclose.cpp
new file mode 100644
index 0000000..e76eb74
--- /dev/null
+++ b/src/dlfcn/dlclose.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of dlclose -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "dlclose.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO(@izaakschroeder): https://github.com/llvm/llvm-project/issues/97917
+LLVM_LIBC_FUNCTION(int, dlclose, (void *)) { return -1; }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dlfcn/dlclose.h b/src/dlfcn/dlclose.h
new file mode 100644
index 0000000..4a9cb00
--- /dev/null
+++ b/src/dlfcn/dlclose.h
@@ -0,0 +1,20 @@
+//===-- Implementation header of dlclose ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_DLFCN_DLCLOSE_H
+#define LLVM_LIBC_SRC_DLFCN_DLCLOSE_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int dlclose(void *);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_DLFCN_DLCLOSE_H
diff --git a/src/dlfcn/dlerror.cpp b/src/dlfcn/dlerror.cpp
new file mode 100644
index 0000000..cb2f2f5
--- /dev/null
+++ b/src/dlfcn/dlerror.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of delerror ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "dlerror.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO(@izaakschroeder): https://github.com/llvm/llvm-project/issues/97918
+LLVM_LIBC_FUNCTION(char *, dlerror, ()) {
+  return const_cast<char *>("unsupported");
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dlfcn/dlerror.h b/src/dlfcn/dlerror.h
new file mode 100644
index 0000000..79a2f6e
--- /dev/null
+++ b/src/dlfcn/dlerror.h
@@ -0,0 +1,20 @@
+//===-- Implementation header of dlerror ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_DLFCN_DLERROR_H
+#define LLVM_LIBC_SRC_DLFCN_DLERROR_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+char *dlerror();
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_DLFCN_DLERROR_H
diff --git a/src/dlfcn/dlopen.cpp b/src/dlfcn/dlopen.cpp
new file mode 100644
index 0000000..9e8d58e
--- /dev/null
+++ b/src/dlfcn/dlopen.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of dlopen -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "dlopen.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO(@izaakschroeder): https://github.com/llvm/llvm-project/issues/97919
+LLVM_LIBC_FUNCTION(void *, dlopen, (const char *, int)) { return nullptr; }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dlfcn/dlopen.h b/src/dlfcn/dlopen.h
new file mode 100644
index 0000000..607ef7a
--- /dev/null
+++ b/src/dlfcn/dlopen.h
@@ -0,0 +1,20 @@
+//===-- Implementation header of dlopen -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_DLFCN_DLOPEN_H
+#define LLVM_LIBC_SRC_DLFCN_DLOPEN_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void *dlopen(const char *, int);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_DLFCN_DLOPEN_H
diff --git a/src/dlfcn/dlsym.cpp b/src/dlfcn/dlsym.cpp
new file mode 100644
index 0000000..c075c20
--- /dev/null
+++ b/src/dlfcn/dlsym.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of dlsym ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "dlsym.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO(@izaakschroeder): https://github.com/llvm/llvm-project/issues/97920
+LLVM_LIBC_FUNCTION(void *, dlsym, (void *, const char *)) { return nullptr; }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dlfcn/dlsym.h b/src/dlfcn/dlsym.h
new file mode 100644
index 0000000..70c6ab3
--- /dev/null
+++ b/src/dlfcn/dlsym.h
@@ -0,0 +1,20 @@
+//===-- Implementation header of dlsym --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_DLFCN_DLSYM_H
+#define LLVM_LIBC_SRC_DLFCN_DLSYM_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void *dlsym(void *, const char *);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_DLFCN_DLSYM_H
diff --git a/src/errno/libc_errno.cpp b/src/errno/libc_errno.cpp
index 64f9f52..d1600d1 100644
--- a/src/errno/libc_errno.cpp
+++ b/src/errno/libc_errno.cpp
@@ -7,41 +7,90 @@
 //===----------------------------------------------------------------------===//
 
 #include "libc_errno.h"
+#include "src/__support/macros/config.h"
 
-#ifdef LIBC_TARGET_ARCH_IS_GPU
-// LIBC_THREAD_LOCAL on GPU currently does nothing.  So essentially this is just
-// a global errno for gpu to use for now.
-extern "C" {
-LIBC_THREAD_LOCAL int __llvmlibc_gpu_errno;
+// libc uses a fallback default value, either system or thread local.
+#define LIBC_ERRNO_MODE_DEFAULT 0
+// libc never stores a value; `errno` macro uses get link-time failure.
+#define LIBC_ERRNO_MODE_UNDEFINED 1
+// libc maintains per-thread state (requires C++ `thread_local` support).
+#define LIBC_ERRNO_MODE_THREAD_LOCAL 2
+// libc maintains shared state used by all threads, contrary to standard C
+// semantics unless always single-threaded; nothing prevents data races.
+#define LIBC_ERRNO_MODE_SHARED 3
+// libc doesn't maintain any internal state, instead the embedder must define
+// `int *__llvm_libc_errno(void);` C function.
+#define LIBC_ERRNO_MODE_EXTERNAL 4
+// libc uses system `<errno.h>` `errno` macro directly in the overlay mode; in
+// fullbuild mode, effectively the same as `LIBC_ERRNO_MODE_EXTERNAL`.
+#define LIBC_ERRNO_MODE_SYSTEM 5
+
+#if !defined(LIBC_ERRNO_MODE) || LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_DEFAULT
+#undef LIBC_ERRNO_MODE
+#if defined(LIBC_FULL_BUILD) || !defined(LIBC_COPT_PUBLIC_PACKAGING)
+#define LIBC_ERRNO_MODE LIBC_ERRNO_MODE_THREAD_LOCAL
+#else
+#define LIBC_ERRNO_MODE LIBC_ERRNO_MODE_SYSTEM
+#endif
+#endif // LIBC_ERRNO_MODE
+
+#if LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_DEFAULT &&                              \
+    LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_UNDEFINED &&                            \
+    LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_THREAD_LOCAL &&                         \
+    LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_SHARED &&                               \
+    LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_EXTERNAL &&                             \
+    LIBC_ERRNO_MODE != LIBC_ERRNO_MODE_SYSTEM
+#error LIBC_ERRNO_MODE must be one of the following values: \
+LIBC_ERRNO_MODE_DEFAULT, \
+LIBC_ERRNO_MODE_UNDEFINED, \
+LIBC_ERRNO_MODE_THREAD_LOCAL, \
+LIBC_ERRNO_MODE_SHARED, \
+LIBC_ERRNO_MODE_EXTERNAL, \
+LIBC_ERRNO_MODE_SYSTEM
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+#if LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_UNDEFINED
+
+void Errno::operator=(int) {}
+Errno::operator int() { return 0; }
+
+#elif LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_THREAD_LOCAL
+
+namespace {
+LIBC_THREAD_LOCAL int thread_errno;
 }
 
-void LIBC_NAMESPACE::Errno::operator=(int a) { __llvmlibc_gpu_errno = a; }
-LIBC_NAMESPACE::Errno::operator int() { return __llvmlibc_gpu_errno; }
+extern "C" int *__llvm_libc_errno() noexcept { return &thread_errno; }
 
-#elif !defined(LIBC_COPT_PUBLIC_PACKAGING)
-// This mode is for unit testing.  We just use our internal errno.
-LIBC_THREAD_LOCAL int __llvmlibc_internal_errno;
+void Errno::operator=(int a) { thread_errno = a; }
+Errno::operator int() { return thread_errno; }
 
-void LIBC_NAMESPACE::Errno::operator=(int a) { __llvmlibc_internal_errno = a; }
-LIBC_NAMESPACE::Errno::operator int() { return __llvmlibc_internal_errno; }
+#elif LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_SHARED
 
-#elif defined(LIBC_FULL_BUILD)
-// This mode is for public libc archive, hermetic, and integration tests.
-// In full build mode, we provide the errno storage ourselves.
-extern "C" {
-LIBC_THREAD_LOCAL int __llvmlibc_errno;
+namespace {
+int shared_errno;
 }
 
-void LIBC_NAMESPACE::Errno::operator=(int a) { __llvmlibc_errno = a; }
-LIBC_NAMESPACE::Errno::operator int() { return __llvmlibc_errno; }
+extern "C" int *__llvm_libc_errno() noexcept { return &shared_errno; }
 
-#else
-void LIBC_NAMESPACE::Errno::operator=(int a) { errno = a; }
-LIBC_NAMESPACE::Errno::operator int() { return errno; }
+void Errno::operator=(int a) { shared_errno = a; }
+Errno::operator int() { return shared_errno; }
+
+#elif LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_EXTERNAL
+
+void Errno::operator=(int a) { *__llvm_libc_errno() = a; }
+Errno::operator int() { return *__llvm_libc_errno(); }
 
-#endif // LIBC_FULL_BUILD
+#elif LIBC_ERRNO_MODE == LIBC_ERRNO_MODE_SYSTEM
+
+void Errno::operator=(int a) { errno = a; }
+Errno::operator int() { return errno; }
+
+#endif
 
-namespace LIBC_NAMESPACE {
 // Define the global `libc_errno` instance.
 Errno libc_errno;
-} // namespace LIBC_NAMESPACE
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/errno/libc_errno.h b/src/errno/libc_errno.h
index df67ea3..44ee271 100644
--- a/src/errno/libc_errno.h
+++ b/src/errno/libc_errno.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC_ERRNO_LIBC_ERRNO_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #include "hdr/errno_macros.h"
@@ -30,7 +31,10 @@
 // - Use regular `errno` in the code
 // - Still depend on libc.src.errno.errno
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
+
+extern "C" int *__llvm_libc_errno() noexcept;
+
 struct Errno {
   void operator=(int);
   operator int();
@@ -38,6 +42,6 @@ struct Errno {
 
 extern Errno libc_errno;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_ERRNO_LIBC_ERRNO_H
diff --git a/src/fcntl/creat.h b/src/fcntl/creat.h
index fc91a3c..3e00427 100644
--- a/src/fcntl/creat.h
+++ b/src/fcntl/creat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_FCNTL_CREAT_H
 #define LLVM_LIBC_SRC_FCNTL_CREAT_H
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int creat(const char *path, int mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FCNTL_CREAT_H
diff --git a/src/fcntl/fcntl.h b/src/fcntl/fcntl.h
index 8fe3fb3..02d7250 100644
--- a/src/fcntl/fcntl.h
+++ b/src/fcntl/fcntl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FCNTL_FCNTL_H
 #define LLVM_LIBC_SRC_FCNTL_FCNTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fcntl(int fd, int cmd, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FCNTL_FCNTL_H
diff --git a/src/fcntl/linux/creat.cpp b/src/fcntl/linux/creat.cpp
index 0710fab..23abae2 100644
--- a/src/fcntl/linux/creat.cpp
+++ b/src/fcntl/linux/creat.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, creat, (const char *path, int mode_flags)) {
 #ifdef SYS_open
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, creat, (const char *path, int mode_flags)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fcntl/linux/fcntl.cpp b/src/fcntl/linux/fcntl.cpp
index 3875889..a0c8459 100644
--- a/src/fcntl/linux/fcntl.cpp
+++ b/src/fcntl/linux/fcntl.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/fcntl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdarg.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fcntl, (int fd, int cmd, ...)) {
   void *arg;
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, fcntl, (int fd, int cmd, ...)) {
   return LIBC_NAMESPACE::internal::fcntl(fd, cmd, arg);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fcntl/linux/open.cpp b/src/fcntl/linux/open.cpp
index 7394069..8b699ec 100644
--- a/src/fcntl/linux/open.cpp
+++ b/src/fcntl/linux/open.cpp
@@ -10,13 +10,15 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
+#include "hdr/types/mode_t.h"
 #include <stdarg.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, open, (const char *path, int flags, ...)) {
   mode_t mode_flags = 0;
@@ -42,4 +44,4 @@ LLVM_LIBC_FUNCTION(int, open, (const char *path, int flags, ...)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fcntl/linux/openat.cpp b/src/fcntl/linux/openat.cpp
index a2f7413..6063d9c 100644
--- a/src/fcntl/linux/openat.cpp
+++ b/src/fcntl/linux/openat.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/types/mode_t.h"
 #include <stdarg.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, openat, (int dfd, const char *path, int flags, ...)) {
   mode_t mode_flags = 0;
@@ -38,4 +39,4 @@ LLVM_LIBC_FUNCTION(int, openat, (int dfd, const char *path, int flags, ...)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fcntl/open.h b/src/fcntl/open.h
index 30950dd..11f0ae5 100644
--- a/src/fcntl/open.h
+++ b/src/fcntl/open.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_FCNTL_OPEN_H
 #define LLVM_LIBC_SRC_FCNTL_OPEN_H
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int open(const char *path, int flags, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FCNTL_OPEN_H
diff --git a/src/fcntl/openat.h b/src/fcntl/openat.h
index 5ea5d7f..051c8a2 100644
--- a/src/fcntl/openat.h
+++ b/src/fcntl/openat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_FCNTL_OPENAT_H
 #define LLVM_LIBC_SRC_FCNTL_OPENAT_H
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int openat(int dfd, const char *path, int flags, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FCNTL_OPENAT_H
diff --git a/src/fenv/feclearexcept.cpp b/src/fenv/feclearexcept.cpp
index 5eb1b04..c8a032f 100644
--- a/src/fenv/feclearexcept.cpp
+++ b/src/fenv/feclearexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/feclearexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feclearexcept, (int e)) {
   return fputil::clear_except(e);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/feclearexcept.h b/src/fenv/feclearexcept.h
index e7df86d..19379ed 100644
--- a/src/fenv/feclearexcept.h
+++ b/src/fenv/feclearexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FECLEAREXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FECLEAREXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int feclearexcept(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FECLEAREXCEPT_H
diff --git a/src/fenv/fedisableexcept.cpp b/src/fenv/fedisableexcept.cpp
index c715627..a2a1e97 100644
--- a/src/fenv/fedisableexcept.cpp
+++ b/src/fenv/fedisableexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/fedisableexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fedisableexcept, (int e)) {
   return fputil::disable_except(e);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fedisableexcept.h b/src/fenv/fedisableexcept.h
index 977fd83..6aa0981 100644
--- a/src/fenv/fedisableexcept.h
+++ b/src/fenv/fedisableexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FEDISABLEEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FEDISABLEEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fedisableexcept(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEDISABLEEXCEPT_H
diff --git a/src/fenv/feenableexcept.cpp b/src/fenv/feenableexcept.cpp
index cf45b7f..468a170 100644
--- a/src/fenv/feenableexcept.cpp
+++ b/src/fenv/feenableexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/feenableexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feenableexcept, (int e)) {
   return fputil::enable_except(e);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/feenableexcept.h b/src/fenv/feenableexcept.h
index a077162..0ed19f4 100644
--- a/src/fenv/feenableexcept.h
+++ b/src/fenv/feenableexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FEENABLEEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FEENABLEEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int feenableexcept(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEENABLEEXCEPT_H
diff --git a/src/fenv/fegetenv.cpp b/src/fenv/fegetenv.cpp
index fbdb7d5..c692b87 100644
--- a/src/fenv/fegetenv.cpp
+++ b/src/fenv/fegetenv.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/fegetenv.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fegetenv, (fenv_t * envp)) {
   return fputil::get_env(envp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fegetenv.h b/src/fenv/fegetenv.h
index 8d33029..58a5e7d 100644
--- a/src/fenv/fegetenv.h
+++ b/src/fenv/fegetenv.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FEGETENV_H
 
 #include "hdr/types/fenv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fegetenv(fenv_t *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEGETENV_H
diff --git a/src/fenv/fegetexcept.cpp b/src/fenv/fegetexcept.cpp
index edc4faf..2b3de83 100644
--- a/src/fenv/fegetexcept.cpp
+++ b/src/fenv/fegetexcept.cpp
@@ -9,9 +9,10 @@
 #include "src/fenv/fegetexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fegetexcept, ()) { return fputil::get_except(); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fegetexcept.h b/src/fenv/fegetexcept.h
index 53ce648..eaf48e6 100644
--- a/src/fenv/fegetexcept.h
+++ b/src/fenv/fegetexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FEGETEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FEGETEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fegetexcept();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEGETEXCEPT_H
diff --git a/src/fenv/fegetexceptflag.cpp b/src/fenv/fegetexceptflag.cpp
index 72f31bf..58418cc 100644
--- a/src/fenv/fegetexceptflag.cpp
+++ b/src/fenv/fegetexceptflag.cpp
@@ -10,8 +10,9 @@
 #include "hdr/types/fexcept_t.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fegetexceptflag, (fexcept_t * flagp, int excepts)) {
   static_assert(sizeof(int) >= sizeof(fexcept_t),
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, fegetexceptflag, (fexcept_t * flagp, int excepts)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fegetexceptflag.h b/src/fenv/fegetexceptflag.h
index fcb9598..c427bfb 100644
--- a/src/fenv/fegetexceptflag.h
+++ b/src/fenv/fegetexceptflag.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FEGETEXCEPTFLAG_H
 
 #include "hdr/types/fexcept_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fegetexceptflag(fexcept_t *, int excepts);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEGETEXCEPTFLAG_H
diff --git a/src/fenv/fegetround.cpp b/src/fenv/fegetround.cpp
index edf6eac..4f5caed 100644
--- a/src/fenv/fegetround.cpp
+++ b/src/fenv/fegetround.cpp
@@ -9,9 +9,10 @@
 #include "src/fenv/fegetround.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fegetround, ()) { return fputil::get_round(); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fegetround.h b/src/fenv/fegetround.h
index 40be879..2887c33 100644
--- a/src/fenv/fegetround.h
+++ b/src/fenv/fegetround.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FEGETROUND_H
 #define LLVM_LIBC_SRC_FENV_FEGETROUND_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fegetround();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEGETROUND_H
diff --git a/src/fenv/feholdexcept.cpp b/src/fenv/feholdexcept.cpp
index e5ca257..81b3ea4 100644
--- a/src/fenv/feholdexcept.cpp
+++ b/src/fenv/feholdexcept.cpp
@@ -10,8 +10,9 @@
 #include "hdr/types/fenv_t.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feholdexcept, (fenv_t * envp)) {
   if (fputil::get_env(envp) != 0)
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, feholdexcept, (fenv_t * envp)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/feholdexcept.h b/src/fenv/feholdexcept.h
index e53619e..1882538 100644
--- a/src/fenv/feholdexcept.h
+++ b/src/fenv/feholdexcept.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FEHOLDEXCEPT_H
 
 #include "hdr/types/fenv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int feholdexcept(fenv_t *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEHOLDEXCEPT_H
diff --git a/src/fenv/feraiseexcept.cpp b/src/fenv/feraiseexcept.cpp
index 0bee7f5..6eaa09d 100644
--- a/src/fenv/feraiseexcept.cpp
+++ b/src/fenv/feraiseexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/feraiseexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feraiseexcept, (int e)) {
   return fputil::raise_except(e);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/feraiseexcept.h b/src/fenv/feraiseexcept.h
index a5ab3b9..af62427 100644
--- a/src/fenv/feraiseexcept.h
+++ b/src/fenv/feraiseexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FERAISEEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FERAISEEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int feraiseexcept(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FERAISEEXCEPT_H
diff --git a/src/fenv/fesetenv.cpp b/src/fenv/fesetenv.cpp
index 25ac789..7a9f90a 100644
--- a/src/fenv/fesetenv.cpp
+++ b/src/fenv/fesetenv.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/fesetenv.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fesetenv, (const fenv_t *envp)) {
   return fputil::set_env(envp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fesetenv.h b/src/fenv/fesetenv.h
index 8636711..2f42ebc 100644
--- a/src/fenv/fesetenv.h
+++ b/src/fenv/fesetenv.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FESETENV_H
 
 #include "hdr/types/fenv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fesetenv(const fenv_t *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FESETENV_H
diff --git a/src/fenv/fesetexcept.cpp b/src/fenv/fesetexcept.cpp
index 9afa7b7..8775821 100644
--- a/src/fenv/fesetexcept.cpp
+++ b/src/fenv/fesetexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/fesetexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fesetexcept, (int excepts)) {
   return fputil::set_except(excepts);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fesetexcept.h b/src/fenv/fesetexcept.h
index 40a7303..7b0d8d3 100644
--- a/src/fenv/fesetexcept.h
+++ b/src/fenv/fesetexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FESETEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FESETEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fesetexcept(int excepts);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FESETEXCEPT_H
diff --git a/src/fenv/fesetexceptflag.cpp b/src/fenv/fesetexceptflag.cpp
index 628f33d..9cec9d1 100644
--- a/src/fenv/fesetexceptflag.cpp
+++ b/src/fenv/fesetexceptflag.cpp
@@ -10,8 +10,9 @@
 #include "hdr/types/fexcept_t.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fesetexceptflag,
                    (const fexcept_t *flagp, int excepts)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, fesetexceptflag,
   return fputil::set_except(excepts_to_set);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fesetexceptflag.h b/src/fenv/fesetexceptflag.h
index a018358..7456415 100644
--- a/src/fenv/fesetexceptflag.h
+++ b/src/fenv/fesetexceptflag.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FESETEXCEPTFLAG_H
 
 #include "hdr/types/fexcept_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fesetexceptflag(const fexcept_t *, int excepts);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FESETEXCEPTFLAG_H
diff --git a/src/fenv/fesetround.cpp b/src/fenv/fesetround.cpp
index 22f2b9d..6f65f9f 100644
--- a/src/fenv/fesetround.cpp
+++ b/src/fenv/fesetround.cpp
@@ -9,9 +9,10 @@
 #include "src/fenv/fesetround.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fesetround, (int m)) { return fputil::set_round(m); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fesetround.h b/src/fenv/fesetround.h
index 75023bd..5b15c4f 100644
--- a/src/fenv/fesetround.h
+++ b/src/fenv/fesetround.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FESETROUND_H
 #define LLVM_LIBC_SRC_FENV_FESETROUND_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fesetround(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FESETROUND_H
diff --git a/src/fenv/fetestexcept.cpp b/src/fenv/fetestexcept.cpp
index c284a2c..f4986ac 100644
--- a/src/fenv/fetestexcept.cpp
+++ b/src/fenv/fetestexcept.cpp
@@ -9,11 +9,12 @@
 #include "src/fenv/fetestexcept.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fetestexcept, (int e)) {
   return fputil::test_except(e);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fetestexcept.h b/src/fenv/fetestexcept.h
index dec1ac2..07f30ae 100644
--- a/src/fenv/fetestexcept.h
+++ b/src/fenv/fetestexcept.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_FENV_FETESTEXCEPT_H
 #define LLVM_LIBC_SRC_FENV_FETESTEXCEPT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fetestexcept(int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FETESTEXCEPT_H
diff --git a/src/fenv/fetestexceptflag.cpp b/src/fenv/fetestexceptflag.cpp
index 6345335..03ba1e6 100644
--- a/src/fenv/fetestexceptflag.cpp
+++ b/src/fenv/fetestexceptflag.cpp
@@ -10,8 +10,9 @@
 #include "hdr/types/fexcept_t.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fetestexceptflag,
                    (const fexcept_t *flagp, int excepts)) {
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, fetestexceptflag,
   return *flagp | fputil::test_except(excepts);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/fetestexceptflag.h b/src/fenv/fetestexceptflag.h
index 1c8b0b8..4cf6434 100644
--- a/src/fenv/fetestexceptflag.h
+++ b/src/fenv/fetestexceptflag.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FETESTEXCEPTFLAG_H
 
 #include "hdr/types/fexcept_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fetestexceptflag(const fexcept_t *, int excepts);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FETESTEXCEPTFLAG_H
diff --git a/src/fenv/feupdateenv.cpp b/src/fenv/feupdateenv.cpp
index 0664863..1cc730c 100644
--- a/src/fenv/feupdateenv.cpp
+++ b/src/fenv/feupdateenv.cpp
@@ -11,8 +11,9 @@
 #include "src/__support/common.h"
 
 #include "hdr/types/fenv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feupdateenv, (const fenv_t *envp)) {
   int current_excepts = fputil::test_except(FE_ALL_EXCEPT);
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, feupdateenv, (const fenv_t *envp)) {
   return fputil::raise_except(current_excepts);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/fenv/feupdateenv.h b/src/fenv/feupdateenv.h
index 3c9c88b..52212cb 100644
--- a/src/fenv/feupdateenv.h
+++ b/src/fenv/feupdateenv.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_FENV_FEUPDATEENV_H
 
 #include "hdr/types/fenv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int feupdateenv(const fenv_t *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_FENV_FEUPDATEENV_H
diff --git a/src/gpu/rpc_fprintf.cpp b/src/gpu/rpc_fprintf.cpp
deleted file mode 100644
index 7b0e60b..0000000
--- a/src/gpu/rpc_fprintf.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-//===-- GPU implementation of fprintf -------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "rpc_fprintf.h"
-
-#include "src/__support/CPP/string_view.h"
-#include "src/__support/GPU/utils.h"
-#include "src/__support/RPC/rpc_client.h"
-#include "src/__support/common.h"
-#include "src/stdio/gpu/file.h"
-
-namespace LIBC_NAMESPACE {
-
-template <uint16_t opcode>
-int fprintf_impl(::FILE *__restrict file, const char *__restrict format,
-                 size_t format_size, void *args, size_t args_size) {
-  uint64_t mask = gpu::get_lane_mask();
-  rpc::Client::Port port = rpc::client.open<opcode>();
-
-  if constexpr (opcode == RPC_PRINTF_TO_STREAM) {
-    port.send([&](rpc::Buffer *buffer) {
-      buffer->data[0] = reinterpret_cast<uintptr_t>(file);
-    });
-  }
-
-  port.send_n(format, format_size);
-  port.send_n(args, args_size);
-
-  uint32_t ret = 0;
-  for (;;) {
-    const char *str = nullptr;
-    port.recv([&](rpc::Buffer *buffer) {
-      ret = static_cast<uint32_t>(buffer->data[0]);
-      str = reinterpret_cast<const char *>(buffer->data[1]);
-    });
-    // If any lanes have a string argument it needs to be copied back.
-    if (!gpu::ballot(mask, str))
-      break;
-
-    uint64_t size = str ? internal::string_length(str) + 1 : 0;
-    port.send_n(str, size);
-  }
-
-  port.close();
-  return ret;
-}
-
-// TODO: This is a stand-in function that uses a struct pointer and size in
-// place of varargs. Once varargs support is added we will use that to
-// implement the real version.
-LLVM_LIBC_FUNCTION(int, rpc_fprintf,
-                   (::FILE *__restrict stream, const char *__restrict format,
-                    void *args, size_t size)) {
-  cpp::string_view str(format);
-  if (stream == stdout)
-    return fprintf_impl<RPC_PRINTF_TO_STDOUT>(stream, format, str.size() + 1,
-                                              args, size);
-  else if (stream == stderr)
-    return fprintf_impl<RPC_PRINTF_TO_STDERR>(stream, format, str.size() + 1,
-                                              args, size);
-  else
-    return fprintf_impl<RPC_PRINTF_TO_STREAM>(stream, format, str.size() + 1,
-                                              args, size);
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/gpu/rpc_fprintf.h b/src/gpu/rpc_fprintf.h
deleted file mode 100644
index 053f7b4..0000000
--- a/src/gpu/rpc_fprintf.h
+++ /dev/null
@@ -1,22 +0,0 @@
-//===-- Implementation header for RPC functions -----------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
-#define LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
-
-#include <stddef.h>
-#include <stdio.h>
-
-namespace LIBC_NAMESPACE {
-
-int rpc_fprintf(::FILE *__restrict stream, const char *__restrict format,
-                void *argc, size_t size);
-
-} // namespace LIBC_NAMESPACE
-
-#endif // LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
diff --git a/src/gpu/rpc_host_call.cpp b/src/gpu/rpc_host_call.cpp
index 7b9b9f2..1181e95 100644
--- a/src/gpu/rpc_host_call.cpp
+++ b/src/gpu/rpc_host_call.cpp
@@ -11,19 +11,25 @@
 #include "src/__support/GPU/utils.h"
 #include "src/__support/RPC/rpc_client.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This calls the associated function pointer on the RPC server with the given
 // arguments. We expect that the pointer here is a valid pointer on the server.
-LLVM_LIBC_FUNCTION(void, rpc_host_call, (void *fn, void *data, size_t size)) {
+LLVM_LIBC_FUNCTION(unsigned long long, rpc_host_call,
+                   (void *fn, void *data, size_t size)) {
   rpc::Client::Port port = rpc::client.open<RPC_HOST_CALL>();
   port.send_n(data, size);
-  port.send([=](rpc::Buffer *buffer) {
+  port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = reinterpret_cast<uintptr_t>(fn);
   });
-  port.recv([](rpc::Buffer *) {});
+  unsigned long long ret;
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
+    ret = static_cast<unsigned long long>(buffer->data[0]);
+  });
   port.close();
+  return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/gpu/rpc_host_call.h b/src/gpu/rpc_host_call.h
index 473d90b..861149d 100644
--- a/src/gpu/rpc_host_call.h
+++ b/src/gpu/rpc_host_call.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
 #define LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-void rpc_host_call(void *fn, void *buffer, size_t size);
+unsigned long long rpc_host_call(void *fn, void *buffer, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
diff --git a/src/inttypes/imaxabs.cpp b/src/inttypes/imaxabs.cpp
index b390676..385fd9b 100644
--- a/src/inttypes/imaxabs.cpp
+++ b/src/inttypes/imaxabs.cpp
@@ -9,9 +9,10 @@
 #include "src/inttypes/imaxabs.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(intmax_t, imaxabs, (intmax_t j)) { return integer_abs(j); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/inttypes/imaxabs.h b/src/inttypes/imaxabs.h
index cd30011..4cc39e2 100644
--- a/src/inttypes/imaxabs.h
+++ b/src/inttypes/imaxabs.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_INTTYPES_IMAXABS_H
 #define LLVM_LIBC_SRC_INTTYPES_IMAXABS_H
 
+#include "src/__support/macros/config.h"
 #include <inttypes.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 intmax_t imaxabs(intmax_t j);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_INTTYPES_IMAXABS_H
diff --git a/src/inttypes/imaxdiv.cpp b/src/inttypes/imaxdiv.cpp
index 77f0cc5..4b878d5 100644
--- a/src/inttypes/imaxdiv.cpp
+++ b/src/inttypes/imaxdiv.cpp
@@ -9,8 +9,9 @@
 #include "src/inttypes/imaxdiv.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(imaxdiv_t, imaxdiv, (intmax_t x, intmax_t y)) {
   imaxdiv_t res;
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(imaxdiv_t, imaxdiv, (intmax_t x, intmax_t y)) {
   return res;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/inttypes/imaxdiv.h b/src/inttypes/imaxdiv.h
index 7491227..6dbefaf 100644
--- a/src/inttypes/imaxdiv.h
+++ b/src/inttypes/imaxdiv.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_INTTYPES_IMAXDIV_H
 #define LLVM_LIBC_SRC_INTTYPES_IMAXDIV_H
 
+#include "src/__support/macros/config.h"
 #include <inttypes.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 imaxdiv_t imaxdiv(intmax_t x, intmax_t y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_INTTYPES_IMAXDIV_H
diff --git a/src/inttypes/strtoimax.cpp b/src/inttypes/strtoimax.cpp
index 459877e..85f197c 100644
--- a/src/inttypes/strtoimax.cpp
+++ b/src/inttypes/strtoimax.cpp
@@ -8,10 +8,11 @@
 
 #include "src/inttypes/strtoimax.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(intmax_t, strtoimax,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(intmax_t, strtoimax,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/inttypes/strtoimax.h b/src/inttypes/strtoimax.h
index b72547f..804d07c 100644
--- a/src/inttypes/strtoimax.h
+++ b/src/inttypes/strtoimax.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_INTTYPES_STRTOIMAX_H
 #define LLVM_LIBC_SRC_INTTYPES_STRTOIMAX_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 intmax_t strtoimax(const char *__restrict str, char **__restrict str_end,
                    int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_INTTYPES_STRTOIMAX_H
diff --git a/src/inttypes/strtoumax.cpp b/src/inttypes/strtoumax.cpp
index 4011a17..2e9cbc9 100644
--- a/src/inttypes/strtoumax.cpp
+++ b/src/inttypes/strtoumax.cpp
@@ -8,10 +8,11 @@
 
 #include "src/inttypes/strtoumax.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uintmax_t, strtoumax,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(uintmax_t, strtoumax,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/inttypes/strtoumax.h b/src/inttypes/strtoumax.h
index d59e993..4c53c03 100644
--- a/src/inttypes/strtoumax.h
+++ b/src/inttypes/strtoumax.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_INTTYPES_STRTOUMAX_H
 #define LLVM_LIBC_SRC_INTTYPES_STRTOUMAX_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uintmax_t strtoumax(const char *__restrict str, char **__restrict str_end,
                     int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_INTTYPES_STRTOUMAX_H
diff --git a/src/locale/duplocale.cpp b/src/locale/duplocale.cpp
new file mode 100644
index 0000000..d1bd083
--- /dev/null
+++ b/src/locale/duplocale.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of duplocale ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/duplocale.h"
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/locale/locale.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(locale_t, duplocale, (locale_t loc)) { return loc; }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/duplocale.h b/src/locale/duplocale.h
new file mode 100644
index 0000000..a745383
--- /dev/null
+++ b/src/locale/duplocale.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for duplocale ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_DUPLOCALE_H
+#define LLVM_LIBC_SRC_LOCALE_DUPLOCALE_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+locale_t duplocale(locale_t loc);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_DUPLOCALE_H
diff --git a/src/locale/freelocale.cpp b/src/locale/freelocale.cpp
new file mode 100644
index 0000000..2008995
--- /dev/null
+++ b/src/locale/freelocale.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of freelocale --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/freelocale.h"
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/locale/locale.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void, freelocale, (locale_t)) {}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/freelocale.h b/src/locale/freelocale.h
new file mode 100644
index 0000000..77ece30
--- /dev/null
+++ b/src/locale/freelocale.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for freelocale --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_FREELOCALE_H
+#define LLVM_LIBC_SRC_LOCALE_FREELOCALE_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+void freelocale(locale_t loc);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_FREELOCALE_H
diff --git a/src/locale/locale.cpp b/src/locale/locale.cpp
new file mode 100644
index 0000000..1610fb5
--- /dev/null
+++ b/src/locale/locale.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of locale ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/locale.h"
+
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+__locale_t c_locale = {nullptr};
+
+locale_t locale = nullptr;
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/locale.h b/src/locale/locale.h
new file mode 100644
index 0000000..14befa6
--- /dev/null
+++ b/src/locale/locale.h
@@ -0,0 +1,36 @@
+//===-- Implementation header for the locale --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
+#define LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
+
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+// We only support the "C" locale right now.
+static constexpr size_t MAX_LOCALE_NAME_SIZE = 2;
+
+struct __locale_data {
+  char name[MAX_LOCALE_NAME_SIZE];
+};
+
+// The pointer to the default "C" locale.
+extern __locale_t c_locale;
+
+// The global locale instance.
+extern locale_t locale;
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
diff --git a/src/locale/localeconv.cpp b/src/locale/localeconv.cpp
new file mode 100644
index 0000000..e4d7536
--- /dev/null
+++ b/src/locale/localeconv.cpp
@@ -0,0 +1,49 @@
+//===-- Implementation of localeconv --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/localeconv.h"
+
+#include "src/__support/CPP/limits.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static char DOT_STRING[] = ".";
+static char EMPTY_STRING[] = "";
+
+static struct lconv C_LCONV = {
+    .decimal_point = DOT_STRING,
+    .thousands_sep = EMPTY_STRING,
+    .grouping = EMPTY_STRING,
+    .mon_decimal_point = EMPTY_STRING,
+    .mon_thousands_sep = EMPTY_STRING,
+    .mon_grouping = EMPTY_STRING,
+    .positive_sign = EMPTY_STRING,
+    .negative_sign = EMPTY_STRING,
+    .currency_symbol = EMPTY_STRING,
+    .frac_digits = CHAR_MAX,
+    .p_cs_precedes = CHAR_MAX,
+    .n_cs_precedes = CHAR_MAX,
+    .p_sep_by_space = CHAR_MAX,
+    .n_sep_by_space = CHAR_MAX,
+    .p_sign_posn = CHAR_MAX,
+    .n_sign_posn = CHAR_MAX,
+    .int_curr_symbol = EMPTY_STRING,
+    .int_frac_digits = CHAR_MAX,
+    .int_p_cs_precedes = CHAR_MAX,
+    .int_n_cs_precedes = CHAR_MAX,
+    .int_p_sep_by_space = CHAR_MAX,
+    .int_n_sep_by_space = CHAR_MAX,
+    .int_p_sign_posn = CHAR_MAX,
+    .int_n_sign_posn = CHAR_MAX,
+};
+
+LLVM_LIBC_FUNCTION(struct lconv *, localeconv, ()) { return &C_LCONV; }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/localeconv.h b/src/locale/localeconv.h
new file mode 100644
index 0000000..a8f7599
--- /dev/null
+++ b/src/locale/localeconv.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for localeconv --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
+#define LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
+
+#include "src/__support/macros/config.h"
+
+#include "include/llvm-libc-types/struct_lconv.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+struct lconv *localeconv();
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_LOCALECONV_H
diff --git a/src/locale/newlocale.cpp b/src/locale/newlocale.cpp
new file mode 100644
index 0000000..379e7e6
--- /dev/null
+++ b/src/locale/newlocale.cpp
@@ -0,0 +1,28 @@
+//===-- Implementation of newlocale ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/newlocale.h"
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/locale/locale.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(locale_t, newlocale,
+                   (int category_mask, const char *locale_name, locale_t)) {
+  cpp::string_view name(locale_name);
+  if (category_mask > LC_ALL || (!name.empty() && name != "C"))
+    return nullptr;
+
+  return &c_locale;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/newlocale.h b/src/locale/newlocale.h
new file mode 100644
index 0000000..08a0071
--- /dev/null
+++ b/src/locale/newlocale.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for setlocale ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
+#define LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+locale_t newlocale(int category_mask, const char *locale_name, locale_t base);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
diff --git a/src/locale/setlocale.cpp b/src/locale/setlocale.cpp
new file mode 100644
index 0000000..0950ad7
--- /dev/null
+++ b/src/locale/setlocale.cpp
@@ -0,0 +1,28 @@
+//===-- Implementation of setlocale ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/setlocale.h"
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/locale/locale.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(char *, setlocale, (int category, const char *locale_name)) {
+  cpp::string_view name(locale_name);
+  if (category > LC_ALL || (!name.empty() && name != "C"))
+    return nullptr;
+
+  static char locale_str[] = "C";
+  return locale_str;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/setlocale.h b/src/locale/setlocale.h
new file mode 100644
index 0000000..a9213cf
--- /dev/null
+++ b/src/locale/setlocale.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for setlocale ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
+#define LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+char *setlocale(int category, const char *locale_name);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
diff --git a/src/locale/uselocale.cpp b/src/locale/uselocale.cpp
new file mode 100644
index 0000000..d6fdad2
--- /dev/null
+++ b/src/locale/uselocale.cpp
@@ -0,0 +1,23 @@
+//===-- Implementation of uselocale ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/uselocale.h"
+#include "src/locale/locale.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(locale_t, uselocale, (locale_t newloc)) {
+  if (!newloc)
+    return locale;
+  return locale = newloc;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/locale/uselocale.h b/src/locale/uselocale.h
new file mode 100644
index 0000000..1540349
--- /dev/null
+++ b/src/locale/uselocale.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for uselocale ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_LOCALE_USELOCALE_H
+#define LLVM_LIBC_SRC_LOCALE_USELOCALE_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/locale_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+locale_t uselocale(locale_t newloc);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_LOCALE_USELOCALE_H
diff --git a/src/math/aarch64/round.cpp b/src/math/aarch64/round.cpp
deleted file mode 100644
index 8972c16..0000000
--- a/src/math/aarch64/round.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//===-- Implementation of the round function for aarch64 ------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/math/round.h"
-#include "src/__support/common.h"
-
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(double, round, (double x)) {
-  double y;
-  __asm__ __volatile__("frinta %d0, %d1\n\t" : "=w"(y) : "w"(x));
-  return y;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/math/aarch64/roundf.cpp b/src/math/aarch64/roundf.cpp
deleted file mode 100644
index 8b3a9cf..0000000
--- a/src/math/aarch64/roundf.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//===-- Implementation of the roundf function for aarch64 -----------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/math/roundf.h"
-#include "src/__support/common.h"
-
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(float, roundf, (float x)) {
-  float y;
-  __asm__ __volatile__("frinta %s0, %s1\n\t" : "=w"(y) : "w"(x));
-  return y;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/math/aarch64/trunc.cpp b/src/math/aarch64/trunc.cpp
deleted file mode 100644
index 34ffd17..0000000
--- a/src/math/aarch64/trunc.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//===-- Implementation of the trunc function for aarch64 ------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/math/trunc.h"
-#include "src/__support/common.h"
-
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(double, trunc, (double x)) {
-  double y;
-  __asm__ __volatile__("frintz %d0, %d1\n" : "=w"(y) : "w"(x));
-  return y;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/math/aarch64/truncf.cpp b/src/math/aarch64/truncf.cpp
deleted file mode 100644
index fc2426f..0000000
--- a/src/math/aarch64/truncf.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//===-- Implementation of the truncf function for aarch64 -----------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/math/truncf.h"
-#include "src/__support/common.h"
-
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(float, truncf, (float x)) {
-  float y;
-  __asm__ __volatile__("frintz %s0, %s1\n\t" : "=w"(y) : "w"(x));
-  return y;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/math/acos.h b/src/math/acos.h
index da89a9d..fed59e2 100644
--- a/src/math/acos.h
+++ b/src/math/acos.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ACOS_H
 #define LLVM_LIBC_SRC_MATH_ACOS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double acos(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ACOS_H
diff --git a/src/math/acosf.h b/src/math/acosf.h
index 3221efa..839f7df 100644
--- a/src/math/acosf.h
+++ b/src/math/acosf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ACOSF_H
 #define LLVM_LIBC_SRC_MATH_ACOSF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float acosf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ACOSF_H
diff --git a/src/math/acosh.h b/src/math/acosh.h
index a5bbd82..7d59b6c 100644
--- a/src/math/acosh.h
+++ b/src/math/acosh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ACOSH_H
 #define LLVM_LIBC_SRC_MATH_ACOSH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double acosh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ACOSH_H
diff --git a/src/math/acoshf.h b/src/math/acoshf.h
index aac43b4..a6f08bd 100644
--- a/src/math/acoshf.h
+++ b/src/math/acoshf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ACOSHF_H
 #define LLVM_LIBC_SRC_MATH_ACOSHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float acoshf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ACOSHF_H
diff --git a/src/math/amdgpu/acos.cpp b/src/math/amdgpu/acos.cpp
index b1e30fe..de870f2 100644
--- a/src/math/amdgpu/acos.cpp
+++ b/src/math/amdgpu/acos.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, acos, (double x)) { return __ocml_acos_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/acosf.cpp b/src/math/amdgpu/acosf.cpp
index 4c2dd4b..0a72a70 100644
--- a/src/math/amdgpu/acosf.cpp
+++ b/src/math/amdgpu/acosf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, acosf, (float x)) { return __ocml_acos_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/acosh.cpp b/src/math/amdgpu/acosh.cpp
index dcdeeab..15c9734 100644
--- a/src/math/amdgpu/acosh.cpp
+++ b/src/math/amdgpu/acosh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, acosh, (double x)) { return __ocml_acosh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/acoshf.cpp b/src/math/amdgpu/acoshf.cpp
index 52baa2e..79e71b0 100644
--- a/src/math/amdgpu/acoshf.cpp
+++ b/src/math/amdgpu/acoshf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, acoshf, (float x)) { return __ocml_acosh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/asin.cpp b/src/math/amdgpu/asin.cpp
index 835c317..a79641e 100644
--- a/src/math/amdgpu/asin.cpp
+++ b/src/math/amdgpu/asin.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, asin, (double x)) { return __ocml_asin_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/asinf.cpp b/src/math/amdgpu/asinf.cpp
index 72c45d5..e70944a 100644
--- a/src/math/amdgpu/asinf.cpp
+++ b/src/math/amdgpu/asinf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, asinf, (float x)) { return __ocml_asin_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/asinh.cpp b/src/math/amdgpu/asinh.cpp
index 7a9f7ea..6423685 100644
--- a/src/math/amdgpu/asinh.cpp
+++ b/src/math/amdgpu/asinh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, asinh, (double x)) { return __ocml_asinh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/asinhf.cpp b/src/math/amdgpu/asinhf.cpp
index 28d6bde..bafa77f 100644
--- a/src/math/amdgpu/asinhf.cpp
+++ b/src/math/amdgpu/asinhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, asinhf, (float x)) { return __ocml_asinh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atan.cpp b/src/math/amdgpu/atan.cpp
index a1fa38b..49941e9 100644
--- a/src/math/amdgpu/atan.cpp
+++ b/src/math/amdgpu/atan.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atan, (double x)) { return __ocml_atan_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atan2.cpp b/src/math/amdgpu/atan2.cpp
index 9cfdba7..f590750 100644
--- a/src/math/amdgpu/atan2.cpp
+++ b/src/math/amdgpu/atan2.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atan2, (double x, double y)) {
   return __ocml_atan2_f64(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atan2f.cpp b/src/math/amdgpu/atan2f.cpp
index ef56293..736c77d 100644
--- a/src/math/amdgpu/atan2f.cpp
+++ b/src/math/amdgpu/atan2f.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atan2f, (float x, float y)) {
   return __ocml_atan2_f32(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atanf.cpp b/src/math/amdgpu/atanf.cpp
index bbcceca..ab1837d 100644
--- a/src/math/amdgpu/atanf.cpp
+++ b/src/math/amdgpu/atanf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanf, (float x)) { return __ocml_atan_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atanh.cpp b/src/math/amdgpu/atanh.cpp
index ec46258..091c155 100644
--- a/src/math/amdgpu/atanh.cpp
+++ b/src/math/amdgpu/atanh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atanh, (double x)) { return __ocml_atanh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/atanhf.cpp b/src/math/amdgpu/atanhf.cpp
index 2272693..fa9cf39 100644
--- a/src/math/amdgpu/atanhf.cpp
+++ b/src/math/amdgpu/atanhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanhf, (float x)) { return __ocml_atanh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ceil.cpp b/src/math/amdgpu/ceil.cpp
index ad1407d..8834c7b 100644
--- a/src/math/amdgpu/ceil.cpp
+++ b/src/math/amdgpu/ceil.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/ceil.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ceil, (double x)) { return __builtin_ceil(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ceilf.cpp b/src/math/amdgpu/ceilf.cpp
index c4fc58d..5d26a30 100644
--- a/src/math/amdgpu/ceilf.cpp
+++ b/src/math/amdgpu/ceilf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/ceilf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ceilf, (float x)) { return __builtin_ceilf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/copysign.cpp b/src/math/amdgpu/copysign.cpp
index 6f804bd..06ef36f 100644
--- a/src/math/amdgpu/copysign.cpp
+++ b/src/math/amdgpu/copysign.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/copysign.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, copysign, (double x, double y)) {
   return __builtin_copysign(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/copysignf.cpp b/src/math/amdgpu/copysignf.cpp
index 4d7e132..aea94f3 100644
--- a/src/math/amdgpu/copysignf.cpp
+++ b/src/math/amdgpu/copysignf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/copysignf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, copysignf, (float x, float y)) {
   return __builtin_copysignf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/cos.cpp b/src/math/amdgpu/cos.cpp
index 68239d9..a4d4c94 100644
--- a/src/math/amdgpu/cos.cpp
+++ b/src/math/amdgpu/cos.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, cos, (double x)) { return __ocml_cos_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/cosf.cpp b/src/math/amdgpu/cosf.cpp
index a60e9ea..99ec118 100644
--- a/src/math/amdgpu/cosf.cpp
+++ b/src/math/amdgpu/cosf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, cosf, (float x)) { return __ocml_cos_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/cosh.cpp b/src/math/amdgpu/cosh.cpp
index b71df0c..d94d7af 100644
--- a/src/math/amdgpu/cosh.cpp
+++ b/src/math/amdgpu/cosh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, cosh, (double x)) { return __ocml_cosh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/coshf.cpp b/src/math/amdgpu/coshf.cpp
index 699fb04..5b641be 100644
--- a/src/math/amdgpu/coshf.cpp
+++ b/src/math/amdgpu/coshf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, coshf, (float x)) { return __ocml_cosh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/declarations.h b/src/math/amdgpu/declarations.h
index 5d7f3c9..88e2201 100644
--- a/src/math/amdgpu/declarations.h
+++ b/src/math/amdgpu/declarations.h
@@ -12,8 +12,9 @@
 #include "platform.h"
 
 #include "src/__support/GPU/utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 extern "C" {
 float __ocml_acos_f32(float);
@@ -65,6 +66,8 @@ float __ocml_nextafter_f32(float, float);
 double __ocml_nextafter_f64(double, double);
 float __ocml_pow_f32(float, float);
 double __ocml_pow_f64(double, double);
+float __ocml_pown_f32(float, int);
+double __ocml_pown_f64(double, int);
 float __ocml_sin_f32(float);
 double __ocml_sin_f64(double);
 float __ocml_sincos_f32(float, float *);
@@ -79,8 +82,10 @@ float __ocml_remquo_f32(float, float, gpu::Private<int> *);
 double __ocml_remquo_f64(double, double, gpu::Private<int> *);
 double __ocml_tgamma_f64(double);
 float __ocml_tgamma_f32(float);
+double __ocml_lgamma_f64(double);
+double __ocml_lgamma_r_f64(double, gpu::Private<int> *);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_AMDGPU_DECLARATIONS_H
diff --git a/src/math/amdgpu/erf.cpp b/src/math/amdgpu/erf.cpp
index 7a46455..07ae268 100644
--- a/src/math/amdgpu/erf.cpp
+++ b/src/math/amdgpu/erf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, erf, (double x)) { return __ocml_erf_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/erff.cpp b/src/math/amdgpu/erff.cpp
index 1f77d08..a4b7b27 100644
--- a/src/math/amdgpu/erff.cpp
+++ b/src/math/amdgpu/erff.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, erff, (float x)) { return __ocml_erf_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/exp.cpp b/src/math/amdgpu/exp.cpp
index d19c73d..dae79be 100644
--- a/src/math/amdgpu/exp.cpp
+++ b/src/math/amdgpu/exp.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp, (double x)) { return __ocml_exp_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/exp10.cpp b/src/math/amdgpu/exp10.cpp
index 17d8f33..f13d218 100644
--- a/src/math/amdgpu/exp10.cpp
+++ b/src/math/amdgpu/exp10.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp10, (double x)) { return __ocml_exp10_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/exp10f.cpp b/src/math/amdgpu/exp10f.cpp
index ddab555..883e734 100644
--- a/src/math/amdgpu/exp10f.cpp
+++ b/src/math/amdgpu/exp10f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp10f, (float x)) { return __ocml_exp10_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/exp2.cpp b/src/math/amdgpu/exp2.cpp
index dfbb1f8..fb336cf 100644
--- a/src/math/amdgpu/exp2.cpp
+++ b/src/math/amdgpu/exp2.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp2, (double x)) { return __ocml_exp2_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/exp2f.cpp b/src/math/amdgpu/exp2f.cpp
index 016dfe3..77b4a9c 100644
--- a/src/math/amdgpu/exp2f.cpp
+++ b/src/math/amdgpu/exp2f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp2f, (float x)) { return __ocml_exp2_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/expf.cpp b/src/math/amdgpu/expf.cpp
index 3339307..6c44aad 100644
--- a/src/math/amdgpu/expf.cpp
+++ b/src/math/amdgpu/expf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expf, (float x)) { return __ocml_exp_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/expm1.cpp b/src/math/amdgpu/expm1.cpp
index d2ac28a..df3643f 100644
--- a/src/math/amdgpu/expm1.cpp
+++ b/src/math/amdgpu/expm1.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, expm1, (double x)) { return __ocml_expm1_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/expm1f.cpp b/src/math/amdgpu/expm1f.cpp
index 0ffe1a3..2409997 100644
--- a/src/math/amdgpu/expm1f.cpp
+++ b/src/math/amdgpu/expm1f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expm1f, (float x)) { return __ocml_expm1_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fabs.cpp b/src/math/amdgpu/fabs.cpp
index c0d063d..bb37596 100644
--- a/src/math/amdgpu/fabs.cpp
+++ b/src/math/amdgpu/fabs.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/fabs.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fabs, (double x)) { return __builtin_fabs(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fabsf.cpp b/src/math/amdgpu/fabsf.cpp
index 398ffd0..2698618 100644
--- a/src/math/amdgpu/fabsf.cpp
+++ b/src/math/amdgpu/fabsf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/fabsf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fabsf, (float x)) { return __builtin_fabsf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fdim.cpp b/src/math/amdgpu/fdim.cpp
index f16942d..8ade0b2 100644
--- a/src/math/amdgpu/fdim.cpp
+++ b/src/math/amdgpu/fdim.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fdim, (double x, double y)) {
   return __ocml_fdim_f64(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fdimf.cpp b/src/math/amdgpu/fdimf.cpp
index eccb441..ed3855e 100644
--- a/src/math/amdgpu/fdimf.cpp
+++ b/src/math/amdgpu/fdimf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fdimf, (float x, float y)) {
   return __ocml_fdim_f32(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/floor.cpp b/src/math/amdgpu/floor.cpp
index eada89c..564efa9 100644
--- a/src/math/amdgpu/floor.cpp
+++ b/src/math/amdgpu/floor.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/floor.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, floor, (double x)) { return __builtin_floor(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/floorf.cpp b/src/math/amdgpu/floorf.cpp
index a5611c5..6717c8f 100644
--- a/src/math/amdgpu/floorf.cpp
+++ b/src/math/amdgpu/floorf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/floorf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, floorf, (float x)) { return __builtin_floorf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fma.cpp b/src/math/amdgpu/fma.cpp
index 41a6ddf..c4a117e 100644
--- a/src/math/amdgpu/fma.cpp
+++ b/src/math/amdgpu/fma.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fma.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fma, (double x, double y, double z)) {
   return __builtin_fma(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmaf.cpp b/src/math/amdgpu/fmaf.cpp
index c948e32..c088bd5 100644
--- a/src/math/amdgpu/fmaf.cpp
+++ b/src/math/amdgpu/fmaf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmaf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaf, (float x, float y, float z)) {
   return __builtin_fmaf(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmax.cpp b/src/math/amdgpu/fmax.cpp
index 09f0f94..4740197 100644
--- a/src/math/amdgpu/fmax.cpp
+++ b/src/math/amdgpu/fmax.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmax, (double x, double y)) {
   return __builtin_fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmaxf.cpp b/src/math/amdgpu/fmaxf.cpp
index 5913a85..59ee825 100644
--- a/src/math/amdgpu/fmaxf.cpp
+++ b/src/math/amdgpu/fmaxf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaxf.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaxf, (float x, float y)) {
   return __builtin_fmaxf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmin.cpp b/src/math/amdgpu/fmin.cpp
index 0d6f352..694eb66 100644
--- a/src/math/amdgpu/fmin.cpp
+++ b/src/math/amdgpu/fmin.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmin.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmin, (double x, double y)) {
   return __builtin_fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fminf.cpp b/src/math/amdgpu/fminf.cpp
index 42744ab..2060b71 100644
--- a/src/math/amdgpu/fminf.cpp
+++ b/src/math/amdgpu/fminf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminf.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminf, (float x, float y)) {
   return __builtin_fminf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmod.cpp b/src/math/amdgpu/fmod.cpp
index 0654cdd..49d19c4 100644
--- a/src/math/amdgpu/fmod.cpp
+++ b/src/math/amdgpu/fmod.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmod, (double x, double y)) {
   return __builtin_fmod(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/fmodf.cpp b/src/math/amdgpu/fmodf.cpp
index b689046..8fbcb0c 100644
--- a/src/math/amdgpu/fmodf.cpp
+++ b/src/math/amdgpu/fmodf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmodf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmodf, (float x, float y)) {
   return __builtin_fmodf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/frexp.cpp b/src/math/amdgpu/frexp.cpp
index 0acf973..00e5187 100644
--- a/src/math/amdgpu/frexp.cpp
+++ b/src/math/amdgpu/frexp.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, frexp, (double x, int *p)) {
   return __builtin_frexp(x, p);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/frexpf.cpp b/src/math/amdgpu/frexpf.cpp
index d870bf3..2799e54 100644
--- a/src/math/amdgpu/frexpf.cpp
+++ b/src/math/amdgpu/frexpf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, frexpf, (float x, int *p)) {
   return __builtin_frexpf(x, p);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/hypot.cpp b/src/math/amdgpu/hypot.cpp
index ffc1350..dcf1152 100644
--- a/src/math/amdgpu/hypot.cpp
+++ b/src/math/amdgpu/hypot.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, hypot, (double x, double y)) {
   return __ocml_hypot_f64(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/hypotf.cpp b/src/math/amdgpu/hypotf.cpp
index 811fc54..68ec659 100644
--- a/src/math/amdgpu/hypotf.cpp
+++ b/src/math/amdgpu/hypotf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, hypotf, (float x, float y)) {
   return __ocml_hypot_f32(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ilogb.cpp b/src/math/amdgpu/ilogb.cpp
index 4479908..37f24df 100644
--- a/src/math/amdgpu/ilogb.cpp
+++ b/src/math/amdgpu/ilogb.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogb, (double x)) { return __ocml_ilogb_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ilogbf.cpp b/src/math/amdgpu/ilogbf.cpp
index cded285..56e74e1 100644
--- a/src/math/amdgpu/ilogbf.cpp
+++ b/src/math/amdgpu/ilogbf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbf, (float x)) { return __ocml_ilogb_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ldexp.cpp b/src/math/amdgpu/ldexp.cpp
index 70c5b0d..393eabb 100644
--- a/src/math/amdgpu/ldexp.cpp
+++ b/src/math/amdgpu/ldexp.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ldexp, (double x, int y)) {
   return __builtin_ldexp(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/ldexpf.cpp b/src/math/amdgpu/ldexpf.cpp
index 8dc7c13..970603d 100644
--- a/src/math/amdgpu/ldexpf.cpp
+++ b/src/math/amdgpu/ldexpf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ldexpf, (float x, int y)) {
   return __builtin_ldexpf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/aarch64/ceilf.cpp b/src/math/amdgpu/lgamma.cpp
similarity index 52%
rename from src/math/aarch64/ceilf.cpp
rename to src/math/amdgpu/lgamma.cpp
index 3cbcc1f..acff4c7 100644
--- a/src/math/aarch64/ceilf.cpp
+++ b/src/math/amdgpu/lgamma.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the ceilf function for aarch64 ------------------===//
+//===-- Implementation of the lgamma function for GPU ---------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,15 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/ceilf.h"
+#include "src/math/lgamma.h"
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+#include "declarations.h"
+#include "src/__support/macros/config.h"
 
-LLVM_LIBC_FUNCTION(float, ceilf, (float x)) {
-  float y;
-  __asm__ __volatile__("frintp %s0, %s1\n\t" : "=w"(y) : "w"(x));
-  return y;
-}
+namespace LIBC_NAMESPACE_DECL {
 
-} // namespace LIBC_NAMESPACE
+LLVM_LIBC_FUNCTION(double, lgamma, (double x)) { return __ocml_lgamma_f64(x); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/lgamma_r.cpp b/src/math/amdgpu/lgamma_r.cpp
new file mode 100644
index 0000000..0a79988
--- /dev/null
+++ b/src/math/amdgpu/lgamma_r.cpp
@@ -0,0 +1,24 @@
+//===-- Implementation of the lgamma_r function for GPU -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/lgamma_r.h"
+#include "src/__support/common.h"
+
+#include "declarations.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, lgamma_r, (double x, int *signp)) {
+  int tmp = *signp;
+  double r = __ocml_lgamma_r_f64(x, (gpu::Private<int> *)&tmp);
+  *signp = tmp;
+  return r;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/llrint.cpp b/src/math/amdgpu/llrint.cpp
index 307420a..21129fe 100644
--- a/src/math/amdgpu/llrint.cpp
+++ b/src/math/amdgpu/llrint.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrint, (double x)) {
   return static_cast<long long>(__builtin_rint(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/llrintf.cpp b/src/math/amdgpu/llrintf.cpp
index 2340499..a6f9f43 100644
--- a/src/math/amdgpu/llrintf.cpp
+++ b/src/math/amdgpu/llrintf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrintf, (float x)) {
   return static_cast<long long>(__builtin_rintf(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log.cpp b/src/math/amdgpu/log.cpp
index 3f24895..bd01adf 100644
--- a/src/math/amdgpu/log.cpp
+++ b/src/math/amdgpu/log.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log, (double x)) { return __ocml_log_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log10.cpp b/src/math/amdgpu/log10.cpp
index d522d5e..75957c9 100644
--- a/src/math/amdgpu/log10.cpp
+++ b/src/math/amdgpu/log10.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log10, (double x)) { return __ocml_log10_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log10f.cpp b/src/math/amdgpu/log10f.cpp
index 47b9b16..9c12d6b 100644
--- a/src/math/amdgpu/log10f.cpp
+++ b/src/math/amdgpu/log10f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log10f, (float x)) { return __ocml_log10_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log1p.cpp b/src/math/amdgpu/log1p.cpp
index fae60e4..fc27519 100644
--- a/src/math/amdgpu/log1p.cpp
+++ b/src/math/amdgpu/log1p.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log1p, (double x)) { return __ocml_log1p_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log1pf.cpp b/src/math/amdgpu/log1pf.cpp
index e7b1772..b2d26fb 100644
--- a/src/math/amdgpu/log1pf.cpp
+++ b/src/math/amdgpu/log1pf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log1pf, (float x)) { return __ocml_log1p_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log2.cpp b/src/math/amdgpu/log2.cpp
index 9d84f62..73f34b6 100644
--- a/src/math/amdgpu/log2.cpp
+++ b/src/math/amdgpu/log2.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log2, (double x)) { return __ocml_log2_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/log2f.cpp b/src/math/amdgpu/log2f.cpp
index 7742a61..3b62eda 100644
--- a/src/math/amdgpu/log2f.cpp
+++ b/src/math/amdgpu/log2f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log2f, (float x)) { return __ocml_log2_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/logb.cpp b/src/math/amdgpu/logb.cpp
index 1344fbb..4b68e28 100644
--- a/src/math/amdgpu/logb.cpp
+++ b/src/math/amdgpu/logb.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, logb, (double x)) { return __ocml_logb_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/logbf.cpp b/src/math/amdgpu/logbf.cpp
index fdb493f..bc7c462 100644
--- a/src/math/amdgpu/logbf.cpp
+++ b/src/math/amdgpu/logbf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logbf, (float x)) { return __ocml_logb_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/logf.cpp b/src/math/amdgpu/logf.cpp
index d4d4b26..1792567 100644
--- a/src/math/amdgpu/logf.cpp
+++ b/src/math/amdgpu/logf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logf, (float x)) { return __ocml_log_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/lrint.cpp b/src/math/amdgpu/lrint.cpp
index b335b4f..715b552 100644
--- a/src/math/amdgpu/lrint.cpp
+++ b/src/math/amdgpu/lrint.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrint, (double x)) {
   return static_cast<long>(__builtin_rint(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/lrintf.cpp b/src/math/amdgpu/lrintf.cpp
index 7959e76..3870638 100644
--- a/src/math/amdgpu/lrintf.cpp
+++ b/src/math/amdgpu/lrintf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintf, (float x)) {
   return static_cast<long>(__builtin_rintf(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/nearbyint.cpp b/src/math/amdgpu/nearbyint.cpp
index 9c7b600..7d78c72 100644
--- a/src/math/amdgpu/nearbyint.cpp
+++ b/src/math/amdgpu/nearbyint.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/nearbyint.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nearbyint, (double x)) {
   return __builtin_nearbyint(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/nearbyintf.cpp b/src/math/amdgpu/nearbyintf.cpp
index 7fbe9f4..4bd20dc 100644
--- a/src/math/amdgpu/nearbyintf.cpp
+++ b/src/math/amdgpu/nearbyintf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/nearbyintf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nearbyintf, (float x)) {
   return __builtin_nearbyintf(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/nextafter.cpp b/src/math/amdgpu/nextafter.cpp
index 5c74ef1..226b8a5 100644
--- a/src/math/amdgpu/nextafter.cpp
+++ b/src/math/amdgpu/nextafter.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nextafter, (double x, double y)) {
   return __ocml_nextafter_f64(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/nextafterf.cpp b/src/math/amdgpu/nextafterf.cpp
index a97b990..7bed2c1 100644
--- a/src/math/amdgpu/nextafterf.cpp
+++ b/src/math/amdgpu/nextafterf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nextafterf, (float x, float y)) {
   return __ocml_nextafter_f32(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/platform.h b/src/math/amdgpu/platform.h
index 29d6cac..472a983 100644
--- a/src/math/amdgpu/platform.h
+++ b/src/math/amdgpu/platform.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC_MATH_AMDGPU_PLATFORM_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The ROCm device library uses control globals to alter codegen for the
 // different targets. To avoid needing to link them in manually we simply
@@ -49,6 +50,6 @@ extern const LIBC_INLINE_VAR uint32_t __oclc_ISA_version = 9000;
 [[gnu::alias("__oclc_finite_only_opt")]] const uint8_t __oclc_finite_only_opt__;
 [[gnu::alias("__oclc_ISA_version")]] const uint32_t __oclc_ISA_version__;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_AMDGPU_PLATFORM_H
diff --git a/src/math/amdgpu/powf.cpp b/src/math/amdgpu/powf.cpp
index 6114bcc..6931934 100644
--- a/src/math/amdgpu/powf.cpp
+++ b/src/math/amdgpu/powf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   return __ocml_pow_f32(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/powi.cpp b/src/math/amdgpu/powi.cpp
new file mode 100644
index 0000000..6b31b47
--- /dev/null
+++ b/src/math/amdgpu/powi.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of the powi function for GPU -----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/powi.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#include "declarations.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, powi, (double x, int y)) {
+  return __ocml_pown_f64(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/powif.cpp b/src/math/amdgpu/powif.cpp
new file mode 100644
index 0000000..94f8a91
--- /dev/null
+++ b/src/math/amdgpu/powif.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of the powi function for GPU -----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/powif.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#include "declarations.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, powif, (float x, int y)) {
+  return __ocml_pown_f32(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/remainder.cpp b/src/math/amdgpu/remainder.cpp
index 89b235f..9027204 100644
--- a/src/math/amdgpu/remainder.cpp
+++ b/src/math/amdgpu/remainder.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/remainder.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remainder, (double x, double y)) {
   return __builtin_remainder(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/remainderf.cpp b/src/math/amdgpu/remainderf.cpp
index 9fee6f8..50df3b2 100644
--- a/src/math/amdgpu/remainderf.cpp
+++ b/src/math/amdgpu/remainderf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/remainderf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remainderf, (float x, float y)) {
   return __builtin_remainderf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/remquo.cpp b/src/math/amdgpu/remquo.cpp
index d8074a9..42c908e 100644
--- a/src/math/amdgpu/remquo.cpp
+++ b/src/math/amdgpu/remquo.cpp
@@ -10,8 +10,9 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remquo, (double x, double y, int *quo)) {
   int tmp;
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(double, remquo, (double x, double y, int *quo)) {
   return r;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/remquof.cpp b/src/math/amdgpu/remquof.cpp
index b6584df..854d3bf 100644
--- a/src/math/amdgpu/remquof.cpp
+++ b/src/math/amdgpu/remquof.cpp
@@ -10,8 +10,9 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remquof, (float x, float y, int *quo)) {
   int tmp;
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(float, remquof, (float x, float y, int *quo)) {
   return r;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/rint.cpp b/src/math/amdgpu/rint.cpp
index 44d494a..ac6837a 100644
--- a/src/math/amdgpu/rint.cpp
+++ b/src/math/amdgpu/rint.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/rint.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, rint, (double x)) { return __builtin_rint(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/rintf.cpp b/src/math/amdgpu/rintf.cpp
index daf98d9..9409347 100644
--- a/src/math/amdgpu/rintf.cpp
+++ b/src/math/amdgpu/rintf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/rintf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, rintf, (float x)) { return __builtin_rintf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/round.cpp b/src/math/amdgpu/round.cpp
index 9d8b558..0d2765f 100644
--- a/src/math/amdgpu/round.cpp
+++ b/src/math/amdgpu/round.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/round.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, round, (double x)) { return __builtin_round(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/roundf.cpp b/src/math/amdgpu/roundf.cpp
index 8743e4e..86e8ba3 100644
--- a/src/math/amdgpu/roundf.cpp
+++ b/src/math/amdgpu/roundf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/roundf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, roundf, (float x)) { return __builtin_roundf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/scalbn.cpp b/src/math/amdgpu/scalbn.cpp
index c2a43e0..05bbbc6 100644
--- a/src/math/amdgpu/scalbn.cpp
+++ b/src/math/amdgpu/scalbn.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, scalbn, (double x, int y)) {
   return __builtin_amdgcn_ldexp(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/scalbnf.cpp b/src/math/amdgpu/scalbnf.cpp
index 63de26c..f0e9e47 100644
--- a/src/math/amdgpu/scalbnf.cpp
+++ b/src/math/amdgpu/scalbnf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, scalbnf, (float x, int y)) {
   return __builtin_amdgcn_ldexpf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sin.cpp b/src/math/amdgpu/sin.cpp
index dbc29a7..f3d88af 100644
--- a/src/math/amdgpu/sin.cpp
+++ b/src/math/amdgpu/sin.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sin, (double x)) { return __ocml_sin_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sincos.cpp b/src/math/amdgpu/sincos.cpp
index 7cdd0d1..304ac0c 100644
--- a/src/math/amdgpu/sincos.cpp
+++ b/src/math/amdgpu/sincos.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, sincos, (double x, double *sinptr, double *cosptr)) {
   *sinptr = __ocml_sincos_f64(x, cosptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sincosf.cpp b/src/math/amdgpu/sincosf.cpp
index 37a5e2a..1c4e9c6 100644
--- a/src/math/amdgpu/sincosf.cpp
+++ b/src/math/amdgpu/sincosf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinptr, float *cosptr)) {
   *sinptr = __ocml_sincos_f32(x, cosptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sinf.cpp b/src/math/amdgpu/sinf.cpp
index cda2c62..c6d64a6 100644
--- a/src/math/amdgpu/sinf.cpp
+++ b/src/math/amdgpu/sinf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinf, (float x)) { return __ocml_sin_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sinh.cpp b/src/math/amdgpu/sinh.cpp
index 66cacd1..26314f4 100644
--- a/src/math/amdgpu/sinh.cpp
+++ b/src/math/amdgpu/sinh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sinh, (double x)) { return __ocml_sinh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sinhf.cpp b/src/math/amdgpu/sinhf.cpp
index 5d3f5ea..a4eb8e1 100644
--- a/src/math/amdgpu/sinhf.cpp
+++ b/src/math/amdgpu/sinhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinhf, (float x)) { return __ocml_sinh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sqrt.cpp b/src/math/amdgpu/sqrt.cpp
index 60ca5af..ed83b6e 100644
--- a/src/math/amdgpu/sqrt.cpp
+++ b/src/math/amdgpu/sqrt.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sqrt, (double x)) { return __builtin_sqrt(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/sqrtf.cpp b/src/math/amdgpu/sqrtf.cpp
index e17f942..851922c 100644
--- a/src/math/amdgpu/sqrtf.cpp
+++ b/src/math/amdgpu/sqrtf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/sqrtf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sqrtf, (float x)) { return __builtin_sqrtf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tan.cpp b/src/math/amdgpu/tan.cpp
index 6121a93..c946dc2 100644
--- a/src/math/amdgpu/tan.cpp
+++ b/src/math/amdgpu/tan.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tan, (double x)) { return __ocml_tan_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tanf.cpp b/src/math/amdgpu/tanf.cpp
index fdd83ee..8c93fc4 100644
--- a/src/math/amdgpu/tanf.cpp
+++ b/src/math/amdgpu/tanf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tanf, (float x)) { return __ocml_tan_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tanh.cpp b/src/math/amdgpu/tanh.cpp
index 25a9c29..834353e 100644
--- a/src/math/amdgpu/tanh.cpp
+++ b/src/math/amdgpu/tanh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tanh, (double x)) { return __ocml_tanh_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tanhf.cpp b/src/math/amdgpu/tanhf.cpp
index a4bfd20..5029596 100644
--- a/src/math/amdgpu/tanhf.cpp
+++ b/src/math/amdgpu/tanhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tanhf, (float x)) { return __ocml_tanh_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tgamma.cpp b/src/math/amdgpu/tgamma.cpp
index 10f58d5..485a6a3 100644
--- a/src/math/amdgpu/tgamma.cpp
+++ b/src/math/amdgpu/tgamma.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tgamma, (double x)) { return __ocml_tgamma_f64(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/tgammaf.cpp b/src/math/amdgpu/tgammaf.cpp
index e7d2205..e48a486 100644
--- a/src/math/amdgpu/tgammaf.cpp
+++ b/src/math/amdgpu/tgammaf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tgammaf, (float x)) { return __ocml_tgamma_f32(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/trunc.cpp b/src/math/amdgpu/trunc.cpp
index 773600f..f60caa2 100644
--- a/src/math/amdgpu/trunc.cpp
+++ b/src/math/amdgpu/trunc.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/trunc.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, trunc, (double x)) { return __builtin_trunc(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/truncf.cpp b/src/math/amdgpu/truncf.cpp
index 534797a..a6c9b8f 100644
--- a/src/math/amdgpu/truncf.cpp
+++ b/src/math/amdgpu/truncf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/truncf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, truncf, (float x)) { return __builtin_truncf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/asin.h b/src/math/asin.h
index e443776..6516e40 100644
--- a/src/math/asin.h
+++ b/src/math/asin.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ASIN_H
 #define LLVM_LIBC_SRC_MATH_ASIN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double asin(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ASIN_H
diff --git a/src/math/asinf.h b/src/math/asinf.h
index 227f10b..ed0b8ab 100644
--- a/src/math/asinf.h
+++ b/src/math/asinf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ASINF_H
 #define LLVM_LIBC_SRC_MATH_ASINF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float asinf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ASINF_H
diff --git a/src/math/asinh.h b/src/math/asinh.h
index 418bf96..45fbc7c 100644
--- a/src/math/asinh.h
+++ b/src/math/asinh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ASINH_H
 #define LLVM_LIBC_SRC_MATH_ASINH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double asinh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ASINH_H
diff --git a/src/math/asinhf.h b/src/math/asinhf.h
index 32a697c..d5787ee 100644
--- a/src/math/asinhf.h
+++ b/src/math/asinhf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ASINHF_H
 #define LLVM_LIBC_SRC_MATH_ASINHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float asinhf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ASINHF_H
diff --git a/src/math/atan.h b/src/math/atan.h
index bcbc97a..a9ba28a 100644
--- a/src/math/atan.h
+++ b/src/math/atan.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATAN_H
 #define LLVM_LIBC_SRC_MATH_ATAN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double atan(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATAN_H
diff --git a/src/math/atan2.h b/src/math/atan2.h
index 024bbfb..7bb2f96 100644
--- a/src/math/atan2.h
+++ b/src/math/atan2.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATAN2_H
 #define LLVM_LIBC_SRC_MATH_ATAN2_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double atan2(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATAN2_H
diff --git a/src/math/atan2f.h b/src/math/atan2f.h
index 25d2de0..ed60383 100644
--- a/src/math/atan2f.h
+++ b/src/math/atan2f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATAN2F_H
 #define LLVM_LIBC_SRC_MATH_ATAN2F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float atan2f(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATAN2F_H
diff --git a/src/math/atan2l.h b/src/math/atan2l.h
new file mode 100644
index 0000000..134d570
--- /dev/null
+++ b/src/math/atan2l.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for atan2l ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ATAN2L_H
+#define LLVM_LIBC_SRC_MATH_ATAN2L_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double atan2l(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ATAN2L_H
diff --git a/src/math/atanf.h b/src/math/atanf.h
index bb4c5a8..0be32f3 100644
--- a/src/math/atanf.h
+++ b/src/math/atanf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATANF_H
 #define LLVM_LIBC_SRC_MATH_ATANF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float atanf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATANF_H
diff --git a/src/math/atanh.h b/src/math/atanh.h
index dc84d07..485c824 100644
--- a/src/math/atanh.h
+++ b/src/math/atanh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATANH_H
 #define LLVM_LIBC_SRC_MATH_ATANH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double atanh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATANH_H
diff --git a/src/math/atanhf.h b/src/math/atanhf.h
index 589ffd0..0a4d899 100644
--- a/src/math/atanhf.h
+++ b/src/math/atanhf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ATANHF_H
 #define LLVM_LIBC_SRC_MATH_ATANHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float atanhf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ATANHF_H
diff --git a/src/math/canonicalize.h b/src/math/canonicalize.h
index b7b5959..6b6b1e0 100644
--- a/src/math/canonicalize.h
+++ b/src/math/canonicalize.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CANONICALIZE_H
 #define LLVM_LIBC_SRC_MATH_CANONICALIZE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int canonicalize(double *cx, const double *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CANONICALIZE_H
diff --git a/src/math/canonicalizef.h b/src/math/canonicalizef.h
index 556607f..94bc48b 100644
--- a/src/math/canonicalizef.h
+++ b/src/math/canonicalizef.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CANONICALIZEF_H
 #define LLVM_LIBC_SRC_MATH_CANONICALIZEF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int canonicalizef(float *cx, const float *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CANONICALIZEF_H
diff --git a/src/math/canonicalizef128.h b/src/math/canonicalizef128.h
index 6db8009..eeeb7e3 100644
--- a/src/math/canonicalizef128.h
+++ b/src/math/canonicalizef128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_CANONICALIZEF128_H
 #define LLVM_LIBC_SRC_MATH_CANONICALIZEF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int canonicalizef128(float128 *cx, const float128 *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CANONICALIZEF128_H
diff --git a/src/math/canonicalizef16.h b/src/math/canonicalizef16.h
index 102af01..c47cec6 100644
--- a/src/math/canonicalizef16.h
+++ b/src/math/canonicalizef16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_CANONICALIZEF16_H
 #define LLVM_LIBC_SRC_MATH_CANONICALIZEF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int canonicalizef16(float16 *cx, const float16 *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CANONICALIZEF16_H
diff --git a/src/math/canonicalizel.h b/src/math/canonicalizel.h
index 1cab29e..1c6b9e6 100644
--- a/src/math/canonicalizel.h
+++ b/src/math/canonicalizel.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CANONICALIZEL_H
 #define LLVM_LIBC_SRC_MATH_CANONICALIZEL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int canonicalizel(long double *cx, const long double *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CANONICALIZEL_H
diff --git a/src/math/cbrt.h b/src/math/cbrt.h
new file mode 100644
index 0000000..8cf7d9b
--- /dev/null
+++ b/src/math/cbrt.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cbrt --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_CBRT_H
+#define LLVM_LIBC_SRC_MATH_CBRT_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double cbrt(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_CBRT_H
diff --git a/src/math/cbrtf.h b/src/math/cbrtf.h
new file mode 100644
index 0000000..1187efb
--- /dev/null
+++ b/src/math/cbrtf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cbrtf -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_CBRTF_H
+#define LLVM_LIBC_SRC_MATH_CBRTF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float cbrtf(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_CBRTF_H
diff --git a/src/math/ceil.h b/src/math/ceil.h
index c424dee..4cf262e 100644
--- a/src/math/ceil.h
+++ b/src/math/ceil.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CEIL_H
 #define LLVM_LIBC_SRC_MATH_CEIL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double ceil(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CEIL_H
diff --git a/src/math/ceilf.h b/src/math/ceilf.h
index 0fa3aa8..359465c 100644
--- a/src/math/ceilf.h
+++ b/src/math/ceilf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CEILF_H
 #define LLVM_LIBC_SRC_MATH_CEILF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float ceilf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CEILF_H
diff --git a/src/math/ceilf128.h b/src/math/ceilf128.h
index b0c4020..211b813 100644
--- a/src/math/ceilf128.h
+++ b/src/math/ceilf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_CEILF128_H
 #define LLVM_LIBC_SRC_MATH_CEILF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 ceilf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CEILF128_H
diff --git a/src/math/ceilf16.h b/src/math/ceilf16.h
index 36a6bd2..b0e988b 100644
--- a/src/math/ceilf16.h
+++ b/src/math/ceilf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_CEILF16_H
 #define LLVM_LIBC_SRC_MATH_CEILF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 ceilf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CEILF16_H
diff --git a/src/math/ceill.h b/src/math/ceill.h
index fbe6563..ce79cb5 100644
--- a/src/math/ceill.h
+++ b/src/math/ceill.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_CEILL_H
 #define LLVM_LIBC_SRC_MATH_CEILL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double ceill(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_CEILL_H
diff --git a/src/math/copysign.h b/src/math/copysign.h
index 004240f..a115f12 100644
--- a/src/math/copysign.h
+++ b/src/math/copysign.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COPYSIGN_H
 #define LLVM_LIBC_SRC_MATH_COPYSIGN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double copysign(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COPYSIGN_H
diff --git a/src/math/copysignf.h b/src/math/copysignf.h
index 503e7cb..3877f7b 100644
--- a/src/math/copysignf.h
+++ b/src/math/copysignf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COPYSIGNF_H
 #define LLVM_LIBC_SRC_MATH_COPYSIGNF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float copysignf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COPYSIGNF_H
diff --git a/src/math/copysignf128.h b/src/math/copysignf128.h
index 06c1949..b001b8e 100644
--- a/src/math/copysignf128.h
+++ b/src/math/copysignf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_COPYSIGNF128_H
 #define LLVM_LIBC_SRC_MATH_COPYSIGNF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 copysignf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COPYSIGNF128_H
diff --git a/src/math/copysignf16.h b/src/math/copysignf16.h
index 3ddde9f..0b0e486 100644
--- a/src/math/copysignf16.h
+++ b/src/math/copysignf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_COPYSIGNF16_H
 #define LLVM_LIBC_SRC_MATH_COPYSIGNF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 copysignf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COPYSIGNF16_H
diff --git a/src/math/copysignl.h b/src/math/copysignl.h
index 8b8b37b..6c5e8fb 100644
--- a/src/math/copysignl.h
+++ b/src/math/copysignl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COPYSIGNL_H
 #define LLVM_LIBC_SRC_MATH_COPYSIGNL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double copysignl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COPYSIGNL_H
diff --git a/src/math/cos.h b/src/math/cos.h
index aa97ccf..7c1a88f 100644
--- a/src/math/cos.h
+++ b/src/math/cos.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COS_H
 #define LLVM_LIBC_SRC_MATH_COS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double cos(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COS_H
diff --git a/src/math/cosf.h b/src/math/cosf.h
index 158f311..7942eaf 100644
--- a/src/math/cosf.h
+++ b/src/math/cosf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COSF_H
 #define LLVM_LIBC_SRC_MATH_COSF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float cosf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COSF_H
diff --git a/src/math/cosh.h b/src/math/cosh.h
index f0c8b6b..4a4be4a 100644
--- a/src/math/cosh.h
+++ b/src/math/cosh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COSH_H
 #define LLVM_LIBC_SRC_MATH_COSH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double cosh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COSH_H
diff --git a/src/math/coshf.h b/src/math/coshf.h
index c470a8c..28abada 100644
--- a/src/math/coshf.h
+++ b/src/math/coshf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_COSHF_H
 #define LLVM_LIBC_SRC_MATH_COSHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float coshf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_COSHF_H
diff --git a/src/math/coshf16.h b/src/math/coshf16.h
new file mode 100644
index 0000000..55c9d49
--- /dev/null
+++ b/src/math/coshf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for coshf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_COSHF16_H
+#define LLVM_LIBC_SRC_MATH_COSHF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 coshf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_COSHF16_H
diff --git a/src/math/cospif.h b/src/math/cospif.h
new file mode 100644
index 0000000..fbe011f
--- /dev/null
+++ b/src/math/cospif.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cospif ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_COSPIF_H
+#define LLVM_LIBC_SRC_MATH_COSPIF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float cospif(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_COSPIF_H
diff --git a/src/math/cospif16.h b/src/math/cospif16.h
new file mode 100644
index 0000000..122b548
--- /dev/null
+++ b/src/math/cospif16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for cospif16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_COSPIF16_H
+#define LLVM_LIBC_SRC_MATH_COSPIF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 cospif16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_COSPIF16_H
diff --git a/src/math/daddf128.h b/src/math/daddf128.h
new file mode 100644
index 0000000..cf6c199
--- /dev/null
+++ b/src/math/daddf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for daddf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DADDF128_H
+#define LLVM_LIBC_SRC_MATH_DADDF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double daddf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DADDF128_H
diff --git a/src/math/daddl.h b/src/math/daddl.h
new file mode 100644
index 0000000..8dc5d4d
--- /dev/null
+++ b/src/math/daddl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for daddl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DADDL_H
+#define LLVM_LIBC_SRC_MATH_DADDL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double daddl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DADDL_H
diff --git a/src/math/ddivf128.h b/src/math/ddivf128.h
new file mode 100644
index 0000000..f7a5ef0
--- /dev/null
+++ b/src/math/ddivf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for ddivf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DDIVF128_H
+#define LLVM_LIBC_SRC_MATH_DDIVF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double ddivf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DDIVF128_H
diff --git a/src/math/ddivl.h b/src/math/ddivl.h
new file mode 100644
index 0000000..bf0da28
--- /dev/null
+++ b/src/math/ddivl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ddivl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DDIVL_H
+#define LLVM_LIBC_SRC_MATH_DDIVL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double ddivl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DDIVL_H
diff --git a/src/math/dfmaf128.h b/src/math/dfmaf128.h
new file mode 100644
index 0000000..1b2e728
--- /dev/null
+++ b/src/math/dfmaf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for dfmaf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DFMAF128_H
+#define LLVM_LIBC_SRC_MATH_DFMAF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dfmaf128(float128 x, float128 y, float128 z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DFMAF128_H
diff --git a/src/math/dfmal.h b/src/math/dfmal.h
new file mode 100644
index 0000000..e086730
--- /dev/null
+++ b/src/math/dfmal.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for dfmal -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DFMAL_H
+#define LLVM_LIBC_SRC_MATH_DFMAL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dfmal(long double x, long double y, long double z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DFMAL_H
diff --git a/src/math/dmulf128.h b/src/math/dmulf128.h
new file mode 100644
index 0000000..623f22c
--- /dev/null
+++ b/src/math/dmulf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for dmulf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DMULF128_H
+#define LLVM_LIBC_SRC_MATH_DMULF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dmulf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DMULF128_H
diff --git a/src/math/dmull.h b/src/math/dmull.h
new file mode 100644
index 0000000..656776a
--- /dev/null
+++ b/src/math/dmull.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for dmull -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DMULL_H
+#define LLVM_LIBC_SRC_MATH_DMULL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dmull(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DMULL_H
diff --git a/src/math/dsqrtf128.h b/src/math/dsqrtf128.h
new file mode 100644
index 0000000..9710339
--- /dev/null
+++ b/src/math/dsqrtf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for dsqrtf128 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DSQRTF128_H
+#define LLVM_LIBC_SRC_MATH_DSQRTF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dsqrtf128(float128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DSQRTF128_H
diff --git a/src/math/dsqrtl.h b/src/math/dsqrtl.h
new file mode 100644
index 0000000..7bf0255
--- /dev/null
+++ b/src/math/dsqrtl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for dsqrtl ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DSQRTL_H
+#define LLVM_LIBC_SRC_MATH_DSQRTL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dsqrtl(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DSQRTL_H
diff --git a/src/math/dsubf128.h b/src/math/dsubf128.h
new file mode 100644
index 0000000..8ac58a9
--- /dev/null
+++ b/src/math/dsubf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for dsubf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DSUBF128_H
+#define LLVM_LIBC_SRC_MATH_DSUBF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dsubf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DSUBF128_H
diff --git a/src/math/dsubl.h b/src/math/dsubl.h
new file mode 100644
index 0000000..a512bbe
--- /dev/null
+++ b/src/math/dsubl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for dsubl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DSUBL_H
+#define LLVM_LIBC_SRC_MATH_DSUBL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double dsubl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DSUBL_H
diff --git a/src/math/erf.h b/src/math/erf.h
index a38c924..bd16abc 100644
--- a/src/math/erf.h
+++ b/src/math/erf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ERF_H
 #define LLVM_LIBC_SRC_MATH_ERF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double erf(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ERF_H
diff --git a/src/math/erff.h b/src/math/erff.h
index f6c56c7..24cfa83 100644
--- a/src/math/erff.h
+++ b/src/math/erff.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ERFF_H
 #define LLVM_LIBC_SRC_MATH_ERFF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float erff(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ERFF_H
diff --git a/src/math/exp.h b/src/math/exp.h
index 6d60a3b..1e1e672 100644
--- a/src/math/exp.h
+++ b/src/math/exp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP_H
 #define LLVM_LIBC_SRC_MATH_EXP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double exp(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP_H
diff --git a/src/math/exp10.h b/src/math/exp10.h
index 081b419..06e9be5 100644
--- a/src/math/exp10.h
+++ b/src/math/exp10.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP10_H
 #define LLVM_LIBC_SRC_MATH_EXP10_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double exp10(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP10_H
diff --git a/src/math/exp10f.h b/src/math/exp10f.h
index 4df5c46..0e53742 100644
--- a/src/math/exp10f.h
+++ b/src/math/exp10f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP10F_H
 #define LLVM_LIBC_SRC_MATH_EXP10F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float exp10f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP10F_H
diff --git a/src/math/exp10f16.h b/src/math/exp10f16.h
new file mode 100644
index 0000000..62a62f7
--- /dev/null
+++ b/src/math/exp10f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for exp10f16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXP10F16_H
+#define LLVM_LIBC_SRC_MATH_EXP10F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 exp10f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXP10F16_H
diff --git a/src/math/exp10m1f.h b/src/math/exp10m1f.h
new file mode 100644
index 0000000..fcb9f77
--- /dev/null
+++ b/src/math/exp10m1f.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for exp10m1f ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXP10M1F_H
+#define LLVM_LIBC_SRC_MATH_EXP10M1F_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float exp10m1f(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXP10M1F_H
diff --git a/src/math/exp10m1f16.h b/src/math/exp10m1f16.h
new file mode 100644
index 0000000..e195bc4
--- /dev/null
+++ b/src/math/exp10m1f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for exp10m1f16 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXP10M1F16_H
+#define LLVM_LIBC_SRC_MATH_EXP10M1F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 exp10m1f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXP10M1F16_H
diff --git a/src/math/exp2.h b/src/math/exp2.h
index 2feccf6..50b11ee 100644
--- a/src/math/exp2.h
+++ b/src/math/exp2.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP2_H
 #define LLVM_LIBC_SRC_MATH_EXP2_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double exp2(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP2_H
diff --git a/src/math/exp2f.h b/src/math/exp2f.h
index 13af54c..994371c 100644
--- a/src/math/exp2f.h
+++ b/src/math/exp2f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP2F_H
 #define LLVM_LIBC_SRC_MATH_EXP2F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float exp2f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP2F_H
diff --git a/src/math/exp2f16.h b/src/math/exp2f16.h
new file mode 100644
index 0000000..71361b9
--- /dev/null
+++ b/src/math/exp2f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for exp2f16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXP2F16_H
+#define LLVM_LIBC_SRC_MATH_EXP2F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 exp2f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXP2F16_H
diff --git a/src/math/exp2m1f.h b/src/math/exp2m1f.h
index 0eaf6b0..71b1588 100644
--- a/src/math/exp2m1f.h
+++ b/src/math/exp2m1f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXP2M1F_H
 #define LLVM_LIBC_SRC_MATH_EXP2M1F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float exp2m1f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXP2M1F_H
diff --git a/src/math/exp2m1f16.h b/src/math/exp2m1f16.h
new file mode 100644
index 0000000..39fcebd
--- /dev/null
+++ b/src/math/exp2m1f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for exp2m1f16 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXP2M1F16_H
+#define LLVM_LIBC_SRC_MATH_EXP2M1F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 exp2m1f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXP2M1F16_H
diff --git a/src/math/expf.h b/src/math/expf.h
index 38837cb..e82b762 100644
--- a/src/math/expf.h
+++ b/src/math/expf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXPF_H
 #define LLVM_LIBC_SRC_MATH_EXPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float expf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXPF_H
diff --git a/src/math/expf16.h b/src/math/expf16.h
new file mode 100644
index 0000000..8547f65
--- /dev/null
+++ b/src/math/expf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for expf16 ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXPF16_H
+#define LLVM_LIBC_SRC_MATH_EXPF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 expf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXPF16_H
diff --git a/src/math/expm1.h b/src/math/expm1.h
index 5240929..216e8b8 100644
--- a/src/math/expm1.h
+++ b/src/math/expm1.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXPM1_H
 #define LLVM_LIBC_SRC_MATH_EXPM1_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double expm1(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXPM1_H
diff --git a/src/math/expm1f.h b/src/math/expm1f.h
index 359cbee..e3539c5 100644
--- a/src/math/expm1f.h
+++ b/src/math/expm1f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_EXPM1F_H
 #define LLVM_LIBC_SRC_MATH_EXPM1F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float expm1f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_EXPM1F_H
diff --git a/src/math/expm1f16.h b/src/math/expm1f16.h
new file mode 100644
index 0000000..644e6cd
--- /dev/null
+++ b/src/math/expm1f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for expm1f16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_EXPM1F16_H
+#define LLVM_LIBC_SRC_MATH_EXPM1F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 expm1f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_EXPM1F16_H
diff --git a/src/math/f16add.h b/src/math/f16add.h
new file mode 100644
index 0000000..1e794fd
--- /dev/null
+++ b/src/math/f16add.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16add ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16ADD_H
+#define LLVM_LIBC_SRC_MATH_F16ADD_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16add(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16ADD_H
diff --git a/src/math/f16addf.h b/src/math/f16addf.h
new file mode 100644
index 0000000..d9cd0cf
--- /dev/null
+++ b/src/math/f16addf.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16addf -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16ADDF_H
+#define LLVM_LIBC_SRC_MATH_F16ADDF_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16addf(float x, float y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16ADDF_H
diff --git a/src/math/f16addf128.h b/src/math/f16addf128.h
new file mode 100644
index 0000000..aabb5eb
--- /dev/null
+++ b/src/math/f16addf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16addf128 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16ADDF128_H
+#define LLVM_LIBC_SRC_MATH_F16ADDF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16addf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16ADDF128_H
diff --git a/src/math/f16addl.h b/src/math/f16addl.h
new file mode 100644
index 0000000..b39a290
--- /dev/null
+++ b/src/math/f16addl.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16addl -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16ADDL_H
+#define LLVM_LIBC_SRC_MATH_F16ADDL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16addl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16ADDL_H
diff --git a/src/math/f16div.h b/src/math/f16div.h
new file mode 100644
index 0000000..4e1724f
--- /dev/null
+++ b/src/math/f16div.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16div ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16DIV_H
+#define LLVM_LIBC_SRC_MATH_F16DIV_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16div(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16DIV_H
diff --git a/src/math/f16divf.h b/src/math/f16divf.h
new file mode 100644
index 0000000..351cffd
--- /dev/null
+++ b/src/math/f16divf.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16divf -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16DIVF_H
+#define LLVM_LIBC_SRC_MATH_F16DIVF_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16divf(float x, float y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16DIVF_H
diff --git a/src/math/f16divf128.h b/src/math/f16divf128.h
new file mode 100644
index 0000000..b515419
--- /dev/null
+++ b/src/math/f16divf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16divf128 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16DIVF128_H
+#define LLVM_LIBC_SRC_MATH_F16DIVF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16divf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16DIVF128_H
diff --git a/src/math/f16divl.h b/src/math/f16divl.h
new file mode 100644
index 0000000..61a3774
--- /dev/null
+++ b/src/math/f16divl.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16divl -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16DIVL_H
+#define LLVM_LIBC_SRC_MATH_F16DIVL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16divl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16DIVL_H
diff --git a/src/math/f16fma.h b/src/math/f16fma.h
new file mode 100644
index 0000000..d2628e3
--- /dev/null
+++ b/src/math/f16fma.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16fma ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16FMA_H
+#define LLVM_LIBC_SRC_MATH_F16FMA_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16fma(double x, double y, double z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16FMA_H
diff --git a/src/math/f16fmaf.h b/src/math/f16fmaf.h
index d92cb43..627afae 100644
--- a/src/math/f16fmaf.h
+++ b/src/math/f16fmaf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_F16FMAF_H
 #define LLVM_LIBC_SRC_MATH_F16FMAF_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 f16fmaf(float x, float y, float z);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_F16FMAF_H
diff --git a/src/math/f16fmaf128.h b/src/math/f16fmaf128.h
new file mode 100644
index 0000000..c8f81d4
--- /dev/null
+++ b/src/math/f16fmaf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16fmaf128 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16FMAF128_H
+#define LLVM_LIBC_SRC_MATH_F16FMAF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16fmaf128(float128 x, float128 y, float128 z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16FMAF128_H
diff --git a/src/math/f16fmal.h b/src/math/f16fmal.h
new file mode 100644
index 0000000..ff35f63
--- /dev/null
+++ b/src/math/f16fmal.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16fmal -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16FMAL_H
+#define LLVM_LIBC_SRC_MATH_F16FMAL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16fmal(long double x, long double y, long double z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16FMAL_H
diff --git a/src/math/f16mul.h b/src/math/f16mul.h
new file mode 100644
index 0000000..89403cf
--- /dev/null
+++ b/src/math/f16mul.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16mul ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16MUL_H
+#define LLVM_LIBC_SRC_MATH_F16MUL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16mul(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16MUL_H
diff --git a/src/math/f16mulf.h b/src/math/f16mulf.h
new file mode 100644
index 0000000..755886d
--- /dev/null
+++ b/src/math/f16mulf.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16mulf -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16MULF_H
+#define LLVM_LIBC_SRC_MATH_F16MULF_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16mulf(float x, float y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16MULF_H
diff --git a/src/math/f16mulf128.h b/src/math/f16mulf128.h
new file mode 100644
index 0000000..14371c5
--- /dev/null
+++ b/src/math/f16mulf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16mulf128 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16MULF128_H
+#define LLVM_LIBC_SRC_MATH_F16MULF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16mulf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16MULF128_H
diff --git a/src/math/f16mull.h b/src/math/f16mull.h
new file mode 100644
index 0000000..a3177ca
--- /dev/null
+++ b/src/math/f16mull.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16mull -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16MULL_H
+#define LLVM_LIBC_SRC_MATH_F16MULL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16mull(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16MULL_H
diff --git a/src/math/f16sqrt.h b/src/math/f16sqrt.h
new file mode 100644
index 0000000..27c6f34
--- /dev/null
+++ b/src/math/f16sqrt.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16sqrt -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SQRT_H
+#define LLVM_LIBC_SRC_MATH_F16SQRT_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16sqrt(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SQRT_H
diff --git a/src/math/f16sqrtf.h b/src/math/f16sqrtf.h
index 197ebe6..0471b02 100644
--- a/src/math/f16sqrtf.h
+++ b/src/math/f16sqrtf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_F16SQRTF_H
 #define LLVM_LIBC_SRC_MATH_F16SQRTF_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 f16sqrtf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_F16SQRTF_H
diff --git a/src/math/f16sqrtf128.h b/src/math/f16sqrtf128.h
new file mode 100644
index 0000000..713bbe1
--- /dev/null
+++ b/src/math/f16sqrtf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16sqrtf128 -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SQRTF128_H
+#define LLVM_LIBC_SRC_MATH_F16SQRTF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16sqrtf128(float128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SQRTF128_H
diff --git a/src/math/f16sqrtl.h b/src/math/f16sqrtl.h
new file mode 100644
index 0000000..8238f9e
--- /dev/null
+++ b/src/math/f16sqrtl.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16sqrtl ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SQRTL_H
+#define LLVM_LIBC_SRC_MATH_F16SQRTL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16sqrtl(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SQRTL_H
diff --git a/src/math/f16sub.h b/src/math/f16sub.h
new file mode 100644
index 0000000..fbceba8
--- /dev/null
+++ b/src/math/f16sub.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16sub ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SUB_H
+#define LLVM_LIBC_SRC_MATH_F16SUB_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16sub(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SUB_H
diff --git a/src/math/f16subf.h b/src/math/f16subf.h
new file mode 100644
index 0000000..255953a
--- /dev/null
+++ b/src/math/f16subf.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16subf -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SUBF_H
+#define LLVM_LIBC_SRC_MATH_F16SUBF_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16subf(float x, float y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SUBF_H
diff --git a/src/math/f16subf128.h b/src/math/f16subf128.h
new file mode 100644
index 0000000..fae3360
--- /dev/null
+++ b/src/math/f16subf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16subf128 --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SUBF128_H
+#define LLVM_LIBC_SRC_MATH_F16SUBF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16subf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SUBF128_H
diff --git a/src/math/f16subl.h b/src/math/f16subl.h
new file mode 100644
index 0000000..b4e3c3c
--- /dev/null
+++ b/src/math/f16subl.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for f16subl -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_F16SUBL_H
+#define LLVM_LIBC_SRC_MATH_F16SUBL_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 f16subl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_F16SUBL_H
diff --git a/src/math/fabs.h b/src/math/fabs.h
index 0aad5ea..c2f179a 100644
--- a/src/math/fabs.h
+++ b/src/math/fabs.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FABS_H
 #define LLVM_LIBC_SRC_MATH_FABS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fabs(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FABS_H
diff --git a/src/math/fabsf.h b/src/math/fabsf.h
index ca2cc10..52347d9 100644
--- a/src/math/fabsf.h
+++ b/src/math/fabsf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FABSF_H
 #define LLVM_LIBC_SRC_MATH_FABSF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fabsf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FABSF_H
diff --git a/src/math/fabsf128.h b/src/math/fabsf128.h
index 0a27502..4507e57 100644
--- a/src/math/fabsf128.h
+++ b/src/math/fabsf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FABSF128_H
 #define LLVM_LIBC_SRC_MATH_FABSF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fabsf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FABSF128_H
diff --git a/src/math/fabsf16.h b/src/math/fabsf16.h
index 532662a..f48a51f 100644
--- a/src/math/fabsf16.h
+++ b/src/math/fabsf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FABSF16_H
 #define LLVM_LIBC_SRC_MATH_FABSF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fabsf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FABSF16_H
diff --git a/src/math/fabsl.h b/src/math/fabsl.h
index b3df8bf..a044460 100644
--- a/src/math/fabsl.h
+++ b/src/math/fabsl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FABSL_H
 #define LLVM_LIBC_SRC_MATH_FABSL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fabsl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FABSL_H
diff --git a/src/math/fadd.h b/src/math/fadd.h
new file mode 100644
index 0000000..fe79568
--- /dev/null
+++ b/src/math/fadd.h
@@ -0,0 +1,20 @@
+//===-- Implementation of fadd function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FADD_H
+#define LLVM_LIBC_SRC_MATH_FADD_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fadd(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FADD_H
diff --git a/src/math/faddf128.h b/src/math/faddf128.h
new file mode 100644
index 0000000..73e5ff1
--- /dev/null
+++ b/src/math/faddf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation of faddf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FADDF128_H
+#define LLVM_LIBC_SRC_MATH_FADDF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float faddf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FADDF128_H
diff --git a/src/math/faddl.h b/src/math/faddl.h
new file mode 100644
index 0000000..b1dc206
--- /dev/null
+++ b/src/math/faddl.h
@@ -0,0 +1,20 @@
+//===-- Implementation of faddl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FADDL_H
+#define LLVM_LIBC_SRC_MATH_FADDL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float faddl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FADDL_H
diff --git a/src/math/fdim.h b/src/math/fdim.h
index 457cb47..19a9e99 100644
--- a/src/math/fdim.h
+++ b/src/math/fdim.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FDIM_H
 #define LLVM_LIBC_SRC_MATH_FDIM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fdim(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FDIM_H
diff --git a/src/math/fdimf.h b/src/math/fdimf.h
index 01d5a53..b90bb45 100644
--- a/src/math/fdimf.h
+++ b/src/math/fdimf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FDIMF_H
 #define LLVM_LIBC_SRC_MATH_FDIMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fdimf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FDIMF_H
diff --git a/src/math/fdimf128.h b/src/math/fdimf128.h
index f0485ab..a5e1387 100644
--- a/src/math/fdimf128.h
+++ b/src/math/fdimf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FDIMF128_H
 #define LLVM_LIBC_SRC_MATH_FDIMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fdimf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FDIMF128_H
diff --git a/src/math/fdimf16.h b/src/math/fdimf16.h
index 0aa2381..e3aac7b 100644
--- a/src/math/fdimf16.h
+++ b/src/math/fdimf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FDIMF16_H
 #define LLVM_LIBC_SRC_MATH_FDIMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fdimf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FDIMF16_H
diff --git a/src/math/fdiml.h b/src/math/fdiml.h
index 4b18d9a..2268601 100644
--- a/src/math/fdiml.h
+++ b/src/math/fdiml.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FDIML_H
 #define LLVM_LIBC_SRC_MATH_FDIML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fdiml(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FDIML_H
diff --git a/src/math/fdiv.h b/src/math/fdiv.h
new file mode 100644
index 0000000..4d60afa
--- /dev/null
+++ b/src/math/fdiv.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fdiv --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FDIV_H
+#define LLVM_LIBC_SRC_MATH_FDIV_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fdiv(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FDIV_H
diff --git a/src/math/fdivf128.h b/src/math/fdivf128.h
new file mode 100644
index 0000000..1a15038
--- /dev/null
+++ b/src/math/fdivf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for fdivf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FDIVF128_H
+#define LLVM_LIBC_SRC_MATH_FDIVF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fdivf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FDIVF128_H
diff --git a/src/math/fdivl.h b/src/math/fdivl.h
new file mode 100644
index 0000000..1943eaa
--- /dev/null
+++ b/src/math/fdivl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fdivl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FDIVL_H
+#define LLVM_LIBC_SRC_MATH_FDIVL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fdivl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FDIVL_H
diff --git a/src/math/ffma.h b/src/math/ffma.h
new file mode 100644
index 0000000..98d89f2
--- /dev/null
+++ b/src/math/ffma.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ffma --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FFMA_H
+#define LLVM_LIBC_SRC_MATH_FFMA_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float ffma(double x, double y, double z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FFMA_H
diff --git a/src/math/ffmaf128.h b/src/math/ffmaf128.h
new file mode 100644
index 0000000..7410997
--- /dev/null
+++ b/src/math/ffmaf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for ffmaf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FFMAF128_H
+#define LLVM_LIBC_SRC_MATH_FFMAF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float ffmaf128(float128 x, float128 y, float128 z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FFMAF128_H
diff --git a/src/math/ffmal.h b/src/math/ffmal.h
new file mode 100644
index 0000000..75fd40a
--- /dev/null
+++ b/src/math/ffmal.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ffmal -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FFMAL_H
+#define LLVM_LIBC_SRC_MATH_FFMAL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float ffmal(long double x, long double y, long double z);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FFMAL_H
diff --git a/src/math/floor.h b/src/math/floor.h
index 2920c7a..d6c6195 100644
--- a/src/math/floor.h
+++ b/src/math/floor.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FLOOR_H
 #define LLVM_LIBC_SRC_MATH_FLOOR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double floor(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FLOOR_H
diff --git a/src/math/floorf.h b/src/math/floorf.h
index 52d6dd7..c9dfcf6 100644
--- a/src/math/floorf.h
+++ b/src/math/floorf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FLOORF_H
 #define LLVM_LIBC_SRC_MATH_FLOORF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float floorf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FLOORF_H
diff --git a/src/math/floorf128.h b/src/math/floorf128.h
index b97c4b6..9af48b2 100644
--- a/src/math/floorf128.h
+++ b/src/math/floorf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FLOORF128_H
 #define LLVM_LIBC_SRC_MATH_FLOORF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 floorf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FLOORF128_H
diff --git a/src/math/floorf16.h b/src/math/floorf16.h
index 4e5e196..c9b1f48 100644
--- a/src/math/floorf16.h
+++ b/src/math/floorf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FLOORF16_H
 #define LLVM_LIBC_SRC_MATH_FLOORF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 floorf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FLOORF16_H
diff --git a/src/math/floorl.h b/src/math/floorl.h
index ef53b29..4597b4e 100644
--- a/src/math/floorl.h
+++ b/src/math/floorl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FLOORL_H
 #define LLVM_LIBC_SRC_MATH_FLOORL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double floorl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FLOORL_H
diff --git a/src/math/fma.h b/src/math/fma.h
index 7f0608e..a705228 100644
--- a/src/math/fma.h
+++ b/src/math/fma.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMA_H
 #define LLVM_LIBC_SRC_MATH_FMA_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fma(double x, double y, double z);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMA_H
diff --git a/src/math/fmaf.h b/src/math/fmaf.h
index 29e5bdc..b7335c4 100644
--- a/src/math/fmaf.h
+++ b/src/math/fmaf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAF_H
 #define LLVM_LIBC_SRC_MATH_FMAF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaf(float x, float y, float z);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAF_H
diff --git a/src/math/fmax.h b/src/math/fmax.h
index 64baa4d..0112874 100644
--- a/src/math/fmax.h
+++ b/src/math/fmax.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAX_H
 #define LLVM_LIBC_SRC_MATH_FMAX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmax(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAX_H
diff --git a/src/math/fmaxf.h b/src/math/fmaxf.h
index 1126323..af6a0cb 100644
--- a/src/math/fmaxf.h
+++ b/src/math/fmaxf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXF_H
 #define LLVM_LIBC_SRC_MATH_FMAXF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaxf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXF_H
diff --git a/src/math/fmaxf128.h b/src/math/fmaxf128.h
index a4407d9..47bf354 100644
--- a/src/math/fmaxf128.h
+++ b/src/math/fmaxf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXF128_H
 #define LLVM_LIBC_SRC_MATH_FMAXF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmaxf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXF128_H
diff --git a/src/math/fmaxf16.h b/src/math/fmaxf16.h
index bf608f8..9048160 100644
--- a/src/math/fmaxf16.h
+++ b/src/math/fmaxf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXF16_H
 #define LLVM_LIBC_SRC_MATH_FMAXF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmaxf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXF16_H
diff --git a/src/math/fmaximum.h b/src/math/fmaximum.h
index 8eac02b..818c428 100644
--- a/src/math/fmaximum.h
+++ b/src/math/fmaximum.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmaximum(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_H
diff --git a/src/math/fmaximum_mag.h b/src/math/fmaximum_mag.h
index 31b7c0f..d4954e3 100644
--- a/src/math/fmaximum_mag.h
+++ b/src/math/fmaximum_mag.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmaximum_mag(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_H
diff --git a/src/math/fmaximum_mag_num.h b/src/math/fmaximum_mag_num.h
index c4ff243..debb017 100644
--- a/src/math/fmaximum_mag_num.h
+++ b/src/math/fmaximum_mag_num.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUM_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmaximum_mag_num(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUM_H
diff --git a/src/math/fmaximum_mag_numf.h b/src/math/fmaximum_mag_numf.h
index 702903a..0ec05c3 100644
--- a/src/math/fmaximum_mag_numf.h
+++ b/src/math/fmaximum_mag_numf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaximum_mag_numf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF_H
diff --git a/src/math/fmaximum_mag_numf128.h b/src/math/fmaximum_mag_numf128.h
index 2afae7f..a263f98 100644
--- a/src/math/fmaximum_mag_numf128.h
+++ b/src/math/fmaximum_mag_numf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmaximum_mag_numf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF128_H
diff --git a/src/math/fmaximum_mag_numf16.h b/src/math/fmaximum_mag_numf16.h
index 4c963d4..1bf2e46 100644
--- a/src/math/fmaximum_mag_numf16.h
+++ b/src/math/fmaximum_mag_numf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmaximum_mag_numf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUMF16_H
diff --git a/src/math/fmaximum_mag_numl.h b/src/math/fmaximum_mag_numl.h
index 32f9ae9..9fbc638 100644
--- a/src/math/fmaximum_mag_numl.h
+++ b/src/math/fmaximum_mag_numl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUML_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmaximum_mag_numl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAG_NUML_H
diff --git a/src/math/fmaximum_magf.h b/src/math/fmaximum_magf.h
index 1bfcc79..73ffd2e 100644
--- a/src/math/fmaximum_magf.h
+++ b/src/math/fmaximum_magf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaximum_magf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF_H
diff --git a/src/math/fmaximum_magf128.h b/src/math/fmaximum_magf128.h
index 23c466b..fb68af7 100644
--- a/src/math/fmaximum_magf128.h
+++ b/src/math/fmaximum_magf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF128_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmaximum_magf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF128_H
diff --git a/src/math/fmaximum_magf16.h b/src/math/fmaximum_magf16.h
index e5f57d3..32aee6e 100644
--- a/src/math/fmaximum_magf16.h
+++ b/src/math/fmaximum_magf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF16_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmaximum_magf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGF16_H
diff --git a/src/math/fmaximum_magl.h b/src/math/fmaximum_magl.h
index 23b283c..8745f6a 100644
--- a/src/math/fmaximum_magl.h
+++ b/src/math/fmaximum_magl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGL_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmaximum_magl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_MAGL_H
diff --git a/src/math/fmaximum_num.h b/src/math/fmaximum_num.h
index ce3ce12..df4bfcb 100644
--- a/src/math/fmaximum_num.h
+++ b/src/math/fmaximum_num.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_NUM_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_NUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmaximum_num(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_NUM_H
diff --git a/src/math/fmaximum_numf.h b/src/math/fmaximum_numf.h
index b3243ed..6599715 100644
--- a/src/math/fmaximum_numf.h
+++ b/src/math/fmaximum_numf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaximum_numf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF_H
diff --git a/src/math/fmaximum_numf128.h b/src/math/fmaximum_numf128.h
index d55183c..1e9bd8d 100644
--- a/src/math/fmaximum_numf128.h
+++ b/src/math/fmaximum_numf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmaximum_numf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF128_H
diff --git a/src/math/fmaximum_numf16.h b/src/math/fmaximum_numf16.h
index b450a45..3a2b230 100644
--- a/src/math/fmaximum_numf16.h
+++ b/src/math/fmaximum_numf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmaximum_numf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_NUMF16_H
diff --git a/src/math/fmaximum_numl.h b/src/math/fmaximum_numl.h
index f668cbd..fc1d3ca 100644
--- a/src/math/fmaximum_numl.h
+++ b/src/math/fmaximum_numl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUM_NUML_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUM_NUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmaximum_numl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUM_NUML_H
diff --git a/src/math/fmaximumf.h b/src/math/fmaximumf.h
index 4eee696..9c4c544 100644
--- a/src/math/fmaximumf.h
+++ b/src/math/fmaximumf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUMF_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmaximumf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUMF_H
diff --git a/src/math/fmaximumf128.h b/src/math/fmaximumf128.h
index 4a214ef..3cc6fa0 100644
--- a/src/math/fmaximumf128.h
+++ b/src/math/fmaximumf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmaximumf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUMF128_H
diff --git a/src/math/fmaximumf16.h b/src/math/fmaximumf16.h
index 806339f..8a81e81 100644
--- a/src/math/fmaximumf16.h
+++ b/src/math/fmaximumf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmaximumf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUMF16_H
diff --git a/src/math/fmaximuml.h b/src/math/fmaximuml.h
index ba8a8b1..71310c2 100644
--- a/src/math/fmaximuml.h
+++ b/src/math/fmaximuml.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXIMUML_H
 #define LLVM_LIBC_SRC_MATH_FMAXIMUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmaximuml(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXIMUML_H
diff --git a/src/math/fmaxl.h b/src/math/fmaxl.h
index a067300..ea5cc4d 100644
--- a/src/math/fmaxl.h
+++ b/src/math/fmaxl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMAXL_H
 #define LLVM_LIBC_SRC_MATH_FMAXL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmaxl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMAXL_H
diff --git a/src/math/fmin.h b/src/math/fmin.h
index bf011bb..d09ec69 100644
--- a/src/math/fmin.h
+++ b/src/math/fmin.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMIN_H
 #define LLVM_LIBC_SRC_MATH_FMIN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmin(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMIN_H
diff --git a/src/math/fminf.h b/src/math/fminf.h
index b9c159a..8eeb542 100644
--- a/src/math/fminf.h
+++ b/src/math/fminf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINF_H
 #define LLVM_LIBC_SRC_MATH_FMINF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fminf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINF_H
diff --git a/src/math/fminf128.h b/src/math/fminf128.h
index d2ed593..7bc393a 100644
--- a/src/math/fminf128.h
+++ b/src/math/fminf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINF128_H
 #define LLVM_LIBC_SRC_MATH_FMINF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fminf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINF128_H
diff --git a/src/math/fminf16.h b/src/math/fminf16.h
index 22d4e6c..a92ff50 100644
--- a/src/math/fminf16.h
+++ b/src/math/fminf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINF16_H
 #define LLVM_LIBC_SRC_MATH_FMINF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fminf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINF16_H
diff --git a/src/math/fminimum.h b/src/math/fminimum.h
index 9d39b1b..53d764e 100644
--- a/src/math/fminimum.h
+++ b/src/math/fminimum.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fminimum(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_H
diff --git a/src/math/fminimum_mag.h b/src/math/fminimum_mag.h
index 10b242e..5ebe3ee 100644
--- a/src/math/fminimum_mag.h
+++ b/src/math/fminimum_mag.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fminimum_mag(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_H
diff --git a/src/math/fminimum_mag_num.h b/src/math/fminimum_mag_num.h
index eb18230..c446434 100644
--- a/src/math/fminimum_mag_num.h
+++ b/src/math/fminimum_mag_num.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUM_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fminimum_mag_num(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMH
diff --git a/src/math/fminimum_mag_numf.h b/src/math/fminimum_mag_numf.h
index 8091990..627b5ad 100644
--- a/src/math/fminimum_mag_numf.h
+++ b/src/math/fminimum_mag_numf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fminimum_mag_numf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF_H
diff --git a/src/math/fminimum_mag_numf128.h b/src/math/fminimum_mag_numf128.h
index 803c5e6..e3e69a7 100644
--- a/src/math/fminimum_mag_numf128.h
+++ b/src/math/fminimum_mag_numf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fminimum_mag_numf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF128_H
diff --git a/src/math/fminimum_mag_numf16.h b/src/math/fminimum_mag_numf16.h
index 0fd314b..5ceca3a 100644
--- a/src/math/fminimum_mag_numf16.h
+++ b/src/math/fminimum_mag_numf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fminimum_mag_numf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUMF16_H
diff --git a/src/math/fminimum_mag_numl.h b/src/math/fminimum_mag_numl.h
index fdbb183..6b14126 100644
--- a/src/math/fminimum_mag_numl.h
+++ b/src/math/fminimum_mag_numl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUML_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fminimum_mag_numl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAG_NUML_H
diff --git a/src/math/fminimum_magf.h b/src/math/fminimum_magf.h
index 6209340..98c9cc0 100644
--- a/src/math/fminimum_magf.h
+++ b/src/math/fminimum_magf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fminimum_magf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF_H
diff --git a/src/math/fminimum_magf128.h b/src/math/fminimum_magf128.h
index 05bd163..00eee4e 100644
--- a/src/math/fminimum_magf128.h
+++ b/src/math/fminimum_magf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF128_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fminimum_magf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF128_H
diff --git a/src/math/fminimum_magf16.h b/src/math/fminimum_magf16.h
index 2767355..cebc76d 100644
--- a/src/math/fminimum_magf16.h
+++ b/src/math/fminimum_magf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF16_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fminimum_magf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAGF16_H
diff --git a/src/math/fminimum_magl.h b/src/math/fminimum_magl.h
index bcda35c..3220e50 100644
--- a/src/math/fminimum_magl.h
+++ b/src/math/fminimum_magl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_MAGL_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_MAGL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fminimum_magl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_MAGL_H
diff --git a/src/math/fminimum_num.h b/src/math/fminimum_num.h
index 4c864cb..42afb06 100644
--- a/src/math/fminimum_num.h
+++ b/src/math/fminimum_num.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_NUM_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_NUM_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fminimum_num(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_NUM_H
diff --git a/src/math/fminimum_numf.h b/src/math/fminimum_numf.h
index ac4b08b..8252b8f 100644
--- a/src/math/fminimum_numf.h
+++ b/src/math/fminimum_numf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fminimum_numf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF_H
diff --git a/src/math/fminimum_numf128.h b/src/math/fminimum_numf128.h
index 00f8960..1833e9e 100644
--- a/src/math/fminimum_numf128.h
+++ b/src/math/fminimum_numf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fminimum_numf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF128_H
diff --git a/src/math/fminimum_numf16.h b/src/math/fminimum_numf16.h
index 598ff9d..0b01c37 100644
--- a/src/math/fminimum_numf16.h
+++ b/src/math/fminimum_numf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fminimum_numf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_NUMF16_H
diff --git a/src/math/fminimum_numl.h b/src/math/fminimum_numl.h
index 0da204e..77d124f 100644
--- a/src/math/fminimum_numl.h
+++ b/src/math/fminimum_numl.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUM_NUML_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUM_NUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fminimum_numl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUM_NUML_H
diff --git a/src/math/fminimumf.h b/src/math/fminimumf.h
index 424309f..915e206 100644
--- a/src/math/fminimumf.h
+++ b/src/math/fminimumf.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUMF_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUMF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fminimumf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUMF_H
diff --git a/src/math/fminimumf128.h b/src/math/fminimumf128.h
index 7ff0190..d507766 100644
--- a/src/math/fminimumf128.h
+++ b/src/math/fminimumf128.h
@@ -10,12 +10,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUMF128_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUMF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fminimumf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUMF128_H
diff --git a/src/math/fminimumf16.h b/src/math/fminimumf16.h
index 86dd240..eaa466a 100644
--- a/src/math/fminimumf16.h
+++ b/src/math/fminimumf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUMF16_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUMF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fminimumf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUMF16_H
diff --git a/src/math/fminimuml.h b/src/math/fminimuml.h
index b9cc321..3928806 100644
--- a/src/math/fminimuml.h
+++ b/src/math/fminimuml.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINIMUML_H
 #define LLVM_LIBC_SRC_MATH_FMINIMUML_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fminimuml(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINIMUML_H
diff --git a/src/math/fminl.h b/src/math/fminl.h
index e111e26..7b352cb 100644
--- a/src/math/fminl.h
+++ b/src/math/fminl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMINL_H
 #define LLVM_LIBC_SRC_MATH_FMINL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fminl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMINL_H
diff --git a/src/math/fmod.h b/src/math/fmod.h
index 01b9aa7..f796930 100644
--- a/src/math/fmod.h
+++ b/src/math/fmod.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMOD_H
 #define LLVM_LIBC_SRC_MATH_FMOD_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fmod(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMOD_H
diff --git a/src/math/fmodf.h b/src/math/fmodf.h
index 90d97e6..01e0868 100644
--- a/src/math/fmodf.h
+++ b/src/math/fmodf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMODF_H
 #define LLVM_LIBC_SRC_MATH_FMODF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmodf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMODF_H
diff --git a/src/math/fmodf128.h b/src/math/fmodf128.h
index b324270..908fc61 100644
--- a/src/math/fmodf128.h
+++ b/src/math/fmodf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMODF128_H
 #define LLVM_LIBC_SRC_MATH_FMODF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fmodf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMODF128_H
diff --git a/src/math/fmodf16.h b/src/math/fmodf16.h
index ab65843..1c8cb8a 100644
--- a/src/math/fmodf16.h
+++ b/src/math/fmodf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMODF16_H
 #define LLVM_LIBC_SRC_MATH_FMODF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fmodf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMODF16_H
diff --git a/src/math/fmodl.h b/src/math/fmodl.h
index f259ddb..2ff5c9a 100644
--- a/src/math/fmodl.h
+++ b/src/math/fmodl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMODL_H
 #define LLVM_LIBC_SRC_MATH_FMODL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fmodl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMODL_H
diff --git a/src/math/fmul.h b/src/math/fmul.h
index fbc1069..73ec2ee 100644
--- a/src/math/fmul.h
+++ b/src/math/fmul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FMUL_H
 #define LLVM_LIBC_SRC_MATH_FMUL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fmul(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FMUL_H
diff --git a/src/math/fmulf128.h b/src/math/fmulf128.h
new file mode 100644
index 0000000..94137ae
--- /dev/null
+++ b/src/math/fmulf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for fmulf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FMULF128_H
+#define LLVM_LIBC_SRC_MATH_FMULF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fmulf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FMULF128_H
diff --git a/src/math/fmull.h b/src/math/fmull.h
new file mode 100644
index 0000000..46e6c77
--- /dev/null
+++ b/src/math/fmull.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fmull -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FMULL_H
+#define LLVM_LIBC_SRC_MATH_FMULL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fmull(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FMULL_H
diff --git a/src/math/frexp.h b/src/math/frexp.h
index 963ea7b..316f5e0 100644
--- a/src/math/frexp.h
+++ b/src/math/frexp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FREXP_H
 #define LLVM_LIBC_SRC_MATH_FREXP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double frexp(double x, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FREXP_H
diff --git a/src/math/frexpf.h b/src/math/frexpf.h
index 74eeac2..f137073 100644
--- a/src/math/frexpf.h
+++ b/src/math/frexpf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FREXPF_H
 #define LLVM_LIBC_SRC_MATH_FREXPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float frexpf(float x, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FREXPF_H
diff --git a/src/math/frexpf128.h b/src/math/frexpf128.h
index 55c4a47..e143e6f 100644
--- a/src/math/frexpf128.h
+++ b/src/math/frexpf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FREXPF128_H
 #define LLVM_LIBC_SRC_MATH_FREXPF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 frexpf128(float128 x, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FREXPF128_H
diff --git a/src/math/frexpf16.h b/src/math/frexpf16.h
index dc1898c..09a9938 100644
--- a/src/math/frexpf16.h
+++ b/src/math/frexpf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FREXPF16_H
 #define LLVM_LIBC_SRC_MATH_FREXPF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 frexpf16(float16 x, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FREXPF16_H
diff --git a/src/math/frexpl.h b/src/math/frexpl.h
index 818266e..a5d8279 100644
--- a/src/math/frexpl.h
+++ b/src/math/frexpl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FREXPL_H
 #define LLVM_LIBC_SRC_MATH_FREXPL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double frexpl(long double x, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FREXPL_H
diff --git a/src/math/fromfp.h b/src/math/fromfp.h
index d3de2dd..63094bb 100644
--- a/src/math/fromfp.h
+++ b/src/math/fromfp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFP_H
 #define LLVM_LIBC_SRC_MATH_FROMFP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fromfp(double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFP_H
diff --git a/src/math/fromfpf.h b/src/math/fromfpf.h
index 11d4321..47e15ff 100644
--- a/src/math/fromfpf.h
+++ b/src/math/fromfpf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPF_H
 #define LLVM_LIBC_SRC_MATH_FROMFPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fromfpf(float x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPF_H
diff --git a/src/math/fromfpf128.h b/src/math/fromfpf128.h
index 5f85fde..1600b81 100644
--- a/src/math/fromfpf128.h
+++ b/src/math/fromfpf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPF128_H
 #define LLVM_LIBC_SRC_MATH_FROMFPF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fromfpf128(float128 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPF128_H
diff --git a/src/math/fromfpf16.h b/src/math/fromfpf16.h
index 6e37c2d..a76a92f 100644
--- a/src/math/fromfpf16.h
+++ b/src/math/fromfpf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPF16_H
 #define LLVM_LIBC_SRC_MATH_FROMFPF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fromfpf16(float16 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPF16_H
diff --git a/src/math/fromfpl.h b/src/math/fromfpl.h
index dd8e1ee..dab2006 100644
--- a/src/math/fromfpl.h
+++ b/src/math/fromfpl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPL_H
 #define LLVM_LIBC_SRC_MATH_FROMFPL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fromfpl(long double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPL_H
diff --git a/src/math/fromfpx.h b/src/math/fromfpx.h
index 3fc96e1..e3e36a0 100644
--- a/src/math/fromfpx.h
+++ b/src/math/fromfpx.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPX_H
 #define LLVM_LIBC_SRC_MATH_FROMFPX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double fromfpx(double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPX_H
diff --git a/src/math/fromfpxf.h b/src/math/fromfpxf.h
index b55bc4c..5cc75ac 100644
--- a/src/math/fromfpxf.h
+++ b/src/math/fromfpxf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPXF_H
 #define LLVM_LIBC_SRC_MATH_FROMFPXF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float fromfpxf(float x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPXF_H
diff --git a/src/math/fromfpxf128.h b/src/math/fromfpxf128.h
index 8893264..32a7729 100644
--- a/src/math/fromfpxf128.h
+++ b/src/math/fromfpxf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPXF128_H
 #define LLVM_LIBC_SRC_MATH_FROMFPXF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 fromfpxf128(float128 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPXF128_H
diff --git a/src/math/fromfpxf16.h b/src/math/fromfpxf16.h
index f53afbc..516ef42 100644
--- a/src/math/fromfpxf16.h
+++ b/src/math/fromfpxf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPXF16_H
 #define LLVM_LIBC_SRC_MATH_FROMFPXF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 fromfpxf16(float16 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPXF16_H
diff --git a/src/math/fromfpxl.h b/src/math/fromfpxl.h
index 5452888..1940508 100644
--- a/src/math/fromfpxl.h
+++ b/src/math/fromfpxl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_FROMFPXL_H
 #define LLVM_LIBC_SRC_MATH_FROMFPXL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double fromfpxl(long double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_FROMFPXL_H
diff --git a/src/math/fsqrt.h b/src/math/fsqrt.h
new file mode 100644
index 0000000..e6a8c31
--- /dev/null
+++ b/src/math/fsqrt.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fsqrt -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSQRT_H
+#define LLVM_LIBC_SRC_MATH_FSQRT_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsqrt(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSQRT_H
diff --git a/src/math/fsqrtf128.h b/src/math/fsqrtf128.h
new file mode 100644
index 0000000..5286cbc
--- /dev/null
+++ b/src/math/fsqrtf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for fsqrtf128 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSQRTF128_H
+#define LLVM_LIBC_SRC_MATH_FSQRTF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsqrtf128(float128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSQRTF128_H
diff --git a/src/math/fsqrtl.h b/src/math/fsqrtl.h
new file mode 100644
index 0000000..a50eea3
--- /dev/null
+++ b/src/math/fsqrtl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fsqrtl ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSQRTL_H
+#define LLVM_LIBC_SRC_MATH_FSQRTL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsqrtl(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSQRTL_H
diff --git a/src/math/fsub.h b/src/math/fsub.h
new file mode 100644
index 0000000..f17f0fd
--- /dev/null
+++ b/src/math/fsub.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fsub --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSUB_H
+#define LLVM_LIBC_SRC_MATH_FSUB_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsub(double x, double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSUB_H
diff --git a/src/math/fsubf128.h b/src/math/fsubf128.h
new file mode 100644
index 0000000..4f41c7d
--- /dev/null
+++ b/src/math/fsubf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for fsubf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSUBF128_H
+#define LLVM_LIBC_SRC_MATH_FSUBF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsubf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSUBF128_H
diff --git a/src/math/fsubl.h b/src/math/fsubl.h
new file mode 100644
index 0000000..32570ca
--- /dev/null
+++ b/src/math/fsubl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fsubl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_FSUBL_H
+#define LLVM_LIBC_SRC_MATH_FSUBL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float fsubl(long double x, long double y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_FSUBL_H
diff --git a/src/math/generic/acosf.cpp b/src/math/generic/acosf.cpp
index f02edec..3c097a7 100644
--- a/src/math/generic/acosf.cpp
+++ b/src/math/generic/acosf.cpp
@@ -13,13 +13,12 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
 #include "inv_trigf_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static constexpr size_t N_EXCEPTS = 4;
 
@@ -120,4 +119,4 @@ LLVM_LIBC_FUNCTION(float, acosf, (float x)) {
   return static_cast<float>(x_sign ? M_MATH_PI - r : r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/acoshf.cpp b/src/math/generic/acoshf.cpp
index 9422ec6..6158063 100644
--- a/src/math/generic/acoshf.cpp
+++ b/src/math/generic/acoshf.cpp
@@ -12,11 +12,12 @@
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/math/generic/common_constants.h"
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, acoshf, (float x)) {
   using FPBits_t = typename fputil::FPBits<float>;
@@ -70,4 +71,4 @@ LLVM_LIBC_FUNCTION(float, acoshf, (float x)) {
       x_d + fputil::sqrt<double>(fputil::multiply_add(x_d, x_d, -1.0))));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/asinf.cpp b/src/math/generic/asinf.cpp
index c4afca4..3a89def 100644
--- a/src/math/generic/asinf.cpp
+++ b/src/math/generic/asinf.cpp
@@ -13,14 +13,13 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
 #include "inv_trigf_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static constexpr size_t N_EXCEPTS = 2;
 
@@ -152,4 +151,4 @@ LLVM_LIBC_FUNCTION(float, asinf, (float x)) {
   return static_cast<float>(fputil::multiply_add(c3, r, c2));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/asinhf.cpp b/src/math/generic/asinhf.cpp
index 82dc2a3..1d68ac9 100644
--- a/src/math/generic/asinhf.cpp
+++ b/src/math/generic/asinhf.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/math/generic/common_constants.h"
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, asinhf, (float x)) {
   using FPBits_t = typename fputil::FPBits<float>;
@@ -102,4 +103,4 @@ LLVM_LIBC_FUNCTION(float, asinhf, (float x)) {
                    fputil::sqrt<double>(fputil::multiply_add(x_d, x_d, 1.0)))));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atan2.cpp b/src/math/generic/atan2.cpp
new file mode 100644
index 0000000..1b16e15
--- /dev/null
+++ b/src/math/generic/atan2.cpp
@@ -0,0 +1,313 @@
+//===-- Double-precision atan2 function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/atan2.h"
+#include "inv_trigf_utils.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace {
+
+using DoubleDouble = fputil::DoubleDouble;
+
+// atan(i/64) with i = 0..64, generated by Sollya with:
+// > for i from 0 to 64 do {
+//     a = round(atan(i/64), D, RN);
+//     b = round(atan(i/64) - a, D, RN);
+//     print("{", b, ",", a, "},");
+//   };
+constexpr fputil::DoubleDouble ATAN_I[65] = {
+    {0.0, 0.0},
+    {-0x1.220c39d4dff5p-61, 0x1.fff555bbb729bp-7},
+    {-0x1.5ec431444912cp-60, 0x1.ffd55bba97625p-6},
+    {-0x1.86ef8f794f105p-63, 0x1.7fb818430da2ap-5},
+    {-0x1.c934d86d23f1dp-60, 0x1.ff55bb72cfdeap-5},
+    {0x1.ac4ce285df847p-58, 0x1.3f59f0e7c559dp-4},
+    {-0x1.cfb654c0c3d98p-58, 0x1.7ee182602f10fp-4},
+    {0x1.f7b8f29a05987p-58, 0x1.be39ebe6f07c3p-4},
+    {-0x1.cd37686760c17p-59, 0x1.fd5ba9aac2f6ep-4},
+    {-0x1.b485914dacf8cp-59, 0x1.1e1fafb043727p-3},
+    {0x1.61a3b0ce9281bp-57, 0x1.3d6eee8c6626cp-3},
+    {-0x1.054ab2c010f3dp-58, 0x1.5c9811e3ec26ap-3},
+    {0x1.347b0b4f881cap-58, 0x1.7b97b4bce5b02p-3},
+    {0x1.cf601e7b4348ep-59, 0x1.9a6a8e96c8626p-3},
+    {0x1.17b10d2e0e5abp-61, 0x1.b90d7529260a2p-3},
+    {0x1.c648d1534597ep-57, 0x1.d77d5df205736p-3},
+    {0x1.8ab6e3cf7afbdp-57, 0x1.f5b75f92c80ddp-3},
+    {0x1.62e47390cb865p-56, 0x1.09dc597d86362p-2},
+    {0x1.30ca4748b1bf9p-57, 0x1.18bf5a30bf178p-2},
+    {-0x1.077cdd36dfc81p-56, 0x1.278372057ef46p-2},
+    {-0x1.963a544b672d8p-57, 0x1.362773707ebccp-2},
+    {-0x1.5d5e43c55b3bap-56, 0x1.44aa436c2af0ap-2},
+    {-0x1.2566480884082p-57, 0x1.530ad9951cd4ap-2},
+    {-0x1.a725715711fp-56, 0x1.614840309cfe2p-2},
+    {-0x1.c63aae6f6e918p-56, 0x1.6f61941e4def1p-2},
+    {0x1.69c885c2b249ap-56, 0x1.7d5604b63b3f7p-2},
+    {0x1.b6d0ba3748fa8p-56, 0x1.8b24d394a1b25p-2},
+    {0x1.9e6c988fd0a77p-56, 0x1.98cd5454d6b18p-2},
+    {-0x1.24dec1b50b7ffp-56, 0x1.a64eec3cc23fdp-2},
+    {0x1.ae187b1ca504p-56, 0x1.b3a911da65c6cp-2},
+    {-0x1.cc1ce70934c34p-56, 0x1.c0db4c94ec9fp-2},
+    {-0x1.a2cfa4418f1adp-56, 0x1.cde53432c1351p-2},
+    {0x1.a2b7f222f65e2p-56, 0x1.dac670561bb4fp-2},
+    {0x1.0e53dc1bf3435p-56, 0x1.e77eb7f175a34p-2},
+    {-0x1.a3992dc382a23p-57, 0x1.f40dd0b541418p-2},
+    {-0x1.b32c949c9d593p-55, 0x1.0039c73c1a40cp-1},
+    {-0x1.d5b495f6349e6p-56, 0x1.0657e94db30dp-1},
+    {0x1.974fa13b5404fp-58, 0x1.0c6145b5b43dap-1},
+    {-0x1.2bdaee1c0ee35p-58, 0x1.1255d9bfbd2a9p-1},
+    {0x1.c621cec00c301p-55, 0x1.1835a88be7c13p-1},
+    {-0x1.928df287a668fp-58, 0x1.1e00babdefeb4p-1},
+    {0x1.c421c9f38224ep-57, 0x1.23b71e2cc9e6ap-1},
+    {-0x1.09e73b0c6c087p-56, 0x1.2958e59308e31p-1},
+    {0x1.c5d5e9ff0cf8dp-55, 0x1.2ee628406cbcap-1},
+    {0x1.1021137c71102p-55, 0x1.345f01cce37bbp-1},
+    {-0x1.2304331d8bf46p-55, 0x1.39c391cd4171ap-1},
+    {0x1.ecf8b492644fp-56, 0x1.3f13fb89e96f4p-1},
+    {-0x1.f76d0163f79c8p-56, 0x1.445065b795b56p-1},
+    {0x1.2419a87f2a458p-56, 0x1.4978fa3269ee1p-1},
+    {0x1.4a33dbeb3796cp-55, 0x1.4e8de5bb6ec04p-1},
+    {-0x1.1bb74abda520cp-55, 0x1.538f57b89061fp-1},
+    {-0x1.5e5c9d8c5a95p-56, 0x1.587d81f732fbbp-1},
+    {0x1.0028e4bc5e7cap-57, 0x1.5d58987169b18p-1},
+    {-0x1.2b785350ee8c1p-57, 0x1.6220d115d7b8ep-1},
+    {-0x1.6ea6febe8bbbap-56, 0x1.66d663923e087p-1},
+    {-0x1.a80386188c50ep-55, 0x1.6b798920b3d99p-1},
+    {-0x1.8c34d25aadef6p-56, 0x1.700a7c5784634p-1},
+    {0x1.7b2a6165884a1p-59, 0x1.748978fba8e0fp-1},
+    {0x1.406a08980374p-55, 0x1.78f6bbd5d315ep-1},
+    {0x1.560821e2f3aa9p-55, 0x1.7d528289fa093p-1},
+    {-0x1.bf76229d3b917p-56, 0x1.819d0b7158a4dp-1},
+    {0x1.6b66e7fc8b8c3p-57, 0x1.85d69576cc2c5p-1},
+    {-0x1.55b9a5e177a1bp-55, 0x1.89ff5ff57f1f8p-1},
+    {-0x1.ec182ab042f61p-56, 0x1.8e17aa99cc05ep-1},
+    {0x1.1a62633145c07p-55, 0x1.921fb54442d18p-1},
+};
+
+// Approximate atan(x) for |x| <= 2^-7.
+// Using degree-9 Taylor polynomial:
+//  P = x - x^3/3 + x^5/5 -x^7/7 + x^9/9;
+// Then the absolute error is bounded by:
+//   |atan(x) - P(x)| < |x|^11/11 < 2^(-7*11) / 11 < 2^-80.
+// And the relative error is bounded by:
+//   |(atan(x) - P(x))/atan(x)| < |x|^10 / 10 < 2^-73.
+// For x = x_hi + x_lo, fully expand the polynomial and drop any terms less than
+//   ulp(x_hi^3 / 3) gives us:
+// P(x) ~ x_hi - x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
+//        + x_lo * (1 - x_hi^2 + x_hi^4)
+DoubleDouble atan_eval(const DoubleDouble &x) {
+  DoubleDouble p;
+  p.hi = x.hi;
+  double x_hi_sq = x.hi * x.hi;
+  // c0 ~ x_hi^2 * 1/5 - 1/3
+  double c0 = fputil::multiply_add(x_hi_sq, 0x1.999999999999ap-3,
+                                   -0x1.5555555555555p-2);
+  // c1 ~ x_hi^2 * 1/9 - 1/7
+  double c1 = fputil::multiply_add(x_hi_sq, 0x1.c71c71c71c71cp-4,
+                                   -0x1.2492492492492p-3);
+  // x_hi^3
+  double x_hi_3 = x_hi_sq * x.hi;
+  // x_hi^4
+  double x_hi_4 = x_hi_sq * x_hi_sq;
+  // d0 ~ 1/3 - x_hi^2 / 5 + x_hi^4 / 7 - x_hi^6 / 9
+  double d0 = fputil::multiply_add(x_hi_4, c1, c0);
+  // x_lo - x_lo * x_hi^2 + x_lo * x_hi^4
+  double d1 = fputil::multiply_add(x_hi_4 - x_hi_sq, x.lo, x.lo);
+  // p.lo ~ -x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
+  //        + x_lo * (1 - x_hi^2 + x_hi^4)
+  p.lo = fputil::multiply_add(x_hi_3, d0, d1);
+  return p;
+}
+
+} // anonymous namespace
+
+// There are several range reduction steps we can take for atan2(y, x) as
+// follow:
+
+// * Range reduction 1: signness
+// atan2(y, x) will return a number between -PI and PI representing the angle
+// forming by the 0x axis and the vector (x, y) on the 0xy-plane.
+// In particular, we have that:
+//   atan2(y, x) = atan( y/x )         if x >= 0 and y >= 0 (I-quadrant)
+//               = pi + atan( y/x )    if x < 0 and y >= 0  (II-quadrant)
+//               = -pi + atan( y/x )   if x < 0 and y < 0   (III-quadrant)
+//               = atan( y/x )         if x >= 0 and y < 0  (IV-quadrant)
+// Since atan function is odd, we can use the formula:
+//   atan(-u) = -atan(u)
+// to adjust the above conditions a bit further:
+//   atan2(y, x) = atan( |y|/|x| )         if x >= 0 and y >= 0 (I-quadrant)
+//               = pi - atan( |y|/|x| )    if x < 0 and y >= 0  (II-quadrant)
+//               = -pi + atan( |y|/|x| )   if x < 0 and y < 0   (III-quadrant)
+//               = -atan( |y|/|x| )        if x >= 0 and y < 0  (IV-quadrant)
+// Which can be simplified to:
+//   atan2(y, x) = sign(y) * atan( |y|/|x| )             if x >= 0
+//               = sign(y) * (pi - atan( |y|/|x| ))      if x < 0
+
+// * Range reduction 2: reciprocal
+// Now that the argument inside atan is positive, we can use the formula:
+//   atan(1/x) = pi/2 - atan(x)
+// to make the argument inside atan <= 1 as follow:
+//   atan2(y, x) = sign(y) * atan( |y|/|x|)            if 0 <= |y| <= x
+//               = sign(y) * (pi/2 - atan( |x|/|y| )   if 0 <= x < |y|
+//               = sign(y) * (pi - atan( |y|/|x| ))    if 0 <= |y| <= -x
+//               = sign(y) * (pi/2 + atan( |x|/|y| ))  if 0 <= -x < |y|
+
+// * Range reduction 3: look up table.
+// After the previous two range reduction steps, we reduce the problem to
+// compute atan(u) with 0 <= u <= 1, or to be precise:
+//   atan( n / d ) where n = min(|x|, |y|) and d = max(|x|, |y|).
+// An accurate polynomial approximation for the whole [0, 1] input range will
+// require a very large degree.  To make it more efficient, we reduce the input
+// range further by finding an integer idx such that:
+//   | n/d - idx/64 | <= 1/128.
+// In particular,
+//   idx := round(2^6 * n/d)
+// Then for the fast pass, we find a polynomial approximation for:
+//   atan( n/d ) ~ atan( idx/64 ) + (n/d - idx/64) * Q(n/d - idx/64)
+// For the accurate pass, we use the addition formula:
+//   atan( n/d ) - atan( idx/64 ) = atan( (n/d - idx/64)/(1 + (n*idx)/(64*d)) )
+//                                = atan( (n - d*(idx/64))/(d + n*(idx/64)) )
+// And for the fast pass, we use degree-9 Taylor polynomial to compute the RHS:
+//   atan(u) ~ P(u) = u - u^3/3 + u^5/5 - u^7/7 + u^9/9
+// with absolute errors bounded by:
+//   |atan(u) - P(u)| < |u|^11 / 11 < 2^-80
+// and relative errors bounded by:
+//   |(atan(u) - P(u)) / P(u)| < u^10 / 11 < 2^-73.
+
+LLVM_LIBC_FUNCTION(double, atan2, (double y, double x)) {
+  using FPBits = fputil::FPBits<double>;
+
+  constexpr double IS_NEG[2] = {1.0, -1.0};
+  constexpr DoubleDouble ZERO = {0.0, 0.0};
+  constexpr DoubleDouble MZERO = {-0.0, -0.0};
+  constexpr DoubleDouble PI = {0x1.1a62633145c07p-53, 0x1.921fb54442d18p+1};
+  constexpr DoubleDouble MPI = {-0x1.1a62633145c07p-53, -0x1.921fb54442d18p+1};
+  constexpr DoubleDouble PI_OVER_2 = {0x1.1a62633145c07p-54,
+                                      0x1.921fb54442d18p0};
+  constexpr DoubleDouble MPI_OVER_2 = {-0x1.1a62633145c07p-54,
+                                       -0x1.921fb54442d18p0};
+  constexpr DoubleDouble PI_OVER_4 = {0x1.1a62633145c07p-55,
+                                      0x1.921fb54442d18p-1};
+  constexpr DoubleDouble THREE_PI_OVER_4 = {0x1.a79394c9e8a0ap-54,
+                                            0x1.2d97c7f3321d2p+1};
+  // Adjustment for constant term:
+  //   CONST_ADJ[x_sign][y_sign][recip]
+  constexpr DoubleDouble CONST_ADJ[2][2][2] = {
+      {{ZERO, MPI_OVER_2}, {MZERO, MPI_OVER_2}},
+      {{MPI, PI_OVER_2}, {MPI, PI_OVER_2}}};
+
+  FPBits x_bits(x), y_bits(y);
+  bool x_sign = x_bits.sign().is_neg();
+  bool y_sign = y_bits.sign().is_neg();
+  x_bits = x_bits.abs();
+  y_bits = y_bits.abs();
+  uint64_t x_abs = x_bits.uintval();
+  uint64_t y_abs = y_bits.uintval();
+  bool recip = x_abs < y_abs;
+  uint64_t min_abs = recip ? x_abs : y_abs;
+  uint64_t max_abs = !recip ? x_abs : y_abs;
+  unsigned min_exp = static_cast<unsigned>(min_abs >> FPBits::FRACTION_LEN);
+  unsigned max_exp = static_cast<unsigned>(max_abs >> FPBits::FRACTION_LEN);
+
+  double num = FPBits(min_abs).get_val();
+  double den = FPBits(max_abs).get_val();
+
+  // Check for exceptional cases, whether inputs are 0, inf, nan, or close to
+  // overflow, or close to underflow.
+  if (LIBC_UNLIKELY(max_exp > 0x7ffU - 128U || min_exp < 128U)) {
+    if (x_bits.is_nan() || y_bits.is_nan())
+      return FPBits::quiet_nan().get_val();
+    unsigned x_except = x == 0.0 ? 0 : (FPBits(x_abs).is_inf() ? 2 : 1);
+    unsigned y_except = y == 0.0 ? 0 : (FPBits(y_abs).is_inf() ? 2 : 1);
+
+    // Exceptional cases:
+    //   EXCEPT[y_except][x_except][x_is_neg]
+    // with x_except & y_except:
+    //   0: zero
+    //   1: finite, non-zero
+    //   2: infinity
+    constexpr DoubleDouble EXCEPTS[3][3][2] = {
+        {{ZERO, PI}, {ZERO, PI}, {ZERO, PI}},
+        {{PI_OVER_2, PI_OVER_2}, {ZERO, ZERO}, {ZERO, PI}},
+        {{PI_OVER_2, PI_OVER_2},
+         {PI_OVER_2, PI_OVER_2},
+         {PI_OVER_4, THREE_PI_OVER_4}},
+    };
+
+    if ((x_except != 1) || (y_except != 1)) {
+      DoubleDouble r = EXCEPTS[y_except][x_except][x_sign];
+      return fputil::multiply_add(IS_NEG[y_sign], r.hi, IS_NEG[y_sign] * r.lo);
+    }
+    bool scale_up = min_exp < 128U;
+    bool scale_down = max_exp > 0x7ffU - 128U;
+    // At least one input is denormal, multiply both numerator and denominator
+    // by some large enough power of 2 to normalize denormal inputs.
+    if (scale_up) {
+      num *= 0x1.0p64;
+      if (!scale_down)
+        den *= 0x1.0p64;
+    } else if (scale_down) {
+      den *= 0x1.0p-64;
+      if (!scale_up)
+        num *= 0x1.0p-64;
+    }
+
+    min_abs = FPBits(num).uintval();
+    max_abs = FPBits(den).uintval();
+    min_exp = static_cast<unsigned>(min_abs >> FPBits::FRACTION_LEN);
+    max_exp = static_cast<unsigned>(max_abs >> FPBits::FRACTION_LEN);
+  }
+
+  double final_sign = IS_NEG[(x_sign != y_sign) != recip];
+  DoubleDouble const_term = CONST_ADJ[x_sign][y_sign][recip];
+  unsigned exp_diff = max_exp - min_exp;
+  // We have the following bound for normalized n and d:
+  //   2^(-exp_diff - 1) < n/d < 2^(-exp_diff + 1).
+  if (LIBC_UNLIKELY(exp_diff > 54)) {
+    return fputil::multiply_add(final_sign, const_term.hi,
+                                final_sign * (const_term.lo + num / den));
+  }
+
+  double k = fputil::nearest_integer(64.0 * num / den);
+  unsigned idx = static_cast<unsigned>(k);
+  // k = idx / 64
+  k *= 0x1.0p-6;
+
+  // Range reduction:
+  // atan(n/d) - atan(k/64) = atan((n/d - k/64) / (1 + (n/d) * (k/64)))
+  //                        = atan((n - d * k/64)) / (d + n * k/64))
+  DoubleDouble num_k = fputil::exact_mult(num, k);
+  DoubleDouble den_k = fputil::exact_mult(den, k);
+
+  // num_dd = n - d * k
+  DoubleDouble num_dd = fputil::exact_add(num - den_k.hi, -den_k.lo);
+  // den_dd = d + n * k
+  DoubleDouble den_dd = fputil::exact_add(den, num_k.hi);
+  den_dd.lo += num_k.lo;
+
+  // q = (n - d * k) / (d + n * k)
+  DoubleDouble q = fputil::div(num_dd, den_dd);
+  // p ~ atan(q)
+  DoubleDouble p = atan_eval(q);
+
+  DoubleDouble r = fputil::add(const_term, fputil::add(ATAN_I[idx], p));
+  r.hi *= final_sign;
+  r.lo *= final_sign;
+
+  return r.hi + r.lo;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atan2f.cpp b/src/math/generic/atan2f.cpp
index b79410d..a2e5499 100644
--- a/src/math/generic/atan2f.cpp
+++ b/src/math/generic/atan2f.cpp
@@ -14,9 +14,10 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -245,12 +246,18 @@ LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
   uint32_t y_abs = y_bits.uintval();
   uint32_t max_abs = x_abs > y_abs ? x_abs : y_abs;
   uint32_t min_abs = x_abs <= y_abs ? x_abs : y_abs;
+  float num_f = FPBits(min_abs).get_val();
+  float den_f = FPBits(max_abs).get_val();
+  double num_d = static_cast<double>(num_f);
+  double den_d = static_cast<double>(den_f);
 
-  if (LIBC_UNLIKELY(max_abs >= 0x7f80'0000U || min_abs == 0U)) {
+  if (LIBC_UNLIKELY(max_abs >= 0x7f80'0000U || num_d == 0.0)) {
     if (x_bits.is_nan() || y_bits.is_nan())
       return FPBits::quiet_nan().get_val();
-    size_t x_except = x_abs == 0 ? 0 : (x_abs == 0x7f80'0000 ? 2 : 1);
-    size_t y_except = y_abs == 0 ? 0 : (y_abs == 0x7f80'0000 ? 2 : 1);
+    double x_d = static_cast<double>(x);
+    double y_d = static_cast<double>(y);
+    size_t x_except = (x_d == 0.0) ? 0 : (x_abs == 0x7f80'0000 ? 2 : 1);
+    size_t y_except = (y_d == 0.0) ? 0 : (y_abs == 0x7f80'0000 ? 2 : 1);
 
     // Exceptional cases:
     //   EXCEPT[y_except][x_except][x_is_neg]
@@ -274,8 +281,6 @@ LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
   bool recip = x_abs < y_abs;
   double final_sign = IS_NEG[(x_sign != y_sign) != recip];
   fputil::DoubleDouble const_term = CONST_ADJ[x_sign][y_sign][recip];
-  double num_d = static_cast<double>(FPBits(min_abs).get_val());
-  double den_d = static_cast<double>(FPBits(max_abs).get_val());
   double q_d = num_d / den_d;
 
   double k_d = fputil::nearest_integer(q_d * 0x1.0p4f);
@@ -303,4 +308,4 @@ LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
                               const_term);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atan2l.cpp b/src/math/generic/atan2l.cpp
new file mode 100644
index 0000000..47a2e98
--- /dev/null
+++ b/src/math/generic/atan2l.cpp
@@ -0,0 +1,26 @@
+//===-- Extended-precision atan2 function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/atan2l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/properties/types.h"
+#include "src/math/atan2.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO: Implement this for extended precision.
+LLVM_LIBC_FUNCTION(long double, atan2l, (long double y, long double x)) {
+#if defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
+  return static_cast<long double>(
+      atan2(static_cast<double>(y), static_cast<double>(x)));
+#else
+#error "Extended precision is not yet supported"
+#endif
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atanf.cpp b/src/math/generic/atanf.cpp
index 9fa1a33..5e0788e 100644
--- a/src/math/generic/atanf.cpp
+++ b/src/math/generic/atanf.cpp
@@ -14,9 +14,10 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -117,4 +118,4 @@ LLVM_LIBC_FUNCTION(float, atanf, (float x)) {
   return static_cast<float>(r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atanhf.cpp b/src/math/generic/atanhf.cpp
index 97fd1b2..a2051bd 100644
--- a/src/math/generic/atanhf.cpp
+++ b/src/math/generic/atanhf.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/atanhf.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanhf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -58,4 +59,4 @@ LLVM_LIBC_FUNCTION(float, atanhf, (float x)) {
   return static_cast<float>(0.5 * log_eval((xdbl + 1.0) / (xdbl - 1.0)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/canonicalize.cpp b/src/math/generic/canonicalize.cpp
index f38ca01..d93501d 100644
--- a/src/math/generic/canonicalize.cpp
+++ b/src/math/generic/canonicalize.cpp
@@ -9,11 +9,12 @@
 #include "src/math/canonicalize.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, canonicalize, (double *cx, const double *x)) {
   return fputil::canonicalize(*cx, *x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/canonicalizef.cpp b/src/math/generic/canonicalizef.cpp
index dce601d..437cf87 100644
--- a/src/math/generic/canonicalizef.cpp
+++ b/src/math/generic/canonicalizef.cpp
@@ -9,11 +9,12 @@
 #include "src/math/canonicalizef.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, canonicalizef, (float *cx, const float *x)) {
   return fputil::canonicalize(*cx, *x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/canonicalizef128.cpp b/src/math/generic/canonicalizef128.cpp
index 0078b47..477d9c7 100644
--- a/src/math/generic/canonicalizef128.cpp
+++ b/src/math/generic/canonicalizef128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/canonicalizef128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, canonicalizef128, (float128 * cx, const float128 *x)) {
   return fputil::canonicalize(*cx, *x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/canonicalizef16.cpp b/src/math/generic/canonicalizef16.cpp
index 232e84f..ff32c91 100644
--- a/src/math/generic/canonicalizef16.cpp
+++ b/src/math/generic/canonicalizef16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/canonicalizef16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, canonicalizef16, (float16 * cx, const float16 *x)) {
   return fputil::canonicalize(*cx, *x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/canonicalizel.cpp b/src/math/generic/canonicalizel.cpp
index 5310a31..fa2b846 100644
--- a/src/math/generic/canonicalizel.cpp
+++ b/src/math/generic/canonicalizel.cpp
@@ -9,12 +9,13 @@
 #include "src/math/canonicalizel.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, canonicalizel,
                    (long double *cx, const long double *x)) {
   return fputil::canonicalize(*cx, *x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cbrt.cpp b/src/math/generic/cbrt.cpp
new file mode 100644
index 0000000..ee7d69b
--- /dev/null
+++ b/src/math/generic/cbrt.cpp
@@ -0,0 +1,340 @@
+//===-- Implementation of cbrt function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cbrt.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+#if ((LIBC_MATH & LIBC_MATH_SKIP_ACCURATE_PASS) != 0)
+#define LIBC_MATH_CBRT_SKIP_ACCURATE_PASS
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+using DoubleDouble = fputil::DoubleDouble;
+using Float128 = fputil::DyadicFloat<128>;
+
+namespace {
+
+// Initial approximation of x^(-2/3) for 1 <= x < 2.
+// Polynomial generated by Sollya with:
+// > P = fpminimax(x^(-2/3), 7, [|D...|], [1, 2]);
+// > dirtyinfnorm(P/x^(-2/3) - 1, [1, 2]);
+// 0x1.28...p-21
+double intial_approximation(double x) {
+  constexpr double COEFFS[8] = {
+      0x1.bc52aedead5c6p1,  -0x1.b52bfebf110b3p2,  0x1.1d8d71d53d126p3,
+      -0x1.de2db9e81cf87p2, 0x1.0154ca06153bdp2,   -0x1.5973c66ee6da7p0,
+      0x1.07bf6ac832552p-2, -0x1.5e53d9ce41cb8p-6,
+  };
+
+  double x_sq = x * x;
+
+  double c0 = fputil::multiply_add(x, COEFFS[1], COEFFS[0]);
+  double c1 = fputil::multiply_add(x, COEFFS[3], COEFFS[2]);
+  double c2 = fputil::multiply_add(x, COEFFS[5], COEFFS[4]);
+  double c3 = fputil::multiply_add(x, COEFFS[7], COEFFS[6]);
+
+  double x_4 = x_sq * x_sq;
+  double d0 = fputil::multiply_add(x_sq, c1, c0);
+  double d1 = fputil::multiply_add(x_sq, c3, c2);
+
+  return fputil::multiply_add(x_4, d1, d0);
+}
+
+// Get the error term for Newton iteration:
+//   h(x) = x^3 * a^2 - 1,
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+double get_error(const DoubleDouble &x_3, const DoubleDouble &a_sq) {
+  return fputil::multiply_add(x_3.hi, a_sq.hi, -1.0) +
+         fputil::multiply_add(x_3.lo, a_sq.hi, x_3.hi * a_sq.lo);
+}
+#else
+double get_error(const DoubleDouble &x_3, const DoubleDouble &a_sq) {
+  DoubleDouble x_3_a_sq = fputil::quick_mult(a_sq, x_3);
+  return (x_3_a_sq.hi - 1.0) + x_3_a_sq.lo;
+}
+#endif
+
+} // anonymous namespace
+
+// Correctly rounded cbrt algorithm:
+//
+// === Step 1 - Range reduction ===
+// For x = (-1)^s * 2^e * (1.m), we get 2 reduced arguments x_r and a as:
+//   x_r = 1.m
+//   a   = (-1)^s * 2^(e % 3) * (1.m)
+// Then cbrt(x) = x^(1/3) can be computed as:
+//   x^(1/3) = 2^(e / 3) * a^(1/3).
+//
+// In order to avoid division, we compute a^(-2/3) using Newton method and then
+// multiply the results by a:
+//   a^(1/3) = a * a^(-2/3).
+//
+// === Step 2 - First approximation to a^(-2/3) ===
+// First, we use a degree-7 minimax polynomial generated by Sollya to
+// approximate x_r^(-2/3) for 1 <= x_r < 2.
+//   p = P(x_r) ~ x_r^(-2/3),
+// with relative errors bounded by:
+//   | p / x_r^(-2/3) - 1 | < 1.16 * 2^-21.
+//
+// Then we multiply with 2^(e % 3) from a small lookup table to get:
+//   x_0 = 2^(-2*(e % 3)/3) * p
+//       ~ 2^(-2*(e % 3)/3) * x_r^(-2/3)
+//       = a^(-2/3)
+// With relative errors:
+//   | x_0 / a^(-2/3) - 1 | < 1.16 * 2^-21.
+// This step is done in double precision.
+//
+// === Step 3 - First Newton iteration ===
+// We follow the method described in:
+//   Sibidanov, A. and Zimmermann, P., "Correctly rounded cubic root evaluation
+//   in double precision", https://core-math.gitlabpages.inria.fr/cbrt64.pdf
+// to derive multiplicative Newton iterations as below:
+// Let x_n be the nth approximation to a^(-2/3).  Define the n^th error as:
+//   h_n = x_n^3 * a^2 - 1
+// Then:
+//   a^(-2/3) = x_n / (1 + h_n)^(1/3)
+//            = x_n * (1 - (1/3) * h_n + (2/9) * h_n^2 - (14/81) * h_n^3 + ...)
+// using the Taylor series expansion of (1 + h_n)^(-1/3).
+//
+// Apply to x_0 above:
+//   h_0 = x_0^3 * a^2 - 1
+//       = a^2 * (x_0 - a^(-2/3)) * (x_0^2 + x_0 * a^(-2/3) + a^(-4/3)),
+// it's bounded by:
+//   |h_0| < 4 * 3 * 1.16 * 2^-21 * 4 < 2^-17.
+// So in the first iteration step, we use:
+//   x_1 = x_0 * (1 - (1/3) * h_n + (2/9) * h_n^2 - (14/81) * h_n^3)
+// Its relative error is bounded by:
+//   | x_1 / a^(-2/3) - 1 | < 35/242 * |h_0|^4 < 2^-70.
+// Then we perform Ziv's rounding test and check if the answer is exact.
+// This step is done in double-double precision.
+//
+// === Step 4 - Second Newton iteration ===
+// If the Ziv's rounding test from the previous step fails, we define the error
+// term:
+//   h_1 = x_1^3 * a^2 - 1,
+// And perform another iteration:
+//   x_2 = x_1 * (1 - h_1 / 3)
+// with the relative errors exceed the precision of double-double.
+// We then check the Ziv's accuracy test with relative errors < 2^-102 to
+// compensate for rounding errors.
+//
+// === Step 5 - Final iteration ===
+// If the Ziv's accuracy test from the previous step fails, we perform another
+// iteration in 128-bit precision and check for exact outputs.
+//
+// TODO: It is possible to replace this costly computation step with special
+// exceptional handling, similar to what was done in the CORE-MATH project:
+// https://gitlab.inria.fr/core-math/core-math/-/blob/master/src/binary64/cbrt/cbrt.c
+
+LLVM_LIBC_FUNCTION(double, cbrt, (double x)) {
+  using FPBits = fputil::FPBits<double>;
+
+  uint64_t x_abs = FPBits(x).abs().uintval();
+
+  unsigned exp_bias_correction = 682; // 1023 * 2/3
+
+  if (LIBC_UNLIKELY(x_abs < FPBits::min_normal().uintval() ||
+                    x_abs >= FPBits::inf().uintval())) {
+    if (x == 0.0 || x_abs >= FPBits::inf().uintval())
+      // x is 0, Inf, or NaN.
+      // Make sure it works for FTZ/DAZ modes.
+      return static_cast<double>(x + x);
+
+    // x is non-zero denormal number.
+    // Normalize x.
+    x *= 0x1.0p60;
+    exp_bias_correction -= 20;
+  }
+
+  FPBits x_bits(x);
+
+  // When using biased exponent of x in double precision,
+  //   x_e = real_exponent_of_x + 1023
+  // Then:
+  //   x_e / 3 = real_exponent_of_x / 3 + 1023/3
+  //           = real_exponent_of_x / 3 + 341
+  // So to make it the correct biased exponent of x^(1/3), we add
+  //   1023 - 341 = 682
+  // to the quotient x_e / 3.
+  unsigned x_e = static_cast<unsigned>(x_bits.get_biased_exponent());
+  unsigned out_e = (x_e / 3 + exp_bias_correction);
+  unsigned shift_e = x_e % 3;
+
+  // Set x_r = 1.mantissa
+  double x_r =
+      FPBits(x_bits.get_mantissa() |
+             (static_cast<uint64_t>(FPBits::EXP_BIAS) << FPBits::FRACTION_LEN))
+          .get_val();
+
+  // Set a = (-1)^x_sign * 2^(x_e % 3) * (1.mantissa)
+  uint64_t a_bits = x_bits.uintval() & 0x800F'FFFF'FFFF'FFFF;
+  a_bits |=
+      (static_cast<uint64_t>(shift_e + static_cast<unsigned>(FPBits::EXP_BIAS))
+       << FPBits::FRACTION_LEN);
+  double a = FPBits(a_bits).get_val();
+
+  // Initial approximation of x_r^(-2/3).
+  double p = intial_approximation(x_r);
+
+  // Look up for 2^(-2*n/3) used for first approximation step.
+  constexpr double EXP2_M2_OVER_3[3] = {1.0, 0x1.428a2f98d728bp-1,
+                                        0x1.965fea53d6e3dp-2};
+
+  // x0 is an initial approximation of a^(-2/3) for 1 <= |a| < 8.
+  // Relative error: < 1.16 * 2^(-21).
+  double x0 = static_cast<double>(EXP2_M2_OVER_3[shift_e] * p);
+
+  // First iteration in double precision.
+  DoubleDouble a_sq = fputil::exact_mult(a, a);
+
+  // h0 = x0^3 * a^2 - 1
+  DoubleDouble x0_sq = fputil::exact_mult(x0, x0);
+  DoubleDouble x0_3 = fputil::quick_mult(x0, x0_sq);
+
+  double h0 = get_error(x0_3, a_sq);
+
+#ifdef LIBC_MATH_CBRT_SKIP_ACCURATE_PASS
+  constexpr double REL_ERROR = 0;
+#else
+  constexpr double REL_ERROR = 0x1.0p-51;
+#endif // LIBC_MATH_CBRT_SKIP_ACCURATE_PASS
+
+  // Taylor polynomial of (1 + h)^(-1/3):
+  //   (1 + h)^(-1/3) = 1 - h/3 + 2 h^2 / 9 - 14 h^3 / 81 + ...
+  constexpr double ERR_COEFFS[3] = {
+      -0x1.5555555555555p-2 - REL_ERROR, // -1/3 - relative_error
+      0x1.c71c71c71c71cp-3,              // 2/9
+      -0x1.61f9add3c0ca4p-3,             // -14/81
+  };
+  // e0 = -14 * h^2 / 81 + 2 * h / 9 - 1/3 - relative_error.
+  double e0 = fputil::polyeval(h0, ERR_COEFFS[0], ERR_COEFFS[1], ERR_COEFFS[2]);
+  double x0_h0 = x0 * h0;
+
+  // x1 = x0 (1 - h0/3 + 2 h0^2 / 9 - 14 h0^3 / 81)
+  // x1 approximate a^(-2/3) with relative errors bounded by:
+  //   | x1 / a^(-2/3) - 1 | < (34/243) h0^4 < h0 * REL_ERROR
+  DoubleDouble x1_dd{x0_h0 * e0, x0};
+
+  // r1 = x1 * a ~ a^(-2/3) * a = a^(1/3).
+  DoubleDouble r1 = fputil::quick_mult(a, x1_dd);
+
+  // Lambda function to update the exponent of the result.
+  auto update_exponent = [=](double r) -> double {
+    uint64_t r_m = FPBits(r).uintval() - 0x3FF0'0000'0000'0000;
+    // Adjust exponent and sign.
+    uint64_t r_bits =
+        r_m + (static_cast<uint64_t>(out_e) << FPBits::FRACTION_LEN);
+    return FPBits(r_bits).get_val();
+  };
+
+#ifdef LIBC_MATH_CBRT_SKIP_ACCURATE_PASS
+  // TODO: We probably don't need to use double-double if accurate tests and
+  // passes are skipped.
+  return update_exponent(r1.hi + r1.lo);
+#else
+  // Accurate checks and passes.
+  double r1_lower = r1.hi + r1.lo;
+  double r1_upper =
+      r1.hi + fputil::multiply_add(x0_h0, 2.0 * REL_ERROR * a, r1.lo);
+
+  // Ziv's accuracy test.
+  if (LIBC_LIKELY(r1_upper == r1_lower)) {
+    // Test for exact outputs.
+    // Check if lower (52 - 17 = 35) bits are 0's.
+    if (LIBC_UNLIKELY((FPBits(r1_lower).uintval() & 0x0000'0007'FFFF'FFFF) ==
+                      0)) {
+      double r1_err = (r1_lower - r1.hi) - r1.lo;
+      if (FPBits(r1_err).abs().get_val() < 0x1.0p69)
+        fputil::clear_except_if_required(FE_INEXACT);
+    }
+
+    return update_exponent(r1_lower);
+  }
+
+  // Accuracy test failed, perform another Newton iteration.
+  double x1 = x1_dd.hi + (e0 + REL_ERROR) * x0_h0;
+
+  // Second iteration in double-double precision.
+  // h1 = x1^3 * a^2 - 1.
+  DoubleDouble x1_sq = fputil::exact_mult(x1, x1);
+  DoubleDouble x1_3 = fputil::quick_mult(x1, x1_sq);
+  double h1 = get_error(x1_3, a_sq);
+
+  // e1 = -x1*h1/3.
+  double e1 = h1 * (x1 * -0x1.5555555555555p-2);
+  // x2 = x1*(1 - h1/3) = x1 + e1 ~ a^(-2/3) with relative errors < 2^-101.
+  DoubleDouble x2 = fputil::exact_add(x1, e1);
+  // r2 = a * x2 ~ a * a^(-2/3) = a^(1/3) with relative errors < 2^-100.
+  DoubleDouble r2 = fputil::quick_mult(a, x2);
+
+  double r2_upper = r2.hi + fputil::multiply_add(a, 0x1.0p-102, r2.lo);
+  double r2_lower = r2.hi + fputil::multiply_add(a, -0x1.0p-102, r2.lo);
+
+  // Ziv's accuracy test.
+  if (LIBC_LIKELY(r2_upper == r2_lower))
+    return update_exponent(r2_upper);
+
+  // TODO: Investigate removing float128 and just list exceptional cases.
+  // Apply another Newton iteration with ~126-bit accuracy.
+  Float128 x2_f128 = fputil::quick_add(Float128(x2.hi), Float128(x2.lo));
+  // x2^3
+  Float128 x2_3 =
+      fputil::quick_mul(fputil::quick_mul(x2_f128, x2_f128), x2_f128);
+  // a^2
+  Float128 a_sq_f128 = fputil::quick_mul(Float128(a), Float128(a));
+  // x2^3 * a^2
+  Float128 x2_3_a_sq = fputil::quick_mul(x2_3, a_sq_f128);
+  // h2 = x2^3 * a^2 - 1
+  Float128 h2_f128 = fputil::quick_add(x2_3_a_sq, Float128(-1.0));
+  double h2 = static_cast<double>(h2_f128);
+  // t2 = 1 - h2 / 3
+  Float128 t2 =
+      fputil::quick_add(Float128(1.0), Float128(h2 * (-0x1.5555555555555p-2)));
+  // x3 = x2 * (1 - h2 / 3) ~ a^(-2/3)
+  Float128 x3 = fputil::quick_mul(x2_f128, t2);
+  // r3 = a * x3 ~ a * a^(-2/3) = a^(1/3)
+  Float128 r3 = fputil::quick_mul(Float128(a), x3);
+
+  // Check for exact cases:
+  Float128::MantissaType rounding_bits =
+      r3.mantissa & 0x0000'0000'0000'03FF'FFFF'FFFF'FFFF'FFFF_u128;
+
+  double result = static_cast<double>(r3);
+  if ((rounding_bits < 0x0000'0000'0000'0000'0000'0000'0000'000F_u128) ||
+      (rounding_bits >= 0x0000'0000'0000'03FF'FFFF'FFFF'FFFF'FFF0_u128)) {
+    // Output is exact.
+    r3.mantissa &= 0xFFFF'FFFF'FFFF'FFFF'FFFF'FFFF'FFFF'FFF0_u128;
+
+    if (rounding_bits >= 0x0000'0000'0000'03FF'FFFF'FFFF'FFFF'FFF0_u128) {
+      Float128 tmp{r3.sign, r3.exponent - 123,
+                   0x8000'0000'0000'0000'0000'0000'0000'0000_u128};
+      Float128 r4 = fputil::quick_add(r3, tmp);
+      result = static_cast<double>(r4);
+    } else {
+      result = static_cast<double>(r3);
+    }
+
+    fputil::clear_except_if_required(FE_INEXACT);
+  }
+
+  return update_exponent(result);
+#endif // LIBC_MATH_CBRT_SKIP_ACCURATE_PASS
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cbrtf.cpp b/src/math/generic/cbrtf.cpp
new file mode 100644
index 0000000..0abbf6e
--- /dev/null
+++ b/src/math/generic/cbrtf.cpp
@@ -0,0 +1,159 @@
+//===-- Implementation of cbrtf function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cbrtf.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace {
+
+// Look up table for 2^(i/3) for i = 0, 1, 2.
+constexpr double CBRT2[3] = {1.0, 0x1.428a2f98d728bp0, 0x1.965fea53d6e3dp0};
+
+// Degree-7 polynomials approximation of ((1 + x)^(1/3) - 1)/x for 0 <= x <= 1
+// generated by Sollya with:
+// > for i from 0 to 15 do {
+//     P = fpminimax((1 + x)^(1/3) - 1)/x, 6, [|D...|], [i/16, (i + 1)/16]);
+//     print("{", coeff(P, 0), ",", coeff(P, 1), ",", coeff(P, 2), ",",
+//           coeff(P, 3), ",", coeff(P, 4), ",", coeff(P, 5), ",",
+//           coeff(P, 6), "},");
+// };
+// Then (1 + x)^(1/3) ~ 1 + x * P(x).
+constexpr double COEFFS[16][7] = {
+    {0x1.55555555554ebp-2, -0x1.c71c71c678c0cp-4, 0x1.f9add2776de81p-5,
+     -0x1.511e10aa964a7p-5, 0x1.ee44165937fa2p-6, -0x1.7c5c9e059345dp-6,
+     0x1.047f75e0aff14p-6},
+    {0x1.5555554d1149ap-2, -0x1.c71c676fcb5bp-4, 0x1.f9ab127dc57ebp-5,
+     -0x1.50ea8fd1d4c15p-5, 0x1.e9d68f28ced43p-6, -0x1.60e0e1e661311p-6,
+     0x1.716eca1d6e3bcp-7},
+    {0x1.5555546377d45p-2, -0x1.c71bc1c6d49d2p-4, 0x1.f9924cc0ed24dp-5,
+     -0x1.4fea3beb53b3bp-5, 0x1.de028a9a07b1bp-6, -0x1.3b090d2233524p-6,
+     0x1.0aeca34893785p-7},
+    {0x1.55554dce9f649p-2, -0x1.c7188b34b98f8p-4, 0x1.f93e1af34af49p-5,
+     -0x1.4d9a06be75c63p-5, 0x1.cb943f4f68992p-6, -0x1.139a685a5e3c4p-6,
+     0x1.88410674c6a5dp-8},
+    {0x1.5555347d211c3p-2, -0x1.c70f2a4b1a5fap-4, 0x1.f88420e8602c3p-5,
+     -0x1.49becfa4ed3ep-5, 0x1.b475cd9013162p-6, -0x1.dcfee1dd2f8efp-7,
+     0x1.249bb51a1c498p-8},
+    {0x1.5554f01b33dbap-2, -0x1.c6facb929dbf1p-4, 0x1.f73fb7861252ep-5,
+     -0x1.4459a4a0071fap-5, 0x1.9a8df2b504fc2p-6, -0x1.9a7ce3006d06ep-7,
+     0x1.ba9230918fa2ep-9},
+    {0x1.55545c695db5fp-2, -0x1.c6d6089f20275p-4, 0x1.f556e0ea80efp-5,
+     -0x1.3d91372d083f4p-5, 0x1.7f66cff331f4p-6, -0x1.606a562491737p-7,
+     0x1.52e3e17c71069p-9},
+    {0x1.55534a879232ap-2, -0x1.c69b836998b84p-4, 0x1.f2bb26dac0e4cp-5,
+     -0x1.359eed43716d7p-5, 0x1.64218cd824fbcp-6, -0x1.2e703e2e091e8p-7,
+     0x1.0677d9af6aad4p-9},
+    {0x1.5551836bb5494p-2, -0x1.c64658c15353bp-4, 0x1.ef68517451a6ep-5,
+     -0x1.2cc20a980dceep-5, 0x1.49843e0fad93ap-6, -0x1.03c59ccb68e54p-7,
+     0x1.9ad325dc7adcbp-10},
+    {0x1.554ecacb0d035p-2, -0x1.c5d2664026ffcp-4, 0x1.eb624796ba809p-5,
+     -0x1.233803d19a535p-5, 0x1.300decb1c3c28p-6, -0x1.befe18031ec3dp-8,
+     0x1.449f5ee175c69p-10},
+    {0x1.554ae1f5ae815p-2, -0x1.c53c6b14ff6b2p-4, 0x1.e6b2d5127bb5bp-5,
+     -0x1.19387336788a3p-5, 0x1.180955a6ab255p-6, -0x1.81696703ba369p-8,
+     0x1.02cb36389bd79p-10},
+    {0x1.55458a59f356ep-2, -0x1.c4820dd631ae9p-4, 0x1.e167af818bd15p-5,
+     -0x1.0ef35f6f72e52p-5, 0x1.019c33b65e4ebp-6, -0x1.4d25bdd52d3a5p-8,
+     0x1.a008ae91f5936p-11},
+    {0x1.553e878eafee1p-2, -0x1.c3a1d0b2a3db2p-4, 0x1.db90d8ed9f89bp-5,
+     -0x1.0490e20f1ae91p-5, 0x1.d9a5d1fc42fe3p-7, -0x1.20bf8227c2abfp-8,
+     0x1.50f8174cdb6e9p-11},
+    {0x1.5535a0dedf1b1p-2, -0x1.c29afb8bd01a1p-4, 0x1.d53f6371c1e27p-5,
+     -0x1.f463209b433e2p-6, 0x1.b35222a17e44p-7, -0x1.f5efbf505e133p-9,
+     0x1.12e0e94e8586dp-11},
+    {0x1.552aa25e57bfdp-2, -0x1.c16d811e4acadp-4, 0x1.ce8489b47aa51p-5,
+     -0x1.dfde7ff758ea8p-6, 0x1.901f43aac38c8p-7, -0x1.b581d07df5ad5p-9,
+     0x1.c3726535f1fc6p-12},
+    {0x1.551d5d9b204d3p-2, -0x1.c019e328f8db1p-4, 0x1.c7710f44fc3cep-5,
+     -0x1.cbbbe25ea8ba4p-6, 0x1.6fe270088623dp-7, -0x1.7e6fc79733761p-9,
+     0x1.75077abf18d84p-12},
+};
+
+} // anonymous namespace
+
+LLVM_LIBC_FUNCTION(float, cbrtf, (float x)) {
+  using FloatBits = typename fputil::FPBits<float>;
+  using DoubleBits = typename fputil::FPBits<double>;
+
+  FloatBits x_bits(x);
+
+  uint32_t x_abs = x_bits.uintval() & 0x7fff'ffff;
+  uint32_t sign_bit = (x_bits.uintval() >> 31) << DoubleBits::EXP_LEN;
+
+  if (LIBC_UNLIKELY(x == 0.0f || x_abs >= 0x7f80'0000)) {
+    // x is 0, Inf, or NaN.
+    // Make sure it works for FTZ/DAZ modes.
+    return x + x;
+  }
+
+  double xd = static_cast<double>(x);
+  DoubleBits xd_bits(xd);
+
+  // When using biased exponent of x in double precision,
+  //   x_e = real_exponent_of_x + 1023
+  // Then:
+  //   x_e / 3 = real_exponent_of_x / 3 + 1023/3
+  //           = real_exponent_of_x / 3 + 341
+  // So to make it the correct biased exponent of x^(1/3), we add
+  //   1023 - 341 = 682
+  // to the quotient x_e / 3.
+  unsigned x_e = static_cast<unsigned>(xd_bits.get_biased_exponent());
+  unsigned out_e = (x_e / 3 + 682) | sign_bit;
+  unsigned shift_e = x_e % 3;
+
+  // Set x_m = 2^(x_e % 3) * (1.mantissa)
+  uint64_t x_m = xd_bits.get_mantissa();
+  // Use the leading 4 bits for look up table
+  unsigned idx = static_cast<unsigned>(x_m >> (DoubleBits::FRACTION_LEN - 4));
+
+  x_m |= static_cast<uint64_t>(DoubleBits::EXP_BIAS)
+         << DoubleBits::FRACTION_LEN;
+
+  double x_reduced = DoubleBits(x_m).get_val();
+  double dx = x_reduced - 1.0;
+
+  double dx_sq = dx * dx;
+  double c0 = fputil::multiply_add(dx, COEFFS[idx][0], 1.0);
+  double c1 = fputil::multiply_add(dx, COEFFS[idx][2], COEFFS[idx][1]);
+  double c2 = fputil::multiply_add(dx, COEFFS[idx][4], COEFFS[idx][3]);
+  double c3 = fputil::multiply_add(dx, COEFFS[idx][6], COEFFS[idx][5]);
+
+  double dx_4 = dx_sq * dx_sq;
+  double p0 = fputil::multiply_add(dx_sq, c1, c0);
+  double p1 = fputil::multiply_add(dx_sq, c3, c2);
+
+  double r = fputil::multiply_add(dx_4, p1, p0) * CBRT2[shift_e];
+
+  uint64_t r_m = DoubleBits(r).get_mantissa();
+  // Check if the output is exact.  To be exact, the smallest 1-bit of the
+  // output has to be at least 2^-7 or higher.  So we check the lowest 44 bits
+  // to see if they are within 2^(-52 + 3) errors from all zeros, then the
+  // result cube root is exact.
+  if (LIBC_UNLIKELY(((r_m + 8) & 0xfffffffffff) <= 16)) {
+    if ((r_m & 0xfffffffffff) <= 8)
+      r_m &= 0xffff'ffff'ffff'ffe0;
+    else
+      r_m = (r_m & 0xffff'ffff'ffff'ffe0) + 0x20;
+    fputil::clear_except_if_required(FE_INEXACT);
+  }
+  // Adjust exponent and sign.
+  uint64_t r_bits =
+      r_m | (static_cast<uint64_t>(out_e) << DoubleBits::FRACTION_LEN);
+
+  return static_cast<float>(DoubleBits(r_bits).get_val());
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ceil.cpp b/src/math/generic/ceil.cpp
index efd0f24..72c6e99 100644
--- a/src/math/generic/ceil.cpp
+++ b/src/math/generic/ceil.cpp
@@ -9,9 +9,16 @@
 #include "src/math/ceil.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, ceil, (double x)) { return fputil::ceil(x); }
+LLVM_LIBC_FUNCTION(double, ceil, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_ceil(x);
+#else
+  return fputil::ceil(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ceilf.cpp b/src/math/generic/ceilf.cpp
index d49b342..dfd0dc6 100644
--- a/src/math/generic/ceilf.cpp
+++ b/src/math/generic/ceilf.cpp
@@ -9,9 +9,16 @@
 #include "src/math/ceilf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, ceilf, (float x)) { return fputil::ceil(x); }
+LLVM_LIBC_FUNCTION(float, ceilf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_ceilf(x);
+#else
+  return fputil::ceil(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ceilf128.cpp b/src/math/generic/ceilf128.cpp
index af98042..5d0cf46 100644
--- a/src/math/generic/ceilf128.cpp
+++ b/src/math/generic/ceilf128.cpp
@@ -9,9 +9,10 @@
 #include "src/math/ceilf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, ceilf128, (float128 x)) { return fputil::ceil(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ceilf16.cpp b/src/math/generic/ceilf16.cpp
index 205d742..9d89efc 100644
--- a/src/math/generic/ceilf16.cpp
+++ b/src/math/generic/ceilf16.cpp
@@ -8,10 +8,20 @@
 
 #include "src/math/ceilf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float16, ceilf16, (float16 x)) { return fputil::ceil(x); }
+LLVM_LIBC_FUNCTION(float16, ceilf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC) &&                       \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_ceilf(x));
+#else
+  return fputil::ceil(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ceill.cpp b/src/math/generic/ceill.cpp
index 7c3b680..bce9d55 100644
--- a/src/math/generic/ceill.cpp
+++ b/src/math/generic/ceill.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ceill.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, ceill, (long double x)) {
   return fputil::ceil(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/common_constants.cpp b/src/math/generic/common_constants.cpp
index 1a23d00..e29c083 100644
--- a/src/math/generic/common_constants.cpp
+++ b/src/math/generic/common_constants.cpp
@@ -8,9 +8,10 @@
 
 #include "common_constants.h"
 #include "src/__support/FPUtil/triple_double.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/number_pair.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Lookup table for (1/f) where f = 1 + n*2^(-7), n = 0..127.
 const double ONE_OVER_F[128] = {
@@ -805,4 +806,4 @@ const fputil::TripleDouble EXP2_MID2[64] = {
     {0x1.6ae7d36d7c1f7p-109, 0x1.e47120223467fp-54, 0x1.02be6e199c811p0},
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/common_constants.h b/src/math/generic/common_constants.h
index 13fc8d7..dc1a90c 100644
--- a/src/math/generic/common_constants.h
+++ b/src/math/generic/common_constants.h
@@ -10,9 +10,10 @@
 #define LLVM_LIBC_SRC_MATH_GENERIC_COMMON_CONSTANTS_H
 
 #include "src/__support/FPUtil/triple_double.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/number_pair.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Lookup table for (1/f) where f = 1 + n*2^(-7), n = 0..127.
 extern const double ONE_OVER_F[128];
@@ -77,6 +78,6 @@ extern const fputil::TripleDouble EXP2_MID1[64];
 // Lookup table for 2^(k * 2^-12) with k = 0..63.
 extern const fputil::TripleDouble EXP2_MID2[64];
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_COMMON_CONSTANTS_H
diff --git a/src/math/generic/copysign.cpp b/src/math/generic/copysign.cpp
index c5ad414..186bb2c 100644
--- a/src/math/generic/copysign.cpp
+++ b/src/math/generic/copysign.cpp
@@ -9,11 +9,16 @@
 #include "src/math/copysign.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, copysign, (double x, double y)) {
+#ifdef __LIBC_MISC_MATH_BASIC_OPS_OPT
+  return __builtin_copysign(x, y);
+#else
   return fputil::copysign(x, y);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/copysignf.cpp b/src/math/generic/copysignf.cpp
index 077e1ce..c79e50b 100644
--- a/src/math/generic/copysignf.cpp
+++ b/src/math/generic/copysignf.cpp
@@ -9,11 +9,16 @@
 #include "src/math/copysignf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, copysignf, (float x, float y)) {
+#ifdef __LIBC_MISC_MATH_BASIC_OPS_OPT
+  return __builtin_copysignf(x, y);
+#else
   return fputil::copysign(x, y);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/copysignf128.cpp b/src/math/generic/copysignf128.cpp
index 2fe36d5..9a51c8d 100644
--- a/src/math/generic/copysignf128.cpp
+++ b/src/math/generic/copysignf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/copysignf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, copysignf128, (float128 x, float128 y)) {
   return fputil::copysign(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/copysignf16.cpp b/src/math/generic/copysignf16.cpp
index 435c7e4..546622f 100644
--- a/src/math/generic/copysignf16.cpp
+++ b/src/math/generic/copysignf16.cpp
@@ -9,11 +9,16 @@
 #include "src/math/copysignf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, copysignf16, (float16 x, float16 y)) {
+#ifdef __LIBC_MISC_MATH_BASIC_OPS_OPT
+  return __builtin_copysignf16(x, y);
+#else
   return fputil::copysign(x, y);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/copysignl.cpp b/src/math/generic/copysignl.cpp
index b74393c..73c47bb 100644
--- a/src/math/generic/copysignl.cpp
+++ b/src/math/generic/copysignl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/copysignl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, copysignl, (long double x, long double y)) {
   return fputil::copysign(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cos.cpp b/src/math/generic/cos.cpp
new file mode 100644
index 0000000..568b125
--- /dev/null
+++ b/src/math/generic/cos.cpp
@@ -0,0 +1,163 @@
+//===-- Double-precision cos function -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cos.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
+#include "src/math/generic/range_reduction_double_common.h"
+#include "src/math/generic/sincos_eval.h"
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+#include "range_reduction_double_fma.h"
+#else
+#include "range_reduction_double_nofma.h"
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+namespace LIBC_NAMESPACE_DECL {
+
+using DoubleDouble = fputil::DoubleDouble;
+using Float128 = typename fputil::DyadicFloat<128>;
+
+LLVM_LIBC_FUNCTION(double, cos, (double x)) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  uint16_t x_e = xbits.get_biased_exponent();
+
+  DoubleDouble y;
+  unsigned k;
+  LargeRangeReduction range_reduction_large{};
+
+  // |x| < 2^16.
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT)) {
+    // |x| < 2^-7
+    if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 7)) {
+      // |x| < 2^-27
+      if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 27)) {
+        // Signed zeros.
+        if (LIBC_UNLIKELY(x == 0.0))
+          return 1.0;
+
+        // For |x| < 2^-27, |cos(x) - 1| < |x|^2/2 < 2^-54 = ulp(1 - 2^-53)/2.
+        return fputil::round_result_slightly_down(1.0);
+      }
+      // No range reduction needed.
+      k = 0;
+      y.lo = 0.0;
+      y.hi = x;
+    } else {
+      // Small range reduction.
+      k = range_reduction_small(x, y);
+    }
+  } else {
+    // Inf or NaN
+    if (LIBC_UNLIKELY(x_e > 2 * FPBits::EXP_BIAS)) {
+      // sin(+-Inf) = NaN
+      if (xbits.get_mantissa() == 0) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    // Large range reduction.
+    k = range_reduction_large.fast(x, y);
+  }
+
+  DoubleDouble sin_y, cos_y;
+
+  [[maybe_unused]] double err = generic::sincos_eval(y, sin_y, cos_y);
+
+  // Look up sin(k * pi/128) and cos(k * pi/128)
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+  // Memory saving versions.  Use 65-entry table.
+  auto get_idx_dd = [](unsigned kk) -> DoubleDouble {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    DoubleDouble ans = SIN_K_PI_OVER_128[idx];
+    if (kk & 128) {
+      ans.hi = -ans.hi;
+      ans.lo = -ans.lo;
+    }
+    return ans;
+  };
+  DoubleDouble msin_k = get_idx_dd(k + 128);
+  DoubleDouble cos_k = get_idx_dd(k + 64);
+#else
+  // Fast look up version, but needs 256-entry table.
+  // -sin(k * pi/128) = sin((k + 128) * pi/128)
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  DoubleDouble msin_k = SIN_K_PI_OVER_128[(k + 128) & 255];
+  DoubleDouble cos_k = SIN_K_PI_OVER_128[(k + 64) & 255];
+#endif // LIBC_MATH_HAS_SMALL_TABLES
+
+  // After range reduction, k = round(x * 128 / pi) and y = x - k * (pi / 128).
+  // So k is an integer and -pi / 256 <= y <= pi / 256.
+  // Then cos(x) = cos((k * pi/128 + y)
+  //             = cos(y) * cos(k*pi/128) - sin(y) * sin(k*pi/128)
+  DoubleDouble cos_k_cos_y = fputil::quick_mult(cos_y, cos_k);
+  DoubleDouble msin_k_sin_y = fputil::quick_mult(sin_y, msin_k);
+
+  DoubleDouble rr = fputil::exact_add<false>(cos_k_cos_y.hi, msin_k_sin_y.hi);
+  rr.lo += msin_k_sin_y.lo + cos_k_cos_y.lo;
+
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return rr.hi + rr.lo;
+#else
+
+  double rlp = rr.lo + err;
+  double rlm = rr.lo - err;
+
+  double r_upper = rr.hi + rlp; // (rr.lo + ERR);
+  double r_lower = rr.hi + rlm; // (rr.lo - ERR);
+
+  // Ziv's rounding test.
+  if (LIBC_LIKELY(r_upper == r_lower))
+    return r_upper;
+
+  Float128 u_f128, sin_u, cos_u;
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT))
+    u_f128 = range_reduction_small_f128(x);
+  else
+    u_f128 = range_reduction_large.accurate();
+
+  generic::sincos_eval(u_f128, sin_u, cos_u);
+
+  auto get_sin_k = [](unsigned kk) -> Float128 {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    Float128 ans = SIN_K_PI_OVER_128_F128[idx];
+    if (kk & 128)
+      ans.sign = Sign::NEG;
+    return ans;
+  };
+
+  // -sin(k * pi/128) = sin((k + 128) * pi/128)
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  Float128 msin_k_f128 = get_sin_k(k + 128);
+  Float128 cos_k_f128 = get_sin_k(k + 64);
+
+  // cos(x) = cos((k * pi/128 + u)
+  //        = cos(u) * cos(k*pi/128) - sin(u) * sin(k*pi/128)
+  Float128 r = fputil::quick_add(fputil::quick_mul(cos_k_f128, cos_u),
+                                 fputil::quick_mul(msin_k_f128, sin_u));
+
+  // TODO: Add assertion if Ziv's accuracy tests fail in debug mode.
+  // https://github.com/llvm/llvm-project/issues/96452.
+
+  return static_cast<double>(r);
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cosf.cpp b/src/math/generic/cosf.cpp
index 180a44e..972ffa9 100644
--- a/src/math/generic/cosf.cpp
+++ b/src/math/generic/cosf.cpp
@@ -14,12 +14,11 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Exceptional cases for cosf.
 static constexpr size_t N_EXCEPTS = 6;
@@ -134,4 +133,4 @@ LLVM_LIBC_FUNCTION(float, cosf, (float x)) {
       sin_y, -sin_k, fputil::multiply_add(cosm1_y, cos_k, cos_k)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/coshf.cpp b/src/math/generic/coshf.cpp
index a8ea324..c869f7d 100644
--- a/src/math/generic/coshf.cpp
+++ b/src/math/generic/coshf.cpp
@@ -10,10 +10,11 @@
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, coshf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -52,4 +53,4 @@ LLVM_LIBC_FUNCTION(float, coshf, (float x)) {
   return static_cast<float>(exp_pm_eval</*is_sinh*/ false>(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/coshf16.cpp b/src/math/generic/coshf16.cpp
new file mode 100644
index 0000000..cca7581
--- /dev/null
+++ b/src/math/generic/coshf16.cpp
@@ -0,0 +1,103 @@
+//===-- Half-precision cosh(x) function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/coshf16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 9> COSHF16_EXCEPTS_POS = {{
+    // x = 0x1.6ap-5, coshf16(x) = 0x1p+0 (RZ)
+    {0x29a8U, 0x3c00U, 1U, 0U, 1U},
+    // x = 0x1.8c4p+0, coshf16(x) = 0x1.3a8p+1 (RZ)
+    {0x3e31U, 0x40eaU, 1U, 0U, 0U},
+    // x = 0x1.994p+0, coshf16(x) = 0x1.498p+1 (RZ)
+    {0x3e65U, 0x4126U, 1U, 0U, 0U},
+    // x = 0x1.b6p+0, coshf16(x) = 0x1.6d8p+1 (RZ)
+    {0x3ed8U, 0x41b6U, 1U, 0U, 1U},
+    // x = 0x1.aap+1, coshf16(x) = 0x1.be8p+3 (RZ)
+    {0x42a8U, 0x4afaU, 1U, 0U, 1U},
+    // x = 0x1.cc4p+1, coshf16(x) = 0x1.23cp+4 (RZ)
+    {0x4331U, 0x4c8fU, 1U, 0U, 0U},
+    // x = 0x1.288p+2, coshf16(x) = 0x1.9b4p+5 (RZ)
+    {0x44a2U, 0x526dU, 1U, 0U, 0U},
+    // x = 0x1.958p+2, coshf16(x) = 0x1.1a4p+8 (RZ)
+    {0x4656U, 0x5c69U, 1U, 0U, 0U},
+    // x = 0x1.5fp+3, coshf16(x) = 0x1.c54p+14 (RZ)
+    {0x497cU, 0x7715U, 1U, 0U, 1U},
+}};
+
+static constexpr fputil::ExceptValues<float16, 4> COSHF16_EXCEPTS_NEG = {{
+    // x = -0x1.6ap-5, coshf16(x) = 0x1p+0 (RZ)
+    {0xa9a8U, 0x3c00U, 1U, 0U, 1U},
+    // x = -0x1.b6p+0, coshf16(x) = 0x1.6d8p+1 (RZ)
+    {0xbed8U, 0x41b6U, 1U, 0U, 1U},
+    // x = -0x1.288p+2, coshf16(x) = 0x1.9b4p+5 (RZ)
+    {0xc4a2U, 0x526dU, 1U, 0U, 0U},
+    // x = -0x1.5fp+3, coshf16(x) = 0x1.c54p+14 (RZ)
+    {0xc97cU, 0x7715U, 1U, 0U, 1U},
+}};
+
+LLVM_LIBC_FUNCTION(float16, coshf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| >= acosh(2^16), or x is NaN.
+  if (LIBC_UNLIKELY(x_abs >= 0x49e5U)) {
+    // cosh(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When |x| >= acosh(2^16).
+    if (x_abs >= 0x49e5U) {
+      // cosh(+/-inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+  }
+
+  if (x_bits.is_pos()) {
+    if (auto r = COSHF16_EXCEPTS_POS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+  } else {
+    if (auto r = COSHF16_EXCEPTS_NEG.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+  }
+
+  return eval_sinh_or_cosh</*IsSinh=*/false>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cospif.cpp b/src/math/generic/cospif.cpp
new file mode 100644
index 0000000..4ef1539
--- /dev/null
+++ b/src/math/generic/cospif.cpp
@@ -0,0 +1,96 @@
+//===-- Single-precision cospi function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cospif.h"
+#include "sincosf_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, cospif, (float x)) {
+  using FPBits = typename fputil::FPBits<float>;
+
+  FPBits xbits(x);
+  xbits.set_sign(Sign::POS);
+
+  uint32_t x_abs = xbits.uintval();
+  double xd = static_cast<double>(xbits.get_val());
+
+  // Range reduction:
+  // For |x| > 1/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * 1/32
+  //   k is an integer
+  //   |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32)
+  //   y = x * 32 - k
+  //
+  // Once k and y are computed, we then deduce the answer by the cosine of sum
+  // formula:
+  //   cospi(x) = cos((k + y)*pi/32)
+  //          = cos(y*pi/32) * cos(k*pi/32) - sin(y*pi/32) * sin(k*pi/32)
+  // The values of sin(k*pi/32) and cos(k*pi/32) for k = 0..63 are precomputed
+  // and stored using a vector of 32 doubles. Sin(y*pi/32) and cos(y*pi/32) are
+  // computed using degree-7 and degree-6 minimax polynomials generated by
+  // Sollya respectively.
+
+  // The exhautive test passes for smaller values
+  if (LIBC_UNLIKELY(x_abs < 0x38A2'F984U)) {
+
+#if defined(LIBC_TARGET_CPU_HAS_FMA)
+    return fputil::multiply_add(xbits.get_val(), -0x1.0p-25f, 1.0f);
+#else
+    return static_cast<float>(fputil::multiply_add(xd, -0x1.0p-25, 1.0));
+#endif // LIBC_TARGET_CPU_HAS_FMA
+  }
+
+  // Numbers greater or equal to 2^23 are always integers or NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x4B00'0000)) {
+
+    if (LIBC_UNLIKELY(x_abs < 0x4B80'0000)) {
+      return (x_abs & 0x1) ? -1.0f : 1.0f;
+    }
+
+    // x is inf or nan.
+    if (LIBC_UNLIKELY(x_abs >= 0x7f80'0000U)) {
+      if (x_abs == 0x7f80'0000U) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    return 1.0f;
+  }
+
+  // Combine the results with the sine of sum formula:
+  //   cos(pi * x) = cos((k + y)*pi/32)
+  //          = cos(y*pi/32) * cos(k*pi/32) - sin(y*pi/32) * sin(k*pi/32)
+  //          = (cosm1_y + 1) * cos_k - sin_y * sin_k
+  //          = (cosm1_y * cos_k + cos_k) - sin_y * sin_k
+  double sin_k, cos_k, sin_y, cosm1_y;
+
+  sincospif_eval(xd, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && cos_k == 0)) {
+    return 0.0f;
+  }
+
+  return static_cast<float>(fputil::multiply_add(
+      sin_y, -sin_k, fputil::multiply_add(cosm1_y, cos_k, cos_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/cospif16.cpp b/src/math/generic/cospif16.cpp
new file mode 100644
index 0000000..384b39f
--- /dev/null
+++ b/src/math/generic/cospif16.cpp
@@ -0,0 +1,81 @@
+//===-- Half-precision cospif function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cospif16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, cospif16, (float16 x)) {
+  using FPBits = typename fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+  // Range reduction:
+  // For |x| > 1/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * 1/32
+  //   k is an integer
+  //   |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32)
+  //   y = x * 32 - k
+  //
+  // Once k and y are computed, we then deduce the answer by the cosine of sum
+  // formula:
+  //   cos(x * pi) = cos((k + y) * pi/32)
+  //               = cos(k * pi/32) * cos(y * pi/32) +
+  //                 sin(y * pi/32) * sin(k * pi/32)
+
+  // For signed zeros
+  if (LIBC_UNLIKELY(x_abs == 0U))
+    return fputil::cast<float16>(1.0f);
+
+  // Numbers greater or equal to 2^10 are integers, or infinity, or NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x6400)) {
+    if (LIBC_UNLIKELY(x_abs <= 0x67FF))
+      return fputil::cast<float16>((x_abs & 0x1) ? -1.0f : 1.0f);
+
+    // Check for NaN or infintiy values
+    if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
+      // If value is equal to infinity
+      if (x_abs == 0x7c00) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    return fputil::cast<float16>(1.0f);
+  }
+
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincospif16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && cos_k == 0))
+    return fputil::cast<float16>(0.0f);
+
+  // Since, cosm1_y = cos_y - 1, therefore:
+  // 	cos(x * pi) = cos_k(cosm1_y) + cos_k - sin_k * sin_y
+  return fputil::cast<float16>(fputil::multiply_add(
+      cos_k, cosm1_y, fputil::multiply_add(-sin_k, sin_y, cos_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/daddf128.cpp b/src/math/generic/daddf128.cpp
new file mode 100644
index 0000000..6edba3b
--- /dev/null
+++ b/src/math/generic/daddf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of daddf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/daddf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, daddf128, (float128 x, float128 y)) {
+  return fputil::generic::add<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/daddl.cpp b/src/math/generic/daddl.cpp
new file mode 100644
index 0000000..708de38
--- /dev/null
+++ b/src/math/generic/daddl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of daddl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/daddl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, daddl, (long double x, long double y)) {
+  return fputil::generic::add<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ddivf128.cpp b/src/math/generic/ddivf128.cpp
new file mode 100644
index 0000000..1ce4fd6
--- /dev/null
+++ b/src/math/generic/ddivf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ddivf128 function--------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/ddivf128.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, ddivf128, (float128 x, float128 y)) {
+  return fputil::generic::div<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ddivl.cpp b/src/math/generic/ddivl.cpp
new file mode 100644
index 0000000..18fc44d
--- /dev/null
+++ b/src/math/generic/ddivl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ddivl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/ddivl.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, ddivl, (long double x, long double y)) {
+  return fputil::generic::div<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dfmaf128.cpp b/src/math/generic/dfmaf128.cpp
new file mode 100644
index 0000000..b6e1bdb
--- /dev/null
+++ b/src/math/generic/dfmaf128.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of dfmaf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_DFMAf128_H
+#define LLVM_LIBC_SRC_MATH_DFMAf128_H
+
+#include "src/math/dfmaf128.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dfmaf128, (float128 x, float128 y, float128 z)) {
+  return fputil::fma<double>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_DFMAf128_H
diff --git a/src/math/generic/dfmal.cpp b/src/math/generic/dfmal.cpp
new file mode 100644
index 0000000..02e0ce8
--- /dev/null
+++ b/src/math/generic/dfmal.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of dfmal function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dfmal.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dfmal,
+                   (long double x, long double y, long double z)) {
+  return fputil::fma<double>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dmulf128.cpp b/src/math/generic/dmulf128.cpp
new file mode 100644
index 0000000..7e6ef95
--- /dev/null
+++ b/src/math/generic/dmulf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dmulf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dmulf128.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dmulf128, (float128 x, float128 y)) {
+  return fputil::generic::mul<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dmull.cpp b/src/math/generic/dmull.cpp
new file mode 100644
index 0000000..428caa8
--- /dev/null
+++ b/src/math/generic/dmull.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dmull function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dmull.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dmull, (long double x, long double y)) {
+  return fputil::generic::mul<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dsqrtf128.cpp b/src/math/generic/dsqrtf128.cpp
new file mode 100644
index 0000000..ad83393
--- /dev/null
+++ b/src/math/generic/dsqrtf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dsqrtf128 function ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dsqrtf128.h"
+#include "src/__support/FPUtil/generic/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dsqrtf128, (float128 x)) {
+  return fputil::sqrt<double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dsqrtl.cpp b/src/math/generic/dsqrtl.cpp
new file mode 100644
index 0000000..bf1dae9
--- /dev/null
+++ b/src/math/generic/dsqrtl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dsqrtl function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dsqrtl.h"
+#include "src/__support/FPUtil/generic/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dsqrtl, (long double x)) {
+  return fputil::sqrt<double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dsubf128.cpp b/src/math/generic/dsubf128.cpp
new file mode 100644
index 0000000..1b2f121
--- /dev/null
+++ b/src/math/generic/dsubf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dsubf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dsubf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dsubf128, (float128 x, float128 y)) {
+  return fputil::generic::sub<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/dsubl.cpp b/src/math/generic/dsubl.cpp
new file mode 100644
index 0000000..8b567d0
--- /dev/null
+++ b/src/math/generic/dsubl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of dsubl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/dsubl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, dsubl, (long double x, long double y)) {
+  return fputil::generic::sub<double>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/erff.cpp b/src/math/generic/erff.cpp
index f120d56..1535745 100644
--- a/src/math/generic/erff.cpp
+++ b/src/math/generic/erff.cpp
@@ -12,9 +12,10 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Polynomials approximating erf(x)/x on ( k/8, (k + 1)/8 ) generated by Sollya
 // with:
@@ -127,15 +128,6 @@ LLVM_LIBC_FUNCTION(float, erff, (float x)) {
   uint32_t x_u = xbits.uintval();
   uint32_t x_abs = x_u & 0x7fff'ffffU;
 
-  // Exceptional values
-  if (LIBC_UNLIKELY(x_abs == 0x3f65'9229U)) // |x| = 0x1.cb2452p-1f
-    return x < 0.0f ? fputil::round_result_slightly_down(-0x1.972ea8p-1f)
-                    : fputil::round_result_slightly_up(0x1.972ea8p-1f);
-  if (LIBC_UNLIKELY(x_abs == 0x4004'1e6aU)) // |x| = 0x1.083cd4p+1f
-    return x < 0.0f ? fputil::round_result_slightly_down(-0x1.fe3462p-1f)
-                    : fputil::round_result_slightly_up(0x1.fe3462p-1f);
-
-  // if (LIBC_UNLIKELY(x_abs > 0x407a'd444U)) {
   if (LIBC_UNLIKELY(x_abs >= 0x4080'0000U)) {
     const float ONE[2] = {1.0f, -1.0f};
     const float SMALL[2] = {-0x1.0p-25f, 0x1.0p-25f};
@@ -149,6 +141,21 @@ LLVM_LIBC_FUNCTION(float, erff, (float x)) {
     return ONE[sign] + SMALL[sign];
   }
 
+  // Exceptional mask = common 0 bits of 2 exceptional values.
+  constexpr uint32_t EXCEPT_MASK = 0x809a'6184U;
+
+  if (LIBC_UNLIKELY((x_abs & EXCEPT_MASK) == 0)) {
+    // Exceptional values
+    if (LIBC_UNLIKELY(x_abs == 0x3f65'9229U)) // |x| = 0x1.cb2452p-1f
+      return x < 0.0f ? fputil::round_result_slightly_down(-0x1.972ea8p-1f)
+                      : fputil::round_result_slightly_up(0x1.972ea8p-1f);
+    if (LIBC_UNLIKELY(x_abs == 0x4004'1e6aU)) // |x| = 0x1.083cd4p+1f
+      return x < 0.0f ? fputil::round_result_slightly_down(-0x1.fe3462p-1f)
+                      : fputil::round_result_slightly_up(0x1.fe3462p-1f);
+    if (x_abs == 0U)
+      return x;
+  }
+
   // Polynomial approximation:
   //   erf(x) ~ x * (c0 + c1 * x^2 + c2 * x^4 + ... + c7 * x^14)
   double xd = static_cast<double>(x);
@@ -170,4 +177,4 @@ LLVM_LIBC_FUNCTION(float, erff, (float x)) {
   return static_cast<float>(xd * fputil::multiply_add(x8, p1, p0));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp.cpp b/src/math/generic/exp.cpp
index 3d060bc..38b683a 100644
--- a/src/math/generic/exp.cpp
+++ b/src/math/generic/exp.cpp
@@ -22,11 +22,10 @@
 #include "src/__support/FPUtil/triple_double.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using fputil::DoubleDouble;
 using fputil::TripleDouble;
@@ -416,4 +415,4 @@ LLVM_LIBC_FUNCTION(double, exp, (double x)) {
   return static_cast<double>(r_f128);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10.cpp b/src/math/generic/exp10.cpp
index a4ae414..748c8a2 100644
--- a/src/math/generic/exp10.cpp
+++ b/src/math/generic/exp10.cpp
@@ -22,11 +22,10 @@
 #include "src/__support/FPUtil/triple_double.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using fputil::DoubleDouble;
 using fputil::TripleDouble;
@@ -476,4 +475,4 @@ LLVM_LIBC_FUNCTION(double, exp10, (double x)) {
   return static_cast<double>(r_f128);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10f.cpp b/src/math/generic/exp10f.cpp
index 273b583..5284c38 100644
--- a/src/math/generic/exp10f.cpp
+++ b/src/math/generic/exp10f.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/exp10f.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/math/generic/exp10f_impl.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp10f, (float x)) { return generic::exp10f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10f16.cpp b/src/math/generic/exp10f16.cpp
new file mode 100644
index 0000000..006dd5c
--- /dev/null
+++ b/src/math/generic/exp10f16.cpp
@@ -0,0 +1,130 @@
+//===-- Half-precision 10^x function --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp10f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/array.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_EXP10F16_EXCEPTS = 5;
+#else
+static constexpr size_t N_EXP10F16_EXCEPTS = 8;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_EXP10F16_EXCEPTS>
+    EXP10F16_EXCEPTS = {{
+        // x = 0x1.8f4p-2, exp10f16(x) = 0x1.3ap+1 (RZ)
+        {0x363dU, 0x40e8U, 1U, 0U, 1U},
+        // x = 0x1.95cp-2, exp10f16(x) = 0x1.3ecp+1 (RZ)
+        {0x3657U, 0x40fbU, 1U, 0U, 0U},
+        // x = -0x1.018p-4, exp10f16(x) = 0x1.bbp-1 (RZ)
+        {0xac06U, 0x3aecU, 1U, 0U, 0U},
+        // x = -0x1.c28p+0, exp10f16(x) = 0x1.1ccp-6 (RZ)
+        {0xbf0aU, 0x2473U, 1U, 0U, 0U},
+        // x = -0x1.e1cp+1, exp10f16(x) = 0x1.694p-13 (RZ)
+        {0xc387U, 0x09a5U, 1U, 0U, 0U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.0cp+1, exp10f16(x) = 0x1.f04p+6 (RZ)
+        {0x4030U, 0x57c1U, 1U, 0U, 1U},
+        // x = 0x1.1b8p+1, exp10f16(x) = 0x1.47cp+7 (RZ)
+        {0x406eU, 0x591fU, 1U, 0U, 1U},
+        // x = 0x1.1b8p+2, exp10f16(x) = 0x1.a4p+14 (RZ)
+        {0x446eU, 0x7690U, 1U, 0U, 1U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, exp10f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| >= 5, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs >= 0x4500U)) {
+    // exp10(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When x >= 5.
+    if (x_bits.is_pos()) {
+      // exp10(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x <= -8.
+    if (x_u >= 0xc800U) {
+      // exp10(-inf) = +0
+      if (x_bits.is_inf())
+        return FPBits::zero().get_val();
+
+      fputil::set_errno_if_required(ERANGE);
+      fputil::raise_except_if_required(FE_UNDERFLOW | FE_INEXACT);
+
+      if (fputil::fenv_is_round_up())
+        return FPBits::min_subnormal().get_val();
+      return FPBits::zero().get_val();
+    }
+  }
+
+  // When x is 1, 2, 3, or 4. These are hard-to-round cases with exact results.
+  if (LIBC_UNLIKELY((x_u & ~(0x3c00U | 0x4000U | 0x4200U | 0x4400U)) == 0)) {
+    switch (x_u) {
+    case 0x3c00U: // x = 1.0f16
+      return fputil::cast<float16>(10.0);
+    case 0x4000U: // x = 2.0f16
+      return fputil::cast<float16>(100.0);
+    case 0x4200U: // x = 3.0f16
+      return fputil::cast<float16>(1'000.0);
+    case 0x4400U: // x = 4.0f16
+      return fputil::cast<float16>(10'000.0);
+    }
+  }
+
+  if (auto r = EXP10F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // 10^x = 2^((hi + mid) * log2(10)) * 10^lo
+  auto [exp2_hi_mid, exp10_lo] = exp10_range_reduction(x);
+  return fputil::cast<float16>(exp2_hi_mid * exp10_lo);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10f_impl.h b/src/math/generic/exp10f_impl.h
index ff4c1c3..d741318 100644
--- a/src/math/generic/exp10f_impl.h
+++ b/src/math/generic/exp10f_impl.h
@@ -18,11 +18,11 @@
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
 
 LIBC_INLINE float exp10f(float x) {
   using FPBits = typename fputil::FPBits<float>;
@@ -135,6 +135,7 @@ LIBC_INLINE float exp10f(float x) {
   return static_cast<float>(multiply_add(p, lo2 * rr.mh, c0 * rr.mh));
 }
 
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_EXP10F_IMPL_H
diff --git a/src/math/generic/exp10m1f.cpp b/src/math/generic/exp10m1f.cpp
new file mode 100644
index 0000000..c0e302e
--- /dev/null
+++ b/src/math/generic/exp10m1f.cpp
@@ -0,0 +1,216 @@
+//===-- Implementation of exp10m1f function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp10m1f.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/errno/libc_errno.h"
+
+#include "explogxf.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr size_t N_EXCEPTS_LO = 11;
+
+static constexpr fputil::ExceptValues<float, N_EXCEPTS_LO> EXP10M1F_EXCEPTS_LO =
+    {{
+        // x = 0x1.0fe54ep-11, exp10m1f(x) = 0x1.3937eep-10 (RZ)
+        {0x3a07'f2a7U, 0x3a9c'9bf7U, 1U, 0U, 1U},
+        // x = 0x1.80e6eap-11, exp10m1f(x) = 0x1.bb8272p-10 (RZ)
+        {0x3a40'7375U, 0x3add'c139U, 1U, 0U, 1U},
+        // x = -0x1.2a33bcp-51, exp10m1f(x) = -0x1.57515ep-50 (RZ)
+        {0xa615'19deU, 0xa6ab'a8afU, 0U, 1U, 0U},
+        // x = -0x0p+0, exp10m1f(x) = -0x0p+0 (RZ)
+        {0x8000'0000U, 0x8000'0000U, 0U, 0U, 0U},
+        // x = -0x1.b59e08p-31, exp10m1f(x) = -0x1.f7d356p-30 (RZ)
+        {0xb05a'cf04U, 0xb0fb'e9abU, 0U, 1U, 1U},
+        // x = -0x1.bf342p-12, exp10m1f(x) = -0x1.014e02p-10 (RZ)
+        {0xb9df'9a10U, 0xba80'a701U, 0U, 1U, 0U},
+        // x = -0x1.6207fp-11, exp10m1f(x) = -0x1.9746cap-10 (RZ)
+        {0xba31'03f8U, 0xbacb'a365U, 0U, 1U, 1U},
+        // x = -0x1.bd0c66p-11, exp10m1f(x) = -0x1.ffe168p-10 (RZ)
+        {0xba5e'8633U, 0xbaff'f0b4U, 0U, 1U, 1U},
+        // x = -0x1.ffd84cp-10, exp10m1f(x) = -0x1.25faf2p-8 (RZ)
+        {0xbaff'ec26U, 0xbb92'fd79U, 0U, 1U, 0U},
+        // x = -0x1.a74172p-9, exp10m1f(x) = -0x1.e57be2p-8 (RZ)
+        {0xbb53'a0b9U, 0xbbf2'bdf1U, 0U, 1U, 1U},
+        // x = -0x1.cb694cp-9, exp10m1f(x) = -0x1.0764e4p-7 (RZ)
+        {0xbb65'b4a6U, 0xbc03'b272U, 0U, 1U, 0U},
+    }};
+
+static constexpr size_t N_EXCEPTS_HI = 19;
+
+static constexpr fputil::ExceptValues<float, N_EXCEPTS_HI> EXP10M1F_EXCEPTS_HI =
+    {{
+        // (input, RZ output, RU offset, RD offset, RN offset)
+        // x = 0x1.8d31eep-8, exp10m1f(x) = 0x1.cc7e4cp-7 (RZ)
+        {0x3bc6'98f7U, 0x3c66'3f26U, 1U, 0U, 1U},
+        // x = 0x1.915fcep-8, exp10m1f(x) = 0x1.d15f72p-7 (RZ)
+        {0x3bc8'afe7U, 0x3c68'afb9U, 1U, 0U, 0U},
+        // x = 0x1.bcf982p-8, exp10m1f(x) = 0x1.022928p-6 (RZ)
+        {0x3bde'7cc1U, 0x3c81'1494U, 1U, 0U, 1U},
+        // x = 0x1.99ff0ap-7, exp10m1f(x) = 0x1.dee416p-6 (RZ)
+        {0x3c4c'ff85U, 0x3cef'720bU, 1U, 0U, 0U},
+        // x = 0x1.75ea14p-6, exp10m1f(x) = 0x1.b9ff16p-5 (RZ)
+        {0x3cba'f50aU, 0x3d5c'ff8bU, 1U, 0U, 0U},
+        // x = 0x1.f81b64p-6, exp10m1f(x) = 0x1.2cb6bcp-4 (RZ)
+        {0x3cfc'0db2U, 0x3d96'5b5eU, 1U, 0U, 0U},
+        // x = 0x1.fafecp+3, exp10m1f(x) = 0x1.8c880ap+52 (RZ)
+        {0x417d'7f60U, 0x59c6'4405U, 1U, 0U, 0U},
+        // x = -0x1.3bf094p-8, exp10m1f(x) = -0x1.69ba4ap-7 (RZ)
+        {0xbb9d'f84aU, 0xbc34'dd25U, 0U, 1U, 0U},
+        // x = -0x1.4558bcp-8, exp10m1f(x) = -0x1.746fb8p-7 (RZ)
+        {0xbba2'ac5eU, 0xbc3a'37dcU, 0U, 1U, 1U},
+        // x = -0x1.4bb43p-8, exp10m1f(x) = -0x1.7babe4p-7 (RZ)
+        {0xbba5'da18U, 0xbc3d'd5f2U, 0U, 1U, 1U},
+        // x = -0x1.776cc8p-8, exp10m1f(x) = -0x1.ad62c4p-7 (RZ)
+        {0xbbbb'b664U, 0xbc56'b162U, 0U, 1U, 0U},
+        // x = -0x1.f024cp-8, exp10m1f(x) = -0x1.1b20d6p-6 (RZ)
+        {0xbbf8'1260U, 0xbc8d'906bU, 0U, 1U, 1U},
+        // x = -0x1.f510eep-8, exp10m1f(x) = -0x1.1de9aap-6 (RZ)
+        {0xbbfa'8877U, 0xbc8e'f4d5U, 0U, 1U, 0U},
+        // x = -0x1.0b43c4p-7, exp10m1f(x) = -0x1.30d418p-6 (RZ)
+        {0xbc05'a1e2U, 0xbc98'6a0cU, 0U, 1U, 0U},
+        // x = -0x1.245ee4p-7, exp10m1f(x) = -0x1.4d2b86p-6 (RZ)
+        {0xbc12'2f72U, 0xbca6'95c3U, 0U, 1U, 0U},
+        // x = -0x1.f9f2dap-7, exp10m1f(x) = -0x1.1e2186p-5 (RZ)
+        {0xbc7c'f96dU, 0xbd0f'10c3U, 0U, 1U, 0U},
+        // x = -0x1.08e42p-6, exp10m1f(x) = -0x1.2b5c4p-5 (RZ)
+        {0xbc84'7210U, 0xbd15'ae20U, 0U, 1U, 1U},
+        // x = -0x1.0cdc44p-5, exp10m1f(x) = -0x1.2a2152p-4 (RZ)
+        {0xbd06'6e22U, 0xbd95'10a9U, 0U, 1U, 1U},
+        // x = -0x1.ca4322p-5, exp10m1f(x) = -0x1.ef073p-4 (RZ)
+        {0xbd65'2191U, 0xbdf7'8398U, 0U, 1U, 1U},
+    }};
+
+LLVM_LIBC_FUNCTION(float, exp10m1f, (float x)) {
+  using FPBits = fputil::FPBits<float>;
+  FPBits xbits(x);
+
+  uint32_t x_u = xbits.uintval();
+  uint32_t x_abs = x_u & 0x7fff'ffffU;
+
+  // When x >= log10(2^128), or x is nan
+  if (LIBC_UNLIKELY(xbits.is_pos() && x_u >= 0x421a'209bU)) {
+    if (xbits.is_finite()) {
+      int rounding = fputil::quick_get_round();
+      if (rounding == FE_DOWNWARD || rounding == FE_TOWARDZERO)
+        return FPBits::max_normal().get_val();
+
+      fputil::set_errno_if_required(ERANGE);
+      fputil::raise_except_if_required(FE_OVERFLOW);
+    }
+
+    // x >= log10(2^128) and 10^x - 1 rounds to +inf, or x is +inf or nan
+    return x + FPBits::inf().get_val();
+  }
+
+  // When |x| <= log10(2) * 2^(-6)
+  if (LIBC_UNLIKELY(x_abs <= 0x3b9a'209bU)) {
+    if (auto r = EXP10M1F_EXCEPTS_LO.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+
+    double dx = x;
+    double dx_sq = dx * dx;
+    double c0 = dx * Exp10Base::COEFFS[0];
+    double c1 =
+        fputil::multiply_add(dx, Exp10Base::COEFFS[2], Exp10Base::COEFFS[1]);
+    double c2 =
+        fputil::multiply_add(dx, Exp10Base::COEFFS[4], Exp10Base::COEFFS[3]);
+    // 10^dx - 1 ~ (1 + COEFFS[0] * dx + ... + COEFFS[4] * dx^5) - 1
+    //           = COEFFS[0] * dx + ... + COEFFS[4] * dx^5
+    return static_cast<float>(fputil::polyeval(dx_sq, c0, c1, c2));
+  }
+
+  // When x <= log10(2^-25), or x is nan
+  if (LIBC_UNLIKELY(x_u >= 0xc0f0d2f1)) {
+    // exp10m1(-inf) = -1
+    if (xbits.is_inf())
+      return -1.0f;
+    // exp10m1(nan) = nan
+    if (xbits.is_nan())
+      return x;
+
+    int rounding = fputil::quick_get_round();
+    if (rounding == FE_UPWARD || rounding == FE_TOWARDZERO ||
+        (rounding == FE_TONEAREST && x_u == 0xc0f0d2f1))
+      return -0x1.ffff'fep-1f; // -1.0f + 0x1.0p-24f
+
+    fputil::set_errno_if_required(ERANGE);
+    fputil::raise_except_if_required(FE_UNDERFLOW);
+    return -1.0f;
+  }
+
+  // Exact outputs when x = 1, 2, ..., 10.
+  // Quick check mask: 0x800f'ffffU = ~(bits of 1.0f | ... | bits of 10.0f)
+  if (LIBC_UNLIKELY((x_u & 0x800f'ffffU) == 0)) {
+    switch (x_u) {
+    case 0x3f800000U: // x = 1.0f
+      return 9.0f;
+    case 0x40000000U: // x = 2.0f
+      return 99.0f;
+    case 0x40400000U: // x = 3.0f
+      return 999.0f;
+    case 0x40800000U: // x = 4.0f
+      return 9'999.0f;
+    case 0x40a00000U: // x = 5.0f
+      return 99'999.0f;
+    case 0x40c00000U: // x = 6.0f
+      return 999'999.0f;
+    case 0x40e00000U: // x = 7.0f
+      return 9'999'999.0f;
+    case 0x41000000U: { // x = 8.0f
+      int rounding = fputil::quick_get_round();
+      if (rounding == FE_UPWARD || rounding == FE_TONEAREST)
+        return 100'000'000.0f;
+      return 99'999'992.0f;
+    }
+    case 0x41100000U: { // x = 9.0f
+      int rounding = fputil::quick_get_round();
+      if (rounding == FE_UPWARD || rounding == FE_TONEAREST)
+        return 1'000'000'000.0f;
+      return 999'999'936.0f;
+    }
+    case 0x41200000U: { // x = 10.0f
+      int rounding = fputil::quick_get_round();
+      if (rounding == FE_UPWARD || rounding == FE_TONEAREST)
+        return 10'000'000'000.0f;
+      return 9'999'998'976.0f;
+    }
+    }
+  }
+
+  if (auto r = EXP10M1F_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // Range reduction: 10^x = 2^(mid + hi) * 10^lo
+  //   rr = (2^(mid + hi), lo)
+  auto rr = exp_b_range_reduc<Exp10Base>(x);
+
+  // The low part is approximated by a degree-5 minimax polynomial.
+  // 10^lo ~ 1 + COEFFS[0] * lo + ... + COEFFS[4] * lo^5
+  double lo_sq = rr.lo * rr.lo;
+  double c0 = fputil::multiply_add(rr.lo, Exp10Base::COEFFS[0], 1.0);
+  double c1 =
+      fputil::multiply_add(rr.lo, Exp10Base::COEFFS[2], Exp10Base::COEFFS[1]);
+  double c2 =
+      fputil::multiply_add(rr.lo, Exp10Base::COEFFS[4], Exp10Base::COEFFS[3]);
+  double exp10_lo = fputil::polyeval(lo_sq, c0, c1, c2);
+  // 10^x - 1 = 2^(mid + hi) * 10^lo - 1
+  //          ~ mh * exp10_lo - 1
+  return static_cast<float>(fputil::multiply_add(exp10_lo, rr.mh, -1.0));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10m1f16.cpp b/src/math/generic/exp10m1f16.cpp
new file mode 100644
index 0000000..449aedf
--- /dev/null
+++ b/src/math/generic/exp10m1f16.cpp
@@ -0,0 +1,166 @@
+//===-- Half-precision 10^x - 1 function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp10m1f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 3> EXP10M1F16_EXCEPTS_LO = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.5c4p-4, exp10m1f16(x) = 0x1.bacp-3 (RZ)
+    {0x2d71U, 0x32ebU, 1U, 0U, 0U},
+    // x = -0x1.5ep-13, exp10m1f16(x) = -0x1.92cp-12 (RZ)
+    {0x8978U, 0x8e4bU, 0U, 1U, 0U},
+    // x = -0x1.e2p-10, exp10m1f16(x) = -0x1.14cp-8 (RZ)
+    {0x9788U, 0x9c53U, 0U, 1U, 0U},
+}};
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_EXP10M1F16_EXCEPTS_HI = 3;
+#else
+static constexpr size_t N_EXP10M1F16_EXCEPTS_HI = 6;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_EXP10M1F16_EXCEPTS_HI>
+    EXP10M1F16_EXCEPTS_HI = {{
+        // (input, RZ output, RU offset, RD offset, RN offset)
+        // x = 0x1.8f4p-2, exp10m1f16(x) = 0x1.744p+0 (RZ)
+        {0x363dU, 0x3dd1U, 1U, 0U, 0U},
+        // x = 0x1.95cp-2, exp10m1f16(x) = 0x1.7d8p+0 (RZ)
+        {0x3657U, 0x3df6U, 1U, 0U, 0U},
+        // x = 0x1.d04p-2, exp10m1f16(x) = 0x1.d7p+0 (RZ)
+        {0x3741U, 0x3f5cU, 1U, 0U, 1U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.0cp+1, exp10m1f16(x) = 0x1.ec4p+6 (RZ)
+        {0x4030U, 0x57b1U, 1U, 0U, 1U},
+        // x = 0x1.1b8p+1, exp10m1f16(x) = 0x1.45cp+7 (RZ)
+        {0x406eU, 0x5917U, 1U, 0U, 1U},
+        // x = 0x1.2f4p+2, exp10m1f16(x) = 0x1.ab8p+15 (RZ)
+        {0x44bdU, 0x7aaeU, 1U, 0U, 1U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, exp10m1f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| <= 2^(-3), or |x| >= 11 * log10(2), or x is NaN.
+  if (LIBC_UNLIKELY(x_abs <= 0x3000U || x_abs >= 0x429fU)) {
+    // exp10m1(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When x >= 16 * log10(2).
+    if (x_u >= 0x44d1U && x_bits.is_pos()) {
+      // exp10m1(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x < -11 * log10(2).
+    if (x_u > 0xc29fU) {
+      // exp10m1(-inf) = -1
+      if (x_bits.is_inf())
+        return FPBits::one(Sign::NEG).get_val();
+
+      // When x >= -0x1.ce4p+1, round(10^x - 1, HP, RN) = -0x1.ffcp-1.
+      if (x_u <= 0xc339U) {
+        return fputil::round_result_slightly_down(
+            fputil::cast<float16>(-0x1.ffcp-1));
+      }
+
+      // When x < -0x1.ce4p+1, round(10^x - 1, HP, RN) = -1.
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_DOWNWARD:
+        return FPBits::one(Sign::NEG).get_val();
+      default:
+        return fputil::cast<float16>(-0x1.ffcp-1);
+      }
+    }
+
+    // When |x| <= 2^(-3).
+    if (x_abs <= 0x3000U) {
+      if (LIBC_UNLIKELY(x_abs == 0))
+        return x;
+
+      if (auto r = EXP10M1F16_EXCEPTS_LO.lookup(x_u);
+          LIBC_UNLIKELY(r.has_value()))
+        return r.value();
+
+      float xf = x;
+      // Degree-5 minimax polynomial generated by Sollya with the following
+      // commands:
+      //   > display = hexadecimal;
+      //   > P = fpminimax((10^x - 1)/x, 4, [|SG...|], [-2^-3, 2^-3]);
+      //   > x * P;
+      return fputil::cast<float16>(
+          xf * fputil::polyeval(xf, 0x1.26bb1cp+1f, 0x1.5351c8p+1f,
+                                0x1.04704p+1f, 0x1.2ce084p+0f, 0x1.14a6bep-1f));
+    }
+  }
+
+  // When x is 1, 2, or 3. These are hard-to-round cases with exact results.
+  // 10^4 - 1 = 9'999 is not exactly representable as a float16, but luckily the
+  // polynomial approximation gives the correct result for x = 4 in all
+  // rounding modes.
+  if (LIBC_UNLIKELY((x_u & ~(0x3c00U | 0x4000U | 0x4200U | 0x4400U)) == 0)) {
+    switch (x_u) {
+    case 0x3c00U: // x = 1.0f16
+      return fputil::cast<float16>(9.0);
+    case 0x4000U: // x = 2.0f16
+      return fputil::cast<float16>(99.0);
+    case 0x4200U: // x = 3.0f16
+      return fputil::cast<float16>(999.0);
+    }
+  }
+
+  if (auto r = EXP10M1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // exp10(x) = exp2((hi + mid) * log2(10)) * exp10(lo)
+  auto [exp2_hi_mid, exp10_lo] = exp10_range_reduction(x);
+  // exp10m1(x) = exp2((hi + mid) * log2(lo)) * exp10(lo) - 1
+  return fputil::cast<float16>(
+      fputil::multiply_add(exp2_hi_mid, exp10_lo, -1.0f));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2.cpp b/src/math/generic/exp2.cpp
index 1a2fa3f..935548b 100644
--- a/src/math/generic/exp2.cpp
+++ b/src/math/generic/exp2.cpp
@@ -22,11 +22,10 @@
 #include "src/__support/FPUtil/triple_double.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using fputil::DoubleDouble;
 using fputil::TripleDouble;
@@ -390,4 +389,4 @@ LLVM_LIBC_FUNCTION(double, exp2, (double x)) {
   return static_cast<double>(r_f128);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2f.cpp b/src/math/generic/exp2f.cpp
index e6cb938..60d6510 100644
--- a/src/math/generic/exp2f.cpp
+++ b/src/math/generic/exp2f.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/exp2f.h"
 #include "src/__support/common.h" // for LLVM_LIBC_FUNCTION
+#include "src/__support/macros/config.h"
 #include "src/math/generic/exp2f_impl.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp2f, (float x)) { return generic::exp2f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2f16.cpp b/src/math/generic/exp2f16.cpp
new file mode 100644
index 0000000..858053f
--- /dev/null
+++ b/src/math/generic/exp2f16.cpp
@@ -0,0 +1,93 @@
+//===-- Half-precision 2^x function ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp2f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 3> EXP2F16_EXCEPTS = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.714p-11, exp2f16(x) = 0x1p+0 (RZ)
+    {0x11c5U, 0x3c00U, 1U, 0U, 1U},
+    // x = -0x1.558p-4, exp2f16(x) = 0x1.e34p-1 (RZ)
+    {0xad56U, 0x3b8dU, 1U, 0U, 0U},
+    // x = -0x1.d5cp-4, exp2f16(x) = 0x1.d8cp-1 (RZ)
+    {0xaf57U, 0x3b63U, 1U, 0U, 0U},
+}};
+
+LLVM_LIBC_FUNCTION(float16, exp2f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| >= 16, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs >= 0x4c00U)) {
+    // exp2(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When x >= 16.
+    if (x_bits.is_pos()) {
+      // exp2(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x <= -25.
+    if (x_u >= 0xce40U) {
+      // exp2(-inf) = +0
+      if (x_bits.is_inf())
+        return FPBits::zero().get_val();
+
+      fputil::set_errno_if_required(ERANGE);
+      fputil::raise_except_if_required(FE_UNDERFLOW | FE_INEXACT);
+
+      if (fputil::fenv_is_round_up())
+        return FPBits::min_subnormal().get_val();
+      return FPBits::zero().get_val();
+    }
+  }
+
+  if (auto r = EXP2F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // exp2(x) = exp2(hi + mid) * exp2(lo)
+  auto [exp2_hi_mid, exp2_lo] = exp2_range_reduction(x);
+  return fputil::cast<float16>(exp2_hi_mid * exp2_lo);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2f_impl.h b/src/math/generic/exp2f_impl.h
index d2342e2..ae2d062 100644
--- a/src/math/generic/exp2f_impl.h
+++ b/src/math/generic/exp2f_impl.h
@@ -17,14 +17,14 @@
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h"
 
-#include <errno.h>
-
 #include "explogxf.h"
 
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
 
 LIBC_INLINE float exp2f(float x) {
   constexpr uint32_t EXVAL1 = 0x3b42'9d37U;
@@ -160,6 +160,7 @@ LIBC_INLINE float exp2f(float x) {
   return static_cast<float>(fputil::multiply_add(p, dx_sq * mh, c1 * mh));
 }
 
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_EXP2F_IMPL_H
diff --git a/src/math/generic/exp2m1f.cpp b/src/math/generic/exp2m1f.cpp
index c60930d..2060dc3 100644
--- a/src/math/generic/exp2m1f.cpp
+++ b/src/math/generic/exp2m1f.cpp
@@ -14,13 +14,14 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/macros/properties/cpu_features.h"
 #include "src/errno/libc_errno.h"
 
 #include "explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static constexpr size_t N_EXCEPTS_LO = 8;
 
@@ -180,4 +181,4 @@ LLVM_LIBC_FUNCTION(float, exp2m1f, (float x)) {
   return static_cast<float>(fputil::multiply_add(exp2_lo, mh, -1.0));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2m1f16.cpp b/src/math/generic/exp2m1f16.cpp
new file mode 100644
index 0000000..6a1cd23
--- /dev/null
+++ b/src/math/generic/exp2m1f16.cpp
@@ -0,0 +1,162 @@
+//===-- Half-precision 2^x - 1 function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp2m1f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 6> EXP2M1F16_EXCEPTS_LO = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.cf4p-13, exp2m1f16(x) = 0x1.41p-13 (RZ)
+    {0x0b3dU, 0x0904U, 1U, 0U, 1U},
+    // x = 0x1.4fcp-12, exp2m1f16(x) = 0x1.d14p-13 (RZ)
+    {0x0d3fU, 0x0b45U, 1U, 0U, 1U},
+    // x = 0x1.63p-11, exp2m1f16(x) = 0x1.ec4p-12 (RZ)
+    {0x118cU, 0x0fb1U, 1U, 0U, 0U},
+    // x = 0x1.6fp-7, exp2m1f16(x) = 0x1.fe8p-8 (RZ)
+    {0x21bcU, 0x1ffaU, 1U, 0U, 1U},
+    // x = -0x1.c6p-10, exp2m1f16(x) = -0x1.3a8p-10 (RZ)
+    {0x9718U, 0x94eaU, 0U, 1U, 0U},
+    // x = -0x1.cfcp-10, exp2m1f16(x) = -0x1.414p-10 (RZ)
+    {0x973fU, 0x9505U, 0U, 1U, 0U},
+}};
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_EXP2M1F16_EXCEPTS_HI = 6;
+#else
+static constexpr size_t N_EXP2M1F16_EXCEPTS_HI = 7;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_EXP2M1F16_EXCEPTS_HI>
+    EXP2M1F16_EXCEPTS_HI = {{
+        // (input, RZ output, RU offset, RD offset, RN offset)
+        // x = 0x1.e58p-3, exp2m1f16(x) = 0x1.6dcp-3 (RZ)
+        {0x3396U, 0x31b7U, 1U, 0U, 0U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.2e8p-2, exp2m1f16(x) = 0x1.d14p-3 (RZ)
+        {0x34baU, 0x3345U, 1U, 0U, 0U},
+#endif
+        // x = 0x1.ad8p-2, exp2m1f16(x) = 0x1.598p-2 (RZ)
+        {0x36b6U, 0x3566U, 1U, 0U, 0U},
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.edcp-2, exp2m1f16(x) = 0x1.964p-2 (RZ)
+        {0x37b7U, 0x3659U, 1U, 0U, 1U},
+#endif
+        // x = -0x1.804p-3, exp2m1f16(x) = -0x1.f34p-4 (RZ)
+        {0xb201U, 0xafcdU, 0U, 1U, 1U},
+        // x = -0x1.f3p-3, exp2m1f16(x) = -0x1.3e4p-3 (RZ)
+        {0xb3ccU, 0xb0f9U, 0U, 1U, 0U},
+        // x = -0x1.294p-1, exp2m1f16(x) = -0x1.53p-2 (RZ)
+        {0xb8a5U, 0xb54cU, 0U, 1U, 1U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = -0x1.a34p-1, exp2m1f16(x) = -0x1.bb4p-2 (RZ)
+        {0xba8dU, 0xb6edU, 0U, 1U, 1U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, exp2m1f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| <= 2^(-3), or |x| >= 11, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs <= 0x3000U || x_abs >= 0x4980U)) {
+    // exp2m1(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When x >= 16.
+    if (x_u >= 0x4c00 && x_bits.is_pos()) {
+      // exp2m1(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x < -11.
+    if (x_u > 0xc980U) {
+      // exp2m1(-inf) = -1
+      if (x_bits.is_inf())
+        return FPBits::one(Sign::NEG).get_val();
+
+      // When -12 < x < -11, round(2^x - 1, HP, RN) = -0x1.ffcp-1.
+      if (x_u < 0xca00U)
+        return fputil::round_result_slightly_down(
+            fputil::cast<float16>(-0x1.ffcp-1));
+
+      // When x <= -12, round(2^x - 1, HP, RN) = -1.
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_DOWNWARD:
+        return FPBits::one(Sign::NEG).get_val();
+      default:
+        return fputil::cast<float16>(-0x1.ffcp-1);
+      }
+    }
+
+    // When |x| <= 2^(-3).
+    if (x_abs <= 0x3000U) {
+      if (auto r = EXP2M1F16_EXCEPTS_LO.lookup(x_u);
+          LIBC_UNLIKELY(r.has_value()))
+        return r.value();
+
+      float xf = x;
+      // Degree-5 minimax polynomial generated by Sollya with the following
+      // commands:
+      //   > display = hexadecimal;
+      //   > P = fpminimax((2^x - 1)/x, 4, [|SG...|], [-2^-3, 2^-3]);
+      //   > x * P;
+      return fputil::cast<float16>(
+          xf * fputil::polyeval(xf, 0x1.62e43p-1f, 0x1.ebfbdep-3f,
+                                0x1.c6af88p-5f, 0x1.3b45d6p-7f,
+                                0x1.641e7cp-10f));
+    }
+  }
+
+  if (auto r = EXP2M1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // exp2(x) = exp2(hi + mid) * exp2(lo)
+  auto [exp2_hi_mid, exp2_lo] = exp2_range_reduction(x);
+  // exp2m1(x) = exp2(hi + mid) * exp2(lo) - 1
+  return fputil::cast<float16>(
+      fputil::multiply_add(exp2_hi_mid, exp2_lo, -1.0f));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp_utils.cpp b/src/math/generic/exp_utils.cpp
index ad13919..cc21637 100644
--- a/src/math/generic/exp_utils.cpp
+++ b/src/math/generic/exp_utils.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "exp_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 const Exp2fDataTable exp2f_data = {
     // :tab[i] = uint(2^(i/N)) - (i << 52-BITS)
@@ -124,4 +125,4 @@ const Exp2fDataTable exp2f_data = {
     },
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp_utils.h b/src/math/generic/exp_utils.h
index 405678c..dca9eb7 100644
--- a/src/math/generic/exp_utils.h
+++ b/src/math/generic/exp_utils.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_MATH_GENERIC_EXP_UTILS_H
 #define LLVM_LIBC_SRC_MATH_GENERIC_EXP_UTILS_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
 #define EXP2F_TABLE_BITS 5
 #define EXP2F_POLY_ORDER 3
 #define N (1 << EXP2F_TABLE_BITS)
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct Exp2fDataTable {
   uint64_t tab[1 << EXP2F_TABLE_BITS];
@@ -28,6 +29,6 @@ struct Exp2fDataTable {
 
 extern const Exp2fDataTable exp2f_data;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_EXP_UTILS_H
diff --git a/src/math/generic/expf.cpp b/src/math/generic/expf.cpp
index c7ab974..ee5c2a3 100644
--- a/src/math/generic/expf.cpp
+++ b/src/math/generic/expf.cpp
@@ -16,11 +16,10 @@
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -105,4 +104,4 @@ LLVM_LIBC_FUNCTION(float, expf, (float x)) {
   return static_cast<float>(exp_hi * exp_mid * exp_lo);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/expf16.cpp b/src/math/generic/expf16.cpp
new file mode 100644
index 0000000..0548ef3
--- /dev/null
+++ b/src/math/generic/expf16.cpp
@@ -0,0 +1,120 @@
+//===-- Half-precision e^x function ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/expf16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 2> EXPF16_EXCEPTS_LO = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.de4p-8, expf16(x) = 0x1.01cp+0 (RZ)
+    {0x1f79U, 0x3c07U, 1U, 0U, 0U},
+    // x = 0x1.73cp-6, expf16(x) = 0x1.05cp+0 (RZ)
+    {0x25cfU, 0x3c17U, 1U, 0U, 0U},
+}};
+
+static constexpr fputil::ExceptValues<float16, 3> EXPF16_EXCEPTS_HI = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.c34p+0, expf16(x) = 0x1.74cp+2 (RZ)
+    {0x3f0dU, 0x45d3U, 1U, 0U, 1U},
+    // x = -0x1.488p-5, expf16(x) = 0x1.ebcp-1 (RZ)
+    {0xa922U, 0x3bafU, 1U, 0U, 0U},
+    // x = -0x1.55p-5, expf16(x) = 0x1.ebp-1 (RZ)
+    {0xa954U, 0x3bacU, 1U, 0U, 0U},
+}};
+
+LLVM_LIBC_FUNCTION(float16, expf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When 0 < |x| <= 2^(-5), or |x| >= 12, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs <= 0x2800U || x_abs >= 0x4a00U)) {
+    // exp(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When x >= 12.
+    if (x_bits.is_pos() && x_abs >= 0x4a00U) {
+      // exp(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x <= -18.
+    if (x_u >= 0xcc80U) {
+      // exp(-inf) = +0
+      if (x_bits.is_inf())
+        return FPBits::zero().get_val();
+
+      fputil::set_errno_if_required(ERANGE);
+      fputil::raise_except_if_required(FE_UNDERFLOW | FE_INEXACT);
+
+      switch (fputil::quick_get_round()) {
+      case FE_UPWARD:
+        return FPBits::min_subnormal().get_val();
+      default:
+        return FPBits::zero().get_val();
+      }
+    }
+
+    // When 0 < |x| <= 2^(-5).
+    if (x_abs <= 0x2800U && !x_bits.is_zero()) {
+      if (auto r = EXPF16_EXCEPTS_LO.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+        return r.value();
+
+      float xf = x;
+      // Degree-3 minimax polynomial generated by Sollya with the following
+      // commands:
+      //   > display = hexadecimal;
+      //   > P = fpminimax(expm1(x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+      //   > 1 + x * P;
+      return fputil::cast<float16>(
+          fputil::polyeval(xf, 0x1p+0f, 0x1p+0f, 0x1.0004p-1f, 0x1.555778p-3f));
+    }
+  }
+
+  if (auto r = EXPF16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // exp(x) = exp(hi + mid) * exp(lo)
+  auto [exp_hi_mid, exp_lo] = exp_range_reduction(x);
+  return fputil::cast<float16>(exp_hi_mid * exp_lo);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/explogxf.cpp b/src/math/generic/explogxf.cpp
index 87ee578..9e945ec 100644
--- a/src/math/generic/explogxf.cpp
+++ b/src/math/generic/explogxf.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "explogxf.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // N[Table[Log[2, 1 + x], {x, 0/64, 63/64, 1/64}], 40]
 alignas(64) const double LOG_P1_LOG2[LOG_P1_SIZE] = {
@@ -71,4 +72,4 @@ alignas(64) const
     double K_LOG2_EVEN[4] = {-0x1.71547652b82fep-1, -0x1.71547652b82fep-2,
                              -0x1.ec709dc3a03fdp-3, -0x1.2776c50ef9bfep-3};
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/explogxf.h b/src/math/generic/explogxf.h
index f7d04f5..651524a 100644
--- a/src/math/generic/explogxf.h
+++ b/src/math/generic/explogxf.h
@@ -17,11 +17,10 @@
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/cpu_features.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct ExpBase {
   // Base = e
@@ -160,12 +159,12 @@ template <class Base> LIBC_INLINE exp_b_reduc_t exp_b_range_reduc(float x) {
   int k = static_cast<int>(kd);
   // hi = floor(kd * 2^(-MID_BITS))
   // exp_hi = shift hi to the exponent field of double precision.
-  int64_t exp_hi = static_cast<int64_t>((k >> Base::MID_BITS))
-                   << fputil::FPBits<double>::FRACTION_LEN;
+  uint64_t exp_hi = static_cast<uint64_t>(k >> Base::MID_BITS)
+                    << fputil::FPBits<double>::FRACTION_LEN;
   // mh = 2^hi * 2^mid
   // mh_bits = bit field of mh
-  int64_t mh_bits = Base::EXP_2_MID[k & Base::MID_MASK] + exp_hi;
-  double mh = fputil::FPBits<double>(uint64_t(mh_bits)).get_val();
+  uint64_t mh_bits = Base::EXP_2_MID[k & Base::MID_MASK] + exp_hi;
+  double mh = fputil::FPBits<double>(mh_bits).get_val();
   // dx = lo = x - (hi + mid) * log(2)
   double dx = fputil::multiply_add(
       kd, Base::M_LOGB_2_LO, fputil::multiply_add(kd, Base::M_LOGB_2_HI, xd));
@@ -379,6 +378,6 @@ LIBC_INLINE cpp::optional<double> ziv_test_denorm(int hi, double mid, double lo,
   return cpp::nullopt;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_EXPLOGXF_H
diff --git a/src/math/generic/expm1.cpp b/src/math/generic/expm1.cpp
index 574c4b9..a4dbf38 100644
--- a/src/math/generic/expm1.cpp
+++ b/src/math/generic/expm1.cpp
@@ -23,18 +23,14 @@
 #include "src/__support/FPUtil/triple_double.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
-#include <errno.h>
-
-// #define DEBUGDEBUG
-
-#ifdef DEBUGDEBUG
-#include <iomanip>
-#include <iostream>
+#if ((LIBC_MATH & LIBC_MATH_SKIP_ACCURATE_PASS) != 0)
+#define LIBC_MATH_EXPM1_SKIP_ACCURATE_PASS
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using fputil::DoubleDouble;
 using fputil::TripleDouble;
@@ -51,7 +47,7 @@ constexpr double LOG2_E = 0x1.71547652b82fep+0;
 constexpr uint64_t ERR_D = 0x3c08000000000000;
 // Errors when using double-double precision.
 // 0x1.0p-99
-constexpr uint64_t ERR_DD = 0x39c0000000000000;
+[[maybe_unused]] constexpr uint64_t ERR_DD = 0x39c0000000000000;
 
 // -2^-12 * log(2)
 // > a = -2^-12 * log(2);
@@ -108,7 +104,7 @@ DoubleDouble poly_approx_dd(const DoubleDouble &dx) {
 // Return (exp(dx) - 1)/dx ~ 1 + dx / 2 + dx^2 / 6 + ... + dx^6 / 5040
 // For |dx| < 2^-13 + 2^-30:
 //   | output - exp(dx) | < 2^-126.
-Float128 poly_approx_f128(const Float128 &dx) {
+[[maybe_unused]] Float128 poly_approx_f128(const Float128 &dx) {
   constexpr Float128 COEFFS_128[]{
       {Sign::POS, -127, 0x80000000'00000000'00000000'00000000_u128}, // 1.0
       {Sign::POS, -128, 0x80000000'00000000'00000000'00000000_u128}, // 0.5
@@ -127,13 +123,14 @@ Float128 poly_approx_f128(const Float128 &dx) {
 
 #ifdef DEBUGDEBUG
 std::ostream &operator<<(std::ostream &OS, const Float128 &r) {
-  OS << (r.sign ? "-(" : "(") << r.mantissa.val[0] << " + " << r.mantissa.val[1]
-     << " * 2^64) * 2^" << r.exponent << "\n";
+  OS << (r.sign == Sign::NEG ? "-(" : "(") << r.mantissa.val[0] << " + "
+     << r.mantissa.val[1] << " * 2^64) * 2^" << r.exponent << "\n";
   return OS;
 }
 
 std::ostream &operator<<(std::ostream &OS, const DoubleDouble &r) {
-  OS << std::hexfloat << r.hi << " + " << r.lo << std::defaultfloat << "\n";
+  OS << std::hexfloat << "(" << r.hi << " + " << r.lo << ")"
+     << std::defaultfloat << "\n";
   return OS;
 }
 #endif
@@ -141,7 +138,7 @@ std::ostream &operator<<(std::ostream &OS, const DoubleDouble &r) {
 // Compute exp(x) - 1 using 128-bit precision.
 // TODO(lntue): investigate triple-double precision implementation for this
 // step.
-Float128 expm1_f128(double x, double kd, int idx1, int idx2) {
+[[maybe_unused]] Float128 expm1_f128(double x, double kd, int idx1, int idx2) {
   // Recalculate dx:
 
   double t1 = fputil::multiply_add(kd, MLOG_2_EXP2_M12_HI, x); // exact
@@ -182,9 +179,10 @@ Float128 expm1_f128(double x, double kd, int idx1, int idx2) {
 #ifdef DEBUGDEBUG
   std::cout << "=== VERY SLOW PASS ===\n"
             << "        kd: " << kd << "\n"
-            << "        dx: " << dx << "exp_mid_m1: " << exp_mid_m1
-            << "   exp_mid: " << exp_mid << "         p: " << p
-            << "         r: " << r << std::endl;
+            << "        hi: " << hi << "\n"
+            << " minus_one: " << minus_one << "        dx: " << dx
+            << "exp_mid_m1: " << exp_mid_m1 << "   exp_mid: " << exp_mid
+            << "         p: " << p << "         r: " << r << std::endl;
 #endif
 
   return r;
@@ -479,6 +477,12 @@ LLVM_LIBC_FUNCTION(double, expm1, (double x)) {
   // Use double-double
   DoubleDouble r_dd = exp_double_double(x, kd, exp_mid, hi_part);
 
+#ifdef LIBC_MATH_EXPM1_SKIP_ACCURATE_PASS
+  int64_t exp_hi = static_cast<int64_t>(hi) << FPBits::FRACTION_LEN;
+  double r =
+      cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(r_dd.hi + r_dd.lo));
+  return r;
+#else
   double err_dd = cpp::bit_cast<double>(ERR_DD + err);
 
   double upper_dd = r_dd.hi + (r_dd.lo + err_dd);
@@ -494,6 +498,7 @@ LLVM_LIBC_FUNCTION(double, expm1, (double x)) {
   Float128 r_f128 = expm1_f128(x, kd, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_EXPM1_SKIP_ACCURATE_PASS
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/expm1f.cpp b/src/math/generic/expm1f.cpp
index 6b9f074..d5e9e85 100644
--- a/src/math/generic/expm1f.cpp
+++ b/src/math/generic/expm1f.cpp
@@ -17,12 +17,11 @@
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expm1f, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -170,4 +169,4 @@ LLVM_LIBC_FUNCTION(float, expm1f, (float x)) {
   return static_cast<float>(fputil::multiply_add(exp_hi_mid, exp_lo, -1.0));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/expm1f16.cpp b/src/math/generic/expm1f16.cpp
new file mode 100644
index 0000000..4ce0efd
--- /dev/null
+++ b/src/math/generic/expm1f16.cpp
@@ -0,0 +1,133 @@
+//===-- Half-precision e^x - 1 function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/expm1f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 1> EXPM1F16_EXCEPTS_LO = {{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    // x = 0x1.564p-5, expm1f16(x) = 0x1.5d4p-5 (RZ)
+    {0x2959U, 0x2975U, 1U, 0U, 1U},
+}};
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_EXPM1F16_EXCEPTS_HI = 2;
+#else
+static constexpr size_t N_EXPM1F16_EXCEPTS_HI = 3;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_EXPM1F16_EXCEPTS_HI>
+    EXPM1F16_EXCEPTS_HI = {{
+        // (input, RZ output, RU offset, RD offset, RN offset)
+        // x = 0x1.c34p+0, expm1f16(x) = 0x1.34cp+2 (RZ)
+        {0x3f0dU, 0x44d3U, 1U, 0U, 1U},
+        // x = -0x1.e28p-3, expm1f16(x) = -0x1.adcp-3 (RZ)
+        {0xb38aU, 0xb2b7U, 0U, 1U, 1U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.a08p-3, exp10m1f(x) = 0x1.cdcp-3 (RZ)
+        {0x3282U, 0x3337U, 1U, 0U, 0U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, expm1f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| <= 2^(-3), or |x| >= -11 * log(2), or x is NaN.
+  if (LIBC_UNLIKELY(x_abs <= 0x3000U || x_abs >= 0x47a0U)) {
+    // expm1(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // expm1(+/-0) = +/-0
+    if (x_abs == 0)
+      return x;
+
+    // When x >= 16 * log(2).
+    if (x_bits.is_pos() && x_abs >= 0x498cU) {
+      // expm1(+inf) = +inf
+      if (x_bits.is_inf())
+        return FPBits::inf().get_val();
+
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_UPWARD:
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+        return FPBits::inf().get_val();
+      default:
+        return FPBits::max_normal().get_val();
+      }
+    }
+
+    // When x <= -11 * log(2).
+    if (x_u >= 0xc7a0U) {
+      // expm1(-inf) = -1
+      if (x_bits.is_inf())
+        return FPBits::one(Sign::NEG).get_val();
+
+      // When x > -0x1.0ap+3, round(expm1(x), HP, RN) = -1.
+      if (x_u > 0xc828U)
+        return fputil::round_result_slightly_up(
+            FPBits::one(Sign::NEG).get_val());
+      // When x <= -0x1.0ap+3, round(expm1(x), HP, RN) = -0x1.ffcp-1.
+      return fputil::round_result_slightly_down(
+          fputil::cast<float16>(-0x1.ffcp-1));
+    }
+
+    // When 0 < |x| <= 2^(-3).
+    if (x_abs <= 0x3000U && !x_bits.is_zero()) {
+      if (auto r = EXPM1F16_EXCEPTS_LO.lookup(x_u);
+          LIBC_UNLIKELY(r.has_value()))
+        return r.value();
+
+      float xf = x;
+      // Degree-5 minimax polynomial generated by Sollya with the following
+      // commands:
+      //   > display = hexadecimal;
+      //   > P = fpminimax(expm1(x)/x, 4, [|SG...|], [-2^-3, 2^-3]);
+      //   > x * P;
+      return fputil::cast<float16>(
+          xf * fputil::polyeval(xf, 0x1p+0f, 0x1.fffff8p-2f, 0x1.555556p-3f,
+                                0x1.55905ep-5f, 0x1.1124c2p-7f));
+    }
+  }
+
+  if (auto r = EXPM1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // exp(x) = exp(hi + mid) * exp(lo)
+  auto [exp_hi_mid, exp_lo] = exp_range_reduction(x);
+  // expm1(x) = exp(hi + mid) * exp(lo) - 1
+  return fputil::cast<float16>(fputil::multiply_add(exp_hi_mid, exp_lo, -1.0f));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/expxf16.h b/src/math/generic/expxf16.h
new file mode 100644
index 0000000..67bb248
--- /dev/null
+++ b/src/math/generic/expxf16.h
@@ -0,0 +1,349 @@
+//===-- Common utilities for half-precision exponential functions ---------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_EXPXF16_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_EXPXF16_H
+
+#include "src/__support/CPP/array.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from -18 to 12 do print(round(exp(i), SG, RN));
+static constexpr cpp::array<float, 31> EXP_HI = {
+    0x1.05a628p-26f, 0x1.639e32p-25f, 0x1.e355bcp-24f, 0x1.4875cap-22f,
+    0x1.be6c7p-21f,  0x1.2f6054p-19f, 0x1.9c54c4p-18f, 0x1.183542p-16f,
+    0x1.7cd79cp-15f, 0x1.02cf22p-13f, 0x1.5fc21p-12f,  0x1.de16bap-11f,
+    0x1.44e52p-9f,   0x1.b993fep-8f,  0x1.2c155cp-6f,  0x1.97db0cp-5f,
+    0x1.152aaap-3f,  0x1.78b564p-2f,  0x1p+0f,         0x1.5bf0a8p+1f,
+    0x1.d8e64cp+2f,  0x1.415e5cp+4f,  0x1.b4c902p+5f,  0x1.28d38ap+7f,
+    0x1.936dc6p+8f,  0x1.122886p+10f, 0x1.749ea8p+11f, 0x1.fa7158p+12f,
+    0x1.5829dcp+14f, 0x1.d3c448p+15f, 0x1.3de166p+17f,
+};
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 7 do print(round(exp(i * 2^-3), SG, RN));
+static constexpr cpp::array<float, 8> EXP_MID = {
+    0x1p+0f,        0x1.221604p+0f, 0x1.48b5e4p+0f, 0x1.747a52p+0f,
+    0x1.a61298p+0f, 0x1.de455ep+0f, 0x1.0ef9dcp+1f, 0x1.330e58p+1f,
+};
+
+struct ExpRangeReduction {
+  float exp_hi_mid;
+  float exp_lo;
+};
+
+LIBC_INLINE ExpRangeReduction exp_range_reduction(float16 x) {
+  // For -18 < x < 12, to compute exp(x), we perform the following range
+  // reduction: find hi, mid, lo, such that:
+  //   x = hi + mid + lo, in which
+  //     hi is an integer,
+  //     mid * 2^3 is an integer,
+  //     -2^(-4) <= lo < 2^(-4).
+  // In particular,
+  //   hi + mid = round(x * 2^3) * 2^(-3).
+  // Then,
+  //   exp(x) = exp(hi + mid + lo) = exp(hi) * exp(mid) * exp(lo).
+  // We store exp(hi) and exp(mid) in the lookup tables EXP_HI and EXP_MID
+  // respectively.  exp(lo) is computed using a degree-3 minimax polynomial
+  // generated by Sollya.
+
+  float xf = x;
+  float kf = fputil::nearest_integer(xf * 0x1.0p+3f);
+  int x_hi_mid = static_cast<int>(kf);
+  int x_hi = x_hi_mid >> 3;
+  int x_mid = x_hi_mid & 0x7;
+  // lo = x - (hi + mid) = round(x * 2^3) * (-2^(-3)) + x
+  float lo = fputil::multiply_add(kf, -0x1.0p-3f, xf);
+
+  float exp_hi = EXP_HI[x_hi + 18];
+  float exp_mid = EXP_MID[x_mid];
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(expm1(x)/x, 2, [|SG...|], [-2^-4, 2^-4]);
+  //   > 1 + x * P;
+  float exp_lo =
+      fputil::polyeval(lo, 0x1p+0f, 0x1p+0f, 0x1.001p-1f, 0x1.555ddep-3f);
+  return {exp_hi * exp_mid, exp_lo};
+}
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 7 do printsingle(round(2^(i * 2^-3), SG, RN));
+constexpr cpp::array<uint32_t, 8> EXP2_MID_BITS = {
+    0x3f80'0000U, 0x3f8b'95c2U, 0x3f98'37f0U, 0x3fa5'fed7U,
+    0x3fb5'04f3U, 0x3fc5'672aU, 0x3fd7'44fdU, 0x3fea'c0c7U,
+};
+
+LIBC_INLINE ExpRangeReduction exp2_range_reduction(float16 x) {
+  // For -25 < x < 16, to compute 2^x, we perform the following range reduction:
+  // find hi, mid, lo, such that:
+  //   x = hi + mid + lo, in which
+  //     hi is an integer,
+  //     mid * 2^3 is an integer,
+  //     -2^(-4) <= lo < 2^(-4).
+  // In particular,
+  //   hi + mid = round(x * 2^3) * 2^(-3).
+  // Then,
+  //   2^x = 2^(hi + mid + lo) = 2^hi * 2^mid * 2^lo.
+  // We store 2^mid in the lookup table EXP2_MID_BITS, and compute 2^hi * 2^mid
+  // by adding hi to the exponent field of 2^mid.  2^lo is computed using a
+  // degree-3 minimax polynomial generated by Sollya.
+
+  float xf = x;
+  float kf = fputil::nearest_integer(xf * 0x1.0p+3f);
+  int x_hi_mid = static_cast<int>(kf);
+  unsigned x_hi = static_cast<unsigned>(x_hi_mid) >> 3;
+  unsigned x_mid = static_cast<unsigned>(x_hi_mid) & 0x7;
+  // lo = x - (hi + mid) = round(x * 2^3) * (-2^(-3)) + x
+  float lo = fputil::multiply_add(kf, -0x1.0p-3f, xf);
+
+  uint32_t exp2_hi_mid_bits =
+      EXP2_MID_BITS[x_mid] +
+      static_cast<uint32_t>(x_hi << fputil::FPBits<float>::FRACTION_LEN);
+  float exp2_hi_mid = fputil::FPBits<float>(exp2_hi_mid_bits).get_val();
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax((2^x - 1)/x, 2, [|SG...|], [-2^-4, 2^-4]);
+  //   > 1 + x * P;
+  float exp2_lo = fputil::polyeval(lo, 0x1p+0f, 0x1.62e43p-1f, 0x1.ec0aa6p-3f,
+                                   0x1.c6b4a6p-5f);
+  return {exp2_hi_mid, exp2_lo};
+}
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > round(log2(10), SG, RN);
+static constexpr float LOG2F_10 = 0x1.a934fp+1f;
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > round(log10(2), SG, RN);
+static constexpr float LOG10F_2 = 0x1.344136p-2f;
+
+LIBC_INLINE ExpRangeReduction exp10_range_reduction(float16 x) {
+  // For -8 < x < 5, to compute 10^x, we perform the following range reduction:
+  // find hi, mid, lo, such that:
+  //   x = (hi + mid) * log2(10) + lo, in which
+  //     hi is an integer,
+  //     mid * 2^3 is an integer,
+  //     -2^(-4) <= lo < 2^(-4).
+  // In particular,
+  //   hi + mid = round(x * 2^3) * 2^(-3).
+  // Then,
+  //   10^x = 10^(hi + mid + lo) = 2^((hi + mid) * log2(10)) + 10^lo
+  // We store 2^mid in the lookup table EXP2_MID_BITS, and compute 2^hi * 2^mid
+  // by adding hi to the exponent field of 2^mid.  10^lo is computed using a
+  // degree-4 minimax polynomial generated by Sollya.
+
+  float xf = x;
+  float kf = fputil::nearest_integer(xf * (LOG2F_10 * 0x1.0p+3f));
+  int x_hi_mid = static_cast<int>(kf);
+  unsigned x_hi = static_cast<unsigned>(x_hi_mid) >> 3;
+  unsigned x_mid = static_cast<unsigned>(x_hi_mid) & 0x7;
+  // lo = x - (hi + mid) = round(x * 2^3 * log2(10)) * log10(2) * (-2^(-3)) + x
+  float lo = fputil::multiply_add(kf, LOG10F_2 * -0x1.0p-3f, xf);
+
+  uint32_t exp2_hi_mid_bits =
+      EXP2_MID_BITS[x_mid] +
+      static_cast<uint32_t>(x_hi << fputil::FPBits<float>::FRACTION_LEN);
+  float exp2_hi_mid = fputil::FPBits<float>(exp2_hi_mid_bits).get_val();
+  // Degree-4 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax((10^x - 1)/x, 3, [|SG...|], [-2^-4, 2^-4]);
+  //   > 1 + x * P;
+  float exp10_lo = fputil::polyeval(lo, 0x1p+0f, 0x1.26bb14p+1f, 0x1.53526p+1f,
+                                    0x1.04b434p+1f, 0x1.2bcf9ep+0f);
+  return {exp2_hi_mid, exp10_lo};
+}
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > round(log2(exp(1)), SG, RN);
+static constexpr float LOG2F_E = 0x1.715476p+0f;
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > round(log(2), SG, RN);
+static constexpr float LOGF_2 = 0x1.62e43p-1f;
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 31 do printsingle(round(2^(i * 2^-5), SG, RN));
+static constexpr cpp::array<uint32_t, 32> EXP2_MID_5_BITS = {
+    0x3f80'0000U, 0x3f82'cd87U, 0x3f85'aac3U, 0x3f88'980fU, 0x3f8b'95c2U,
+    0x3f8e'a43aU, 0x3f91'c3d3U, 0x3f94'f4f0U, 0x3f98'37f0U, 0x3f9b'8d3aU,
+    0x3f9e'f532U, 0x3fa2'7043U, 0x3fa5'fed7U, 0x3fa9'a15bU, 0x3fad'583fU,
+    0x3fb1'23f6U, 0x3fb5'04f3U, 0x3fb8'fbafU, 0x3fbd'08a4U, 0x3fc1'2c4dU,
+    0x3fc5'672aU, 0x3fc9'b9beU, 0x3fce'248cU, 0x3fd2'a81eU, 0x3fd7'44fdU,
+    0x3fdb'fbb8U, 0x3fe0'ccdfU, 0x3fe5'b907U, 0x3fea'c0c7U, 0x3fef'e4baU,
+    0x3ff5'257dU, 0x3ffa'83b3U,
+};
+
+// This function correctly calculates sinh(x) and cosh(x) by calculating exp(x)
+// and exp(-x) simultaneously.
+// To compute e^x, we perform the following range reduction:
+// find hi, mid, lo such that:
+//   x = (hi + mid) * log(2) + lo, in which
+//     hi is an integer,
+//     0 <= mid * 2^5 < 32 is an integer
+//     -2^(-5) <= lo * log2(e) <= 2^-5.
+// In particular,
+//   hi + mid = round(x * log2(e) * 2^5) * 2^(-5).
+// Then,
+//   e^x = 2^(hi + mid) * e^lo = 2^hi * 2^mid * e^lo.
+// We store 2^mid in the lookup table EXP2_MID_5_BITS, and compute 2^hi * 2^mid
+// by adding hi to the exponent field of 2^mid.
+// e^lo is computed using a degree-3 minimax polynomial generated by Sollya:
+//   e^lo ~ P(lo)
+//        = 1 + lo + c2 * lo^2 + ... + c5 * lo^5
+//        = (1 + c2*lo^2 + c4*lo^4) + lo * (1 + c3*lo^2 + c5*lo^4)
+//        = P_even + lo * P_odd
+// To compute e^(-x), notice that:
+//   e^(-x) = 2^(-(hi + mid)) * e^(-lo)
+//          ~ 2^(-(hi + mid)) * P(-lo)
+//          = 2^(-(hi + mid)) * (P_even - lo * P_odd)
+// So:
+//   sinh(x) = (e^x - e^(-x)) / 2
+//           ~ 0.5 * (2^(hi + mid) * (P_even + lo * P_odd) -
+//                    2^(-(hi + mid)) * (P_even - lo * P_odd))
+//           = 0.5 * (P_even * (2^(hi + mid) - 2^(-(hi + mid))) +
+//                    lo * P_odd * (2^(hi + mid) + 2^(-(hi + mid))))
+// And similarly:
+//   cosh(x) = (e^x + e^(-x)) / 2
+//           ~ 0.5 * (P_even * (2^(hi + mid) + 2^(-(hi + mid))) +
+//                    lo * P_odd * (2^(hi + mid) - 2^(-(hi + mid))))
+// The main point of these formulas is that the expensive part of calculating
+// the polynomials approximating lower parts of e^x and e^(-x) is shared and
+// only done once.
+template <bool IsSinh> LIBC_INLINE float16 eval_sinh_or_cosh(float16 x) {
+  float xf = x;
+  float kf = fputil::nearest_integer(xf * (LOG2F_E * 0x1.0p+5f));
+  int x_hi_mid_p = static_cast<int>(kf);
+  int x_hi_mid_m = -x_hi_mid_p;
+
+  unsigned x_hi_p = static_cast<unsigned>(x_hi_mid_p) >> 5;
+  unsigned x_hi_m = static_cast<unsigned>(x_hi_mid_m) >> 5;
+  unsigned x_mid_p = static_cast<unsigned>(x_hi_mid_p) & 0x1f;
+  unsigned x_mid_m = static_cast<unsigned>(x_hi_mid_m) & 0x1f;
+
+  uint32_t exp2_hi_mid_bits_p =
+      EXP2_MID_5_BITS[x_mid_p] +
+      static_cast<uint32_t>(x_hi_p << fputil::FPBits<float>::FRACTION_LEN);
+  uint32_t exp2_hi_mid_bits_m =
+      EXP2_MID_5_BITS[x_mid_m] +
+      static_cast<uint32_t>(x_hi_m << fputil::FPBits<float>::FRACTION_LEN);
+  // exp2_hi_mid_p = 2^(hi + mid)
+  float exp2_hi_mid_p = fputil::FPBits<float>(exp2_hi_mid_bits_p).get_val();
+  // exp2_hi_mid_m = 2^(-(hi + mid))
+  float exp2_hi_mid_m = fputil::FPBits<float>(exp2_hi_mid_bits_m).get_val();
+
+  // exp2_hi_mid_sum = 2^(hi + mid) + 2^(-(hi + mid))
+  float exp2_hi_mid_sum = exp2_hi_mid_p + exp2_hi_mid_m;
+  // exp2_hi_mid_diff = 2^(hi + mid) - 2^(-(hi + mid))
+  float exp2_hi_mid_diff = exp2_hi_mid_p - exp2_hi_mid_m;
+
+  // lo = x - (hi + mid) = round(x * log2(e) * 2^5) * log(2) * (-2^(-5)) + x
+  float lo = fputil::multiply_add(kf, LOGF_2 * -0x1.0p-5f, xf);
+  float lo_sq = lo * lo;
+
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(expm1(x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+  //   > 1 + x * P;
+  constexpr cpp::array<float, 4> COEFFS = {0x1p+0f, 0x1p+0f, 0x1.0004p-1f,
+                                           0x1.555778p-3f};
+  float half_p_odd =
+      fputil::polyeval(lo_sq, COEFFS[1] * 0.5f, COEFFS[3] * 0.5f);
+  float half_p_even =
+      fputil::polyeval(lo_sq, COEFFS[0] * 0.5f, COEFFS[2] * 0.5f);
+
+  // sinh(x) = lo * (0.5 * P_odd * (2^(hi + mid) + 2^(-(hi + mid)))) +
+  //                (0.5 * P_even * (2^(hi + mid) - 2^(-(hi + mid))))
+  if constexpr (IsSinh)
+    return fputil::cast<float16>(fputil::multiply_add(
+        lo, half_p_odd * exp2_hi_mid_sum, half_p_even * exp2_hi_mid_diff));
+  // cosh(x) = lo * (0.5 * P_odd * (2^(hi + mid) - 2^(-(hi + mid)))) +
+  //                (0.5 * P_even * (2^(hi + mid) + 2^(-(hi + mid))))
+  return fputil::cast<float16>(fputil::multiply_add(
+      lo, half_p_odd * exp2_hi_mid_diff, half_p_even * exp2_hi_mid_sum));
+}
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 31 do print(round(log(1 + i * 2^-5), SG, RN));
+constexpr cpp::array<float, 32> LOGF_F = {
+    0x0p+0f,        0x1.f829bp-6f,  0x1.f0a30cp-5f, 0x1.6f0d28p-4f,
+    0x1.e27076p-4f, 0x1.29553p-3f,  0x1.5ff308p-3f, 0x1.9525aap-3f,
+    0x1.c8ff7cp-3f, 0x1.fb9186p-3f, 0x1.1675cap-2f, 0x1.2e8e2cp-2f,
+    0x1.4618bcp-2f, 0x1.5d1bdcp-2f, 0x1.739d8p-2f,  0x1.89a338p-2f,
+    0x1.9f323ep-2f, 0x1.b44f78p-2f, 0x1.c8ff7cp-2f, 0x1.dd46ap-2f,
+    0x1.f128f6p-2f, 0x1.02552ap-1f, 0x1.0be72ep-1f, 0x1.154c3ep-1f,
+    0x1.1e85f6p-1f, 0x1.2795e2p-1f, 0x1.307d74p-1f, 0x1.393e0ep-1f,
+    0x1.41d8fep-1f, 0x1.4a4f86p-1f, 0x1.52a2d2p-1f, 0x1.5ad404p-1f,
+};
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 31 do print(round(log2(1 + i * 2^-5), SG, RN));
+constexpr cpp::array<float, 32> LOG2F_F = {
+    0x0p+0f,        0x1.6bad38p-5f, 0x1.663f7p-4f,  0x1.08c588p-3f,
+    0x1.5c01a4p-3f, 0x1.acf5e2p-3f, 0x1.fbc16cp-3f, 0x1.24407ap-2f,
+    0x1.49a784p-2f, 0x1.6e221cp-2f, 0x1.91bba8p-2f, 0x1.b47ecp-2f,
+    0x1.d6753ep-2f, 0x1.f7a856p-2f, 0x1.0c105p-1f,  0x1.1bf312p-1f,
+    0x1.2b8034p-1f, 0x1.3abb4p-1f,  0x1.49a784p-1f, 0x1.584822p-1f,
+    0x1.66a008p-1f, 0x1.74b1fep-1f, 0x1.82809ep-1f, 0x1.900e62p-1f,
+    0x1.9d5dap-1f,  0x1.aa709p-1f,  0x1.b74948p-1f, 0x1.c3e9cap-1f,
+    0x1.d053f6p-1f, 0x1.dc899ap-1f, 0x1.e88c6cp-1f, 0x1.f45e08p-1f,
+};
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 31 do print(round(log10(1 + i * 2^-5), SG, RN));
+constexpr cpp::array<float, 32> LOG10F_F = {
+    0x0p+0f,        0x1.b5e908p-7f, 0x1.af5f92p-6f, 0x1.3ed11ap-5f,
+    0x1.a30a9ep-5f, 0x1.02428cp-4f, 0x1.31b306p-4f, 0x1.5fe804p-4f,
+    0x1.8cf184p-4f, 0x1.b8de4ep-4f, 0x1.e3bc1ap-4f, 0x1.06cbd6p-3f,
+    0x1.1b3e72p-3f, 0x1.2f3b6ap-3f, 0x1.42c7e8p-3f, 0x1.55e8c6p-3f,
+    0x1.68a288p-3f, 0x1.7af974p-3f, 0x1.8cf184p-3f, 0x1.9e8e7cp-3f,
+    0x1.afd3e4p-3f, 0x1.c0c514p-3f, 0x1.d1653p-3f,  0x1.e1b734p-3f,
+    0x1.f1bdeep-3f, 0x1.00be06p-2f, 0x1.087a08p-2f, 0x1.101432p-2f,
+    0x1.178da6p-2f, 0x1.1ee778p-2f, 0x1.2622bp-2f,  0x1.2d404cp-2f,
+};
+
+// Generated by Sollya with the following commands:
+//   > display = hexadecimal;
+//   > for i from 0 to 31 do print(round(1 / (1 + i * 2^-5), SG, RN));
+constexpr cpp::array<float, 32> ONE_OVER_F_F = {
+    0x1p+0f,        0x1.f07c2p-1f,  0x1.e1e1e2p-1f, 0x1.d41d42p-1f,
+    0x1.c71c72p-1f, 0x1.bacf92p-1f, 0x1.af286cp-1f, 0x1.a41a42p-1f,
+    0x1.99999ap-1f, 0x1.8f9c18p-1f, 0x1.861862p-1f, 0x1.7d05f4p-1f,
+    0x1.745d18p-1f, 0x1.6c16c2p-1f, 0x1.642c86p-1f, 0x1.5c9882p-1f,
+    0x1.555556p-1f, 0x1.4e5e0ap-1f, 0x1.47ae14p-1f, 0x1.414142p-1f,
+    0x1.3b13b2p-1f, 0x1.3521dp-1f,  0x1.2f684cp-1f, 0x1.29e412p-1f,
+    0x1.24924ap-1f, 0x1.1f7048p-1f, 0x1.1a7b96p-1f, 0x1.15b1e6p-1f,
+    0x1.111112p-1f, 0x1.0c9714p-1f, 0x1.08421p-1f,  0x1.041042p-1f,
+};
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_EXPXF16_H
diff --git a/src/math/generic/f16add.cpp b/src/math/generic/f16add.cpp
new file mode 100644
index 0000000..e9be8a7
--- /dev/null
+++ b/src/math/generic/f16add.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16add function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16add.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16add, (double x, double y)) {
+  return fputil::generic::add<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16addf.cpp b/src/math/generic/f16addf.cpp
new file mode 100644
index 0000000..ee05ff7
--- /dev/null
+++ b/src/math/generic/f16addf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16addf function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16addf.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16addf, (float x, float y)) {
+  return fputil::generic::add<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16addf128.cpp b/src/math/generic/f16addf128.cpp
new file mode 100644
index 0000000..4e9038e
--- /dev/null
+++ b/src/math/generic/f16addf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16addf128 function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16addf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16addf128, (float128 x, float128 y)) {
+  return fputil::generic::add<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16addl.cpp b/src/math/generic/f16addl.cpp
new file mode 100644
index 0000000..925f084
--- /dev/null
+++ b/src/math/generic/f16addl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16addl function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16addl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16addl, (long double x, long double y)) {
+  return fputil::generic::add<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16div.cpp b/src/math/generic/f16div.cpp
new file mode 100644
index 0000000..7df94a8
--- /dev/null
+++ b/src/math/generic/f16div.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16div function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16div.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16div, (double x, double y)) {
+  return fputil::generic::div<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16divf.cpp b/src/math/generic/f16divf.cpp
new file mode 100644
index 0000000..3e6289e
--- /dev/null
+++ b/src/math/generic/f16divf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16divf function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16divf.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16divf, (float x, float y)) {
+  return fputil::generic::div<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16divf128.cpp b/src/math/generic/f16divf128.cpp
new file mode 100644
index 0000000..8980ebe
--- /dev/null
+++ b/src/math/generic/f16divf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16divf128 function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16divf128.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16divf128, (float128 x, float128 y)) {
+  return fputil::generic::div<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16divl.cpp b/src/math/generic/f16divl.cpp
new file mode 100644
index 0000000..2a0b200
--- /dev/null
+++ b/src/math/generic/f16divl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16divl function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16divl.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16divl, (long double x, long double y)) {
+  return fputil::generic::div<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16fma.cpp b/src/math/generic/f16fma.cpp
new file mode 100644
index 0000000..70314b5
--- /dev/null
+++ b/src/math/generic/f16fma.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16fma function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16fma.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16fma, (double x, double y, double z)) {
+  return fputil::fma<float16>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16fmaf.cpp b/src/math/generic/f16fmaf.cpp
index 09f2712..bd0b56b 100644
--- a/src/math/generic/f16fmaf.cpp
+++ b/src/math/generic/f16fmaf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/f16fmaf.h"
 #include "src/__support/FPUtil/FMA.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, f16fmaf, (float x, float y, float z)) {
   return fputil::fma<float16>(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16fmaf128.cpp b/src/math/generic/f16fmaf128.cpp
new file mode 100644
index 0000000..5c4823c
--- /dev/null
+++ b/src/math/generic/f16fmaf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16fmaf128 function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16fmaf128.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16fmaf128, (float128 x, float128 y, float128 z)) {
+  return fputil::fma<float16>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16fmal.cpp b/src/math/generic/f16fmal.cpp
new file mode 100644
index 0000000..4f2bf92
--- /dev/null
+++ b/src/math/generic/f16fmal.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of f16fmal function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16fmal.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16fmal,
+                   (long double x, long double y, long double z)) {
+  return fputil::fma<float16>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16mul.cpp b/src/math/generic/f16mul.cpp
new file mode 100644
index 0000000..f7a5225
--- /dev/null
+++ b/src/math/generic/f16mul.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16mul function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16mul.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16mul, (double x, double y)) {
+  return fputil::generic::mul<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16mulf.cpp b/src/math/generic/f16mulf.cpp
new file mode 100644
index 0000000..2c04664
--- /dev/null
+++ b/src/math/generic/f16mulf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16mulf function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16mulf.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16mulf, (float x, float y)) {
+  return fputil::generic::mul<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16mulf128.cpp b/src/math/generic/f16mulf128.cpp
new file mode 100644
index 0000000..7e2d6a0
--- /dev/null
+++ b/src/math/generic/f16mulf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16mulf128 function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16mulf128.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16mulf128, (float128 x, float128 y)) {
+  return fputil::generic::mul<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16mull.cpp b/src/math/generic/f16mull.cpp
new file mode 100644
index 0000000..fc66fba
--- /dev/null
+++ b/src/math/generic/f16mull.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16mull function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16mull.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16mull, (long double x, long double y)) {
+  return fputil::generic::mul<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/aarch64/floor.cpp b/src/math/generic/f16sqrt.cpp
similarity index 51%
rename from src/math/aarch64/floor.cpp
rename to src/math/generic/f16sqrt.cpp
index 0e3d13a..4addb55 100644
--- a/src/math/aarch64/floor.cpp
+++ b/src/math/generic/f16sqrt.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the floor function for aarch64 ------------------===//
+//===-- Implementation of f16sqrt function --------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,15 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/floor.h"
+#include "src/math/f16sqrt.h"
+#include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, floor, (double x)) {
-  double y;
-  __asm__ __volatile__("frintm %d0, %d1\n\t" : "=w"(y) : "w"(x));
-  return y;
+LLVM_LIBC_FUNCTION(float16, f16sqrt, (double x)) {
+  return fputil::sqrt<float16>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16sqrtf.cpp b/src/math/generic/f16sqrtf.cpp
index 1f7ee2d..be43a77 100644
--- a/src/math/generic/f16sqrtf.cpp
+++ b/src/math/generic/f16sqrtf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/f16sqrtf.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, f16sqrtf, (float x)) {
   return fputil::sqrt<float16>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16sqrtf128.cpp b/src/math/generic/f16sqrtf128.cpp
new file mode 100644
index 0000000..d33d6d2
--- /dev/null
+++ b/src/math/generic/f16sqrtf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16sqrtf128 function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16sqrtf128.h"
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16sqrtf128, (float128 x)) {
+  return fputil::sqrt<float16>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16sqrtl.cpp b/src/math/generic/f16sqrtl.cpp
new file mode 100644
index 0000000..c6ce73d
--- /dev/null
+++ b/src/math/generic/f16sqrtl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16sqrtl function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16sqrtl.h"
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16sqrtl, (long double x)) {
+  return fputil::sqrt<float16>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16sub.cpp b/src/math/generic/f16sub.cpp
new file mode 100644
index 0000000..88962b8
--- /dev/null
+++ b/src/math/generic/f16sub.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16sub function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16sub.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16sub, (double x, double y)) {
+  return fputil::generic::sub<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16subf.cpp b/src/math/generic/f16subf.cpp
new file mode 100644
index 0000000..adc0ca4
--- /dev/null
+++ b/src/math/generic/f16subf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16subf function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16subf.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16subf, (float x, float y)) {
+  return fputil::generic::sub<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16subf128.cpp b/src/math/generic/f16subf128.cpp
new file mode 100644
index 0000000..c3e0ba5
--- /dev/null
+++ b/src/math/generic/f16subf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16subf128 function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16subf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16subf128, (float128 x, float128 y)) {
+  return fputil::generic::sub<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/f16subl.cpp b/src/math/generic/f16subl.cpp
new file mode 100644
index 0000000..0ade790
--- /dev/null
+++ b/src/math/generic/f16subl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of f16subl function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/f16subl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, f16subl, (long double x, long double y)) {
+  return fputil::generic::sub<float16>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fabs.cpp b/src/math/generic/fabs.cpp
index 0c0b774..55fa958 100644
--- a/src/math/generic/fabs.cpp
+++ b/src/math/generic/fabs.cpp
@@ -9,9 +9,16 @@
 #include "src/math/fabs.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, fabs, (double x)) { return fputil::abs(x); }
+LLVM_LIBC_FUNCTION(double, fabs, (double x)) {
+#ifdef __LIBC_MISC_MATH_BASIC_OPS_OPT
+  return __builtin_fabs(x);
+#else
+  return fputil::abs(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fabsf.cpp b/src/math/generic/fabsf.cpp
index a57f6bf..2ba18d0 100644
--- a/src/math/generic/fabsf.cpp
+++ b/src/math/generic/fabsf.cpp
@@ -9,9 +9,16 @@
 #include "src/math/fabsf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, fabsf, (float x)) { return fputil::abs(x); }
+LLVM_LIBC_FUNCTION(float, fabsf, (float x)) {
+#ifdef __LIBC_MISC_MATH_BASIC_OPS_OPT
+  return __builtin_fabsf(x);
+#else
+  return fputil::abs(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fabsf128.cpp b/src/math/generic/fabsf128.cpp
index 615b13f..795d907 100644
--- a/src/math/generic/fabsf128.cpp
+++ b/src/math/generic/fabsf128.cpp
@@ -9,9 +9,10 @@
 #include "src/math/fabsf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fabsf128, (float128 x)) { return fputil::abs(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fabsf16.cpp b/src/math/generic/fabsf16.cpp
index 4de84f3..02e1133 100644
--- a/src/math/generic/fabsf16.cpp
+++ b/src/math/generic/fabsf16.cpp
@@ -9,9 +9,21 @@
 #include "src/math/fabsf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/architectures.h"
+#include "src/__support/macros/properties/compiler.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float16, fabsf16, (float16 x)) { return fputil::abs(x); }
+LLVM_LIBC_FUNCTION(float16, fabsf16, (float16 x)) {
+  // For x86, GCC generates better code from the generic implementation.
+  // https://godbolt.org/z/K9orM4hTa
+#if defined(__LIBC_MISC_MATH_BASIC_OPS_OPT) &&                                 \
+    !(defined(LIBC_TARGET_ARCH_IS_X86) && defined(LIBC_COMPILER_IS_GCC))
+  return __builtin_fabsf16(x);
+#else
+  return fputil::abs(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fabsl.cpp b/src/math/generic/fabsl.cpp
index 6b912c9..ea86054 100644
--- a/src/math/generic/fabsl.cpp
+++ b/src/math/generic/fabsl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fabsl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fabsl, (long double x)) {
   return fputil::abs(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fadd.cpp b/src/math/generic/fadd.cpp
new file mode 100644
index 0000000..60460f8
--- /dev/null
+++ b/src/math/generic/fadd.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fadd function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fadd.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fadd, (double x, double y)) {
+  return fputil::generic::add<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/faddf128.cpp b/src/math/generic/faddf128.cpp
new file mode 100644
index 0000000..953b1a1
--- /dev/null
+++ b/src/math/generic/faddf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of faddf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/faddf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, faddf128, (float128 x, float128 y)) {
+  return fputil::generic::add<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/faddl.cpp b/src/math/generic/faddl.cpp
new file mode 100644
index 0000000..b5c6ab4
--- /dev/null
+++ b/src/math/generic/faddl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of faddl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/faddl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, faddl, (long double x, long double y)) {
+  return fputil::generic::add<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdim.cpp b/src/math/generic/fdim.cpp
index 22d9986..9ea121f 100644
--- a/src/math/generic/fdim.cpp
+++ b/src/math/generic/fdim.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fdim.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fdim, (double x, double y)) {
   return fputil::fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdimf.cpp b/src/math/generic/fdimf.cpp
index 789a0c5..2c6bf7a 100644
--- a/src/math/generic/fdimf.cpp
+++ b/src/math/generic/fdimf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fdimf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fdimf, (float x, float y)) {
   return fputil::fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdimf128.cpp b/src/math/generic/fdimf128.cpp
index a3ea9e5..f8b1499 100644
--- a/src/math/generic/fdimf128.cpp
+++ b/src/math/generic/fdimf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fdimf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fdimf128, (float128 x, float128 y)) {
   return fputil::fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdimf16.cpp b/src/math/generic/fdimf16.cpp
index 25e1d88..6eac460 100644
--- a/src/math/generic/fdimf16.cpp
+++ b/src/math/generic/fdimf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fdimf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fdimf16, (float16 x, float16 y)) {
   return fputil::fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdiml.cpp b/src/math/generic/fdiml.cpp
index c1091cc..ebac58e 100644
--- a/src/math/generic/fdiml.cpp
+++ b/src/math/generic/fdiml.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fdiml.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fdiml, (long double x, long double y)) {
   return fputil::fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdiv.cpp b/src/math/generic/fdiv.cpp
new file mode 100644
index 0000000..1d97fad
--- /dev/null
+++ b/src/math/generic/fdiv.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fdiv function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fdiv.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fdiv, (double x, double y)) {
+  return fputil::generic::div<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdivf128.cpp b/src/math/generic/fdivf128.cpp
new file mode 100644
index 0000000..192f13f
--- /dev/null
+++ b/src/math/generic/fdivf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fdivf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fdivf128.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fdivf128, (float128 x, float128 y)) {
+  return fputil::generic::div<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fdivl.cpp b/src/math/generic/fdivl.cpp
new file mode 100644
index 0000000..dcd5deb
--- /dev/null
+++ b/src/math/generic/fdivl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fdivl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fdivl.h"
+#include "src/__support/FPUtil/generic/div.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fdivl, (long double x, long double y)) {
+  return fputil::generic::div<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ffma.cpp b/src/math/generic/ffma.cpp
new file mode 100644
index 0000000..a4c834d
--- /dev/null
+++ b/src/math/generic/ffma.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ffma function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/ffma.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, ffma, (double x, double y, double z)) {
+  return fputil::fma<float>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ffmaf128.cpp b/src/math/generic/ffmaf128.cpp
new file mode 100644
index 0000000..55da930
--- /dev/null
+++ b/src/math/generic/ffmaf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ffmaf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/ffmaf128.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, ffmaf128, (float128 x, float128 y, float128 z)) {
+  return fputil::fma<float>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ffmal.cpp b/src/math/generic/ffmal.cpp
new file mode 100644
index 0000000..d5cd4f7
--- /dev/null
+++ b/src/math/generic/ffmal.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of ffmal function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/ffmal.h"
+#include "src/__support/FPUtil/FMA.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, ffmal,
+                   (long double x, long double y, long double z)) {
+  return fputil::fma<float>(x, y, z);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/floor.cpp b/src/math/generic/floor.cpp
index 60386f0..86aed6c 100644
--- a/src/math/generic/floor.cpp
+++ b/src/math/generic/floor.cpp
@@ -9,9 +9,16 @@
 #include "src/math/floor.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, floor, (double x)) { return fputil::floor(x); }
+LLVM_LIBC_FUNCTION(double, floor, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_floor(x);
+#else
+  return fputil::floor(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/floorf.cpp b/src/math/generic/floorf.cpp
index 8566668..22739ef 100644
--- a/src/math/generic/floorf.cpp
+++ b/src/math/generic/floorf.cpp
@@ -9,9 +9,16 @@
 #include "src/math/floorf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, floorf, (float x)) { return fputil::floor(x); }
+LLVM_LIBC_FUNCTION(float, floorf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_floorf(x);
+#else
+  return fputil::floor(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/floorf128.cpp b/src/math/generic/floorf128.cpp
index 22a8eac..f3ad20a 100644
--- a/src/math/generic/floorf128.cpp
+++ b/src/math/generic/floorf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/floorf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, floorf128, (float128 x)) {
   return fputil::floor(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/floorf16.cpp b/src/math/generic/floorf16.cpp
index db0b326..361b227 100644
--- a/src/math/generic/floorf16.cpp
+++ b/src/math/generic/floorf16.cpp
@@ -8,10 +8,20 @@
 
 #include "src/math/floorf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float16, floorf16, (float16 x)) { return fputil::floor(x); }
+LLVM_LIBC_FUNCTION(float16, floorf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC) &&                       \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_floorf(x));
+#else
+  return fputil::floor(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/floorl.cpp b/src/math/generic/floorl.cpp
index 2803127..74fbb68 100644
--- a/src/math/generic/floorl.cpp
+++ b/src/math/generic/floorl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/floorl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, floorl, (long double x)) {
   return fputil::floor(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fma.cpp b/src/math/generic/fma.cpp
index 7937766..2ea4ae9 100644
--- a/src/math/generic/fma.cpp
+++ b/src/math/generic/fma.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "src/__support/FPUtil/FMA.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fma, (double x, double y, double z)) {
   return fputil::fma<double>(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaf.cpp b/src/math/generic/fmaf.cpp
index d367a06..dad85b4 100644
--- a/src/math/generic/fmaf.cpp
+++ b/src/math/generic/fmaf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "src/__support/FPUtil/FMA.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaf, (float x, float y, float z)) {
   return fputil::fma<float>(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmax.cpp b/src/math/generic/fmax.cpp
index 7feeee9..b9ac4a0 100644
--- a/src/math/generic/fmax.cpp
+++ b/src/math/generic/fmax.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmax.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmax, (double x, double y)) {
   return fputil::fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaxf.cpp b/src/math/generic/fmaxf.cpp
index 3241092..1c422de 100644
--- a/src/math/generic/fmaxf.cpp
+++ b/src/math/generic/fmaxf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaxf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaxf, (float x, float y)) {
   return fputil::fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaxf128.cpp b/src/math/generic/fmaxf128.cpp
index 096e4be..08a9c8f 100644
--- a/src/math/generic/fmaxf128.cpp
+++ b/src/math/generic/fmaxf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaxf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmaxf128, (float128 x, float128 y)) {
   return fputil::fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaxf16.cpp b/src/math/generic/fmaxf16.cpp
index c317aef..02c2bd8 100644
--- a/src/math/generic/fmaxf16.cpp
+++ b/src/math/generic/fmaxf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaxf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmaxf16, (float16 x, float16 y)) {
   return fputil::fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum.cpp b/src/math/generic/fmaximum.cpp
index ac9593b..1493521 100644
--- a/src/math/generic/fmaximum.cpp
+++ b/src/math/generic/fmaximum.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmaximum, (double x, double y)) {
   return fputil::fmaximum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag.cpp b/src/math/generic/fmaximum_mag.cpp
index 0deb0c2..a0152bf 100644
--- a/src/math/generic/fmaximum_mag.cpp
+++ b/src/math/generic/fmaximum_mag.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_mag.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmaximum_mag, (double x, double y)) {
   return fputil::fmaximum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag_num.cpp b/src/math/generic/fmaximum_mag_num.cpp
index d0b1096..de250bb 100644
--- a/src/math/generic/fmaximum_mag_num.cpp
+++ b/src/math/generic/fmaximum_mag_num.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_mag_num.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmaximum_mag_num, (double x, double y)) {
   return fputil::fmaximum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag_numf.cpp b/src/math/generic/fmaximum_mag_numf.cpp
index 672d3fd..e372f1b 100644
--- a/src/math/generic/fmaximum_mag_numf.cpp
+++ b/src/math/generic/fmaximum_mag_numf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_mag_numf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaximum_mag_numf, (float x, float y)) {
   return fputil::fmaximum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag_numf128.cpp b/src/math/generic/fmaximum_mag_numf128.cpp
index e7d13f1..09e7248 100644
--- a/src/math/generic/fmaximum_mag_numf128.cpp
+++ b/src/math/generic/fmaximum_mag_numf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_mag_numf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmaximum_mag_numf128, (float128 x, float128 y)) {
   return fputil::fmaximum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag_numf16.cpp b/src/math/generic/fmaximum_mag_numf16.cpp
index 5055802..d81b9fe 100644
--- a/src/math/generic/fmaximum_mag_numf16.cpp
+++ b/src/math/generic/fmaximum_mag_numf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_mag_numf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmaximum_mag_numf16, (float16 x, float16 y)) {
   return fputil::fmaximum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_mag_numl.cpp b/src/math/generic/fmaximum_mag_numl.cpp
index a8499ca..3816bdd 100644
--- a/src/math/generic/fmaximum_mag_numl.cpp
+++ b/src/math/generic/fmaximum_mag_numl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fmaximum_mag_numl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmaximum_mag_numl,
                    (long double x, long double y)) {
   return fputil::fmaximum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_magf.cpp b/src/math/generic/fmaximum_magf.cpp
index 380aca0..41099a1 100644
--- a/src/math/generic/fmaximum_magf.cpp
+++ b/src/math/generic/fmaximum_magf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_magf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaximum_magf, (float x, float y)) {
   return fputil::fmaximum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_magf128.cpp b/src/math/generic/fmaximum_magf128.cpp
index 301938f..671d0fb 100644
--- a/src/math/generic/fmaximum_magf128.cpp
+++ b/src/math/generic/fmaximum_magf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_magf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmaximum_magf128, (float128 x, float128 y)) {
   return fputil::fmaximum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_magf16.cpp b/src/math/generic/fmaximum_magf16.cpp
index fbd5eac..79e75ab 100644
--- a/src/math/generic/fmaximum_magf16.cpp
+++ b/src/math/generic/fmaximum_magf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_magf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmaximum_magf16, (float16 x, float16 y)) {
   return fputil::fmaximum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_magl.cpp b/src/math/generic/fmaximum_magl.cpp
index 283a11e..1230076 100644
--- a/src/math/generic/fmaximum_magl.cpp
+++ b/src/math/generic/fmaximum_magl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_magl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmaximum_magl, (long double x, long double y)) {
   return fputil::fmaximum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_num.cpp b/src/math/generic/fmaximum_num.cpp
index 23553db..33df7da 100644
--- a/src/math/generic/fmaximum_num.cpp
+++ b/src/math/generic/fmaximum_num.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_num.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmaximum_num, (double x, double y)) {
   return fputil::fmaximum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_numf.cpp b/src/math/generic/fmaximum_numf.cpp
index f946ff4..1577080 100644
--- a/src/math/generic/fmaximum_numf.cpp
+++ b/src/math/generic/fmaximum_numf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_numf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaximum_numf, (float x, float y)) {
   return fputil::fmaximum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_numf128.cpp b/src/math/generic/fmaximum_numf128.cpp
index f33a5e1..5cfaca5 100644
--- a/src/math/generic/fmaximum_numf128.cpp
+++ b/src/math/generic/fmaximum_numf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_numf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmaximum_numf128, (float128 x, float128 y)) {
   return fputil::fmaximum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_numf16.cpp b/src/math/generic/fmaximum_numf16.cpp
index 187cfbe..394ce8b 100644
--- a/src/math/generic/fmaximum_numf16.cpp
+++ b/src/math/generic/fmaximum_numf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_numf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmaximum_numf16, (float16 x, float16 y)) {
   return fputil::fmaximum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximum_numl.cpp b/src/math/generic/fmaximum_numl.cpp
index 503fc41..eecebf6 100644
--- a/src/math/generic/fmaximum_numl.cpp
+++ b/src/math/generic/fmaximum_numl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximum_numl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmaximum_numl, (long double x, long double y)) {
   return fputil::fmaximum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximumf.cpp b/src/math/generic/fmaximumf.cpp
index 3b2a609..faa00a6 100644
--- a/src/math/generic/fmaximumf.cpp
+++ b/src/math/generic/fmaximumf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximumf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaximumf, (float x, float y)) {
   return fputil::fmaximum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximumf128.cpp b/src/math/generic/fmaximumf128.cpp
index 0099c91..362b583 100644
--- a/src/math/generic/fmaximumf128.cpp
+++ b/src/math/generic/fmaximumf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximumf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmaximumf128, (float128 x, float128 y)) {
   return fputil::fmaximum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximumf16.cpp b/src/math/generic/fmaximumf16.cpp
index 9e194d2..aa4982d 100644
--- a/src/math/generic/fmaximumf16.cpp
+++ b/src/math/generic/fmaximumf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximumf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmaximumf16, (float16 x, float16 y)) {
   return fputil::fmaximum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaximuml.cpp b/src/math/generic/fmaximuml.cpp
index ecd6983..65e3b69 100644
--- a/src/math/generic/fmaximuml.cpp
+++ b/src/math/generic/fmaximuml.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaximuml.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmaximuml, (long double x, long double y)) {
   return fputil::fmaximum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmaxl.cpp b/src/math/generic/fmaxl.cpp
index 6c62507..a5460f5 100644
--- a/src/math/generic/fmaxl.cpp
+++ b/src/math/generic/fmaxl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmaxl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmaxl, (long double x, long double y)) {
   return fputil::fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmin.cpp b/src/math/generic/fmin.cpp
index b9f313d..2351874 100644
--- a/src/math/generic/fmin.cpp
+++ b/src/math/generic/fmin.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmin.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmin, (double x, double y)) {
   return fputil::fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminf.cpp b/src/math/generic/fminf.cpp
index 539fedb..83dd0aa 100644
--- a/src/math/generic/fminf.cpp
+++ b/src/math/generic/fminf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminf, (float x, float y)) {
   return fputil::fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminf128.cpp b/src/math/generic/fminf128.cpp
index 084ed4c..184b7e3 100644
--- a/src/math/generic/fminf128.cpp
+++ b/src/math/generic/fminf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fminf128, (float128 x, float128 y)) {
   return fputil::fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminf16.cpp b/src/math/generic/fminf16.cpp
index 12547c3..8b69273 100644
--- a/src/math/generic/fminf16.cpp
+++ b/src/math/generic/fminf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fminf16, (float16 x, float16 y)) {
   return fputil::fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum.cpp b/src/math/generic/fminimum.cpp
index 28b257d..2f14e64 100644
--- a/src/math/generic/fminimum.cpp
+++ b/src/math/generic/fminimum.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fminimum, (double x, double y)) {
   return fputil::fminimum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag.cpp b/src/math/generic/fminimum_mag.cpp
index 6af9957..8d8001d 100644
--- a/src/math/generic/fminimum_mag.cpp
+++ b/src/math/generic/fminimum_mag.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_mag.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fminimum_mag, (double x, double y)) {
   return fputil::fminimum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag_num.cpp b/src/math/generic/fminimum_mag_num.cpp
index fc5431a..ab049b5 100644
--- a/src/math/generic/fminimum_mag_num.cpp
+++ b/src/math/generic/fminimum_mag_num.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_mag_num.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fminimum_mag_num, (double x, double y)) {
   return fputil::fminimum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag_numf.cpp b/src/math/generic/fminimum_mag_numf.cpp
index 71179a6..2aa88c7 100644
--- a/src/math/generic/fminimum_mag_numf.cpp
+++ b/src/math/generic/fminimum_mag_numf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_mag_numf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminimum_mag_numf, (float x, float y)) {
   return fputil::fminimum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag_numf128.cpp b/src/math/generic/fminimum_mag_numf128.cpp
index 109ce7e..ec7ab54 100644
--- a/src/math/generic/fminimum_mag_numf128.cpp
+++ b/src/math/generic/fminimum_mag_numf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_mag_numf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fminimum_mag_numf128, (float128 x, float128 y)) {
   return fputil::fminimum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag_numf16.cpp b/src/math/generic/fminimum_mag_numf16.cpp
index 1a893c6..5805514 100644
--- a/src/math/generic/fminimum_mag_numf16.cpp
+++ b/src/math/generic/fminimum_mag_numf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_mag_numf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fminimum_mag_numf16, (float16 x, float16 y)) {
   return fputil::fminimum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_mag_numl.cpp b/src/math/generic/fminimum_mag_numl.cpp
index c97ce6e..70fea1f 100644
--- a/src/math/generic/fminimum_mag_numl.cpp
+++ b/src/math/generic/fminimum_mag_numl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fminimum_mag_numl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fminimum_mag_numl,
                    (long double x, long double y)) {
   return fputil::fminimum_mag_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_magf.cpp b/src/math/generic/fminimum_magf.cpp
index 834f6a4..fcc2e05 100644
--- a/src/math/generic/fminimum_magf.cpp
+++ b/src/math/generic/fminimum_magf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_magf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminimum_magf, (float x, float y)) {
   return fputil::fminimum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_magf128.cpp b/src/math/generic/fminimum_magf128.cpp
index 2828e28..3e7e01f 100644
--- a/src/math/generic/fminimum_magf128.cpp
+++ b/src/math/generic/fminimum_magf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_magf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fminimum_magf128, (float128 x, float128 y)) {
   return fputil::fminimum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_magf16.cpp b/src/math/generic/fminimum_magf16.cpp
index 45183a9..4417f75 100644
--- a/src/math/generic/fminimum_magf16.cpp
+++ b/src/math/generic/fminimum_magf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_magf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fminimum_magf16, (float16 x, float16 y)) {
   return fputil::fminimum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_magl.cpp b/src/math/generic/fminimum_magl.cpp
index 50e328f..befc4ac 100644
--- a/src/math/generic/fminimum_magl.cpp
+++ b/src/math/generic/fminimum_magl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_magl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fminimum_magl, (long double x, long double y)) {
   return fputil::fminimum_mag(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_num.cpp b/src/math/generic/fminimum_num.cpp
index e89c7f5..3ff79de 100644
--- a/src/math/generic/fminimum_num.cpp
+++ b/src/math/generic/fminimum_num.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_num.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fminimum_num, (double x, double y)) {
   return fputil::fminimum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_numf.cpp b/src/math/generic/fminimum_numf.cpp
index c37c8bd..c7ac99b 100644
--- a/src/math/generic/fminimum_numf.cpp
+++ b/src/math/generic/fminimum_numf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_numf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminimum_numf, (float x, float y)) {
   return fputil::fminimum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_numf128.cpp b/src/math/generic/fminimum_numf128.cpp
index 6b1f77b..6d95712 100644
--- a/src/math/generic/fminimum_numf128.cpp
+++ b/src/math/generic/fminimum_numf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_numf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fminimum_numf128, (float128 x, float128 y)) {
   return fputil::fminimum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_numf16.cpp b/src/math/generic/fminimum_numf16.cpp
index 825ad3e..0af7205 100644
--- a/src/math/generic/fminimum_numf16.cpp
+++ b/src/math/generic/fminimum_numf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_numf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fminimum_numf16, (float16 x, float16 y)) {
   return fputil::fminimum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimum_numl.cpp b/src/math/generic/fminimum_numl.cpp
index 22045f8..8a4cff3 100644
--- a/src/math/generic/fminimum_numl.cpp
+++ b/src/math/generic/fminimum_numl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimum_numl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fminimum_numl, (long double x, long double y)) {
   return fputil::fminimum_num(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimumf.cpp b/src/math/generic/fminimumf.cpp
index c937fb0..57e33c1 100644
--- a/src/math/generic/fminimumf.cpp
+++ b/src/math/generic/fminimumf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimumf.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminimumf, (float x, float y)) {
   return fputil::fminimum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimumf128.cpp b/src/math/generic/fminimumf128.cpp
index 24e02b8..3dbd18d 100644
--- a/src/math/generic/fminimumf128.cpp
+++ b/src/math/generic/fminimumf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimumf128.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fminimumf128, (float128 x, float128 y)) {
   return fputil::fminimum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimumf16.cpp b/src/math/generic/fminimumf16.cpp
index 16f738b..42ad9a5 100644
--- a/src/math/generic/fminimumf16.cpp
+++ b/src/math/generic/fminimumf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimumf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fminimumf16, (float16 x, float16 y)) {
   return fputil::fminimum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminimuml.cpp b/src/math/generic/fminimuml.cpp
index 4331950..c80cb0a 100644
--- a/src/math/generic/fminimuml.cpp
+++ b/src/math/generic/fminimuml.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminimuml.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fminimuml, (long double x, long double y)) {
   return fputil::fminimum(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fminl.cpp b/src/math/generic/fminl.cpp
index 147f6c5..aa15de7 100644
--- a/src/math/generic/fminl.cpp
+++ b/src/math/generic/fminl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminl.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fminl, (long double x, long double y)) {
   return fputil::fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmod.cpp b/src/math/generic/fmod.cpp
index 69e0c8d..010e66a 100644
--- a/src/math/generic/fmod.cpp
+++ b/src/math/generic/fmod.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmod.h"
 #include "src/__support/FPUtil/generic/FMod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmod, (double x, double y)) {
   return fputil::generic::FMod<double>::eval(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmodf.cpp b/src/math/generic/fmodf.cpp
index 9a9e46e..1e1ef48 100644
--- a/src/math/generic/fmodf.cpp
+++ b/src/math/generic/fmodf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmodf.h"
 #include "src/__support/FPUtil/generic/FMod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmodf, (float x, float y)) {
   return fputil::generic::FMod<float, uint64_t>::eval(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmodf128.cpp b/src/math/generic/fmodf128.cpp
index 08a3797..a7633bf 100644
--- a/src/math/generic/fmodf128.cpp
+++ b/src/math/generic/fmodf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmodf128.h"
 #include "src/__support/FPUtil/generic/FMod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fmodf128, (float128 x, float128 y)) {
   return fputil::generic::FMod<float128>::eval(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmodf16.cpp b/src/math/generic/fmodf16.cpp
index a5bfd78..2585639 100644
--- a/src/math/generic/fmodf16.cpp
+++ b/src/math/generic/fmodf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmodf16.h"
 #include "src/__support/FPUtil/generic/FMod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fmodf16, (float16 x, float16 y)) {
   return fputil::generic::FMod<float16, uint32_t>::eval(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmodl.cpp b/src/math/generic/fmodl.cpp
index 23a3702..1af8ffc 100644
--- a/src/math/generic/fmodl.cpp
+++ b/src/math/generic/fmodl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmodl.h"
 #include "src/__support/FPUtil/generic/FMod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fmodl, (long double x, long double y)) {
   return fputil::generic::FMod<long double>::eval(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmul.cpp b/src/math/generic/fmul.cpp
index 40af204..e759e48 100644
--- a/src/math/generic/fmul.cpp
+++ b/src/math/generic/fmul.cpp
@@ -1,128 +1,119 @@
-//===-- Implementation of fmul function------------------------------------===//
+//===-- Implementation of fmul function -----------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
-
 #include "src/math/fmul.h"
-#include "src/__support/CPP/bit.h"
-#include "src/__support/FPUtil/BasicOperations.h"
-#include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/FPUtil/rounding_mode.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/generic/mul.h"
 #include "src/__support/common.h"
-#include "src/__support/uint128.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmul, (double x, double y)) {
-  auto x_bits = fputil::FPBits<double>(x);
-
-  auto y_bits = fputil::FPBits<double>(y);
-
-  auto output_sign = (x_bits.sign() != y_bits.sign()) ? Sign::NEG : Sign::POS;
-
-  if (LIBC_UNLIKELY(x_bits.is_inf_or_nan() || y_bits.is_inf_or_nan() ||
-                    x_bits.is_zero() || y_bits.is_zero())) {
-    if (x_bits.is_nan())
-      return static_cast<float>(x);
-    if (y_bits.is_nan())
-      return static_cast<float>(y);
-    if (x_bits.is_inf())
-      return y_bits.is_zero()
-                 ? fputil::FPBits<float>::quiet_nan().get_val()
-                 : fputil::FPBits<float>::inf(output_sign).get_val();
-    if (y_bits.is_inf())
-      return x_bits.is_zero()
-                 ? fputil::FPBits<float>::quiet_nan().get_val()
-                 : fputil::FPBits<float>::inf(output_sign).get_val();
-    // Now either x or y is zero, and the other one is finite.
-    return fputil::FPBits<float>::zero(output_sign).get_val();
+
+  // Without FMA instructions, fputil::exact_mult is not
+  // correctly rounded for all rounding modes, so we fall
+  // back to the generic `fmul` implementation
+
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+  return fputil::generic::mul<float>(x, y);
+#else
+  fputil::DoubleDouble prod = fputil::exact_mult(x, y);
+  using DoubleBits = fputil::FPBits<double>;
+  using DoubleStorageType = typename DoubleBits::StorageType;
+  using FloatBits = fputil::FPBits<float>;
+  using FloatStorageType = typename FloatBits::StorageType;
+  DoubleBits x_bits(x);
+  DoubleBits y_bits(y);
+
+  Sign result_sign = x_bits.sign() == y_bits.sign() ? Sign::POS : Sign::NEG;
+  double result = prod.hi;
+  DoubleBits hi_bits(prod.hi), lo_bits(prod.lo);
+  // Check for cases where we need to propagate the sticky bits:
+  constexpr uint64_t STICKY_MASK = 0xFFF'FFF; // Lower (52 - 23 - 1 = 28 bits)
+  uint64_t sticky_bits = (hi_bits.uintval() & STICKY_MASK);
+  if (LIBC_UNLIKELY(sticky_bits == 0)) {
+    // Might need to propagate sticky bits:
+    if (!(lo_bits.is_inf_or_nan() || lo_bits.is_zero())) {
+      // Now prod.lo is nonzero and finite, we need to propagate sticky bits.
+      if (lo_bits.sign() != hi_bits.sign())
+        result = DoubleBits(hi_bits.uintval() - 1).get_val();
+      else
+        result = DoubleBits(hi_bits.uintval() | 1).get_val();
+    }
+  }
+
+  float result_f = static_cast<float>(result);
+  FloatBits rf_bits(result_f);
+  uint32_t rf_exp = rf_bits.get_biased_exponent();
+  if (LIBC_LIKELY(rf_exp > 0 && rf_exp < 2 * FloatBits::EXP_BIAS + 1)) {
+    return result_f;
   }
 
-  uint64_t mx, my;
-
-  // Get mantissa and append the hidden bit if needed.
-  mx = x_bits.get_explicit_mantissa();
-  my = y_bits.get_explicit_mantissa();
-
-  // Get the corresponding biased exponent.
-  int ex = x_bits.get_explicit_exponent();
-  int ey = y_bits.get_explicit_exponent();
-
-  // Count the number of leading zeros of the explicit mantissas.
-  int nx = cpp::countl_zero(mx);
-  int ny = cpp::countl_zero(my);
-  // Shift the leading 1 bit to the most significant bit.
-  mx <<= nx;
-  my <<= ny;
-
-  // Adjust exponent accordingly: If x or y are normal, we will only need to
-  // shift by (exponent length + sign bit = 11 bits. If x or y are denormal, we
-  // will need to shift more than 11 bits.
-  ex -= (nx - 11);
-  ey -= (ny - 11);
-
-  UInt128 product = static_cast<UInt128>(mx) * static_cast<UInt128>(my);
-  int32_t dm1;
-  uint64_t highs, lows;
-  uint64_t g, hight, lowt;
-  uint32_t m;
-  uint32_t b;
-  int c;
-
-  highs = static_cast<uint64_t>(product >> 64);
-  c = static_cast<int>(highs >= 0x8000000000000000);
-  lows = static_cast<uint64_t>(product);
-
-  lowt = (lows != 0);
-
-  dm1 = ex + ey + c + fputil::FPBits<float>::EXP_BIAS;
-
-  int round_mode = fputil::quick_get_round();
-  if (dm1 >= 255) {
-    if ((round_mode == FE_TOWARDZERO) ||
-        (round_mode == FE_UPWARD && output_sign.is_neg()) ||
-        (round_mode == FE_DOWNWARD && output_sign.is_pos())) {
-      return fputil::FPBits<float>::max_normal(output_sign).get_val();
+  // Now result_f is either inf/nan/zero/denormal.
+  if (x_bits.is_nan() || y_bits.is_nan()) {
+    if (x_bits.is_signaling_nan() || y_bits.is_signaling_nan())
+      fputil::raise_except_if_required(FE_INVALID);
+
+    if (x_bits.is_quiet_nan()) {
+      DoubleStorageType x_payload = x_bits.get_mantissa();
+      x_payload >>= DoubleBits::FRACTION_LEN - FloatBits::FRACTION_LEN;
+      return FloatBits::quiet_nan(x_bits.sign(),
+                                  static_cast<FloatStorageType>(x_payload))
+          .get_val();
     }
-    return fputil::FPBits<float>::inf().get_val();
-  } else if (dm1 <= 0) {
-
-    int m_shift = 40 + c - dm1;
-    int g_shift = m_shift - 1;
-    int h_shift = 64 - g_shift;
-    m = (m_shift >= 64) ? 0 : static_cast<uint32_t>(highs >> m_shift);
-
-    g = g_shift >= 64 ? 0 : (highs >> g_shift) & 1;
-    hight = h_shift >= 64 ? highs : (highs << h_shift) != 0;
-
-    dm1 = 0;
-  } else {
-    m = static_cast<uint32_t>(highs >> (39 + c));
-    g = (highs >> (38 + c)) & 1;
-    hight = (highs << (26 - c)) != 0;
+
+    if (y_bits.is_quiet_nan()) {
+      DoubleStorageType y_payload = y_bits.get_mantissa();
+      y_payload >>= DoubleBits::FRACTION_LEN - FloatBits::FRACTION_LEN;
+      return FloatBits::quiet_nan(y_bits.sign(),
+                                  static_cast<FloatStorageType>(y_payload))
+          .get_val();
+    }
+
+    return FloatBits::quiet_nan().get_val();
   }
 
-  if (round_mode == FE_TONEAREST) {
-    b = g && ((hight && lowt) || ((m & 1) != 0));
-  } else if ((output_sign.is_neg() && round_mode == FE_DOWNWARD) ||
-             (output_sign.is_pos() && round_mode == FE_UPWARD)) {
-    b = (g == 0 && (hight && lowt) == 0) ? 0 : 1;
-  } else {
-    b = 0;
+  if (x_bits.is_inf()) {
+    if (y_bits.is_zero()) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+
+      return FloatBits::quiet_nan().get_val();
+    }
+
+    return FloatBits::inf(result_sign).get_val();
+  }
+
+  if (y_bits.is_inf()) {
+    if (x_bits.is_zero()) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+      return FloatBits::quiet_nan().get_val();
+    }
+
+    return FloatBits::inf(result_sign).get_val();
   }
 
-  uint32_t exp16 = (dm1 << 23);
+  // Now either x or y is zero, and the other one is finite.
+  if (rf_bits.is_inf()) {
+    fputil::set_errno_if_required(ERANGE);
+    return FloatBits::inf(result_sign).get_val();
+  }
 
-  uint32_t m2 = m & fputil::FPBits<float>::FRACTION_MASK;
+  if (x_bits.is_zero() || y_bits.is_zero())
+    return FloatBits::zero(result_sign).get_val();
 
-  uint32_t result = (exp16 + m2) + b;
+  fputil::set_errno_if_required(ERANGE);
+  fputil::raise_except_if_required(FE_UNDERFLOW);
+  return result_f;
 
-  auto result_bits = fputil::FPBits<float>(result);
-  result_bits.set_sign(output_sign);
-  return result_bits.get_val();
+#endif
 }
-
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmulf128.cpp b/src/math/generic/fmulf128.cpp
new file mode 100644
index 0000000..c0c55ac
--- /dev/null
+++ b/src/math/generic/fmulf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fmulf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fmulf128.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fmulf128, (float128 x, float128 y)) {
+  return fputil::generic::mul<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fmull.cpp b/src/math/generic/fmull.cpp
new file mode 100644
index 0000000..41ab165
--- /dev/null
+++ b/src/math/generic/fmull.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fmull function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fmull.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fmull, (long double x, long double y)) {
+  return fputil::generic::mul<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/frexp.cpp b/src/math/generic/frexp.cpp
index a183ba7..0efc0d4 100644
--- a/src/math/generic/frexp.cpp
+++ b/src/math/generic/frexp.cpp
@@ -9,11 +9,12 @@
 #include "src/math/frexp.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, frexp, (double x, int *exp)) {
   return fputil::frexp(x, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/frexpf.cpp b/src/math/generic/frexpf.cpp
index 4fdc869..09227ba 100644
--- a/src/math/generic/frexpf.cpp
+++ b/src/math/generic/frexpf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/frexpf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, frexpf, (float x, int *exp)) {
   return fputil::frexp(x, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/frexpf128.cpp b/src/math/generic/frexpf128.cpp
index b50f37d..eb816c4 100644
--- a/src/math/generic/frexpf128.cpp
+++ b/src/math/generic/frexpf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/frexpf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, frexpf128, (float128 x, int *exp)) {
   return fputil::frexp(x, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/frexpf16.cpp b/src/math/generic/frexpf16.cpp
index 2d29c07..4571b0d 100644
--- a/src/math/generic/frexpf16.cpp
+++ b/src/math/generic/frexpf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/frexpf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, frexpf16, (float16 x, int *exp)) {
   return fputil::frexp(x, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/frexpl.cpp b/src/math/generic/frexpl.cpp
index 0be4e74..6f2b456 100644
--- a/src/math/generic/frexpl.cpp
+++ b/src/math/generic/frexpl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/frexpl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, frexpl, (long double x, int *exp)) {
   return fputil::frexp(x, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfp.cpp b/src/math/generic/fromfp.cpp
index ba3f0a1..f75e659 100644
--- a/src/math/generic/fromfp.cpp
+++ b/src/math/generic/fromfp.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fromfp.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fromfp, (double x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpf.cpp b/src/math/generic/fromfpf.cpp
index fd058a1..83f0518 100644
--- a/src/math/generic/fromfpf.cpp
+++ b/src/math/generic/fromfpf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fromfpf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fromfpf, (float x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpf128.cpp b/src/math/generic/fromfpf128.cpp
index 440a5da..bcbe86c 100644
--- a/src/math/generic/fromfpf128.cpp
+++ b/src/math/generic/fromfpf128.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fromfpf128,
                    (float128 x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpf16.cpp b/src/math/generic/fromfpf16.cpp
index 3604004..0166e8e 100644
--- a/src/math/generic/fromfpf16.cpp
+++ b/src/math/generic/fromfpf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fromfpf16,
                    (float16 x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpl.cpp b/src/math/generic/fromfpl.cpp
index ee3abea..ab1cbef 100644
--- a/src/math/generic/fromfpl.cpp
+++ b/src/math/generic/fromfpl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fromfpl,
                    (long double x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpx.cpp b/src/math/generic/fromfpx.cpp
index b9e7e4a..cf545df 100644
--- a/src/math/generic/fromfpx.cpp
+++ b/src/math/generic/fromfpx.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fromfpx.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fromfpx, (double x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpxf.cpp b/src/math/generic/fromfpxf.cpp
index 1473499..1af3c98 100644
--- a/src/math/generic/fromfpxf.cpp
+++ b/src/math/generic/fromfpxf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fromfpxf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fromfpxf, (float x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpxf128.cpp b/src/math/generic/fromfpxf128.cpp
index 5d930d2..bb47578 100644
--- a/src/math/generic/fromfpxf128.cpp
+++ b/src/math/generic/fromfpxf128.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpxf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, fromfpxf128,
                    (float128 x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpxf16.cpp b/src/math/generic/fromfpxf16.cpp
index 0854cb6..64a3b86 100644
--- a/src/math/generic/fromfpxf16.cpp
+++ b/src/math/generic/fromfpxf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpxf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, fromfpxf16,
                    (float16 x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fromfpxl.cpp b/src/math/generic/fromfpxl.cpp
index c3db055..b402aa1 100644
--- a/src/math/generic/fromfpxl.cpp
+++ b/src/math/generic/fromfpxl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/fromfpxl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, fromfpxl,
                    (long double x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/true>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsqrt.cpp b/src/math/generic/fsqrt.cpp
new file mode 100644
index 0000000..d54471f
--- /dev/null
+++ b/src/math/generic/fsqrt.cpp
@@ -0,0 +1,18 @@
+//===-- Implementation of fsqrt function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsqrt.h"
+#include "src/__support/FPUtil/generic/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsqrt, (double x)) { return fputil::sqrt<float>(x); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsqrtf128.cpp b/src/math/generic/fsqrtf128.cpp
new file mode 100644
index 0000000..f2c0495
--- /dev/null
+++ b/src/math/generic/fsqrtf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fsqrt128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsqrtf128.h"
+#include "src/__support/FPUtil/generic/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsqrtf128, (float128 x)) {
+  return fputil::sqrt<float>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsqrtl.cpp b/src/math/generic/fsqrtl.cpp
new file mode 100644
index 0000000..b896a84
--- /dev/null
+++ b/src/math/generic/fsqrtl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fsqrtl function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsqrtl.h"
+#include "src/__support/FPUtil/generic/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsqrtl, (long double x)) {
+  return fputil::sqrt<float>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsub.cpp b/src/math/generic/fsub.cpp
new file mode 100644
index 0000000..97e2801
--- /dev/null
+++ b/src/math/generic/fsub.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fsub function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsub.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsub, (double x, double y)) {
+  return fputil::generic::sub<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsubf128.cpp b/src/math/generic/fsubf128.cpp
new file mode 100644
index 0000000..3efb349
--- /dev/null
+++ b/src/math/generic/fsubf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fsubf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsubf128.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsubf128, (float128 x, float128 y)) {
+  return fputil::generic::sub<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/fsubl.cpp b/src/math/generic/fsubl.cpp
new file mode 100644
index 0000000..cad5a2d
--- /dev/null
+++ b/src/math/generic/fsubl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of fsubl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/fsubl.h"
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, fsubl, (long double x, long double y)) {
+  return fputil::generic::sub<float>(x, y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/getpayload.cpp b/src/math/generic/getpayload.cpp
new file mode 100644
index 0000000..14d9551
--- /dev/null
+++ b/src/math/generic/getpayload.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of getpayload function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/getpayload.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, getpayload, (const double *x)) {
+  return fputil::getpayload(*x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/getpayloadf.cpp b/src/math/generic/getpayloadf.cpp
new file mode 100644
index 0000000..22db186
--- /dev/null
+++ b/src/math/generic/getpayloadf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of getpayloadf function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/getpayloadf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, getpayloadf, (const float *x)) {
+  return fputil::getpayload(*x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/getpayloadf128.cpp b/src/math/generic/getpayloadf128.cpp
new file mode 100644
index 0000000..b57469e
--- /dev/null
+++ b/src/math/generic/getpayloadf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of getpayloadf128 function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/getpayloadf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float128, getpayloadf128, (const float128 *x)) {
+  return fputil::getpayload(*x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/getpayloadf16.cpp b/src/math/generic/getpayloadf16.cpp
index 0923226..34c31ac 100644
--- a/src/math/generic/getpayloadf16.cpp
+++ b/src/math/generic/getpayloadf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/getpayloadf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, getpayloadf16, (const float16 *x)) {
   return fputil::getpayload(*x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/getpayloadl.cpp b/src/math/generic/getpayloadl.cpp
new file mode 100644
index 0000000..028dc1e
--- /dev/null
+++ b/src/math/generic/getpayloadl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of getpayloadl function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/getpayloadl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long double, getpayloadl, (const long double *x)) {
+  return fputil::getpayload(*x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/hypot.cpp b/src/math/generic/hypot.cpp
index a1914d0..0dfe436 100644
--- a/src/math/generic/hypot.cpp
+++ b/src/math/generic/hypot.cpp
@@ -9,11 +9,12 @@
 #include "src/math/hypot.h"
 #include "src/__support/FPUtil/Hypot.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, hypot, (double x, double y)) {
   return LIBC_NAMESPACE::fputil::hypot(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/hypotf.cpp b/src/math/generic/hypotf.cpp
index b09d09a..959c042 100644
--- a/src/math/generic/hypotf.cpp
+++ b/src/math/generic/hypotf.cpp
@@ -6,68 +6,93 @@
 //
 //===----------------------------------------------------------------------===//
 #include "src/math/hypotf.h"
-#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, hypotf, (float x, float y)) {
   using DoubleBits = fputil::FPBits<double>;
   using FPBits = fputil::FPBits<float>;
 
-  FPBits x_bits(x), y_bits(y);
+  FPBits x_abs = FPBits(x).abs();
+  FPBits y_abs = FPBits(y).abs();
 
-  uint16_t x_exp = x_bits.get_biased_exponent();
-  uint16_t y_exp = y_bits.get_biased_exponent();
-  uint16_t exp_diff = (x_exp > y_exp) ? (x_exp - y_exp) : (y_exp - x_exp);
+  bool x_abs_larger = x_abs.uintval() >= y_abs.uintval();
 
-  if (exp_diff >= FPBits::FRACTION_LEN + 2) {
-    return fputil::abs(x) + fputil::abs(y);
-  }
+  FPBits a_bits = x_abs_larger ? x_abs : y_abs;
+  FPBits b_bits = x_abs_larger ? y_abs : x_abs;
 
-  double xd = static_cast<double>(x);
-  double yd = static_cast<double>(y);
+  uint32_t a_u = a_bits.uintval();
+  uint32_t b_u = b_bits.uintval();
 
-  // These squares are exact.
-  double x_sq = xd * xd;
-  double y_sq = yd * yd;
+  // Note: replacing `a_u >= FPBits::EXP_MASK` with `a_bits.is_inf_or_nan()`
+  // generates extra exponent bit masking instructions on x86-64.
+  if (LIBC_UNLIKELY(a_u >= FPBits::EXP_MASK)) {
+    // x or y is inf or nan
+    if (a_bits.is_signaling_nan() || b_bits.is_signaling_nan()) {
+      fputil::raise_except_if_required(FE_INVALID);
+      return FPBits::quiet_nan().get_val();
+    }
+    if (a_bits.is_inf() || b_bits.is_inf())
+      return FPBits::inf().get_val();
+    return a_bits.get_val();
+  }
 
-  // Compute the sum of squares.
-  double sum_sq = x_sq + y_sq;
+  if (LIBC_UNLIKELY(a_u - b_u >=
+                    static_cast<uint32_t>((FPBits::FRACTION_LEN + 2)
+                                          << FPBits::FRACTION_LEN)))
+    return x_abs.get_val() + y_abs.get_val();
 
-  // Compute the rounding error with Fast2Sum algorithm:
-  // x_sq + y_sq = sum_sq - err
-  double err = (x_sq >= y_sq) ? (sum_sq - x_sq) - y_sq : (sum_sq - y_sq) - x_sq;
+  double ad = static_cast<double>(a_bits.get_val());
+  double bd = static_cast<double>(b_bits.get_val());
+
+  // These squares are exact.
+  double a_sq = ad * ad;
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+  double sum_sq = fputil::multiply_add(bd, bd, a_sq);
+#else
+  double b_sq = bd * bd;
+  double sum_sq = a_sq + b_sq;
+#endif
 
   // Take sqrt in double precision.
   DoubleBits result(fputil::sqrt<double>(sum_sq));
+  uint64_t r_u = result.uintval();
 
-  if (!DoubleBits(sum_sq).is_inf_or_nan()) {
-    // Correct rounding.
-    double r_sq = result.get_val() * result.get_val();
-    double diff = sum_sq - r_sq;
-    constexpr uint64_t MASK = 0x0000'0000'3FFF'FFFFULL;
-    uint64_t lrs = result.uintval() & MASK;
-
-    if (lrs == 0x0000'0000'1000'0000ULL && err < diff) {
-      result.set_uintval(result.uintval() | 1ULL);
-    } else if (lrs == 0x0000'0000'3000'0000ULL && err > diff) {
-      result.set_uintval(result.uintval() - 1ULL);
-    }
-  } else {
-    FPBits bits_x(x), bits_y(y);
-    if (bits_x.is_inf_or_nan() || bits_y.is_inf_or_nan()) {
-      if (bits_x.is_inf() || bits_y.is_inf())
-        return FPBits::inf().get_val();
-      if (bits_x.is_nan())
-        return x;
-      return y;
+  // If any of the sticky bits of the result are non-zero, except the LSB, then
+  // the rounded result is correct.
+  if (LIBC_UNLIKELY(((r_u + 1) & 0x0000'0000'0FFF'FFFE) == 0)) {
+    double r_d = result.get_val();
+
+    // Perform rounding correction.
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+    double sum_sq_lo = fputil::multiply_add(bd, bd, a_sq - sum_sq);
+    double err = sum_sq_lo - fputil::multiply_add(r_d, r_d, -sum_sq);
+#else
+    fputil::DoubleDouble r_sq = fputil::exact_mult(r_d, r_d);
+    double sum_sq_lo = b_sq - (sum_sq - a_sq);
+    double err = (sum_sq - r_sq.hi) + (sum_sq_lo - r_sq.lo);
+#endif
+
+    if (err > 0) {
+      r_u |= 1;
+    } else if ((err < 0) && (r_u & 1) == 0) {
+      r_u -= 1;
+    } else if ((r_u & 0x0000'0000'1FFF'FFFF) == 0) {
+      // The rounded result is exact.
+      fputil::clear_except_if_required(FE_INEXACT);
     }
+    return static_cast<float>(DoubleBits(r_u).get_val());
   }
 
   return static_cast<float>(result.get_val());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ilogb.cpp b/src/math/generic/ilogb.cpp
index 7e4f669..60f2af2 100644
--- a/src/math/generic/ilogb.cpp
+++ b/src/math/generic/ilogb.cpp
@@ -9,9 +9,10 @@
 #include "src/math/ilogb.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogb, (double x)) { return fputil::intlogb<int>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ilogbf.cpp b/src/math/generic/ilogbf.cpp
index 422788c..7da2aff 100644
--- a/src/math/generic/ilogbf.cpp
+++ b/src/math/generic/ilogbf.cpp
@@ -9,9 +9,10 @@
 #include "src/math/ilogbf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbf, (float x)) { return fputil::intlogb<int>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ilogbf128.cpp b/src/math/generic/ilogbf128.cpp
index 4049ecc..4abc670 100644
--- a/src/math/generic/ilogbf128.cpp
+++ b/src/math/generic/ilogbf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ilogbf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbf128, (float128 x)) {
   return fputil::intlogb<int>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ilogbf16.cpp b/src/math/generic/ilogbf16.cpp
index 87e43f8..9217cdf 100644
--- a/src/math/generic/ilogbf16.cpp
+++ b/src/math/generic/ilogbf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ilogbf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbf16, (float16 x)) {
   return fputil::intlogb<int>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ilogbl.cpp b/src/math/generic/ilogbl.cpp
index b7f7eb4..12460a8 100644
--- a/src/math/generic/ilogbl.cpp
+++ b/src/math/generic/ilogbl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ilogbl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbl, (long double x)) {
   return fputil::intlogb<int>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/inv_trigf_utils.cpp b/src/math/generic/inv_trigf_utils.cpp
index 19c8b99..f23028b 100644
--- a/src/math/generic/inv_trigf_utils.cpp
+++ b/src/math/generic/inv_trigf_utils.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "inv_trigf_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Polynomial approximation for 0 <= x <= 1:
 //   atan(x) ~ atan((i/16) + (x - (i/16)) * Q(x - i/16)
@@ -82,4 +83,4 @@ double ATAN_COEFFS[17][9] = {
      0x1.555e31a1e15e9p-6, -0x1.245240d65e629p-7, -0x1.fa9ba66478903p-11},
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/inv_trigf_utils.h b/src/math/generic/inv_trigf_utils.h
index e60c367..bdabec9 100644
--- a/src/math/generic/inv_trigf_utils.h
+++ b/src/math/generic/inv_trigf_utils.h
@@ -12,8 +12,9 @@
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // PI and PI / 2
 constexpr double M_MATH_PI = 0x1.921fb54442d18p+1;
@@ -56,6 +57,6 @@ LIBC_INLINE double asin_eval(double xsq) {
   return fputil::multiply_add(xsq, r2, r1);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_INV_TRIGF_UTILS_H
diff --git a/src/math/generic/iscanonical.cpp b/src/math/generic/iscanonical.cpp
new file mode 100644
index 0000000..ff922f3
--- /dev/null
+++ b/src/math/generic/iscanonical.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of iscanonical function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/iscanonical.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#undef iscanonical
+LLVM_LIBC_FUNCTION(int, iscanonical, (double x)) {
+  double temp;
+  return fputil::canonicalize(temp, x) == 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/iscanonicalf.cpp b/src/math/generic/iscanonicalf.cpp
new file mode 100644
index 0000000..5c38e9b
--- /dev/null
+++ b/src/math/generic/iscanonicalf.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of iscanonicalf function ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/iscanonicalf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, iscanonicalf, (float x)) {
+  float temp;
+  return fputil::canonicalize(temp, x) == 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/iscanonicalf128.cpp b/src/math/generic/iscanonicalf128.cpp
new file mode 100644
index 0000000..ff549c3
--- /dev/null
+++ b/src/math/generic/iscanonicalf128.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of iscanonicalf128 function ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/iscanonicalf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, iscanonicalf128, (float128 x)) {
+  float128 temp;
+  return fputil::canonicalize(temp, x) == 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/iscanonicalf16.cpp b/src/math/generic/iscanonicalf16.cpp
new file mode 100644
index 0000000..f9b093d
--- /dev/null
+++ b/src/math/generic/iscanonicalf16.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of iscanonicalf16 function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/iscanonicalf16.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, iscanonicalf16, (float16 x)) {
+  float16 temp;
+  return fputil::canonicalize(temp, x) == 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/iscanonicall.cpp b/src/math/generic/iscanonicall.cpp
new file mode 100644
index 0000000..34e0035
--- /dev/null
+++ b/src/math/generic/iscanonicall.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of iscanonicall function ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/iscanonicall.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, iscanonicall, (long double x)) {
+  long double temp;
+  return fputil::canonicalize(temp, x) == 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/x86_64/cos.cpp b/src/math/generic/isnan.cpp
similarity index 55%
rename from src/math/x86_64/cos.cpp
rename to src/math/generic/isnan.cpp
index 2cb8db4..73230a4 100644
--- a/src/math/x86_64/cos.cpp
+++ b/src/math/generic/isnan.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the cos function for x86_64 ---------------------===//
+//===-- Implementation of isnan function ----------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,14 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/cos.h"
+#include "src/math/isnan.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, cos, (double x)) {
-  __asm__ __volatile__("fcos" : "+t"(x));
-  return x;
-}
+LLVM_LIBC_FUNCTION(int, isnan, (double x)) { return __builtin_isnan(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/x86_64/sin.cpp b/src/math/generic/isnanf.cpp
similarity index 55%
rename from src/math/x86_64/sin.cpp
rename to src/math/generic/isnanf.cpp
index 2c7b8aa..a1d814e 100644
--- a/src/math/x86_64/sin.cpp
+++ b/src/math/generic/isnanf.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the sin function for x86_64 ---------------------===//
+//===-- Implementation of isnanf function ---------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,14 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/sin.h"
+#include "src/math/isnanf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, sin, (double x)) {
-  __asm__ __volatile__("fsin" : "+t"(x));
-  return x;
-}
+LLVM_LIBC_FUNCTION(int, isnanf, (float x)) { return __builtin_isnan(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/isnanl.cpp b/src/math/generic/isnanl.cpp
new file mode 100644
index 0000000..57ce79f
--- /dev/null
+++ b/src/math/generic/isnanl.cpp
@@ -0,0 +1,17 @@
+//===-- Implementation of isnanl function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/isnanl.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, isnanl, (long double x)) { return __builtin_isnan(x); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/issignaling.cpp b/src/math/generic/issignaling.cpp
new file mode 100644
index 0000000..657be5e
--- /dev/null
+++ b/src/math/generic/issignaling.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of issignaling function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/issignaling.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, issignaling, (double x)) {
+  return fputil::issignaling_impl(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/issignalingf.cpp b/src/math/generic/issignalingf.cpp
new file mode 100644
index 0000000..8a8003a
--- /dev/null
+++ b/src/math/generic/issignalingf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of issignalingf function ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/issignalingf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, issignalingf, (float x)) {
+  return fputil::issignaling_impl(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/issignalingf128.cpp b/src/math/generic/issignalingf128.cpp
new file mode 100644
index 0000000..adf0eba
--- /dev/null
+++ b/src/math/generic/issignalingf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of issignalingf128 function ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/issignalingf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, issignalingf128, (float128 x)) {
+  return fputil::issignaling_impl(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/issignalingf16.cpp b/src/math/generic/issignalingf16.cpp
new file mode 100644
index 0000000..68a771e
--- /dev/null
+++ b/src/math/generic/issignalingf16.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of issignalingf16 function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/issignalingf16.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, issignalingf16, (float16 x)) {
+  return fputil::issignaling_impl(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/issignalingl.cpp b/src/math/generic/issignalingl.cpp
new file mode 100644
index 0000000..b993c55
--- /dev/null
+++ b/src/math/generic/issignalingl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of issignalingl function ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/issignalingl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, issignalingl, (long double x)) {
+  return fputil::issignaling_impl(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ldexp.cpp b/src/math/generic/ldexp.cpp
index 18aae09..93ed328 100644
--- a/src/math/generic/ldexp.cpp
+++ b/src/math/generic/ldexp.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ldexp.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ldexp, (double x, int exp)) {
   return fputil::ldexp(x, exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ldexpf.cpp b/src/math/generic/ldexpf.cpp
index 37f88ab..63c5d21 100644
--- a/src/math/generic/ldexpf.cpp
+++ b/src/math/generic/ldexpf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ldexpf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ldexpf, (float x, int exp)) {
   return fputil::ldexp(x, exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ldexpf128.cpp b/src/math/generic/ldexpf128.cpp
index ed2ebd3..03b1a2d 100644
--- a/src/math/generic/ldexpf128.cpp
+++ b/src/math/generic/ldexpf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ldexpf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, ldexpf128, (float128 x, int exp)) {
   return fputil::ldexp(x, exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ldexpf16.cpp b/src/math/generic/ldexpf16.cpp
index ed15c45..caa344b 100644
--- a/src/math/generic/ldexpf16.cpp
+++ b/src/math/generic/ldexpf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ldexpf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, ldexpf16, (float16 x, int exp)) {
   return fputil::ldexp(x, exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ldexpl.cpp b/src/math/generic/ldexpl.cpp
index 8b29009..9e1de5c 100644
--- a/src/math/generic/ldexpl.cpp
+++ b/src/math/generic/ldexpl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ldexpl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, ldexpl, (long double x, int exp)) {
   return fputil::ldexp(x, exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llogb.cpp b/src/math/generic/llogb.cpp
index 917bc38..3850ac0 100644
--- a/src/math/generic/llogb.cpp
+++ b/src/math/generic/llogb.cpp
@@ -9,9 +9,10 @@
 #include "src/math/llogb.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, llogb, (double x)) { return fputil::intlogb<long>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llogbf.cpp b/src/math/generic/llogbf.cpp
index ca1c03d..fedad95 100644
--- a/src/math/generic/llogbf.cpp
+++ b/src/math/generic/llogbf.cpp
@@ -9,9 +9,10 @@
 #include "src/math/llogbf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, llogbf, (float x)) { return fputil::intlogb<long>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llogbf128.cpp b/src/math/generic/llogbf128.cpp
index 5ae4af3..9106731 100644
--- a/src/math/generic/llogbf128.cpp
+++ b/src/math/generic/llogbf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llogbf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, llogbf128, (float128 x)) {
   return fputil::intlogb<long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llogbf16.cpp b/src/math/generic/llogbf16.cpp
index b7a21b9..c792e90 100644
--- a/src/math/generic/llogbf16.cpp
+++ b/src/math/generic/llogbf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llogbf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, llogbf16, (float16 x)) {
   return fputil::intlogb<long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llogbl.cpp b/src/math/generic/llogbl.cpp
index a092997..7ee3ac5 100644
--- a/src/math/generic/llogbl.cpp
+++ b/src/math/generic/llogbl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llogbl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, llogbl, (long double x)) {
   return fputil::intlogb<long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llrint.cpp b/src/math/generic/llrint.cpp
index 87755e8..f6e8cab 100644
--- a/src/math/generic/llrint.cpp
+++ b/src/math/generic/llrint.cpp
@@ -9,8 +9,9 @@
 #include "src/math/llrint.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrint, (double x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<double,
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(long long, llrint, (double x)) {
       x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llrintf.cpp b/src/math/generic/llrintf.cpp
index 836e7cb..b5180de 100644
--- a/src/math/generic/llrintf.cpp
+++ b/src/math/generic/llrintf.cpp
@@ -9,8 +9,9 @@
 #include "src/math/llrintf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrintf, (float x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float,
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(long long, llrintf, (float x)) {
       x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llrintf128.cpp b/src/math/generic/llrintf128.cpp
index e5a4c50..af48985 100644
--- a/src/math/generic/llrintf128.cpp
+++ b/src/math/generic/llrintf128.cpp
@@ -9,8 +9,9 @@
 #include "src/math/llrintf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrintf128, (float128 x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float128,
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(long long, llrintf128, (float128 x)) {
       x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llrintf16.cpp b/src/math/generic/llrintf16.cpp
index 0bed21a..c6b31c7 100644
--- a/src/math/generic/llrintf16.cpp
+++ b/src/math/generic/llrintf16.cpp
@@ -9,8 +9,9 @@
 #include "src/math/llrintf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrintf16, (float16 x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float16,
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(long long, llrintf16, (float16 x)) {
       x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llrintl.cpp b/src/math/generic/llrintl.cpp
index 104e3d4..35ae609 100644
--- a/src/math/generic/llrintl.cpp
+++ b/src/math/generic/llrintl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/llrintl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llrintl, (long double x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<
       long double, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llround.cpp b/src/math/generic/llround.cpp
index 41bee85..40b2614 100644
--- a/src/math/generic/llround.cpp
+++ b/src/math/generic/llround.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llround.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llround, (double x)) {
   return fputil::round_to_signed_integer<double, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llroundf.cpp b/src/math/generic/llroundf.cpp
index 67105e8..259c769 100644
--- a/src/math/generic/llroundf.cpp
+++ b/src/math/generic/llroundf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llroundf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llroundf, (float x)) {
   return fputil::round_to_signed_integer<float, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llroundf128.cpp b/src/math/generic/llroundf128.cpp
index 2579163..2df24f5 100644
--- a/src/math/generic/llroundf128.cpp
+++ b/src/math/generic/llroundf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llroundf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llroundf128, (float128 x)) {
   return fputil::round_to_signed_integer<float128, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llroundf16.cpp b/src/math/generic/llroundf16.cpp
index 9485674..d3f691e 100644
--- a/src/math/generic/llroundf16.cpp
+++ b/src/math/generic/llroundf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llroundf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llroundf16, (float16 x)) {
   return fputil::round_to_signed_integer<float16, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/llroundl.cpp b/src/math/generic/llroundl.cpp
index 98cfb36..49b41c8 100644
--- a/src/math/generic/llroundl.cpp
+++ b/src/math/generic/llroundl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/llroundl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llroundl, (long double x)) {
   return fputil::round_to_signed_integer<long double, long long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log.cpp b/src/math/generic/log.cpp
index 6de0d90..4302c64 100644
--- a/src/math/generic/log.cpp
+++ b/src/math/generic/log.cpp
@@ -15,12 +15,13 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "common_constants.h"
 #include "log_range_reduction.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // 128-bit precision dyadic floating point numbers.
 using Float128 = typename fputil::DyadicFloat<128>;
@@ -748,7 +749,7 @@ LLVM_LIBC_FUNCTION(double, log, (double x)) {
 
   if (LIBC_UNLIKELY(xbits.uintval() < FPBits_t::min_normal().uintval() ||
                     xbits.uintval() > FPBits_t::max_normal().uintval())) {
-    if (xbits.is_zero()) {
+    if (x == 0.0) {
       // return -Inf and raise FE_DIVBYZERO.
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -837,4 +838,4 @@ LLVM_LIBC_FUNCTION(double, log, (double x)) {
   return log_accurate(x_e, index, u);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log10.cpp b/src/math/generic/log10.cpp
index fb839c1..7df57ef 100644
--- a/src/math/generic/log10.cpp
+++ b/src/math/generic/log10.cpp
@@ -15,12 +15,13 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "common_constants.h"
 #include "log_range_reduction.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // 128-bit precision dyadic floating point numbers.
 using Float128 = typename fputil::DyadicFloat<128>;
@@ -750,7 +751,7 @@ LLVM_LIBC_FUNCTION(double, log10, (double x)) {
 
   if (LIBC_UNLIKELY(xbits.uintval() < FPBits_t::min_normal().uintval() ||
                     xbits.uintval() > FPBits_t::max_normal().uintval())) {
-    if (xbits.is_zero()) {
+    if (x == 0.0) {
       // return -Inf and raise FE_DIVBYZERO.
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -898,4 +899,4 @@ LLVM_LIBC_FUNCTION(double, log10, (double x)) {
   return log10_accurate(x_e, index, u);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log10f.cpp b/src/math/generic/log10f.cpp
index 1b6979d..c635fa4 100644
--- a/src/math/generic/log10f.cpp
+++ b/src/math/generic/log10f.cpp
@@ -15,6 +15,7 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h"
 
@@ -54,7 +55,7 @@
 // Dept. of Comp. Sci., Rutgets U., Technical Report DCS-TR-758, Nov. 2021.
 // https://arxiv.org/pdf/2111.12852.pdf.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Lookup table for -log10(r) where r is defined in common_constants.cpp.
 static constexpr double LOG10_R[128] = {
@@ -163,7 +164,7 @@ LLVM_LIBC_FUNCTION(float, log10f, (float x)) {
 
   if (LIBC_UNLIKELY(x_u < FPBits::min_normal().uintval() ||
                     x_u > FPBits::max_normal().uintval())) {
-    if (xbits.is_zero()) {
+    if (x == 0.0f) {
       // Return -inf and raise FE_DIVBYZERO
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -215,4 +216,4 @@ LLVM_LIBC_FUNCTION(float, log10f, (float x)) {
   return static_cast<float>(r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log10f16.cpp b/src/math/generic/log10f16.cpp
new file mode 100644
index 0000000..990bcab
--- /dev/null
+++ b/src/math/generic/log10f16.cpp
@@ -0,0 +1,164 @@
+//===-- Half-precision log10(x) function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/log10f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_LOG10F16_EXCEPTS = 11;
+#else
+static constexpr size_t N_LOG10F16_EXCEPTS = 17;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_LOG10F16_EXCEPTS>
+    LOG10F16_EXCEPTS = {{
+        // (input, RZ output, RU offset, RD offset, RN offset)
+        // x = 0x1.e3cp-3, log10f16(x) = -0x1.40cp-1 (RZ)
+        {0x338fU, 0xb903U, 0U, 1U, 0U},
+        // x = 0x1.fep-3, log10f16(x) = -0x1.35p-1 (RZ)
+        {0x33f8U, 0xb8d4U, 0U, 1U, 1U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.394p-1, log10f16(x) = -0x1.b4cp-3 (RZ)
+        {0x38e5U, 0xb2d3U, 0U, 1U, 1U},
+#endif
+        // x = 0x1.ea8p-1, log10f16(x) = -0x1.31p-6 (RZ)
+        {0x3baaU, 0xa4c4U, 0U, 1U, 1U},
+        // x = 0x1.ebp-1, log10f16(x) = -0x1.29cp-6 (RZ)
+        {0x3bacU, 0xa4a7U, 0U, 1U, 1U},
+        // x = 0x1.f3p-1, log10f16(x) = -0x1.6dcp-7 (RZ)
+        {0x3bccU, 0xa1b7U, 0U, 1U, 1U},
+// x = 0x1.f38p-1, log10f16(x) = -0x1.5f8p-7 (RZ)
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        {0x3bceU, 0xa17eU, 0U, 1U, 1U},
+        // x = 0x1.fd8p-1, log10f16(x) = -0x1.168p-9 (RZ)
+        {0x3bf6U, 0x985aU, 0U, 1U, 1U},
+        // x = 0x1.ff8p-1, log10f16(x) = -0x1.bccp-12 (RZ)
+        {0x3bfeU, 0x8ef3U, 0U, 1U, 1U},
+        // x = 0x1.374p+0, log10f16(x) = 0x1.5b8p-4 (RZ)
+        {0x3cddU, 0x2d6eU, 1U, 0U, 1U},
+        // x = 0x1.3ecp+1, log10f16(x) = 0x1.958p-2 (RZ)
+        {0x40fbU, 0x3656U, 1U, 0U, 1U},
+#endif
+        // x = 0x1.4p+3, log10f16(x) = 0x1p+0 (RZ)
+        {0x4900U, 0x3c00U, 0U, 0U, 0U},
+        // x = 0x1.9p+6, log10f16(x) = 0x1p+1 (RZ)
+        {0x5640U, 0x4000U, 0U, 0U, 0U},
+        // x = 0x1.f84p+6, log10f16(x) = 0x1.0ccp+1 (RZ)
+        {0x57e1U, 0x4033U, 1U, 0U, 0U},
+        // x = 0x1.f4p+9, log10f16(x) = 0x1.8p+1 (RZ)
+        {0x63d0U, 0x4200U, 0U, 0U, 0U},
+        // x = 0x1.388p+13, log10f16(x) = 0x1p+2 (RZ)
+        {0x70e2U, 0x4400U, 0U, 0U, 0U},
+        // x = 0x1.674p+13, log10f16(x) = 0x1.03cp+2 (RZ)
+        {0x719dU, 0x440fU, 1U, 0U, 0U},
+    }};
+
+LLVM_LIBC_FUNCTION(float16, log10f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+
+  // If x <= 0, or x is 1, or x is +inf, or x is NaN.
+  if (LIBC_UNLIKELY(x_u == 0U || x_u == 0x3c00U || x_u >= 0x7c00U)) {
+    // log10(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // log10(+/-0) = inf
+    if ((x_u & 0x7fffU) == 0U) {
+      fputil::raise_except_if_required(FE_DIVBYZERO);
+      return FPBits::inf(Sign::NEG).get_val();
+    }
+
+    if (x_u == 0x3c00U)
+      return FPBits::zero().get_val();
+
+    // When x < 0.
+    if (x_u > 0x8000U) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+      return FPBits::quiet_nan().get_val();
+    }
+
+    // log10(+inf) = +inf
+    return FPBits::inf().get_val();
+  }
+
+  if (auto r = LOG10F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // To compute log10(x), we perform the following range reduction:
+  //   x = 2^m * 1.mant,
+  //   log10(x) = m * log10(2) + log10(1.mant).
+  // To compute log10(1.mant), let f be the highest 6 bits including the hidden
+  // bit, and d be the difference (1.mant - f), i.e., the remaining 5 bits of
+  // the mantissa, then:
+  //   log10(1.mant) = log10(f) + log10(1.mant / f)
+  //                 = log10(f) + log10(1 + d/f)
+  // since d/f is sufficiently small.
+  // We store log10(f) and 1/f in the lookup tables LOG10F_F and ONE_OVER_F_F
+  // respectively.
+
+  int m = -FPBits::EXP_BIAS;
+
+  // When x is subnormal, normalize it.
+  if ((x_u & FPBits::EXP_MASK) == 0U) {
+    // Can't pass an integer to fputil::cast directly.
+    constexpr float NORMALIZE_EXP = 1U << FPBits::FRACTION_LEN;
+    x_bits = FPBits(x_bits.get_val() * fputil::cast<float16>(NORMALIZE_EXP));
+    x_u = x_bits.uintval();
+    m -= FPBits::FRACTION_LEN;
+  }
+
+  uint16_t mant = x_bits.get_mantissa();
+  // Leading 10 - 5 = 5 bits of the mantissa.
+  int f = mant >> 5;
+  // Unbiased exponent.
+  m += x_u >> FPBits::FRACTION_LEN;
+
+  // Set bits to 1.mant instead of 2^m * 1.mant.
+  x_bits.set_biased_exponent(FPBits::EXP_BIAS);
+  float mant_f = x_bits.get_val();
+  // v = 1.mant * 1/f - 1 = d/f
+  float v = fputil::multiply_add(mant_f, ONE_OVER_F_F[f], -1.0f);
+
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(log10(1 + x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+  //   > x * P;
+  float log10p1_d_over_f =
+      v * fputil::polyeval(v, 0x1.bcb7bp-2f, -0x1.bce168p-3f, 0x1.28acb8p-3f);
+  // log10(1.mant) = log10(f) + log10(1 + d/f)
+  float log10_1_mant = LOG10F_F[f] + log10p1_d_over_f;
+  return fputil::cast<float16>(
+      fputil::multiply_add(static_cast<float>(m), LOG10F_2, log10_1_mant));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log1p.cpp b/src/math/generic/log1p.cpp
index 2b18708..b9c58b8 100644
--- a/src/math/generic/log1p.cpp
+++ b/src/math/generic/log1p.cpp
@@ -15,11 +15,12 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "common_constants.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // 128-bit precision dyadic floating point numbers.
 using Float128 = typename fputil::DyadicFloat<128>;
@@ -821,8 +822,8 @@ constexpr Float128 BIG_COEFFS[4]{
     {Sign::NEG, -128, 0x80000000'00000000'00000000'00000000_u128},
 };
 
-LIBC_INLINE double log1p_accurate(int e_x, int index,
-                                  fputil::DoubleDouble m_x) {
+[[maybe_unused]] LIBC_INLINE double log1p_accurate(int e_x, int index,
+                                                   fputil::DoubleDouble m_x) {
   Float128 e_x_f128(static_cast<float>(e_x));
   Float128 sum = fputil::quick_mul(LOG_2, e_x_f128);
   sum = fputil::quick_add(sum, LOG_R1[index]);
@@ -881,7 +882,6 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
 
   constexpr int EXP_BIAS = FPBits_t::EXP_BIAS;
   constexpr int FRACTION_LEN = FPBits_t::FRACTION_LEN;
-  constexpr uint64_t FRACTION_MASK = FPBits_t::FRACTION_MASK;
   FPBits_t xbits(x);
   uint64_t x_u = xbits.uintval();
 
@@ -926,8 +926,8 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
       //   log(1 + x) = nextafter(x, -inf) for FE_DOWNWARD, or
       //                                       FE_TOWARDZERO and x > 0,
       //              = x                  otherwise.
-      if (LIBC_UNLIKELY(xbits.is_zero()))
-        return x;
+      if (x == 0.0)
+        return x + x; // Handle FTZ/DAZ correctly.
 
       volatile float tp = 1.0f;
       volatile float tn = -1.0f;
@@ -942,7 +942,7 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
         return FPBits_t(x_u + 1).get_val();
       }
 
-      return x;
+      return (x + x == 0.0) ? x + x : x;
     }
     x_dd = fputil::exact_add(1.0, x);
   }
@@ -953,12 +953,12 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   //   |x_dd.lo| < ulp(x_dd.hi)
 
   FPBits_t xhi_bits(x_dd.hi);
+  uint64_t xhi_frac = xhi_bits.get_mantissa();
   x_u = xhi_bits.uintval();
   // Range reduction:
   // Find k such that |x_hi - k * 2^-7| <= 2^-8.
-  int idx =
-      static_cast<int>(((x_u & FRACTION_MASK) + (1ULL << (FRACTION_LEN - 8))) >>
-                       (FRACTION_LEN - 7));
+  int idx = static_cast<int>((xhi_frac + (1ULL << (FRACTION_LEN - 8))) >>
+                             (FRACTION_LEN - 7));
   int x_e = xhi_bits.get_exponent() + (idx >> 7);
   double e_x = static_cast<double>(x_e);
 
@@ -973,17 +973,21 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   constexpr double ERR_HI[2] = {0x1.0p-85, 0.0};
   double err_hi = ERR_HI[hi == 0.0];
 
-  // Scaling factior = 2^(-xh_bits.get_exponent())
-  uint64_t s_u = (static_cast<uint64_t>(EXP_BIAS) << (FRACTION_LEN + 1)) -
-                 (x_u & FPBits_t::EXP_MASK);
-  // When the exponent of x is 2^1023, its inverse, 2^(-1023), is subnormal.
-  const double EXPONENT_CORRECTION[2] = {0.0, 0x1.0p-1023};
-  double scaling = FPBits_t(s_u).get_val() + EXPONENT_CORRECTION[s_u == 0];
+  // Scale x_dd by 2^(-xh_bits.get_exponent()).
+  int64_t s_u = static_cast<int64_t>(x_u & FPBits_t::EXP_MASK) -
+                (static_cast<int64_t>(EXP_BIAS) << FRACTION_LEN);
   // Normalize arguments:
   //   1 <= m_dd.hi < 2
   //   |m_dd.lo| < 2^-52.
   // This is exact.
-  fputil::DoubleDouble m_dd{scaling * x_dd.lo, scaling * x_dd.hi};
+  uint64_t m_hi = FPBits_t::one().uintval() | xhi_frac;
+
+  uint64_t m_lo =
+      FPBits_t(x_dd.lo).abs().get_val() > x_dd.hi * 0x1.0p-127
+          ? static_cast<uint64_t>(cpp::bit_cast<int64_t>(x_dd.lo) - s_u)
+          : 0;
+
+  fputil::DoubleDouble m_dd{FPBits_t(m_lo).get_val(), FPBits_t(m_hi).get_val()};
 
   // Perform range reduction:
   //   r * m - 1 = r * (m_dd.hi + m_dd.lo) - 1
@@ -1041,4 +1045,4 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   return log1p_accurate(x_e, idx, v_dd);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log1pf.cpp b/src/math/generic/log1pf.cpp
index e3c7d95..869cb07 100644
--- a/src/math/generic/log1pf.cpp
+++ b/src/math/generic/log1pf.cpp
@@ -15,6 +15,7 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h"
 
@@ -30,7 +31,7 @@
 // generated with Sollya using the following command:
 //   fpminimax(log(1 + x)/x, 7, [|D...|], [-2^-6; 2^-6]);
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace internal {
 
@@ -153,4 +154,4 @@ LLVM_LIBC_FUNCTION(float, log1pf, (float x)) {
   return static_cast<float>(r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log2.cpp b/src/math/generic/log2.cpp
index c68bc60..37ea0c8 100644
--- a/src/math/generic/log2.cpp
+++ b/src/math/generic/log2.cpp
@@ -15,12 +15,13 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "common_constants.h"
 #include "log_range_reduction.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // 128-bit precision dyadic floating point numbers.
 using Float128 = typename fputil::DyadicFloat<128>;
@@ -870,7 +871,7 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
 
   if (LIBC_UNLIKELY(xbits.uintval() < FPBits_t::min_normal().uintval() ||
                     xbits.uintval() > FPBits_t::max_normal().uintval())) {
-    if (xbits.is_zero()) {
+    if (x == 0.0) {
       // return -Inf and raise FE_DIVBYZERO.
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -959,4 +960,4 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
   return log2_accurate(x_e, index, u);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log2f.cpp b/src/math/generic/log2f.cpp
index c9f7b21..111f3f1 100644
--- a/src/math/generic/log2f.cpp
+++ b/src/math/generic/log2f.cpp
@@ -14,6 +14,7 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 // This is a correctly-rounded algorithm for log2(x) in single precision with
@@ -51,7 +52,7 @@
 // Dept. of Comp. Sci., Rutgets U., Technical Report DCS-TR-758, Nov. 2021.
 // https://arxiv.org/pdf/2111.12852.pdf.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log2f, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -71,7 +72,7 @@ LLVM_LIBC_FUNCTION(float, log2f, (float x)) {
   // Exceptional inputs.
   if (LIBC_UNLIKELY(x_u < FPBits::min_normal().uintval() ||
                     x_u > FPBits::max_normal().uintval())) {
-    if (xbits.is_zero()) {
+    if (x == 0.0f) {
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
       return FPBits::inf(Sign::NEG).get_val();
@@ -120,4 +121,4 @@ LLVM_LIBC_FUNCTION(float, log2f, (float x)) {
   return static_cast<float>(r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log2f16.cpp b/src/math/generic/log2f16.cpp
new file mode 100644
index 0000000..ff4e026
--- /dev/null
+++ b/src/math/generic/log2f16.cpp
@@ -0,0 +1,149 @@
+//===-- Half-precision log2(x) function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/log2f16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_LOG2F16_EXCEPTS = 2;
+#else
+static constexpr size_t N_LOG2F16_EXCEPTS = 9;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_LOG2F16_EXCEPTS>
+    LOG2F16_EXCEPTS = {{
+// (input, RZ output, RU offset, RD offset, RN offset)
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.224p-1, log2f16(x) = -0x1.a34p-1 (RZ)
+        {0x3889U, 0xba8dU, 0U, 1U, 0U},
+        // x = 0x1.e34p-1, log2f16(x) = -0x1.558p-4 (RZ)
+        {0x3b8dU, 0xad56U, 0U, 1U, 0U},
+#endif
+        // x = 0x1.e8cp-1, log2f16(x) = -0x1.128p-4 (RZ)
+        {0x3ba3U, 0xac4aU, 0U, 1U, 0U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.f98p-1, log2f16(x) = -0x1.2ep-6 (RZ)
+        {0x3be6U, 0xa4b8U, 0U, 1U, 0U},
+        // x = 0x1.facp-1, log2f16(x) = -0x1.e7p-7 (RZ)
+        {0x3bebU, 0xa39cU, 0U, 1U, 1U},
+#endif
+        // x = 0x1.fb4p-1, log2f16(x) = -0x1.b88p-7 (RZ)
+        {0x3bedU, 0xa2e2U, 0U, 1U, 1U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.fecp-1, log2f16(x) = -0x1.cep-9 (RZ)
+        {0x3bfbU, 0x9b38U, 0U, 1U, 1U},
+        // x = 0x1.ffcp-1, log2f16(x) = -0x1.714p-11 (RZ)
+        {0x3bffU, 0x91c5U, 0U, 1U, 1U},
+        // x = 0x1.224p+0, log2f16(x) = 0x1.72cp-3 (RZ)
+        {0x3c89U, 0x31cbU, 1U, 0U, 1U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, log2f16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+
+  // If x <= 0, or x is 1, or x is +inf, or x is NaN.
+  if (LIBC_UNLIKELY(x_u == 0U || x_u == 0x3c00U || x_u >= 0x7c00U)) {
+    // log2(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // log2(+/-0) = inf
+    if ((x_u & 0x7fffU) == 0U) {
+      fputil::raise_except_if_required(FE_DIVBYZERO);
+      return FPBits::inf(Sign::NEG).get_val();
+    }
+
+    if (x_u == 0x3c00U)
+      return FPBits::zero().get_val();
+
+    // When x < 0.
+    if (x_u > 0x8000U) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+      return FPBits::quiet_nan().get_val();
+    }
+
+    // log2(+inf) = +inf
+    return FPBits::inf().get_val();
+  }
+
+  if (auto r = LOG2F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // To compute log2(x), we perform the following range reduction:
+  //   x = 2^m * 1.mant,
+  //   log2(x) = m + log2(1.mant).
+  // To compute log2(1.mant), let f be the highest 6 bits including the hidden
+  // bit, and d be the difference (1.mant - f), i.e., the remaining 5 bits of
+  // the mantissa, then:
+  //   log2(1.mant) = log2(f) + log2(1.mant / f)
+  //                = log2(f) + log2(1 + d/f)
+  // since d/f is sufficiently small.
+  // We store log2(f) and 1/f in the lookup tables LOG2F_F and ONE_OVER_F_F
+  // respectively.
+
+  int m = -FPBits::EXP_BIAS;
+
+  // When x is subnormal, normalize it.
+  if ((x_u & FPBits::EXP_MASK) == 0U) {
+    // Can't pass an integer to fputil::cast directly.
+    constexpr float NORMALIZE_EXP = 1U << FPBits::FRACTION_LEN;
+    x_bits = FPBits(x_bits.get_val() * fputil::cast<float16>(NORMALIZE_EXP));
+    x_u = x_bits.uintval();
+    m -= FPBits::FRACTION_LEN;
+  }
+
+  uint16_t mant = x_bits.get_mantissa();
+  // Leading 10 - 5 = 5 bits of the mantissa.
+  int f = mant >> 5;
+  // Unbiased exponent.
+  m += x_u >> FPBits::FRACTION_LEN;
+
+  // Set bits to 1.mant instead of 2^m * 1.mant.
+  x_bits.set_biased_exponent(FPBits::EXP_BIAS);
+  float mant_f = x_bits.get_val();
+  // v = 1.mant * 1/f - 1 = d/f
+  float v = fputil::multiply_add(mant_f, ONE_OVER_F_F[f], -1.0f);
+
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(log2(1 + x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+  //   > x * P;
+  float log2p1_d_over_f =
+      v * fputil::polyeval(v, 0x1.715476p+0f, -0x1.71771ap-1f, 0x1.ecb38ep-2f);
+  // log2(1.mant) = log2(f) + log2(1 + d/f)
+  float log2_1_mant = LOG2F_F[f] + log2p1_d_over_f;
+  return fputil::cast<float16>(static_cast<float>(m) + log2_1_mant);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log_range_reduction.h b/src/math/generic/log_range_reduction.h
index d12da47..8c94230 100644
--- a/src/math/generic/log_range_reduction.h
+++ b/src/math/generic/log_range_reduction.h
@@ -11,9 +11,10 @@
 
 #include "common_constants.h"
 #include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/uint128.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Struct to store -log*(r) for 4 range reduction steps.
 struct LogRR {
@@ -87,6 +88,6 @@ log_range_reduction(double m_x, const LogRR &log_table,
                                      static_cast<uint64_t>(vv4 >> 64)}));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_LOG_RANGE_REDUCTION_H
diff --git a/src/math/generic/logb.cpp b/src/math/generic/logb.cpp
index 8cd6edc..4b8fde9 100644
--- a/src/math/generic/logb.cpp
+++ b/src/math/generic/logb.cpp
@@ -9,9 +9,10 @@
 #include "src/math/logb.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, logb, (double x)) { return fputil::logb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logbf.cpp b/src/math/generic/logbf.cpp
index 9f9f7fb..0dc0251 100644
--- a/src/math/generic/logbf.cpp
+++ b/src/math/generic/logbf.cpp
@@ -9,9 +9,10 @@
 #include "src/math/logbf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logbf, (float x)) { return fputil::logb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logbf128.cpp b/src/math/generic/logbf128.cpp
index 090433d..af83487 100644
--- a/src/math/generic/logbf128.cpp
+++ b/src/math/generic/logbf128.cpp
@@ -9,9 +9,10 @@
 #include "src/math/logbf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, logbf128, (float128 x)) { return fputil::logb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logbf16.cpp b/src/math/generic/logbf16.cpp
index 52eb9ac..6e286a2 100644
--- a/src/math/generic/logbf16.cpp
+++ b/src/math/generic/logbf16.cpp
@@ -9,9 +9,10 @@
 #include "src/math/logbf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, logbf16, (float16 x)) { return fputil::logb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logbl.cpp b/src/math/generic/logbl.cpp
index f18c372..dcab957 100644
--- a/src/math/generic/logbl.cpp
+++ b/src/math/generic/logbl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/logbl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, logbl, (long double x)) {
   return fputil::logb(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logf.cpp b/src/math/generic/logf.cpp
index 5296ba6..30c00ed 100644
--- a/src/math/generic/logf.cpp
+++ b/src/math/generic/logf.cpp
@@ -14,6 +14,7 @@
 #include "src/__support/FPUtil/except_value_utils.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h"
 
@@ -49,7 +50,7 @@
 // USA, January 16-22, 2022.
 // https://people.cs.rutgers.edu/~sn349/papers/rlibmall-popl-2022.pdf
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logf, (float x)) {
   constexpr double LOG_2 = 0x1.62e42fefa39efp-1;
@@ -81,7 +82,7 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
     }
     // Subnormal inputs.
     if (LIBC_UNLIKELY(x_u < FPBits::min_normal().uintval())) {
-      if (x_u == 0) {
+      if (x == 0.0f) {
         // Return -inf and raise FE_DIVBYZERO
         fputil::set_errno_if_required(ERANGE);
         fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -170,4 +171,4 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
   return static_cast<float>(r);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/logf16.cpp b/src/math/generic/logf16.cpp
new file mode 100644
index 0000000..802225a
--- /dev/null
+++ b/src/math/generic/logf16.cpp
@@ -0,0 +1,157 @@
+//===-- Half-precision log(x) function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/logf16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/macros/properties/cpu_features.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr size_t N_LOGF16_EXCEPTS = 5;
+#else
+static constexpr size_t N_LOGF16_EXCEPTS = 11;
+#endif
+
+static constexpr fputil::ExceptValues<float16, N_LOGF16_EXCEPTS>
+    LOGF16_EXCEPTS = {{
+// (input, RZ output, RU offset, RD offset, RN offset)
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.61cp-13, logf16(x) = -0x1.16p+3 (RZ)
+        {0x0987U, 0xc858U, 0U, 1U, 0U},
+        // x = 0x1.f2p-12, logf16(x) = -0x1.e98p+2 (RZ)
+        {0x0fc8U, 0xc7a6U, 0U, 1U, 1U},
+#endif
+        // x = 0x1.4d4p-9, logf16(x) = -0x1.7e4p+2 (RZ)
+        {0x1935U, 0xc5f9U, 0U, 1U, 0U},
+        // x = 0x1.5ep-8, logf16(x) = -0x1.4ecp+2 (RZ)
+        {0x1d78U, 0xc53bU, 0U, 1U, 0U},
+#ifndef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.fdp-1, logf16(x) = -0x1.81p-8 (RZ)
+        {0x3bf4U, 0x9e04U, 0U, 1U, 1U},
+        // x = 0x1.fep-1, logf16(x) = -0x1.008p-8 (RZ)
+        {0x3bf8U, 0x9c02U, 0U, 1U, 0U},
+#endif
+        // x = 0x1.ffp-1, logf16(x) = -0x1.004p-9 (RZ)
+        {0x3bfcU, 0x9801U, 0U, 1U, 0U},
+        // x = 0x1.ff8p-1, logf16(x) = -0x1p-10 (RZ)
+        {0x3bfeU, 0x9400U, 0U, 1U, 1U},
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+        // x = 0x1.4c4p+1, logf16(x) = 0x1.e84p-1 (RZ)
+        {0x4131U, 0x3ba1U, 1U, 0U, 1U},
+#else
+        // x = 0x1.75p+2, logf16(x) = 0x1.c34p+0 (RZ)
+        {0x45d4U, 0x3f0dU, 1U, 0U, 0U},
+        // x = 0x1.75p+2, logf16(x) = 0x1.c34p+0 (RZ)
+        {0x45d4U, 0x3f0dU, 1U, 0U, 0U},
+        // x = 0x1.d5p+9, logf16(x) = 0x1.b5cp+2 (RZ)
+        {0x6354U, 0x46d7U, 1U, 0U, 1U},
+#endif
+    }};
+
+LLVM_LIBC_FUNCTION(float16, logf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+
+  // If x <= 0, or x is 1, or x is +inf, or x is NaN.
+  if (LIBC_UNLIKELY(x_u == 0U || x_u == 0x3c00U || x_u >= 0x7c00U)) {
+    // log(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // log(+/-0) = inf
+    if ((x_u & 0x7fffU) == 0U) {
+      fputil::raise_except_if_required(FE_DIVBYZERO);
+      return FPBits::inf(Sign::NEG).get_val();
+    }
+
+    if (x_u == 0x3c00U)
+      return FPBits::zero().get_val();
+
+    // When x < 0.
+    if (x_u > 0x8000U) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+      return FPBits::quiet_nan().get_val();
+    }
+
+    // log(+inf) = +inf
+    return FPBits::inf().get_val();
+  }
+
+  if (auto r = LOGF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // To compute log(x), we perform the following range reduction:
+  //   x = 2^m * 1.mant,
+  //   log(x) = m * log(2) + log(1.mant).
+  // To compute log(1.mant), let f be the highest 6 bits including the hidden
+  // bit, and d be the difference (1.mant - f), i.e., the remaining 5 bits of
+  // the mantissa, then:
+  //   log(1.mant) = log(f) + log(1.mant / f)
+  //               = log(f) + log(1 + d/f)
+  // since d/f is sufficiently small.
+  // We store log(f) and 1/f in the lookup tables LOGF_F and ONE_OVER_F_F
+  // respectively.
+
+  int m = -FPBits::EXP_BIAS;
+
+  // When x is subnormal, normalize it.
+  if ((x_u & FPBits::EXP_MASK) == 0U) {
+    // Can't pass an integer to fputil::cast directly.
+    constexpr float NORMALIZE_EXP = 1U << FPBits::FRACTION_LEN;
+    x_bits = FPBits(x_bits.get_val() * fputil::cast<float16>(NORMALIZE_EXP));
+    x_u = x_bits.uintval();
+    m -= FPBits::FRACTION_LEN;
+  }
+
+  uint16_t mant = x_bits.get_mantissa();
+  // Leading 10 - 5 = 5 bits of the mantissa.
+  int f = mant >> 5;
+  // Unbiased exponent.
+  m += x_u >> FPBits::FRACTION_LEN;
+
+  // Set bits to 1.mant instead of 2^m * 1.mant.
+  x_bits.set_biased_exponent(FPBits::EXP_BIAS);
+  float mant_f = x_bits.get_val();
+  // v = 1.mant * 1/f - 1 = d/f
+  float v = fputil::multiply_add(mant_f, ONE_OVER_F_F[f], -1.0f);
+
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(log(1 + x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+  //   > x * P;
+  float log1p_d_over_f =
+      v * fputil::polyeval(v, 0x1p+0f, -0x1.001804p-1f, 0x1.557ef6p-2f);
+  // log(1.mant) = log(f) + log(1 + d/f)
+  float log_1_mant = LOGF_F[f] + log1p_d_over_f;
+  return fputil::cast<float16>(
+      fputil::multiply_add(static_cast<float>(m), LOGF_2, log_1_mant));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lrint.cpp b/src/math/generic/lrint.cpp
index 59fde7b..eae9bc1 100644
--- a/src/math/generic/lrint.cpp
+++ b/src/math/generic/lrint.cpp
@@ -9,12 +9,13 @@
 #include "src/math/lrint.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrint, (double x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<double,
                                                                      long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lrintf.cpp b/src/math/generic/lrintf.cpp
index e92014c..e08c87c 100644
--- a/src/math/generic/lrintf.cpp
+++ b/src/math/generic/lrintf.cpp
@@ -9,12 +9,13 @@
 #include "src/math/lrintf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintf, (float x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float,
                                                                      long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lrintf128.cpp b/src/math/generic/lrintf128.cpp
index 8e06062..15ecded 100644
--- a/src/math/generic/lrintf128.cpp
+++ b/src/math/generic/lrintf128.cpp
@@ -9,12 +9,13 @@
 #include "src/math/lrintf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintf128, (float128 x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float128,
                                                                      long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lrintf16.cpp b/src/math/generic/lrintf16.cpp
index d49be28..92af687 100644
--- a/src/math/generic/lrintf16.cpp
+++ b/src/math/generic/lrintf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/lrintf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintf16, (float16 x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<float16,
                                                                      long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lrintl.cpp b/src/math/generic/lrintl.cpp
index b363aac..d881aee 100644
--- a/src/math/generic/lrintl.cpp
+++ b/src/math/generic/lrintl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/lrintl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintl, (long double x)) {
   return fputil::round_to_signed_integer_using_current_rounding_mode<
       long double, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lround.cpp b/src/math/generic/lround.cpp
index a22d872..b208457 100644
--- a/src/math/generic/lround.cpp
+++ b/src/math/generic/lround.cpp
@@ -9,11 +9,12 @@
 #include "src/math/lround.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lround, (double x)) {
   return fputil::round_to_signed_integer<double, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lroundf.cpp b/src/math/generic/lroundf.cpp
index 40c1323..1e1a948 100644
--- a/src/math/generic/lroundf.cpp
+++ b/src/math/generic/lroundf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/lroundf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lroundf, (float x)) {
   return fputil::round_to_signed_integer<float, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lroundf128.cpp b/src/math/generic/lroundf128.cpp
index f93c475..89b15f5 100644
--- a/src/math/generic/lroundf128.cpp
+++ b/src/math/generic/lroundf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/lroundf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lroundf128, (float128 x)) {
   return fputil::round_to_signed_integer<float128, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lroundf16.cpp b/src/math/generic/lroundf16.cpp
index db8113d..d25bc84 100644
--- a/src/math/generic/lroundf16.cpp
+++ b/src/math/generic/lroundf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/lroundf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lroundf16, (float16 x)) {
   return fputil::round_to_signed_integer<float16, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/lroundl.cpp b/src/math/generic/lroundl.cpp
index c0c3bde..efcf3da 100644
--- a/src/math/generic/lroundl.cpp
+++ b/src/math/generic/lroundl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/lroundl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lroundl, (long double x)) {
   return fputil::round_to_signed_integer<long double, long>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/modf.cpp b/src/math/generic/modf.cpp
index d465d19..ce56aa0 100644
--- a/src/math/generic/modf.cpp
+++ b/src/math/generic/modf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/modf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, modf, (double x, double *iptr)) {
   return fputil::modf(x, *iptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/modff.cpp b/src/math/generic/modff.cpp
index daa6697..c86a4fb 100644
--- a/src/math/generic/modff.cpp
+++ b/src/math/generic/modff.cpp
@@ -9,11 +9,12 @@
 #include "src/math/modff.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, modff, (float x, float *iptr)) {
   return fputil::modf(x, *iptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/modff128.cpp b/src/math/generic/modff128.cpp
index 6aef5f5..6f519a6 100644
--- a/src/math/generic/modff128.cpp
+++ b/src/math/generic/modff128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/modff128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, modff128, (float128 x, float128 *iptr)) {
   return fputil::modf(x, *iptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/modff16.cpp b/src/math/generic/modff16.cpp
index 50cc5b5..853fc55 100644
--- a/src/math/generic/modff16.cpp
+++ b/src/math/generic/modff16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/modff16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, modff16, (float16 x, float16 *iptr)) {
   return fputil::modf(x, *iptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/modfl.cpp b/src/math/generic/modfl.cpp
index 3271da2..8c9ab48 100644
--- a/src/math/generic/modfl.cpp
+++ b/src/math/generic/modfl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/modfl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, modfl, (long double x, long double *iptr)) {
   return fputil::modf(x, *iptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nan.cpp b/src/math/generic/nan.cpp
index c0d7fbf..f92cd3f 100644
--- a/src/math/generic/nan.cpp
+++ b/src/math/generic/nan.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/nan.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nan, (const char *arg)) {
   auto result = internal::strtonan<double>(arg);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(double, nan, (const char *arg)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nanf.cpp b/src/math/generic/nanf.cpp
index 2751a81..7287182 100644
--- a/src/math/generic/nanf.cpp
+++ b/src/math/generic/nanf.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/nanf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nanf, (const char *arg)) {
   auto result = internal::strtonan<float>(arg);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(float, nanf, (const char *arg)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nanf128.cpp b/src/math/generic/nanf128.cpp
index f087c9f..3d8581a 100644
--- a/src/math/generic/nanf128.cpp
+++ b/src/math/generic/nanf128.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/nanf128.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, nanf128, (const char *arg)) {
   auto result = internal::strtonan<float128>(arg);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(float128, nanf128, (const char *arg)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nanf16.cpp b/src/math/generic/nanf16.cpp
index c42cd25..27d9d16 100644
--- a/src/math/generic/nanf16.cpp
+++ b/src/math/generic/nanf16.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/nanf16.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nanf16, (const char *arg)) {
   auto result = internal::strtonan<float16>(arg);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(float16, nanf16, (const char *arg)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nanl.cpp b/src/math/generic/nanl.cpp
index 76dcb56..4f698cb 100644
--- a/src/math/generic/nanl.cpp
+++ b/src/math/generic/nanl.cpp
@@ -8,10 +8,11 @@
 
 #include "src/math/nanl.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nanl, (const char *arg)) {
   auto result = internal::strtonan<long double>(arg);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(long double, nanl, (const char *arg)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nearbyint.cpp b/src/math/generic/nearbyint.cpp
index 20cbf6c..5662d66 100644
--- a/src/math/generic/nearbyint.cpp
+++ b/src/math/generic/nearbyint.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nearbyint.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nearbyint, (double x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nearbyintf.cpp b/src/math/generic/nearbyintf.cpp
index 5fb1033..9b8db08 100644
--- a/src/math/generic/nearbyintf.cpp
+++ b/src/math/generic/nearbyintf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nearbyintf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nearbyintf, (float x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nearbyintf128.cpp b/src/math/generic/nearbyintf128.cpp
index fca3587..95038b8 100644
--- a/src/math/generic/nearbyintf128.cpp
+++ b/src/math/generic/nearbyintf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nearbyintf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, nearbyintf128, (float128 x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nearbyintf16.cpp b/src/math/generic/nearbyintf16.cpp
index efd31e9..1e6229b 100644
--- a/src/math/generic/nearbyintf16.cpp
+++ b/src/math/generic/nearbyintf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nearbyintf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nearbyintf16, (float16 x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nearbyintl.cpp b/src/math/generic/nearbyintl.cpp
index 9cbff01..79ee73c 100644
--- a/src/math/generic/nearbyintl.cpp
+++ b/src/math/generic/nearbyintl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nearbyintl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nearbyintl, (long double x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextafter.cpp b/src/math/generic/nextafter.cpp
index 57a58b1..ff35c86 100644
--- a/src/math/generic/nextafter.cpp
+++ b/src/math/generic/nextafter.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextafter.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nextafter, (double x, double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextafterf.cpp b/src/math/generic/nextafterf.cpp
index dd09fb7..fd8ca02 100644
--- a/src/math/generic/nextafterf.cpp
+++ b/src/math/generic/nextafterf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextafterf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nextafterf, (float x, float y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextafterf128.cpp b/src/math/generic/nextafterf128.cpp
index 905c890..c774f10 100644
--- a/src/math/generic/nextafterf128.cpp
+++ b/src/math/generic/nextafterf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextafterf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, nextafterf128, (float128 x, float128 y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextafterf16.cpp b/src/math/generic/nextafterf16.cpp
index 144b3fc..70adc9c 100644
--- a/src/math/generic/nextafterf16.cpp
+++ b/src/math/generic/nextafterf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextafterf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nextafterf16, (float16 x, float16 y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextafterl.cpp b/src/math/generic/nextafterl.cpp
index e12ad04..5dafd63 100644
--- a/src/math/generic/nextafterl.cpp
+++ b/src/math/generic/nextafterl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextafterl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nextafterl, (long double x, long double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextdown.cpp b/src/math/generic/nextdown.cpp
index 51dee48..90a9143 100644
--- a/src/math/generic/nextdown.cpp
+++ b/src/math/generic/nextdown.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextdown.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nextdown, (double x)) {
   return fputil::nextupdown</*IsDown=*/true>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextdownf.cpp b/src/math/generic/nextdownf.cpp
index 857b412..282ebfd 100644
--- a/src/math/generic/nextdownf.cpp
+++ b/src/math/generic/nextdownf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextdownf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nextdownf, (float x)) {
   return fputil::nextupdown</*IsDown=*/true>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextdownf128.cpp b/src/math/generic/nextdownf128.cpp
index 2585a13..1557e33 100644
--- a/src/math/generic/nextdownf128.cpp
+++ b/src/math/generic/nextdownf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextdownf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, nextdownf128, (float128 x)) {
   return fputil::nextupdown</*IsDown=*/true>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextdownf16.cpp b/src/math/generic/nextdownf16.cpp
index 9fdaa9d..2573fbf 100644
--- a/src/math/generic/nextdownf16.cpp
+++ b/src/math/generic/nextdownf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextdownf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nextdownf16, (float16 x)) {
   return fputil::nextupdown</*IsDown=*/true>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextdownl.cpp b/src/math/generic/nextdownl.cpp
index 06a09c9..476c5f3 100644
--- a/src/math/generic/nextdownl.cpp
+++ b/src/math/generic/nextdownl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextdownl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nextdownl, (long double x)) {
   return fputil::nextupdown</*IsDown=*/true>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nexttoward.cpp b/src/math/generic/nexttoward.cpp
index ce3e4e6..7102a0a 100644
--- a/src/math/generic/nexttoward.cpp
+++ b/src/math/generic/nexttoward.cpp
@@ -9,8 +9,9 @@
 #include "src/math/nexttoward.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nexttoward, (double x, long double y)) {
   // We can reuse the nextafter implementation because the internal nextafter is
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(double, nexttoward, (double x, long double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nexttowardf.cpp b/src/math/generic/nexttowardf.cpp
index 3b0762c..095a7af 100644
--- a/src/math/generic/nexttowardf.cpp
+++ b/src/math/generic/nexttowardf.cpp
@@ -9,8 +9,9 @@
 #include "src/math/nexttowardf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nexttowardf, (float x, long double y)) {
   // We can reuse the nextafter implementation because the internal nextafter is
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(float, nexttowardf, (float x, long double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nexttowardf16.cpp b/src/math/generic/nexttowardf16.cpp
index d1d78e8..75218b1 100644
--- a/src/math/generic/nexttowardf16.cpp
+++ b/src/math/generic/nexttowardf16.cpp
@@ -9,8 +9,9 @@
 #include "src/math/nexttowardf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nexttowardf16, (float16 x, long double y)) {
   // We can reuse the nextafter implementation because the internal nextafter is
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(float16, nexttowardf16, (float16 x, long double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nexttowardl.cpp b/src/math/generic/nexttowardl.cpp
index e9f7f83..b208689 100644
--- a/src/math/generic/nexttowardl.cpp
+++ b/src/math/generic/nexttowardl.cpp
@@ -9,8 +9,9 @@
 #include "src/math/nexttowardl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nexttowardl, (long double x, long double y)) {
   // We can reuse the nextafter implementation because the internal nextafter is
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(long double, nexttowardl, (long double x, long double y)) {
   return fputil::nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextup.cpp b/src/math/generic/nextup.cpp
index d75a336..ac06824 100644
--- a/src/math/generic/nextup.cpp
+++ b/src/math/generic/nextup.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextup.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nextup, (double x)) {
   return fputil::nextupdown</*IsDown=*/false>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextupf.cpp b/src/math/generic/nextupf.cpp
index 3b18dae..10a4b03 100644
--- a/src/math/generic/nextupf.cpp
+++ b/src/math/generic/nextupf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextupf.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nextupf, (float x)) {
   return fputil::nextupdown</*IsDown=*/false>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextupf128.cpp b/src/math/generic/nextupf128.cpp
index 7d862c3..c380f0d 100644
--- a/src/math/generic/nextupf128.cpp
+++ b/src/math/generic/nextupf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextupf128.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, nextupf128, (float128 x)) {
   return fputil::nextupdown</*IsDown=*/false>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextupf16.cpp b/src/math/generic/nextupf16.cpp
index 5d3d52c..5588480 100644
--- a/src/math/generic/nextupf16.cpp
+++ b/src/math/generic/nextupf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextupf16.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, nextupf16, (float16 x)) {
   return fputil::nextupdown</*IsDown=*/false>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/nextupl.cpp b/src/math/generic/nextupl.cpp
index ccc5244..e4ef195 100644
--- a/src/math/generic/nextupl.cpp
+++ b/src/math/generic/nextupl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/nextupl.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, nextupl, (long double x)) {
   return fputil::nextupdown</*IsDown=*/false>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/pow.cpp b/src/math/generic/pow.cpp
new file mode 100644
index 0000000..213dbd9
--- /dev/null
+++ b/src/math/generic/pow.cpp
@@ -0,0 +1,529 @@
+//===-- Double-precision x^y function -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/pow.h"
+#include "common_constants.h" // Lookup tables EXP_M1 and EXP_M2.
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/FPUtil/sqrt.h" // Speedup for pow(x, 1/2) = sqrt(x)
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+namespace LIBC_NAMESPACE_DECL {
+
+using fputil::DoubleDouble;
+
+namespace {
+
+// Constants for log2(x) range reduction, generated by Sollya with:
+// > for i from 0 to 127 do {
+//     r = 2^-8 * ceil( 2^8 * (1 - 2^(-8)) / (1 + i*2^-7) );
+//     b = nearestint(log2(r) * 2^41) * 2^-41;
+//     c = round(log2(r) - b, D, RN);
+//     print("{", -c, ",", -b, "},");
+//   };
+// This is the same as -log2(RD[i]), with the least significant bits of the
+// high part set to be 2^-41, so that the sum of high parts + e_x is exact in
+// double precision.
+// We also replace the first and the last ones to be 0.
+constexpr DoubleDouble LOG2_R_DD[128] = {
+    {0.0, 0.0},
+    {-0x1.19b14945cf6bap-44, 0x1.72c7ba21p-7},
+    {-0x1.95539356f93dcp-43, 0x1.743ee862p-6},
+    {0x1.abe0a48f83604p-43, 0x1.184b8e4c5p-5},
+    {0x1.635577970e04p-43, 0x1.77394c9d9p-5},
+    {-0x1.401fbaaa67e3cp-45, 0x1.d6ebd1f2p-5},
+    {-0x1.5b1799ceaeb51p-43, 0x1.1bb32a6008p-4},
+    {0x1.7c407050799bfp-43, 0x1.4c560fe688p-4},
+    {0x1.da6339da288fcp-43, 0x1.7d60496cf8p-4},
+    {0x1.be4f6f22dbbadp-43, 0x1.960caf9ab8p-4},
+    {-0x1.c760bc9b188c4p-45, 0x1.c7b528b71p-4},
+    {0x1.164e932b2d51cp-44, 0x1.f9c95dc1dp-4},
+    {0x1.924ae921f7ecap-45, 0x1.097e38ce6p-3},
+    {-0x1.6d25a5b8a19b2p-44, 0x1.22dadc2ab4p-3},
+    {0x1.e50a1644ac794p-43, 0x1.3c6fb650ccp-3},
+    {0x1.f34baa74a7942p-43, 0x1.494f863b8cp-3},
+    {-0x1.8f7aac147fdc1p-46, 0x1.633a8bf438p-3},
+    {0x1.f84be19cb9578p-43, 0x1.7046031c78p-3},
+    {-0x1.66cccab240e9p-46, 0x1.8a8980abfcp-3},
+    {-0x1.3f7a55cd2af4cp-47, 0x1.97c1cb13c8p-3},
+    {0x1.3458cde69308cp-43, 0x1.b2602497d4p-3},
+    {-0x1.667f21fa8423fp-44, 0x1.bfc67a8p-3},
+    {0x1.d2fe4574e09b9p-47, 0x1.dac22d3e44p-3},
+    {0x1.367bde40c5e6dp-43, 0x1.e857d3d36p-3},
+    {0x1.d45da26510033p-46, 0x1.01d9bbcfa6p-2},
+    {-0x1.7204f55bbf90dp-44, 0x1.08bce0d96p-2},
+    {-0x1.d4f1b95e0ff45p-43, 0x1.169c05364p-2},
+    {0x1.c20d74c0211bfp-44, 0x1.1d982c9d52p-2},
+    {0x1.ad89a083e072ap-43, 0x1.249cd2b13cp-2},
+    {0x1.cd0cb4492f1bcp-43, 0x1.32bfee370ep-2},
+    {-0x1.2101a9685c779p-47, 0x1.39de8e155ap-2},
+    {0x1.9451cd394fe8dp-43, 0x1.4106017c3ep-2},
+    {0x1.661e393a16b95p-44, 0x1.4f6fbb2cecp-2},
+    {-0x1.c6d8d86531d56p-44, 0x1.56b22e6b58p-2},
+    {0x1.c1c885adb21d3p-43, 0x1.5dfdcf1eeap-2},
+    {0x1.3bb5921006679p-45, 0x1.6552b49986p-2},
+    {0x1.1d406db502403p-43, 0x1.6cb0f6865cp-2},
+    {0x1.55a63e278bad5p-43, 0x1.7b89f02cf2p-2},
+    {-0x1.66ae2a7ada553p-49, 0x1.8304d90c12p-2},
+    {-0x1.66cccab240e9p-45, 0x1.8a8980abfcp-2},
+    {-0x1.62404772a151dp-45, 0x1.921800924ep-2},
+    {0x1.ac9bca36fd02ep-44, 0x1.99b072a96cp-2},
+    {0x1.4bc302ffa76fbp-43, 0x1.a8ff97181p-2},
+    {0x1.01fea1ec47c71p-43, 0x1.b0b67f4f46p-2},
+    {-0x1.f20203b3186a6p-43, 0x1.b877c57b1cp-2},
+    {-0x1.2642415d47384p-45, 0x1.c043859e3p-2},
+    {-0x1.bc76a2753b99bp-50, 0x1.c819dc2d46p-2},
+    {-0x1.da93ae3a5f451p-43, 0x1.cffae611aep-2},
+    {-0x1.50e785694a8c6p-43, 0x1.d7e6c0abc4p-2},
+    {0x1.c56138c894641p-43, 0x1.dfdd89d586p-2},
+    {0x1.5669df6a2b592p-43, 0x1.e7df5fe538p-2},
+    {-0x1.ea92d9e0e8ac2p-48, 0x1.efec61b012p-2},
+    {0x1.a0331af2e6feap-43, 0x1.f804ae8d0cp-2},
+    {0x1.9518ce032f41dp-48, 0x1.0014332bep-1},
+    {-0x1.b3b3864c60011p-44, 0x1.042bd4b9a8p-1},
+    {-0x1.103e8f00d41c8p-45, 0x1.08494c66b9p-1},
+    {0x1.65be75cc3da17p-43, 0x1.0c6caaf0c5p-1},
+    {0x1.3676289cd3dd4p-43, 0x1.1096015deep-1},
+    {-0x1.41dfc7d7c3321p-43, 0x1.14c560fe69p-1},
+    {0x1.e0cda8bd74461p-44, 0x1.18fadb6e2dp-1},
+    {0x1.2a606046ad444p-44, 0x1.1d368296b5p-1},
+    {0x1.f9ea977a639cp-43, 0x1.217868b0c3p-1},
+    {-0x1.50520a377c7ecp-45, 0x1.25c0a0463cp-1},
+    {0x1.6e3cb71b554e7p-47, 0x1.2a0f3c3407p-1},
+    {-0x1.4275f1035e5e8p-48, 0x1.2e644fac05p-1},
+    {-0x1.4275f1035e5e8p-48, 0x1.2e644fac05p-1},
+    {-0x1.979a5db68721dp-45, 0x1.32bfee370fp-1},
+    {0x1.1ee969a95f529p-43, 0x1.37222bb707p-1},
+    {0x1.bb4b69336b66ep-43, 0x1.3b8b1c68fap-1},
+    {0x1.d5e6a8a4fb059p-45, 0x1.3ffad4e74fp-1},
+    {0x1.3106e404cabb7p-44, 0x1.44716a2c08p-1},
+    {0x1.3106e404cabb7p-44, 0x1.44716a2c08p-1},
+    {-0x1.9bcaf1aa4168ap-43, 0x1.48eef19318p-1},
+    {0x1.1646b761c48dep-44, 0x1.4d7380dcc4p-1},
+    {0x1.2f0c0bfe9dbecp-43, 0x1.51ff2e3021p-1},
+    {0x1.29904613e33cp-43, 0x1.5692101d9bp-1},
+    {0x1.1d406db502403p-44, 0x1.5b2c3da197p-1},
+    {0x1.1d406db502403p-44, 0x1.5b2c3da197p-1},
+    {-0x1.125d6cbcd1095p-44, 0x1.5fcdce2728p-1},
+    {-0x1.bd9b32266d92cp-43, 0x1.6476d98adap-1},
+    {0x1.54243b21709cep-44, 0x1.6927781d93p-1},
+    {0x1.54243b21709cep-44, 0x1.6927781d93p-1},
+    {-0x1.ce60916e52e91p-44, 0x1.6ddfc2a79p-1},
+    {0x1.f1f5ae718f241p-43, 0x1.729fd26b7p-1},
+    {-0x1.6eb9612e0b4f3p-43, 0x1.7767c12968p-1},
+    {-0x1.6eb9612e0b4f3p-43, 0x1.7767c12968p-1},
+    {0x1.fed21f9cb2cc5p-43, 0x1.7c37a9227ep-1},
+    {0x1.7f5dc57266758p-43, 0x1.810fa51bf6p-1},
+    {0x1.7f5dc57266758p-43, 0x1.810fa51bf6p-1},
+    {0x1.5b338360c2ae2p-43, 0x1.85efd062c6p-1},
+    {-0x1.96fc8f4b56502p-43, 0x1.8ad846cf37p-1},
+    {-0x1.96fc8f4b56502p-43, 0x1.8ad846cf37p-1},
+    {-0x1.bdc81c4db3134p-44, 0x1.8fc924c89bp-1},
+    {0x1.36c101ee1344p-43, 0x1.94c287492cp-1},
+    {0x1.36c101ee1344p-43, 0x1.94c287492cp-1},
+    {0x1.e41fa0a62e6aep-44, 0x1.99c48be206p-1},
+    {-0x1.d97ee9124773bp-46, 0x1.9ecf50bf44p-1},
+    {-0x1.d97ee9124773bp-46, 0x1.9ecf50bf44p-1},
+    {-0x1.3f94e00e7d6bcp-46, 0x1.a3e2f4ac44p-1},
+    {-0x1.6879fa00b120ap-43, 0x1.a8ff971811p-1},
+    {-0x1.6879fa00b120ap-43, 0x1.a8ff971811p-1},
+    {0x1.1659d8e2d7d38p-44, 0x1.ae255819fp-1},
+    {0x1.1e5e0ae0d3f8ap-43, 0x1.b35458761dp-1},
+    {0x1.1e5e0ae0d3f8ap-43, 0x1.b35458761dp-1},
+    {0x1.484a15babcf88p-43, 0x1.b88cb9a2abp-1},
+    {0x1.484a15babcf88p-43, 0x1.b88cb9a2abp-1},
+    {0x1.871a7610e40bdp-45, 0x1.bdce9dcc96p-1},
+    {-0x1.2d90e5edaeceep-43, 0x1.c31a27dd01p-1},
+    {-0x1.2d90e5edaeceep-43, 0x1.c31a27dd01p-1},
+    {-0x1.5dd31d962d373p-43, 0x1.c86f7b7ea5p-1},
+    {-0x1.5dd31d962d373p-43, 0x1.c86f7b7ea5p-1},
+    {-0x1.9ad57391924a7p-43, 0x1.cdcebd2374p-1},
+    {-0x1.3167ccc538261p-44, 0x1.d338120a6ep-1},
+    {-0x1.3167ccc538261p-44, 0x1.d338120a6ep-1},
+    {0x1.c7a4ff65ddbc9p-45, 0x1.d8aba045bp-1},
+    {0x1.c7a4ff65ddbc9p-45, 0x1.d8aba045bp-1},
+    {-0x1.f9ab3cf74babap-44, 0x1.de298ec0bbp-1},
+    {-0x1.f9ab3cf74babap-44, 0x1.de298ec0bbp-1},
+    {0x1.52842c1c1e586p-43, 0x1.e3b20546f5p-1},
+    {0x1.52842c1c1e586p-43, 0x1.e3b20546f5p-1},
+    {0x1.3c6764fc87b4ap-48, 0x1.e9452c8a71p-1},
+    {0x1.3c6764fc87b4ap-48, 0x1.e9452c8a71p-1},
+    {-0x1.a0976c0a2827dp-44, 0x1.eee32e2aedp-1},
+    {-0x1.a0976c0a2827dp-44, 0x1.eee32e2aedp-1},
+    {-0x1.a45314dc4fc42p-43, 0x1.f48c34bd1fp-1},
+    {-0x1.a45314dc4fc42p-43, 0x1.f48c34bd1fp-1},
+    {0x1.ef5d00e390ap-44, 0x1.fa406bd244p-1},
+    {0.0, 1.0},
+};
+
+bool is_odd_integer(double x) {
+  using FPBits = fputil::FPBits<double>;
+  FPBits xbits(x);
+  uint64_t x_u = xbits.uintval();
+  unsigned x_e = static_cast<unsigned>(xbits.get_biased_exponent());
+  unsigned lsb =
+      static_cast<unsigned>(cpp::countr_zero(x_u | FPBits::EXP_MASK));
+  constexpr unsigned UNIT_EXPONENT =
+      static_cast<unsigned>(FPBits::EXP_BIAS + FPBits::FRACTION_LEN);
+  return (x_e + lsb == UNIT_EXPONENT);
+}
+
+bool is_integer(double x) {
+  using FPBits = fputil::FPBits<double>;
+  FPBits xbits(x);
+  uint64_t x_u = xbits.uintval();
+  unsigned x_e = static_cast<unsigned>(xbits.get_biased_exponent());
+  unsigned lsb =
+      static_cast<unsigned>(cpp::countr_zero(x_u | FPBits::EXP_MASK));
+  constexpr unsigned UNIT_EXPONENT =
+      static_cast<unsigned>(FPBits::EXP_BIAS + FPBits::FRACTION_LEN);
+  return (x_e + lsb >= UNIT_EXPONENT);
+}
+
+} // namespace
+
+LLVM_LIBC_FUNCTION(double, pow, (double x, double y)) {
+  using FPBits = fputil::FPBits<double>;
+
+  FPBits xbits(x), ybits(y);
+
+  bool x_sign = xbits.sign() == Sign::NEG;
+  bool y_sign = ybits.sign() == Sign::NEG;
+
+  FPBits x_abs = xbits.abs();
+  FPBits y_abs = ybits.abs();
+
+  uint64_t x_mant = xbits.get_mantissa();
+  uint64_t y_mant = ybits.get_mantissa();
+  uint64_t x_u = xbits.uintval();
+  uint64_t x_a = x_abs.uintval();
+  uint64_t y_a = y_abs.uintval();
+
+  double e_x = static_cast<double>(xbits.get_exponent());
+  uint64_t sign = 0;
+
+  ///////// BEGIN - Check exceptional cases ////////////////////////////////////
+
+  // The double precision number that is closest to 1 is (1 - 2^-53), which has
+  //   log2(1 - 2^-53) ~ -1.715...p-53.
+  // So if |y| > |1075 / log2(1 - 2^-53)|, and x is finite:
+  //   |y * log2(x)| = 0 or > 1075.
+  // Hence x^y will either overflow or underflow if x is not zero.
+  if (LIBC_UNLIKELY(y_mant == 0 || y_a > 0x43d7'4910'd52d'3052 ||
+                    x_u == FPBits::one().uintval() ||
+                    x_u >= FPBits::inf().uintval() ||
+                    x_u < FPBits::min_normal().uintval())) {
+    // Exceptional exponents.
+    if (y == 0.0)
+      return 1.0;
+
+    switch (y_a) {
+    case 0x3fe0'0000'0000'0000: { // y = +-0.5
+      // TODO: speed up x^(-1/2) with rsqrt(x) when available.
+      if (LIBC_UNLIKELY(
+              (x == 0.0 || x_u == FPBits::inf(Sign::NEG).uintval()))) {
+        // pow(-0, 1/2) = +0
+        // pow(-inf, 1/2) = +inf
+        // Make sure it works correctly for FTZ/DAZ.
+        return y_sign ? 1.0 / (x * x) : (x * x);
+      }
+      return y_sign ? (1.0 / fputil::sqrt<double>(x)) : fputil::sqrt<double>(x);
+    }
+    case 0x3ff0'0000'0000'0000: // y = +-1.0
+      return y_sign ? (1.0 / x) : x;
+    case 0x4000'0000'0000'0000: // y = +-2.0;
+      return y_sign ? (1.0 / (x * x)) : (x * x);
+    }
+
+    // |y| > |1075 / log2(1 - 2^-53)|.
+    if (y_a > 0x43d7'4910'd52d'3052) {
+      if (y_a >= 0x7ff0'0000'0000'0000) {
+        // y is inf or nan
+        if (y_mant != 0) {
+          // y is NaN
+          // pow(1, NaN) = 1
+          // pow(x, NaN) = NaN
+          return (x_u == FPBits::one().uintval()) ? 1.0 : y;
+        }
+
+        // Now y is +-Inf
+        if (x_abs.is_nan()) {
+          // pow(NaN, +-Inf) = NaN
+          return x;
+        }
+
+        if (x_a == 0x3ff0'0000'0000'0000) {
+          // pow(+-1, +-Inf) = 1.0
+          return 1.0;
+        }
+
+        if (x == 0.0 && y_sign) {
+          // pow(+-0, -Inf) = +inf and raise FE_DIVBYZERO
+          fputil::set_errno_if_required(EDOM);
+          fputil::raise_except_if_required(FE_DIVBYZERO);
+          return FPBits::inf().get_val();
+        }
+        // pow (|x| < 1, -inf) = +inf
+        // pow (|x| < 1, +inf) = 0.0
+        // pow (|x| > 1, -inf) = 0.0
+        // pow (|x| > 1, +inf) = +inf
+        return ((x_a < FPBits::one().uintval()) == y_sign)
+                   ? FPBits::inf().get_val()
+                   : 0.0;
+      }
+      // x^y will overflow / underflow in double precision.  Set y to a
+      // large enough exponent but not too large, so that the computations
+      // won't overflow in double precision.
+      y = y_sign ? -0x1.0p100 : 0x1.0p100;
+    }
+
+    // y is finite and non-zero.
+
+    if (x_u == FPBits::one().uintval()) {
+      // pow(1, y) = 1
+      return 1.0;
+    }
+
+    // TODO: Speed things up with pow(2, y) = exp2(y) and pow(10, y) = exp10(y).
+
+    if (x == 0.0) {
+      bool out_is_neg = x_sign && is_odd_integer(y);
+      if (y_sign) {
+        // pow(0, negative number) = inf
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_DIVBYZERO);
+        return FPBits::inf(out_is_neg ? Sign::NEG : Sign::POS).get_val();
+      }
+      // pow(0, positive number) = 0
+      return out_is_neg ? -0.0 : 0.0;
+    }
+
+    if (x_a == FPBits::inf().uintval()) {
+      bool out_is_neg = x_sign && is_odd_integer(y);
+      if (y_sign)
+        return out_is_neg ? -0.0 : 0.0;
+      return FPBits::inf(out_is_neg ? Sign::NEG : Sign::POS).get_val();
+    }
+
+    if (x_a > FPBits::inf().uintval()) {
+      // x is NaN.
+      // pow (aNaN, 0) is already taken care above.
+      return x;
+    }
+
+    // Normalize denormal inputs.
+    if (x_a < FPBits::min_normal().uintval()) {
+      e_x -= 64.0;
+      x_mant = FPBits(x * 0x1.0p64).get_mantissa();
+    }
+
+    // x is finite and negative, and y is a finite integer.
+    if (x_sign) {
+      if (is_integer(y)) {
+        x = -x;
+        if (is_odd_integer(y))
+          // sign = -1.0;
+          sign = 0x8000'0000'0000'0000;
+      } else {
+        // pow( negative, non-integer ) = NaN
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+    }
+  }
+
+  ///////// END - Check exceptional cases //////////////////////////////////////
+
+  // x^y = 2^( y * log2(x) )
+  //     = 2^( y * ( e_x + log2(m_x) ) )
+  // First we compute log2(x) = e_x + log2(m_x)
+
+  // Extract exponent field of x.
+
+  // Use the highest 7 fractional bits of m_x as the index for look up tables.
+  unsigned idx_x = static_cast<unsigned>(x_mant >> (FPBits::FRACTION_LEN - 7));
+  // Add the hidden bit to the mantissa.
+  // 1 <= m_x < 2
+  FPBits m_x = FPBits(x_mant | 0x3ff0'0000'0000'0000);
+
+  // Reduced argument for log2(m_x):
+  //   dx = r * m_x - 1.
+  // The computation is exact, and -2^-8 <= dx < 2^-7.
+  // Then m_x = (1 + dx) / r, and
+  //   log2(m_x) = log2( (1 + dx) / r )
+  //             = log2(1 + dx) - log2(r).
+
+  // In order for the overall computations x^y = 2^(y * log2(x)) to have the
+  // relative errors < 2^-52 (1ULP), we will need to evaluate the exponent part
+  // y * log2(x) with absolute errors < 2^-52 (or better, 2^-53).  Since the
+  // whole exponent range for double precision is bounded by
+  // |y * log2(x)| < 1076 ~ 2^10, we need to evaluate log2(x) with absolute
+  // errors < 2^-53 * 2^-10 = 2^-63.
+
+  // With that requirement, we use the following degree-6 polynomial
+  // approximation:
+  //   P(dx) ~ log2(1 + dx) / dx
+  // Generated by Sollya with:
+  // > P = fpminimax(log2(1 + x)/x, 6, [|D...|], [-2^-8, 2^-7]); P;
+  // > dirtyinfnorm(log2(1 + x) - x*P, [-2^-8, 2^-7]);
+  //   0x1.d03cc...p-66
+  constexpr double COEFFS[] = {0x1.71547652b82fep0,  -0x1.71547652b82e7p-1,
+                               0x1.ec709dc3b1fd5p-2, -0x1.7154766124215p-2,
+                               0x1.2776bd90259d8p-2, -0x1.ec586c6f3d311p-3,
+                               0x1.9c4775eccf524p-3};
+  // Error: ulp(dx^2) <= (2^-7)^2 * 2^-52 = 2^-66
+  // Extra errors from various computations and rounding directions, the overall
+  // errors we can be bounded by 2^-65.
+
+  double dx;
+  DoubleDouble dx_c0;
+
+  // Perform exact range reduction and exact product dx * c0.
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+  dx = fputil::multiply_add(RD[idx_x], m_x.get_val(), -1.0); // Exact
+  dx_c0 = fputil::exact_mult(COEFFS[0], dx);
+#else
+  double c = FPBits(m_x.uintval() & 0x3fff'e000'0000'0000).get_val();
+  dx = fputil::multiply_add(RD[idx_x], m_x.get_val() - c, CD[idx_x]); // Exact
+  dx_c0 = fputil::exact_mult<28>(dx, COEFFS[0]);                      // Exact
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+  double dx2 = dx * dx;
+  double c0 = fputil::multiply_add(dx, COEFFS[2], COEFFS[1]);
+  double c1 = fputil::multiply_add(dx, COEFFS[4], COEFFS[3]);
+  double c2 = fputil::multiply_add(dx, COEFFS[6], COEFFS[5]);
+
+  double p = fputil::polyeval(dx2, c0, c1, c2);
+
+  // s = e_x - log2(r) + dx * P(dx)
+  // Absolute error bound:
+  //   |log2(x) - log2_x.hi - log2_x.lo| < 2^-65.
+
+  // Notice that e_x - log2(r).hi is exact, so we perform an exact sum of
+  // e_x - log2(r).hi and the high part of the product dx * c0:
+  //   log2_x_hi.hi + log2_x_hi.lo = e_x - log2(r).hi + (dx * c0).hi
+  DoubleDouble log2_x_hi =
+      fputil::exact_add(e_x + LOG2_R_DD[idx_x].hi, dx_c0.hi);
+  // The low part is dx^2 * p + low part of (dx * c0) + low part of -log2(r).
+  double log2_x_lo =
+      fputil::multiply_add(dx2, p, dx_c0.lo + LOG2_R_DD[idx_x].lo);
+  // Perform accurate sums.
+  DoubleDouble log2_x = fputil::exact_add(log2_x_hi.hi, log2_x_lo);
+  log2_x.lo += log2_x_hi.lo;
+
+  // To compute 2^(y * log2(x)), we break the exponent into 3 parts:
+  //   y * log(2) = hi + mid + lo, where
+  //   hi is an integer
+  //   mid * 2^6 is an integer
+  //   |lo| <= 2^-7
+  // Then:
+  //   x^y = 2^(y * log2(x)) = 2^hi * 2^mid * 2^lo,
+  // In which 2^mid is obtained from a look-up table of size 2^6 = 64 elements,
+  // and 2^lo ~ 1 + lo * P(lo).
+  // Thus, we have:
+  //   hi + mid = 2^-6 * round( 2^6 * y * log2(x) )
+  // If we restrict the output such that |hi| < 150, (hi + mid) uses (8 + 6)
+  // bits, hence, if we use double precision to perform
+  //   round( 2^6 * y * log2(x))
+  // the lo part is bounded by 2^-7 + 2^(-(52 - 14)) = 2^-7 + 2^-38
+
+  // In the following computations:
+  //   y6  = 2^6 * y
+  //   hm  = 2^6 * (hi + mid) = round(2^6 * y * log2(x)) ~ round(y6 * s)
+  //   lo6 = 2^6 * lo = 2^6 * (y - (hi + mid)) = y6 * log2(x) - hm.
+  double y6 = y * 0x1.0p6; // Exact.
+
+  DoubleDouble y6_log2_x = fputil::exact_mult(y6, log2_x.hi);
+  y6_log2_x.lo = fputil::multiply_add(y6, log2_x.lo, y6_log2_x.lo);
+
+  // Check overflow/underflow.
+  double scale = 1.0;
+
+  // |2^(hi + mid) - exp2_hi_mid| <= ulp(exp2_hi_mid) / 2
+  // Clamp the exponent part into smaller range that fits double precision.
+  // For those exponents that are out of range, the final conversion will round
+  // them correctly to inf/max float or 0/min float accordingly.
+  constexpr double UPPER_EXP_BOUND = 512.0 * 0x1.0p6;
+  if (LIBC_UNLIKELY(FPBits(y6_log2_x.hi).abs().get_val() >= UPPER_EXP_BOUND)) {
+    if (FPBits(y6_log2_x.hi).sign() == Sign::POS) {
+      scale = 0x1.0p512;
+      y6_log2_x.hi -= 512.0 * 64.0;
+      if (y6_log2_x.hi > 513.0 * 64.0)
+        y6_log2_x.hi = 513.0 * 64.0;
+    } else {
+      scale = 0x1.0p-512;
+      y6_log2_x.hi += 512.0 * 64.0;
+      if (y6_log2_x.hi < (-1076.0 + 512.0) * 64.0)
+        y6_log2_x.hi = -564.0 * 64.0;
+    }
+  }
+
+  double hm = fputil::nearest_integer(y6_log2_x.hi);
+
+  // lo6 = 2^6 * lo.
+  double lo6_hi = y6_log2_x.hi - hm;
+  double lo6 = lo6_hi + y6_log2_x.lo;
+
+  int hm_i = static_cast<int>(hm);
+  unsigned idx_y = static_cast<unsigned>(hm_i) & 0x3f;
+
+  // 2^hi
+  int64_t exp2_hi_i = static_cast<int64_t>(
+      static_cast<uint64_t>(static_cast<int64_t>(hm_i >> 6))
+      << FPBits::FRACTION_LEN);
+  // 2^mid
+  int64_t exp2_mid_hi_i =
+      static_cast<int64_t>(FPBits(EXP2_MID1[idx_y].hi).uintval());
+  int64_t exp2_mid_lo_i =
+      static_cast<int64_t>(FPBits(EXP2_MID1[idx_y].mid).uintval());
+  // (-1)^sign * 2^hi * 2^mid
+  // Error <= 2^hi * 2^-53
+  uint64_t exp2_hm_hi_i =
+      static_cast<uint64_t>(exp2_hi_i + exp2_mid_hi_i) + sign;
+  // The low part could be 0.
+  uint64_t exp2_hm_lo_i =
+      idx_y != 0 ? static_cast<uint64_t>(exp2_hi_i + exp2_mid_lo_i) + sign
+                 : sign;
+  double exp2_hm_hi = FPBits(exp2_hm_hi_i).get_val();
+  double exp2_hm_lo = FPBits(exp2_hm_lo_i).get_val();
+
+  // Degree-5 polynomial approximation P(lo6) ~ 2^(lo6 / 2^6) = 2^(lo).
+  // Generated by Sollya with:
+  // > P = fpminimax(2^(x/64), 5, [|1, D...|], [-2^-1, 2^-1]);
+  // > dirtyinfnorm(2^(x/64) - P, [-0.5, 0.5]);
+  // 0x1.a2b77e618f5c4c176fd11b7659016cde5de83cb72p-60
+  constexpr double EXP2_COEFFS[] = {0x1p0,
+                                    0x1.62e42fefa39efp-7,
+                                    0x1.ebfbdff82a23ap-15,
+                                    0x1.c6b08d7076268p-23,
+                                    0x1.3b2ad33f8b48bp-31,
+                                    0x1.5d870c4d84445p-40};
+
+  double lo6_sqr = lo6 * lo6;
+
+  double d0 = fputil::multiply_add(lo6, EXP2_COEFFS[2], EXP2_COEFFS[1]);
+  double d1 = fputil::multiply_add(lo6, EXP2_COEFFS[4], EXP2_COEFFS[3]);
+  double pp = fputil::polyeval(lo6_sqr, d0, d1, EXP2_COEFFS[5]);
+
+  double r = fputil::multiply_add(exp2_hm_hi * lo6, pp, exp2_hm_lo);
+  r += exp2_hm_hi;
+
+  return r * scale;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/powf.cpp b/src/math/generic/powf.cpp
index 13c0424..c84ce0d 100644
--- a/src/math/generic/powf.cpp
+++ b/src/math/generic/powf.cpp
@@ -19,14 +19,13 @@
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/FPUtil/sqrt.h" // Speedup for powf(x, 1/2) = sqrtf(x)
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 #include "exp10f_impl.h" // Speedup for powf(10, y) = exp10f(y)
 #include "exp2f_impl.h"  // Speedup for powf(2, y) = exp2f(y)
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using fputil::DoubleDouble;
 using fputil::TripleDouble;
@@ -530,10 +529,10 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   // Hence x^y will either overflow or underflow if x is not zero.
   if (LIBC_UNLIKELY((y_abs & 0x0007'ffff) == 0) || (y_abs > 0x4f170000)) {
     // Exceptional exponents.
-    switch (y_abs) {
-    case 0x0000'0000: { // y = +-0.0f
+    if (y == 0.0f)
       return 1.0f;
-    }
+
+    switch (y_abs) {
     case 0x7f80'0000: { // y = +-Inf
       if (x_abs > 0x7f80'0000) {
         // pow(NaN, +-Inf) = NaN
@@ -543,7 +542,7 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
         // pow(+-1, +-Inf) = 1.0f
         return 1.0f;
       }
-      if (x_abs == 0 && y_u == 0xff80'0000) {
+      if (x == 0.0f && y_u == 0xff80'0000) {
         // pow(+-0, -Inf) = +inf and raise FE_DIVBYZERO
         fputil::set_errno_if_required(EDOM);
         fputil::raise_except_if_required(FE_DIVBYZERO);
@@ -562,7 +561,15 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
       switch (y_u) {
       case 0x3f00'0000: // y = 0.5f
         // pow(x, 1/2) = sqrt(x)
-        return fputil::sqrt<float>(x);
+        if (LIBC_UNLIKELY(x == 0.0f || x_u == 0xff80'0000)) {
+          // pow(-0, 1/2) = +0
+          // pow(-inf, 1/2) = +inf
+          // Make sure it is correct for FTZ/DAZ.
+          return x * x;
+        }
+        float r;
+        r = fputil::sqrt<float>(x);
+        return (FloatBits(r).uintval() != 0x8000'0000) ? r : 0.0f;
       case 0x3f80'0000: // y = 1.0f
         return x;
       case 0x4000'0000: // y = 2.0f
@@ -630,8 +637,7 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
 
     const bool x_is_neg = x_u >= FloatBits::SIGN_MASK;
 
-    switch (x_abs) {
-    case 0x0000'0000: { // x = +-0.0f
+    if (x == 0.0f) {
       const bool out_is_neg =
           x_is_neg && is_odd_integer(FloatBits(y_u).get_val());
       if (y_u > 0x8000'0000U) {
@@ -643,7 +649,9 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
       // pow(0, positive number) = 0
       return out_is_neg ? -0.0f : 0.0f;
     }
-    case 0x7f80'0000: { // x = +-Inf
+
+    if (x_abs == 0x7f80'0000) {
+      // x = +-Inf
       const bool out_is_neg =
           x_is_neg && is_odd_integer(FloatBits(y_u).get_val());
       if (y_u >= FloatBits::SIGN_MASK) {
@@ -651,7 +659,6 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
       }
       return FloatBits::inf(out_is_neg ? Sign::NEG : Sign::POS).get_val();
     }
-    }
 
     if (x_abs > 0x7f80'0000) {
       // x is NaN.
@@ -851,9 +858,9 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
           : 0.0;
   exp2_hi_mid_dd.hi = exp2_hi_mid;
 
-  return static_cast<float>(
-             powf_double_double(idx_x, dx, y6, lo6_hi, exp2_hi_mid_dd)) +
-         0.0f;
+  double r_dd = powf_double_double(idx_x, dx, y6, lo6_hi, exp2_hi_mid_dd);
+
+  return static_cast<float>(r_dd);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/range_reduction.h b/src/math/generic/range_reduction.h
index 8a75af5..9ea446d 100644
--- a/src/math/generic/range_reduction.h
+++ b/src/math/generic/range_reduction.h
@@ -13,8 +13,9 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace generic {
 
@@ -84,6 +85,6 @@ LIBC_INLINE int64_t large_range_reduction(double x, int x_exp, double &y) {
 
 } // namespace generic
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_H
diff --git a/src/math/generic/range_reduction_double_common.h b/src/math/generic/range_reduction_double_common.h
new file mode 100644
index 0000000..bcab82f
--- /dev/null
+++ b/src/math/generic/range_reduction_double_common.h
@@ -0,0 +1,375 @@
+//===-- Range reduction for double precision sin/cos/tan -*- C++ --------*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_COMMON_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_COMMON_H
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/common.h"
+#include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+static constexpr unsigned SPLIT = DEFAULT_DOUBLE_SPLIT;
+#else
+// When there is no-FMA instructions, in order to have exact product of 2 double
+// precision with directional roundings, we need to lower the precision of the
+// constants by at least 1 bit, and use a different splitting constant.
+static constexpr unsigned SPLIT = 28;
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+using LIBC_NAMESPACE::fputil::DoubleDouble;
+using Float128 = LIBC_NAMESPACE::fputil::DyadicFloat<128>;
+
+#define FAST_PASS_EXPONENT 16
+
+// For 2^-7 < |x| < 2^16, return k and u such that:
+//   k = round(x * 128/pi)
+//   x mod pi/128 = x - k * pi/128 ~ u.hi + u.lo
+// Error bound:
+//   |(x - k * pi/128) - (u_hi + u_lo)| <= max(ulp(ulp(u_hi)), 2^-119)
+//                                      <= 2^-111.
+LIBC_INLINE unsigned range_reduction_small(double x, DoubleDouble &u) {
+  // Values of -pi/128 used for inputs with absolute value <= 2^16.
+  // The first 3 parts are generated with (53 - 21 = 32)-bit precision, so that
+  // the product k * MPI_OVER_128[i] is exact.
+  // Generated by Sollya with:
+  // > display = hexadecimal!;
+  // > a = round(pi/128, 32, RN);
+  // > b = round(pi/128 - a, 32, RN);
+  // > c = round(pi/128 - a - b, D, RN);
+  // > print(-a, ",", -b, ",", -c);
+  constexpr double MPI_OVER_128[3] = {-0x1.921fb544p-6, -0x1.0b4611a6p-40,
+                                      -0x1.3198a2e037073p-75};
+  constexpr double ONE_TWENTY_EIGHT_OVER_PI_D = 0x1.45f306dc9c883p5;
+  double prod_hi = x * ONE_TWENTY_EIGHT_OVER_PI_D;
+  double kd = fputil::nearest_integer(prod_hi);
+
+  // Let y = x - k * (pi/128)
+  // Then |y| < pi / 256
+  // With extra rounding errors, we can bound |y| < 1.6 * 2^-7.
+  double y_hi = fputil::multiply_add(kd, MPI_OVER_128[0], x); // Exact
+  // |u.hi| < 1.6*2^-7
+  u.hi = fputil::multiply_add(kd, MPI_OVER_128[1], y_hi);
+  double u0 = y_hi - u.hi; // Exact
+  // |u.lo| <= max(ulp(u.hi), |kd * MPI_OVER_128[2]|)
+  double u1 = fputil::multiply_add(kd, MPI_OVER_128[1], u0); // Exact
+  u.lo = fputil::multiply_add(kd, MPI_OVER_128[2], u1);
+  // Error bound:
+  // |x - k * pi/128| - (u.hi + u.lo) <= ulp(u.lo)
+  //                                  <= ulp(max(ulp(u.hi), kd*MPI_OVER_128[2]))
+  //                                  <= 2^(-7 - 104) = 2^-111.
+
+  return static_cast<unsigned>(static_cast<int64_t>(kd));
+}
+
+// Digits of 2^(16*i) / pi, generated by Sollya with:
+// > procedure ulp(x, n) { return 2^(floor(log2(abs(x))) - n); };
+// > for i from 0 to 63 do {
+//     if i < 3 then { pi_inv = 0.25 + 2^(16*(i - 3)) / pi; }
+//     else { pi_inv = 2^(16*(i-3)) / pi; };
+//     pn = nearestint(pi_inv);
+//     pi_frac = pi_inv - pn;
+//     a = round(pi_frac, 51, RN);
+//     b = round(pi_frac - a, 51, RN);
+//     c = round(pi_frac - a - b, 51, RN);
+//     d = round(pi_frac - a - b - c, D, RN);
+//     print("{", 2^7 * a, ",", 2^7 * b, ",", 2^7 * c, ",", 2^7 * d, "},");
+// };
+//
+// Notice that for [0..2] the leading bit of 2^(16*(i - 3)) / pi is very small,
+// so we add 0.25 so that the conditions for the algorithms are still satisfied,
+// and one of those conditions guarantees that ulp(0.25 * x_reduced) >= 2, and
+// will safely be discarded.
+
+static constexpr double ONE_TWENTY_EIGHT_OVER_PI[64][4] = {
+    {0x1.0000000000014p5, 0x1.7cc1b727220a8p-49, 0x1.4fe13abe8fa9cp-101,
+     -0x1.911f924eb5336p-153},
+    {0x1.0000000145f3p5, 0x1.b727220a94fep-49, 0x1.3abe8fa9a6eep-101,
+     0x1.b6c52b3278872p-155},
+    {0x1.000145f306dc8p5, 0x1.c882a53f84ebp-47, -0x1.70565911f925p-101,
+     0x1.4acc9e21c821p-153},
+    {0x1.45f306dc9c884p5, -0x1.5ac07b1505c14p-47, -0x1.96447e493ad4cp-99,
+     -0x1.b0ef1bef806bap-152},
+    {-0x1.f246c6efab58p4, -0x1.ec5417056591p-49, -0x1.f924eb53361ep-101,
+     0x1.c820ff28b1d5fp-153},
+    {0x1.391054a7f09d4p4, 0x1.f47d4d377036cp-48, 0x1.8a5664f10e41p-100,
+     0x1.fe5163abdebbcp-154},
+    {0x1.529fc2757d1f4p2, 0x1.34ddc0db62958p-50, 0x1.93c439041fe5p-102,
+     0x1.63abdebbc561bp-154},
+    {-0x1.ec5417056591p-1, -0x1.f924eb53361ep-53, 0x1.c820ff28b1d6p-105,
+     -0x1.0a21d4f246dc9p-157},
+    {-0x1.505c1596447e4p5, -0x1.275a99b0ef1cp-48, 0x1.07f9458eaf7bp-100,
+     -0x1.0ea79236e4717p-152},
+    {-0x1.596447e493ad4p1, -0x1.9b0ef1bef806cp-52, 0x1.63abdebbc561cp-106,
+     -0x1.1b7238b7b645ap-159},
+    {0x1.bb81b6c52b328p5, -0x1.de37df00d74e4p-49, 0x1.5ef5de2b0db94p-101,
+     -0x1.c8e2ded9169p-153},
+    {0x1.b6c52b3278874p5, -0x1.f7c035d38a844p-47, 0x1.778ac36e48dc8p-99,
+     -0x1.6f6c8b47fe6dbp-152},
+    {0x1.2b3278872084p5, -0x1.ae9c5421443a8p-50, -0x1.e48db91c5bdb4p-102,
+     0x1.d2e006492eea1p-154},
+    {-0x1.8778df7c035d4p5, 0x1.d5ef5de2b0db8p-49, 0x1.2371d2126e97p-101,
+     0x1.924bba8274648p-160},
+    {-0x1.bef806ba71508p4, -0x1.443a9e48db91cp-50, -0x1.6f6c8b47fe6dcp-104,
+     0x1.77504e8c90e7fp-157},
+    {-0x1.ae9c5421443a8p-2, -0x1.e48db91c5bdb4p-54, 0x1.d2e006492eeap-106,
+     0x1.3a32439fc3bd6p-159},
+    {-0x1.38a84288753c8p5, -0x1.1b7238b7b645cp-47, 0x1.c00c925dd413cp-99,
+     -0x1.cdbc603c429c7p-151},
+    {-0x1.0a21d4f246dc8p3, -0x1.c5bdb22d1ff9cp-50, 0x1.25dd413a32438p-103,
+     0x1.fc3bd63962535p-155},
+    {-0x1.d4f246dc8e2ep3, 0x1.26e9700324978p-49, -0x1.5f62e6de301e4p-102,
+     0x1.eb1cb129a73efp-154},
+    {-0x1.236e4716f6c8cp4, 0x1.700324977505p-49, -0x1.736f180f10a7p-101,
+     -0x1.a76b2c608bbeep-153},
+    {0x1.b8e909374b8p4, 0x1.924bba8274648p-48, 0x1.cfe1deb1cb128p-102,
+     0x1.a73ee88235f53p-154},
+    {0x1.09374b801924cp4, -0x1.15f62e6de302p-50, 0x1.deb1cb129a74p-102,
+     -0x1.177dca0ad144cp-154},
+    {-0x1.68ffcdb688afcp3, 0x1.d1921cfe1debp-50, 0x1.cb129a73ee884p-102,
+     -0x1.ca0ad144bb7b1p-154},
+    {0x1.924bba8274648p0, 0x1.cfe1deb1cb128p-54, 0x1.a73ee88235f54p-106,
+     -0x1.144bb7b16639p-158},
+    {-0x1.a22bec5cdbc6p5, -0x1.e214e34ed658cp-50, -0x1.177dca0ad144cp-106,
+     0x1.213a671c09ad1p-160},
+    {0x1.3a32439fc3bd8p1, -0x1.c69dacb1822fp-51, 0x1.1afa975da2428p-105,
+     -0x1.6638fd94ba082p-158},
+    {-0x1.b78c0788538d4p4, 0x1.29a73ee88236p-50, -0x1.5a28976f62cc8p-103,
+     0x1.c09ad17df904ep-156},
+    {0x1.fc3bd63962534p5, 0x1.cfba208d7d4bcp-48, -0x1.12edec598e3f8p-100,
+     0x1.ad17df904e647p-152},
+    {-0x1.4e34ed658c118p2, 0x1.046bea5d7689p-51, 0x1.3a671c09ad17cp-104,
+     0x1.f904e64758e61p-156},
+    {0x1.62534e7dd1048p5, -0x1.415a28976f62cp-47, -0x1.8e3f652e8207p-100,
+     0x1.3991d63983534p-154},
+    {-0x1.63045df7282b4p4, -0x1.44bb7b16638fcp-50, -0x1.94ba081bec67p-102,
+     0x1.d639835339f4ap-154},
+    {0x1.d1046bea5d768p5, 0x1.213a671c09adp-48, 0x1.7df904e64759p-100,
+     -0x1.9f2b3182d8defp-152},
+    {0x1.afa975da24274p3, 0x1.9c7026b45f7e4p-50, 0x1.3991d63983534p-106,
+     -0x1.82d8dee81d108p-160},
+    {-0x1.a28976f62cc7p5, -0x1.fb29741037d8cp-47, -0x1.b8a719f2b3184p-100,
+     0x1.272117e2ef7e5p-152},
+    {-0x1.76f62cc71fb28p5, -0x1.741037d8cdc54p-47, 0x1.cc1a99cfa4e44p-101,
+     -0x1.d03a21036be27p-153},
+    {0x1.d338e04d68bfp5, -0x1.bec66e29c67ccp-50, 0x1.339f49c845f8cp-102,
+     -0x1.081b5f13801dap-156},
+    {0x1.c09ad17df905p4, -0x1.9b8a719f2b318p-48, -0x1.6c6f740e8840cp-103,
+     -0x1.af89c00ed0004p-155},
+    {0x1.68befc827323cp5, -0x1.38cf9598c16c8p-47, 0x1.08bf177bf2508p-99,
+     -0x1.3801da00087eap-152},
+    {-0x1.037d8cdc538dp5, 0x1.a99cfa4e422fcp-49, 0x1.77bf250763ffp-103,
+     0x1.2fffbc0b301fep-155},
+    {-0x1.8cdc538cf9598p5, -0x1.82d8dee81d108p-48, -0x1.b5f13801dap-104,
+     -0x1.0fd33f8086877p-157},
+    {-0x1.4e33e566305bp3, -0x1.bdd03a21036cp-49, 0x1.d8ffc4bffef04p-101,
+     -0x1.33f80868773a5p-153},
+    {-0x1.f2b3182d8dee8p4, -0x1.d1081b5f138p-52, -0x1.da00087e99fcp-104,
+     -0x1.0d0ee74a5f593p-158},
+    {-0x1.8c16c6f740e88p5, -0x1.036be27003b4p-49, -0x1.0fd33f8086878p-109,
+     0x1.8b5a0a6d1f6d3p-162},
+    {0x1.3908bf177bf24p5, 0x1.0763ff12fffbcp-47, 0x1.6603fbcbc462cp-104,
+     0x1.6829b47db4dap-156},
+    {0x1.7e2ef7e4a0ec8p4, -0x1.da00087e99fcp-56, -0x1.0d0ee74a5f594p-110,
+     0x1.1f6d367ecf27dp-162},
+    {-0x1.081b5f13801dcp4, 0x1.fff7816603fbcp-48, 0x1.788c5ad05369p-101,
+     -0x1.25930261b069fp-155},
+    {-0x1.af89c00ed0004p5, -0x1.fa67f010d0ee8p-50, 0x1.6b414da3eda6cp-103,
+     0x1.fb3c9f2c26dd4p-156},
+    {-0x1.c00ed00043f4cp5, -0x1.fc04343b9d298p-48, 0x1.4da3eda6cfdap-103,
+     -0x1.b069ec9161738p-155},
+    {0x1.2fffbc0b301fcp5, 0x1.e5e2316b414dcp-47, -0x1.c125930261b08p-99,
+     0x1.6136e9e8c7ecdp-151},
+    {-0x1.0fd33f8086878p3, 0x1.8b5a0a6d1f6d4p-50, -0x1.30261b069ec9p-103,
+     -0x1.61738132c3403p-155},
+    {-0x1.9fc04343b9d28p4, -0x1.7d64b824b2604p-48, -0x1.86c1a7b24585cp-101,
+     -0x1.c09961a015d29p-154},
+    {-0x1.0d0ee74a5f594p2, 0x1.1f6d367ecf27cp-50, 0x1.6136e9e8c7eccp-103,
+     0x1.3cbfd45aea4f7p-155},
+    {-0x1.dce94beb25c14p5, 0x1.a6cfd9e4f9614p-47, -0x1.22c2e70265868p-100,
+     -0x1.5d28ad8453814p-158},
+    {-0x1.4beb25c12593p5, -0x1.30d834f648b0cp-50, 0x1.8fd9a797fa8b4p-104,
+     0x1.d49eeb1faf97cp-156},
+    {0x1.b47db4d9fb3c8p4, 0x1.f2c26dd3d18fcp-48, 0x1.9a797fa8b5d48p-100,
+     0x1.eeb1faf97c5edp-152},
+    {-0x1.25930261b06ap5, 0x1.36e9e8c7ecd3cp-47, 0x1.7fa8b5d49eebp-100,
+     0x1.faf97c5ecf41dp-152},
+    {0x1.fb3c9f2c26dd4p4, -0x1.738132c3402bcp-51, 0x1.aea4f758fd7ccp-103,
+     -0x1.d0985f18c10ebp-159},
+    {-0x1.b069ec9161738p5, -0x1.32c3402ba515cp-51, 0x1.eeb1faf97c5ecp-104,
+     0x1.e839cfbc52949p-157},
+    {-0x1.ec9161738132cp5, -0x1.a015d28ad8454p-50, 0x1.faf97c5ecf41cp-104,
+     0x1.cfbc529497536p-157},
+    {-0x1.61738132c3404p5, 0x1.45aea4f758fd8p-47, -0x1.a0e84c2f8c608p-102,
+     -0x1.d6b5b45650128p-156},
+    {0x1.fb34f2ff516bcp3, -0x1.6c229c0a0d074p-49, -0x1.30be31821d6b4p-104,
+     -0x1.b4565012813b8p-156},
+    {0x1.3cbfd45aea4f8p5, -0x1.4e050683a130cp-48, 0x1.ce7de294a4ba8p-104,
+     0x1.afed7ec47e357p-156},
+    {-0x1.5d28ad8453814p2, -0x1.a0e84c2f8c608p-54, -0x1.d6b5b45650128p-108,
+     -0x1.3b81ca8bdea7fp-164},
+    {-0x1.15b08a702834p5, -0x1.d0985f18c10ecp-47, 0x1.4a4ba9afed7ecp-100,
+     0x1.1f8d5d0856033p-154},
+};
+
+// For large range |x| >= 2^16, we perform the range reduction computations as:
+//   u = x - k * pi/128 = (pi/128) * (x * (128/pi) - k).
+// We use the exponent of x to find 4 double-chunks of 128/pi:
+// c_hi, c_mid, c_lo, c_lo_2 such that:
+//   1) ulp(round(x * c_hi, D, RN)) >= 2^8 = 256,
+//   2) If x * c_hi = ph_hi + ph_lo and x * c_mid = pm_hi + pm_lo, then
+//        min(ulp(ph_lo), ulp(pm_hi)) >= 2^-53.
+// This will allow us to drop the high part ph_hi and the addition:
+//   (ph_lo + pm_hi) mod 1
+// can be exactly representable in a double precision.
+// This will allow us to do split the computations as:
+//   (x * 256/pi) ~ x * (c_hi + c_mid + c_lo + c_lo_2)    (mod 256)
+//                ~ (ph_lo + pm_hi) + (pm_lo + x * c_lo) + x * c_lo_2.
+// Then,
+//   round(x * 128/pi) = round(ph_lo + pm_hi)    (mod 256)
+// And the high part of fractional part of (x * 128/pi) can simply be:
+//   {x * 128/pi}_hi = {ph_lo + pm_hi}.
+// To prevent overflow when x is very large, we simply scale up
+// (c_hi, c_mid, c_lo, c_lo_2) by a fixed power of 2 (based on the index) and
+// scale down x by the same amount.
+
+struct LargeRangeReduction {
+
+  // To be implemented in range_reduction_double_fma.h and
+  // range_reduction_double_nofma.h.
+  unsigned fast(double x, DoubleDouble &u);
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  LIBC_INLINE Float128 accurate() const {
+    constexpr Float128 PI_OVER_128_F128 = {
+        Sign::POS, -133, 0xc90f'daa2'2168'c234'c4c6'628b'80dc'1cd1_u128};
+
+    // y_lo = x * c_lo + pm.lo
+    Float128 y_lo_0(x_reduced * ONE_TWENTY_EIGHT_OVER_PI[idx][3]);
+    Float128 y_lo_1 = fputil::quick_add(Float128(y_lo), y_lo_0);
+    Float128 y_mid_f128 = fputil::quick_add(Float128(y_mid.lo), y_lo_1);
+    Float128 y_hi_f128 = fputil::quick_add(Float128(y_hi), Float128(y_mid.hi));
+    Float128 y = fputil::quick_add(y_hi_f128, y_mid_f128);
+
+    return fputil::quick_mul(y, PI_OVER_128_F128);
+  }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+private:
+  // Index of x in the look-up table ONE_TWENTY_EIGHT_OVER_PI.
+  unsigned idx;
+  // x scaled down by 2^(-16 *(idx - 3))).
+  double x_reduced;
+  // Parts of (x * 128/pi) mod 1.
+  double y_hi, y_lo;
+  DoubleDouble y_mid;
+};
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+static Float128 range_reduction_small_f128(double x) {
+  constexpr Float128 PI_OVER_128_F128 = {
+      Sign::POS, -133, 0xc90f'daa2'2168'c234'c4c6'628b'80dc'1cd1_u128};
+  constexpr double ONE_TWENTY_EIGHT_OVER_PI_D = 0x1.45f306dc9c883p5;
+  double prod_hi = x * ONE_TWENTY_EIGHT_OVER_PI_D;
+  double kd = fputil::nearest_integer(prod_hi);
+
+  Float128 mk_f128(-kd);
+  Float128 x_f128(x);
+  Float128 p_hi =
+      fputil::quick_mul(x_f128, Float128(ONE_TWENTY_EIGHT_OVER_PI[3][0]));
+  Float128 p_mid =
+      fputil::quick_mul(x_f128, Float128(ONE_TWENTY_EIGHT_OVER_PI[3][1]));
+  Float128 p_lo =
+      fputil::quick_mul(x_f128, Float128(ONE_TWENTY_EIGHT_OVER_PI[3][2]));
+  Float128 s_hi = fputil::quick_add(p_hi, mk_f128);
+  Float128 s_lo = fputil::quick_add(p_mid, p_lo);
+  Float128 y = fputil::quick_add(s_hi, s_lo);
+
+  return fputil::quick_mul(y, PI_OVER_128_F128);
+}
+
+static constexpr Float128 SIN_K_PI_OVER_128_F128[65] = {
+    {Sign::POS, 0, 0},
+    {Sign::POS, -133, 0xc90a'afbd'1b33'efc9'c539'edcb'fda0'cf2c_u128},
+    {Sign::POS, -132, 0xc8fb'2f88'6ec0'9f37'6a17'954b'2b7c'5171_u128},
+    {Sign::POS, -131, 0x96a9'0496'70cf'ae65'f775'7409'4d3c'35c4_u128},
+    {Sign::POS, -131, 0xc8bd'35e1'4da1'5f0e'c739'6c89'4bbf'7389_u128},
+    {Sign::POS, -131, 0xfab2'72b5'4b98'71a2'7047'29ae'56d7'8a37_u128},
+    {Sign::POS, -130, 0x9640'8374'7309'd113'000a'89a1'1e07'c1fe_u128},
+    {Sign::POS, -130, 0xaf10'a224'59fe'32a6'3fee'f3bb'58b1'f10d_u128},
+    {Sign::POS, -130, 0xc7c5'c1e3'4d30'55b2'5cc8'c00e'4fcc'd850_u128},
+    {Sign::POS, -130, 0xe05c'1353'f27b'17e5'0ebc'61ad'e6ca'83cd_u128},
+    {Sign::POS, -130, 0xf8cf'cbd9'0af8'd57a'4221'dc4b'a772'598d_u128},
+    {Sign::POS, -129, 0x888e'9315'8fb3'bb04'9841'56f5'5334'4306_u128},
+    {Sign::POS, -129, 0x94a0'3176'acf8'2d45'ae4b'a773'da6b'f754_u128},
+    {Sign::POS, -129, 0xa09a'e4a0'bb30'0a19'2f89'5f44'a303'cc0b_u128},
+    {Sign::POS, -129, 0xac7c'd3ad'58fe'e7f0'811f'9539'84ef'f83e_u128},
+    {Sign::POS, -129, 0xb844'2987'd22c'f576'9cc3'ef36'746d'e3b8_u128},
+    {Sign::POS, -129, 0xc3ef'1535'754b'168d'3122'c2a5'9efd'dc37_u128},
+    {Sign::POS, -129, 0xcf7b'ca1d'476c'516d'a812'90bd'baad'62e4_u128},
+    {Sign::POS, -129, 0xdae8'804f'0ae6'015b'362c'b974'182e'3030_u128},
+    {Sign::POS, -129, 0xe633'74c9'8e22'f0b4'2872'ce1b'fc7a'd1cd_u128},
+    {Sign::POS, -129, 0xf15a'e9c0'37b1'd8f0'6c48'e9e3'420b'0f1e_u128},
+    {Sign::POS, -129, 0xfc5d'26df'c4d5'cfda'27c0'7c91'1290'b8d1_u128},
+    {Sign::POS, -128, 0x839c'3cc9'17ff'6cb4'bfd7'9717'f288'0abf_u128},
+    {Sign::POS, -128, 0x88f5'9aa0'da59'1421'b892'ca83'61d8'c84c_u128},
+    {Sign::POS, -128, 0x8e39'd9cd'7346'4364'bba4'cfec'bff5'4867_u128},
+    {Sign::POS, -128, 0x9368'2a66'e896'f544'b178'2191'1e71'c16e_u128},
+    {Sign::POS, -128, 0x987f'bfe7'0b81'a708'19ce'c845'ac87'a5c6_u128},
+    {Sign::POS, -128, 0x9d7f'd149'0285'c9e3'e25e'3954'9638'ae68_u128},
+    {Sign::POS, -128, 0xa267'9928'48ee'b0c0'3b51'67ee'359a'234e_u128},
+    {Sign::POS, -128, 0xa736'55df'1f2f'489e'149f'6e75'9934'68a3_u128},
+    {Sign::POS, -128, 0xabeb'49a4'6764'fd15'1bec'da80'89c1'a94c_u128},
+    {Sign::POS, -128, 0xb085'baa8'e966'f6da'e4ca'd00d'5c94'bcd2_u128},
+    {Sign::POS, -128, 0xb504'f333'f9de'6484'597d'89b3'754a'be9f_u128},
+    {Sign::POS, -128, 0xb968'41bf'7ffc'b21a'9de1'e3b2'2b8b'f4db_u128},
+    {Sign::POS, -128, 0xbdae'f913'557d'76f0'ac85'320f'528d'6d5d_u128},
+    {Sign::POS, -128, 0xc1d8'705f'fcbb'6e90'bdf0'715c'b8b2'0bd7_u128},
+    {Sign::POS, -128, 0xc5e4'0358'a8ba'05a7'43da'25d9'9267'326b_u128},
+    {Sign::POS, -128, 0xc9d1'124c'931f'da7a'8335'241b'e169'3225_u128},
+    {Sign::POS, -128, 0xcd9f'023f'9c3a'059e'23af'31db'7179'a4aa_u128},
+    {Sign::POS, -128, 0xd14d'3d02'313c'0eed'744f'ea20'e8ab'ef92_u128},
+    {Sign::POS, -128, 0xd4db'3148'750d'1819'f630'e8b6'dac8'3e69_u128},
+    {Sign::POS, -128, 0xd848'52c0'a80f'fcdb'24b9'fe00'6635'74a4_u128},
+    {Sign::POS, -128, 0xdb94'1a28'cb71'ec87'2c19'b632'53da'43fc_u128},
+    {Sign::POS, -128, 0xdebe'0563'7ca9'4cfb'4b19'aa71'fec3'ae6d_u128},
+    {Sign::POS, -128, 0xe1c5'978c'05ed'8691'f4e8'a837'2f8c'5810_u128},
+    {Sign::POS, -128, 0xe4aa'5909'a08f'a7b4'1227'85ae'67f5'515d_u128},
+    {Sign::POS, -128, 0xe76b'd7a1'e63b'9786'1251'2952'9d48'a92f_u128},
+    {Sign::POS, -128, 0xea09'a68a'6e49'cd62'15ad'45b4'a1b5'e823_u128},
+    {Sign::POS, -128, 0xec83'5e79'946a'3145'7e61'0231'ac1d'6181_u128},
+    {Sign::POS, -128, 0xeed8'9db6'6611'e307'86f8'c20f'b664'b01b_u128},
+    {Sign::POS, -128, 0xf109'0827'b437'25fd'6712'7db3'5b28'7316_u128},
+    {Sign::POS, -128, 0xf314'4762'4708'8f74'a548'6bdc'455d'56a2_u128},
+    {Sign::POS, -128, 0xf4fa'0ab6'316e'd2ec'163c'5c7f'03b7'18c5_u128},
+    {Sign::POS, -128, 0xf6ba'073b'424b'19e8'2c79'1f59'cc1f'fc23_u128},
+    {Sign::POS, -128, 0xf853'f7dc'9186'b952'c7ad'c6b4'9888'91bb_u128},
+    {Sign::POS, -128, 0xf9c7'9d63'272c'4628'4504'ae08'd19b'2980_u128},
+    {Sign::POS, -128, 0xfb14'be7f'bae5'8156'2172'a361'fd2a'722f_u128},
+    {Sign::POS, -128, 0xfc3b'27d3'8a5d'49ab'2567'78ff'cb5c'1769_u128},
+    {Sign::POS, -128, 0xfd3a'abf8'4528'b50b'eae6'bd95'1c1d'abbe_u128},
+    {Sign::POS, -128, 0xfe13'2387'0cfe'9a3d'90cd'1d95'9db6'74ef_u128},
+    {Sign::POS, -128, 0xfec4'6d1e'8929'2cf0'4139'0efd'c726'e9ef_u128},
+    {Sign::POS, -128, 0xff4e'6d68'0c41'd0a9'0f66'8633'f1ab'858a_u128},
+    {Sign::POS, -128, 0xffb1'0f1b'cb6b'ef1d'421e'8eda'af59'453e_u128},
+    {Sign::POS, -128, 0xffec'4304'2668'65d9'5657'5523'6696'1732_u128},
+    {Sign::POS, 0, 1},
+};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_COMMON_H
diff --git a/src/math/generic/range_reduction_double_fma.h b/src/math/generic/range_reduction_double_fma.h
new file mode 100644
index 0000000..cab031c
--- /dev/null
+++ b/src/math/generic/range_reduction_double_fma.h
@@ -0,0 +1,346 @@
+//===-- Range reduction for double precision sin/cos/tan w/ FMA -*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_FMA_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_FMA_H
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/math/generic/range_reduction_double_common.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+using LIBC_NAMESPACE::fputil::DoubleDouble;
+
+LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  int x_e_m62 = xbits.get_biased_exponent() - (FPBits::EXP_BIAS + 62);
+  idx = static_cast<unsigned>((x_e_m62 >> 4) + 3);
+  // Scale x down by 2^(-(16 * (idx - 3))
+  xbits.set_biased_exponent((x_e_m62 & 15) + FPBits::EXP_BIAS + 62);
+  // 2^62 <= |x_reduced| < 2^(62 + 16) = 2^78
+  x_reduced = xbits.get_val();
+  // x * c_hi = ph.hi + ph.lo exactly.
+  DoubleDouble ph =
+      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
+  // x * c_mid = pm.hi + pm.lo exactly.
+  DoubleDouble pm =
+      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
+  // x * c_lo = pl.hi + pl.lo exactly.
+  DoubleDouble pl =
+      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
+  // Extract integral parts and fractional parts of (ph.lo + pm.hi).
+  double sum_hi = ph.lo + pm.hi;
+  double kd = fputil::nearest_integer(sum_hi);
+
+  // x * 128/pi mod 1 ~ y_hi + y_mid + y_lo
+  y_hi = (ph.lo - kd) + pm.hi; // Exact
+  y_mid = fputil::exact_add(pm.lo, pl.hi);
+  y_lo = pl.lo;
+
+  // y_l = x * c_lo_2 + pl.lo
+  double y_l =
+      fputil::multiply_add(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][3], y_lo);
+  DoubleDouble y = fputil::exact_add(y_hi, y_mid.hi);
+  y.lo += (y_mid.lo + y_l);
+
+  // Digits of pi/128, generated by Sollya with:
+  // > a = round(pi/128, D, RN);
+  // > b = round(pi/128 - a, D, RN);
+  constexpr DoubleDouble PI_OVER_128_DD = {0x1.1a62633145c07p-60,
+                                           0x1.921fb54442d18p-6};
+
+  // Error bound: with {a} denote the fractional part of a, i.e.:
+  //   {a} = a - round(a)
+  // Then,
+  //   | {x * 128/pi} - (y_hi + y_lo) | <=  ulp(ulp(y_hi)) <= 2^-105
+  //   | {x mod pi/128} - (u.hi + u.lo) | < 2 * 2^-6 * 2^-105 = 2^-110
+  u = fputil::quick_mult<SPLIT>(y, PI_OVER_128_DD);
+
+  return static_cast<unsigned>(static_cast<int64_t>(kd));
+}
+
+// Lookup table for sin(k * pi / 128) with k = 0, ..., 255.
+// Table is generated with Sollya as follow:
+// > display = hexadecimal;
+// > for k from 0 to 255 do {
+//     a = D(sin(k * pi/128)); };
+//     b = D(sin(k * pi/128) - a);
+//     print("{", b, ",", a, "},");
+//   };
+LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[256] = {
+    {0, 0},
+    {-0x1.b1d63091a013p-64, 0x1.92155f7a3667ep-6},
+    {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
+    {-0x1.9a088a8bf6b2cp-59, 0x1.2d52092ce19f6p-4},
+    {-0x1.e2718d26ed688p-60, 0x1.917a6bc29b42cp-4},
+    {0x1.a2704729ae56dp-59, 0x1.f564e56a9730ep-4},
+    {0x1.13000a89a11ep-58, 0x1.2c8106e8e613ap-3},
+    {0x1.531ff779ddac6p-57, 0x1.5e214448b3fc6p-3},
+    {-0x1.26d19b9ff8d82p-57, 0x1.8f8b83c69a60bp-3},
+    {-0x1.af1439e521935p-62, 0x1.c0b826a7e4f63p-3},
+    {-0x1.42deef11da2c4p-57, 0x1.f19f97b215f1bp-3},
+    {0x1.824c20ab7aa9ap-56, 0x1.111d262b1f677p-2},
+    {-0x1.5d28da2c4612dp-56, 0x1.294062ed59f06p-2},
+    {0x1.0c97c4afa2518p-56, 0x1.4135c94176601p-2},
+    {-0x1.efdc0d58cf62p-62, 0x1.58f9a75ab1fddp-2},
+    {-0x1.44b19e0864c5dp-56, 0x1.7088530fa459fp-2},
+    {-0x1.72cedd3d5a61p-57, 0x1.87de2a6aea963p-2},
+    {0x1.6da81290bdbabp-57, 0x1.9ef7943a8ed8ap-2},
+    {0x1.5b362cb974183p-57, 0x1.b5d1009e15ccp-2},
+    {0x1.6850e59c37f8fp-58, 0x1.cc66e9931c45ep-2},
+    {0x1.e0d891d3c6841p-58, 0x1.e2b5d3806f63bp-2},
+    {-0x1.2ec1fc1b776b8p-60, 0x1.f8ba4dbf89abap-2},
+    {-0x1.a5a014347406cp-55, 0x1.073879922ffeep-1},
+    {-0x1.ef23b69abe4f1p-55, 0x1.11eb3541b4b23p-1},
+    {0x1.b25dd267f66p-55, 0x1.1c73b39ae68c8p-1},
+    {-0x1.5da743ef3770cp-55, 0x1.26d054cdd12dfp-1},
+    {-0x1.efcc626f74a6fp-57, 0x1.30ff7fce17035p-1},
+    {0x1.e3e25e3954964p-56, 0x1.3affa292050b9p-1},
+    {0x1.8076a2cfdc6b3p-57, 0x1.44cf325091dd6p-1},
+    {0x1.3c293edceb327p-57, 0x1.4e6cabbe3e5e9p-1},
+    {-0x1.75720992bfbb2p-55, 0x1.57d69348cecap-1},
+    {-0x1.251b352ff2a37p-56, 0x1.610b7551d2cdfp-1},
+    {-0x1.bdd3413b26456p-55, 0x1.6a09e667f3bcdp-1},
+    {0x1.0d4ef0f1d915cp-55, 0x1.72d0837efff96p-1},
+    {-0x1.0f537acdf0ad7p-56, 0x1.7b5df226aafafp-1},
+    {-0x1.6f420f8ea3475p-56, 0x1.83b0e0bff976ep-1},
+    {-0x1.2c5e12ed1336dp-55, 0x1.8bc806b151741p-1},
+    {0x1.3d419a920df0bp-55, 0x1.93a22499263fbp-1},
+    {-0x1.30ee286712474p-55, 0x1.9b3e047f38741p-1},
+    {-0x1.128bb015df175p-56, 0x1.a29a7a0462782p-1},
+    {0x1.9f630e8b6dac8p-60, 0x1.a9b66290ea1a3p-1},
+    {-0x1.926da300ffccep-55, 0x1.b090a581502p-1},
+    {-0x1.bc69f324e6d61p-55, 0x1.b728345196e3ep-1},
+    {-0x1.825a732ac700ap-55, 0x1.bd7c0ac6f952ap-1},
+    {-0x1.6e0b1757c8d07p-56, 0x1.c38b2f180bdb1p-1},
+    {-0x1.2fb761e946603p-58, 0x1.c954b213411f5p-1},
+    {-0x1.e7b6bb5ab58aep-58, 0x1.ced7af43cc773p-1},
+    {-0x1.4ef5295d25af2p-55, 0x1.d4134d14dc93ap-1},
+    {0x1.457e610231ac2p-56, 0x1.d906bcf328d46p-1},
+    {0x1.83c37c6107db3p-55, 0x1.ddb13b6ccc23cp-1},
+    {-0x1.014c76c126527p-55, 0x1.e212104f686e5p-1},
+    {-0x1.16b56f2847754p-57, 0x1.e6288ec48e112p-1},
+    {0x1.760b1e2e3f81ep-55, 0x1.e9f4156c62ddap-1},
+    {0x1.e82c791f59cc2p-56, 0x1.ed740e7684963p-1},
+    {0x1.52c7adc6b4989p-56, 0x1.f0a7efb9230d7p-1},
+    {-0x1.d7bafb51f72e6p-56, 0x1.f38f3ac64e589p-1},
+    {0x1.562172a361fd3p-56, 0x1.f6297cff75cbp-1},
+    {0x1.ab256778ffcb6p-56, 0x1.f8764fa714ba9p-1},
+    {-0x1.7a0a8ca13571fp-55, 0x1.fa7557f08a517p-1},
+    {0x1.1ec8668ecaceep-55, 0x1.fc26470e19fd3p-1},
+    {-0x1.87df6378811c7p-55, 0x1.fd88da3d12526p-1},
+    {0x1.521ecd0c67e35p-57, 0x1.fe9cdad01883ap-1},
+    {-0x1.c57bc2e24aa15p-57, 0x1.ff621e3796d7ep-1},
+    {-0x1.1354d4556e4cbp-55, 0x1.ffd886084cd0dp-1},
+    {0, 1},
+#ifndef LIBC_MATH_HAS_SMALL_TABLES
+    {-0x1.1354d4556e4cbp-55, 0x1.ffd886084cd0dp-1},
+    {-0x1.c57bc2e24aa15p-57, 0x1.ff621e3796d7ep-1},
+    {0x1.521ecd0c67e35p-57, 0x1.fe9cdad01883ap-1},
+    {-0x1.87df6378811c7p-55, 0x1.fd88da3d12526p-1},
+    {0x1.1ec8668ecaceep-55, 0x1.fc26470e19fd3p-1},
+    {-0x1.7a0a8ca13571fp-55, 0x1.fa7557f08a517p-1},
+    {0x1.ab256778ffcb6p-56, 0x1.f8764fa714ba9p-1},
+    {0x1.562172a361fd3p-56, 0x1.f6297cff75cbp-1},
+    {-0x1.d7bafb51f72e6p-56, 0x1.f38f3ac64e589p-1},
+    {0x1.52c7adc6b4989p-56, 0x1.f0a7efb9230d7p-1},
+    {0x1.e82c791f59cc2p-56, 0x1.ed740e7684963p-1},
+    {0x1.760b1e2e3f81ep-55, 0x1.e9f4156c62ddap-1},
+    {-0x1.16b56f2847754p-57, 0x1.e6288ec48e112p-1},
+    {-0x1.014c76c126527p-55, 0x1.e212104f686e5p-1},
+    {0x1.83c37c6107db3p-55, 0x1.ddb13b6ccc23cp-1},
+    {0x1.457e610231ac2p-56, 0x1.d906bcf328d46p-1},
+    {-0x1.4ef5295d25af2p-55, 0x1.d4134d14dc93ap-1},
+    {-0x1.e7b6bb5ab58aep-58, 0x1.ced7af43cc773p-1},
+    {-0x1.2fb761e946603p-58, 0x1.c954b213411f5p-1},
+    {-0x1.6e0b1757c8d07p-56, 0x1.c38b2f180bdb1p-1},
+    {-0x1.825a732ac700ap-55, 0x1.bd7c0ac6f952ap-1},
+    {-0x1.bc69f324e6d61p-55, 0x1.b728345196e3ep-1},
+    {-0x1.926da300ffccep-55, 0x1.b090a581502p-1},
+    {0x1.9f630e8b6dac8p-60, 0x1.a9b66290ea1a3p-1},
+    {-0x1.128bb015df175p-56, 0x1.a29a7a0462782p-1},
+    {-0x1.30ee286712474p-55, 0x1.9b3e047f38741p-1},
+    {0x1.3d419a920df0bp-55, 0x1.93a22499263fbp-1},
+    {-0x1.2c5e12ed1336dp-55, 0x1.8bc806b151741p-1},
+    {-0x1.6f420f8ea3475p-56, 0x1.83b0e0bff976ep-1},
+    {-0x1.0f537acdf0ad7p-56, 0x1.7b5df226aafafp-1},
+    {0x1.0d4ef0f1d915cp-55, 0x1.72d0837efff96p-1},
+    {-0x1.bdd3413b26456p-55, 0x1.6a09e667f3bcdp-1},
+    {-0x1.251b352ff2a37p-56, 0x1.610b7551d2cdfp-1},
+    {-0x1.75720992bfbb2p-55, 0x1.57d69348cecap-1},
+    {0x1.3c293edceb327p-57, 0x1.4e6cabbe3e5e9p-1},
+    {0x1.8076a2cfdc6b3p-57, 0x1.44cf325091dd6p-1},
+    {0x1.e3e25e3954964p-56, 0x1.3affa292050b9p-1},
+    {-0x1.efcc626f74a6fp-57, 0x1.30ff7fce17035p-1},
+    {-0x1.5da743ef3770cp-55, 0x1.26d054cdd12dfp-1},
+    {0x1.b25dd267f66p-55, 0x1.1c73b39ae68c8p-1},
+    {-0x1.ef23b69abe4f1p-55, 0x1.11eb3541b4b23p-1},
+    {-0x1.a5a014347406cp-55, 0x1.073879922ffeep-1},
+    {-0x1.2ec1fc1b776b8p-60, 0x1.f8ba4dbf89abap-2},
+    {0x1.e0d891d3c6841p-58, 0x1.e2b5d3806f63bp-2},
+    {0x1.6850e59c37f8fp-58, 0x1.cc66e9931c45ep-2},
+    {0x1.5b362cb974183p-57, 0x1.b5d1009e15ccp-2},
+    {0x1.6da81290bdbabp-57, 0x1.9ef7943a8ed8ap-2},
+    {-0x1.72cedd3d5a61p-57, 0x1.87de2a6aea963p-2},
+    {-0x1.44b19e0864c5dp-56, 0x1.7088530fa459fp-2},
+    {-0x1.efdc0d58cf62p-62, 0x1.58f9a75ab1fddp-2},
+    {0x1.0c97c4afa2518p-56, 0x1.4135c94176601p-2},
+    {-0x1.5d28da2c4612dp-56, 0x1.294062ed59f06p-2},
+    {0x1.824c20ab7aa9ap-56, 0x1.111d262b1f677p-2},
+    {-0x1.42deef11da2c4p-57, 0x1.f19f97b215f1bp-3},
+    {-0x1.af1439e521935p-62, 0x1.c0b826a7e4f63p-3},
+    {-0x1.26d19b9ff8d82p-57, 0x1.8f8b83c69a60bp-3},
+    {0x1.531ff779ddac6p-57, 0x1.5e214448b3fc6p-3},
+    {0x1.13000a89a11ep-58, 0x1.2c8106e8e613ap-3},
+    {0x1.a2704729ae56dp-59, 0x1.f564e56a9730ep-4},
+    {-0x1.e2718d26ed688p-60, 0x1.917a6bc29b42cp-4},
+    {-0x1.9a088a8bf6b2cp-59, 0x1.2d52092ce19f6p-4},
+    {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
+    {-0x1.b1d63091a013p-64, 0x1.92155f7a3667ep-6},
+    {0, 0},
+    {0x1.b1d63091a013p-64, -0x1.92155f7a3667ep-6},
+    {0x1.912bd0d569a9p-61, -0x1.91f65f10dd814p-5},
+    {0x1.9a088a8bf6b2cp-59, -0x1.2d52092ce19f6p-4},
+    {0x1.e2718d26ed688p-60, -0x1.917a6bc29b42cp-4},
+    {-0x1.a2704729ae56dp-59, -0x1.f564e56a9730ep-4},
+    {-0x1.13000a89a11ep-58, -0x1.2c8106e8e613ap-3},
+    {-0x1.531ff779ddac6p-57, -0x1.5e214448b3fc6p-3},
+    {0x1.26d19b9ff8d82p-57, -0x1.8f8b83c69a60bp-3},
+    {0x1.af1439e521935p-62, -0x1.c0b826a7e4f63p-3},
+    {0x1.42deef11da2c4p-57, -0x1.f19f97b215f1bp-3},
+    {-0x1.824c20ab7aa9ap-56, -0x1.111d262b1f677p-2},
+    {0x1.5d28da2c4612dp-56, -0x1.294062ed59f06p-2},
+    {-0x1.0c97c4afa2518p-56, -0x1.4135c94176601p-2},
+    {0x1.efdc0d58cf62p-62, -0x1.58f9a75ab1fddp-2},
+    {0x1.44b19e0864c5dp-56, -0x1.7088530fa459fp-2},
+    {0x1.72cedd3d5a61p-57, -0x1.87de2a6aea963p-2},
+    {-0x1.6da81290bdbabp-57, -0x1.9ef7943a8ed8ap-2},
+    {-0x1.5b362cb974183p-57, -0x1.b5d1009e15ccp-2},
+    {-0x1.6850e59c37f8fp-58, -0x1.cc66e9931c45ep-2},
+    {-0x1.e0d891d3c6841p-58, -0x1.e2b5d3806f63bp-2},
+    {0x1.2ec1fc1b776b8p-60, -0x1.f8ba4dbf89abap-2},
+    {0x1.a5a014347406cp-55, -0x1.073879922ffeep-1},
+    {0x1.ef23b69abe4f1p-55, -0x1.11eb3541b4b23p-1},
+    {-0x1.b25dd267f66p-55, -0x1.1c73b39ae68c8p-1},
+    {0x1.5da743ef3770cp-55, -0x1.26d054cdd12dfp-1},
+    {0x1.efcc626f74a6fp-57, -0x1.30ff7fce17035p-1},
+    {-0x1.e3e25e3954964p-56, -0x1.3affa292050b9p-1},
+    {-0x1.8076a2cfdc6b3p-57, -0x1.44cf325091dd6p-1},
+    {-0x1.3c293edceb327p-57, -0x1.4e6cabbe3e5e9p-1},
+    {0x1.75720992bfbb2p-55, -0x1.57d69348cecap-1},
+    {0x1.251b352ff2a37p-56, -0x1.610b7551d2cdfp-1},
+    {0x1.bdd3413b26456p-55, -0x1.6a09e667f3bcdp-1},
+    {-0x1.0d4ef0f1d915cp-55, -0x1.72d0837efff96p-1},
+    {0x1.0f537acdf0ad7p-56, -0x1.7b5df226aafafp-1},
+    {0x1.6f420f8ea3475p-56, -0x1.83b0e0bff976ep-1},
+    {0x1.2c5e12ed1336dp-55, -0x1.8bc806b151741p-1},
+    {-0x1.3d419a920df0bp-55, -0x1.93a22499263fbp-1},
+    {0x1.30ee286712474p-55, -0x1.9b3e047f38741p-1},
+    {0x1.128bb015df175p-56, -0x1.a29a7a0462782p-1},
+    {-0x1.9f630e8b6dac8p-60, -0x1.a9b66290ea1a3p-1},
+    {0x1.926da300ffccep-55, -0x1.b090a581502p-1},
+    {0x1.bc69f324e6d61p-55, -0x1.b728345196e3ep-1},
+    {0x1.825a732ac700ap-55, -0x1.bd7c0ac6f952ap-1},
+    {0x1.6e0b1757c8d07p-56, -0x1.c38b2f180bdb1p-1},
+    {0x1.2fb761e946603p-58, -0x1.c954b213411f5p-1},
+    {0x1.e7b6bb5ab58aep-58, -0x1.ced7af43cc773p-1},
+    {0x1.4ef5295d25af2p-55, -0x1.d4134d14dc93ap-1},
+    {-0x1.457e610231ac2p-56, -0x1.d906bcf328d46p-1},
+    {-0x1.83c37c6107db3p-55, -0x1.ddb13b6ccc23cp-1},
+    {0x1.014c76c126527p-55, -0x1.e212104f686e5p-1},
+    {0x1.16b56f2847754p-57, -0x1.e6288ec48e112p-1},
+    {-0x1.760b1e2e3f81ep-55, -0x1.e9f4156c62ddap-1},
+    {-0x1.e82c791f59cc2p-56, -0x1.ed740e7684963p-1},
+    {-0x1.52c7adc6b4989p-56, -0x1.f0a7efb9230d7p-1},
+    {0x1.d7bafb51f72e6p-56, -0x1.f38f3ac64e589p-1},
+    {-0x1.562172a361fd3p-56, -0x1.f6297cff75cbp-1},
+    {-0x1.ab256778ffcb6p-56, -0x1.f8764fa714ba9p-1},
+    {0x1.7a0a8ca13571fp-55, -0x1.fa7557f08a517p-1},
+    {-0x1.1ec8668ecaceep-55, -0x1.fc26470e19fd3p-1},
+    {0x1.87df6378811c7p-55, -0x1.fd88da3d12526p-1},
+    {-0x1.521ecd0c67e35p-57, -0x1.fe9cdad01883ap-1},
+    {0x1.c57bc2e24aa15p-57, -0x1.ff621e3796d7ep-1},
+    {0x1.1354d4556e4cbp-55, -0x1.ffd886084cd0dp-1},
+    {0, -1},
+    {0x1.1354d4556e4cbp-55, -0x1.ffd886084cd0dp-1},
+    {0x1.c57bc2e24aa15p-57, -0x1.ff621e3796d7ep-1},
+    {-0x1.521ecd0c67e35p-57, -0x1.fe9cdad01883ap-1},
+    {0x1.87df6378811c7p-55, -0x1.fd88da3d12526p-1},
+    {-0x1.1ec8668ecaceep-55, -0x1.fc26470e19fd3p-1},
+    {0x1.7a0a8ca13571fp-55, -0x1.fa7557f08a517p-1},
+    {-0x1.ab256778ffcb6p-56, -0x1.f8764fa714ba9p-1},
+    {-0x1.562172a361fd3p-56, -0x1.f6297cff75cbp-1},
+    {0x1.d7bafb51f72e6p-56, -0x1.f38f3ac64e589p-1},
+    {-0x1.52c7adc6b4989p-56, -0x1.f0a7efb9230d7p-1},
+    {-0x1.e82c791f59cc2p-56, -0x1.ed740e7684963p-1},
+    {-0x1.760b1e2e3f81ep-55, -0x1.e9f4156c62ddap-1},
+    {0x1.16b56f2847754p-57, -0x1.e6288ec48e112p-1},
+    {0x1.014c76c126527p-55, -0x1.e212104f686e5p-1},
+    {-0x1.83c37c6107db3p-55, -0x1.ddb13b6ccc23cp-1},
+    {-0x1.457e610231ac2p-56, -0x1.d906bcf328d46p-1},
+    {0x1.4ef5295d25af2p-55, -0x1.d4134d14dc93ap-1},
+    {0x1.e7b6bb5ab58aep-58, -0x1.ced7af43cc773p-1},
+    {0x1.2fb761e946603p-58, -0x1.c954b213411f5p-1},
+    {0x1.6e0b1757c8d07p-56, -0x1.c38b2f180bdb1p-1},
+    {0x1.825a732ac700ap-55, -0x1.bd7c0ac6f952ap-1},
+    {0x1.bc69f324e6d61p-55, -0x1.b728345196e3ep-1},
+    {0x1.926da300ffccep-55, -0x1.b090a581502p-1},
+    {-0x1.9f630e8b6dac8p-60, -0x1.a9b66290ea1a3p-1},
+    {0x1.128bb015df175p-56, -0x1.a29a7a0462782p-1},
+    {0x1.30ee286712474p-55, -0x1.9b3e047f38741p-1},
+    {-0x1.3d419a920df0bp-55, -0x1.93a22499263fbp-1},
+    {0x1.2c5e12ed1336dp-55, -0x1.8bc806b151741p-1},
+    {0x1.6f420f8ea3475p-56, -0x1.83b0e0bff976ep-1},
+    {0x1.0f537acdf0ad7p-56, -0x1.7b5df226aafafp-1},
+    {-0x1.0d4ef0f1d915cp-55, -0x1.72d0837efff96p-1},
+    {0x1.bdd3413b26456p-55, -0x1.6a09e667f3bcdp-1},
+    {0x1.251b352ff2a37p-56, -0x1.610b7551d2cdfp-1},
+    {0x1.75720992bfbb2p-55, -0x1.57d69348cecap-1},
+    {-0x1.3c293edceb327p-57, -0x1.4e6cabbe3e5e9p-1},
+    {-0x1.8076a2cfdc6b3p-57, -0x1.44cf325091dd6p-1},
+    {-0x1.e3e25e3954964p-56, -0x1.3affa292050b9p-1},
+    {0x1.efcc626f74a6fp-57, -0x1.30ff7fce17035p-1},
+    {0x1.5da743ef3770cp-55, -0x1.26d054cdd12dfp-1},
+    {-0x1.b25dd267f66p-55, -0x1.1c73b39ae68c8p-1},
+    {0x1.ef23b69abe4f1p-55, -0x1.11eb3541b4b23p-1},
+    {0x1.a5a014347406cp-55, -0x1.073879922ffeep-1},
+    {0x1.2ec1fc1b776b8p-60, -0x1.f8ba4dbf89abap-2},
+    {-0x1.e0d891d3c6841p-58, -0x1.e2b5d3806f63bp-2},
+    {-0x1.6850e59c37f8fp-58, -0x1.cc66e9931c45ep-2},
+    {-0x1.5b362cb974183p-57, -0x1.b5d1009e15ccp-2},
+    {-0x1.6da81290bdbabp-57, -0x1.9ef7943a8ed8ap-2},
+    {0x1.72cedd3d5a61p-57, -0x1.87de2a6aea963p-2},
+    {0x1.44b19e0864c5dp-56, -0x1.7088530fa459fp-2},
+    {0x1.efdc0d58cf62p-62, -0x1.58f9a75ab1fddp-2},
+    {-0x1.0c97c4afa2518p-56, -0x1.4135c94176601p-2},
+    {0x1.5d28da2c4612dp-56, -0x1.294062ed59f06p-2},
+    {-0x1.824c20ab7aa9ap-56, -0x1.111d262b1f677p-2},
+    {0x1.42deef11da2c4p-57, -0x1.f19f97b215f1bp-3},
+    {0x1.af1439e521935p-62, -0x1.c0b826a7e4f63p-3},
+    {0x1.26d19b9ff8d82p-57, -0x1.8f8b83c69a60bp-3},
+    {-0x1.531ff779ddac6p-57, -0x1.5e214448b3fc6p-3},
+    {-0x1.13000a89a11ep-58, -0x1.2c8106e8e613ap-3},
+    {-0x1.a2704729ae56dp-59, -0x1.f564e56a9730ep-4},
+    {0x1.e2718d26ed688p-60, -0x1.917a6bc29b42cp-4},
+    {0x1.9a088a8bf6b2cp-59, -0x1.2d52092ce19f6p-4},
+    {0x1.912bd0d569a9p-61, -0x1.91f65f10dd814p-5},
+    {0x1.b1d63091a013p-64, -0x1.92155f7a3667ep-6},
+#endif // !LIBC_MATH_HAS_SMALL_TABLES
+};
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_FMA_H
diff --git a/src/math/generic/range_reduction_double_nofma.h b/src/math/generic/range_reduction_double_nofma.h
new file mode 100644
index 0000000..5640732
--- /dev/null
+++ b/src/math/generic/range_reduction_double_nofma.h
@@ -0,0 +1,347 @@
+//===-- Range reduction for double precision sin/cos/tan --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_NOFMA_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_NOFMA_H
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/math/generic/range_reduction_double_common.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+using fputil::DoubleDouble;
+
+LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  int x_e_m62 = xbits.get_biased_exponent() - (FPBits::EXP_BIAS + 62);
+  idx = static_cast<unsigned>((x_e_m62 >> 4) + 3);
+  // Scale x down by 2^(-(16 * (idx - 3))
+  xbits.set_biased_exponent((x_e_m62 & 15) + FPBits::EXP_BIAS + 62);
+  // 2^62 <= |x_reduced| < 2^(62 + 16) = 2^78
+  x_reduced = xbits.get_val();
+  // x * c_hi = ph.hi + ph.lo exactly.
+  DoubleDouble x_split = fputil::split(x_reduced);
+  DoubleDouble ph = fputil::exact_mult<SPLIT>(x_split, x_reduced,
+                                              ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
+  // x * c_mid = pm.hi + pm.lo exactly.
+  DoubleDouble pm = fputil::exact_mult<SPLIT>(x_split, x_reduced,
+                                              ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
+  // x * c_lo = pl.hi + pl.lo exactly.
+  DoubleDouble pl = fputil::exact_mult<SPLIT>(x_split, x_reduced,
+                                              ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
+  // Extract integral parts and fractional parts of (ph.lo + pm.hi).
+  double sum_hi = ph.lo + pm.hi;
+  double kd = fputil::nearest_integer(sum_hi);
+
+  // x * 128/pi mod 1 ~ y_hi + y_mid + y_lo
+  y_hi = (ph.lo - kd) + pm.hi; // Exact
+  y_mid = fputil::exact_add(pm.lo, pl.hi);
+  y_lo = pl.lo;
+
+  // y_l = x * c_lo_2 + pl.lo
+  double y_l =
+      fputil::multiply_add(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][3], y_lo);
+  DoubleDouble y = fputil::exact_add(y_hi, y_mid.hi);
+  y.lo += (y_mid.lo + y_l);
+
+  // Digits of pi/128, generated by Sollya with:
+  // > a = round(pi/128, D, RN);
+  // > b = round(pi/128 - a, D, RN);
+  constexpr DoubleDouble PI_OVER_128_DD = {0x1.1a62633145c07p-60,
+                                           0x1.921fb54442d18p-6};
+
+  // Error bound: with {a} denote the fractional part of a, i.e.:
+  //   {a} = a - round(a)
+  // Then,
+  //   | {x * 128/pi} - (y_hi + y_lo) | <=  ulp(ulp(y_hi)) <= 2^-105
+  //   | {x mod pi/128} - (u.hi + u.lo) | < 2 * 2^-6 * 2^-105 = 2^-110
+  u = fputil::quick_mult<SPLIT>(y, PI_OVER_128_DD);
+
+  return static_cast<unsigned>(static_cast<int64_t>(kd));
+}
+
+// Lookup table for sin(k * pi / 128) with k = 0, ..., 255.
+// Table is generated with Sollya as follow:
+// > display = hexadecimal;
+// > for k from 0 to 255 do {
+//     a = round(sin(k * pi/128), 51, RN);
+//     b = round(sin(k * pi/128) - a, D, RN);
+//     print("{", b, ",", a, "},");
+//   };
+LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[256] = {
+    {0, 0},
+    {0x1.f938a73db97fbp-58, 0x1.92155f7a3667cp-6},
+    {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
+    {0x1.ccbeeeae8129ap-56, 0x1.2d52092ce19f4p-4},
+    {-0x1.e2718d26ed688p-60, 0x1.917a6bc29b42cp-4},
+    {-0x1.cbb1f71aca352p-56, 0x1.f564e56a9731p-4},
+    {-0x1.dd9ffeaecbdc4p-55, 0x1.2c8106e8e613cp-3},
+    {-0x1.ab3802218894fp-55, 0x1.5e214448b3fc8p-3},
+    {-0x1.49b466e7fe36p-55, 0x1.8f8b83c69a60cp-3},
+    {-0x1.035e2873ca432p-55, 0x1.c0b826a7e4f64p-3},
+    {-0x1.50b7bbc4768b1p-55, 0x1.f19f97b215f1cp-3},
+    {-0x1.3ed9efaa42ab3p-55, 0x1.111d262b1f678p-2},
+    {0x1.a8b5c974ee7b5p-54, 0x1.294062ed59f04p-2},
+    {0x1.4325f12be8946p-54, 0x1.4135c941766p-2},
+    {0x1.fc2047e54e614p-55, 0x1.58f9a75ab1fdcp-2},
+    {-0x1.512c678219317p-54, 0x1.7088530fa45ap-2},
+    {-0x1.2e59dba7ab4c2p-54, 0x1.87de2a6aea964p-2},
+    {-0x1.d24afdade848bp-54, 0x1.9ef7943a8ed8cp-2},
+    {0x1.5b362cb974183p-57, 0x1.b5d1009e15ccp-2},
+    {-0x1.e97af1a63c807p-54, 0x1.cc66e9931c46p-2},
+    {-0x1.c3e4edc5872f8p-55, 0x1.e2b5d3806f63cp-2},
+    {0x1.fb44f80f92225p-54, 0x1.f8ba4dbf89ab8p-2},
+    {0x1.9697faf2e2fe5p-53, 0x1.073879922ffecp-1},
+    {-0x1.7bc8eda6af93cp-53, 0x1.11eb3541b4b24p-1},
+    {0x1.b25dd267f66p-55, 0x1.1c73b39ae68c8p-1},
+    {-0x1.5769d0fbcddc3p-53, 0x1.26d054cdd12ep-1},
+    {0x1.c20673b2116b2p-54, 0x1.30ff7fce17034p-1},
+    {0x1.3c7c4bc72a92cp-53, 0x1.3affa292050b8p-1},
+    {-0x1.e7f895d302395p-53, 0x1.44cf325091dd8p-1},
+    {0x1.13c293edceb32p-53, 0x1.4e6cabbe3e5e8p-1},
+    {-0x1.75720992bfbb2p-55, 0x1.57d69348cecap-1},
+    {-0x1.24a366a5fe547p-53, 0x1.610b7551d2cep-1},
+    {0x1.21165f626cdd5p-54, 0x1.6a09e667f3bccp-1},
+    {-0x1.bcac43c389ba9p-53, 0x1.72d0837efff98p-1},
+    {-0x1.21ea6f59be15bp-53, 0x1.7b5df226aafbp-1},
+    {0x1.d217be0e2b971p-53, 0x1.83b0e0bff976cp-1},
+    {0x1.69d0f6897664ap-54, 0x1.8bc806b15174p-1},
+    {-0x1.615f32b6f907ap-54, 0x1.93a22499263fcp-1},
+    {0x1.6788ebcc76dc6p-54, 0x1.9b3e047f3874p-1},
+    {0x1.ddae89fd441d1p-53, 0x1.a29a7a046278p-1},
+    {-0x1.f98273c5d2495p-54, 0x1.a9b66290ea1a4p-1},
+    {-0x1.926da300ffccep-55, 0x1.b090a581502p-1},
+    {0x1.90e58336c64a8p-53, 0x1.b728345196e3cp-1},
+    {0x1.9f6963354e3fep-53, 0x1.bd7c0ac6f9528p-1},
+    {0x1.a47d3a2a0dcbep-54, 0x1.c38b2f180bdbp-1},
+    {0x1.ed0489e16b9ap-54, 0x1.c954b213411f4p-1},
+    {-0x1.0f3db5dad5ac5p-53, 0x1.ced7af43cc774p-1},
+    {0x1.ac42b5a8b6943p-53, 0x1.d4134d14dc938p-1},
+    {-0x1.d75033dfb9ca8p-53, 0x1.d906bcf328d48p-1},
+    {0x1.83c37c6107db3p-55, 0x1.ddb13b6ccc23cp-1},
+    {0x1.7f59c49f6cd6dp-54, 0x1.e212104f686e4p-1},
+    {0x1.ee94a90d7b88bp-53, 0x1.e6288ec48e11p-1},
+    {-0x1.a27d3874701f9p-53, 0x1.e9f4156c62ddcp-1},
+    {-0x1.85f4e1b8298dp-54, 0x1.ed740e7684964p-1},
+    {-0x1.ab4e148e52d9ep-54, 0x1.f0a7efb9230d8p-1},
+    {0x1.8a11412b82346p-54, 0x1.f38f3ac64e588p-1},
+    {0x1.562172a361fd3p-56, 0x1.f6297cff75cbp-1},
+    {0x1.3564acef1ff97p-53, 0x1.f8764fa714ba8p-1},
+    {-0x1.5e82a3284d5c8p-53, 0x1.fa7557f08a518p-1},
+    {-0x1.709bccb89a989p-54, 0x1.fc26470e19fd4p-1},
+    {0x1.9e082721dfb8ep-53, 0x1.fd88da3d12524p-1},
+    {-0x1.eade132f3981dp-53, 0x1.fe9cdad01883cp-1},
+    {0x1.e3a843d1db55fp-53, 0x1.ff621e3796d7cp-1},
+    {0x1.765595d548d9ap-54, 0x1.ffd886084cd0cp-1},
+    {0, 1},
+#ifndef LIBC_MATH_HAS_SMALL_TABLES
+    {0x1.765595d548d9ap-54, 0x1.ffd886084cd0cp-1},
+    {0x1.e3a843d1db55fp-53, 0x1.ff621e3796d7cp-1},
+    {-0x1.eade132f3981dp-53, 0x1.fe9cdad01883cp-1},
+    {0x1.9e082721dfb8ep-53, 0x1.fd88da3d12524p-1},
+    {-0x1.709bccb89a989p-54, 0x1.fc26470e19fd4p-1},
+    {-0x1.5e82a3284d5c8p-53, 0x1.fa7557f08a518p-1},
+    {0x1.3564acef1ff97p-53, 0x1.f8764fa714ba8p-1},
+    {0x1.562172a361fd3p-56, 0x1.f6297cff75cbp-1},
+    {0x1.8a11412b82346p-54, 0x1.f38f3ac64e588p-1},
+    {-0x1.ab4e148e52d9ep-54, 0x1.f0a7efb9230d8p-1},
+    {-0x1.85f4e1b8298dp-54, 0x1.ed740e7684964p-1},
+    {-0x1.a27d3874701f9p-53, 0x1.e9f4156c62ddcp-1},
+    {0x1.ee94a90d7b88bp-53, 0x1.e6288ec48e11p-1},
+    {0x1.7f59c49f6cd6dp-54, 0x1.e212104f686e4p-1},
+    {0x1.83c37c6107db3p-55, 0x1.ddb13b6ccc23cp-1},
+    {-0x1.d75033dfb9ca8p-53, 0x1.d906bcf328d48p-1},
+    {0x1.ac42b5a8b6943p-53, 0x1.d4134d14dc938p-1},
+    {-0x1.0f3db5dad5ac5p-53, 0x1.ced7af43cc774p-1},
+    {0x1.ed0489e16b9ap-54, 0x1.c954b213411f4p-1},
+    {0x1.a47d3a2a0dcbep-54, 0x1.c38b2f180bdbp-1},
+    {0x1.9f6963354e3fep-53, 0x1.bd7c0ac6f9528p-1},
+    {0x1.90e58336c64a8p-53, 0x1.b728345196e3cp-1},
+    {-0x1.926da300ffccep-55, 0x1.b090a581502p-1},
+    {-0x1.f98273c5d2495p-54, 0x1.a9b66290ea1a4p-1},
+    {0x1.ddae89fd441d1p-53, 0x1.a29a7a046278p-1},
+    {0x1.6788ebcc76dc6p-54, 0x1.9b3e047f3874p-1},
+    {-0x1.615f32b6f907ap-54, 0x1.93a22499263fcp-1},
+    {0x1.69d0f6897664ap-54, 0x1.8bc806b15174p-1},
+    {0x1.d217be0e2b971p-53, 0x1.83b0e0bff976cp-1},
+    {-0x1.21ea6f59be15bp-53, 0x1.7b5df226aafbp-1},
+    {-0x1.bcac43c389ba9p-53, 0x1.72d0837efff98p-1},
+    {0x1.21165f626cdd5p-54, 0x1.6a09e667f3bccp-1},
+    {-0x1.24a366a5fe547p-53, 0x1.610b7551d2cep-1},
+    {-0x1.75720992bfbb2p-55, 0x1.57d69348cecap-1},
+    {0x1.13c293edceb32p-53, 0x1.4e6cabbe3e5e8p-1},
+    {-0x1.e7f895d302395p-53, 0x1.44cf325091dd8p-1},
+    {0x1.3c7c4bc72a92cp-53, 0x1.3affa292050b8p-1},
+    {0x1.c20673b2116b2p-54, 0x1.30ff7fce17034p-1},
+    {-0x1.5769d0fbcddc3p-53, 0x1.26d054cdd12ep-1},
+    {0x1.b25dd267f66p-55, 0x1.1c73b39ae68c8p-1},
+    {-0x1.7bc8eda6af93cp-53, 0x1.11eb3541b4b24p-1},
+    {0x1.9697faf2e2fe5p-53, 0x1.073879922ffecp-1},
+    {0x1.fb44f80f92225p-54, 0x1.f8ba4dbf89ab8p-2},
+    {-0x1.c3e4edc5872f8p-55, 0x1.e2b5d3806f63cp-2},
+    {-0x1.e97af1a63c807p-54, 0x1.cc66e9931c46p-2},
+    {0x1.5b362cb974183p-57, 0x1.b5d1009e15ccp-2},
+    {-0x1.d24afdade848bp-54, 0x1.9ef7943a8ed8cp-2},
+    {-0x1.2e59dba7ab4c2p-54, 0x1.87de2a6aea964p-2},
+    {-0x1.512c678219317p-54, 0x1.7088530fa45ap-2},
+    {0x1.fc2047e54e614p-55, 0x1.58f9a75ab1fdcp-2},
+    {0x1.4325f12be8946p-54, 0x1.4135c941766p-2},
+    {0x1.a8b5c974ee7b5p-54, 0x1.294062ed59f04p-2},
+    {-0x1.3ed9efaa42ab3p-55, 0x1.111d262b1f678p-2},
+    {-0x1.50b7bbc4768b1p-55, 0x1.f19f97b215f1cp-3},
+    {-0x1.035e2873ca432p-55, 0x1.c0b826a7e4f64p-3},
+    {-0x1.49b466e7fe36p-55, 0x1.8f8b83c69a60cp-3},
+    {-0x1.ab3802218894fp-55, 0x1.5e214448b3fc8p-3},
+    {-0x1.dd9ffeaecbdc4p-55, 0x1.2c8106e8e613cp-3},
+    {-0x1.cbb1f71aca352p-56, 0x1.f564e56a9731p-4},
+    {-0x1.e2718d26ed688p-60, 0x1.917a6bc29b42cp-4},
+    {0x1.ccbeeeae8129ap-56, 0x1.2d52092ce19f4p-4},
+    {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
+    {0x1.f938a73db97fbp-58, 0x1.92155f7a3667cp-6},
+    {0, 0},
+    {-0x1.f938a73db97fbp-58, -0x1.92155f7a3667cp-6},
+    {0x1.912bd0d569a9p-61, -0x1.91f65f10dd814p-5},
+    {-0x1.ccbeeeae8129ap-56, -0x1.2d52092ce19f4p-4},
+    {0x1.e2718d26ed688p-60, -0x1.917a6bc29b42cp-4},
+    {0x1.cbb1f71aca352p-56, -0x1.f564e56a9731p-4},
+    {0x1.dd9ffeaecbdc4p-55, -0x1.2c8106e8e613cp-3},
+    {0x1.ab3802218894fp-55, -0x1.5e214448b3fc8p-3},
+    {0x1.49b466e7fe36p-55, -0x1.8f8b83c69a60cp-3},
+    {0x1.035e2873ca432p-55, -0x1.c0b826a7e4f64p-3},
+    {0x1.50b7bbc4768b1p-55, -0x1.f19f97b215f1cp-3},
+    {0x1.3ed9efaa42ab3p-55, -0x1.111d262b1f678p-2},
+    {-0x1.a8b5c974ee7b5p-54, -0x1.294062ed59f04p-2},
+    {-0x1.4325f12be8946p-54, -0x1.4135c941766p-2},
+    {-0x1.fc2047e54e614p-55, -0x1.58f9a75ab1fdcp-2},
+    {0x1.512c678219317p-54, -0x1.7088530fa45ap-2},
+    {0x1.2e59dba7ab4c2p-54, -0x1.87de2a6aea964p-2},
+    {0x1.d24afdade848bp-54, -0x1.9ef7943a8ed8cp-2},
+    {-0x1.5b362cb974183p-57, -0x1.b5d1009e15ccp-2},
+    {0x1.e97af1a63c807p-54, -0x1.cc66e9931c46p-2},
+    {0x1.c3e4edc5872f8p-55, -0x1.e2b5d3806f63cp-2},
+    {-0x1.fb44f80f92225p-54, -0x1.f8ba4dbf89ab8p-2},
+    {-0x1.9697faf2e2fe5p-53, -0x1.073879922ffecp-1},
+    {0x1.7bc8eda6af93cp-53, -0x1.11eb3541b4b24p-1},
+    {-0x1.b25dd267f66p-55, -0x1.1c73b39ae68c8p-1},
+    {0x1.5769d0fbcddc3p-53, -0x1.26d054cdd12ep-1},
+    {-0x1.c20673b2116b2p-54, -0x1.30ff7fce17034p-1},
+    {-0x1.3c7c4bc72a92cp-53, -0x1.3affa292050b8p-1},
+    {0x1.e7f895d302395p-53, -0x1.44cf325091dd8p-1},
+    {-0x1.13c293edceb32p-53, -0x1.4e6cabbe3e5e8p-1},
+    {0x1.75720992bfbb2p-55, -0x1.57d69348cecap-1},
+    {0x1.24a366a5fe547p-53, -0x1.610b7551d2cep-1},
+    {-0x1.21165f626cdd5p-54, -0x1.6a09e667f3bccp-1},
+    {0x1.bcac43c389ba9p-53, -0x1.72d0837efff98p-1},
+    {0x1.21ea6f59be15bp-53, -0x1.7b5df226aafbp-1},
+    {-0x1.d217be0e2b971p-53, -0x1.83b0e0bff976cp-1},
+    {-0x1.69d0f6897664ap-54, -0x1.8bc806b15174p-1},
+    {0x1.615f32b6f907ap-54, -0x1.93a22499263fcp-1},
+    {-0x1.6788ebcc76dc6p-54, -0x1.9b3e047f3874p-1},
+    {-0x1.ddae89fd441d1p-53, -0x1.a29a7a046278p-1},
+    {0x1.f98273c5d2495p-54, -0x1.a9b66290ea1a4p-1},
+    {0x1.926da300ffccep-55, -0x1.b090a581502p-1},
+    {-0x1.90e58336c64a8p-53, -0x1.b728345196e3cp-1},
+    {-0x1.9f6963354e3fep-53, -0x1.bd7c0ac6f9528p-1},
+    {-0x1.a47d3a2a0dcbep-54, -0x1.c38b2f180bdbp-1},
+    {-0x1.ed0489e16b9ap-54, -0x1.c954b213411f4p-1},
+    {0x1.0f3db5dad5ac5p-53, -0x1.ced7af43cc774p-1},
+    {-0x1.ac42b5a8b6943p-53, -0x1.d4134d14dc938p-1},
+    {0x1.d75033dfb9ca8p-53, -0x1.d906bcf328d48p-1},
+    {-0x1.83c37c6107db3p-55, -0x1.ddb13b6ccc23cp-1},
+    {-0x1.7f59c49f6cd6dp-54, -0x1.e212104f686e4p-1},
+    {-0x1.ee94a90d7b88bp-53, -0x1.e6288ec48e11p-1},
+    {0x1.a27d3874701f9p-53, -0x1.e9f4156c62ddcp-1},
+    {0x1.85f4e1b8298dp-54, -0x1.ed740e7684964p-1},
+    {0x1.ab4e148e52d9ep-54, -0x1.f0a7efb9230d8p-1},
+    {-0x1.8a11412b82346p-54, -0x1.f38f3ac64e588p-1},
+    {-0x1.562172a361fd3p-56, -0x1.f6297cff75cbp-1},
+    {-0x1.3564acef1ff97p-53, -0x1.f8764fa714ba8p-1},
+    {0x1.5e82a3284d5c8p-53, -0x1.fa7557f08a518p-1},
+    {0x1.709bccb89a989p-54, -0x1.fc26470e19fd4p-1},
+    {-0x1.9e082721dfb8ep-53, -0x1.fd88da3d12524p-1},
+    {0x1.eade132f3981dp-53, -0x1.fe9cdad01883cp-1},
+    {-0x1.e3a843d1db55fp-53, -0x1.ff621e3796d7cp-1},
+    {-0x1.765595d548d9ap-54, -0x1.ffd886084cd0cp-1},
+    {0, -1},
+    {-0x1.765595d548d9ap-54, -0x1.ffd886084cd0cp-1},
+    {-0x1.e3a843d1db55fp-53, -0x1.ff621e3796d7cp-1},
+    {0x1.eade132f3981dp-53, -0x1.fe9cdad01883cp-1},
+    {-0x1.9e082721dfb8ep-53, -0x1.fd88da3d12524p-1},
+    {0x1.709bccb89a989p-54, -0x1.fc26470e19fd4p-1},
+    {0x1.5e82a3284d5c8p-53, -0x1.fa7557f08a518p-1},
+    {-0x1.3564acef1ff97p-53, -0x1.f8764fa714ba8p-1},
+    {-0x1.562172a361fd3p-56, -0x1.f6297cff75cbp-1},
+    {-0x1.8a11412b82346p-54, -0x1.f38f3ac64e588p-1},
+    {0x1.ab4e148e52d9ep-54, -0x1.f0a7efb9230d8p-1},
+    {0x1.85f4e1b8298dp-54, -0x1.ed740e7684964p-1},
+    {0x1.a27d3874701f9p-53, -0x1.e9f4156c62ddcp-1},
+    {-0x1.ee94a90d7b88bp-53, -0x1.e6288ec48e11p-1},
+    {-0x1.7f59c49f6cd6dp-54, -0x1.e212104f686e4p-1},
+    {-0x1.83c37c6107db3p-55, -0x1.ddb13b6ccc23cp-1},
+    {0x1.d75033dfb9ca8p-53, -0x1.d906bcf328d48p-1},
+    {-0x1.ac42b5a8b6943p-53, -0x1.d4134d14dc938p-1},
+    {0x1.0f3db5dad5ac5p-53, -0x1.ced7af43cc774p-1},
+    {-0x1.ed0489e16b9ap-54, -0x1.c954b213411f4p-1},
+    {-0x1.a47d3a2a0dcbep-54, -0x1.c38b2f180bdbp-1},
+    {-0x1.9f6963354e3fep-53, -0x1.bd7c0ac6f9528p-1},
+    {-0x1.90e58336c64a8p-53, -0x1.b728345196e3cp-1},
+    {0x1.926da300ffccep-55, -0x1.b090a581502p-1},
+    {0x1.f98273c5d2495p-54, -0x1.a9b66290ea1a4p-1},
+    {-0x1.ddae89fd441d1p-53, -0x1.a29a7a046278p-1},
+    {-0x1.6788ebcc76dc6p-54, -0x1.9b3e047f3874p-1},
+    {0x1.615f32b6f907ap-54, -0x1.93a22499263fcp-1},
+    {-0x1.69d0f6897664ap-54, -0x1.8bc806b15174p-1},
+    {-0x1.d217be0e2b971p-53, -0x1.83b0e0bff976cp-1},
+    {0x1.21ea6f59be15bp-53, -0x1.7b5df226aafbp-1},
+    {0x1.bcac43c389ba9p-53, -0x1.72d0837efff98p-1},
+    {-0x1.21165f626cdd5p-54, -0x1.6a09e667f3bccp-1},
+    {0x1.24a366a5fe547p-53, -0x1.610b7551d2cep-1},
+    {0x1.75720992bfbb2p-55, -0x1.57d69348cecap-1},
+    {-0x1.13c293edceb32p-53, -0x1.4e6cabbe3e5e8p-1},
+    {0x1.e7f895d302395p-53, -0x1.44cf325091dd8p-1},
+    {-0x1.3c7c4bc72a92cp-53, -0x1.3affa292050b8p-1},
+    {-0x1.c20673b2116b2p-54, -0x1.30ff7fce17034p-1},
+    {0x1.5769d0fbcddc3p-53, -0x1.26d054cdd12ep-1},
+    {-0x1.b25dd267f66p-55, -0x1.1c73b39ae68c8p-1},
+    {0x1.7bc8eda6af93cp-53, -0x1.11eb3541b4b24p-1},
+    {-0x1.9697faf2e2fe5p-53, -0x1.073879922ffecp-1},
+    {-0x1.fb44f80f92225p-54, -0x1.f8ba4dbf89ab8p-2},
+    {0x1.c3e4edc5872f8p-55, -0x1.e2b5d3806f63cp-2},
+    {0x1.e97af1a63c807p-54, -0x1.cc66e9931c46p-2},
+    {-0x1.5b362cb974183p-57, -0x1.b5d1009e15ccp-2},
+    {0x1.d24afdade848bp-54, -0x1.9ef7943a8ed8cp-2},
+    {0x1.2e59dba7ab4c2p-54, -0x1.87de2a6aea964p-2},
+    {0x1.512c678219317p-54, -0x1.7088530fa45ap-2},
+    {-0x1.fc2047e54e614p-55, -0x1.58f9a75ab1fdcp-2},
+    {-0x1.4325f12be8946p-54, -0x1.4135c941766p-2},
+    {-0x1.a8b5c974ee7b5p-54, -0x1.294062ed59f04p-2},
+    {0x1.3ed9efaa42ab3p-55, -0x1.111d262b1f678p-2},
+    {0x1.50b7bbc4768b1p-55, -0x1.f19f97b215f1cp-3},
+    {0x1.035e2873ca432p-55, -0x1.c0b826a7e4f64p-3},
+    {0x1.49b466e7fe36p-55, -0x1.8f8b83c69a60cp-3},
+    {0x1.ab3802218894fp-55, -0x1.5e214448b3fc8p-3},
+    {0x1.dd9ffeaecbdc4p-55, -0x1.2c8106e8e613cp-3},
+    {0x1.cbb1f71aca352p-56, -0x1.f564e56a9731p-4},
+    {0x1.e2718d26ed688p-60, -0x1.917a6bc29b42cp-4},
+    {-0x1.ccbeeeae8129ap-56, -0x1.2d52092ce19f4p-4},
+    {0x1.912bd0d569a9p-61, -0x1.91f65f10dd814p-5},
+    {-0x1.f938a73db97fbp-58, -0x1.92155f7a3667cp-6},
+#endif // !LIBC_MATH_HAS_SMALL_TABLES
+};
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_NOFMA_H
diff --git a/src/math/generic/range_reduction_fma.h b/src/math/generic/range_reduction_fma.h
index 82b4ae1..537d572 100644
--- a/src/math/generic/range_reduction_fma.h
+++ b/src/math/generic/range_reduction_fma.h
@@ -12,9 +12,9 @@
 #include "src/__support/FPUtil/FMA.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/nearest_integer.h"
-#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace fma {
 
@@ -87,6 +87,6 @@ LIBC_INLINE int64_t large_range_reduction(double x, int x_exp, double &y) {
 
 } // namespace fma
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_FMA_H
diff --git a/src/math/generic/remainder.cpp b/src/math/generic/remainder.cpp
index 3703a32..a22ffc4 100644
--- a/src/math/generic/remainder.cpp
+++ b/src/math/generic/remainder.cpp
@@ -9,12 +9,13 @@
 #include "src/math/remainder.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remainder, (double x, double y)) {
   int quotient;
   return fputil::remquo(x, y, quotient);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remainderf.cpp b/src/math/generic/remainderf.cpp
index 5e8c5e9..44e32e9 100644
--- a/src/math/generic/remainderf.cpp
+++ b/src/math/generic/remainderf.cpp
@@ -9,12 +9,13 @@
 #include "src/math/remainderf.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remainderf, (float x, float y)) {
   int quotient;
   return fputil::remquo(x, y, quotient);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remainderf128.cpp b/src/math/generic/remainderf128.cpp
new file mode 100644
index 0000000..52b6c51
--- /dev/null
+++ b/src/math/generic/remainderf128.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of remainderf128 function --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/remainderf128.h"
+#include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float128, remainderf128, (float128 x, float128 y)) {
+  int quotient;
+  return fputil::remquo(x, y, quotient);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remainderf16.cpp b/src/math/generic/remainderf16.cpp
index 3517722..2b64882 100644
--- a/src/math/generic/remainderf16.cpp
+++ b/src/math/generic/remainderf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/remainderf16.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, remainderf16, (float16 x, float16 y)) {
   int quotient;
   return fputil::remquo(x, y, quotient);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remainderl.cpp b/src/math/generic/remainderl.cpp
index def5d4b..a61a13e 100644
--- a/src/math/generic/remainderl.cpp
+++ b/src/math/generic/remainderl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/remainderl.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, remainderl, (long double x, long double y)) {
   int quotient;
   return fputil::remquo(x, y, quotient);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remquo.cpp b/src/math/generic/remquo.cpp
index bd88742..45deb81 100644
--- a/src/math/generic/remquo.cpp
+++ b/src/math/generic/remquo.cpp
@@ -9,11 +9,12 @@
 #include "src/math/remquo.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remquo, (double x, double y, int *exp)) {
   return fputil::remquo(x, y, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remquof.cpp b/src/math/generic/remquof.cpp
index b59606f..f3616ab 100644
--- a/src/math/generic/remquof.cpp
+++ b/src/math/generic/remquof.cpp
@@ -9,11 +9,12 @@
 #include "src/math/remquof.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remquof, (float x, float y, int *exp)) {
   return fputil::remquo(x, y, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remquof128.cpp b/src/math/generic/remquof128.cpp
index e195c7b..cf8f564 100644
--- a/src/math/generic/remquof128.cpp
+++ b/src/math/generic/remquof128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/remquof128.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, remquof128, (float128 x, float128 y, int *exp)) {
   return fputil::remquo(x, y, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remquof16.cpp b/src/math/generic/remquof16.cpp
index a373bfa..3a5baad 100644
--- a/src/math/generic/remquof16.cpp
+++ b/src/math/generic/remquof16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/remquof16.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, remquof16, (float16 x, float16 y, int *exp)) {
   return fputil::remquo(x, y, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/remquol.cpp b/src/math/generic/remquol.cpp
index 7a08af3..980f50c 100644
--- a/src/math/generic/remquol.cpp
+++ b/src/math/generic/remquol.cpp
@@ -9,12 +9,13 @@
 #include "src/math/remquol.h"
 #include "src/__support/FPUtil/DivisionAndRemainderOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, remquol,
                    (long double x, long double y, int *exp)) {
   return fputil::remquo(x, y, *exp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/rint.cpp b/src/math/generic/rint.cpp
index e3189ea..5defa60 100644
--- a/src/math/generic/rint.cpp
+++ b/src/math/generic/rint.cpp
@@ -9,11 +9,16 @@
 #include "src/math/rint.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, rint, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_rint(x);
+#else
   return fputil::round_using_current_rounding_mode(x);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/rintf.cpp b/src/math/generic/rintf.cpp
index 259a46f..2fe7788 100644
--- a/src/math/generic/rintf.cpp
+++ b/src/math/generic/rintf.cpp
@@ -9,11 +9,16 @@
 #include "src/math/rintf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, rintf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_rintf(x);
+#else
   return fputil::round_using_current_rounding_mode(x);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/rintf128.cpp b/src/math/generic/rintf128.cpp
index ba9912d..f3b8afa 100644
--- a/src/math/generic/rintf128.cpp
+++ b/src/math/generic/rintf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/rintf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, rintf128, (float128 x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/rintf16.cpp b/src/math/generic/rintf16.cpp
index e0caa7a..aefdcbe 100644
--- a/src/math/generic/rintf16.cpp
+++ b/src/math/generic/rintf16.cpp
@@ -8,12 +8,20 @@
 
 #include "src/math/rintf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, rintf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC) &&                       \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_rintf(x));
+#else
   return fputil::round_using_current_rounding_mode(x);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/rintl.cpp b/src/math/generic/rintl.cpp
index 5110f23..007d29a 100644
--- a/src/math/generic/rintl.cpp
+++ b/src/math/generic/rintl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/rintl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, rintl, (long double x)) {
   return fputil::round_using_current_rounding_mode(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/round.cpp b/src/math/generic/round.cpp
index ca8f19f..6ed5be5 100644
--- a/src/math/generic/round.cpp
+++ b/src/math/generic/round.cpp
@@ -9,9 +9,16 @@
 #include "src/math/round.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, round, (double x)) { return fputil::round(x); }
+LLVM_LIBC_FUNCTION(double, round, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_ROUND
+  return __builtin_round(x);
+#else
+  return fputil::round(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundeven.cpp b/src/math/generic/roundeven.cpp
index 5f2adf9..42f19f3 100644
--- a/src/math/generic/roundeven.cpp
+++ b/src/math/generic/roundeven.cpp
@@ -9,11 +9,16 @@
 #include "src/math/roundeven.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, roundeven, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_ROUNDEVEN
+  return __builtin_roundeven(x);
+#else
   return fputil::round_using_specific_rounding_mode(x, FP_INT_TONEAREST);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundevenf.cpp b/src/math/generic/roundevenf.cpp
index 353bec7..98bdc65 100644
--- a/src/math/generic/roundevenf.cpp
+++ b/src/math/generic/roundevenf.cpp
@@ -9,11 +9,16 @@
 #include "src/math/roundevenf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, roundevenf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_ROUNDEVEN
+  return __builtin_roundevenf(x);
+#else
   return fputil::round_using_specific_rounding_mode(x, FP_INT_TONEAREST);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundevenf128.cpp b/src/math/generic/roundevenf128.cpp
index 259388c..354076b 100644
--- a/src/math/generic/roundevenf128.cpp
+++ b/src/math/generic/roundevenf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/roundevenf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, roundevenf128, (float128 x)) {
   return fputil::round_using_specific_rounding_mode(x, FP_INT_TONEAREST);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundevenf16.cpp b/src/math/generic/roundevenf16.cpp
index 9ecf79c..fdcd968 100644
--- a/src/math/generic/roundevenf16.cpp
+++ b/src/math/generic/roundevenf16.cpp
@@ -8,12 +8,20 @@
 
 #include "src/math/roundevenf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, roundevenf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_ROUNDEVEN) &&                                   \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_roundevenf(x));
+#else
   return fputil::round_using_specific_rounding_mode(x, FP_INT_TONEAREST);
+#endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundevenl.cpp b/src/math/generic/roundevenl.cpp
index f8f429f..6ffe80a 100644
--- a/src/math/generic/roundevenl.cpp
+++ b/src/math/generic/roundevenl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/roundevenl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, roundevenl, (long double x)) {
   return fputil::round_using_specific_rounding_mode(x, FP_INT_TONEAREST);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundf.cpp b/src/math/generic/roundf.cpp
index 9627390..d25f712 100644
--- a/src/math/generic/roundf.cpp
+++ b/src/math/generic/roundf.cpp
@@ -9,9 +9,16 @@
 #include "src/math/roundf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, roundf, (float x)) { return fputil::round(x); }
+LLVM_LIBC_FUNCTION(float, roundf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_ROUND
+  return __builtin_roundf(x);
+#else
+  return fputil::round(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundf128.cpp b/src/math/generic/roundf128.cpp
index 5b35d74..88a545e 100644
--- a/src/math/generic/roundf128.cpp
+++ b/src/math/generic/roundf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/roundf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, roundf128, (float128 x)) {
   return fputil::round(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundf16.cpp b/src/math/generic/roundf16.cpp
index 75a255d..9adfb52 100644
--- a/src/math/generic/roundf16.cpp
+++ b/src/math/generic/roundf16.cpp
@@ -8,10 +8,20 @@
 
 #include "src/math/roundf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float16, roundf16, (float16 x)) { return fputil::round(x); }
+LLVM_LIBC_FUNCTION(float16, roundf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_ROUND) &&                                       \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_roundf(x));
+#else
+  return fputil::round(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/roundl.cpp b/src/math/generic/roundl.cpp
index c734225..0f7b29e 100644
--- a/src/math/generic/roundl.cpp
+++ b/src/math/generic/roundl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/roundl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, roundl, (long double x)) {
   return fputil::round(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbln.cpp b/src/math/generic/scalbln.cpp
new file mode 100644
index 0000000..f976199
--- /dev/null
+++ b/src/math/generic/scalbln.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of scalbln function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/scalbln.h"
+#include "hdr/float_macros.h"
+#include "src/__support/FPUtil/ManipulationFunctions.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#if FLT_RADIX != 2
+#error "FLT_RADIX != 2 is not supported."
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, scalbln, (double x, long n)) {
+  return fputil::ldexp(x, n);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalblnf.cpp b/src/math/generic/scalblnf.cpp
new file mode 100644
index 0000000..aa11a55
--- /dev/null
+++ b/src/math/generic/scalblnf.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of scalblnf function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/scalblnf.h"
+#include "hdr/float_macros.h"
+#include "src/__support/FPUtil/ManipulationFunctions.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#if FLT_RADIX != 2
+#error "FLT_RADIX != 2 is not supported."
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, scalblnf, (float x, long n)) {
+  return fputil::ldexp(x, n);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalblnf128.cpp b/src/math/generic/scalblnf128.cpp
new file mode 100644
index 0000000..fda6ea0
--- /dev/null
+++ b/src/math/generic/scalblnf128.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of scalblnf128 function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/scalblnf128.h"
+#include "hdr/float_macros.h"
+#include "src/__support/FPUtil/ManipulationFunctions.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#if FLT_RADIX != 2
+#error "FLT_RADIX != 2 is not supported."
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float128, scalblnf128, (float128 x, long n)) {
+  return fputil::ldexp(x, n);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalblnf16.cpp b/src/math/generic/scalblnf16.cpp
index 844a071..7f43841 100644
--- a/src/math/generic/scalblnf16.cpp
+++ b/src/math/generic/scalblnf16.cpp
@@ -11,15 +11,16 @@
 #include "src/__support/common.h"
 
 #include "hdr/float_macros.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, scalblnf16, (float16 x, long n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalblnl.cpp b/src/math/generic/scalblnl.cpp
new file mode 100644
index 0000000..5823c49
--- /dev/null
+++ b/src/math/generic/scalblnl.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of scalblnl function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/scalblnl.h"
+#include "hdr/float_macros.h"
+#include "src/__support/FPUtil/ManipulationFunctions.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#if FLT_RADIX != 2
+#error "FLT_RADIX != 2 is not supported."
+#endif
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long double, scalblnl, (long double x, long n)) {
+  return fputil::ldexp(x, n);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbn.cpp b/src/math/generic/scalbn.cpp
index 207cce1..c1ee994 100644
--- a/src/math/generic/scalbn.cpp
+++ b/src/math/generic/scalbn.cpp
@@ -10,15 +10,16 @@
 #include "hdr/float_macros.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, scalbn, (double x, int n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbnf.cpp b/src/math/generic/scalbnf.cpp
index e478088..4281b00 100644
--- a/src/math/generic/scalbnf.cpp
+++ b/src/math/generic/scalbnf.cpp
@@ -10,15 +10,16 @@
 #include "hdr/float_macros.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, scalbnf, (float x, int n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbnf128.cpp b/src/math/generic/scalbnf128.cpp
index 5fd5961..e3e2846 100644
--- a/src/math/generic/scalbnf128.cpp
+++ b/src/math/generic/scalbnf128.cpp
@@ -10,15 +10,16 @@
 #include "hdr/float_macros.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, scalbnf128, (float128 x, int n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbnf16.cpp b/src/math/generic/scalbnf16.cpp
index a42fdff..641e2d0 100644
--- a/src/math/generic/scalbnf16.cpp
+++ b/src/math/generic/scalbnf16.cpp
@@ -11,15 +11,16 @@
 #include "src/__support/common.h"
 
 #include "hdr/float_macros.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, scalbnf16, (float16 x, int n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/scalbnl.cpp b/src/math/generic/scalbnl.cpp
index 1225a7e..3015c3c 100644
--- a/src/math/generic/scalbnl.cpp
+++ b/src/math/generic/scalbnl.cpp
@@ -10,15 +10,16 @@
 #include "hdr/float_macros.h"
 #include "src/__support/FPUtil/ManipulationFunctions.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #if FLT_RADIX != 2
 #error "FLT_RADIX != 2 is not supported."
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, scalbnl, (long double x, int n)) {
   return fputil::ldexp(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayload.cpp b/src/math/generic/setpayload.cpp
new file mode 100644
index 0000000..7e7078c
--- /dev/null
+++ b/src/math/generic/setpayload.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayload function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayload.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayload, (double *res, double pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/false>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadf.cpp b/src/math/generic/setpayloadf.cpp
new file mode 100644
index 0000000..50d2ffd
--- /dev/null
+++ b/src/math/generic/setpayloadf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadf function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadf, (float *res, float pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/false>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadf128.cpp b/src/math/generic/setpayloadf128.cpp
new file mode 100644
index 0000000..a50e5ef
--- /dev/null
+++ b/src/math/generic/setpayloadf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadf128 function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadf128, (float128 * res, float128 pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/false>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadf16.cpp b/src/math/generic/setpayloadf16.cpp
index 98fc239..1d1445e 100644
--- a/src/math/generic/setpayloadf16.cpp
+++ b/src/math/generic/setpayloadf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/setpayloadf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, setpayloadf16, (float16 * res, float16 pl)) {
   return static_cast<int>(fputil::setpayload</*IsSignaling=*/false>(*res, pl));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadl.cpp b/src/math/generic/setpayloadl.cpp
new file mode 100644
index 0000000..486f3f9
--- /dev/null
+++ b/src/math/generic/setpayloadl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadl function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadl, (long double *res, long double pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/false>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadsig.cpp b/src/math/generic/setpayloadsig.cpp
new file mode 100644
index 0000000..fa8b165
--- /dev/null
+++ b/src/math/generic/setpayloadsig.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadsig function --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadsig.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadsig, (double *res, double pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/true>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadsigf.cpp b/src/math/generic/setpayloadsigf.cpp
new file mode 100644
index 0000000..ec9d98f
--- /dev/null
+++ b/src/math/generic/setpayloadsigf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadsigf function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadsigf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadsigf, (float *res, float pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/true>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadsigf128.cpp b/src/math/generic/setpayloadsigf128.cpp
new file mode 100644
index 0000000..97f6a36
--- /dev/null
+++ b/src/math/generic/setpayloadsigf128.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadsigf128 function ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadsigf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadsigf128, (float128 * res, float128 pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/true>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadsigf16.cpp b/src/math/generic/setpayloadsigf16.cpp
index c79620f..5ba9fcd 100644
--- a/src/math/generic/setpayloadsigf16.cpp
+++ b/src/math/generic/setpayloadsigf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/setpayloadsigf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, setpayloadsigf16, (float16 * res, float16 pl)) {
   return static_cast<int>(fputil::setpayload</*IsSignaling=*/true>(*res, pl));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/setpayloadsigl.cpp b/src/math/generic/setpayloadsigl.cpp
new file mode 100644
index 0000000..446fbf5
--- /dev/null
+++ b/src/math/generic/setpayloadsigl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of setpayloadsigl function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/setpayloadsigl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, setpayloadsigl, (long double *res, long double pl)) {
+  return static_cast<int>(fputil::setpayload</*IsSignaling=*/true>(*res, pl));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sin.cpp b/src/math/generic/sin.cpp
new file mode 100644
index 0000000..b32486d
--- /dev/null
+++ b/src/math/generic/sin.cpp
@@ -0,0 +1,173 @@
+//===-- Double-precision sin function -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sin.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
+#include "src/math/generic/range_reduction_double_common.h"
+#include "src/math/generic/sincos_eval.h"
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+#include "range_reduction_double_fma.h"
+#else
+#include "range_reduction_double_nofma.h"
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+namespace LIBC_NAMESPACE_DECL {
+
+using DoubleDouble = fputil::DoubleDouble;
+using Float128 = typename fputil::DyadicFloat<128>;
+
+LLVM_LIBC_FUNCTION(double, sin, (double x)) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  uint16_t x_e = xbits.get_biased_exponent();
+
+  DoubleDouble y;
+  unsigned k;
+  LargeRangeReduction range_reduction_large{};
+
+  // |x| < 2^16
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT)) {
+    // |x| < 2^-7
+    if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 7)) {
+      // |x| < 2^-26, |sin(x) - x| < ulp(x)/2.
+      if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 26)) {
+        // Signed zeros.
+        if (LIBC_UNLIKELY(x == 0.0))
+          return x + x; // Make sure it works with FTZ/DAZ.
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+        return fputil::multiply_add(x, -0x1.0p-54, x);
+#else
+        if (LIBC_UNLIKELY(x_e < 4)) {
+          int rounding_mode = fputil::quick_get_round();
+          if (rounding_mode == FE_TOWARDZERO ||
+              (xbits.sign() == Sign::POS && rounding_mode == FE_DOWNWARD) ||
+              (xbits.sign() == Sign::NEG && rounding_mode == FE_UPWARD))
+            return FPBits(xbits.uintval() - 1).get_val();
+        }
+        return fputil::multiply_add(x, -0x1.0p-54, x);
+#endif // LIBC_TARGET_CPU_HAS_FMA
+      }
+      // No range reduction needed.
+      k = 0;
+      y.lo = 0.0;
+      y.hi = x;
+    } else {
+      // Small range reduction.
+      k = range_reduction_small(x, y);
+    }
+  } else {
+    // Inf or NaN
+    if (LIBC_UNLIKELY(x_e > 2 * FPBits::EXP_BIAS)) {
+      // sin(+-Inf) = NaN
+      if (xbits.get_mantissa() == 0) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    // Large range reduction.
+    k = range_reduction_large.fast(x, y);
+  }
+
+  DoubleDouble sin_y, cos_y;
+
+  [[maybe_unused]] double err = generic::sincos_eval(y, sin_y, cos_y);
+
+  // Look up sin(k * pi/128) and cos(k * pi/128)
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+  // Memory saving versions.  Use 65-entry table.
+  auto get_idx_dd = [](unsigned kk) -> DoubleDouble {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    DoubleDouble ans = SIN_K_PI_OVER_128[idx];
+    if (kk & 128) {
+      ans.hi = -ans.hi;
+      ans.lo = -ans.lo;
+    }
+    return ans;
+  };
+  DoubleDouble sin_k = get_idx_dd(k);
+  DoubleDouble cos_k = get_idx_dd(k + 64);
+#else
+  // Fast look up version, but needs 256-entry table.
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  DoubleDouble sin_k = SIN_K_PI_OVER_128[k & 255];
+  DoubleDouble cos_k = SIN_K_PI_OVER_128[(k + 64) & 255];
+#endif
+
+  // After range reduction, k = round(x * 128 / pi) and y = x - k * (pi / 128).
+  // So k is an integer and -pi / 256 <= y <= pi / 256.
+  // Then sin(x) = sin((k * pi/128 + y)
+  //             = sin(y) * cos(k*pi/128) + cos(y) * sin(k*pi/128)
+  DoubleDouble sin_k_cos_y = fputil::quick_mult(cos_y, sin_k);
+  DoubleDouble cos_k_sin_y = fputil::quick_mult(sin_y, cos_k);
+
+  DoubleDouble rr = fputil::exact_add<false>(sin_k_cos_y.hi, cos_k_sin_y.hi);
+  rr.lo += sin_k_cos_y.lo + cos_k_sin_y.lo;
+
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return rr.hi + rr.lo;
+#else
+  // Accurate test and pass for correctly rounded implementation.
+
+  double rlp = rr.lo + err;
+  double rlm = rr.lo - err;
+
+  double r_upper = rr.hi + rlp; // (rr.lo + ERR);
+  double r_lower = rr.hi + rlm; // (rr.lo - ERR);
+
+  // Ziv's rounding test.
+  if (LIBC_LIKELY(r_upper == r_lower))
+    return r_upper;
+
+  Float128 u_f128, sin_u, cos_u;
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT))
+    u_f128 = range_reduction_small_f128(x);
+  else
+    u_f128 = range_reduction_large.accurate();
+
+  generic::sincos_eval(u_f128, sin_u, cos_u);
+
+  auto get_sin_k = [](unsigned kk) -> Float128 {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    Float128 ans = SIN_K_PI_OVER_128_F128[idx];
+    if (kk & 128)
+      ans.sign = Sign::NEG;
+    return ans;
+  };
+
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  Float128 sin_k_f128 = get_sin_k(k);
+  Float128 cos_k_f128 = get_sin_k(k + 64);
+
+  // sin(x) = sin((k * pi/128 + u)
+  //        = sin(u) * cos(k*pi/128) + cos(u) * sin(k*pi/128)
+  Float128 r = fputil::quick_add(fputil::quick_mul(sin_k_f128, cos_u),
+                                 fputil::quick_mul(cos_k_f128, sin_u));
+
+  // TODO: Add assertion if Ziv's accuracy tests fail in debug mode.
+  // https://github.com/llvm/llvm-project/issues/96452.
+
+  return static_cast<double>(r);
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sincos.cpp b/src/math/generic/sincos.cpp
new file mode 100644
index 0000000..166ce46
--- /dev/null
+++ b/src/math/generic/sincos.cpp
@@ -0,0 +1,215 @@
+//===-- Double-precision sincos function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sincos.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
+#include "src/math/generic/range_reduction_double_common.h"
+#include "src/math/generic/sincos_eval.h"
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+#include "range_reduction_double_fma.h"
+#else
+#include "range_reduction_double_nofma.h"
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+namespace LIBC_NAMESPACE_DECL {
+
+using DoubleDouble = fputil::DoubleDouble;
+using Float128 = typename fputil::DyadicFloat<128>;
+
+LLVM_LIBC_FUNCTION(void, sincos, (double x, double *sin_x, double *cos_x)) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  uint16_t x_e = xbits.get_biased_exponent();
+
+  DoubleDouble y;
+  unsigned k;
+  LargeRangeReduction range_reduction_large{};
+
+  // |x| < 2^16
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT)) {
+    // |x| < 2^-7
+    if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 7)) {
+      // |x| < 2^-27
+      if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 27)) {
+        // Signed zeros.
+        if (LIBC_UNLIKELY(x == 0.0)) {
+          *sin_x = x;
+          *cos_x = 1.0;
+          return;
+        }
+
+        // For |x| < 2^-27, max(|sin(x) - x|, |cos(x) - 1|) < ulp(x)/2.
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+        *sin_x = fputil::multiply_add(x, -0x1.0p-54, x);
+        *cos_x = fputil::multiply_add(x, -x, 1.0);
+#else
+        *cos_x = fputil::round_result_slightly_down(1.0);
+
+        if (LIBC_UNLIKELY(x_e < 4)) {
+          int rounding_mode = fputil::quick_get_round();
+          if (rounding_mode == FE_TOWARDZERO ||
+              (xbits.sign() == Sign::POS && rounding_mode == FE_DOWNWARD) ||
+              (xbits.sign() == Sign::NEG && rounding_mode == FE_UPWARD))
+            *sin_x = FPBits(xbits.uintval() - 1).get_val();
+        }
+        *sin_x = fputil::multiply_add(x, -0x1.0p-54, x);
+#endif // LIBC_TARGET_CPU_HAS_FMA
+        return;
+      }
+      // No range reduction needed.
+      k = 0;
+      y.lo = 0.0;
+      y.hi = x;
+    } else {
+      // Small range reduction.
+      k = range_reduction_small(x, y);
+    }
+  } else {
+    // Inf or NaN
+    if (LIBC_UNLIKELY(x_e > 2 * FPBits::EXP_BIAS)) {
+      // sin(+-Inf) = NaN
+      if (xbits.get_mantissa() == 0) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+      *sin_x = *cos_x = x + FPBits::quiet_nan().get_val();
+      return;
+    }
+
+    // Large range reduction.
+    k = range_reduction_large.fast(x, y);
+  }
+
+  DoubleDouble sin_y, cos_y;
+
+  [[maybe_unused]] double err = generic::sincos_eval(y, sin_y, cos_y);
+
+  // Look up sin(k * pi/128) and cos(k * pi/128)
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+  // Memory saving versions.  Use 65-entry table.
+  auto get_idx_dd = [](unsigned kk) -> DoubleDouble {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    DoubleDouble ans = SIN_K_PI_OVER_128[idx];
+    if (kk & 128) {
+      ans.hi = -ans.hi;
+      ans.lo = -ans.lo;
+    }
+    return ans;
+  };
+  DoubleDouble sin_k = get_idx_dd(k);
+  DoubleDouble cos_k = get_idx_dd(k + 64);
+#else
+  // Fast look up version, but needs 256-entry table.
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  DoubleDouble sin_k = SIN_K_PI_OVER_128[k & 255];
+  DoubleDouble cos_k = SIN_K_PI_OVER_128[(k + 64) & 255];
+#endif // LIBC_MATH_HAS_SMALL_TABLES
+
+  DoubleDouble msin_k{-sin_k.lo, -sin_k.hi};
+
+  // After range reduction, k = round(x * 128 / pi) and y = x - k * (pi / 128).
+  // So k is an integer and -pi / 256 <= y <= pi / 256.
+  // Then sin(x) = sin((k * pi/128 + y)
+  //             = sin(y) * cos(k*pi/128) + cos(y) * sin(k*pi/128)
+  DoubleDouble sin_k_cos_y = fputil::quick_mult(cos_y, sin_k);
+  DoubleDouble cos_k_sin_y = fputil::quick_mult(sin_y, cos_k);
+  //      cos(x) = cos((k * pi/128 + y)
+  //             = cos(y) * cos(k*pi/128) - sin(y) * sin(k*pi/128)
+  DoubleDouble cos_k_cos_y = fputil::quick_mult(cos_y, cos_k);
+  DoubleDouble msin_k_sin_y = fputil::quick_mult(sin_y, msin_k);
+
+  DoubleDouble sin_dd =
+      fputil::exact_add<false>(sin_k_cos_y.hi, cos_k_sin_y.hi);
+  DoubleDouble cos_dd =
+      fputil::exact_add<false>(cos_k_cos_y.hi, msin_k_sin_y.hi);
+  sin_dd.lo += sin_k_cos_y.lo + cos_k_sin_y.lo;
+  cos_dd.lo += msin_k_sin_y.lo + cos_k_cos_y.lo;
+
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  *sin_x = sin_dd.hi + sin_dd.lo;
+  *cos_x = cos_dd.hi + cos_dd.lo;
+  return;
+#else
+  // Accurate test and pass for correctly rounded implementation.
+
+  double sin_lp = sin_dd.lo + err;
+  double sin_lm = sin_dd.lo - err;
+  double cos_lp = cos_dd.lo + err;
+  double cos_lm = cos_dd.lo - err;
+
+  double sin_upper = sin_dd.hi + sin_lp;
+  double sin_lower = sin_dd.hi + sin_lm;
+  double cos_upper = cos_dd.hi + cos_lp;
+  double cos_lower = cos_dd.hi + cos_lm;
+
+  // Ziv's rounding test.
+  if (LIBC_LIKELY(sin_upper == sin_lower && cos_upper == cos_lower)) {
+    *sin_x = sin_upper;
+    *cos_x = cos_upper;
+    return;
+  }
+
+  Float128 u_f128, sin_u, cos_u;
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT))
+    u_f128 = range_reduction_small_f128(x);
+  else
+    u_f128 = range_reduction_large.accurate();
+
+  generic::sincos_eval(u_f128, sin_u, cos_u);
+
+  auto get_sin_k = [](unsigned kk) -> Float128 {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    Float128 ans = SIN_K_PI_OVER_128_F128[idx];
+    if (kk & 128)
+      ans.sign = Sign::NEG;
+    return ans;
+  };
+
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  Float128 sin_k_f128 = get_sin_k(k);
+  Float128 cos_k_f128 = get_sin_k(k + 64);
+  Float128 msin_k_f128 = get_sin_k(k + 128);
+
+  // TODO: Add assertion if Ziv's accuracy tests fail in debug mode.
+  // https://github.com/llvm/llvm-project/issues/96452.
+
+  if (sin_upper == sin_lower)
+    *sin_x = sin_upper;
+  else
+    // sin(x) = sin((k * pi/128 + u)
+    //        = sin(u) * cos(k*pi/128) + cos(u) * sin(k*pi/128)
+    *sin_x = static_cast<double>(
+        fputil::quick_add(fputil::quick_mul(sin_k_f128, cos_u),
+                          fputil::quick_mul(cos_k_f128, sin_u)));
+
+  if (cos_upper == cos_lower)
+    *cos_x = cos_upper;
+  else
+    // cos(x) = cos((k * pi/128 + u)
+    //        = cos(u) * cos(k*pi/128) - sin(u) * sin(k*pi/128)
+    *cos_x = static_cast<double>(
+        fputil::quick_add(fputil::quick_mul(cos_k_f128, cos_u),
+                          fputil::quick_mul(msin_k_f128, sin_u)));
+
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sincos_eval.h b/src/math/generic/sincos_eval.h
new file mode 100644
index 0000000..6cd1da4
--- /dev/null
+++ b/src/math/generic/sincos_eval.h
@@ -0,0 +1,138 @@
+//===-- Compute sin + cos for small angles ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_SINCOS_EVAL_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_SINCOS_EVAL_H
+
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace generic {
+
+using fputil::DoubleDouble;
+using Float128 = fputil::DyadicFloat<128>;
+
+LIBC_INLINE double sincos_eval(const DoubleDouble &u, DoubleDouble &sin_u,
+                               DoubleDouble &cos_u) {
+  // Evaluate sin(y) = sin(x - k * (pi/128))
+  // We use the degree-7 Taylor approximation:
+  //   sin(y) ~ y - y^3/3! + y^5/5! - y^7/7!
+  // Then the error is bounded by:
+  //   |sin(y) - (y - y^3/3! + y^5/5! - y^7/7!)| < |y|^9/9! < 2^-54/9! < 2^-72.
+  // For y ~ u_hi + u_lo, fully expanding the polynomial and drop any terms
+  // < ulp(u_hi^3) gives us:
+  //   y - y^3/3! + y^5/5! - y^7/7! = ...
+  // ~ u_hi + u_hi^3 * (-1/6 + u_hi^2 * (1/120 - u_hi^2 * 1/5040)) +
+  //        + u_lo (1 + u_hi^2 * (-1/2 + u_hi^2 / 24))
+  double u_hi_sq = u.hi * u.hi; // Error < ulp(u_hi^2) < 2^(-6 - 52) = 2^-58.
+  // p1 ~ 1/120 + u_hi^2 / 5040.
+  double p1 = fputil::multiply_add(u_hi_sq, -0x1.a01a01a01a01ap-13,
+                                   0x1.1111111111111p-7);
+  // q1 ~ -1/2 + u_hi^2 / 24.
+  double q1 = fputil::multiply_add(u_hi_sq, 0x1.5555555555555p-5, -0x1.0p-1);
+  double u_hi_3 = u_hi_sq * u.hi;
+  // p2 ~ -1/6 + u_hi^2 (1/120 - u_hi^2 * 1/5040)
+  double p2 = fputil::multiply_add(u_hi_sq, p1, -0x1.5555555555555p-3);
+  // q2 ~ 1 + u_hi^2 (-1/2 + u_hi^2 / 24)
+  double q2 = fputil::multiply_add(u_hi_sq, q1, 1.0);
+  double sin_lo = fputil::multiply_add(u_hi_3, p2, u.lo * q2);
+  // Overall, |sin(y) - (u_hi + sin_lo)| < 2*ulp(u_hi^3) < 2^-69.
+
+  // Evaluate cos(y) = cos(x - k * (pi/128))
+  // We use the degree-8 Taylor approximation:
+  //   cos(y) ~ 1 - y^2/2 + y^4/4! - y^6/6! + y^8/8!
+  // Then the error is bounded by:
+  //   |cos(y) - (...)| < |y|^10/10! < 2^-81
+  // For y ~ u_hi + u_lo, fully expanding the polynomial and drop any terms
+  // < ulp(u_hi^3) gives us:
+  //   1 - y^2/2 + y^4/4! - y^6/6! + y^8/8! = ...
+  // ~ 1 - u_hi^2/2 + u_hi^4(1/24 + u_hi^2 (-1/720 + u_hi^2/40320)) +
+  //     + u_hi u_lo (-1 + u_hi^2/6)
+  // We compute 1 - u_hi^2 accurately:
+  //   v_hi + v_lo ~ 1 - u_hi^2/2
+  // with error <= 2^-105.
+  double u_hi_neg_half = (-0.5) * u.hi;
+  DoubleDouble v;
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+  v.hi = fputil::multiply_add(u.hi, u_hi_neg_half, 1.0);
+  v.lo = 1.0 - v.hi; // Exact
+  v.lo = fputil::multiply_add(u.hi, u_hi_neg_half, v.lo);
+#else
+  DoubleDouble u_hi_sq_neg_half = fputil::exact_mult(u.hi, u_hi_neg_half);
+  v = fputil::exact_add(1.0, u_hi_sq_neg_half.hi);
+  v.lo += u_hi_sq_neg_half.lo;
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+  // r1 ~ -1/720 + u_hi^2 / 40320
+  double r1 = fputil::multiply_add(u_hi_sq, 0x1.a01a01a01a01ap-16,
+                                   -0x1.6c16c16c16c17p-10);
+  // s1 ~ -1 + u_hi^2 / 6
+  double s1 = fputil::multiply_add(u_hi_sq, 0x1.5555555555555p-3, -1.0);
+  double u_hi_4 = u_hi_sq * u_hi_sq;
+  double u_hi_u_lo = u.hi * u.lo;
+  // r2 ~ 1/24 + u_hi^2 (-1/720 + u_hi^2 / 40320)
+  double r2 = fputil::multiply_add(u_hi_sq, r1, 0x1.5555555555555p-5);
+  // s2 ~ v_lo + u_hi * u_lo * (-1 + u_hi^2 / 6)
+  double s2 = fputil::multiply_add(u_hi_u_lo, s1, v.lo);
+  double cos_lo = fputil::multiply_add(u_hi_4, r2, s2);
+  // Overall, |cos(y) - (v_hi + cos_lo)| < 2*ulp(u_hi^4) < 2^-75.
+
+  sin_u = fputil::exact_add(u.hi, sin_lo);
+  cos_u = fputil::exact_add(v.hi, cos_lo);
+
+  return fputil::multiply_add(fputil::FPBits<double>(u_hi_3).abs().get_val(),
+                              0x1.0p-51, 0x1.0p-105);
+}
+
+LIBC_INLINE void sincos_eval(const Float128 &u, Float128 &sin_u,
+                             Float128 &cos_u) {
+  Float128 u_sq = fputil::quick_mul(u, u);
+
+  // sin(u) ~ x - x^3/3! + x^5/5! - x^7/7! + x^9/9! - x^11/11! + x^13/13!
+  constexpr Float128 SIN_COEFFS[] = {
+      {Sign::POS, -127, 0x80000000'00000000'00000000'00000000_u128}, // 1
+      {Sign::NEG, -130, 0xaaaaaaaa'aaaaaaaa'aaaaaaaa'aaaaaaab_u128}, // -1/3!
+      {Sign::POS, -134, 0x88888888'88888888'88888888'88888889_u128}, // 1/5!
+      {Sign::NEG, -140, 0xd00d00d0'0d00d00d'00d00d00'd00d00d0_u128}, // -1/7!
+      {Sign::POS, -146, 0xb8ef1d2a'b6399c7d'560e4472'800b8ef2_u128}, // 1/9!
+      {Sign::NEG, -153, 0xd7322b3f'aa271c7f'3a3f25c1'bee38f10_u128}, // -1/11!
+      {Sign::POS, -160, 0xb092309d'43684be5'1c198e91'd7b4269e_u128}, // 1/13!
+  };
+
+  // cos(u) ~ 1 - x^2/2 + x^4/4! - x^6/6! + x^8/8! - x^10/10! + x^12/12!
+  constexpr Float128 COS_COEFFS[] = {
+      {Sign::POS, -127, 0x80000000'00000000'00000000'00000000_u128}, // 1.0
+      {Sign::NEG, -128, 0x80000000'00000000'00000000'00000000_u128}, // 1/2
+      {Sign::POS, -132, 0xaaaaaaaa'aaaaaaaa'aaaaaaaa'aaaaaaab_u128}, // 1/4!
+      {Sign::NEG, -137, 0xb60b60b6'0b60b60b'60b60b60'b60b60b6_u128}, // 1/6!
+      {Sign::POS, -143, 0xd00d00d0'0d00d00d'00d00d00'd00d00d0_u128}, // 1/8!
+      {Sign::NEG, -149, 0x93f27dbb'c4fae397'780b69f5'333c725b_u128}, // 1/10!
+      {Sign::POS, -156, 0x8f76c77f'c6c4bdaa'26d4c3d6'7f425f60_u128}, // 1/12!
+  };
+
+  sin_u = fputil::quick_mul(u, fputil::polyeval(u_sq, SIN_COEFFS[0],
+                                                SIN_COEFFS[1], SIN_COEFFS[2],
+                                                SIN_COEFFS[3], SIN_COEFFS[4],
+                                                SIN_COEFFS[5], SIN_COEFFS[6]));
+  cos_u = fputil::polyeval(u_sq, COS_COEFFS[0], COS_COEFFS[1], COS_COEFFS[2],
+                           COS_COEFFS[3], COS_COEFFS[4], COS_COEFFS[5],
+                           COS_COEFFS[6]);
+}
+
+} // namespace generic
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF_EVAL_H
diff --git a/src/math/generic/sincosf.cpp b/src/math/generic/sincosf.cpp
index 9ebf0b6..ccaa29c 100644
--- a/src/math/generic/sincosf.cpp
+++ b/src/math/generic/sincosf.cpp
@@ -13,12 +13,11 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Exceptional values
 static constexpr int N_EXCEPTS = 6;
@@ -199,4 +198,4 @@ LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinp, float *cosp)) {
       sin_y, -sin_k, fputil::multiply_add(cosm1_y, cos_k, cos_k)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sincosf16_utils.h b/src/math/generic/sincosf16_utils.h
new file mode 100644
index 0000000..8351175
--- /dev/null
+++ b/src/math/generic/sincosf16_utils.h
@@ -0,0 +1,77 @@
+//===-- Collection of utils for sinf16/cosf16 -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// Lookup table for sin(k * pi / 32) with k = 0, ..., 63.
+// Table is generated with Sollya as follows:
+// > display = hexadecimmal;
+// > for k from 0 to 63 do { round(sin(k * pi/32), SG, RN); };
+constexpr float SIN_K_PI_OVER_32[64] = {
+    0x0.0p0,        0x1.917a6cp-4,  0x1.8f8b84p-3,  0x1.294062p-2,
+    0x1.87de2ap-2,  0x1.e2b5d4p-2,  0x1.1c73b4p-1,  0x1.44cf32p-1,
+    0x1.6a09e6p-1,  0x1.8bc806p-1,  0x1.a9b662p-1,  0x1.c38b3p-1,
+    0x1.d906bcp-1,  0x1.e9f416p-1,  0x1.f6297cp-1,  0x1.fd88dap-1,
+    0x1p0,          0x1.fd88dap-1,  0x1.f6297cp-1,  0x1.e9f416p-1,
+    0x1.d906bcp-1,  0x1.c38b3p-1,   0x1.a9b662p-1,  0x1.8bc806p-1,
+    0x1.6a09e6p-1,  0x1.44cf32p-1,  0x1.1c73b4p-1,  0x1.e2b5d4p-2,
+    0x1.87de2ap-2,  0x1.294062p-2,  0x1.8f8b84p-3,  0x1.917a6cp-4,
+    0x0.0p0,        -0x1.917a6cp-4, -0x1.8f8b84p-3, -0x1.294062p-2,
+    -0x1.87de2ap-2, -0x1.e2b5d4p-2, -0x1.1c73b4p-1, -0x1.44cf32p-1,
+    -0x1.6a09e6p-1, -0x1.8bc806p-1, -0x1.a9b662p-1, -0x1.c38b3p-1,
+    -0x1.d906bcp-1, -0x1.e9f416p-1, -0x1.f6297ep-1, -0x1.fd88dap-1,
+    -0x1p0,         -0x1.fd88dap-1, -0x1.f6297cp-1, -0x1.e9f416p-1,
+    -0x1.d906bcp-1, -0x1.c38b3p-1,  -0x1.a9b662p-1, -0x1.8bc806p-1,
+    -0x1.6a09e6p-1, -0x1.44cf32p-1, -0x1.1c73b4p-1, -0x1.e2b5d4p-2,
+    -0x1.87de2ap-2, -0x1.294062p-2, -0x1.8f8b84p-3, -0x1.917a6cp-4};
+
+LIBC_INLINE int32_t range_reduction_sincospif16(float x, float &y) {
+  float kf = fputil::nearest_integer(x * 32);
+  y = fputil::multiply_add<float>(x, 32.0, -kf);
+
+  return static_cast<int32_t>(kf);
+}
+
+LIBC_INLINE void sincospif16_eval(float xf, float &sin_k, float &cos_k,
+                                  float &sin_y, float &cosm1_y) {
+  float y;
+  int32_t k = range_reduction_sincospif16(xf, y);
+
+  sin_k = SIN_K_PI_OVER_32[k & 63];
+  cos_k = SIN_K_PI_OVER_32[(k + 16) & 63];
+
+  // Recall, after range reduction, -0.5 <= y <= 0.5. For very small values of
+  // y, calculating sin(y * p/32) can be inaccurate. Generating a polynomial for
+  // sin(y * p/32)/y instead significantly reduces the relative errors.
+  float ysq = y * y;
+
+  // Degree-6 minimax even polynomial for sin(y*pi/32)/y generated by Sollya
+  // with:
+  // > Q = fpminimax(sin(y * pi/32)/y, [|0, 2, 4, 6|], [|SG...|], [0, 0.5]);
+  sin_y = y * fputil::polyeval(ysq, 0x1.921fb6p-4f, -0x1.4aeabcp-13f,
+                               0x1.a03354p-21f, -0x1.ad02d2p-20f);
+
+  // Degree-6 minimax even polynomial for cos(y*pi/32) generated by Sollya
+  // with:
+  // > P = fpminimax(cos(y * pi/32), [|0, 2, 4, 6|],[|1, SG...|], [0, 0.5]);
+  cosm1_y = ysq * fputil::polyeval(ysq, -0x1.3bd3ccp-8f, 0x1.03a61ap-18f,
+                                   0x1.a6f7a2p-29f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
diff --git a/src/math/generic/sincosf_utils.h b/src/math/generic/sincosf_utils.h
index 904df4f..726a5ab 100644
--- a/src/math/generic/sincosf_utils.h
+++ b/src/math/generic/sincosf_utils.h
@@ -11,6 +11,7 @@
 
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
 #if defined(LIBC_TARGET_CPU_HAS_FMA)
@@ -19,6 +20,7 @@
 using LIBC_NAMESPACE::fma::FAST_PASS_BOUND;
 using LIBC_NAMESPACE::fma::large_range_reduction;
 using LIBC_NAMESPACE::fma::small_range_reduction;
+
 #else
 #include "range_reduction.h"
 // using namespace LIBC_NAMESPACE::generic;
@@ -27,7 +29,7 @@ using LIBC_NAMESPACE::generic::large_range_reduction;
 using LIBC_NAMESPACE::generic::small_range_reduction;
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Lookup table for sin(k * pi / 32) with k = 0, ..., 63.
 // Table is generated with Sollya as follow:
@@ -58,18 +60,9 @@ const double SIN_K_PI_OVER_32[64] = {
     -0x1.917a6bc29b42cp-4,
 };
 
-LIBC_INLINE void sincosf_eval(double xd, uint32_t x_abs, double &sin_k,
-                              double &cos_k, double &sin_y, double &cosm1_y) {
-  int64_t k;
-  double y;
-
-  if (LIBC_LIKELY(x_abs < FAST_PASS_BOUND)) {
-    k = small_range_reduction(xd, y);
-  } else {
-    fputil::FPBits<float> x_bits(x_abs);
-    k = large_range_reduction(xd, x_bits.get_exponent(), y);
-  }
-
+static LIBC_INLINE void sincosf_poly_eval(int64_t k, double y, double &sin_k,
+                                          double &cos_k, double &sin_y,
+                                          double &cosm1_y) {
   // After range reduction, k = round(x * 32 / pi) and y = (x * 32 / pi) - k.
   // So k is an integer and -0.5 <= y <= 0.5.
   // Then sin(x) = sin((k + y)*pi/32)
@@ -95,6 +88,38 @@ LIBC_INLINE void sincosf_eval(double xd, uint32_t x_abs, double &sin_k,
                                    0x1.03c1f070c2e27p-18, -0x1.55cc84bd942p-30);
 }
 
-} // namespace LIBC_NAMESPACE
+LIBC_INLINE void sincosf_eval(double xd, uint32_t x_abs, double &sin_k,
+                              double &cos_k, double &sin_y, double &cosm1_y) {
+  int64_t k;
+  double y;
+
+  if (LIBC_LIKELY(x_abs < FAST_PASS_BOUND)) {
+    k = small_range_reduction(xd, y);
+  } else {
+    fputil::FPBits<float> x_bits(x_abs);
+    k = large_range_reduction(xd, x_bits.get_exponent(), y);
+  }
+
+  sincosf_poly_eval(k, y, sin_k, cos_k, sin_y, cosm1_y);
+}
+
+// Return k and y, where
+//   k = round(x * 32) and y = (x * 32) - k.
+//   => pi * x = (k + y) * pi / 32
+static LIBC_INLINE int64_t range_reduction_sincospi(double x, double &y) {
+  double kd = fputil::nearest_integer(x * 32);
+  y = fputil::multiply_add<double>(x, 32.0, -kd);
+
+  return static_cast<int64_t>(kd);
+}
+
+LIBC_INLINE void sincospif_eval(double xd, double &sin_k, double &cos_k,
+                                double &sin_y, double &cosm1_y) {
+  double y;
+  int64_t k = range_reduction_sincospi(xd, y);
+  sincosf_poly_eval(k, y, sin_k, cos_k, sin_y, cosm1_y);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF_UTILS_H
diff --git a/src/math/generic/sinf.cpp b/src/math/generic/sinf.cpp
index ff555bc..cea267d 100644
--- a/src/math/generic/sinf.cpp
+++ b/src/math/generic/sinf.cpp
@@ -15,18 +15,17 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
 #if defined(LIBC_TARGET_CPU_HAS_FMA)
 #include "range_reduction_fma.h"
 #else
 #include "range_reduction.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -155,4 +154,4 @@ LLVM_LIBC_FUNCTION(float, sinf, (float x)) {
       sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sinhf.cpp b/src/math/generic/sinhf.cpp
index 780c9a1..371dd6e 100644
--- a/src/math/generic/sinhf.cpp
+++ b/src/math/generic/sinhf.cpp
@@ -9,10 +9,11 @@
 #include "src/math/sinhf.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinhf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -72,4 +73,4 @@ LLVM_LIBC_FUNCTION(float, sinhf, (float x)) {
   return static_cast<float>(exp_pm_eval</*is_sinh*/ true>(x));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sinhf16.cpp b/src/math/generic/sinhf16.cpp
new file mode 100644
index 0000000..e2dd009
--- /dev/null
+++ b/src/math/generic/sinhf16.cpp
@@ -0,0 +1,144 @@
+//===-- Half-precision sinh(x) function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinhf16.h"
+#include "expxf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 16> SINHF16_EXCEPTS_POS = {{
+    // x = 0x1.714p-5, sinhf16(x) = 0x1.714p-5 (RZ)
+    {0x29c5U, 0x29c5U, 1U, 0U, 1U},
+    // x = 0x1.25p-4, sinhf16(x) = 0x1.25p-4 (RZ)
+    {0x2c94U, 0x2c94U, 1U, 0U, 1U},
+    // x = 0x1.f5p-4, sinhf16(x) = 0x1.f64p-4 (RZ)
+    {0x2fd4U, 0x2fd9U, 1U, 0U, 0U},
+    // x = 0x1.b1cp-3, sinhf16(x) = 0x1.b4cp-3 (RZ)
+    {0x32c7U, 0x32d3U, 1U, 0U, 1U},
+    // x = 0x1.6e8p-2, sinhf16(x) = 0x1.764p-2 (RZ)
+    {0x35baU, 0x35d9U, 1U, 0U, 1U},
+    // x = 0x1.6b4p-1, sinhf16(x) = 0x1.8a4p-1 (RZ)
+    {0x39adU, 0x3a29U, 1U, 0U, 1U},
+    // x = 0x1.a58p-1, sinhf16(x) = 0x1.d68p-1 (RZ)
+    {0x3a96U, 0x3b5aU, 1U, 0U, 1U},
+    // x = 0x1.574p+0, sinhf16(x) = 0x1.c78p+0 (RZ)
+    {0x3d5dU, 0x3f1eU, 1U, 0U, 1U},
+    // x = 0x1.648p+1, sinhf16(x) = 0x1.024p+3 (RZ)
+    {0x4192U, 0x4809U, 1U, 0U, 0U},
+    // x = 0x1.cdcp+1, sinhf16(x) = 0x1.26cp+4 (RZ)
+    {0x4337U, 0x4c9bU, 1U, 0U, 0U},
+    // x = 0x1.d0cp+1, sinhf16(x) = 0x1.2d8p+4 (RZ)
+    {0x4343U, 0x4cb6U, 1U, 0U, 1U},
+    // x = 0x1.018p+2, sinhf16(x) = 0x1.bfp+4 (RZ)
+    {0x4406U, 0x4efcU, 1U, 0U, 0U},
+    // x = 0x1.2fcp+2, sinhf16(x) = 0x1.cc4p+5 (RZ)
+    {0x44bfU, 0x5331U, 1U, 0U, 1U},
+    // x = 0x1.4ecp+2, sinhf16(x) = 0x1.75cp+6 (RZ)
+    {0x453bU, 0x55d7U, 1U, 0U, 0U},
+    // x = 0x1.8a4p+2, sinhf16(x) = 0x1.d94p+7 (RZ)
+    {0x4629U, 0x5b65U, 1U, 0U, 1U},
+    // x = 0x1.5fp+3, sinhf16(x) = 0x1.c54p+14 (RZ)
+    {0x497cU, 0x7715U, 1U, 0U, 1U},
+}};
+
+static constexpr fputil::ExceptValues<float16, 12> SINHF16_EXCEPTS_NEG = {{
+    // x = -0x1.714p-5, sinhf16(x) = -0x1.714p-5 (RZ)
+    {0xa9c5U, 0xa9c5U, 0U, 1U, 1U},
+    // x = -0x1.25p-4, sinhf16(x) = -0x1.25p-4 (RZ)
+    {0xac94U, 0xac94U, 0U, 1U, 1U},
+    // x = -0x1.f5p-4, sinhf16(x) = -0x1.f64p-4 (RZ)
+    {0xafd4U, 0xafd9U, 0U, 1U, 0U},
+    // x = -0x1.6e8p-2, sinhf16(x) = -0x1.764p-2 (RZ)
+    {0xb5baU, 0xb5d9U, 0U, 1U, 1U},
+    // x = -0x1.a58p-1, sinhf16(x) = -0x1.d68p-1 (RZ)
+    {0xba96U, 0xbb5aU, 0U, 1U, 1U},
+    // x = -0x1.cdcp+1, sinhf16(x) = -0x1.26cp+4 (RZ)
+    {0xc337U, 0xcc9bU, 0U, 1U, 0U},
+    // x = -0x1.d0cp+1, sinhf16(x) = -0x1.2d8p+4 (RZ)
+    {0xc343U, 0xccb6U, 0U, 1U, 1U},
+    // x = -0x1.018p+2, sinhf16(x) = -0x1.bfp+4 (RZ)
+    {0xc406U, 0xcefcU, 0U, 1U, 0U},
+    // x = -0x1.2fcp+2, sinhf16(x) = -0x1.cc4p+5 (RZ)
+    {0xc4bfU, 0xd331U, 0U, 1U, 1U},
+    // x = -0x1.4ecp+2, sinhf16(x) = -0x1.75cp+6 (RZ)
+    {0xc53bU, 0xd5d7U, 0U, 1U, 0U},
+    // x = -0x1.8a4p+2, sinhf16(x) = -0x1.d94p+7 (RZ)
+    {0xc629U, 0xdb65U, 0U, 1U, 1U},
+    // x = -0x1.5fp+3, sinhf16(x) = -0x1.c54p+14 (RZ)
+    {0xc97cU, 0xf715U, 0U, 1U, 1U},
+}};
+
+LLVM_LIBC_FUNCTION(float16, sinhf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When |x| = 0, or -2^(-14) <= x <= -2^(-9), or |x| >= asinh(2^16), or x is
+  // NaN.
+  if (LIBC_UNLIKELY(x_abs == 0U || (x_u >= 0x8400U && x_u <= 0xa400U) ||
+                    x_abs >= 0x49e5U)) {
+    // sinh(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // sinh(+/-0) = sinh(+/-0)
+    if (x_abs == 0U)
+      return FPBits::zero(x_bits.sign()).get_val();
+
+    // When |x| >= asinh(2^16).
+    if (x_abs >= 0x49e5U) {
+      // sinh(+/-inf) = +/-inf
+      if (x_bits.is_inf())
+        return FPBits::inf(x_bits.sign()).get_val();
+
+      int rounding_mode = fputil::quick_get_round();
+      if (rounding_mode == FE_TONEAREST ||
+          (x_bits.is_pos() && rounding_mode == FE_UPWARD) ||
+          (x_bits.is_neg() && rounding_mode == FE_DOWNWARD)) {
+        fputil::set_errno_if_required(ERANGE);
+        fputil::raise_except_if_required(FE_OVERFLOW | FE_INEXACT);
+        return FPBits::inf(x_bits.sign()).get_val();
+      }
+      return FPBits::max_normal(x_bits.sign()).get_val();
+    }
+
+    // When -2^(-14) <= x <= -2^(-9).
+    if (fputil::fenv_is_round_down())
+      return FPBits(static_cast<uint16_t>(x_u + 1)).get_val();
+    return FPBits(static_cast<uint16_t>(x_u)).get_val();
+  }
+
+  if (x_bits.is_pos()) {
+    if (auto r = SINHF16_EXCEPTS_POS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+  } else {
+    if (auto r = SINHF16_EXCEPTS_NEG.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+  }
+
+  return eval_sinh_or_cosh</*IsSinh=*/true>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sinpif.cpp b/src/math/generic/sinpif.cpp
new file mode 100644
index 0000000..f572ded
--- /dev/null
+++ b/src/math/generic/sinpif.cpp
@@ -0,0 +1,112 @@
+//===-- Single-precision sinpif function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinpif.h"
+#include "sincosf_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, sinpif, (float x)) {
+  using FPBits = typename fputil::FPBits<float>;
+  FPBits xbits(x);
+
+  uint32_t x_u = xbits.uintval();
+  uint32_t x_abs = x_u & 0x7fff'ffffU;
+  double xd = static_cast<double>(x);
+
+  // Range reduction:
+  // For |x| > 1/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * 1/32
+  //   k is an integer
+  //   |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32)
+  //   y = x * 32 - k
+  //
+  // Once k and y are computed, we then deduce the answer by the sine of sum
+  // formula:
+  //   sin(x * pi) = sin((k + y)*pi/32)
+  //          = sin(y*pi/32) * cos(k*pi/32) + cos(y*pi/32) * sin(k*pi/32)
+  // The values of sin(k*pi/32) and cos(k*pi/32) for k = 0..31 are precomputed
+  // and stored using a vector of 32 doubles. Sin(y*pi/32) and cos(y*pi/32) are
+  // computed using degree-7 and degree-6 minimax polynomials generated by
+  // Sollya respectively.
+
+  // |x| <= 1/16
+  if (LIBC_UNLIKELY(x_abs <= 0x3d80'0000U)) {
+
+    if (LIBC_UNLIKELY(x_abs < 0x33CD'01D7U)) {
+      if (LIBC_UNLIKELY(x_abs == 0U)) {
+        // For signed zeros.
+        return x;
+      }
+
+      // For very small values we can approximate sinpi(x) with x * pi
+      // An exhaustive test shows that this is accurate for |x| < 9.546391 
+      // 10-8
+      double xdpi = xd * 0x1.921fb54442d18p1;
+      return static_cast<float>(xdpi);
+    }
+
+    // |x| < 1/16.
+    double xsq = xd * xd;
+
+    // Degree-9 polynomial approximation:
+    //   sinpi(x) ~ x + a_3 x^3 + a_5 x^5 + a_7 x^7 + a_9 x^9
+    //          = x (1 + a_3 x^2 + ... + a_9 x^8)
+    //          = x * P(x^2)
+    // generated by Sollya with the following commands:
+    // > display = hexadecimal;
+    // > Q = fpminimax(sin(pi * x)/x, [|0, 2, 4, 6, 8|], [|D...|], [0, 1/16]);
+    double result = fputil::polyeval(
+        xsq, 0x1.921fb54442d18p1, -0x1.4abbce625bbf2p2, 0x1.466bc675e116ap1,
+        -0x1.32d2c0b62d41cp-1, 0x1.501ec4497cb7dp-4);
+    return static_cast<float>(xd * result);
+  }
+
+  // Numbers greater or equal to 2^23 are always integers or NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x4B00'0000)) {
+
+    // check for NaN values
+    if (LIBC_UNLIKELY(x_abs >= 0x7f80'0000U)) {
+      if (x_abs == 0x7f80'0000U) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    return FPBits::zero(xbits.sign()).get_val();
+  }
+
+  // Combine the results with the sine of sum formula:
+  //   sin(x * pi) = sin((k + y)*pi/32)
+  //          = sin(y*pi/32) * cos(k*pi/32) + cos(y*pi/32) * sin(k*pi/32)
+  //          = sin_y * cos_k + (1 + cosm1_y) * sin_k
+  //          = sin_y * cos_k + (cosm1_y * sin_k + sin_k)
+  double sin_k, cos_k, sin_y, cosm1_y;
+  sincospif_eval(xd, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && sin_k == 0))
+    return FPBits::zero(xbits.sign()).get_val();
+
+  return static_cast<float>(fputil::multiply_add(
+      sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sinpif16.cpp b/src/math/generic/sinpif16.cpp
new file mode 100644
index 0000000..51ea595
--- /dev/null
+++ b/src/math/generic/sinpif16.cpp
@@ -0,0 +1,76 @@
+//===-- Half-precision sinpif function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinpif16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/multiply_add.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, sinpif16, (float16 x)) {
+  using FPBits = typename fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+  // Range reduction:
+  // For |x| > 1/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * 1/32
+  //   k is an integer
+  //   |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32)
+  //   y = x * 32 - k
+  //
+  // Once k and y are computed, we then deduce the answer by the sine of sum
+  // formula:
+  //   sin(x * pi) = sin((k + y) * pi/32)
+  //               = sin(k * pi/32) * cos(y * pi/32) +
+  //                 sin(y * pi/32) * cos(k * pi/32)
+
+  // For signed zeros
+  if (LIBC_UNLIKELY(x_abs == 0U))
+    return x;
+
+  // Numbers greater or equal to 2^10 are integers, or infinity, or NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x6400)) {
+    // Check for NaN or infinity values
+    if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
+      // If value is equal to infinity
+      if (x_abs == 0x7c00) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+
+      return x + FPBits::quiet_nan().get_val();
+    }
+    return FPBits::zero(xbits.sign()).get_val();
+  }
+
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincospif16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && sin_k == 0))
+    return FPBits::zero(xbits.sign()).get_val();
+
+  // Since, cosm1_y = cos_y - 1, therefore:
+  // 	sin(x * pi) = cos_k * sin_y + sin_k + (cosm1_y * sin_k)
+  return fputil::cast<float16>(fputil::multiply_add(
+      sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sqrt.cpp b/src/math/generic/sqrt.cpp
index f33b0a2..791975e 100644
--- a/src/math/generic/sqrt.cpp
+++ b/src/math/generic/sqrt.cpp
@@ -9,9 +9,10 @@
 #include "src/math/sqrt.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sqrt, (double x)) { return fputil::sqrt<double>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sqrtf.cpp b/src/math/generic/sqrtf.cpp
index 26a53e9..69e0c34 100644
--- a/src/math/generic/sqrtf.cpp
+++ b/src/math/generic/sqrtf.cpp
@@ -9,9 +9,10 @@
 #include "src/math/sqrtf.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sqrtf, (float x)) { return fputil::sqrt<float>(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sqrtf128.cpp b/src/math/generic/sqrtf128.cpp
index 70e28dd..f87066b 100644
--- a/src/math/generic/sqrtf128.cpp
+++ b/src/math/generic/sqrtf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/sqrtf128.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, sqrtf128, (float128 x)) {
   return fputil::sqrt<float128>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sqrtf16.cpp b/src/math/generic/sqrtf16.cpp
new file mode 100644
index 0000000..0aa4a20
--- /dev/null
+++ b/src/math/generic/sqrtf16.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of sqrtf16 function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sqrtf16.h"
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float16, sqrtf16, (float16 x)) {
+  return fputil::sqrt<float16>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sqrtl.cpp b/src/math/generic/sqrtl.cpp
index 9f0cc87..2368182 100644
--- a/src/math/generic/sqrtl.cpp
+++ b/src/math/generic/sqrtl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/sqrtl.h"
 #include "src/__support/FPUtil/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, sqrtl, (long double x)) {
   return fputil::sqrt<long double>(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tan.cpp b/src/math/generic/tan.cpp
new file mode 100644
index 0000000..19d31a8
--- /dev/null
+++ b/src/math/generic/tan.cpp
@@ -0,0 +1,291 @@
+//===-- Double-precision tan function -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tan.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
+#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
+#include "src/math/generic/range_reduction_double_common.h"
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+#include "range_reduction_double_fma.h"
+#else
+#include "range_reduction_double_nofma.h"
+#endif // LIBC_TARGET_CPU_HAS_FMA
+
+namespace LIBC_NAMESPACE_DECL {
+
+using DoubleDouble = fputil::DoubleDouble;
+using Float128 = typename fputil::DyadicFloat<128>;
+
+namespace {
+
+LIBC_INLINE double tan_eval(const DoubleDouble &u, DoubleDouble &result) {
+  // Evaluate tan(y) = tan(x - k * (pi/128))
+  // We use the degree-9 Taylor approximation:
+  //   tan(y) ~ P(y) = y + y^3/3 + 2*y^5/15 + 17*y^7/315 + 62*y^9/2835
+  // Then the error is bounded by:
+  //   |tan(y) - P(y)| < 2^-6 * |y|^11 < 2^-6 * 2^-66 = 2^-72.
+  // For y ~ u_hi + u_lo, fully expanding the polynomial and drop any terms
+  // < ulp(u_hi^3) gives us:
+  //   P(y) = y + y^3/3 + 2*y^5/15 + 17*y^7/315 + 62*y^9/2835 = ...
+  // ~ u_hi + u_hi^3 * (1/3 + u_hi^2 * (2/15 + u_hi^2 * (17/315 +
+  //                                                     + u_hi^2 * 62/2835))) +
+  //        + u_lo (1 + u_hi^2 * (1 + u_hi^2 * 2/3))
+  double u_hi_sq = u.hi * u.hi; // Error < ulp(u_hi^2) < 2^(-6 - 52) = 2^-58.
+  // p1 ~ 17/315 + u_hi^2 62 / 2835.
+  double p1 =
+      fputil::multiply_add(u_hi_sq, 0x1.664f4882c10fap-6, 0x1.ba1ba1ba1ba1cp-5);
+  // p2 ~ 1/3 + u_hi^2 2 / 15.
+  double p2 =
+      fputil::multiply_add(u_hi_sq, 0x1.1111111111111p-3, 0x1.5555555555555p-2);
+  // q1 ~ 1 + u_hi^2 * 2/3.
+  double q1 = fputil::multiply_add(u_hi_sq, 0x1.5555555555555p-1, 1.0);
+  double u_hi_3 = u_hi_sq * u.hi;
+  double u_hi_4 = u_hi_sq * u_hi_sq;
+  // p3 ~ 1/3 + u_hi^2 * (2/15 + u_hi^2 * (17/315 + u_hi^2 * 62/2835))
+  double p3 = fputil::multiply_add(u_hi_4, p1, p2);
+  // q2 ~ 1 + u_hi^2 * (1 + u_hi^2 * 2/3)
+  double q2 = fputil::multiply_add(u_hi_sq, q1, 1.0);
+  double tan_lo = fputil::multiply_add(u_hi_3, p3, u.lo * q2);
+  // Overall, |tan(y) - (u_hi + tan_lo)| < ulp(u_hi^3) <= 2^-71.
+  // And the relative errors is:
+  // |(tan(y) - (u_hi + tan_lo)) / tan(y) | <= 2*ulp(u_hi^2) < 2^-64
+  result = fputil::exact_add(u.hi, tan_lo);
+  return fputil::multiply_add(fputil::FPBits<double>(u_hi_3).abs().get_val(),
+                              0x1.0p-51, 0x1.0p-102);
+}
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+// Accurate evaluation of tan for small u.
+[[maybe_unused]] Float128 tan_eval(const Float128 &u) {
+  Float128 u_sq = fputil::quick_mul(u, u);
+
+  // tan(x) ~ x + x^3/3 + x^5 * 2/15 + x^7 * 17/315 + x^9 * 62/2835 +
+  //          + x^11 * 1382/155925 + x^13 * 21844/6081075 +
+  //          + x^15 * 929569/638512875 + x^17 * 6404582/10854718875
+  // Relative errors < 2^-127 for |u| < pi/256.
+  constexpr Float128 TAN_COEFFS[] = {
+      {Sign::POS, -127, 0x80000000'00000000'00000000'00000000_u128}, // 1
+      {Sign::POS, -129, 0xaaaaaaaa'aaaaaaaa'aaaaaaaa'aaaaaaab_u128}, // 1
+      {Sign::POS, -130, 0x88888888'88888888'88888888'88888889_u128}, // 2/15
+      {Sign::POS, -132, 0xdd0dd0dd'0dd0dd0d'd0dd0dd0'dd0dd0dd_u128}, // 17/315
+      {Sign::POS, -133, 0xb327a441'6087cf99'6b5dd24e'ec0b327a_u128}, // 62/2835
+      {Sign::POS, -134,
+       0x91371aaf'3611e47a'da8e1cba'7d900eca_u128}, // 1382/155925
+      {Sign::POS, -136,
+       0xeb69e870'abeefdaf'e606d2e4'd1e65fbc_u128}, // 21844/6081075
+      {Sign::POS, -137,
+       0xbed1b229'5baf15b5'0ec9af45'a2619971_u128}, // 929569/638512875
+      {Sign::POS, -138,
+       0x9aac1240'1b3a2291'1b2ac7e3'e4627d0a_u128}, // 6404582/10854718875
+  };
+
+  return fputil::quick_mul(
+      u, fputil::polyeval(u_sq, TAN_COEFFS[0], TAN_COEFFS[1], TAN_COEFFS[2],
+                          TAN_COEFFS[3], TAN_COEFFS[4], TAN_COEFFS[5],
+                          TAN_COEFFS[6], TAN_COEFFS[7], TAN_COEFFS[8]));
+}
+
+// Calculation a / b = a * (1/b) for Float128.
+// Using the initial approximation of q ~ (1/b), then apply 2 Newton-Raphson
+// iterations, before multiplying by a.
+[[maybe_unused]] Float128 newton_raphson_div(const Float128 &a, Float128 b,
+                                             double q) {
+  Float128 q0(q);
+  constexpr Float128 TWO(2.0);
+  b.sign = (b.sign == Sign::POS) ? Sign::NEG : Sign::POS;
+  Float128 q1 =
+      fputil::quick_mul(q0, fputil::quick_add(TWO, fputil::quick_mul(b, q0)));
+  Float128 q2 =
+      fputil::quick_mul(q1, fputil::quick_add(TWO, fputil::quick_mul(b, q1)));
+  return fputil::quick_mul(a, q2);
+}
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+} // anonymous namespace
+
+LLVM_LIBC_FUNCTION(double, tan, (double x)) {
+  using FPBits = typename fputil::FPBits<double>;
+  FPBits xbits(x);
+
+  uint16_t x_e = xbits.get_biased_exponent();
+
+  DoubleDouble y;
+  unsigned k;
+  LargeRangeReduction range_reduction_large{};
+
+  // |x| < 2^16
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT)) {
+    // |x| < 2^-7
+    if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 7)) {
+      // |x| < 2^-27, |tan(x) - x| < ulp(x)/2.
+      if (LIBC_UNLIKELY(x_e < FPBits::EXP_BIAS - 27)) {
+        // Signed zeros.
+        if (LIBC_UNLIKELY(x == 0.0))
+          return x + x; // Make sure it works with FTZ/DAZ.
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA
+        return fputil::multiply_add(x, 0x1.0p-54, x);
+#else
+        if (LIBC_UNLIKELY(x_e < 4)) {
+          int rounding_mode = fputil::quick_get_round();
+          if ((xbits.sign() == Sign::POS && rounding_mode == FE_UPWARD) ||
+              (xbits.sign() == Sign::NEG && rounding_mode == FE_DOWNWARD))
+            return FPBits(xbits.uintval() + 1).get_val();
+        }
+        return fputil::multiply_add(x, 0x1.0p-54, x);
+#endif // LIBC_TARGET_CPU_HAS_FMA
+      }
+      // No range reduction needed.
+      k = 0;
+      y.lo = 0.0;
+      y.hi = x;
+    } else {
+      // Small range reduction.
+      k = range_reduction_small(x, y);
+    }
+  } else {
+    // Inf or NaN
+    if (LIBC_UNLIKELY(x_e > 2 * FPBits::EXP_BIAS)) {
+      // tan(+-Inf) = NaN
+      if (xbits.get_mantissa() == 0) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    // Large range reduction.
+    k = range_reduction_large.fast(x, y);
+  }
+
+  DoubleDouble tan_y;
+  [[maybe_unused]] double err = tan_eval(y, tan_y);
+
+  // Look up sin(k * pi/128) and cos(k * pi/128)
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+  // Memory saving versions. Use 65-entry table:
+  auto get_idx_dd = [](unsigned kk) -> DoubleDouble {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    DoubleDouble ans = SIN_K_PI_OVER_128[idx];
+    if (kk & 128) {
+      ans.hi = -ans.hi;
+      ans.lo = -ans.lo;
+    }
+    return ans;
+  };
+  DoubleDouble msin_k = get_idx_dd(k + 128);
+  DoubleDouble cos_k = get_idx_dd(k + 64);
+#else
+  // Fast look up version, but needs 256-entry table.
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  DoubleDouble msin_k = SIN_K_PI_OVER_128[(k + 128) & 255];
+  DoubleDouble cos_k = SIN_K_PI_OVER_128[(k + 64) & 255];
+#endif // LIBC_MATH_HAS_SMALL_TABLES
+
+  // After range reduction, k = round(x * 128 / pi) and y = x - k * (pi / 128).
+  // So k is an integer and -pi / 256 <= y <= pi / 256.
+  // Then tan(x) = sin(x) / cos(x)
+  //             = sin((k * pi/128 + y) / cos((k * pi/128 + y)
+  //             = (cos(y) * sin(k*pi/128) + sin(y) * cos(k*pi/128)) /
+  //               / (cos(y) * cos(k*pi/128) - sin(y) * sin(k*pi/128))
+  //             = (sin(k*pi/128) + tan(y) * cos(k*pi/128)) /
+  //               / (cos(k*pi/128) - tan(y) * sin(k*pi/128))
+  DoubleDouble cos_k_tan_y = fputil::quick_mult(tan_y, cos_k);
+  DoubleDouble msin_k_tan_y = fputil::quick_mult(tan_y, msin_k);
+
+  // num_dd = sin(k*pi/128) + tan(y) * cos(k*pi/128)
+  DoubleDouble num_dd = fputil::exact_add<false>(cos_k_tan_y.hi, -msin_k.hi);
+  // den_dd = cos(k*pi/128) - tan(y) * sin(k*pi/128)
+  DoubleDouble den_dd = fputil::exact_add<false>(msin_k_tan_y.hi, cos_k.hi);
+  num_dd.lo += cos_k_tan_y.lo - msin_k.lo;
+  den_dd.lo += msin_k_tan_y.lo + cos_k.lo;
+
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  double tan_x = (num_dd.hi + num_dd.lo) / (den_dd.hi + den_dd.lo);
+  return tan_x;
+#else
+  // Accurate test and pass for correctly rounded implementation.
+
+  // Accurate double-double division
+  DoubleDouble tan_x = fputil::div(num_dd, den_dd);
+
+  // Simple error bound: |1 / den_dd| < 2^(1 + floor(-log2(den_dd)))).
+  uint64_t den_inv = (static_cast<uint64_t>(FPBits::EXP_BIAS + 1)
+                      << (FPBits::FRACTION_LEN + 1)) -
+                     (FPBits(den_dd.hi).uintval() & FPBits::EXP_MASK);
+
+  // For tan_x = (num_dd + err) / (den_dd + err), the error is bounded by:
+  //   | tan_x - num_dd / den_dd |  <= err * ( 1 + | tan_x * den_dd | ).
+  double tan_err =
+      err * fputil::multiply_add(FPBits(den_inv).get_val(),
+                                 FPBits(tan_x.hi).abs().get_val(), 1.0);
+
+  double err_higher = tan_x.lo + tan_err;
+  double err_lower = tan_x.lo - tan_err;
+
+  double tan_upper = tan_x.hi + err_higher;
+  double tan_lower = tan_x.hi + err_lower;
+
+  // Ziv's rounding test.
+  if (LIBC_LIKELY(tan_upper == tan_lower))
+    return tan_upper;
+
+  Float128 u_f128;
+  if (LIBC_LIKELY(x_e < FPBits::EXP_BIAS + FAST_PASS_EXPONENT))
+    u_f128 = range_reduction_small_f128(x);
+  else
+    u_f128 = range_reduction_large.accurate();
+
+  Float128 tan_u = tan_eval(u_f128);
+
+  auto get_sin_k = [](unsigned kk) -> Float128 {
+    unsigned idx = (kk & 64) ? 64 - (kk & 63) : (kk & 63);
+    Float128 ans = SIN_K_PI_OVER_128_F128[idx];
+    if (kk & 128)
+      ans.sign = Sign::NEG;
+    return ans;
+  };
+
+  // cos(k * pi/128) = sin(k * pi/128 + pi/2) = sin((k + 64) * pi/128).
+  Float128 sin_k_f128 = get_sin_k(k);
+  Float128 cos_k_f128 = get_sin_k(k + 64);
+  Float128 msin_k_f128 = get_sin_k(k + 128);
+
+  // num_f128 = sin(k*pi/128) + tan(y) * cos(k*pi/128)
+  Float128 num_f128 =
+      fputil::quick_add(sin_k_f128, fputil::quick_mul(cos_k_f128, tan_u));
+  // den_f128 = cos(k*pi/128) - tan(y) * sin(k*pi/128)
+  Float128 den_f128 =
+      fputil::quick_add(cos_k_f128, fputil::quick_mul(msin_k_f128, tan_u));
+
+  // tan(x) = (sin(k*pi/128) + tan(y) * cos(k*pi/128)) /
+  //          / (cos(k*pi/128) - tan(y) * sin(k*pi/128))
+  // TODO: The initial seed 1.0/den_dd.hi for Newton-Raphson reciprocal can be
+  // reused from DoubleDouble fputil::div in the fast pass.
+  Float128 result = newton_raphson_div(num_f128, den_f128, 1.0 / den_dd.hi);
+
+  // TODO: Add assertion if Ziv's accuracy tests fail in debug mode.
+  // https://github.com/llvm/llvm-project/issues/96452.
+  return static_cast<double>(result);
+
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tanf.cpp b/src/math/generic/tanf.cpp
index b2882b5..6fd5f9a 100644
--- a/src/math/generic/tanf.cpp
+++ b/src/math/generic/tanf.cpp
@@ -15,12 +15,11 @@
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Exceptional cases for tanf.
 constexpr size_t N_EXCEPTS = 6;
@@ -139,4 +138,4 @@ LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
       multiply_add(sin_y, -sin_k, multiply_add(cosm1_y, cos_k, cos_k)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tanhf.cpp b/src/math/generic/tanhf.cpp
index 0efd0ce..32153c3 100644
--- a/src/math/generic/tanhf.cpp
+++ b/src/math/generic/tanhf.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h"
 #include "src/math/generic/explogxf.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // 2^6 * log2(e)
 constexpr double LOG2_E_EXP2_6 = ExpBase::LOG2_B * 2.0;
@@ -116,4 +117,4 @@ LLVM_LIBC_FUNCTION(float, tanhf, (float x)) {
   return static_cast<float>((r - mh) / (r + mh));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tanhf16.cpp b/src/math/generic/tanhf16.cpp
new file mode 100644
index 0000000..0266b5c
--- /dev/null
+++ b/src/math/generic/tanhf16.cpp
@@ -0,0 +1,147 @@
+//===-- Half-precision tanh(x) function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanhf16.h"
+#include "expxf16.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/CPP/array.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static constexpr fputil::ExceptValues<float16, 2> TANHF16_EXCEPTS = {{
+    // x = 0x1.f54p+0, tanhf16(x) = 0x1.ecp-1 (RZ)
+    {0x3fd5U, 0x3bb0U, 1U, 0U, 0U},
+    // x = -0x1.f54p+0, tanhf16(x) = -0x1.ecp-1 (RZ)
+    {0xbfd5U, 0xbbb0U, 0U, 1U, 0U},
+}};
+
+LLVM_LIBC_FUNCTION(float16, tanhf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits x_bits(x);
+
+  uint16_t x_u = x_bits.uintval();
+  uint16_t x_abs = x_u & 0x7fffU;
+
+  // When -2^(-14) <= x <= -2^(-9), or |x| <= 0x1.d2p-4,
+  // or |x| >= atanh(1 - 2^(-11)), or x is NaN.
+  if (LIBC_UNLIKELY(x_abs <= 0x2f48U || x_abs >= 0x4429U)) {
+    // tanh(NaN) = NaN
+    if (x_bits.is_nan()) {
+      if (x_bits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // When -2^(-14) <= x <= -2^(-9).
+    if (x_u >= 0x8400U && x_u <= 0x9800U) {
+      switch (fputil::quick_get_round()) {
+      case FE_TONEAREST:
+      case FE_DOWNWARD:
+        return x;
+      default:
+        return FPBits(static_cast<uint16_t>(x_u - 1U)).get_val();
+      }
+    }
+
+    // When |x| <= 0x1.d2p-4.
+    if (x_abs <= 0x2f48U) {
+      if (LIBC_UNLIKELY(x_abs == 0))
+        return x;
+
+      float xf = x;
+      float xf_sq = xf * xf;
+      // Degree-7 Taylor expansion generated by Sollya with the following
+      // commands:
+      //   > taylor(tanh(x), 7, 0);
+      //   > display = hexadecimal;
+      //   > // For each coefficient:
+      //   > round(/* put coefficient here */, SG, RN);
+      return fputil::cast<float16>(
+          xf * fputil::polyeval(xf_sq, 0x1p+0f, -0x1.555556p-2f, 0x1.111112p-3f,
+                                -0x1.ba1ba2p-5f));
+    }
+
+    // tanh(+/-inf) = +/-1
+    if (x_bits.is_inf())
+      return FPBits::one(x_bits.sign()).get_val();
+
+    // When |x| >= atanh(1 - 2^(-11)).
+    fputil::raise_except_if_required(FE_INEXACT);
+
+    int rounding_mode = fputil::quick_get_round();
+    if ((rounding_mode == FE_TONEAREST && x_abs >= 0x4482U) ||
+        (rounding_mode == FE_UPWARD && x_bits.is_pos()) ||
+        (rounding_mode == FE_DOWNWARD && x_bits.is_neg())) {
+      return FPBits::one(x_bits.sign()).get_val();
+    }
+    if (x_bits.is_pos())
+      return fputil::cast<float16>(0x1.ffcp-1);
+    return fputil::cast<float16>(-0x1.ffcp-1);
+  }
+
+  if (auto r = TANHF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+
+  // For atanh(-1 + 2^(-11)) < x < atanh(1 - 2^(-11)), to compute tanh(x), we
+  // perform the following range reduction: find hi, mid, lo, such that:
+  //   x = (hi + mid) * log(2) * 0.5 + lo, in which
+  //     hi is an integer,
+  //     mid * 2^5 is an integer,
+  //     -2^(-5) <= lo < 2^(-5).
+  // In particular,
+  //   hi + mid = round(x * log2(e) * 2 * 2^5) * 2^(-5).
+  // Then,
+  //   tanh(x) = sinh(x)/cosh(x)
+  //           = (e^x - e^(-x)) / (e^x + e^(-x))
+  //           = (e^(2x) - 1) / (e^(2x) + 1)
+  //           = (2^(hi + mid) * e^(2*lo) - 1) / (2^(hi + mid) * e^(2*lo) + 1)
+  //           = (e^(2*lo) - 2^(-hi - mid)) / (e^(2*lo) + 2^(-hi - mid))
+  // We store 2^(-mid) in the lookup table EXP2_MID_5_BITS, and compute
+  // 2^(-hi - mid) by adding -hi to the exponent field of 2^(-mid).
+  // e^lo is computed using a degree-3 minimax polynomial generated by Sollya.
+
+  float xf = x;
+  float kf = fputil::nearest_integer(xf * (LOG2F_E * 2.0f * 0x1.0p+5f));
+  int x_hi_mid = -static_cast<int>(kf);
+  unsigned x_hi = static_cast<unsigned>(x_hi_mid) >> 5;
+  unsigned x_mid = static_cast<unsigned>(x_hi_mid) & 0x1f;
+  // lo = x - (hi + mid)
+  //    = round(x * log2(e) * 2 * 2^5) * log(2) * 0.5 * (-2^(-5)) + x
+  float lo = fputil::multiply_add(kf, LOGF_2 * 0.5f * -0x1.0p-5f, xf);
+
+  uint32_t exp2_hi_mid_bits =
+      EXP2_MID_5_BITS[x_mid] +
+      static_cast<uint32_t>(x_hi << fputil::FPBits<float>::FRACTION_LEN);
+  // exp2_hi_mid = 2^(-hi - mid)
+  float exp2_hi_mid = fputil::FPBits<float>(exp2_hi_mid_bits).get_val();
+  // Degree-3 minimax polynomial generated by Sollya with the following
+  // commands:
+  //   > display = hexadecimal;
+  //   > P = fpminimax(expm1(2*x)/x, 2, [|SG...|], [-2^-5, 2^-5]);
+  //   > 1 + x * P;
+  float exp_2lo =
+      fputil::polyeval(lo, 0x1p+0f, 0x1p+1f, 0x1.001p+1f, 0x1.555ddep+0f);
+  return fputil::cast<float16>((exp_2lo - exp2_hi_mid) /
+                               (exp_2lo + exp2_hi_mid));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tanpif16.cpp b/src/math/generic/tanpif16.cpp
new file mode 100644
index 0000000..ab3c9cb
--- /dev/null
+++ b/src/math/generic/tanpif16.cpp
@@ -0,0 +1,103 @@
+//===-- Half-precision tanpif function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanpif16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+constexpr size_t N_EXCEPTS = 21;
+
+constexpr fputil::ExceptValues<float16, N_EXCEPTS> TANF16_EXCEPTS{{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    {0x07f2, 0x0e3d, 1, 0, 0}, {0x086a, 0x0eee, 1, 0, 1},
+    {0x08db, 0x0fa0, 1, 0, 0}, {0x094c, 0x1029, 1, 0, 0},
+    {0x0b10, 0x118c, 1, 0, 0}, {0x1ce0, 0x23a8, 1, 0, 1},
+    {0x1235, 0x18e0, 1, 0, 0}, {0x2579, 0x2c4e, 1, 0, 0},
+    {0x28b2, 0x2f68, 1, 0, 1}, {0x2a43, 0x30f4, 1, 0, 1},
+    {0x31b7, 0x3907, 1, 0, 0}, {0x329d, 0x3a12, 1, 0, 1},
+    {0x34f1, 0x3dd7, 1, 0, 0}, {0x3658, 0x41ee, 1, 0, 0},
+    {0x38d4, 0xc1ee, 0, 1, 0}, {0x3d96, 0x41ee, 1, 0, 0},
+    {0x3e6a, 0xc1ee, 0, 1, 0}, {0x40cb, 0x41ee, 1, 0, 0},
+    {0x4135, 0xc1ee, 0, 1, 0}, {0x42cb, 0x41ee, 1, 0, 0},
+    {0x4335, 0xc1ee, 0, 1, 0},
+}};
+
+LLVM_LIBC_FUNCTION(float16, tanpif16, (float16 x)) {
+  using FPBits = typename fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+
+  // Handle exceptional values
+  if (LIBC_UNLIKELY(x_abs <= 0x4335)) {
+    if (LIBC_UNLIKELY(x_abs == 0U))
+      return x;
+
+    bool x_sign = x_u >> 15;
+    if (auto r = TANF16_EXCEPTS.lookup_odd(x_abs, x_sign);
+        LIBC_UNLIKELY(r.has_value()))
+      return r.value();
+  }
+
+  // Numbers greater or equal to 2^10 are integers, or infinity, or NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x6400)) {
+    // Check for NaN or infinity values
+    if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
+      if (x_abs == 0x7c00) {
+        fputil::set_errno_if_required(EDOM);
+        fputil::raise_except_if_required(FE_INVALID);
+      }
+
+      return x + FPBits::quiet_nan().get_val();
+    }
+
+    return FPBits::zero(xbits.sign()).get_val();
+  }
+  // Range reduction:
+  // For |x| > 1/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * 1/32
+  //   k is an integer
+  //   |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32)
+  //   y = x * 32 - k
+  //
+  // Once k and y are computed, we then deduce the answer by tthe formula:
+  // tan(x) = sin(x) / cos(x)
+  //        = (sin_y * cos_k + cos_y * sin_k) / (cos_y * cos_k - sin_y * sin_k)
+  float xf = x;
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincospif16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && cos_k == 0)) {
+    fputil::set_errno_if_required(EDOM);
+    fputil::raise_except_if_required(FE_DIVBYZERO);
+
+    int16_t x_mp5_u = static_cast<int16_t>(x - 0.5);
+    return ((x_mp5_u & 0x1) ? -1 : 1) * FPBits::inf().get_val();
+  }
+
+  using fputil::multiply_add;
+  return fputil::cast<float16>(
+      multiply_add(sin_y, cos_k, multiply_add(cosm1_y, sin_k, sin_k)) /
+      multiply_add(sin_y, -sin_k, multiply_add(cosm1_y, cos_k, cos_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalorder.cpp b/src/math/generic/totalorder.cpp
new file mode 100644
index 0000000..f052c81
--- /dev/null
+++ b/src/math/generic/totalorder.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of totalorder function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalorder.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalorder, (const double *x, const double *y)) {
+  return static_cast<int>(fputil::totalorder(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalorderf.cpp b/src/math/generic/totalorderf.cpp
new file mode 100644
index 0000000..17c1304
--- /dev/null
+++ b/src/math/generic/totalorderf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of totalorderf function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalorderf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalorderf, (const float *x, const float *y)) {
+  return static_cast<int>(fputil::totalorder(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalorderf128.cpp b/src/math/generic/totalorderf128.cpp
new file mode 100644
index 0000000..83d7768
--- /dev/null
+++ b/src/math/generic/totalorderf128.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of totalorderf128 function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalorderf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalorderf128,
+                   (const float128 *x, const float128 *y)) {
+  return static_cast<int>(fputil::totalorder(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalorderf16.cpp b/src/math/generic/totalorderf16.cpp
index e43beb3..743aa5a 100644
--- a/src/math/generic/totalorderf16.cpp
+++ b/src/math/generic/totalorderf16.cpp
@@ -9,11 +9,12 @@
 #include "src/math/totalorderf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, totalorderf16, (const float16 *x, const float16 *y)) {
   return static_cast<int>(fputil::totalorder(*x, *y));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalorderl.cpp b/src/math/generic/totalorderl.cpp
new file mode 100644
index 0000000..1aae1c6
--- /dev/null
+++ b/src/math/generic/totalorderl.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of totalorderl function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalorderl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalorderl,
+                   (const long double *x, const long double *y)) {
+  return static_cast<int>(fputil::totalorder(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalordermag.cpp b/src/math/generic/totalordermag.cpp
new file mode 100644
index 0000000..fb8215c
--- /dev/null
+++ b/src/math/generic/totalordermag.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of totalordermag function --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalordermag.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalordermag, (const double *x, const double *y)) {
+  return static_cast<int>(fputil::totalordermag(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalordermagf.cpp b/src/math/generic/totalordermagf.cpp
new file mode 100644
index 0000000..6b93bac
--- /dev/null
+++ b/src/math/generic/totalordermagf.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of totalordermagf function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalordermagf.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalordermagf, (const float *x, const float *y)) {
+  return static_cast<int>(fputil::totalordermag(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalordermagf128.cpp b/src/math/generic/totalordermagf128.cpp
new file mode 100644
index 0000000..b32abfa
--- /dev/null
+++ b/src/math/generic/totalordermagf128.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of totalordermagf128 function ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalordermagf128.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalordermagf128,
+                   (const float128 *x, const float128 *y)) {
+  return static_cast<int>(fputil::totalordermag(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalordermagf16.cpp b/src/math/generic/totalordermagf16.cpp
index 09d04fb..0d2e9e1 100644
--- a/src/math/generic/totalordermagf16.cpp
+++ b/src/math/generic/totalordermagf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/totalordermagf16.h"
 #include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, totalordermagf16,
                    (const float16 *x, const float16 *y)) {
   return static_cast<int>(fputil::totalordermag(*x, *y));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/totalordermagl.cpp b/src/math/generic/totalordermagl.cpp
new file mode 100644
index 0000000..49eed62
--- /dev/null
+++ b/src/math/generic/totalordermagl.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation of totalordermagl function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/totalordermagl.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, totalordermagl,
+                   (const long double *x, const long double *y)) {
+  return static_cast<int>(fputil::totalordermag(*x, *y));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/trunc.cpp b/src/math/generic/trunc.cpp
index d171ab1..603750f 100644
--- a/src/math/generic/trunc.cpp
+++ b/src/math/generic/trunc.cpp
@@ -9,9 +9,16 @@
 #include "src/math/trunc.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, trunc, (double x)) { return fputil::trunc(x); }
+LLVM_LIBC_FUNCTION(double, trunc, (double x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_trunc(x);
+#else
+  return fputil::trunc(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/truncf.cpp b/src/math/generic/truncf.cpp
index 93bfb7f..d7b0ffd 100644
--- a/src/math/generic/truncf.cpp
+++ b/src/math/generic/truncf.cpp
@@ -9,9 +9,16 @@
 #include "src/math/truncf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float, truncf, (float x)) { return fputil::trunc(x); }
+LLVM_LIBC_FUNCTION(float, truncf, (float x)) {
+#ifdef __LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC
+  return __builtin_truncf(x);
+#else
+  return fputil::trunc(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/truncf128.cpp b/src/math/generic/truncf128.cpp
index ecf05fa..200dbf1 100644
--- a/src/math/generic/truncf128.cpp
+++ b/src/math/generic/truncf128.cpp
@@ -9,11 +9,12 @@
 #include "src/math/truncf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, truncf128, (float128 x)) {
   return fputil::trunc(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/truncf16.cpp b/src/math/generic/truncf16.cpp
index 65bd57d..4d37e65 100644
--- a/src/math/generic/truncf16.cpp
+++ b/src/math/generic/truncf16.cpp
@@ -8,10 +8,20 @@
 
 #include "src/math/truncf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/cpu_features.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(float16, truncf16, (float16 x)) { return fputil::trunc(x); }
+LLVM_LIBC_FUNCTION(float16, truncf16, (float16 x)) {
+#if defined(__LIBC_USE_BUILTIN_CEIL_FLOOR_RINT_TRUNC) &&                       \
+    defined(LIBC_TARGET_CPU_HAS_FAST_FLOAT16_OPS)
+  return fputil::cast<float16>(__builtin_truncf(x));
+#else
+  return fputil::trunc(x);
+#endif
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/truncl.cpp b/src/math/generic/truncl.cpp
index 3429129..83b0827 100644
--- a/src/math/generic/truncl.cpp
+++ b/src/math/generic/truncl.cpp
@@ -9,11 +9,12 @@
 #include "src/math/truncl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, truncl, (long double x)) {
   return fputil::trunc(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfp.cpp b/src/math/generic/ufromfp.cpp
index 15800d6..f460a43 100644
--- a/src/math/generic/ufromfp.cpp
+++ b/src/math/generic/ufromfp.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ufromfp.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ufromfp, (double x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpf.cpp b/src/math/generic/ufromfpf.cpp
index 898446e..07be4e9 100644
--- a/src/math/generic/ufromfpf.cpp
+++ b/src/math/generic/ufromfpf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ufromfpf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ufromfpf, (float x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpf128.cpp b/src/math/generic/ufromfpf128.cpp
index cc728f3..1a532cf 100644
--- a/src/math/generic/ufromfpf128.cpp
+++ b/src/math/generic/ufromfpf128.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, ufromfpf128,
                    (float128 x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpf16.cpp b/src/math/generic/ufromfpf16.cpp
index bf041f4..314c525 100644
--- a/src/math/generic/ufromfpf16.cpp
+++ b/src/math/generic/ufromfpf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, ufromfpf16,
                    (float16 x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpl.cpp b/src/math/generic/ufromfpl.cpp
index bd353e9..050950a 100644
--- a/src/math/generic/ufromfpl.cpp
+++ b/src/math/generic/ufromfpl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, ufromfpl,
                    (long double x, int rnd, unsigned int width)) {
   return fputil::fromfp</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpx.cpp b/src/math/generic/ufromfpx.cpp
index 5ad95ff..178049b 100644
--- a/src/math/generic/ufromfpx.cpp
+++ b/src/math/generic/ufromfpx.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ufromfpx.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ufromfpx, (double x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpxf.cpp b/src/math/generic/ufromfpxf.cpp
index 7c87848..8f3cd50 100644
--- a/src/math/generic/ufromfpxf.cpp
+++ b/src/math/generic/ufromfpxf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/ufromfpxf.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ufromfpxf, (float x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpxf128.cpp b/src/math/generic/ufromfpxf128.cpp
index 57c2903..9d6348c 100644
--- a/src/math/generic/ufromfpxf128.cpp
+++ b/src/math/generic/ufromfpxf128.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpxf128.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float128, ufromfpxf128,
                    (float128 x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpxf16.cpp b/src/math/generic/ufromfpxf16.cpp
index aeb7aa8..b1f42a8 100644
--- a/src/math/generic/ufromfpxf16.cpp
+++ b/src/math/generic/ufromfpxf16.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpxf16.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float16, ufromfpxf16,
                    (float16 x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/ufromfpxl.cpp b/src/math/generic/ufromfpxl.cpp
index 9a8ba7a..637721e 100644
--- a/src/math/generic/ufromfpxl.cpp
+++ b/src/math/generic/ufromfpxl.cpp
@@ -9,12 +9,13 @@
 #include "src/math/ufromfpxl.h"
 #include "src/__support/FPUtil/NearestIntegerOperations.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, ufromfpxl,
                    (long double x, int rnd, unsigned int width)) {
   return fputil::fromfpx</*IsSigned=*/false>(x, rnd, width);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/getpayload.h b/src/math/getpayload.h
new file mode 100644
index 0000000..b00d313
--- /dev/null
+++ b/src/math/getpayload.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for getpayload --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GETPAYLOAD_H
+#define LLVM_LIBC_SRC_MATH_GETPAYLOAD_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double getpayload(const double *x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GETPAYLOAD_H
diff --git a/src/math/getpayloadf.h b/src/math/getpayloadf.h
new file mode 100644
index 0000000..20901cd
--- /dev/null
+++ b/src/math/getpayloadf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for getpayloadf -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GETPAYLOADF_H
+#define LLVM_LIBC_SRC_MATH_GETPAYLOADF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float getpayloadf(const float *x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GETPAYLOADF_H
diff --git a/src/math/getpayloadf128.h b/src/math/getpayloadf128.h
new file mode 100644
index 0000000..7ebb429
--- /dev/null
+++ b/src/math/getpayloadf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for getpayloadf128 ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GETPAYLOADF128_H
+#define LLVM_LIBC_SRC_MATH_GETPAYLOADF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float128 getpayloadf128(const float128 *x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GETPAYLOADF128_H
diff --git a/src/math/getpayloadf16.h b/src/math/getpayloadf16.h
index 1349dfd..565454e 100644
--- a/src/math/getpayloadf16.h
+++ b/src/math/getpayloadf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_GETPAYLOADF16_H
 #define LLVM_LIBC_SRC_MATH_GETPAYLOADF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 getpayloadf16(const float16 *x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GETPAYLOADF16_H
diff --git a/src/math/getpayloadl.h b/src/math/getpayloadl.h
new file mode 100644
index 0000000..1ae9f86
--- /dev/null
+++ b/src/math/getpayloadl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for getpayloadl -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GETPAYLOADL_H
+#define LLVM_LIBC_SRC_MATH_GETPAYLOADL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double getpayloadl(const long double *x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GETPAYLOADL_H
diff --git a/src/math/hypot.h b/src/math/hypot.h
index 981473f..b78792b 100644
--- a/src/math/hypot.h
+++ b/src/math/hypot.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_HYPOT_H
 #define LLVM_LIBC_SRC_MATH_HYPOT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double hypot(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_HYPOT_H
diff --git a/src/math/hypotf.h b/src/math/hypotf.h
index 1d290b4..2c10c46 100644
--- a/src/math/hypotf.h
+++ b/src/math/hypotf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_HYPOTF_H
 #define LLVM_LIBC_SRC_MATH_HYPOTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float hypotf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_HYPOTF_H
diff --git a/src/math/ilogb.h b/src/math/ilogb.h
index e851a6a..5b43107 100644
--- a/src/math/ilogb.h
+++ b/src/math/ilogb.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ILOGB_H
 #define LLVM_LIBC_SRC_MATH_ILOGB_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int ilogb(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ILOGB_H
diff --git a/src/math/ilogbf.h b/src/math/ilogbf.h
index edea346..36197ec 100644
--- a/src/math/ilogbf.h
+++ b/src/math/ilogbf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ILOGBF_H
 #define LLVM_LIBC_SRC_MATH_ILOGBF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int ilogbf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ILOGBF_H
diff --git a/src/math/ilogbf128.h b/src/math/ilogbf128.h
index d8fe3b9..9ea5e89 100644
--- a/src/math/ilogbf128.h
+++ b/src/math/ilogbf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ILOGBF128_H
 #define LLVM_LIBC_SRC_MATH_ILOGBF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ilogbf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ILOGBF128_H
diff --git a/src/math/ilogbf16.h b/src/math/ilogbf16.h
index 4884a14..a712cd7 100644
--- a/src/math/ilogbf16.h
+++ b/src/math/ilogbf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ILOGBF16_H
 #define LLVM_LIBC_SRC_MATH_ILOGBF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ilogbf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ILOGBF16_H
diff --git a/src/math/ilogbl.h b/src/math/ilogbl.h
index 1b4782f..5f089e2 100644
--- a/src/math/ilogbl.h
+++ b/src/math/ilogbl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ILOGBL_H
 #define LLVM_LIBC_SRC_MATH_ILOGBL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int ilogbl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ILOGBL_H
diff --git a/src/math/iscanonical.h b/src/math/iscanonical.h
new file mode 100644
index 0000000..14b2d17
--- /dev/null
+++ b/src/math/iscanonical.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for iscanonical -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISCANONICAL_H
+#define LLVM_LIBC_SRC_MATH_ISCANONICAL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscanonical(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISCANONICAL_H
diff --git a/src/math/iscanonicalf.h b/src/math/iscanonicalf.h
new file mode 100644
index 0000000..fdb48bc
--- /dev/null
+++ b/src/math/iscanonicalf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for iscanonicalf ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISCANONICALF_H
+#define LLVM_LIBC_SRC_MATH_ISCANONICALF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscanonicalf(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISCANONICALF_H
diff --git a/src/math/iscanonicalf128.h b/src/math/iscanonicalf128.h
new file mode 100644
index 0000000..9ba021c
--- /dev/null
+++ b/src/math/iscanonicalf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for iscanonicalf128 ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISCANONICALF128_H
+#define LLVM_LIBC_SRC_MATH_ISCANONICALF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscanonicalf128(float128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISCANONICALF128_H
diff --git a/src/math/iscanonicalf16.h b/src/math/iscanonicalf16.h
new file mode 100644
index 0000000..565d3ea
--- /dev/null
+++ b/src/math/iscanonicalf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for iscanonicalf16 ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISCANONICALF16_H
+#define LLVM_LIBC_SRC_MATH_ISCANONICALF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscanonicalf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISCANONICALF16_H
diff --git a/src/math/iscanonicall.h b/src/math/iscanonicall.h
new file mode 100644
index 0000000..edda6e3
--- /dev/null
+++ b/src/math/iscanonicall.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for iscanonicall ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISCANONICALL_H
+#define LLVM_LIBC_SRC_MATH_ISCANONICALL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int iscanonicall(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISCANONICALL_H
diff --git a/src/math/isnan.h b/src/math/isnan.h
new file mode 100644
index 0000000..e9776fd
--- /dev/null
+++ b/src/math/isnan.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for isnan -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISNAN_H
+#define LLVM_LIBC_SRC_MATH_ISNAN_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isnan(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISNAN_H
diff --git a/src/math/isnanf.h b/src/math/isnanf.h
new file mode 100644
index 0000000..bdf74d3
--- /dev/null
+++ b/src/math/isnanf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for isnanf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISNANF_H
+#define LLVM_LIBC_SRC_MATH_ISNANF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isnanf(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISNANF_H
diff --git a/src/math/isnanl.h b/src/math/isnanl.h
new file mode 100644
index 0000000..ade6a88
--- /dev/null
+++ b/src/math/isnanl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for isnanl ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISNANL_H
+#define LLVM_LIBC_SRC_MATH_ISNANL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int isnanl(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISNANL_H
diff --git a/src/math/issignaling.h b/src/math/issignaling.h
new file mode 100644
index 0000000..093fd7d
--- /dev/null
+++ b/src/math/issignaling.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for issignaling -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISSIGNALING_H
+#define LLVM_LIBC_SRC_MATH_ISSIGNALING_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int issignaling(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISSIGNALING_H
diff --git a/src/math/issignalingf.h b/src/math/issignalingf.h
new file mode 100644
index 0000000..9752260
--- /dev/null
+++ b/src/math/issignalingf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for issignalingf ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISSIGNALINGF_H
+#define LLVM_LIBC_SRC_MATH_ISSIGNALINGF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int issignalingf(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISSIGNALINGF_H
diff --git a/src/math/issignalingf128.h b/src/math/issignalingf128.h
new file mode 100644
index 0000000..7d1bfde
--- /dev/null
+++ b/src/math/issignalingf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for issignalingf128 ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISSIGNALINGF128_H
+#define LLVM_LIBC_SRC_MATH_ISSIGNALINGF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int issignalingf128(float128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISSIGNALINGF128_H
diff --git a/src/math/issignalingf16.h b/src/math/issignalingf16.h
new file mode 100644
index 0000000..2b38525
--- /dev/null
+++ b/src/math/issignalingf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for issignalingf16 ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISSIGNALINGF16_H
+#define LLVM_LIBC_SRC_MATH_ISSIGNALINGF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int issignalingf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISSIGNALINGF16_H
diff --git a/src/math/issignalingl.h b/src/math/issignalingl.h
new file mode 100644
index 0000000..edc0394
--- /dev/null
+++ b/src/math/issignalingl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for issignalingl ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ISSIGNALINGL_H
+#define LLVM_LIBC_SRC_MATH_ISSIGNALINGL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int issignalingl(long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ISSIGNALINGL_H
diff --git a/src/math/ldexp.h b/src/math/ldexp.h
index 7a8bcc3..e7897d2 100644
--- a/src/math/ldexp.h
+++ b/src/math/ldexp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LDEXP_H
 #define LLVM_LIBC_SRC_MATH_LDEXP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double ldexp(double x, int exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LDEXP_H
diff --git a/src/math/ldexpf.h b/src/math/ldexpf.h
index c06b487..363a1b7 100644
--- a/src/math/ldexpf.h
+++ b/src/math/ldexpf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LDEXPF_H
 #define LLVM_LIBC_SRC_MATH_LDEXPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float ldexpf(float x, int exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LDEXPF_H
diff --git a/src/math/ldexpf128.h b/src/math/ldexpf128.h
index 7aa6ded..74c3ef6 100644
--- a/src/math/ldexpf128.h
+++ b/src/math/ldexpf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LDEXPF128_H
 #define LLVM_LIBC_SRC_MATH_LDEXPF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 ldexpf128(float128 x, int exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LDEXPF128_H
diff --git a/src/math/ldexpf16.h b/src/math/ldexpf16.h
index 7303610..877e48b 100644
--- a/src/math/ldexpf16.h
+++ b/src/math/ldexpf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LDEXPF16_H
 #define LLVM_LIBC_SRC_MATH_LDEXPF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 ldexpf16(float16 x, int exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LDEXPF16_H
diff --git a/src/math/ldexpl.h b/src/math/ldexpl.h
index f2df0c8..16a480d 100644
--- a/src/math/ldexpl.h
+++ b/src/math/ldexpl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LDEXPL_H
 #define LLVM_LIBC_SRC_MATH_LDEXPL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double ldexpl(long double x, int exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LDEXPL_H
diff --git a/src/math/lgamma.h b/src/math/lgamma.h
new file mode 100644
index 0000000..4c7d365
--- /dev/null
+++ b/src/math/lgamma.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for lgamma ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_LGAMMA_H
+#define LLVM_LIBC_SRC_MATH_LGAMMA_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double lgamma(double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_LGAMMA_H
diff --git a/src/math/lgamma_r.h b/src/math/lgamma_r.h
new file mode 100644
index 0000000..1ca6b94
--- /dev/null
+++ b/src/math/lgamma_r.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for lgamma_r-----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_LGAMMA_R_H
+#define LLVM_LIBC_SRC_MATH_LGAMMA_R_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double lgamma_r(double x, int *signp);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_LGAMMA_R_H
diff --git a/src/math/llogb.h b/src/math/llogb.h
index b51f89f..f945489 100644
--- a/src/math/llogb.h
+++ b/src/math/llogb.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLOGB_H
 #define LLVM_LIBC_SRC_MATH_LLOGB_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long llogb(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLOGB_H
diff --git a/src/math/llogbf.h b/src/math/llogbf.h
index af4aa8a..4415562 100644
--- a/src/math/llogbf.h
+++ b/src/math/llogbf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLOGBF_H
 #define LLVM_LIBC_SRC_MATH_LLOGBF_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long llogbf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLOGBF_H
diff --git a/src/math/llogbf128.h b/src/math/llogbf128.h
index ce7c872..1ad4932 100644
--- a/src/math/llogbf128.h
+++ b/src/math/llogbf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLOGBF128_H
 #define LLVM_LIBC_SRC_MATH_LLOGBF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long llogbf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLOGBF128_H
diff --git a/src/math/llogbf16.h b/src/math/llogbf16.h
index 267ae41..4672328 100644
--- a/src/math/llogbf16.h
+++ b/src/math/llogbf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLOGBF16_H
 #define LLVM_LIBC_SRC_MATH_LLOGBF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long llogbf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLOGBF16_H
diff --git a/src/math/llogbl.h b/src/math/llogbl.h
index 3c323a3..bf502a1 100644
--- a/src/math/llogbl.h
+++ b/src/math/llogbl.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLOGBL_H
 #define LLVM_LIBC_SRC_MATH_LLOGBL_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long llogbl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLOGBL_H
diff --git a/src/math/llrint.h b/src/math/llrint.h
index 69c881e..7ad5bbd 100644
--- a/src/math/llrint.h
+++ b/src/math/llrint.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLRINT_H
 #define LLVM_LIBC_SRC_MATH_LLRINT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llrint(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLRINT_H
diff --git a/src/math/llrintf.h b/src/math/llrintf.h
index 023e84a..89334b5 100644
--- a/src/math/llrintf.h
+++ b/src/math/llrintf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLRINTF_H
 #define LLVM_LIBC_SRC_MATH_LLRINTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llrintf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLRINTF_H
diff --git a/src/math/llrintf128.h b/src/math/llrintf128.h
index ac9c249..ff2e9a2 100644
--- a/src/math/llrintf128.h
+++ b/src/math/llrintf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLRINTF128_H
 #define LLVM_LIBC_SRC_MATH_LLRINTF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long long llrintf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLRINTF128_H
diff --git a/src/math/llrintf16.h b/src/math/llrintf16.h
index 90ad0e9..5c05303 100644
--- a/src/math/llrintf16.h
+++ b/src/math/llrintf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLRINTF16_H
 #define LLVM_LIBC_SRC_MATH_LLRINTF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long long llrintf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLRINTF16_H
diff --git a/src/math/llrintl.h b/src/math/llrintl.h
index 4dbcc60..0c0d7d3 100644
--- a/src/math/llrintl.h
+++ b/src/math/llrintl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLRINTL_H
 #define LLVM_LIBC_SRC_MATH_LLRINTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llrintl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLRINTL_H
diff --git a/src/math/llround.h b/src/math/llround.h
index 265b4fd..3843e12 100644
--- a/src/math/llround.h
+++ b/src/math/llround.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLROUND_H
 #define LLVM_LIBC_SRC_MATH_LLROUND_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llround(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLROUND_H
diff --git a/src/math/llroundf.h b/src/math/llroundf.h
index 2141ca9..7f61889 100644
--- a/src/math/llroundf.h
+++ b/src/math/llroundf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLROUNDF_H
 #define LLVM_LIBC_SRC_MATH_LLROUNDF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llroundf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLROUNDF_H
diff --git a/src/math/llroundf128.h b/src/math/llroundf128.h
index 3245dfa..59d4d8d 100644
--- a/src/math/llroundf128.h
+++ b/src/math/llroundf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLROUNDF128_H
 #define LLVM_LIBC_SRC_MATH_LLROUNDF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long long llroundf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLROUNDF128_H
diff --git a/src/math/llroundf16.h b/src/math/llroundf16.h
index 379c454..5ab6f2f 100644
--- a/src/math/llroundf16.h
+++ b/src/math/llroundf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLROUNDF16_H
 #define LLVM_LIBC_SRC_MATH_LLROUNDF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long long llroundf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLROUNDF16_H
diff --git a/src/math/llroundl.h b/src/math/llroundl.h
index 9cb4251..325cac3 100644
--- a/src/math/llroundl.h
+++ b/src/math/llroundl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LLROUNDL_H
 #define LLVM_LIBC_SRC_MATH_LLROUNDL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llroundl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LLROUNDL_H
diff --git a/src/math/log.h b/src/math/log.h
index 67f5d7f..ce6296f 100644
--- a/src/math/log.h
+++ b/src/math/log.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG_H
 #define LLVM_LIBC_SRC_MATH_LOG_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double log(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG_H
diff --git a/src/math/log10.h b/src/math/log10.h
index 3d8249a..025163a 100644
--- a/src/math/log10.h
+++ b/src/math/log10.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG10_H
 #define LLVM_LIBC_SRC_MATH_LOG10_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double log10(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG10_H
diff --git a/src/math/log10f.h b/src/math/log10f.h
index ca3eadc..59a7999 100644
--- a/src/math/log10f.h
+++ b/src/math/log10f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG10F_H
 #define LLVM_LIBC_SRC_MATH_LOG10F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float log10f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG10F_H
diff --git a/src/math/log10f16.h b/src/math/log10f16.h
new file mode 100644
index 0000000..298deb3
--- /dev/null
+++ b/src/math/log10f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for log10f16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_LOG10F16_H
+#define LLVM_LIBC_SRC_MATH_LOG10F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 log10f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_LOG10F16_H
diff --git a/src/math/log1p.h b/src/math/log1p.h
index 48eb9ca..84b3d8f 100644
--- a/src/math/log1p.h
+++ b/src/math/log1p.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG1P_H
 #define LLVM_LIBC_SRC_MATH_LOG1P_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double log1p(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG1P_H
diff --git a/src/math/log1pf.h b/src/math/log1pf.h
index 854f76f..364c1e8 100644
--- a/src/math/log1pf.h
+++ b/src/math/log1pf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG1PF_H
 #define LLVM_LIBC_SRC_MATH_LOG1PF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float log1pf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG1PF_H
diff --git a/src/math/log2.h b/src/math/log2.h
index 49f0549..a278954 100644
--- a/src/math/log2.h
+++ b/src/math/log2.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG2_H
 #define LLVM_LIBC_SRC_MATH_LOG2_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double log2(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG2_H
diff --git a/src/math/log2f.h b/src/math/log2f.h
index 04b7743..dc35c93 100644
--- a/src/math/log2f.h
+++ b/src/math/log2f.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOG2F_H
 #define LLVM_LIBC_SRC_MATH_LOG2F_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float log2f(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOG2F_H
diff --git a/src/math/log2f16.h b/src/math/log2f16.h
new file mode 100644
index 0000000..d89f9f3
--- /dev/null
+++ b/src/math/log2f16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for log2f16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_LOG2F16_H
+#define LLVM_LIBC_SRC_MATH_LOG2F16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 log2f16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_LOG2F16_H
diff --git a/src/math/logb.h b/src/math/logb.h
index e24dd43..13207e2 100644
--- a/src/math/logb.h
+++ b/src/math/logb.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGB_H
 #define LLVM_LIBC_SRC_MATH_LOGB_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double logb(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGB_H
diff --git a/src/math/logbf.h b/src/math/logbf.h
index e8d5018..83e117e 100644
--- a/src/math/logbf.h
+++ b/src/math/logbf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGBF_H
 #define LLVM_LIBC_SRC_MATH_LOGBF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float logbf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGBF_H
diff --git a/src/math/logbf128.h b/src/math/logbf128.h
index 7823bbd..9ce2397 100644
--- a/src/math/logbf128.h
+++ b/src/math/logbf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGBF128_H
 #define LLVM_LIBC_SRC_MATH_LOGBF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 logbf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGBF128_H
diff --git a/src/math/logbf16.h b/src/math/logbf16.h
index 8082e06..f602098 100644
--- a/src/math/logbf16.h
+++ b/src/math/logbf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGBF16_H
 #define LLVM_LIBC_SRC_MATH_LOGBF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 logbf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGBF16_H
diff --git a/src/math/logbl.h b/src/math/logbl.h
index bc32993..02114c4 100644
--- a/src/math/logbl.h
+++ b/src/math/logbl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGBL_H
 #define LLVM_LIBC_SRC_MATH_LOGBL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double logbl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGBL_H
diff --git a/src/math/logf.h b/src/math/logf.h
index b69be46..163f369 100644
--- a/src/math/logf.h
+++ b/src/math/logf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LOGF_H
 #define LLVM_LIBC_SRC_MATH_LOGF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float logf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LOGF_H
diff --git a/src/math/logf16.h b/src/math/logf16.h
new file mode 100644
index 0000000..e2d296b
--- /dev/null
+++ b/src/math/logf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for logf16 ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_LOGF16_H
+#define LLVM_LIBC_SRC_MATH_LOGF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 logf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_LOGF16_H
diff --git a/src/math/lrint.h b/src/math/lrint.h
index e40f860..f8988dc 100644
--- a/src/math/lrint.h
+++ b/src/math/lrint.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LRINT_H
 #define LLVM_LIBC_SRC_MATH_LRINT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lrint(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LRINT_H
diff --git a/src/math/lrintf.h b/src/math/lrintf.h
index 93b2c8c..cbb1818 100644
--- a/src/math/lrintf.h
+++ b/src/math/lrintf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LRINTF_H
 #define LLVM_LIBC_SRC_MATH_LRINTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lrintf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LRINTF_H
diff --git a/src/math/lrintf128.h b/src/math/lrintf128.h
index 8f3f5ce..ae710e9 100644
--- a/src/math/lrintf128.h
+++ b/src/math/lrintf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LRINTF128_H
 #define LLVM_LIBC_SRC_MATH_LRINTF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long lrintf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LRINTF128_H
diff --git a/src/math/lrintf16.h b/src/math/lrintf16.h
index f31fba4..3f2ae90 100644
--- a/src/math/lrintf16.h
+++ b/src/math/lrintf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LRINTF16_H
 #define LLVM_LIBC_SRC_MATH_LRINTF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long lrintf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LRINTF16_H
diff --git a/src/math/lrintl.h b/src/math/lrintl.h
index c17901d..fa6e019 100644
--- a/src/math/lrintl.h
+++ b/src/math/lrintl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LRINTL_H
 #define LLVM_LIBC_SRC_MATH_LRINTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lrintl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LRINTL_H
diff --git a/src/math/lround.h b/src/math/lround.h
index 4a67cc9..951f900 100644
--- a/src/math/lround.h
+++ b/src/math/lround.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LROUND_H
 #define LLVM_LIBC_SRC_MATH_LROUND_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lround(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LROUND_H
diff --git a/src/math/lroundf.h b/src/math/lroundf.h
index 9d4f4e8..9488cc6 100644
--- a/src/math/lroundf.h
+++ b/src/math/lroundf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LROUNDF_H
 #define LLVM_LIBC_SRC_MATH_LROUNDF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lroundf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LROUNDF_H
diff --git a/src/math/lroundf128.h b/src/math/lroundf128.h
index 663b373..4191db5 100644
--- a/src/math/lroundf128.h
+++ b/src/math/lroundf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LROUNDF128_H
 #define LLVM_LIBC_SRC_MATH_LROUNDF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long lroundf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LROUNDF128_H
diff --git a/src/math/lroundf16.h b/src/math/lroundf16.h
index 57201e7..9ad782d 100644
--- a/src/math/lroundf16.h
+++ b/src/math/lroundf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_LROUNDF16_H
 #define LLVM_LIBC_SRC_MATH_LROUNDF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long lroundf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LROUNDF16_H
diff --git a/src/math/lroundl.h b/src/math/lroundl.h
index 86673dc..159c67e 100644
--- a/src/math/lroundl.h
+++ b/src/math/lroundl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_LROUNDL_H
 #define LLVM_LIBC_SRC_MATH_LROUNDL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long lroundl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_LROUNDL_H
diff --git a/src/math/modf.h b/src/math/modf.h
index 91453a0..2c56d59 100644
--- a/src/math/modf.h
+++ b/src/math/modf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_MODF_H
 #define LLVM_LIBC_SRC_MATH_MODF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double modf(double x, double *iptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_MODF_H
diff --git a/src/math/modff.h b/src/math/modff.h
index 85bf2aa..79e7d9b 100644
--- a/src/math/modff.h
+++ b/src/math/modff.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_MODFF_H
 #define LLVM_LIBC_SRC_MATH_MODFF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float modff(float x, float *iptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_MODFF_H
diff --git a/src/math/modff128.h b/src/math/modff128.h
index 48e614b..32c9842 100644
--- a/src/math/modff128.h
+++ b/src/math/modff128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_MODFF128_H
 #define LLVM_LIBC_SRC_MATH_MODFF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 modff128(float128 x, float128 *iptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_MODFF128_H
diff --git a/src/math/modff16.h b/src/math/modff16.h
index a3017c5..ce09744 100644
--- a/src/math/modff16.h
+++ b/src/math/modff16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_MODFF16_H
 #define LLVM_LIBC_SRC_MATH_MODFF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 modff16(float16 x, float16 *iptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_MODFF16_H
diff --git a/src/math/modfl.h b/src/math/modfl.h
index 5ea2c6d..c1e1627 100644
--- a/src/math/modfl.h
+++ b/src/math/modfl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_MODFL_H
 #define LLVM_LIBC_SRC_MATH_MODFL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double modfl(long double x, long double *iptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_MODFL_H
diff --git a/src/math/nan.h b/src/math/nan.h
index 463940b..36fed1b 100644
--- a/src/math/nan.h
+++ b/src/math/nan.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NAN_H
 #define LLVM_LIBC_SRC_MATH_NAN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nan(const char *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NAN_H
diff --git a/src/math/nanf.h b/src/math/nanf.h
index f05d60e..3b72ed2 100644
--- a/src/math/nanf.h
+++ b/src/math/nanf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NANF_H
 #define LLVM_LIBC_SRC_MATH_NANF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nanf(const char *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NANF_H
diff --git a/src/math/nanf128.h b/src/math/nanf128.h
index b06d14e..1c1323a 100644
--- a/src/math/nanf128.h
+++ b/src/math/nanf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NANF128_H
 #define LLVM_LIBC_SRC_MATH_NANF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 nanf128(const char *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NANF128_H
diff --git a/src/math/nanf16.h b/src/math/nanf16.h
index c2db4ba..1721bcc 100644
--- a/src/math/nanf16.h
+++ b/src/math/nanf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NANF16_H
 #define LLVM_LIBC_SRC_MATH_NANF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nanf16(const char *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NANF16_H
diff --git a/src/math/nanl.h b/src/math/nanl.h
index d8bbce7..a4a0377 100644
--- a/src/math/nanl.h
+++ b/src/math/nanl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NANL_H
 #define LLVM_LIBC_SRC_MATH_NANL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nanl(const char *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NANL_H
diff --git a/src/math/nearbyint.h b/src/math/nearbyint.h
index df292a2..469bd99 100644
--- a/src/math/nearbyint.h
+++ b/src/math/nearbyint.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEARBYINT_H
 #define LLVM_LIBC_SRC_MATH_NEARBYINT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nearbyint(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEARBYINT_H
diff --git a/src/math/nearbyintf.h b/src/math/nearbyintf.h
index 3860dc0..d89a762 100644
--- a/src/math/nearbyintf.h
+++ b/src/math/nearbyintf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEARBYINTF_H
 #define LLVM_LIBC_SRC_MATH_NEARBYINTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nearbyintf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEARBYINTF_H
diff --git a/src/math/nearbyintf128.h b/src/math/nearbyintf128.h
index d12754a..9c4fdd5 100644
--- a/src/math/nearbyintf128.h
+++ b/src/math/nearbyintf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEARBYINTF128_H
 #define LLVM_LIBC_SRC_MATH_NEARBYINTF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 nearbyintf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEARBYINTF128_H
diff --git a/src/math/nearbyintf16.h b/src/math/nearbyintf16.h
index 3e6f3fb..2241e43 100644
--- a/src/math/nearbyintf16.h
+++ b/src/math/nearbyintf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEARBYINTF16_H
 #define LLVM_LIBC_SRC_MATH_NEARBYINTF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nearbyintf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEARBYINTF16_H
diff --git a/src/math/nearbyintl.h b/src/math/nearbyintl.h
index e22cae6..3fed5d8 100644
--- a/src/math/nearbyintl.h
+++ b/src/math/nearbyintl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEARBYINTL_H
 #define LLVM_LIBC_SRC_MATH_NEARBYINTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nearbyintl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEARBYINTL_H
diff --git a/src/math/nextafter.h b/src/math/nextafter.h
index fc4c9eb..636dbd5 100644
--- a/src/math/nextafter.h
+++ b/src/math/nextafter.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTAFTER_H
 #define LLVM_LIBC_SRC_MATH_NEXTAFTER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nextafter(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTAFTER_H
diff --git a/src/math/nextafterf.h b/src/math/nextafterf.h
index de7870d..70ab76e 100644
--- a/src/math/nextafterf.h
+++ b/src/math/nextafterf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTAFTERF_H
 #define LLVM_LIBC_SRC_MATH_NEXTAFTERF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nextafterf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTAFTERF_H
diff --git a/src/math/nextafterf128.h b/src/math/nextafterf128.h
index a404d33..99b15d6 100644
--- a/src/math/nextafterf128.h
+++ b/src/math/nextafterf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTAFTERF128_H
 #define LLVM_LIBC_SRC_MATH_NEXTAFTERF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 nextafterf128(float128 x, float128 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTAFTERF128_H
diff --git a/src/math/nextafterf16.h b/src/math/nextafterf16.h
index 293569e..ab4e0fd 100644
--- a/src/math/nextafterf16.h
+++ b/src/math/nextafterf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTAFTERF16_H
 #define LLVM_LIBC_SRC_MATH_NEXTAFTERF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nextafterf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTAFTERF16_H
diff --git a/src/math/nextafterl.h b/src/math/nextafterl.h
index 1b94e24..a697f79 100644
--- a/src/math/nextafterl.h
+++ b/src/math/nextafterl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTAFTERL_H
 #define LLVM_LIBC_SRC_MATH_NEXTAFTERL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nextafterl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTAFTERL_H
diff --git a/src/math/nextdown.h b/src/math/nextdown.h
index 8049b17..21f33e3 100644
--- a/src/math/nextdown.h
+++ b/src/math/nextdown.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTDOWN_H
 #define LLVM_LIBC_SRC_MATH_NEXTDOWN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nextdown(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTDOWN_H
diff --git a/src/math/nextdownf.h b/src/math/nextdownf.h
index 0a2f234..f689287 100644
--- a/src/math/nextdownf.h
+++ b/src/math/nextdownf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTDOWNF_H
 #define LLVM_LIBC_SRC_MATH_NEXTDOWNF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nextdownf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTDOWNF_H
diff --git a/src/math/nextdownf128.h b/src/math/nextdownf128.h
index 0a3043b..60ba251 100644
--- a/src/math/nextdownf128.h
+++ b/src/math/nextdownf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTDOWNF128_H
 #define LLVM_LIBC_SRC_MATH_NEXTDOWNF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 nextdownf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTDOWNF128_H
diff --git a/src/math/nextdownf16.h b/src/math/nextdownf16.h
index 1913757..5183db2 100644
--- a/src/math/nextdownf16.h
+++ b/src/math/nextdownf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTDOWNF16_H
 #define LLVM_LIBC_SRC_MATH_NEXTDOWNF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nextdownf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTDOWNF16_H
diff --git a/src/math/nextdownl.h b/src/math/nextdownl.h
index 9cb274a..5815579 100644
--- a/src/math/nextdownl.h
+++ b/src/math/nextdownl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTDOWNL_H
 #define LLVM_LIBC_SRC_MATH_NEXTDOWNL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nextdownl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTDOWNL_H
diff --git a/src/math/nexttoward.h b/src/math/nexttoward.h
index 6a5bece..cfa6af9 100644
--- a/src/math/nexttoward.h
+++ b/src/math/nexttoward.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTTOWARD_H
 #define LLVM_LIBC_SRC_MATH_NEXTTOWARD_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nexttoward(double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTTOWARD_H
diff --git a/src/math/nexttowardf.h b/src/math/nexttowardf.h
index 7a0eb2a..ee34548 100644
--- a/src/math/nexttowardf.h
+++ b/src/math/nexttowardf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTTOWARDF_H
 #define LLVM_LIBC_SRC_MATH_NEXTTOWARDF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nexttowardf(float x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTTOWARDF_H
diff --git a/src/math/nexttowardf16.h b/src/math/nexttowardf16.h
index 604eb32..5975926 100644
--- a/src/math/nexttowardf16.h
+++ b/src/math/nexttowardf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTTOWARDF16_H
 #define LLVM_LIBC_SRC_MATH_NEXTTOWARDF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nexttowardf16(float16 x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTTOWARDF16_H
diff --git a/src/math/nexttowardl.h b/src/math/nexttowardl.h
index be1d8b2..180ffb5 100644
--- a/src/math/nexttowardl.h
+++ b/src/math/nexttowardl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTTOWARDL_H
 #define LLVM_LIBC_SRC_MATH_NEXTTOWARDL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nexttowardl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTTOWARDL_H
diff --git a/src/math/nextup.h b/src/math/nextup.h
index 97ae822..37b81fd 100644
--- a/src/math/nextup.h
+++ b/src/math/nextup.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTUP_H
 #define LLVM_LIBC_SRC_MATH_NEXTUP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double nextup(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTUP_H
diff --git a/src/math/nextupf.h b/src/math/nextupf.h
index ffc0fa1..9963dbd 100644
--- a/src/math/nextupf.h
+++ b/src/math/nextupf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTUPF_H
 #define LLVM_LIBC_SRC_MATH_NEXTUPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float nextupf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTUPF_H
diff --git a/src/math/nextupf128.h b/src/math/nextupf128.h
index b442992..755c08d 100644
--- a/src/math/nextupf128.h
+++ b/src/math/nextupf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTUPF128_H
 #define LLVM_LIBC_SRC_MATH_NEXTUPF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 nextupf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTUPF128_H
diff --git a/src/math/nextupf16.h b/src/math/nextupf16.h
index b2973e4..d80a105 100644
--- a/src/math/nextupf16.h
+++ b/src/math/nextupf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTUPF16_H
 #define LLVM_LIBC_SRC_MATH_NEXTUPF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 nextupf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTUPF16_H
diff --git a/src/math/nextupl.h b/src/math/nextupl.h
index cbc6a16..d9c5c52 100644
--- a/src/math/nextupl.h
+++ b/src/math/nextupl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_NEXTUPL_H
 #define LLVM_LIBC_SRC_MATH_NEXTUPL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double nextupl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NEXTUPL_H
diff --git a/src/math/nvptx/acos.cpp b/src/math/nvptx/acos.cpp
index da2c795..7049f9f 100644
--- a/src/math/nvptx/acos.cpp
+++ b/src/math/nvptx/acos.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, acos, (double x)) { return __nv_acos(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/acosf.cpp b/src/math/nvptx/acosf.cpp
index 8a4125f..cf70a0f 100644
--- a/src/math/nvptx/acosf.cpp
+++ b/src/math/nvptx/acosf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, acosf, (float x)) { return __nv_acosf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/acosh.cpp b/src/math/nvptx/acosh.cpp
index 06f6e29..2628aa9 100644
--- a/src/math/nvptx/acosh.cpp
+++ b/src/math/nvptx/acosh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, acosh, (double x)) { return __nv_acosh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/acoshf.cpp b/src/math/nvptx/acoshf.cpp
index 00e8053..b8f57fd 100644
--- a/src/math/nvptx/acoshf.cpp
+++ b/src/math/nvptx/acoshf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, acoshf, (float x)) { return __nv_acoshf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/asin.cpp b/src/math/nvptx/asin.cpp
index 74d92fd..417b67a 100644
--- a/src/math/nvptx/asin.cpp
+++ b/src/math/nvptx/asin.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, asin, (double x)) { return __nv_asin(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/asinf.cpp b/src/math/nvptx/asinf.cpp
index 30544bc..ea819bd 100644
--- a/src/math/nvptx/asinf.cpp
+++ b/src/math/nvptx/asinf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, asinf, (float x)) { return __nv_asinf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/asinh.cpp b/src/math/nvptx/asinh.cpp
index 0e5dbb4..49dcd22 100644
--- a/src/math/nvptx/asinh.cpp
+++ b/src/math/nvptx/asinh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, asinh, (double x)) { return __nv_asinh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/asinhf.cpp b/src/math/nvptx/asinhf.cpp
index 6648108..af8afe7 100644
--- a/src/math/nvptx/asinhf.cpp
+++ b/src/math/nvptx/asinhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, asinhf, (float x)) { return __nv_asinhf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atan.cpp b/src/math/nvptx/atan.cpp
index 3af793a..e94ef57 100644
--- a/src/math/nvptx/atan.cpp
+++ b/src/math/nvptx/atan.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atan, (double x)) { return __nv_atan(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atan2.cpp b/src/math/nvptx/atan2.cpp
index 0c54e0e..d12c4cb 100644
--- a/src/math/nvptx/atan2.cpp
+++ b/src/math/nvptx/atan2.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atan2, (double x, double y)) {
   return __nv_atan2(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atan2f.cpp b/src/math/nvptx/atan2f.cpp
index c3327d9..f39f322 100644
--- a/src/math/nvptx/atan2f.cpp
+++ b/src/math/nvptx/atan2f.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atan2f, (float x, float y)) {
   return __nv_atan2f(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atanf.cpp b/src/math/nvptx/atanf.cpp
index 5595262..f66ade7 100644
--- a/src/math/nvptx/atanf.cpp
+++ b/src/math/nvptx/atanf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanf, (float x)) { return __nv_atanf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atanh.cpp b/src/math/nvptx/atanh.cpp
index 6699d95..a206d51 100644
--- a/src/math/nvptx/atanh.cpp
+++ b/src/math/nvptx/atanh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atanh, (double x)) { return __nv_atanh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/atanhf.cpp b/src/math/nvptx/atanhf.cpp
index 526b7b3..06f6883 100644
--- a/src/math/nvptx/atanhf.cpp
+++ b/src/math/nvptx/atanhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, atanhf, (float x)) { return __nv_atanhf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ceil.cpp b/src/math/nvptx/ceil.cpp
index ad1407d..8834c7b 100644
--- a/src/math/nvptx/ceil.cpp
+++ b/src/math/nvptx/ceil.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/ceil.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ceil, (double x)) { return __builtin_ceil(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ceilf.cpp b/src/math/nvptx/ceilf.cpp
index c4fc58d..5d26a30 100644
--- a/src/math/nvptx/ceilf.cpp
+++ b/src/math/nvptx/ceilf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/ceilf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ceilf, (float x)) { return __builtin_ceilf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/copysign.cpp b/src/math/nvptx/copysign.cpp
index 6f804bd..06ef36f 100644
--- a/src/math/nvptx/copysign.cpp
+++ b/src/math/nvptx/copysign.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/copysign.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, copysign, (double x, double y)) {
   return __builtin_copysign(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/copysignf.cpp b/src/math/nvptx/copysignf.cpp
index 4d7e132..aea94f3 100644
--- a/src/math/nvptx/copysignf.cpp
+++ b/src/math/nvptx/copysignf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/copysignf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, copysignf, (float x, float y)) {
   return __builtin_copysignf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/cos.cpp b/src/math/nvptx/cos.cpp
index 185ad3c..873fd50 100644
--- a/src/math/nvptx/cos.cpp
+++ b/src/math/nvptx/cos.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, cos, (double x)) { return __nv_cos(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/cosf.cpp b/src/math/nvptx/cosf.cpp
index 3d34de4..82b3bb7 100644
--- a/src/math/nvptx/cosf.cpp
+++ b/src/math/nvptx/cosf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, cosf, (float x)) { return __nv_cosf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/cosh.cpp b/src/math/nvptx/cosh.cpp
index 179864c..434e8c5 100644
--- a/src/math/nvptx/cosh.cpp
+++ b/src/math/nvptx/cosh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, cosh, (double x)) { return __nv_cosh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/coshf.cpp b/src/math/nvptx/coshf.cpp
index 9147499..87d6b16 100644
--- a/src/math/nvptx/coshf.cpp
+++ b/src/math/nvptx/coshf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, coshf, (float x)) { return __nv_coshf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/declarations.h b/src/math/nvptx/declarations.h
index d41b16c..6f0bcfe 100644
--- a/src/math/nvptx/declarations.h
+++ b/src/math/nvptx/declarations.h
@@ -9,7 +9,9 @@
 #ifndef LLVM_LIBC_SRC_MATH_NVPTX_DECLARATIONS_H
 #define LLVM_LIBC_SRC_MATH_NVPTX_DECLARATIONS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 extern "C" {
 double __nv_acos(double);
@@ -64,6 +66,8 @@ double __nv_nextafter(double, double);
 float __nv_nextafterf(float, float);
 double __nv_pow(double, double);
 float __nv_powf(float, float);
+double __nv_powi(double, int);
+float __nv_powif(float, int);
 double __nv_sin(double);
 float __nv_sinf(float);
 void __nv_sincos(double, double *, double *);
@@ -82,8 +86,9 @@ double __nv_remquo(double, double, int *);
 float __nv_remquof(float, float, int *);
 double __nv_tgamma(double);
 float __nv_tgammaf(float);
+float __nv_lgamma(double);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NVPTX_DECLARATIONS_H
diff --git a/src/math/nvptx/erf.cpp b/src/math/nvptx/erf.cpp
index 5ea0177..c7ca7d4 100644
--- a/src/math/nvptx/erf.cpp
+++ b/src/math/nvptx/erf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, erf, (double x)) { return __nv_erf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/erff.cpp b/src/math/nvptx/erff.cpp
index 03fdcea..1c64e07 100644
--- a/src/math/nvptx/erff.cpp
+++ b/src/math/nvptx/erff.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, erff, (float x)) { return __nv_erff(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/exp.cpp b/src/math/nvptx/exp.cpp
index 6bbe87b..dcbadcf 100644
--- a/src/math/nvptx/exp.cpp
+++ b/src/math/nvptx/exp.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp, (double x)) { return __nv_exp(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/exp10.cpp b/src/math/nvptx/exp10.cpp
index 11bb734..0972a3c 100644
--- a/src/math/nvptx/exp10.cpp
+++ b/src/math/nvptx/exp10.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp10, (double x)) { return __nv_exp10(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/exp10f.cpp b/src/math/nvptx/exp10f.cpp
index 4e3121a..0709771 100644
--- a/src/math/nvptx/exp10f.cpp
+++ b/src/math/nvptx/exp10f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp10f, (float x)) { return __nv_exp10f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/exp2.cpp b/src/math/nvptx/exp2.cpp
index 35fc27b..3465e5b 100644
--- a/src/math/nvptx/exp2.cpp
+++ b/src/math/nvptx/exp2.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, exp2, (double x)) { return __nv_exp2(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/exp2f.cpp b/src/math/nvptx/exp2f.cpp
index 8d13734..0525764 100644
--- a/src/math/nvptx/exp2f.cpp
+++ b/src/math/nvptx/exp2f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, exp2f, (float x)) { return __nv_exp2f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/expf.cpp b/src/math/nvptx/expf.cpp
index a6362bd..2b802e5 100644
--- a/src/math/nvptx/expf.cpp
+++ b/src/math/nvptx/expf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expf, (float x)) { return __nv_expf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/expm1.cpp b/src/math/nvptx/expm1.cpp
index 0331903..91845cf 100644
--- a/src/math/nvptx/expm1.cpp
+++ b/src/math/nvptx/expm1.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, expm1, (double x)) { return __nv_expm1(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/expm1f.cpp b/src/math/nvptx/expm1f.cpp
index 7b74c54..31e67af 100644
--- a/src/math/nvptx/expm1f.cpp
+++ b/src/math/nvptx/expm1f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, expm1f, (float x)) { return __nv_expm1f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fabs.cpp b/src/math/nvptx/fabs.cpp
index c0d063d..bb37596 100644
--- a/src/math/nvptx/fabs.cpp
+++ b/src/math/nvptx/fabs.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/fabs.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fabs, (double x)) { return __builtin_fabs(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fabsf.cpp b/src/math/nvptx/fabsf.cpp
index 398ffd0..2698618 100644
--- a/src/math/nvptx/fabsf.cpp
+++ b/src/math/nvptx/fabsf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/fabsf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fabsf, (float x)) { return __builtin_fabsf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fdim.cpp b/src/math/nvptx/fdim.cpp
index 2f1ff51..edf4009 100644
--- a/src/math/nvptx/fdim.cpp
+++ b/src/math/nvptx/fdim.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fdim, (double x, double y)) {
   return __nv_fdim(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fdimf.cpp b/src/math/nvptx/fdimf.cpp
index c24e6be..017143a 100644
--- a/src/math/nvptx/fdimf.cpp
+++ b/src/math/nvptx/fdimf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fdimf, (float x, float y)) {
   return __nv_fdimf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/floor.cpp b/src/math/nvptx/floor.cpp
index eada89c..564efa9 100644
--- a/src/math/nvptx/floor.cpp
+++ b/src/math/nvptx/floor.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/floor.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, floor, (double x)) { return __builtin_floor(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/floorf.cpp b/src/math/nvptx/floorf.cpp
index a5611c5..6717c8f 100644
--- a/src/math/nvptx/floorf.cpp
+++ b/src/math/nvptx/floorf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/floorf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, floorf, (float x)) { return __builtin_floorf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fma.cpp b/src/math/nvptx/fma.cpp
index 41a6ddf..c4a117e 100644
--- a/src/math/nvptx/fma.cpp
+++ b/src/math/nvptx/fma.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fma.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fma, (double x, double y, double z)) {
   return __builtin_fma(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmaf.cpp b/src/math/nvptx/fmaf.cpp
index c948e32..c088bd5 100644
--- a/src/math/nvptx/fmaf.cpp
+++ b/src/math/nvptx/fmaf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmaf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaf, (float x, float y, float z)) {
   return __builtin_fmaf(x, y, z);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmax.cpp b/src/math/nvptx/fmax.cpp
index 3ba65d7..a2496fe 100644
--- a/src/math/nvptx/fmax.cpp
+++ b/src/math/nvptx/fmax.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmax.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmax, (double x, double y)) {
   return __builtin_fmax(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmaxf.cpp b/src/math/nvptx/fmaxf.cpp
index e977082..586fd32 100644
--- a/src/math/nvptx/fmaxf.cpp
+++ b/src/math/nvptx/fmaxf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmaxf, (float x, float y)) {
   return __builtin_fmaxf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmin.cpp b/src/math/nvptx/fmin.cpp
index 0d6f352..694eb66 100644
--- a/src/math/nvptx/fmin.cpp
+++ b/src/math/nvptx/fmin.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fmin.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmin, (double x, double y)) {
   return __builtin_fmin(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fminf.cpp b/src/math/nvptx/fminf.cpp
index 42744ab..2060b71 100644
--- a/src/math/nvptx/fminf.cpp
+++ b/src/math/nvptx/fminf.cpp
@@ -9,11 +9,12 @@
 #include "src/math/fminf.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fminf, (float x, float y)) {
   return __builtin_fminf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmod.cpp b/src/math/nvptx/fmod.cpp
index 0654cdd..49d19c4 100644
--- a/src/math/nvptx/fmod.cpp
+++ b/src/math/nvptx/fmod.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, fmod, (double x, double y)) {
   return __builtin_fmod(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/fmodf.cpp b/src/math/nvptx/fmodf.cpp
index b689046..8fbcb0c 100644
--- a/src/math/nvptx/fmodf.cpp
+++ b/src/math/nvptx/fmodf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/fmodf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, fmodf, (float x, float y)) {
   return __builtin_fmodf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/frexp.cpp b/src/math/nvptx/frexp.cpp
index 2423961..edba8d7 100644
--- a/src/math/nvptx/frexp.cpp
+++ b/src/math/nvptx/frexp.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, frexp, (double x, int *p)) {
   return __nv_frexp(x, p);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/frexpf.cpp b/src/math/nvptx/frexpf.cpp
index f1ea290..0461941 100644
--- a/src/math/nvptx/frexpf.cpp
+++ b/src/math/nvptx/frexpf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, frexpf, (float x, int *p)) {
   return __nv_frexpf(x, p);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/hypot.cpp b/src/math/nvptx/hypot.cpp
index 28bf04a..a7bacd6 100644
--- a/src/math/nvptx/hypot.cpp
+++ b/src/math/nvptx/hypot.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, hypot, (double x, double y)) {
   return __nv_hypot(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/hypotf.cpp b/src/math/nvptx/hypotf.cpp
index c506aab..49e85a1 100644
--- a/src/math/nvptx/hypotf.cpp
+++ b/src/math/nvptx/hypotf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, hypotf, (float x, float y)) {
   return __nv_hypotf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ilogb.cpp b/src/math/nvptx/ilogb.cpp
index fc75e2f..3d552c2 100644
--- a/src/math/nvptx/ilogb.cpp
+++ b/src/math/nvptx/ilogb.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogb, (double x)) { return __nv_ilogb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ilogbf.cpp b/src/math/nvptx/ilogbf.cpp
index 3d14fcf..a78926f 100644
--- a/src/math/nvptx/ilogbf.cpp
+++ b/src/math/nvptx/ilogbf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ilogbf, (float x)) { return __nv_ilogbf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ldexp.cpp b/src/math/nvptx/ldexp.cpp
index 761dc48..0adc7c3 100644
--- a/src/math/nvptx/ldexp.cpp
+++ b/src/math/nvptx/ldexp.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, ldexp, (double x, int y)) {
   return __nv_ldexp(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/ldexpf.cpp b/src/math/nvptx/ldexpf.cpp
index 2d4c556..eb7dd42 100644
--- a/src/math/nvptx/ldexpf.cpp
+++ b/src/math/nvptx/ldexpf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, ldexpf, (float x, int y)) {
   return __nv_ldexpf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/amdgpu/pow.cpp b/src/math/nvptx/lgamma.cpp
similarity index 57%
rename from src/math/amdgpu/pow.cpp
rename to src/math/nvptx/lgamma.cpp
index e5056f6..0447a97 100644
--- a/src/math/amdgpu/pow.cpp
+++ b/src/math/nvptx/lgamma.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the pow function for GPU ------------------------===//
+//===-- Implementation of the lgamma function for GPU ---------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,15 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/pow.h"
+#include "src/math/lgamma.h"
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, pow, (double x, double y)) {
-  return __ocml_pow_f64(x, y);
-}
+LLVM_LIBC_FUNCTION(double, lgamma, (double x)) { return __nv_lgamma(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/lgamma_r.cpp b/src/math/nvptx/lgamma_r.cpp
new file mode 100644
index 0000000..85f66c8
--- /dev/null
+++ b/src/math/nvptx/lgamma_r.cpp
@@ -0,0 +1,23 @@
+//===-- Implementation of the lgamma_r function for GPU -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/lgamma_r.h"
+#include "src/__support/common.h"
+
+#include "declarations.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, lgamma_r, (double x, int *signp)) {
+  double result = __nv_lgamma(x);
+  *signp = (result < 0.0) ? -1 : 1;
+  return result;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/llrint.cpp b/src/math/nvptx/llrint.cpp
index 8f95e75..21129fe 100644
--- a/src/math/nvptx/llrint.cpp
+++ b/src/math/nvptx/llrint.cpp
@@ -10,9 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(long long, llrint, (double x)) { return __nv_llrint(x); }
+LLVM_LIBC_FUNCTION(long long, llrint, (double x)) {
+  return static_cast<long long>(__builtin_rint(x));
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/llrintf.cpp b/src/math/nvptx/llrintf.cpp
index 1432ffb..a6f9f43 100644
--- a/src/math/nvptx/llrintf.cpp
+++ b/src/math/nvptx/llrintf.cpp
@@ -10,9 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(long long, llrintf, (float x)) { return __nv_llrintf(x); }
+LLVM_LIBC_FUNCTION(long long, llrintf, (float x)) {
+  return static_cast<long long>(__builtin_rintf(x));
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log.cpp b/src/math/nvptx/log.cpp
index 26b6dfa..fd556ac 100644
--- a/src/math/nvptx/log.cpp
+++ b/src/math/nvptx/log.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log, (double x)) { return __nv_log(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log10.cpp b/src/math/nvptx/log10.cpp
index ff27025..fbbf214 100644
--- a/src/math/nvptx/log10.cpp
+++ b/src/math/nvptx/log10.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log10, (double x)) { return __nv_log10(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log10f.cpp b/src/math/nvptx/log10f.cpp
index af903b6..c2f24df 100644
--- a/src/math/nvptx/log10f.cpp
+++ b/src/math/nvptx/log10f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log10f, (float x)) { return __nv_log10f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log1p.cpp b/src/math/nvptx/log1p.cpp
index 47bc96b..2ffd0fe 100644
--- a/src/math/nvptx/log1p.cpp
+++ b/src/math/nvptx/log1p.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log1p, (double x)) { return __nv_log1p(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log1pf.cpp b/src/math/nvptx/log1pf.cpp
index bfa4f7f..2de4f27 100644
--- a/src/math/nvptx/log1pf.cpp
+++ b/src/math/nvptx/log1pf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log1pf, (float x)) { return __nv_log1pf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log2.cpp b/src/math/nvptx/log2.cpp
index 86a980d..54e2da0 100644
--- a/src/math/nvptx/log2.cpp
+++ b/src/math/nvptx/log2.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, log2, (double x)) { return __nv_log2(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/log2f.cpp b/src/math/nvptx/log2f.cpp
index 5ce4629..c2a6054 100644
--- a/src/math/nvptx/log2f.cpp
+++ b/src/math/nvptx/log2f.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, log2f, (float x)) { return __nv_log2f(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/logb.cpp b/src/math/nvptx/logb.cpp
index b620b16..f6998bd 100644
--- a/src/math/nvptx/logb.cpp
+++ b/src/math/nvptx/logb.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, logb, (double x)) { return __nv_logb(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/logbf.cpp b/src/math/nvptx/logbf.cpp
index f19f032..f72c04f 100644
--- a/src/math/nvptx/logbf.cpp
+++ b/src/math/nvptx/logbf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logbf, (float x)) { return __nv_logbf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/logf.cpp b/src/math/nvptx/logf.cpp
index 6deb482..1a5bc1e 100644
--- a/src/math/nvptx/logf.cpp
+++ b/src/math/nvptx/logf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, logf, (float x)) { return __nv_logf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/lrint.cpp b/src/math/nvptx/lrint.cpp
index 8585f4c..715b552 100644
--- a/src/math/nvptx/lrint.cpp
+++ b/src/math/nvptx/lrint.cpp
@@ -10,9 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(long, lrint, (double x)) { return __nv_lrint(x); }
+LLVM_LIBC_FUNCTION(long, lrint, (double x)) {
+  return static_cast<long>(__builtin_rint(x));
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/lrintf.cpp b/src/math/nvptx/lrintf.cpp
index 312a946..3ed05f6 100644
--- a/src/math/nvptx/lrintf.cpp
+++ b/src/math/nvptx/lrintf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, lrintf, (float x)) { return __nv_lrintf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/nearbyint.cpp b/src/math/nvptx/nearbyint.cpp
index 9c7b600..7d78c72 100644
--- a/src/math/nvptx/nearbyint.cpp
+++ b/src/math/nvptx/nearbyint.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/nearbyint.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nearbyint, (double x)) {
   return __builtin_nearbyint(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/nearbyintf.cpp b/src/math/nvptx/nearbyintf.cpp
index 7fbe9f4..4bd20dc 100644
--- a/src/math/nvptx/nearbyintf.cpp
+++ b/src/math/nvptx/nearbyintf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/nearbyintf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nearbyintf, (float x)) {
   return __builtin_nearbyintf(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/nextafter.cpp b/src/math/nvptx/nextafter.cpp
index 171aaad..3dc9100 100644
--- a/src/math/nvptx/nextafter.cpp
+++ b/src/math/nvptx/nextafter.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, nextafter, (double x, double y)) {
   return __nv_nextafter(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/nextafterf.cpp b/src/math/nvptx/nextafterf.cpp
index a45937c..162b85e 100644
--- a/src/math/nvptx/nextafterf.cpp
+++ b/src/math/nvptx/nextafterf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, nextafterf, (float x, float y)) {
   return __nv_nextafterf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/nvptx.h b/src/math/nvptx/nvptx.h
index 5f9b32f..2035b76 100644
--- a/src/math/nvptx/nvptx.h
+++ b/src/math/nvptx/nvptx.h
@@ -12,8 +12,9 @@
 #include "declarations.h"
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 LIBC_INLINE double acos(double x) { return __nv_acos(x); }
 LIBC_INLINE float acosf(float x) { return __nv_acosf(x); }
@@ -97,6 +98,6 @@ LIBC_INLINE double tgamma(double x) { return __nv_tgamma(x); }
 LIBC_INLINE float tgammaf(float x) { return __nv_tgammaf(x); }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_NVPTX_NVPTX_H
diff --git a/src/math/nvptx/powf.cpp b/src/math/nvptx/powf.cpp
index f9f7dba..9c577c7 100644
--- a/src/math/nvptx/powf.cpp
+++ b/src/math/nvptx/powf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) { return __nv_powf(x, y); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/pow.cpp b/src/math/nvptx/powi.cpp
similarity index 57%
rename from src/math/nvptx/pow.cpp
rename to src/math/nvptx/powi.cpp
index 7de3c9e..16214bd 100644
--- a/src/math/nvptx/pow.cpp
+++ b/src/math/nvptx/powi.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the pow function for GPU ------------------------===//
+//===-- Implementation of the powi function for GPU -----------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,13 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/pow.h"
+#include "src/math/powi.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include "declarations.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(double, pow, (double x, double y)) { return __nv_pow(x, y); }
+LLVM_LIBC_FUNCTION(double, powi, (double x, int y)) { return __nv_powi(x, y); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/aarch64/ceil.cpp b/src/math/nvptx/powif.cpp
similarity index 52%
rename from src/math/aarch64/ceil.cpp
rename to src/math/nvptx/powif.cpp
index 81cd950..5d26fdc 100644
--- a/src/math/aarch64/ceil.cpp
+++ b/src/math/nvptx/powif.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of the ceil function for aarch64 -------------------===//
+//===-- Implementation of the powif function for GPU ----------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,15 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/math/ceil.h"
+#include "src/math/powif.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+#include "declarations.h"
 
-LLVM_LIBC_FUNCTION(double, ceil, (double x)) {
-  double y;
-  __asm__ __volatile__("frintp %d0, %d1\n\t" : "=w"(y) : "w"(x));
-  return y;
-}
+namespace LIBC_NAMESPACE_DECL {
 
-} // namespace LIBC_NAMESPACE
+LLVM_LIBC_FUNCTION(float, powif, (float x, int y)) { return __nv_powif(x, y); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/remainder.cpp b/src/math/nvptx/remainder.cpp
index 89b235f..9027204 100644
--- a/src/math/nvptx/remainder.cpp
+++ b/src/math/nvptx/remainder.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/remainder.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remainder, (double x, double y)) {
   return __builtin_remainder(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/remainderf.cpp b/src/math/nvptx/remainderf.cpp
index 9fee6f8..50df3b2 100644
--- a/src/math/nvptx/remainderf.cpp
+++ b/src/math/nvptx/remainderf.cpp
@@ -8,11 +8,12 @@
 
 #include "src/math/remainderf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remainderf, (float x, float y)) {
   return __builtin_remainderf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/remquo.cpp b/src/math/nvptx/remquo.cpp
index da69a20..aae1831 100644
--- a/src/math/nvptx/remquo.cpp
+++ b/src/math/nvptx/remquo.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, remquo, (double x, double y, int *quo)) {
   return __nv_remquo(x, y, quo);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/remquof.cpp b/src/math/nvptx/remquof.cpp
index dcfba5d..d7ce3c0 100644
--- a/src/math/nvptx/remquof.cpp
+++ b/src/math/nvptx/remquof.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, remquof, (float x, float y, int *quo)) {
   return __nv_remquof(x, y, quo);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/rint.cpp b/src/math/nvptx/rint.cpp
index 44d494a..ac6837a 100644
--- a/src/math/nvptx/rint.cpp
+++ b/src/math/nvptx/rint.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/rint.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, rint, (double x)) { return __builtin_rint(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/rintf.cpp b/src/math/nvptx/rintf.cpp
index daf98d9..9409347 100644
--- a/src/math/nvptx/rintf.cpp
+++ b/src/math/nvptx/rintf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/rintf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, rintf, (float x)) { return __builtin_rintf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/round.cpp b/src/math/nvptx/round.cpp
index 9d8b558..0d2765f 100644
--- a/src/math/nvptx/round.cpp
+++ b/src/math/nvptx/round.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/round.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, round, (double x)) { return __builtin_round(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/roundf.cpp b/src/math/nvptx/roundf.cpp
index 8743e4e..86e8ba3 100644
--- a/src/math/nvptx/roundf.cpp
+++ b/src/math/nvptx/roundf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/roundf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, roundf, (float x)) { return __builtin_roundf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/scalbn.cpp b/src/math/nvptx/scalbn.cpp
index 80374db..ecadc34 100644
--- a/src/math/nvptx/scalbn.cpp
+++ b/src/math/nvptx/scalbn.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, scalbn, (double x, int y)) {
   return __nv_scalbn(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/scalbnf.cpp b/src/math/nvptx/scalbnf.cpp
index 24fa3a5..35ff699 100644
--- a/src/math/nvptx/scalbnf.cpp
+++ b/src/math/nvptx/scalbnf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, scalbnf, (float x, int y)) {
   return __nv_scalbnf(x, y);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sin.cpp b/src/math/nvptx/sin.cpp
index 1bff129..0e86f9c 100644
--- a/src/math/nvptx/sin.cpp
+++ b/src/math/nvptx/sin.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sin, (double x)) { return __nv_sin(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sincos.cpp b/src/math/nvptx/sincos.cpp
index 73f92cf..5a77234 100644
--- a/src/math/nvptx/sincos.cpp
+++ b/src/math/nvptx/sincos.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, sincos, (double x, double *sinptr, double *cosptr)) {
   return __nv_sincos(x, sinptr, cosptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sincosf.cpp b/src/math/nvptx/sincosf.cpp
index d053aa3..e4039ad 100644
--- a/src/math/nvptx/sincosf.cpp
+++ b/src/math/nvptx/sincosf.cpp
@@ -10,11 +10,12 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinptr, float *cosptr)) {
   return __nv_sincosf(x, sinptr, cosptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sinf.cpp b/src/math/nvptx/sinf.cpp
index 9abd5cb..14e722f 100644
--- a/src/math/nvptx/sinf.cpp
+++ b/src/math/nvptx/sinf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinf, (float x)) { return __nv_sinf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sinh.cpp b/src/math/nvptx/sinh.cpp
index dc6a1e1..701811d 100644
--- a/src/math/nvptx/sinh.cpp
+++ b/src/math/nvptx/sinh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sinh, (double x)) { return __nv_sinh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sinhf.cpp b/src/math/nvptx/sinhf.cpp
index c9ab470..2c6ac21 100644
--- a/src/math/nvptx/sinhf.cpp
+++ b/src/math/nvptx/sinhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sinhf, (float x)) { return __nv_sinhf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sqrt.cpp b/src/math/nvptx/sqrt.cpp
index 60ca5af..ed83b6e 100644
--- a/src/math/nvptx/sqrt.cpp
+++ b/src/math/nvptx/sqrt.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/sqrt.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, sqrt, (double x)) { return __builtin_sqrt(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/sqrtf.cpp b/src/math/nvptx/sqrtf.cpp
index e17f942..851922c 100644
--- a/src/math/nvptx/sqrtf.cpp
+++ b/src/math/nvptx/sqrtf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/sqrtf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, sqrtf, (float x)) { return __builtin_sqrtf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tan.cpp b/src/math/nvptx/tan.cpp
index deb03dc..2d3f1fe 100644
--- a/src/math/nvptx/tan.cpp
+++ b/src/math/nvptx/tan.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tan, (double x)) { return __nv_tan(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tanf.cpp b/src/math/nvptx/tanf.cpp
index 5739e4a..bdf51d9 100644
--- a/src/math/nvptx/tanf.cpp
+++ b/src/math/nvptx/tanf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tanf, (float x)) { return __nv_tanf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tanh.cpp b/src/math/nvptx/tanh.cpp
index eabee2c..8255889 100644
--- a/src/math/nvptx/tanh.cpp
+++ b/src/math/nvptx/tanh.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tanh, (double x)) { return __nv_tanh(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tanhf.cpp b/src/math/nvptx/tanhf.cpp
index 582424c..a22524a 100644
--- a/src/math/nvptx/tanhf.cpp
+++ b/src/math/nvptx/tanhf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tanhf, (float x)) { return __nv_tanhf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tgamma.cpp b/src/math/nvptx/tgamma.cpp
index f921938..29f0334 100644
--- a/src/math/nvptx/tgamma.cpp
+++ b/src/math/nvptx/tgamma.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, tgamma, (double x)) { return __nv_tgamma(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/tgammaf.cpp b/src/math/nvptx/tgammaf.cpp
index 8339944..d7de80b 100644
--- a/src/math/nvptx/tgammaf.cpp
+++ b/src/math/nvptx/tgammaf.cpp
@@ -10,9 +10,10 @@
 #include "src/__support/common.h"
 
 #include "declarations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, tgammaf, (float x)) { return __nv_tgammaf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/trunc.cpp b/src/math/nvptx/trunc.cpp
index 773600f..f60caa2 100644
--- a/src/math/nvptx/trunc.cpp
+++ b/src/math/nvptx/trunc.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/trunc.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, trunc, (double x)) { return __builtin_trunc(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/nvptx/truncf.cpp b/src/math/nvptx/truncf.cpp
index 534797a..a6c9b8f 100644
--- a/src/math/nvptx/truncf.cpp
+++ b/src/math/nvptx/truncf.cpp
@@ -8,9 +8,10 @@
 
 #include "src/math/truncf.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, truncf, (float x)) { return __builtin_truncf(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/pow.h b/src/math/pow.h
index dd9b4a6..a861920 100644
--- a/src/math/pow.h
+++ b/src/math/pow.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_POW_H
 #define LLVM_LIBC_SRC_MATH_POW_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double pow(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_POW_H
diff --git a/src/math/powf.h b/src/math/powf.h
index 6582dc3..61c474a 100644
--- a/src/math/powf.h
+++ b/src/math/powf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_POWF_H
 #define LLVM_LIBC_SRC_MATH_POWF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float powf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_POWF_H
diff --git a/src/math/powi.h b/src/math/powi.h
new file mode 100644
index 0000000..a70fab6
--- /dev/null
+++ b/src/math/powi.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for powi --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_POWI_H
+#define LLVM_LIBC_SRC_MATH_POWI_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double powi(double x, int y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_POW_H
diff --git a/src/math/powif.h b/src/math/powif.h
new file mode 100644
index 0000000..ee6716f
--- /dev/null
+++ b/src/math/powif.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for powif -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_POWIF_H
+#define LLVM_LIBC_SRC_MATH_POWIF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float powif(float x, int y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_POW_H
diff --git a/src/math/remainder.h b/src/math/remainder.h
index f1f8954..5bf2af9 100644
--- a/src/math/remainder.h
+++ b/src/math/remainder.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMAINDER_H
 #define LLVM_LIBC_SRC_MATH_REMAINDER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double remainder(double x, double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMAINDER_H
diff --git a/src/math/remainderf.h b/src/math/remainderf.h
index 31a9bbe..4997ebc 100644
--- a/src/math/remainderf.h
+++ b/src/math/remainderf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMAINDERF_H
 #define LLVM_LIBC_SRC_MATH_REMAINDERF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float remainderf(float x, float y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMAINDERF_H
diff --git a/src/math/remainderf128.h b/src/math/remainderf128.h
new file mode 100644
index 0000000..57f770a
--- /dev/null
+++ b/src/math/remainderf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for remainderf128 -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_REMAINDERF128_H
+#define LLVM_LIBC_SRC_MATH_REMAINDERF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float128 remainderf128(float128 x, float128 y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_REMAINDERF128_H
diff --git a/src/math/remainderf16.h b/src/math/remainderf16.h
index e23eead..75f39e5 100644
--- a/src/math/remainderf16.h
+++ b/src/math/remainderf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMAINDERF16_H
 #define LLVM_LIBC_SRC_MATH_REMAINDERF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 remainderf16(float16 x, float16 y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMAINDERF16_H
diff --git a/src/math/remainderl.h b/src/math/remainderl.h
index 584af37..e0df705 100644
--- a/src/math/remainderl.h
+++ b/src/math/remainderl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMAINDERL_H
 #define LLVM_LIBC_SRC_MATH_REMAINDERL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double remainderl(long double x, long double y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMAINDERL_H
diff --git a/src/math/remquo.h b/src/math/remquo.h
index 7590e7d..c16ec95 100644
--- a/src/math/remquo.h
+++ b/src/math/remquo.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMQUO_H
 #define LLVM_LIBC_SRC_MATH_REMQUO_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double remquo(double x, double y, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMQUO_H
diff --git a/src/math/remquof.h b/src/math/remquof.h
index 8b8e877..b63f773 100644
--- a/src/math/remquof.h
+++ b/src/math/remquof.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMQUOF_H
 #define LLVM_LIBC_SRC_MATH_REMQUOF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float remquof(float x, float y, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMQUOF_H
diff --git a/src/math/remquof128.h b/src/math/remquof128.h
index e9db1ef..49e99a9 100644
--- a/src/math/remquof128.h
+++ b/src/math/remquof128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMQUOF128_H
 #define LLVM_LIBC_SRC_MATH_REMQUOF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 remquof128(float128 x, float128 y, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMQUOF128_H
diff --git a/src/math/remquof16.h b/src/math/remquof16.h
index fee848c..310c3db 100644
--- a/src/math/remquof16.h
+++ b/src/math/remquof16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMQUOF16_H
 #define LLVM_LIBC_SRC_MATH_REMQUOF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 remquof16(float16 x, float16 y, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMQUOF16_H
diff --git a/src/math/remquol.h b/src/math/remquol.h
index ba9b099..de5adf4 100644
--- a/src/math/remquol.h
+++ b/src/math/remquol.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_REMQUOL_H
 #define LLVM_LIBC_SRC_MATH_REMQUOL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double remquol(long double x, long double y, int *exp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_REMQUOL_H
diff --git a/src/math/rint.h b/src/math/rint.h
index 3cd676b..1080c4d 100644
--- a/src/math/rint.h
+++ b/src/math/rint.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_RINT_H
 #define LLVM_LIBC_SRC_MATH_RINT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double rint(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_RINT_H
diff --git a/src/math/rintf.h b/src/math/rintf.h
index d0246a3..b371b8c 100644
--- a/src/math/rintf.h
+++ b/src/math/rintf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_RINTF_H
 #define LLVM_LIBC_SRC_MATH_RINTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float rintf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_RINTF_H
diff --git a/src/math/rintf128.h b/src/math/rintf128.h
index 2d92489..2edafcb 100644
--- a/src/math/rintf128.h
+++ b/src/math/rintf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_RINTF128_H
 #define LLVM_LIBC_SRC_MATH_RINTF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 rintf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_RINTF128_H
diff --git a/src/math/rintf16.h b/src/math/rintf16.h
index 5ea9587..839f2dd 100644
--- a/src/math/rintf16.h
+++ b/src/math/rintf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_RINTF16_H
 #define LLVM_LIBC_SRC_MATH_RINTF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 rintf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_RINTF16_H
diff --git a/src/math/rintl.h b/src/math/rintl.h
index bddfa18..fed4769 100644
--- a/src/math/rintl.h
+++ b/src/math/rintl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_RINTL_H
 #define LLVM_LIBC_SRC_MATH_RINTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double rintl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_RINTL_H
diff --git a/src/math/round.h b/src/math/round.h
index 3e6a3b3..c2cd3bf 100644
--- a/src/math/round.h
+++ b/src/math/round.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUND_H
 #define LLVM_LIBC_SRC_MATH_ROUND_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double round(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUND_H
diff --git a/src/math/roundeven.h b/src/math/roundeven.h
index 9c76b1f..a996a03 100644
--- a/src/math/roundeven.h
+++ b/src/math/roundeven.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDEVEN_H
 #define LLVM_LIBC_SRC_MATH_ROUNDEVEN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double roundeven(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDEVEN_H
diff --git a/src/math/roundevenf.h b/src/math/roundevenf.h
index 447e7fd..bdeca67 100644
--- a/src/math/roundevenf.h
+++ b/src/math/roundevenf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDEVENF_H
 #define LLVM_LIBC_SRC_MATH_ROUNDEVENF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float roundevenf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDEVENF_H
diff --git a/src/math/roundevenf128.h b/src/math/roundevenf128.h
index 589839d..ca2ef37 100644
--- a/src/math/roundevenf128.h
+++ b/src/math/roundevenf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDEVENF128_H
 #define LLVM_LIBC_SRC_MATH_ROUNDEVENF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 roundevenf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDEVENF128_H
diff --git a/src/math/roundevenf16.h b/src/math/roundevenf16.h
index 382e2e3..8f5fe22 100644
--- a/src/math/roundevenf16.h
+++ b/src/math/roundevenf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDEVENF16_H
 #define LLVM_LIBC_SRC_MATH_ROUNDEVENF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 roundevenf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDEVENF16_H
diff --git a/src/math/roundevenl.h b/src/math/roundevenl.h
index a2f3397..c53fb08 100644
--- a/src/math/roundevenl.h
+++ b/src/math/roundevenl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDEVENL_H
 #define LLVM_LIBC_SRC_MATH_ROUNDEVENL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double roundevenl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDEVENL_H
diff --git a/src/math/roundf.h b/src/math/roundf.h
index d6ca186..21dbaa8 100644
--- a/src/math/roundf.h
+++ b/src/math/roundf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDF_H
 #define LLVM_LIBC_SRC_MATH_ROUNDF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float roundf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDF_H
diff --git a/src/math/roundf128.h b/src/math/roundf128.h
index e4aca17..ef56d04 100644
--- a/src/math/roundf128.h
+++ b/src/math/roundf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDF128_H
 #define LLVM_LIBC_SRC_MATH_ROUNDF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 roundf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDF128_H
diff --git a/src/math/roundf16.h b/src/math/roundf16.h
index e52f2ae..3077263 100644
--- a/src/math/roundf16.h
+++ b/src/math/roundf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDF16_H
 #define LLVM_LIBC_SRC_MATH_ROUNDF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 roundf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDF16_H
diff --git a/src/math/roundl.h b/src/math/roundl.h
index 0abe87a..8a9fed4 100644
--- a/src/math/roundl.h
+++ b/src/math/roundl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_ROUNDL_H
 #define LLVM_LIBC_SRC_MATH_ROUNDL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double roundl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_ROUNDL_H
diff --git a/src/math/scalbln.h b/src/math/scalbln.h
new file mode 100644
index 0000000..b99ba76
--- /dev/null
+++ b/src/math/scalbln.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for scalbln -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SCALBLN_H
+#define LLVM_LIBC_SRC_MATH_SCALBLN_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double scalbln(double x, long n);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SCALBLN_H
diff --git a/src/math/scalblnf.h b/src/math/scalblnf.h
new file mode 100644
index 0000000..a757f52
--- /dev/null
+++ b/src/math/scalblnf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for scalblnf ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SCALBLNF_H
+#define LLVM_LIBC_SRC_MATH_SCALBLNF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float scalblnf(float x, long n);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SCALBLNF_H
diff --git a/src/math/scalblnf128.h b/src/math/scalblnf128.h
new file mode 100644
index 0000000..b9b7a86
--- /dev/null
+++ b/src/math/scalblnf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for scalblnf128 -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SCALBLNF128_H
+#define LLVM_LIBC_SRC_MATH_SCALBLNF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float128 scalblnf128(float128 x, long n);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SCALBLNF128_H
diff --git a/src/math/scalblnf16.h b/src/math/scalblnf16.h
index be93fab..d47a78c 100644
--- a/src/math/scalblnf16.h
+++ b/src/math/scalblnf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBLNF16_H
 #define LLVM_LIBC_SRC_MATH_SCALBLNF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 scalblnf16(float16 x, long n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBLNF16_H
diff --git a/src/math/scalblnl.h b/src/math/scalblnl.h
new file mode 100644
index 0000000..e2df840
--- /dev/null
+++ b/src/math/scalblnl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for scalblnl ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SCALBLNL_H
+#define LLVM_LIBC_SRC_MATH_SCALBLNL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double scalblnl(long double x, long n);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SCALBLNL_H
diff --git a/src/math/scalbn.h b/src/math/scalbn.h
index 9fc1dc4..d4669d2 100644
--- a/src/math/scalbn.h
+++ b/src/math/scalbn.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBN_H
 #define LLVM_LIBC_SRC_MATH_SCALBN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double scalbn(double x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBN_H
diff --git a/src/math/scalbnf.h b/src/math/scalbnf.h
index 6b5a5f9..d298eeb 100644
--- a/src/math/scalbnf.h
+++ b/src/math/scalbnf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBNF_H
 #define LLVM_LIBC_SRC_MATH_SCALBNF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float scalbnf(float x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBNF_H
diff --git a/src/math/scalbnf128.h b/src/math/scalbnf128.h
index bd3b560..b96d954 100644
--- a/src/math/scalbnf128.h
+++ b/src/math/scalbnf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBNF128_H
 #define LLVM_LIBC_SRC_MATH_SCALBNF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 scalbnf128(float128 x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBNF128_H
diff --git a/src/math/scalbnf16.h b/src/math/scalbnf16.h
index 95e4862..e554a51 100644
--- a/src/math/scalbnf16.h
+++ b/src/math/scalbnf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBNF16_H
 #define LLVM_LIBC_SRC_MATH_SCALBNF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 scalbnf16(float16 x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBNF16_H
diff --git a/src/math/scalbnl.h b/src/math/scalbnl.h
index 876f147..ff02304 100644
--- a/src/math/scalbnl.h
+++ b/src/math/scalbnl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SCALBNL_H
 #define LLVM_LIBC_SRC_MATH_SCALBNL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double scalbnl(long double x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SCALBNL_H
diff --git a/src/math/setpayload.h b/src/math/setpayload.h
new file mode 100644
index 0000000..3f30673
--- /dev/null
+++ b/src/math/setpayload.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayload --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOAD_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOAD_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayload(double *res, double pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOAD_H
diff --git a/src/math/setpayloadf.h b/src/math/setpayloadf.h
new file mode 100644
index 0000000..95544c8
--- /dev/null
+++ b/src/math/setpayloadf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayloadf -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADF_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadf(float *res, float pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADF_H
diff --git a/src/math/setpayloadf128.h b/src/math/setpayloadf128.h
new file mode 100644
index 0000000..e46aef3
--- /dev/null
+++ b/src/math/setpayloadf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for setpayloadf128 ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADF128_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadf128(float128 *res, float128 pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADF128_H
diff --git a/src/math/setpayloadf16.h b/src/math/setpayloadf16.h
index 8705e28..6bdf64a 100644
--- a/src/math/setpayloadf16.h
+++ b/src/math/setpayloadf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADF16_H
 #define LLVM_LIBC_SRC_MATH_SETPAYLOADF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int setpayloadf16(float16 *res, float16 pl);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SETPAYLOADF16_H
diff --git a/src/math/setpayloadl.h b/src/math/setpayloadl.h
new file mode 100644
index 0000000..f0df62f
--- /dev/null
+++ b/src/math/setpayloadl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayloadl -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADL_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadl(long double *res, long double pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADL_H
diff --git a/src/math/setpayloadsig.h b/src/math/setpayloadsig.h
new file mode 100644
index 0000000..8059e6f
--- /dev/null
+++ b/src/math/setpayloadsig.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayloadsig -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADSIG_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADSIG_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadsig(double *res, double pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADSIG_H
diff --git a/src/math/setpayloadsigf.h b/src/math/setpayloadsigf.h
new file mode 100644
index 0000000..e7a0175
--- /dev/null
+++ b/src/math/setpayloadsigf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayloadsigf ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadsigf(float *res, float pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF_H
diff --git a/src/math/setpayloadsigf128.h b/src/math/setpayloadsigf128.h
new file mode 100644
index 0000000..4e036b9
--- /dev/null
+++ b/src/math/setpayloadsigf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for setpayloadsigf128 -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF128_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadsigf128(float128 *res, float128 pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF128_H
diff --git a/src/math/setpayloadsigf16.h b/src/math/setpayloadsigf16.h
index ee9bc38..0c5e773 100644
--- a/src/math/setpayloadsigf16.h
+++ b/src/math/setpayloadsigf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF16_H
 #define LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int setpayloadsigf16(float16 *res, float16 pl);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF16_H
diff --git a/src/math/setpayloadsigl.h b/src/math/setpayloadsigl.h
new file mode 100644
index 0000000..9bc47ee
--- /dev/null
+++ b/src/math/setpayloadsigl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for setpayloadsigl ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SETPAYLOADSIGL_H
+#define LLVM_LIBC_SRC_MATH_SETPAYLOADSIGL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int setpayloadsigl(long double *res, long double pl);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SETPAYLOADSIGF_H
diff --git a/src/math/sin.h b/src/math/sin.h
index 50ecdc7..2a4362d 100644
--- a/src/math/sin.h
+++ b/src/math/sin.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SIN_H
 #define LLVM_LIBC_SRC_MATH_SIN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double sin(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SIN_H
diff --git a/src/math/sincos.h b/src/math/sincos.h
index 6235a7c..580bdbb 100644
--- a/src/math/sincos.h
+++ b/src/math/sincos.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SINCOS_H
 #define LLVM_LIBC_SRC_MATH_SINCOS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 void sincos(double x, double *sinx, double *cosx);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SINCOS_H
diff --git a/src/math/sincosf.h b/src/math/sincosf.h
index 56539f5..28dbc65 100644
--- a/src/math/sincosf.h
+++ b/src/math/sincosf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SINCOSF_H
 #define LLVM_LIBC_SRC_MATH_SINCOSF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 void sincosf(float x, float *sinx, float *cosx);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SINCOSF_H
diff --git a/src/math/sinf.h b/src/math/sinf.h
index aa0b753..c4f8c88 100644
--- a/src/math/sinf.h
+++ b/src/math/sinf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SINF_H
 #define LLVM_LIBC_SRC_MATH_SINF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float sinf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SINF_H
diff --git a/src/math/sinh.h b/src/math/sinh.h
index bf1b1f1..b87471c 100644
--- a/src/math/sinh.h
+++ b/src/math/sinh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SINH_H
 #define LLVM_LIBC_SRC_MATH_SINH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double sinh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SINH_H
diff --git a/src/math/sinhf.h b/src/math/sinhf.h
index 65cb39f..f69a194 100644
--- a/src/math/sinhf.h
+++ b/src/math/sinhf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SINHF_H
 #define LLVM_LIBC_SRC_MATH_SINHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float sinhf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SINHF_H
diff --git a/src/math/sinhf16.h b/src/math/sinhf16.h
new file mode 100644
index 0000000..8b8c1b6
--- /dev/null
+++ b/src/math/sinhf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for sinhf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SINHF16_H
+#define LLVM_LIBC_SRC_MATH_SINHF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 sinhf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SINHF16_H
diff --git a/src/math/sinpif.h b/src/math/sinpif.h
new file mode 100644
index 0000000..038fb19
--- /dev/null
+++ b/src/math/sinpif.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for sinpif ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SINPIF_H
+#define LLVM_LIBC_SRC_MATH_SINPIF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float sinpif(float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SINPIF_H
diff --git a/src/math/sinpif16.h b/src/math/sinpif16.h
new file mode 100644
index 0000000..33a0ae2
--- /dev/null
+++ b/src/math/sinpif16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for sinpif16 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache Licese v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SINPIF16_H
+#define LLVM_LIBC_SRC_MATH_SINPIF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 sinpif16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SINPIF16_H
diff --git a/src/math/sqrt.h b/src/math/sqrt.h
index d003e3f..566944a 100644
--- a/src/math/sqrt.h
+++ b/src/math/sqrt.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SQRT_H
 #define LLVM_LIBC_SRC_MATH_SQRT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double sqrt(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SQRT_H
diff --git a/src/math/sqrtf.h b/src/math/sqrtf.h
index fe4192a..db39ab7 100644
--- a/src/math/sqrtf.h
+++ b/src/math/sqrtf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SQRTF_H
 #define LLVM_LIBC_SRC_MATH_SQRTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float sqrtf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SQRTF_H
diff --git a/src/math/sqrtf128.h b/src/math/sqrtf128.h
index 9da9eb6..81f4c12 100644
--- a/src/math/sqrtf128.h
+++ b/src/math/sqrtf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_SQRTF128_H
 #define LLVM_LIBC_SRC_MATH_SQRTF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 sqrtf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SQRTF128_H
diff --git a/src/math/sqrtf16.h b/src/math/sqrtf16.h
new file mode 100644
index 0000000..bb09c4f
--- /dev/null
+++ b/src/math/sqrtf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for sqrtf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SQRTF16_H
+#define LLVM_LIBC_SRC_MATH_SQRTF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 sqrtf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SQRTF16_H
diff --git a/src/math/sqrtl.h b/src/math/sqrtl.h
index e632c19..52b208d 100644
--- a/src/math/sqrtl.h
+++ b/src/math/sqrtl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_SQRTL_H
 #define LLVM_LIBC_SRC_MATH_SQRTL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double sqrtl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_SQRTL_H
diff --git a/src/math/tan.h b/src/math/tan.h
index 5d0121f..462c60f 100644
--- a/src/math/tan.h
+++ b/src/math/tan.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TAN_H
 #define LLVM_LIBC_SRC_MATH_TAN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double tan(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TAN_H
diff --git a/src/math/tanf.h b/src/math/tanf.h
index e0f06a8..0d4b9e7 100644
--- a/src/math/tanf.h
+++ b/src/math/tanf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TANF_H
 #define LLVM_LIBC_SRC_MATH_TANF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float tanf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TANF_H
diff --git a/src/math/tanh.h b/src/math/tanh.h
index 66561ee..eadde36 100644
--- a/src/math/tanh.h
+++ b/src/math/tanh.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TANH_H
 #define LLVM_LIBC_SRC_MATH_TANH_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double tanh(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TANH_H
diff --git a/src/math/tanhf.h b/src/math/tanhf.h
index ff9d02e..a0bd1e9 100644
--- a/src/math/tanhf.h
+++ b/src/math/tanhf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TANHF_H
 #define LLVM_LIBC_SRC_MATH_TANHF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float tanhf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TANHF_H
diff --git a/src/math/tanhf16.h b/src/math/tanhf16.h
new file mode 100644
index 0000000..6749870
--- /dev/null
+++ b/src/math/tanhf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for tanhf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TANHF16_H
+#define LLVM_LIBC_SRC_MATH_TANHF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 tanhf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TANHF16_H
diff --git a/src/math/tanpif16.h b/src/math/tanpif16.h
new file mode 100644
index 0000000..c07a955
--- /dev/null
+++ b/src/math/tanpif16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for tanpif16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TANPIF16_H
+#define LLVM_LIBC_SRC_MATH_TANPIF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 tanpif16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TANPIF16_H
diff --git a/src/math/tgamma.h b/src/math/tgamma.h
index 24590ed..9210a4b 100644
--- a/src/math/tgamma.h
+++ b/src/math/tgamma.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TGAMMA_H
 #define LLVM_LIBC_SRC_MATH_TGAMMA_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double tgamma(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TGAMMA_H
diff --git a/src/math/tgammaf.h b/src/math/tgammaf.h
index d28e4c3..0524dee 100644
--- a/src/math/tgammaf.h
+++ b/src/math/tgammaf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TGAMMAF_H
 #define LLVM_LIBC_SRC_MATH_TGAMMAF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float tgammaf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TGAMMAF_H
diff --git a/src/math/totalorder.h b/src/math/totalorder.h
new file mode 100644
index 0000000..d8d0297
--- /dev/null
+++ b/src/math/totalorder.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalorder --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDER_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDER_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalorder(const double *x, const double *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDER_H
diff --git a/src/math/totalorderf.h b/src/math/totalorderf.h
new file mode 100644
index 0000000..bade04c
--- /dev/null
+++ b/src/math/totalorderf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalorderf -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERF_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalorderf(const float *x, const float *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERF_H
diff --git a/src/math/totalorderf128.h b/src/math/totalorderf128.h
new file mode 100644
index 0000000..9587148
--- /dev/null
+++ b/src/math/totalorderf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for totalorderf128 ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERF128_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalorderf128(const float128 *x, const float128 *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERF128_H
diff --git a/src/math/totalorderf16.h b/src/math/totalorderf16.h
index f539014..db787c9 100644
--- a/src/math/totalorderf16.h
+++ b/src/math/totalorderf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_TOTALORDERF16_H
 #define LLVM_LIBC_SRC_MATH_TOTALORDERF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int totalorderf16(const float16 *x, const float16 *y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TOTALORDERF16_H
diff --git a/src/math/totalorderl.h b/src/math/totalorderl.h
new file mode 100644
index 0000000..064b2a5
--- /dev/null
+++ b/src/math/totalorderl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalorderl -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERL_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalorderl(const long double *x, const long double *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERL_H
diff --git a/src/math/totalordermag.h b/src/math/totalordermag.h
new file mode 100644
index 0000000..cfdd868
--- /dev/null
+++ b/src/math/totalordermag.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalordermag -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERMAG_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERMAG_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalordermag(const double *x, const double *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERMAG_H
diff --git a/src/math/totalordermagf.h b/src/math/totalordermagf.h
new file mode 100644
index 0000000..47ddd83
--- /dev/null
+++ b/src/math/totalordermagf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalordermagf ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERMAGF_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERMAGF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalordermagf(const float *x, const float *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERMAGF_H
diff --git a/src/math/totalordermagf128.h b/src/math/totalordermagf128.h
new file mode 100644
index 0000000..389d059
--- /dev/null
+++ b/src/math/totalordermagf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for totalordermagf128 -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERMAGF128_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERMAGF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalordermagf128(const float128 *x, const float128 *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERMAGF128_H
diff --git a/src/math/totalordermagf16.h b/src/math/totalordermagf16.h
index 8c6621b..eed8bf3 100644
--- a/src/math/totalordermagf16.h
+++ b/src/math/totalordermagf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_TOTALORDERMAGF16_H
 #define LLVM_LIBC_SRC_MATH_TOTALORDERMAGF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int totalordermagf16(const float16 *x, const float16 *y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TOTALORDERMAGF16_H
diff --git a/src/math/totalordermagl.h b/src/math/totalordermagl.h
new file mode 100644
index 0000000..64d27f1
--- /dev/null
+++ b/src/math/totalordermagl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for totalordermag -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TOTALORDERMAGL_H
+#define LLVM_LIBC_SRC_MATH_TOTALORDERMAGL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int totalordermagl(const long double *x, const long double *y);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TOTALORDERMAGl_H
diff --git a/src/math/trunc.h b/src/math/trunc.h
index d766aff..d4fb878 100644
--- a/src/math/trunc.h
+++ b/src/math/trunc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TRUNC_H
 #define LLVM_LIBC_SRC_MATH_TRUNC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double trunc(double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TRUNC_H
diff --git a/src/math/truncf.h b/src/math/truncf.h
index e666d77..3cdf2ee 100644
--- a/src/math/truncf.h
+++ b/src/math/truncf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TRUNCF_H
 #define LLVM_LIBC_SRC_MATH_TRUNCF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float truncf(float x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TRUNCF_H
diff --git a/src/math/truncf128.h b/src/math/truncf128.h
index 5eb6116..df3899c 100644
--- a/src/math/truncf128.h
+++ b/src/math/truncf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_TRUNCF128_H
 #define LLVM_LIBC_SRC_MATH_TRUNCF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 truncf128(float128 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TRUNCF128_H
diff --git a/src/math/truncf16.h b/src/math/truncf16.h
index 6d65980..db03c68 100644
--- a/src/math/truncf16.h
+++ b/src/math/truncf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_TRUNCF16_H
 #define LLVM_LIBC_SRC_MATH_TRUNCF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 truncf16(float16 x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TRUNCF16_H
diff --git a/src/math/truncl.h b/src/math/truncl.h
index 38f414f..6b4d22d 100644
--- a/src/math/truncl.h
+++ b/src/math/truncl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_TRUNCL_H
 #define LLVM_LIBC_SRC_MATH_TRUNCL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double truncl(long double x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_TRUNCL_H
diff --git a/src/math/ufromfp.h b/src/math/ufromfp.h
index f466748..6b40623 100644
--- a/src/math/ufromfp.h
+++ b/src/math/ufromfp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFP_H
 #define LLVM_LIBC_SRC_MATH_UFROMFP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double ufromfp(double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFP_H
diff --git a/src/math/ufromfpf.h b/src/math/ufromfpf.h
index 40c6773..d272cec 100644
--- a/src/math/ufromfpf.h
+++ b/src/math/ufromfpf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPF_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float ufromfpf(float x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPF_H
diff --git a/src/math/ufromfpf128.h b/src/math/ufromfpf128.h
index 785fa82..b38ef69 100644
--- a/src/math/ufromfpf128.h
+++ b/src/math/ufromfpf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPF128_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 ufromfpf128(float128 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPF128_H
diff --git a/src/math/ufromfpf16.h b/src/math/ufromfpf16.h
index 07a38bd..c863a2d 100644
--- a/src/math/ufromfpf16.h
+++ b/src/math/ufromfpf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPF16_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 ufromfpf16(float16 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPF16_H
diff --git a/src/math/ufromfpl.h b/src/math/ufromfpl.h
index f05a77d..c7b9331 100644
--- a/src/math/ufromfpl.h
+++ b/src/math/ufromfpl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPL_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double ufromfpl(long double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPL_H
diff --git a/src/math/ufromfpx.h b/src/math/ufromfpx.h
index 79c413a..00a3c5f 100644
--- a/src/math/ufromfpx.h
+++ b/src/math/ufromfpx.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPX_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double ufromfpx(double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPX_H
diff --git a/src/math/ufromfpxf.h b/src/math/ufromfpxf.h
index f6bd8f7..1740ac3 100644
--- a/src/math/ufromfpxf.h
+++ b/src/math/ufromfpxf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPXF_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPXF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float ufromfpxf(float x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPXF_H
diff --git a/src/math/ufromfpxf128.h b/src/math/ufromfpxf128.h
index f3b43ff..5008b7a 100644
--- a/src/math/ufromfpxf128.h
+++ b/src/math/ufromfpxf128.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPXF128_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPXF128_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float128 ufromfpxf128(float128 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPXF128_H
diff --git a/src/math/ufromfpxf16.h b/src/math/ufromfpxf16.h
index 988092b..9e03353 100644
--- a/src/math/ufromfpxf16.h
+++ b/src/math/ufromfpxf16.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPXF16_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPXF16_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 float16 ufromfpxf16(float16 x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPXF16_H
diff --git a/src/math/ufromfpxl.h b/src/math/ufromfpxl.h
index 180b8f9..13ff936 100644
--- a/src/math/ufromfpxl.h
+++ b/src/math/ufromfpxl.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_MATH_UFROMFPXL_H
 #define LLVM_LIBC_SRC_MATH_UFROMFPXL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double ufromfpxl(long double x, int rnd, unsigned int width);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_UFROMFPXL_H
diff --git a/src/math/x86_64/tan.cpp b/src/math/x86_64/tan.cpp
deleted file mode 100644
index bc0e0fc..0000000
--- a/src/math/x86_64/tan.cpp
+++ /dev/null
@@ -1,23 +0,0 @@
-//===-- Implementation of the tan function for x86_64 ---------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/math/tan.h"
-#include "src/__support/common.h"
-
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(double, tan, (double x)) {
-  double result;
-  // The fptan instruction pushes the number 1 on to the FP stack after
-  // computing tan. So, we read out the one before popping the actual result.
-  __asm__ __volatile__("fptan" : "+t"(x));
-  __asm__ __volatile__("fstpl %0" : "=m"(result));
-  return result;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/network/htonl.cpp b/src/network/htonl.cpp
index 862d5e3..681786a 100644
--- a/src/network/htonl.cpp
+++ b/src/network/htonl.cpp
@@ -8,12 +8,13 @@
 
 #include "src/network/htonl.h"
 #include "src/__support/common.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uint32_t, htonl, (uint32_t hostlong)) {
   return Endian::to_big_endian(hostlong);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/network/htonl.h b/src/network/htonl.h
index c7743df..1421731 100644
--- a/src/network/htonl.h
+++ b/src/network/htonl.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_NETWORK_HTONL_H
 #define LLVM_LIBC_SRC_NETWORK_HTONL_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uint32_t htonl(uint32_t hostlong);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_NETWORK_HTONL_H
diff --git a/src/network/htons.cpp b/src/network/htons.cpp
index e844454..675f53c 100644
--- a/src/network/htons.cpp
+++ b/src/network/htons.cpp
@@ -8,12 +8,13 @@
 
 #include "src/network/htons.h"
 #include "src/__support/common.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uint16_t, htons, (uint16_t hostshort)) {
   return Endian::to_big_endian(hostshort);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/network/htons.h b/src/network/htons.h
index e0a379f..8f5c68a 100644
--- a/src/network/htons.h
+++ b/src/network/htons.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_NETWORK_HTONS_H
 #define LLVM_LIBC_SRC_NETWORK_HTONS_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uint16_t htons(uint16_t hostshort);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_NETWORK_HTONS_H
diff --git a/src/network/ntohl.cpp b/src/network/ntohl.cpp
index c00f4a5..6a309e9 100644
--- a/src/network/ntohl.cpp
+++ b/src/network/ntohl.cpp
@@ -8,9 +8,10 @@
 
 #include "src/network/ntohl.h"
 #include "src/__support/common.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uint32_t, ntohl, (uint32_t netlong)) {
   if constexpr (Endian::IS_LITTLE)
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(uint32_t, ntohl, (uint32_t netlong)) {
     return netlong;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/network/ntohl.h b/src/network/ntohl.h
index 2fc4ef0..c325951 100644
--- a/src/network/ntohl.h
+++ b/src/network/ntohl.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_NETWORK_NTOHL_H
 #define LLVM_LIBC_SRC_NETWORK_NTOHL_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uint32_t ntohl(uint32_t netlong);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_NETWORK_NTOHL_H
diff --git a/src/network/ntohs.cpp b/src/network/ntohs.cpp
index 572b686..b51ecb9 100644
--- a/src/network/ntohs.cpp
+++ b/src/network/ntohs.cpp
@@ -8,9 +8,10 @@
 
 #include "src/network/ntohs.h"
 #include "src/__support/common.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uint16_t, ntohs, (uint16_t netshort)) {
   if constexpr (Endian::IS_LITTLE)
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(uint16_t, ntohs, (uint16_t netshort)) {
     return netshort;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/network/ntohs.h b/src/network/ntohs.h
index a84c52e..f555914 100644
--- a/src/network/ntohs.h
+++ b/src/network/ntohs.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_NETWORK_NTOHS_H
 #define LLVM_LIBC_SRC_NETWORK_NTOHS_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uint16_t ntohs(uint16_t netshort);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_NETWORK_NTOHS_H
diff --git a/src/pthread/pthread_atfork.cpp b/src/pthread/pthread_atfork.cpp
index 57191b8..b2c67c7 100644
--- a/src/pthread/pthread_atfork.cpp
+++ b/src/pthread/pthread_atfork.cpp
@@ -9,12 +9,13 @@
 #include "pthread_atfork.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/fork_callbacks.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_atfork,
                    (__atfork_callback_t prepare, __atfork_callback_t parent,
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, pthread_atfork,
   return register_atfork_callbacks(prepare, parent, child) ? 0 : ENOMEM;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_atfork.h b/src/pthread/pthread_atfork.h
index 8b89d68..4292e2a 100644
--- a/src/pthread/pthread_atfork.h
+++ b/src/pthread/pthread_atfork.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATFORK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATFORK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_atfork(__atfork_callback_t prepare, __atfork_callback_t parent,
                    __atfork_callback_t child);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATFORK_H
diff --git a/src/pthread/pthread_attr_destroy.cpp b/src/pthread/pthread_attr_destroy.cpp
index a5bde84..090cc23 100644
--- a/src/pthread/pthread_attr_destroy.cpp
+++ b/src/pthread/pthread_attr_destroy.cpp
@@ -9,14 +9,15 @@
 #include "pthread_attr_destroy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_destroy, (pthread_attr_t *)) {
   // There is nothing to cleanup.
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_destroy.h b/src/pthread/pthread_attr_destroy.h
index 532a0f4..a5e7e62 100644
--- a/src/pthread/pthread_attr_destroy.h
+++ b/src/pthread/pthread_attr_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_destroy(pthread_attr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_DESTROY_H
diff --git a/src/pthread/pthread_attr_getdetachstate.cpp b/src/pthread/pthread_attr_getdetachstate.cpp
index 4bff85d..ec75513 100644
--- a/src/pthread/pthread_attr_getdetachstate.cpp
+++ b/src/pthread/pthread_attr_getdetachstate.cpp
@@ -9,10 +9,11 @@
 #include "pthread_attr_getdetachstate.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_getdetachstate,
                    (const pthread_attr_t *attr, int *detachstate)) {
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_getdetachstate,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_getdetachstate.h b/src/pthread/pthread_attr_getdetachstate.h
index 57a47b7..e1c89ba 100644
--- a/src/pthread/pthread_attr_getdetachstate.h
+++ b/src/pthread/pthread_attr_getdetachstate.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETDETACHSTATE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETDETACHSTATE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detach_state);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETDETACHSTATE_H
diff --git a/src/pthread/pthread_attr_getguardsize.cpp b/src/pthread/pthread_attr_getguardsize.cpp
index 8f28db8..b7c5085 100644
--- a/src/pthread/pthread_attr_getguardsize.cpp
+++ b/src/pthread/pthread_attr_getguardsize.cpp
@@ -9,10 +9,11 @@
 #include "pthread_attr_getguardsize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_getguardsize,
                    (const pthread_attr_t *__restrict attr,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_getguardsize,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_getguardsize.h b/src/pthread/pthread_attr_getguardsize.h
index ef2e758..e5f9cbf 100644
--- a/src/pthread/pthread_attr_getguardsize.h
+++ b/src/pthread/pthread_attr_getguardsize.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETGUARDSIZE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETGUARDSIZE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_getguardsize(const pthread_attr_t *__restrict attr,
                               size_t *__restrict guardsize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETGUARDSIZE_H
diff --git a/src/pthread/pthread_attr_getstack.cpp b/src/pthread/pthread_attr_getstack.cpp
index 8788fbc..6166e44 100644
--- a/src/pthread/pthread_attr_getstack.cpp
+++ b/src/pthread/pthread_attr_getstack.cpp
@@ -10,11 +10,12 @@
 #include "pthread_attr_getstacksize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_getstack,
                    (const pthread_attr_t *__restrict attr,
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_getstack,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_getstack.h b/src/pthread/pthread_attr_getstack.h
index 22ac24a..f28c734 100644
--- a/src/pthread/pthread_attr_getstack.h
+++ b/src/pthread/pthread_attr_getstack.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_getstack(const pthread_attr_t *__restrict attr,
                           void **__restrict stack,
                           size_t *__restrict stacksize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACK_H
diff --git a/src/pthread/pthread_attr_getstacksize.cpp b/src/pthread/pthread_attr_getstacksize.cpp
index ecc4787..230ca78 100644
--- a/src/pthread/pthread_attr_getstacksize.cpp
+++ b/src/pthread/pthread_attr_getstacksize.cpp
@@ -9,10 +9,11 @@
 #include "pthread_attr_getstacksize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_getstacksize,
                    (const pthread_attr_t *__restrict attr,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_getstacksize,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_getstacksize.h b/src/pthread/pthread_attr_getstacksize.h
index 3136f08..078da78 100644
--- a/src/pthread/pthread_attr_getstacksize.h
+++ b/src/pthread/pthread_attr_getstacksize.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACKSIZE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACKSIZE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_getstacksize(const pthread_attr_t *__restrict attr,
                               size_t *__restrict stacksize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_GETSTACKSIZE_H
diff --git a/src/pthread/pthread_attr_init.cpp b/src/pthread/pthread_attr_init.cpp
index 13d302c..1fc6430 100644
--- a/src/pthread/pthread_attr_init.cpp
+++ b/src/pthread/pthread_attr_init.cpp
@@ -9,11 +9,12 @@
 #include "pthread_attr_init.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h" // For thread::DEFAULT_*
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_init, (pthread_attr_t * attr)) {
   *attr = pthread_attr_t{
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_init, (pthread_attr_t * attr)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_init.h b/src/pthread/pthread_attr_init.h
index 3a2ad3d..6996998 100644
--- a/src/pthread/pthread_attr_init.h
+++ b/src/pthread/pthread_attr_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_init(pthread_attr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_INIT_H
diff --git a/src/pthread/pthread_attr_setdetachstate.cpp b/src/pthread/pthread_attr_setdetachstate.cpp
index 029b4d5..872f694 100644
--- a/src/pthread/pthread_attr_setdetachstate.cpp
+++ b/src/pthread/pthread_attr_setdetachstate.cpp
@@ -9,11 +9,12 @@
 #include "pthread_attr_setdetachstate.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_setdetachstate,
                    (pthread_attr_t * attr, int detachstate)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_setdetachstate,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_setdetachstate.h b/src/pthread/pthread_attr_setdetachstate.h
index 2b994d9..06e1aa6 100644
--- a/src/pthread/pthread_attr_setdetachstate.h
+++ b/src/pthread/pthread_attr_setdetachstate.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETDETACHSTATE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETDETACHSTATE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detach_state);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETDETACHSTATE_H
diff --git a/src/pthread/pthread_attr_setguardsize.cpp b/src/pthread/pthread_attr_setguardsize.cpp
index 98855b2..fa4375e 100644
--- a/src/pthread/pthread_attr_setguardsize.cpp
+++ b/src/pthread/pthread_attr_setguardsize.cpp
@@ -9,12 +9,13 @@
 #include "pthread_attr_setguardsize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <linux/param.h> // For EXEC_PAGESIZE.
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_setguardsize,
                    (pthread_attr_t *__restrict attr, size_t guardsize)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_setguardsize,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_setguardsize.h b/src/pthread/pthread_attr_setguardsize.h
index 64d896a..f418355 100644
--- a/src/pthread/pthread_attr_setguardsize.h
+++ b/src/pthread/pthread_attr_setguardsize.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETGUARDSIZE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETGUARDSIZE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETGUARDSIZE_H
diff --git a/src/pthread/pthread_attr_setstack.cpp b/src/pthread/pthread_attr_setstack.cpp
index dde4e3f..1154055 100644
--- a/src/pthread/pthread_attr_setstack.cpp
+++ b/src/pthread/pthread_attr_setstack.cpp
@@ -10,13 +10,14 @@
 #include "pthread_attr_setstacksize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h" // For STACK_ALIGNMENT
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_setstack,
                    (pthread_attr_t *__restrict attr, void *stack,
@@ -35,4 +36,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_setstack,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_setstack.h b/src/pthread/pthread_attr_setstack.h
index fe2a7f4..9ae2cfa 100644
--- a/src/pthread/pthread_attr_setstack.h
+++ b/src/pthread/pthread_attr_setstack.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_setstack(pthread_attr_t *attr, void *stack, size_t stacksize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACK_H
diff --git a/src/pthread/pthread_attr_setstacksize.cpp b/src/pthread/pthread_attr_setstacksize.cpp
index 642a888..0a5d1af 100644
--- a/src/pthread/pthread_attr_setstacksize.cpp
+++ b/src/pthread/pthread_attr_setstacksize.cpp
@@ -9,11 +9,12 @@
 #include "pthread_attr_setstacksize.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_attr_setstacksize,
                    (pthread_attr_t *__restrict attr, size_t stacksize)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, pthread_attr_setstacksize,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_attr_setstacksize.h b/src/pthread/pthread_attr_setstacksize.h
index f594094..0641856 100644
--- a/src/pthread/pthread_attr_setstacksize.h
+++ b/src/pthread/pthread_attr_setstacksize.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACKSIZE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACKSIZE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ATTR_SETSTACKSIZE_H
diff --git a/src/pthread/pthread_condattr_destroy.cpp b/src/pthread/pthread_condattr_destroy.cpp
index 41994c6..f0b9fd1 100644
--- a/src/pthread/pthread_condattr_destroy.cpp
+++ b/src/pthread/pthread_condattr_destroy.cpp
@@ -9,10 +9,11 @@
 #include "pthread_condattr_destroy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_destroy,
                    (pthread_condattr_t * attr [[gnu::unused]])) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_destroy,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_destroy.h b/src/pthread/pthread_condattr_destroy.h
index 2910fa9..1579497 100644
--- a/src/pthread/pthread_condattr_destroy.h
+++ b/src/pthread/pthread_condattr_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_destroy(pthread_condattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_DESTROY_H
diff --git a/src/pthread/pthread_condattr_getclock.cpp b/src/pthread/pthread_condattr_getclock.cpp
index a3a3963..75fd930 100644
--- a/src/pthread/pthread_condattr_getclock.cpp
+++ b/src/pthread/pthread_condattr_getclock.cpp
@@ -9,11 +9,12 @@
 #include "pthread_condattr_getclock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>   // pthread_condattr_t
 #include <sys/types.h> // clockid_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_getclock,
                    (const pthread_condattr_t *__restrict attr,
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_getclock,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_getclock.h b/src/pthread/pthread_condattr_getclock.h
index d5878c4..52025b3 100644
--- a/src/pthread/pthread_condattr_getclock.h
+++ b/src/pthread/pthread_condattr_getclock.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_GETCLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_GETCLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>   // pthread_condattr_t
 #include <sys/types.h> // clockid_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_getclock(const pthread_condattr_t *__restrict attr,
                               clockid_t *__restrict clock_id);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_GETCLOCK_H
diff --git a/src/pthread/pthread_condattr_getpshared.cpp b/src/pthread/pthread_condattr_getpshared.cpp
index 0c5fdc1..8692149 100644
--- a/src/pthread/pthread_condattr_getpshared.cpp
+++ b/src/pthread/pthread_condattr_getpshared.cpp
@@ -9,10 +9,11 @@
 #include "pthread_condattr_getpshared.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_getpshared,
                    (const pthread_condattr_t *__restrict attr,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_getpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_getpshared.h b/src/pthread/pthread_condattr_getpshared.h
index 3d7a0c1..2b1eb10 100644
--- a/src/pthread/pthread_condattr_getpshared.h
+++ b/src/pthread/pthread_condattr_getpshared.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_PSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_PSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_getpshared(const pthread_condattr_t *__restrict attr,
                                 int *__restrict pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_PSHARED_H
diff --git a/src/pthread/pthread_condattr_init.cpp b/src/pthread/pthread_condattr_init.cpp
index 54633b2..12005b8 100644
--- a/src/pthread/pthread_condattr_init.cpp
+++ b/src/pthread/pthread_condattr_init.cpp
@@ -9,11 +9,12 @@
 #include "pthread_condattr_init.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h> // pthread_condattr_t, PTHREAD_PROCESS_PRIVATE
 #include <time.h>    // CLOCK_REALTIME
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_init, (pthread_condattr_t * attr)) {
   attr->clock = CLOCK_REALTIME;
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_init, (pthread_condattr_t * attr)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_init.h b/src/pthread/pthread_condattr_init.h
index 9f3c06b..8f68154 100644
--- a/src/pthread/pthread_condattr_init.h
+++ b/src/pthread/pthread_condattr_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_init(pthread_condattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_INIT_H
diff --git a/src/pthread/pthread_condattr_setclock.cpp b/src/pthread/pthread_condattr_setclock.cpp
index 6eca8b3..37fbd6b 100644
--- a/src/pthread/pthread_condattr_setclock.cpp
+++ b/src/pthread/pthread_condattr_setclock.cpp
@@ -9,13 +9,14 @@
 #include "pthread_condattr_setclock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>     // EINVAL
 #include <pthread.h>   // pthread_condattr_t
 #include <sys/types.h> // clockid_t
 #include <time.h>      // CLOCK_MONOTONIC, CLOCK_REALTIME
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_setclock,
                    (pthread_condattr_t * attr, clockid_t clock)) {
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_setclock,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_setclock.h b/src/pthread/pthread_condattr_setclock.h
index 328766f..e9fd77a 100644
--- a/src/pthread/pthread_condattr_setclock.h
+++ b/src/pthread/pthread_condattr_setclock.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETCLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETCLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 #include <sys/types.h> // clockid_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_setclock(pthread_condattr_t *attr, clockid_t clock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETCLOCK_H
diff --git a/src/pthread/pthread_condattr_setpshared.cpp b/src/pthread/pthread_condattr_setpshared.cpp
index 7f1560a..433b2dc 100644
--- a/src/pthread/pthread_condattr_setpshared.cpp
+++ b/src/pthread/pthread_condattr_setpshared.cpp
@@ -9,11 +9,12 @@
 #include "pthread_condattr_setpshared.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h> // EINVAL
 #include <pthread.h> // pthread_condattr_t, PTHREAD_PROCESS_SHARED, PTHREAD_PROCESS_PRIVATE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_condattr_setpshared,
                    (pthread_condattr_t * attr, int pshared)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, pthread_condattr_setpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_condattr_setpshared.h b/src/pthread/pthread_condattr_setpshared.h
index 8083bde..7a55466 100644
--- a/src/pthread/pthread_condattr_setpshared.h
+++ b/src/pthread/pthread_condattr_setpshared.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETPSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETPSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CONDATTR_SETPSHARED_H
diff --git a/src/pthread/pthread_create.cpp b/src/pthread/pthread_create.cpp
index 8b406cd..e1b1f3b 100644
--- a/src/pthread/pthread_create.cpp
+++ b/src/pthread/pthread_create.cpp
@@ -16,13 +16,14 @@
 #include "pthread_attr_getstack.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/threads/thread.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -84,4 +85,4 @@ LLVM_LIBC_FUNCTION(int, pthread_create,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_create.h b/src/pthread/pthread_create.h
index 75466e3..d6c3c9c 100644
--- a/src/pthread/pthread_create.h
+++ b/src/pthread/pthread_create.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_CREATE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_CREATE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_create(pthread_t *__restrict thread,
                    const pthread_attr_t *__restrict attr,
                    __pthread_start_t func, void *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_CREATE_H
diff --git a/src/pthread/pthread_detach.cpp b/src/pthread/pthread_detach.cpp
index e8b69b6..b3c9667 100644
--- a/src/pthread/pthread_detach.cpp
+++ b/src/pthread/pthread_detach.cpp
@@ -9,11 +9,12 @@
 #include "pthread_detach.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_detach, (pthread_t th)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_detach.h b/src/pthread/pthread_detach.h
index d54fdf8..471a358 100644
--- a/src/pthread/pthread_detach.h
+++ b/src/pthread/pthread_detach.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_DETACH_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_DETACH_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_detach(pthread_t thread);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_DETACH_H
diff --git a/src/pthread/pthread_equal.cpp b/src/pthread/pthread_equal.cpp
index f154e9b..7d28738 100644
--- a/src/pthread/pthread_equal.cpp
+++ b/src/pthread/pthread_equal.cpp
@@ -9,11 +9,12 @@
 #include "pthread_equal.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_equal, (pthread_t lhs, pthread_t rhs)) {
   return *lhs_internal == *rhs_internal;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_equal.h b/src/pthread/pthread_equal.h
index 448fb8f..a64990a 100644
--- a/src/pthread/pthread_equal.h
+++ b/src/pthread/pthread_equal.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_EQUAL_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_EQUAL_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_equal(pthread_t lhs, pthread_t rhs);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_EQUAL_H
diff --git a/src/pthread/pthread_exit.cpp b/src/pthread/pthread_exit.cpp
index acba665..7e3bbee 100644
--- a/src/pthread/pthread_exit.cpp
+++ b/src/pthread/pthread_exit.cpp
@@ -9,11 +9,12 @@
 #include "pthread_exit.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(void, pthread_exit, (void *retval)) {
   LIBC_NAMESPACE::thread_exit(ThreadReturnValue(retval), ThreadStyle::POSIX);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_exit.h b/src/pthread/pthread_exit.h
index 6617dab..9aa9e0a 100644
--- a/src/pthread/pthread_exit.h
+++ b/src/pthread/pthread_exit.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_EXIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_EXIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void pthread_exit(void *retval);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_EXIT_H
diff --git a/src/pthread/pthread_getname_np.cpp b/src/pthread/pthread_getname_np.cpp
index 3de8c2e..8df3ae2 100644
--- a/src/pthread/pthread_getname_np.cpp
+++ b/src/pthread/pthread_getname_np.cpp
@@ -11,12 +11,13 @@
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/stringstream.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, pthread_getname_np,
   return thread->get_name(name_stream);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_getname_np.h b/src/pthread/pthread_getname_np.h
index a515737..417bc22 100644
--- a/src/pthread/pthread_getname_np.h
+++ b/src/pthread/pthread_getname_np.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETNAME_NP_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETNAME_NP_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_getname_np(pthread_t, char *, size_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETNAME_NP_H
diff --git a/src/pthread/pthread_getspecific.cpp b/src/pthread/pthread_getspecific.cpp
index 3893b52..eddc026 100644
--- a/src/pthread/pthread_getspecific.cpp
+++ b/src/pthread/pthread_getspecific.cpp
@@ -9,15 +9,16 @@
 #include "pthread_getspecific.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, pthread_getspecific, (pthread_key_t key)) {
   return get_tss_value(key);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_getspecific.h b/src/pthread/pthread_getspecific.h
index 2843983..f491488 100644
--- a/src/pthread/pthread_getspecific.h
+++ b/src/pthread/pthread_getspecific.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETSPECIFIC_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETSPECIFIC_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *pthread_getspecific(pthread_key_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_GETSPECIFIC_H
diff --git a/src/pthread/pthread_join.cpp b/src/pthread/pthread_join.cpp
index 8d4c2dd..78f9965 100644
--- a/src/pthread/pthread_join.cpp
+++ b/src/pthread/pthread_join.cpp
@@ -9,11 +9,12 @@
 #include "pthread_join.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_join, (pthread_t th, void **retval)) {
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_join.h b/src/pthread/pthread_join.h
index 506efae..e430ec3 100644
--- a/src/pthread/pthread_join.h
+++ b/src/pthread/pthread_join.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_JOIN_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_JOIN_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_join(pthread_t thread, void **retval);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_JOIN_H
diff --git a/src/pthread/pthread_key_create.cpp b/src/pthread/pthread_key_create.cpp
index 81c1f39..383762f 100644
--- a/src/pthread/pthread_key_create.cpp
+++ b/src/pthread/pthread_key_create.cpp
@@ -9,12 +9,13 @@
 #include "pthread_key_create.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_key_create,
                    (pthread_key_t * key, __pthread_tss_dtor_t dtor)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, pthread_key_create,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_key_create.h b/src/pthread/pthread_key_create.h
index f12c908..23a861c 100644
--- a/src/pthread/pthread_key_create.h
+++ b/src/pthread/pthread_key_create.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_CREATE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_CREATE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_key_create(pthread_key_t *key, __pthread_tss_dtor_t dtor);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_CREATE_H
diff --git a/src/pthread/pthread_key_delete.cpp b/src/pthread/pthread_key_delete.cpp
index 18a4cc7..b54db82 100644
--- a/src/pthread/pthread_key_delete.cpp
+++ b/src/pthread/pthread_key_delete.cpp
@@ -9,12 +9,13 @@
 #include "pthread_key_delete.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_key_delete, (pthread_key_t key)) {
   if (LIBC_NAMESPACE::tss_key_delete(key))
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, pthread_key_delete, (pthread_key_t key)) {
     return EINVAL;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_key_delete.h b/src/pthread/pthread_key_delete.h
index 5b7e40b..62572ee 100644
--- a/src/pthread/pthread_key_delete.h
+++ b/src/pthread/pthread_key_delete.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_DELETE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_DELETE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_key_delete(pthread_key_t key);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_KEY_DELETE_H
diff --git a/src/pthread/pthread_mutex_destroy.cpp b/src/pthread/pthread_mutex_destroy.cpp
index 65f4b79..4603ebe 100644
--- a/src/pthread/pthread_mutex_destroy.cpp
+++ b/src/pthread/pthread_mutex_destroy.cpp
@@ -9,11 +9,12 @@
 #include "pthread_mutex_destroy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutex_destroy, (pthread_mutex_t * mutex)) {
   auto *m = reinterpret_cast<Mutex *>(mutex);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutex_destroy, (pthread_mutex_t * mutex)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutex_destroy.h b/src/pthread/pthread_mutex_destroy.h
index 2df303e..ebbed18 100644
--- a/src/pthread/pthread_mutex_destroy.h
+++ b/src/pthread/pthread_mutex_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutex_destroy(pthread_mutex_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_DESTROY_H
diff --git a/src/pthread/pthread_mutex_init.cpp b/src/pthread/pthread_mutex_init.cpp
index 3914669..94052e5 100644
--- a/src/pthread/pthread_mutex_init.cpp
+++ b/src/pthread/pthread_mutex_init.cpp
@@ -10,12 +10,12 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(Mutex) <= sizeof(pthread_mutex_t),
               "The public pthread_mutex_t type cannot accommodate the internal "
@@ -33,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutex_init,
   return err == MutexError::NONE ? 0 : EAGAIN;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutex_init.h b/src/pthread/pthread_mutex_init.h
index e6b5a0a..8e3ba60 100644
--- a/src/pthread/pthread_mutex_init.h
+++ b/src/pthread/pthread_mutex_init.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutex_init(pthread_mutex_t *mutex,
                        const pthread_mutexattr_t *__restrict attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_INIT_H
diff --git a/src/pthread/pthread_mutex_lock.cpp b/src/pthread/pthread_mutex_lock.cpp
index efc6f75..1537454 100644
--- a/src/pthread/pthread_mutex_lock.cpp
+++ b/src/pthread/pthread_mutex_lock.cpp
@@ -9,11 +9,12 @@
 #include "pthread_mutex_lock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The implementation currently handles only plain mutexes.
 LLVM_LIBC_FUNCTION(int, pthread_mutex_lock, (pthread_mutex_t * mutex)) {
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutex_lock, (pthread_mutex_t * mutex)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutex_lock.h b/src/pthread/pthread_mutex_lock.h
index c5a835e..a83ae2c 100644
--- a/src/pthread/pthread_mutex_lock.h
+++ b/src/pthread/pthread_mutex_lock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_LOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_LOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutex_lock(pthread_mutex_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_LOCK_H
diff --git a/src/pthread/pthread_mutex_unlock.cpp b/src/pthread/pthread_mutex_unlock.cpp
index b0819bd..de4d2cb 100644
--- a/src/pthread/pthread_mutex_unlock.cpp
+++ b/src/pthread/pthread_mutex_unlock.cpp
@@ -9,11 +9,12 @@
 #include "pthread_mutex_unlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The implementation currently handles only plain mutexes.
 LLVM_LIBC_FUNCTION(int, pthread_mutex_unlock, (pthread_mutex_t * mutex)) {
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutex_unlock, (pthread_mutex_t * mutex)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutex_unlock.h b/src/pthread/pthread_mutex_unlock.h
index 303ec00..a3d661a 100644
--- a/src/pthread/pthread_mutex_unlock.h
+++ b/src/pthread/pthread_mutex_unlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_UNLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_UNLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutex_unlock(pthread_mutex_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEX_UNLOCK_H
diff --git a/src/pthread/pthread_mutexattr.h b/src/pthread/pthread_mutexattr.h
index 292ceeb..be719b9 100644
--- a/src/pthread/pthread_mutexattr.h
+++ b/src/pthread/pthread_mutexattr.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 enum class PThreadMutexAttrPos : unsigned int {
   TYPE_SHIFT = 0,
@@ -48,6 +49,6 @@ LIBC_INLINE int get_mutexattr_pshared(pthread_mutexattr_t attr) {
          unsigned(PThreadMutexAttrPos::PSHARED_SHIFT);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_H
diff --git a/src/pthread/pthread_mutexattr_destroy.cpp b/src/pthread/pthread_mutexattr_destroy.cpp
index 9722d2b..bddeb8b 100644
--- a/src/pthread/pthread_mutexattr_destroy.cpp
+++ b/src/pthread/pthread_mutexattr_destroy.cpp
@@ -10,13 +10,12 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_destroy, (pthread_mutexattr_t *)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_destroy.h b/src/pthread/pthread_mutexattr_destroy.h
index 32a8b94..815145a 100644
--- a/src/pthread/pthread_mutexattr_destroy.h
+++ b/src/pthread/pthread_mutexattr_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_DESTROY_H
diff --git a/src/pthread/pthread_mutexattr_getpshared.cpp b/src/pthread/pthread_mutexattr_getpshared.cpp
index a89af08..0ea5d42 100644
--- a/src/pthread/pthread_mutexattr_getpshared.cpp
+++ b/src/pthread/pthread_mutexattr_getpshared.cpp
@@ -10,10 +10,9 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_getpshared,
                    (const pthread_mutexattr_t *__restrict attr,
@@ -23,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_getpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_getpshared.h b/src/pthread/pthread_mutexattr_getpshared.h
index 843fa36..31b204a 100644
--- a/src/pthread/pthread_mutexattr_getpshared.h
+++ b/src/pthread/pthread_mutexattr_getpshared.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETPSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETPSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict attr,
                                  int *__restrict pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETPSHARED_H
diff --git a/src/pthread/pthread_mutexattr_getrobust.cpp b/src/pthread/pthread_mutexattr_getrobust.cpp
index 9c54b07..b2359e0 100644
--- a/src/pthread/pthread_mutexattr_getrobust.cpp
+++ b/src/pthread/pthread_mutexattr_getrobust.cpp
@@ -10,10 +10,9 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_getrobust,
                    (const pthread_mutexattr_t *__restrict attr,
@@ -23,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_getrobust,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_getrobust.h b/src/pthread/pthread_mutexattr_getrobust.h
index 5ef2b92..c968f54 100644
--- a/src/pthread/pthread_mutexattr_getrobust.h
+++ b/src/pthread/pthread_mutexattr_getrobust.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETROBUST_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETROBUST_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict attr,
                                 int *__restrict robust);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETROBUST_H
diff --git a/src/pthread/pthread_mutexattr_gettype.cpp b/src/pthread/pthread_mutexattr_gettype.cpp
index c54396e..0bd226e 100644
--- a/src/pthread/pthread_mutexattr_gettype.cpp
+++ b/src/pthread/pthread_mutexattr_gettype.cpp
@@ -10,10 +10,9 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_gettype,
                    (const pthread_mutexattr_t *__restrict attr,
@@ -23,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_gettype,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_gettype.h b/src/pthread/pthread_mutexattr_gettype.h
index b0e7c6e..67562b3 100644
--- a/src/pthread/pthread_mutexattr_gettype.h
+++ b/src/pthread/pthread_mutexattr_gettype.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETTYPE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETTYPE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict attr,
                               int *__restrict type);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_GETTYPE_H
diff --git a/src/pthread/pthread_mutexattr_init.cpp b/src/pthread/pthread_mutexattr_init.cpp
index 439d198..7f0ce0b 100644
--- a/src/pthread/pthread_mutexattr_init.cpp
+++ b/src/pthread/pthread_mutexattr_init.cpp
@@ -10,8 +10,9 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_init, (pthread_mutexattr_t * attr)) {
   // Set the default attributes and mark the attribute object as initiliazed
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_init, (pthread_mutexattr_t * attr)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_init.h b/src/pthread/pthread_mutexattr_init.h
index 13de2e5..fdcd347 100644
--- a/src/pthread/pthread_mutexattr_init.h
+++ b/src/pthread/pthread_mutexattr_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_init(pthread_mutexattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_INIT_H
diff --git a/src/pthread/pthread_mutexattr_setpshared.cpp b/src/pthread/pthread_mutexattr_setpshared.cpp
index f654d33..deeae15 100644
--- a/src/pthread/pthread_mutexattr_setpshared.cpp
+++ b/src/pthread/pthread_mutexattr_setpshared.cpp
@@ -10,11 +10,12 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_setpshared,
                    (pthread_mutexattr_t *__restrict attr, int pshared)) {
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_setpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_setpshared.h b/src/pthread/pthread_mutexattr_setpshared.h
index 0726b77..6a04cd9 100644
--- a/src/pthread/pthread_mutexattr_setpshared.h
+++ b/src/pthread/pthread_mutexattr_setpshared.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETPSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETPSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_setpshared(pthread_mutexattr_t *__restrict attr,
                                  int pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETPSHARED_H
diff --git a/src/pthread/pthread_mutexattr_setrobust.cpp b/src/pthread/pthread_mutexattr_setrobust.cpp
index 15fdac6..9fd46f4 100644
--- a/src/pthread/pthread_mutexattr_setrobust.cpp
+++ b/src/pthread/pthread_mutexattr_setrobust.cpp
@@ -10,11 +10,12 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_setrobust,
                    (pthread_mutexattr_t *__restrict attr, int robust)) {
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_setrobust,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_setrobust.h b/src/pthread/pthread_mutexattr_setrobust.h
index 8361a14..62f0d05 100644
--- a/src/pthread/pthread_mutexattr_setrobust.h
+++ b/src/pthread/pthread_mutexattr_setrobust.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETROBUST_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETROBUST_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_setrobust(pthread_mutexattr_t *__restrict attr,
                                 int robust);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETROBUST_H
diff --git a/src/pthread/pthread_mutexattr_settype.cpp b/src/pthread/pthread_mutexattr_settype.cpp
index d5514a1..c7e7827 100644
--- a/src/pthread/pthread_mutexattr_settype.cpp
+++ b/src/pthread/pthread_mutexattr_settype.cpp
@@ -10,11 +10,12 @@
 #include "pthread_mutexattr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_mutexattr_settype,
                    (pthread_mutexattr_t *__restrict attr, int type)) {
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, pthread_mutexattr_settype,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_mutexattr_settype.h b/src/pthread/pthread_mutexattr_settype.h
index 8ad3285..1507919 100644
--- a/src/pthread/pthread_mutexattr_settype.h
+++ b/src/pthread/pthread_mutexattr_settype.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETTYPE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETTYPE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_mutexattr_settype(pthread_mutexattr_t *__restrict attr, int type);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_MUTEXATTR_SETTYPE_H
diff --git a/src/pthread/pthread_once.cpp b/src/pthread/pthread_once.cpp
index 0e0045e..d78644a 100644
--- a/src/pthread/pthread_once.cpp
+++ b/src/pthread/pthread_once.cpp
@@ -8,11 +8,12 @@
 
 #include "pthread_once.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/callonce.h"
 
 #include <pthread.h> // For pthread_once_t and __pthread_once_func_t definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_once,
                    (pthread_once_t * flag, __pthread_once_func_t func)) {
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, pthread_once,
                   reinterpret_cast<CallOnceCallback *>(func));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_once.h b/src/pthread/pthread_once.h
index 25ee70a..0e9af00 100644
--- a/src/pthread/pthread_once.h
+++ b/src/pthread/pthread_once.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_ONCE_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_ONCE_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_once(pthread_once_t *flag, __pthread_once_func_t func);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_ONCE_H
diff --git a/src/pthread/pthread_rwlock_clockrdlock.cpp b/src/pthread/pthread_rwlock_clockrdlock.cpp
new file mode 100644
index 0000000..1e44e6d
--- /dev/null
+++ b/src/pthread/pthread_rwlock_clockrdlock.cpp
@@ -0,0 +1,50 @@
+//===-- Implementation of the Rwlock's clockrdlock function ---------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_rwlock_clockrdlock.h"
+
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/threads/linux/rwlock.h"
+
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(
+    sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
+        alignof(RwLock) == alignof(pthread_rwlock_t),
+    "The public pthread_rwlock_t type must be of the same size and alignment "
+    "as the internal rwlock type.");
+
+LLVM_LIBC_FUNCTION(int, pthread_rwlock_clockrdlock,
+                   (pthread_rwlock_t * rwlock, clockid_t clockid,
+                    const timespec *abstime)) {
+  if (!rwlock)
+    return EINVAL;
+  if (clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME)
+    return EINVAL;
+  bool is_realtime = (clockid == CLOCK_REALTIME);
+  RwLock *rw = reinterpret_cast<RwLock *>(rwlock);
+  LIBC_ASSERT(abstime && "clockrdlock called with a null timeout");
+  auto timeout = internal::AbsTimeout::from_timespec(
+      *abstime, /*is_realtime=*/is_realtime);
+  if (LIBC_LIKELY(timeout.has_value()))
+    return static_cast<int>(rw->read_lock(timeout.value()));
+
+  switch (timeout.error()) {
+  case internal::AbsTimeout::Error::Invalid:
+    return EINVAL;
+  case internal::AbsTimeout::Error::BeforeEpoch:
+    return ETIMEDOUT;
+  }
+  __builtin_unreachable();
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_clockrdlock.h b/src/pthread/pthread_rwlock_clockrdlock.h
new file mode 100644
index 0000000..8fbd3b0
--- /dev/null
+++ b/src/pthread/pthread_rwlock_clockrdlock.h
@@ -0,0 +1,23 @@
+//===-- Implementation header for Rwlock's clockrdlock function --*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKRDLOCK_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKRDLOCK_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict rwlock,
+                               clockid_t clockid,
+                               const timespec *__restrict abstime);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKRDLOCK_H
diff --git a/src/pthread/pthread_rwlock_clockwrlock.cpp b/src/pthread/pthread_rwlock_clockwrlock.cpp
new file mode 100644
index 0000000..8f58c7f
--- /dev/null
+++ b/src/pthread/pthread_rwlock_clockwrlock.cpp
@@ -0,0 +1,51 @@
+//===-- Implementation of the Rwlock's clockwrlock function----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_rwlock_clockwrlock.h"
+
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/threads/linux/rwlock.h"
+#include "src/__support/time/linux/abs_timeout.h"
+
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(
+    sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
+        alignof(RwLock) == alignof(pthread_rwlock_t),
+    "The public pthread_rwlock_t type must be of the same size and alignment "
+    "as the internal rwlock type.");
+
+LLVM_LIBC_FUNCTION(int, pthread_rwlock_clockwrlock,
+                   (pthread_rwlock_t * rwlock, clockid_t clockid,
+                    const timespec *abstime)) {
+  if (!rwlock)
+    return EINVAL;
+  if (clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME)
+    return EINVAL;
+  bool is_realtime = (clockid == CLOCK_REALTIME);
+  RwLock *rw = reinterpret_cast<RwLock *>(rwlock);
+  LIBC_ASSERT(abstime && "clockwrlock called with a null timeout");
+  auto timeout = internal::AbsTimeout::from_timespec(
+      *abstime, /*is_realtime=*/is_realtime);
+  if (LIBC_LIKELY(timeout.has_value()))
+    return static_cast<int>(rw->write_lock(timeout.value()));
+
+  switch (timeout.error()) {
+  case internal::AbsTimeout::Error::Invalid:
+    return EINVAL;
+  case internal::AbsTimeout::Error::BeforeEpoch:
+    return ETIMEDOUT;
+  }
+  __builtin_unreachable();
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_clockwrlock.h b/src/pthread/pthread_rwlock_clockwrlock.h
new file mode 100644
index 0000000..cb3fa39
--- /dev/null
+++ b/src/pthread/pthread_rwlock_clockwrlock.h
@@ -0,0 +1,23 @@
+//===-- Implementation header for Rwlock's clockwrlock function --*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKWRLOCK_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKWRLOCK_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict rwlock,
+                               clockid_t clockid,
+                               const timespec *__restrict abstime);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_CLOCKWRLOCK_H
diff --git a/src/pthread/pthread_rwlock_destroy.cpp b/src/pthread/pthread_rwlock_destroy.cpp
index d82bb37..afc5622 100644
--- a/src/pthread/pthread_rwlock_destroy.cpp
+++ b/src/pthread/pthread_rwlock_destroy.cpp
@@ -9,12 +9,12 @@
 #include "src/pthread/pthread_rwlock_destroy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlock_destroy, (pthread_rwlock_t * rwlock)) {
   if (!rwlock)
@@ -30,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_destroy, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(res);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_destroy.h b/src/pthread/pthread_rwlock_destroy.h
index f845e80..892a049 100644
--- a/src/pthread/pthread_rwlock_destroy.h
+++ b/src/pthread/pthread_rwlock_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_DESTROY_H
diff --git a/src/pthread/pthread_rwlock_init.cpp b/src/pthread/pthread_rwlock_init.cpp
index b1b58aa..dc5424c 100644
--- a/src/pthread/pthread_rwlock_init.cpp
+++ b/src/pthread/pthread_rwlock_init.cpp
@@ -11,12 +11,12 @@
 #include "src/__support/CPP/new.h"
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -64,4 +64,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_init,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_init.h b/src/pthread/pthread_rwlock_init.h
index 78d2934..dbd6443 100644
--- a/src/pthread/pthread_rwlock_init.h
+++ b/src/pthread/pthread_rwlock_init.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_init(pthread_rwlock_t *rwlock,
                         const pthread_rwlockattr_t *__restrict attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_INIT_H
diff --git a/src/pthread/pthread_rwlock_rdlock.cpp b/src/pthread/pthread_rwlock_rdlock.cpp
index e9aee5d..7dee8eb 100644
--- a/src/pthread/pthread_rwlock_rdlock.cpp
+++ b/src/pthread/pthread_rwlock_rdlock.cpp
@@ -9,12 +9,12 @@
 #include "src/pthread/pthread_rwlock_rdlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -29,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_rdlock, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(rw->read_lock());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_rdlock.h b/src/pthread/pthread_rwlock_rdlock.h
index 7902773..f5c0c26 100644
--- a/src/pthread/pthread_rwlock_rdlock.h
+++ b/src/pthread/pthread_rwlock_rdlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_RDLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_RDLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_RDLOCK_H
diff --git a/src/pthread/pthread_rwlock_timedrdlock.cpp b/src/pthread/pthread_rwlock_timedrdlock.cpp
index 6ce69ea..112ff5c 100644
--- a/src/pthread/pthread_rwlock_timedrdlock.cpp
+++ b/src/pthread/pthread_rwlock_timedrdlock.cpp
@@ -7,17 +7,17 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/pthread/pthread_rwlock_timedrdlock.h"
-
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/threads/linux/rwlock.h"
 #include "src/__support/time/linux/abs_timeout.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -46,4 +46,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_timedrdlock,
   __builtin_unreachable();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_timedrdlock.h b/src/pthread/pthread_rwlock_timedrdlock.h
index dfa43f2..d6c67dc 100644
--- a/src/pthread/pthread_rwlock_timedrdlock.h
+++ b/src/pthread/pthread_rwlock_timedrdlock.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDRDLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDRDLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict rwlock,
                                const struct timespec *__restrict abs_timeout);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDRDLOCK_H
diff --git a/src/pthread/pthread_rwlock_timedwrlock.cpp b/src/pthread/pthread_rwlock_timedwrlock.cpp
index ad3f913..d2dc70e 100644
--- a/src/pthread/pthread_rwlock_timedwrlock.cpp
+++ b/src/pthread/pthread_rwlock_timedwrlock.cpp
@@ -10,14 +10,14 @@
 
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/threads/linux/rwlock.h"
 #include "src/__support/time/linux/abs_timeout.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlock_timedwrlock,
                    (pthread_rwlock_t *__restrict rwlock,
@@ -40,4 +40,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_timedwrlock,
   __builtin_unreachable();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_timedwrlock.h b/src/pthread/pthread_rwlock_timedwrlock.h
index a39d8de..995d80c 100644
--- a/src/pthread/pthread_rwlock_timedwrlock.h
+++ b/src/pthread/pthread_rwlock_timedwrlock.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDWRLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDWRLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict rwlock,
                                const struct timespec *__restrict abs_timeout);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TIMEDWRLOCK_H
diff --git a/src/pthread/pthread_rwlock_tryrdlock.cpp b/src/pthread/pthread_rwlock_tryrdlock.cpp
index 9dc1bf0..d54b57f 100644
--- a/src/pthread/pthread_rwlock_tryrdlock.cpp
+++ b/src/pthread/pthread_rwlock_tryrdlock.cpp
@@ -9,12 +9,12 @@
 #include "src/pthread/pthread_rwlock_tryrdlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -29,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_tryrdlock, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(rw->try_read_lock());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_tryrdlock.h b/src/pthread/pthread_rwlock_tryrdlock.h
index b07ab5b..10ef7af 100644
--- a/src/pthread/pthread_rwlock_tryrdlock.h
+++ b/src/pthread/pthread_rwlock_tryrdlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYRDLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYRDLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYRDLOCK_H
diff --git a/src/pthread/pthread_rwlock_trywrlock.cpp b/src/pthread/pthread_rwlock_trywrlock.cpp
index e4ace3c..a63dc89 100644
--- a/src/pthread/pthread_rwlock_trywrlock.cpp
+++ b/src/pthread/pthread_rwlock_trywrlock.cpp
@@ -9,12 +9,13 @@
 #include "src/pthread/pthread_rwlock_trywrlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_trywrlock, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(rw->try_write_lock());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_trywrlock.h b/src/pthread/pthread_rwlock_trywrlock.h
index fc146c6..df185b0 100644
--- a/src/pthread/pthread_rwlock_trywrlock.h
+++ b/src/pthread/pthread_rwlock_trywrlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYWRLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYWRLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_TRYWRLOCK_H
diff --git a/src/pthread/pthread_rwlock_unlock.cpp b/src/pthread/pthread_rwlock_unlock.cpp
index 21cedf4..e612901 100644
--- a/src/pthread/pthread_rwlock_unlock.cpp
+++ b/src/pthread/pthread_rwlock_unlock.cpp
@@ -9,12 +9,13 @@
 #include "src/pthread/pthread_rwlock_unlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlock_unlock, (pthread_rwlock_t * rwlock)) {
   if (!rwlock)
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_unlock, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(rw->unlock());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_unlock.h b/src/pthread/pthread_rwlock_unlock.h
index b9a72f1..d416f8d 100644
--- a/src/pthread/pthread_rwlock_unlock.h
+++ b/src/pthread/pthread_rwlock_unlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_UNLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_UNLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_UNLOCK_H
diff --git a/src/pthread/pthread_rwlock_wrlock.cpp b/src/pthread/pthread_rwlock_wrlock.cpp
index 5d3868a..f02fb6b 100644
--- a/src/pthread/pthread_rwlock_wrlock.cpp
+++ b/src/pthread/pthread_rwlock_wrlock.cpp
@@ -9,12 +9,12 @@
 #include "src/pthread/pthread_rwlock_wrlock.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/rwlock.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(
     sizeof(RwLock) == sizeof(pthread_rwlock_t) &&
@@ -29,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlock_wrlock, (pthread_rwlock_t * rwlock)) {
   return static_cast<int>(rw->write_lock());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlock_wrlock.h b/src/pthread/pthread_rwlock_wrlock.h
index ba77c1f..662c347 100644
--- a/src/pthread/pthread_rwlock_wrlock.h
+++ b/src/pthread/pthread_rwlock_wrlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_WRLOCK_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_WRLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCK_WRLOCK_H
diff --git a/src/pthread/pthread_rwlockattr_destroy.cpp b/src/pthread/pthread_rwlockattr_destroy.cpp
index e3ca751..b86cd11 100644
--- a/src/pthread/pthread_rwlockattr_destroy.cpp
+++ b/src/pthread/pthread_rwlockattr_destroy.cpp
@@ -9,10 +9,11 @@
 #include "pthread_rwlockattr_destroy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h> // pthread_rwlockattr_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_destroy,
                    (pthread_rwlockattr_t * attr [[gnu::unused]])) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_destroy,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_destroy.h b/src/pthread/pthread_rwlockattr_destroy.h
index 5904d6b..1de3d9e 100644
--- a/src/pthread/pthread_rwlockattr_destroy.h
+++ b/src/pthread/pthread_rwlockattr_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_DESTROY_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_DESTROY_H
diff --git a/src/pthread/pthread_rwlockattr_getkind_np.cpp b/src/pthread/pthread_rwlockattr_getkind_np.cpp
index 0c82179..9c034cf 100644
--- a/src/pthread/pthread_rwlockattr_getkind_np.cpp
+++ b/src/pthread/pthread_rwlockattr_getkind_np.cpp
@@ -9,10 +9,11 @@
 #include "pthread_rwlockattr_getkind_np.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h> // pthread_rwlockattr_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_getkind_np,
                    (const pthread_rwlockattr_t *__restrict attr,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_getkind_np,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_getkind_np.h b/src/pthread/pthread_rwlockattr_getkind_np.h
index 51f633c..5feeeb2 100644
--- a/src/pthread/pthread_rwlockattr_getkind_np.h
+++ b/src/pthread/pthread_rwlockattr_getkind_np.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETKIND_NP_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETKIND_NP_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict attr,
                                   int *__restrict pref);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETKIND_NP_H
diff --git a/src/pthread/pthread_rwlockattr_getpshared.cpp b/src/pthread/pthread_rwlockattr_getpshared.cpp
index 0dad230..0943e33 100644
--- a/src/pthread/pthread_rwlockattr_getpshared.cpp
+++ b/src/pthread/pthread_rwlockattr_getpshared.cpp
@@ -9,10 +9,11 @@
 #include "pthread_rwlockattr_getpshared.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h> // pthread_rwlockattr_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_getpshared,
                    (const pthread_rwlockattr_t *attr, int *pshared)) {
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_getpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_getpshared.h b/src/pthread/pthread_rwlockattr_getpshared.h
index 64843e5..77fd767 100644
--- a/src/pthread/pthread_rwlockattr_getpshared.h
+++ b/src/pthread/pthread_rwlockattr_getpshared.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETPSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETPSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr,
                                   int *pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_GETPSHARED_H
diff --git a/src/pthread/pthread_rwlockattr_init.cpp b/src/pthread/pthread_rwlockattr_init.cpp
index bbc8955..3ff1041 100644
--- a/src/pthread/pthread_rwlockattr_init.cpp
+++ b/src/pthread/pthread_rwlockattr_init.cpp
@@ -9,10 +9,11 @@
 #include "pthread_rwlockattr_init.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <pthread.h> // pthread_rwlockattr_t, PTHREAD_PROCESS_PRIVATE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_init,
                    (pthread_rwlockattr_t * attr)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_init,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_init.h b/src/pthread/pthread_rwlockattr_init.h
index 30ae499..c2e525f 100644
--- a/src/pthread/pthread_rwlockattr_init.h
+++ b/src/pthread/pthread_rwlockattr_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_INIT_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_INIT_H
diff --git a/src/pthread/pthread_rwlockattr_setkind_np.cpp b/src/pthread/pthread_rwlockattr_setkind_np.cpp
index 47fbf2a..80d34a3 100644
--- a/src/pthread/pthread_rwlockattr_setkind_np.cpp
+++ b/src/pthread/pthread_rwlockattr_setkind_np.cpp
@@ -9,11 +9,12 @@
 #include "pthread_rwlockattr_setkind_np.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h> // pthread_rwlockattr_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_setkind_np,
                    (pthread_rwlockattr_t * attr, int pref)) {
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_setkind_np,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_setkind_np.h b/src/pthread/pthread_rwlockattr_setkind_np.h
index 00ef8e1..cea5566 100644
--- a/src/pthread/pthread_rwlockattr_setkind_np.h
+++ b/src/pthread/pthread_rwlockattr_setkind_np.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETKIND_NP_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETKIND_NP_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETKIND_NP_H
diff --git a/src/pthread/pthread_rwlockattr_setpshared.cpp b/src/pthread/pthread_rwlockattr_setpshared.cpp
index 6bcba7c..5a7191a 100644
--- a/src/pthread/pthread_rwlockattr_setpshared.cpp
+++ b/src/pthread/pthread_rwlockattr_setpshared.cpp
@@ -9,11 +9,12 @@
 #include "pthread_rwlockattr_setpshared.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h> // EINVAL
 #include <pthread.h> // pthread_rwlockattr_t, PTHREAD_PROCESS_SHARED, PTHREAD_PROCESS_PRIVATE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_setpshared,
                    (pthread_rwlockattr_t * attr, int pshared)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_rwlockattr_setpshared,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_rwlockattr_setpshared.h b/src/pthread/pthread_rwlockattr_setpshared.h
index 393c07d..6905865 100644
--- a/src/pthread/pthread_rwlockattr_setpshared.h
+++ b/src/pthread/pthread_rwlockattr_setpshared.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETPSHARED_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETPSHARED_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_RWLOCKATTR_SETPSHARED_H
diff --git a/src/pthread/pthread_self.cpp b/src/pthread/pthread_self.cpp
index 3e74f96..c3169ec 100644
--- a/src/pthread/pthread_self.cpp
+++ b/src/pthread/pthread_self.cpp
@@ -9,11 +9,12 @@
 #include "pthread_self.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h> // For pthread_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(pthread_t, pthread_self, ()) {
   return th;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_self.h b/src/pthread/pthread_self.h
index 058072e..4edb566 100644
--- a/src/pthread/pthread_self.h
+++ b/src/pthread/pthread_self.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SELF_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SELF_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pthread_t pthread_self();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SELF_H
diff --git a/src/pthread/pthread_setname_np.cpp b/src/pthread/pthread_setname_np.cpp
index e211d7e..785a96a 100644
--- a/src/pthread/pthread_setname_np.cpp
+++ b/src/pthread/pthread_setname_np.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(pthread_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between pthread_t and internal Thread.");
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_setname_np, (pthread_t th, const char *name)) {
   return thread->set_name(cpp::string_view(name));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_setname_np.h b/src/pthread/pthread_setname_np.h
index e240425..6dc6bfb 100644
--- a/src/pthread/pthread_setname_np.h
+++ b/src/pthread/pthread_setname_np.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETNAME_NP_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETNAME_NP_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_setname_np(pthread_t, const char *name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETNAME_NP_H
diff --git a/src/pthread/pthread_setspecific.cpp b/src/pthread/pthread_setspecific.cpp
index e9b23d8..70c29c1 100644
--- a/src/pthread/pthread_setspecific.cpp
+++ b/src/pthread/pthread_setspecific.cpp
@@ -9,12 +9,13 @@
 #include "pthread_setspecific.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pthread_setspecific,
                    (pthread_key_t key, const void *data)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, pthread_setspecific,
     return EINVAL;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_setspecific.h b/src/pthread/pthread_setspecific.h
index af9a890..2a85968 100644
--- a/src/pthread/pthread_setspecific.h
+++ b/src/pthread/pthread_setspecific.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETSPECIFIC_H
 #define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETSPECIFIC_H
 
+#include "src/__support/macros/config.h"
 #include <pthread.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int pthread_setspecific(pthread_key_t, const void *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SETSPECIFIC_H
diff --git a/src/pthread/pthread_spin_destroy.cpp b/src/pthread/pthread_spin_destroy.cpp
new file mode 100644
index 0000000..7d93dd9
--- /dev/null
+++ b/src/pthread/pthread_spin_destroy.cpp
@@ -0,0 +1,47 @@
+//===-- Implementation of pthread_spin_destroy function -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_spin_destroy.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/spin_lock.h"
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(sizeof(pthread_spinlock_t::__lockword) == sizeof(SpinLock) &&
+                  alignof(decltype(pthread_spinlock_t::__lockword)) ==
+                      alignof(SpinLock),
+              "pthread_spinlock_t::__lockword and SpinLock must be of the same "
+              "size and alignment");
+
+LLVM_LIBC_FUNCTION(int, pthread_spin_destroy,
+                   ([[maybe_unused]] pthread_spinlock_t * lock)) {
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_lock() or pthread_spin_trylock() does not refer to an
+  // initialized spin lock object, it is recommended that the function should
+  // fail and report an [EINVAL] error.
+  if (!lock)
+    return EINVAL;
+  auto spin_lock = reinterpret_cast<SpinLock *>(&lock->__lockword);
+  if (!spin_lock || spin_lock->is_invalid())
+    return EINVAL;
+
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_destroy() or pthread_spin_init() refers to a locked spin
+  // lock object, or detects that the value specified by the lock argument to
+  // pthread_spin_init() refers to an already initialized spin lock object, it
+  // is recommended that the function should fail and report an [EBUSY] error.
+  if (spin_lock->is_locked())
+    return EBUSY;
+
+  // poison the lock
+  spin_lock->~SpinLock();
+  lock->__owner = 0;
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_spin_destroy.h b/src/pthread/pthread_spin_destroy.h
new file mode 100644
index 0000000..2581e9e
--- /dev/null
+++ b/src/pthread/pthread_spin_destroy.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for pthread_spin_destroy function --*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_DESTROY_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_DESTROY_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_spin_destroy(pthread_spinlock_t *lock);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_DESTROY_H
diff --git a/src/pthread/pthread_spin_init.cpp b/src/pthread/pthread_spin_init.cpp
new file mode 100644
index 0000000..5497247
--- /dev/null
+++ b/src/pthread/pthread_spin_init.cpp
@@ -0,0 +1,37 @@
+//===-- Implementation of pthread_spin_init function ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_spin_init.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/CPP/new.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/spin_lock.h"
+#include <pthread.h> // for PTHREAD_PROCESS_SHARED, PTHREAD_PROCESS_PRIVATE
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(sizeof(pthread_spinlock_t::__lockword) == sizeof(SpinLock) &&
+                  alignof(decltype(pthread_spinlock_t::__lockword)) ==
+                      alignof(SpinLock),
+              "pthread_spinlock_t::__lockword and SpinLock must be of the same "
+              "size and alignment");
+
+LLVM_LIBC_FUNCTION(int, pthread_spin_init,
+                   (pthread_spinlock_t * lock, [[maybe_unused]] int pshared)) {
+  if (!lock)
+    return EINVAL;
+  if (pshared != PTHREAD_PROCESS_SHARED && pshared != PTHREAD_PROCESS_PRIVATE)
+    return EINVAL;
+  // The spin lock here is a simple atomic flag, so we don't need to do any
+  // special handling for pshared.
+  ::new (&lock->__lockword) SpinLock();
+  lock->__owner = 0;
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_spin_init.h b/src/pthread/pthread_spin_init.h
new file mode 100644
index 0000000..89f7e3a
--- /dev/null
+++ b/src/pthread/pthread_spin_init.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for pthread_spin_init function ---*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_INIT_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_INIT_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_INIT_H
diff --git a/src/pthread/pthread_spin_lock.cpp b/src/pthread/pthread_spin_lock.cpp
new file mode 100644
index 0000000..61c8db1
--- /dev/null
+++ b/src/pthread/pthread_spin_lock.cpp
@@ -0,0 +1,47 @@
+//===-- Implementation of pthread_spin_lock function ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_spin_lock.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/identifier.h"
+#include "src/__support/threads/spin_lock.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(sizeof(pthread_spinlock_t::__lockword) == sizeof(SpinLock) &&
+                  alignof(decltype(pthread_spinlock_t::__lockword)) ==
+                      alignof(SpinLock),
+              "pthread_spinlock_t::__lockword and SpinLock must be of the same "
+              "size and alignment");
+
+LLVM_LIBC_FUNCTION(int, pthread_spin_lock, (pthread_spinlock_t * lock)) {
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_lock() or pthread_spin_trylock() does not refer to an
+  // initialized spin lock object, it is recommended that the function should
+  // fail and report an [EINVAL] error.
+  if (!lock)
+    return EINVAL;
+  auto spin_lock = reinterpret_cast<SpinLock *>(&lock->__lockword);
+  if (spin_lock->is_invalid())
+    return EINVAL;
+
+  pid_t self_tid = internal::gettid();
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_lock() refers to a spin lock object for which the calling
+  // thread already holds the lock, it is recommended that the function should
+  // fail and report an [EDEADLK] error.
+  if (lock->__owner == self_tid)
+    return EDEADLK;
+
+  spin_lock->lock();
+  lock->__owner = self_tid;
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_spin_lock.h b/src/pthread/pthread_spin_lock.h
new file mode 100644
index 0000000..835aa85
--- /dev/null
+++ b/src/pthread/pthread_spin_lock.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for pthread_spin_lock function ---*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_LOCK_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_LOCK_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_spin_lock(pthread_spinlock_t *lock);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_LOCK_H
diff --git a/src/pthread/pthread_spin_trylock.cpp b/src/pthread/pthread_spin_trylock.cpp
new file mode 100644
index 0000000..99b0eac
--- /dev/null
+++ b/src/pthread/pthread_spin_trylock.cpp
@@ -0,0 +1,41 @@
+//===-- Implementation of pthread_spin_trylock function -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_spin_trylock.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/identifier.h"
+#include "src/__support/threads/spin_lock.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(sizeof(pthread_spinlock_t::__lockword) == sizeof(SpinLock) &&
+                  alignof(decltype(pthread_spinlock_t::__lockword)) ==
+                      alignof(SpinLock),
+              "pthread_spinlock_t::__lockword and SpinLock must be of the same "
+              "size and alignment");
+
+LLVM_LIBC_FUNCTION(int, pthread_spin_trylock, (pthread_spinlock_t * lock)) {
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_lock() or pthread_spin_trylock() does not refer to an
+  // initialized spin lock object, it is recommended that the function should
+  // fail and report an [EINVAL] error.
+  if (!lock)
+    return EINVAL;
+  auto spin_lock = reinterpret_cast<SpinLock *>(&lock->__lockword);
+  if (!spin_lock || spin_lock->is_invalid())
+    return EINVAL;
+  // Try to acquire the lock without blocking.
+  if (!spin_lock->try_lock())
+    return EBUSY;
+  // We have acquired the lock. Update the owner field.
+  lock->__owner = internal::gettid();
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_spin_trylock.h b/src/pthread/pthread_spin_trylock.h
new file mode 100644
index 0000000..e175ab8
--- /dev/null
+++ b/src/pthread/pthread_spin_trylock.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for pthread_spin_trylock function ---*- C++
+//-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_TRYLOCK_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_TRYLOCK_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_spin_trylock(pthread_spinlock_t *lock);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_TRYLOCK_H
diff --git a/src/pthread/pthread_spin_unlock.cpp b/src/pthread/pthread_spin_unlock.cpp
new file mode 100644
index 0000000..a02f2b3
--- /dev/null
+++ b/src/pthread/pthread_spin_unlock.cpp
@@ -0,0 +1,44 @@
+//===-- Implementation of pthread_spin_unlock function --------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/pthread/pthread_spin_unlock.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/identifier.h"
+#include "src/__support/threads/spin_lock.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+static_assert(sizeof(pthread_spinlock_t::__lockword) == sizeof(SpinLock) &&
+                  alignof(decltype(pthread_spinlock_t::__lockword)) ==
+                      alignof(SpinLock),
+              "pthread_spinlock_t::__lockword and SpinLock must be of the same "
+              "size and alignment");
+
+LLVM_LIBC_FUNCTION(int, pthread_spin_unlock, (pthread_spinlock_t * lock)) {
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_lock() or pthread_spin_trylock() does not refer to an
+  // initialized spin lock object, it is recommended that the function should
+  // fail and report an [EINVAL] error.
+  if (!lock)
+    return EINVAL;
+  auto spin_lock = reinterpret_cast<SpinLock *>(&lock->__lockword);
+  if (!spin_lock || spin_lock->is_invalid())
+    return EINVAL;
+  // If an implementation detects that the value specified by the lock argument
+  // to pthread_spin_unlock() refers to a spin lock object for which the current
+  // thread does not hold the lock, it is recommended that the function should
+  // fail and report an [EPERM] error.
+  if (lock->__owner != internal::gettid())
+    return EPERM;
+  // Release the lock.
+  lock->__owner = 0;
+  spin_lock->unlock();
+  return 0;
+}
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/pthread/pthread_spin_unlock.h b/src/pthread/pthread_spin_unlock.h
new file mode 100644
index 0000000..4918613
--- /dev/null
+++ b/src/pthread/pthread_spin_unlock.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for pthread_spin_unlock function ---*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_UNLOCK_H
+#define LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_UNLOCK_H
+
+#include "src/__support/macros/config.h"
+#include <pthread.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pthread_spin_unlock(pthread_spinlock_t *lock);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_PTHREAD_PTHREAD_SPIN_UNLOCK_H
diff --git a/src/sched/linux/sched_get_priority_max.cpp b/src/sched/linux/sched_get_priority_max.cpp
index 0b6537e..77a82c7 100644
--- a/src/sched/linux/sched_get_priority_max.cpp
+++ b/src/sched/linux/sched_get_priority_max.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_get_priority_max, (int policy)) {
   int ret =
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, sched_get_priority_max, (int policy)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_get_priority_min.cpp b/src/sched/linux/sched_get_priority_min.cpp
index 1240a50..fca66a1 100644
--- a/src/sched/linux/sched_get_priority_min.cpp
+++ b/src/sched/linux/sched_get_priority_min.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_get_priority_min, (int policy)) {
   int ret =
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, sched_get_priority_min, (int policy)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_getaffinity.cpp b/src/sched/linux/sched_getaffinity.cpp
index 4765761..7b1fd8c 100644
--- a/src/sched/linux/sched_getaffinity.cpp
+++ b/src/sched/linux/sched_getaffinity.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sched.h>
 #include <stdint.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_getaffinity,
                    (pid_t tid, size_t cpuset_size, cpu_set_t *mask)) {
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, sched_getaffinity,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_getcpucount.cpp b/src/sched/linux/sched_getcpucount.cpp
index a816d92..dbda4b2 100644
--- a/src/sched/linux/sched_getcpucount.cpp
+++ b/src/sched/linux/sched_getcpucount.cpp
@@ -9,11 +9,12 @@
 #include "src/sched/sched_getcpucount.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sched.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, __sched_getcpucount,
                    (size_t cpuset_size, const cpu_set_t *mask)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, __sched_getcpucount,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_getparam.cpp b/src/sched/linux/sched_getparam.cpp
index 64a62c5..75756a6 100644
--- a/src/sched/linux/sched_getparam.cpp
+++ b/src/sched/linux/sched_getparam.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_getparam,
                    (pid_t tid, struct sched_param *param)) {
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, sched_getparam,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_getscheduler.cpp b/src/sched/linux/sched_getscheduler.cpp
index 992a11d..545cda8 100644
--- a/src/sched/linux/sched_getscheduler.cpp
+++ b/src/sched/linux/sched_getscheduler.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_getscheduler, (pid_t tid)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_sched_getscheduler, tid);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, sched_getscheduler, (pid_t tid)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_rr_get_interval.cpp b/src/sched/linux/sched_rr_get_interval.cpp
index 9d7d0e9..1f0ef69 100644
--- a/src/sched/linux/sched_rr_get_interval.cpp
+++ b/src/sched/linux/sched_rr_get_interval.cpp
@@ -10,6 +10,7 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
@@ -18,7 +19,7 @@
 #include <linux/time_types.h> // For __kernel_timespec.
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_rr_get_interval,
                    (pid_t tid, struct timespec *tp)) {
@@ -36,7 +37,7 @@ LLVM_LIBC_FUNCTION(int, sched_rr_get_interval,
                                             tid, &ts32);
     if (ret == 0) {
       tp->tv_sec = ts32.tv_sec;
-      tp->tv_nsec = ts32.tv_nsec;
+      tp->tv_nsec = static_cast<long int>(ts32.tv_nsec);
     }
   } else
     // When tp is a nullptr, we still do the syscall to set ret and errno
@@ -53,4 +54,4 @@ LLVM_LIBC_FUNCTION(int, sched_rr_get_interval,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_setaffinity.cpp b/src/sched/linux/sched_setaffinity.cpp
index 5098942..cad48c2 100644
--- a/src/sched/linux/sched_setaffinity.cpp
+++ b/src/sched/linux/sched_setaffinity.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sched.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_setaffinity,
                    (pid_t tid, size_t cpuset_size, const cpu_set_t *mask)) {
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, sched_setaffinity,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_setparam.cpp b/src/sched/linux/sched_setparam.cpp
index 79acf78..e78e78a 100644
--- a/src/sched/linux/sched_setparam.cpp
+++ b/src/sched/linux/sched_setparam.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_setparam,
                    (pid_t tid, const struct sched_param *param)) {
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, sched_setparam,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_setscheduler.cpp b/src/sched/linux/sched_setscheduler.cpp
index 1c18526..b6b6f66 100644
--- a/src/sched/linux/sched_setscheduler.cpp
+++ b/src/sched/linux/sched_setscheduler.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_setscheduler,
                    (pid_t tid, int policy, const struct sched_param *param)) {
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, sched_setscheduler,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_yield.cpp b/src/sched/linux/sched_yield.cpp
index 6878a37..3de9d0b 100644
--- a/src/sched/linux/sched_yield.cpp
+++ b/src/sched/linux/sched_yield.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sched_yield, ()) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_sched_yield);
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, sched_yield, ()) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/sched_get_priority_max.h b/src/sched/sched_get_priority_max.h
index 01611da..e37bec7 100644
--- a/src/sched/sched_get_priority_max.h
+++ b/src/sched/sched_get_priority_max.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MAX_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MAX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_get_priority_max(int policy);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MAX_H
diff --git a/src/sched/sched_get_priority_min.h b/src/sched/sched_get_priority_min.h
index f4b5d54..691d848 100644
--- a/src/sched/sched_get_priority_min.h
+++ b/src/sched/sched_get_priority_min.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MIN_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MIN_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_get_priority_min(int policy);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GET_PRIORITY_MIN_H
diff --git a/src/sched/sched_getaffinity.h b/src/sched/sched_getaffinity.h
index 2f29b7e..52ec5bc 100644
--- a/src/sched/sched_getaffinity.h
+++ b/src/sched/sched_getaffinity.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GETAFFINITY_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GETAFFINITY_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_getaffinity(pid_t tid, size_t cpuset_size, cpu_set_t *mask);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GETAFFINITY_H
diff --git a/src/sched/sched_getcpucount.h b/src/sched/sched_getcpucount.h
index a0c696f..8f35301 100644
--- a/src/sched/sched_getcpucount.h
+++ b/src/sched/sched_getcpucount.h
@@ -9,15 +9,16 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GETCPUCOUNT_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GETCPUCOUNT_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is for internal use in the CPU_COUNT macro, but since that's a
 // macro and will be applied to client files, this must be a public entrypoint.
 int __sched_getcpucount(size_t cpuset_size, const cpu_set_t *mask);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GETCPUCOUNT_H
diff --git a/src/sched/sched_getparam.h b/src/sched/sched_getparam.h
index 09bed70..e1b2365 100644
--- a/src/sched/sched_getparam.h
+++ b/src/sched/sched_getparam.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GETPARAM_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GETPARAM_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_getparam(pid_t tid, struct sched_param *param);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GETPARAM_H
diff --git a/src/sched/sched_getscheduler.h b/src/sched/sched_getscheduler.h
index 6e4fe06..d29e902 100644
--- a/src/sched/sched_getscheduler.h
+++ b/src/sched/sched_getscheduler.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_GETSCHEDULER_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_GETSCHEDULER_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_getscheduler(pid_t tid);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_GETSCHEDULER_H
diff --git a/src/sched/sched_rr_get_interval.h b/src/sched/sched_rr_get_interval.h
index f9eb2d9..ff09329 100644
--- a/src/sched/sched_rr_get_interval.h
+++ b/src/sched/sched_rr_get_interval.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_RR_GET_INTERVAL_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_RR_GET_INTERVAL_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_rr_get_interval(pid_t tid, struct timespec *tp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_RR_GET_INTERVAL_H
diff --git a/src/sched/sched_setaffinity.h b/src/sched/sched_setaffinity.h
index 5da6dd4..cb2303d 100644
--- a/src/sched/sched_setaffinity.h
+++ b/src/sched/sched_setaffinity.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_SETAFFINITY_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_SETAFFINITY_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_setaffinity(pid_t pid, size_t cpuset_size, const cpu_set_t *mask);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_SETAFFINITY_H
diff --git a/src/sched/sched_setparam.h b/src/sched/sched_setparam.h
index c371bc0..e4691a7 100644
--- a/src/sched/sched_setparam.h
+++ b/src/sched/sched_setparam.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_SETPARAM_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_SETPARAM_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_setparam(pid_t tid, const struct sched_param *param);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_SETPARAM_H
diff --git a/src/sched/sched_setscheduler.h b/src/sched/sched_setscheduler.h
index 8e0cb0d..e745002 100644
--- a/src/sched/sched_setscheduler.h
+++ b/src/sched/sched_setscheduler.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_SETSCHEDULER_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_SETSCHEDULER_H
 
+#include "src/__support/macros/config.h"
 #include <sched.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_setscheduler(pid_t tid, int policy, const struct sched_param *param);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_SETSCHEDULER_H
diff --git a/src/sched/sched_yield.h b/src/sched/sched_yield.h
index 493646a..c48fdd7 100644
--- a/src/sched/sched_yield.h
+++ b/src/sched/sched_yield.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SCHED_SCHED_YIELD_H
 #define LLVM_LIBC_SRC_SCHED_SCHED_YIELD_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int sched_yield(void);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SCHED_SCHED_YIELD_H
diff --git a/src/search/hcreate.cpp b/src/search/hcreate.cpp
index 4bf638b..ac816a9 100644
--- a/src/search/hcreate.cpp
+++ b/src/search/hcreate.cpp
@@ -9,10 +9,11 @@
 #include "src/search/hcreate.h"
 #include "src/__support/HashTable/randomness.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/search/hsearch/global.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, hcreate, (size_t capacity)) {
   // We follow FreeBSD's implementation here. If the global_hash_table is
   // already initialized, this function will do nothing and return 1.
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, hcreate, (size_t capacity)) {
   return 1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hcreate.h b/src/search/hcreate.h
index 2ac37fb..2f5a9c7 100644
--- a/src/search/hcreate.h
+++ b/src/search/hcreate.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HCREATE_H
 #define LLVM_LIBC_SRC_SEARCH_HCREATE_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 int hcreate(size_t capacity);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HCREATE_H
diff --git a/src/search/hcreate_r.cpp b/src/search/hcreate_r.cpp
index 612a45c..17acd80 100644
--- a/src/search/hcreate_r.cpp
+++ b/src/search/hcreate_r.cpp
@@ -9,9 +9,10 @@
 #include "src/search/hcreate_r.h"
 #include "src/__support/HashTable/randomness.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, hcreate_r,
                    (size_t capacity, struct hsearch_data *htab)) {
   if (htab == nullptr) {
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, hcreate_r,
   return 1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hcreate_r.h b/src/search/hcreate_r.h
index e81895e..9606077 100644
--- a/src/search/hcreate_r.h
+++ b/src/search/hcreate_r.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HCREATE_R_H
 #define LLVM_LIBC_SRC_SEARCH_HCREATE_R_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 int hcreate_r(size_t capacity, struct hsearch_data *htab);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HCREATE_R_H
diff --git a/src/search/hdestroy.cpp b/src/search/hdestroy.cpp
index 3c5ea7b..c794b2a 100644
--- a/src/search/hdestroy.cpp
+++ b/src/search/hdestroy.cpp
@@ -8,9 +8,10 @@
 
 #include "src/search/hdestroy.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/search/hsearch/global.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(void, hdestroy, (void)) {
   // HashTable::deallocate will check for nullptr. It will be a no-op if
   // global_hash_table is null.
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(void, hdestroy, (void)) {
   internal::global_hash_table = nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hdestroy.h b/src/search/hdestroy.h
index b81e309..c2b9a87 100644
--- a/src/search/hdestroy.h
+++ b/src/search/hdestroy.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HDESTROY_H
 #define LLVM_LIBC_SRC_SEARCH_HDESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 void hdestroy(void);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HDESTROY_H
diff --git a/src/search/hdestroy_r.cpp b/src/search/hdestroy_r.cpp
index e2fda93..7eff5bb 100644
--- a/src/search/hdestroy_r.cpp
+++ b/src/search/hdestroy_r.cpp
@@ -8,9 +8,10 @@
 
 #include "src/search/hdestroy_r.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(void, hdestroy_r, (struct hsearch_data * htab)) {
   if (htab == nullptr) {
     libc_errno = EINVAL;
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(void, hdestroy_r, (struct hsearch_data * htab)) {
   htab->__opaque = nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hdestroy_r.h b/src/search/hdestroy_r.h
index 503af41..c9a4ddf 100644
--- a/src/search/hdestroy_r.h
+++ b/src/search/hdestroy_r.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HDESTROY_R_H
 #define LLVM_LIBC_SRC_SEARCH_HDESTROY_R_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 void hdestroy_r(struct hsearch_data *htab);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HDESTROY_R_H
diff --git a/src/search/hsearch.cpp b/src/search/hsearch.cpp
index 5aeb5c2..c18b5d3 100644
--- a/src/search/hsearch.cpp
+++ b/src/search/hsearch.cpp
@@ -9,12 +9,13 @@
 #include "src/search/hsearch.h"
 #include "src/__support/HashTable/randomness.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/search/hsearch/global.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(ENTRY *, hsearch, (ENTRY item, ACTION action)) {
-  ENTRY *result;
+  ENTRY *result = nullptr;
   if (internal::global_hash_table == nullptr) {
     // If global_hash_table is null, we create a new hash table with a minimal
     // capacity. Such hashtable will be expanded as needed.
@@ -46,4 +47,4 @@ LLVM_LIBC_FUNCTION(ENTRY *, hsearch, (ENTRY item, ACTION action)) {
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hsearch.h b/src/search/hsearch.h
index 32dc073..4d03985 100644
--- a/src/search/hsearch.h
+++ b/src/search/hsearch.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HSEARCH_H
 #define LLVM_LIBC_SRC_SEARCH_HSEARCH_H
 
+#include "src/__support/macros/config.h"
 #include <search.h> // ENTRY, ACTION
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 ENTRY *hsearch(ENTRY item, ACTION action);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HSEARCH_H
diff --git a/src/search/hsearch/global.cpp b/src/search/hsearch/global.cpp
index b6782ad..8dc64a0 100644
--- a/src/search/hsearch/global.cpp
+++ b/src/search/hsearch/global.cpp
@@ -6,8 +6,10 @@
 //
 //===----------------------------------------------------------------------===//
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 struct HashTable *global_hash_table = nullptr;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hsearch/global.h b/src/search/hsearch/global.h
index 9579195..2ca532c 100644
--- a/src/search/hsearch/global.h
+++ b/src/search/hsearch/global.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HSEARCH_GLOBAL_H
 #define LLVM_LIBC_SRC_SEARCH_HSEARCH_GLOBAL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 extern struct HashTable *global_hash_table;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HSEARCH_GLOBAL_H
diff --git a/src/search/hsearch_r.cpp b/src/search/hsearch_r.cpp
index a2c3a86..f93e608 100644
--- a/src/search/hsearch_r.cpp
+++ b/src/search/hsearch_r.cpp
@@ -8,9 +8,10 @@
 
 #include "src/search/hsearch_r.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, hsearch_r,
                    (ENTRY item, ACTION action, ENTRY **retval,
                     struct hsearch_data *htab)) {
@@ -40,4 +41,4 @@ LLVM_LIBC_FUNCTION(int, hsearch_r,
   return 1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/hsearch_r.h b/src/search/hsearch_r.h
index d36094c..6e95110 100644
--- a/src/search/hsearch_r.h
+++ b/src/search/hsearch_r.h
@@ -9,11 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_HSEARCH_R_H
 #define LLVM_LIBC_SRC_SEARCH_HSEARCH_R_H
 
+#include "src/__support/macros/config.h"
 #include <search.h> // ENTRY, ACTION
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 int hsearch_r(ENTRY item, ACTION action, ENTRY **retval,
               struct hsearch_data *htab);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_HSEARCH_R_H
diff --git a/src/search/insque.cpp b/src/search/insque.cpp
index 7b7d7c7..61a4171 100644
--- a/src/search/insque.cpp
+++ b/src/search/insque.cpp
@@ -9,11 +9,12 @@
 #include "src/search/insque.h"
 #include "src/__support/common.h"
 #include "src/__support/intrusive_list.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, insque, (void *elem, void *prev)) {
   internal::IntrusiveList::insert(elem, prev);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/insque.h b/src/search/insque.h
index e0fb69e..8c6c6b0 100644
--- a/src/search/insque.h
+++ b/src/search/insque.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_INSQUE_H
 #define LLVM_LIBC_SRC_SEARCH_INSQUE_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void insque(void *elem, void *prev);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_INSQUE_H
diff --git a/src/search/lfind.cpp b/src/search/lfind.cpp
new file mode 100644
index 0000000..c8bf07d
--- /dev/null
+++ b/src/search/lfind.cpp
@@ -0,0 +1,35 @@
+//===-- Implementation of lfind   -------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/search/lfind.h"
+#include "src/__support/CPP/cstddef.h" // cpp::byte
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/memory_size.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(void *, lfind,
+                   (const void *key, const void *base, size_t *nmemb,
+                    size_t size, int (*compar)(const void *, const void *))) {
+  if (key == nullptr || base == nullptr || nmemb == nullptr ||
+      compar == nullptr)
+    return nullptr;
+
+  size_t byte_len = 0;
+  if (internal::mul_overflow(*nmemb, size, &byte_len))
+    return nullptr;
+
+  const cpp::byte *next = reinterpret_cast<const cpp::byte *>(base);
+  const cpp::byte *end = next + byte_len;
+  for (; next < end; next += size)
+    if (compar(key, next) == 0)
+      return const_cast<cpp::byte *>(next);
+  return nullptr;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/lfind.h b/src/search/lfind.h
new file mode 100644
index 0000000..2eddb02
--- /dev/null
+++ b/src/search/lfind.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for lfind -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SEARCH_LFIND_H
+#define LLVM_LIBC_SRC_SEARCH_LFIND_H
+
+#include "src/__support/macros/config.h"
+#include <stddef.h> // size_t
+
+namespace LIBC_NAMESPACE_DECL {
+void *lfind(const void *key, const void *base, size_t *nmemb, size_t size,
+            int (*compar)(const void *, const void *));
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SEARCH_LFIND_H
diff --git a/src/search/remque.cpp b/src/search/remque.cpp
index f1d9859..97425df 100644
--- a/src/search/remque.cpp
+++ b/src/search/remque.cpp
@@ -9,11 +9,12 @@
 #include "src/search/remque.h"
 #include "src/__support/common.h"
 #include "src/__support/intrusive_list.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, remque, (void *elem)) {
   internal::IntrusiveList::remove(elem);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/search/remque.h b/src/search/remque.h
index 51f225c..d069579 100644
--- a/src/search/remque.h
+++ b/src/search/remque.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SEARCH_REMQUE_H
 #define LLVM_LIBC_SRC_SEARCH_REMQUE_H
 
+#include "src/__support/macros/config.h"
 #include <search.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void remque(void *elem);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SEARCH_REMQUE_H
diff --git a/src/setjmp/aarch64/longjmp.cpp b/src/setjmp/aarch64/longjmp.cpp
new file mode 100644
index 0000000..80c97c7
--- /dev/null
+++ b/src/setjmp/aarch64/longjmp.cpp
@@ -0,0 +1,92 @@
+//===-- Implementation of longjmp for AArch64 -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/setjmp/longjmp.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO: if MTE stack tagging is in use (-fsanitize=memtag-stack), we need to
+// iterate over the region between the old and new values of sp, using STG or
+// ST2G instructions to clear the memory tags on the invalidated region of the
+// stack. But this requires a means of finding out that we're in that mode, and
+// as far as I can see there isn't currently a predefined macro for that.
+//
+// (__ARM_FEATURE_MEMORY_TAGGING only indicates whether the target architecture
+// supports the MTE instructions, not whether the compiler is configured to use
+// them.)
+
+[[gnu::naked]] LLVM_LIBC_FUNCTION(void, longjmp,
+                                  ([[maybe_unused]] jmp_buf buf,
+                                   [[maybe_unused]] int val)) {
+  // If BTI branch protection is in use, the compiler will automatically insert
+  // a BTI here, so we don't need to make any extra effort to do so.
+
+  // If PAC branch protection is in use, there's no need to sign the return
+  // address at the start of longjmp, because we're not going to use it anyway!
+
+  asm(
+      // Reload the callee-saved GPRs, including fp and lr.
+      R"(
+        ldp x19, x20, [x0,  #0*16]
+        ldp x21, x22, [x0,  #1*16]
+        ldp x23, x24, [x0,  #2*16]
+        ldp x25, x26, [x0,  #3*16]
+        ldp x27, x28, [x0,  #4*16]
+        ldp x29, x30, [x0,  #5*16]
+      )"
+
+#if LIBC_COPT_SETJMP_AARCH64_RESTORE_PLATFORM_REGISTER
+      // Reload the stack pointer, and the platform register x18.
+      R"(
+        ldp x2,  x18, [x0,  #6*16]
+        mov sp, x2
+      )"
+#else
+      // Reload just the stack pointer.
+      R"(
+        ldr x2,       [x0,  #6*16]
+        mov sp, x2
+      )"
+#endif
+
+#if __ARM_FP
+      // Reload the callee-saved FP registers.
+      R"(
+        ldp d8,  d9,  [x0,  #7*16]
+        ldp d10, d11, [x0,  #8*16]
+        ldp d12, d13, [x0,  #9*16]
+        ldp d14, d15, [x0, #10*16]
+      )"
+#endif
+
+      // Calculate the return value.
+      R"(
+        cmp w1, #0
+        cinc w0, w1, eq
+      )"
+
+#if __ARM_FEATURE_PAC_DEFAULT & 1
+      // Authenticate the return address using the PAC A key.
+      R"(
+        autiasp
+      )"
+#elif __ARM_FEATURE_PAC_DEFAULT & 2
+      // Authenticate the return address using the PAC B key.
+      R"(
+        autibsp
+      )"
+#endif
+
+      R"(
+        ret
+      )");
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/aarch64/setjmp.cpp b/src/setjmp/aarch64/setjmp.cpp
new file mode 100644
index 0000000..8dd1eb3
--- /dev/null
+++ b/src/setjmp/aarch64/setjmp.cpp
@@ -0,0 +1,93 @@
+//===-- Implementation of setjmp for AArch64 ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/setjmp/setjmp_impl.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+[[gnu::naked]] LLVM_LIBC_FUNCTION(int, setjmp, ([[maybe_unused]] jmp_buf buf)) {
+  // If BTI branch protection is in use, the compiler will automatically insert
+  // a BTI here, so we don't need to make any extra effort to do so.
+
+  asm(
+#if __ARM_FEATURE_PAC_DEFAULT & 1
+      // Sign the return address using the PAC A key.
+      R"(
+        paciasp
+      )"
+#elif __ARM_FEATURE_PAC_DEFAULT & 2
+      // Sign the return address using the PAC B key.
+      R"(
+        pacibsp
+      )"
+#endif
+
+      // Store all the callee-saved GPRs, including fp (x29) and also lr (x30).
+      // Of course lr isn't normally callee-saved (the call instruction itself
+      // can't help clobbering it), but we certainly need to save it for this
+      // purpose.
+      R"(
+        stp x19, x20, [x0,  #0*16]
+        stp x21, x22, [x0,  #1*16]
+        stp x23, x24, [x0,  #2*16]
+        stp x25, x26, [x0,  #3*16]
+        stp x27, x28, [x0,  #4*16]
+        stp x29, x30, [x0,  #5*16]
+      )"
+
+#if LIBC_COPT_SETJMP_AARCH64_RESTORE_PLATFORM_REGISTER
+      // Store the stack pointer, and the platform register x18.
+      R"(
+        add x1, sp, #0
+        stp x1, x18,  [x0,  #6*16]
+      )"
+#else
+      // Store just the stack pointer.
+      R"(
+        add x1, sp, #0
+        str x1,       [x0,  #6*16]
+      )"
+#endif
+
+#if __ARM_FP
+      // Store the callee-saved FP registers. AAPCS64 only requires the low 64
+      // bits of v8-v15 to be preserved, i.e. each of d8,...,d15.
+      R"(
+        stp d8,  d9,  [x0,  #7*16]
+        stp d10, d11, [x0,  #8*16]
+        stp d12, d13, [x0,  #9*16]
+        stp d14, d15, [x0, #10*16]
+      )"
+#endif
+
+      // Set up return value of zero.
+      R"(
+        mov x0, #0
+      )"
+
+#if (__ARM_FEATURE_PAC_DEFAULT & 7) == 5
+      // Authenticate the return address using the PAC A key, since the
+      // compilation options ask for PAC protection even on leaf functions.
+      R"(
+        autiasp
+      )"
+#elif (__ARM_FEATURE_PAC_DEFAULT & 7) == 6
+      // Same, but using the PAC B key.
+      R"(
+        autibsp
+      )"
+#endif
+
+      R"(
+        ret
+      )");
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/arm/longjmp.cpp b/src/setjmp/arm/longjmp.cpp
index a088b58..623ca8f 100644
--- a/src/setjmp/arm/longjmp.cpp
+++ b/src/setjmp/arm/longjmp.cpp
@@ -9,13 +9,15 @@
 
 #include "src/setjmp/longjmp.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #if defined(__thumb__) && __ARM_ARCH_ISA_THUMB == 1
 
-[[gnu::naked, gnu::target("thumb")]]
-LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
+[[gnu::naked, gnu::target("thumb")]] LLVM_LIBC_FUNCTION(void, longjmp,
+                                                        (jmp_buf buf,
+                                                         int val)) {
   asm(R"(
       # Reload r4, r5, r6, r7.
       ldmia r0!, {r4-r7}
@@ -52,8 +54,7 @@ LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
 // TODO(https://github.com/llvm/llvm-project/issues/94061): fp registers
 // (d0-d16)
 // TODO(https://github.com/llvm/llvm-project/issues/94062): pac+bti
-[[gnu::naked]]
-LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
+[[gnu::naked]] LLVM_LIBC_FUNCTION(void, longjmp, (jmp_buf buf, int val)) {
   asm(R"(
       # While sp may appear in a register list for ARM mode, it may not for
       # Thumb2 mode. Just load the previous value of sp into r12 then move it
@@ -71,4 +72,4 @@ LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
 
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/arm/setjmp.cpp b/src/setjmp/arm/setjmp.cpp
index 287e09c..891ac30 100644
--- a/src/setjmp/arm/setjmp.cpp
+++ b/src/setjmp/arm/setjmp.cpp
@@ -7,14 +7,15 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/setjmp/setjmp_impl.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #if defined(__thumb__) && __ARM_ARCH_ISA_THUMB == 1
 
-[[gnu::naked, gnu::target("thumb")]]
-LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
+[[gnu::naked, gnu::target("thumb")]] LLVM_LIBC_FUNCTION(int, setjmp,
+                                                        (jmp_buf buf)) {
   asm(R"(
       # Store r4, r5, r6, and r7 into buf.
       stmia r0!, {r4-r7}
@@ -43,8 +44,7 @@ LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
 // TODO(https://github.com/llvm/llvm-project/issues/94061): fp registers
 // (d0-d16)
 // TODO(https://github.com/llvm/llvm-project/issues/94062): pac+bti
-[[gnu::naked]]
-LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
+[[gnu::naked]] LLVM_LIBC_FUNCTION(int, setjmp, (jmp_buf buf)) {
   asm(R"(
       # While sp may appear in a register list for ARM mode, it may not for
       # Thumb2 mode. Just move it into r12 then stm that, so that this code
@@ -61,4 +61,4 @@ LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
 
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/longjmp.h b/src/setjmp/longjmp.h
index 3697d62..9b7db29 100644
--- a/src/setjmp/longjmp.h
+++ b/src/setjmp/longjmp.h
@@ -9,12 +9,26 @@
 #ifndef LLVM_LIBC_SRC_SETJMP_LONGJMP_H
 #define LLVM_LIBC_SRC_SETJMP_LONGJMP_H
 
-#include <setjmp.h>
+#include "hdr/types/jmp_buf.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/compiler.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-void longjmp(__jmp_buf *buf, int val);
+// TODO(https://github.com/llvm/llvm-project/issues/112427)
+// Some of the architecture-specific definitions are marked `naked`, which in
+// GCC implies `nothrow`.
+//
+// Right now, our aliases aren't marked `nothrow`, so we wind up in a situation
+// where clang will emit -Wmissing-exception-spec if we add `nothrow` here, but
+// GCC will emit -Wmissing-attributes here without `nothrow`. We need to update
+// LLVM_LIBC_FUNCTION to denote when a function throws or not.
+
+#ifdef LIBC_COMPILER_IS_GCC
+[[gnu::nothrow]]
+#endif
+void longjmp(jmp_buf buf, int val);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SETJMP_LONGJMP_H
diff --git a/src/setjmp/riscv/longjmp.cpp b/src/setjmp/riscv/longjmp.cpp
index 034c31e..16526a4 100644
--- a/src/setjmp/riscv/longjmp.cpp
+++ b/src/setjmp/riscv/longjmp.cpp
@@ -8,10 +8,9 @@
 
 #include "src/setjmp/longjmp.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
-#include <setjmp.h>
-
 #if !defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #error "Invalid file include"
 #endif
@@ -27,9 +26,9 @@
 #define LOAD_FP(reg, val) LOAD_IMPL(fld, reg, val)
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
+LLVM_LIBC_FUNCTION(void, longjmp, (jmp_buf buf, int val)) {
   LOAD(ra, buf->__pc);
   LOAD(s0, buf->__regs[0]);
   LOAD(s1, buf->__regs[1]);
@@ -66,4 +65,4 @@ LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
   LIBC_INLINE_ASM("add a0, %0, zero\n\t" : : "r"(val) :);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/riscv/setjmp.cpp b/src/setjmp/riscv/setjmp.cpp
index 04d6b5e..13cb42e 100644
--- a/src/setjmp/riscv/setjmp.cpp
+++ b/src/setjmp/riscv/setjmp.cpp
@@ -7,10 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/setjmp/setjmp_impl.h"
 
-#include <setjmp.h>
-
 #if !defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #error "Invalid file include"
 #endif
@@ -26,9 +25,9 @@
 #define STORE_FP(reg, val) STORE_IMPL(fsd, reg, val)
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
+LLVM_LIBC_FUNCTION(int, setjmp, (jmp_buf buf)) {
   STORE(ra, buf->__pc);
   STORE(s0, buf->__regs[0]);
   STORE(s1, buf->__regs[1]);
@@ -64,4 +63,4 @@ LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/setjmp_impl.h b/src/setjmp/setjmp_impl.h
index 52c835c..d035409 100644
--- a/src/setjmp/setjmp_impl.h
+++ b/src/setjmp/setjmp_impl.h
@@ -11,12 +11,26 @@
 
 // This header has the _impl prefix in its name to avoid conflict with the
 // public header setjmp.h which is also included. here.
-#include <setjmp.h>
+#include "hdr/types/jmp_buf.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/compiler.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-int setjmp(__jmp_buf *buf);
+// TODO(https://github.com/llvm/llvm-project/issues/112427)
+// Some of the architecture-specific definitions are marked `naked`, which in
+// GCC implies `nothrow`.
+//
+// Right now, our aliases aren't marked `nothrow`, so we wind up in a situation
+// where clang will emit -Wmissing-exception-spec if we add `nothrow` here, but
+// GCC will emit -Wmissing-attributes here without `nothrow`. We need to update
+// LLVM_LIBC_FUNCTION to denote when a function throws or not.
+
+#ifdef LIBC_COMPILER_IS_GCC
+[[gnu::nothrow]]
+#endif
+int setjmp(jmp_buf buf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SETJMP_SETJMP_IMPL_H
diff --git a/src/setjmp/x86_64/longjmp.cpp b/src/setjmp/x86_64/longjmp.cpp
index 3234046..143c9de 100644
--- a/src/setjmp/x86_64/longjmp.cpp
+++ b/src/setjmp/x86_64/longjmp.cpp
@@ -7,38 +7,59 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/setjmp/longjmp.h"
+#include "include/llvm-libc-macros/offsetof-macro.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-#if !defined(LIBC_TARGET_ARCH_IS_X86_64)
+#if !defined(LIBC_TARGET_ARCH_IS_X86)
 #error "Invalid file include"
 #endif
 
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(void, longjmp, (__jmp_buf * buf, int val)) {
-  register __UINT64_TYPE__ rbx __asm__("rbx");
-  register __UINT64_TYPE__ rbp __asm__("rbp");
-  register __UINT64_TYPE__ r12 __asm__("r12");
-  register __UINT64_TYPE__ r13 __asm__("r13");
-  register __UINT64_TYPE__ r14 __asm__("r14");
-  register __UINT64_TYPE__ r15 __asm__("r15");
-  register __UINT64_TYPE__ rsp __asm__("rsp");
-  register __UINT64_TYPE__ rax __asm__("rax");
-
-  // ABI requires that the return value should be stored in rax. So, we store
-  // |val| in rax. Note that this has to happen before we restore the registers
-  // from values in |buf|. Otherwise, once rsp and rbp are updated, we cannot
-  // read |val|.
-  val = val == 0 ? 1 : val;
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(rax) : "m"(val) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(rbx) : "m"(buf->rbx) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(rbp) : "m"(buf->rbp) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(r12) : "m"(buf->r12) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(r13) : "m"(buf->r13) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(r14) : "m"(buf->r14) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(r15) : "m"(buf->r15) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=r"(rsp) : "m"(buf->rsp) :);
-  LIBC_INLINE_ASM("jmp *%0\n\t" : : "m"(buf->rip));
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef __i386__
+[[gnu::naked]]
+LLVM_LIBC_FUNCTION(void, longjmp, (jmp_buf, int)) {
+  asm(R"(
+      mov 0x4(%%esp), %%ecx
+      mov 0x8(%%esp), %%eax
+      cmpl $0x1, %%eax
+      adcl $0x0, %%eax
+
+      mov %c[ebx](%%ecx), %%ebx
+      mov %c[esi](%%ecx), %%esi
+      mov %c[edi](%%ecx), %%edi
+      mov %c[ebp](%%ecx), %%ebp
+      mov %c[esp](%%ecx), %%esp
+
+      jmp *%c[eip](%%ecx)
+      )" ::[ebx] "i"(offsetof(__jmp_buf, ebx)),
+      [esi] "i"(offsetof(__jmp_buf, esi)), [edi] "i"(offsetof(__jmp_buf, edi)),
+      [ebp] "i"(offsetof(__jmp_buf, ebp)), [esp] "i"(offsetof(__jmp_buf, esp)),
+      [eip] "i"(offsetof(__jmp_buf, eip)));
 }
+#else
+[[gnu::naked]]
+LLVM_LIBC_FUNCTION(void, longjmp, (jmp_buf, int)) {
+  asm(R"(
+      cmpl $0x1, %%esi
+      adcl $0x0, %%esi
+      movq %%rsi, %%rax
+
+      movq %c[rbx](%%rdi), %%rbx
+      movq %c[rbp](%%rdi), %%rbp
+      movq %c[r12](%%rdi), %%r12
+      movq %c[r13](%%rdi), %%r13
+      movq %c[r14](%%rdi), %%r14
+      movq %c[r15](%%rdi), %%r15
+      movq %c[rsp](%%rdi), %%rsp
+      jmpq *%c[rip](%%rdi)
+      )" ::[rbx] "i"(offsetof(__jmp_buf, rbx)),
+      [rbp] "i"(offsetof(__jmp_buf, rbp)), [r12] "i"(offsetof(__jmp_buf, r12)),
+      [r13] "i"(offsetof(__jmp_buf, r13)), [r14] "i"(offsetof(__jmp_buf, r14)),
+      [r15] "i"(offsetof(__jmp_buf, r15)), [rsp] "i"(offsetof(__jmp_buf, rsp)),
+      [rip] "i"(offsetof(__jmp_buf, rip)));
+}
+#endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/setjmp/x86_64/setjmp.cpp b/src/setjmp/x86_64/setjmp.cpp
index 8b6981d..5ac10fa 100644
--- a/src/setjmp/x86_64/setjmp.cpp
+++ b/src/setjmp/x86_64/setjmp.cpp
@@ -6,51 +6,66 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "include/llvm-libc-macros/offsetof-macro.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/setjmp/setjmp_impl.h"
 
-#if !defined(LIBC_TARGET_ARCH_IS_X86_64)
+#if !defined(LIBC_TARGET_ARCH_IS_X86)
 #error "Invalid file include"
 #endif
 
-namespace LIBC_NAMESPACE {
-
-LLVM_LIBC_FUNCTION(int, setjmp, (__jmp_buf * buf)) {
-  register __UINT64_TYPE__ rbx __asm__("rbx");
-  register __UINT64_TYPE__ r12 __asm__("r12");
-  register __UINT64_TYPE__ r13 __asm__("r13");
-  register __UINT64_TYPE__ r14 __asm__("r14");
-  register __UINT64_TYPE__ r15 __asm__("r15");
-
-  // We want to store the register values as is. So, we will suppress the
-  // compiler warnings about the uninitialized variables declared above.
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wuninitialized"
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=m"(buf->rbx) : "r"(rbx) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=m"(buf->r12) : "r"(r12) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=m"(buf->r13) : "r"(r13) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=m"(buf->r14) : "r"(r14) :);
-  LIBC_INLINE_ASM("mov %1, %0\n\t" : "=m"(buf->r15) : "r"(r15) :);
-#pragma GCC diagnostic pop
-
-  // We want the rbp of the caller, which is what __builtin_frame_address(1)
-  // should return. But, compilers generate a warning that calling
-  // __builtin_frame_address with non-zero argument is unsafe. So, we use
-  // the knowledge of the x86_64 ABI to fetch the callers rbp. As per the ABI,
-  // the rbp of the caller is pushed on to the stack and then new top is saved
-  // in this function's rbp. So, we fetch it from location at which this
-  // functions's rbp is pointing.
-  buf->rbp = *reinterpret_cast<__UINTPTR_TYPE__ *>(__builtin_frame_address(0));
-
-  // The callers stack address is exactly 2 pointer widths ahead of the current
-  // frame pointer - between the current frame pointer and the rsp of the caller
-  // are the return address (pushed by the x86_64 call instruction) and the
-  // previous stack pointer as required by the x86_64 ABI.
-  // The stack pointer is ahead because the stack grows down on x86_64.
-  buf->rsp = reinterpret_cast<__UINTPTR_TYPE__>(__builtin_frame_address(0)) +
-             sizeof(__UINTPTR_TYPE__) * 2;
-  buf->rip = reinterpret_cast<__UINTPTR_TYPE__>(__builtin_return_address(0));
-  return 0;
+namespace LIBC_NAMESPACE_DECL {
+
+#ifdef __i386__
+[[gnu::naked]]
+LLVM_LIBC_FUNCTION(int, setjmp, (jmp_buf buf)) {
+  asm(R"(
+      mov 4(%%esp), %%eax
+
+      mov %%ebx, %c[ebx](%%eax)
+      mov %%esi, %c[esi](%%eax)
+      mov %%edi, %c[edi](%%eax)
+      mov %%ebp, %c[ebp](%%eax)
+
+      lea 4(%%esp), %%ecx
+      mov %%ecx, %c[esp](%%eax)
+
+      mov (%%esp), %%ecx
+      mov %%ecx, %c[eip](%%eax)
+
+      xorl %%eax, %%eax
+      retl)" ::[ebx] "i"(offsetof(__jmp_buf, ebx)),
+      [esi] "i"(offsetof(__jmp_buf, esi)), [edi] "i"(offsetof(__jmp_buf, edi)),
+      [ebp] "i"(offsetof(__jmp_buf, ebp)), [esp] "i"(offsetof(__jmp_buf, esp)),
+      [eip] "i"(offsetof(__jmp_buf, eip))
+      : "eax", "ecx");
 }
+#else
+[[gnu::naked]]
+LLVM_LIBC_FUNCTION(int, setjmp, (jmp_buf buf)) {
+  asm(R"(
+      mov %%rbx, %c[rbx](%%rdi)
+      mov %%rbp, %c[rbp](%%rdi)
+      mov %%r12, %c[r12](%%rdi)
+      mov %%r13, %c[r13](%%rdi)
+      mov %%r14, %c[r14](%%rdi)
+      mov %%r15, %c[r15](%%rdi)
+
+      lea 8(%%rsp), %%rax
+      mov %%rax, %c[rsp](%%rdi)
+
+      mov (%%rsp), %%rax
+      mov %%rax, %c[rip](%%rdi)
+
+      xorl %%eax, %%eax
+      retq)" ::[rbx] "i"(offsetof(__jmp_buf, rbx)),
+      [rbp] "i"(offsetof(__jmp_buf, rbp)), [r12] "i"(offsetof(__jmp_buf, r12)),
+      [r13] "i"(offsetof(__jmp_buf, r13)), [r14] "i"(offsetof(__jmp_buf, r14)),
+      [r15] "i"(offsetof(__jmp_buf, r15)), [rsp] "i"(offsetof(__jmp_buf, rsp)),
+      [rip] "i"(offsetof(__jmp_buf, rip))
+      : "rax");
+}
+#endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/kill.h b/src/signal/kill.h
index a6d1893..46048f2 100644
--- a/src/signal/kill.h
+++ b/src/signal/kill.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_KILL_H
 #define LLVM_LIBC_SRC_SIGNAL_KILL_H
 
+#include "src/__support/macros/config.h"
 #include <signal.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int kill(pid_t pid, int sig);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_KILL_H
diff --git a/src/signal/linux/__restore.cpp b/src/signal/linux/__restore.cpp
index 36fa375..d3b4240 100644
--- a/src/signal/linux/__restore.cpp
+++ b/src/signal/linux/__restore.cpp
@@ -11,10 +11,11 @@
 // make any stack allocations so we must ensure this.
 
 #include "src/__support/OSUtil/syscall.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 extern "C" void __restore_rt()
     __attribute__((no_sanitize("all"),
@@ -24,4 +25,4 @@ extern "C" void __restore_rt() {
   LIBC_NAMESPACE::syscall_impl<long>(SYS_rt_sigreturn);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/kill.cpp b/src/signal/linux/kill.cpp
index a02b3b1..ed11785 100644
--- a/src/signal/linux/kill.cpp
+++ b/src/signal/linux/kill.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
 #include <signal.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, kill, (pid_t pid, int sig)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_kill, pid, sig);
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, kill, (pid_t pid, int sig)) {
   return ret; // always 0
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/raise.cpp b/src/signal/linux/raise.cpp
index 2250df5..4a89139 100644
--- a/src/signal/linux/raise.cpp
+++ b/src/signal/linux/raise.cpp
@@ -10,9 +10,10 @@
 
 #include "hdr/types/sigset_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/signal/linux/signal_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, raise, (int sig)) {
   sigset_t sigset;
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, raise, (int sig)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigaction.cpp b/src/signal/linux/sigaction.cpp
index 7b220e5..65ec367 100644
--- a/src/signal/linux/sigaction.cpp
+++ b/src/signal/linux/sigaction.cpp
@@ -10,10 +10,11 @@
 
 #include "hdr/types/sigset_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TOOD: Some architectures will have their signal trampoline functions in the
 // vdso, use those when available.
@@ -46,4 +47,4 @@ LLVM_LIBC_FUNCTION(int, sigaction,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigaddset.cpp b/src/signal/linux/sigaddset.cpp
index 8fc5d43..628883e 100644
--- a/src/signal/linux/sigaddset.cpp
+++ b/src/signal/linux/sigaddset.cpp
@@ -10,10 +10,11 @@
 
 #include "hdr/types/sigset_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigaddset, (sigset_t * set, int signum)) {
   if (set != nullptr && add_signal(*set, signum))
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, sigaddset, (sigset_t * set, int signum)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigaltstack.cpp b/src/signal/linux/sigaltstack.cpp
index 47e0b23..c19394c 100644
--- a/src/signal/linux/sigaltstack.cpp
+++ b/src/signal/linux/sigaltstack.cpp
@@ -7,15 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/signal/sigaltstack.h"
+#include "hdr/types/stack_t.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
 #include "src/__support/common.h"
 
-#include <signal.h>
 #include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigaltstack,
                    (const stack_t *__restrict ss, stack_t *__restrict oss)) {
@@ -42,4 +43,4 @@ LLVM_LIBC_FUNCTION(int, sigaltstack,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigdelset.cpp b/src/signal/linux/sigdelset.cpp
index 997f457..2e96405 100644
--- a/src/signal/linux/sigdelset.cpp
+++ b/src/signal/linux/sigdelset.cpp
@@ -10,10 +10,11 @@
 
 #include "hdr/types/sigset_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigdelset, (sigset_t * set, int signum)) {
   if (set != nullptr && delete_signal(*set, signum))
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, sigdelset, (sigset_t * set, int signum)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigemptyset.cpp b/src/signal/linux/sigemptyset.cpp
index d08191e..d347477 100644
--- a/src/signal/linux/sigemptyset.cpp
+++ b/src/signal/linux/sigemptyset.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/signal/sigemptyset.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
@@ -14,7 +15,7 @@
 
 #include <signal.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigemptyset, (sigset_t * set)) {
   if (!set) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, sigemptyset, (sigset_t * set)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/sigfillset.cpp b/src/signal/linux/sigfillset.cpp
index d98bbf7..3e9897a 100644
--- a/src/signal/linux/sigfillset.cpp
+++ b/src/signal/linux/sigfillset.cpp
@@ -10,10 +10,11 @@
 
 #include "hdr/types/sigset_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigfillset, (sigset_t * set)) {
   if (!set) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, sigfillset, (sigset_t * set)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/signal.cpp b/src/signal/linux/signal.cpp
index a517fa7..1da0ef8 100644
--- a/src/signal/linux/signal.cpp
+++ b/src/signal/linux/signal.cpp
@@ -7,13 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/signal/signal.h"
-#include "src/signal/sigaction.h"
-
+#include "hdr/signal_macros.h"
+#include "hdr/types/sighandler_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/signal/sigaction.h"
 
-#include <signal.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(sighandler_t, signal, (int signum, sighandler_t handler)) {
   struct sigaction action, old;
@@ -25,4 +25,4 @@ LLVM_LIBC_FUNCTION(sighandler_t, signal, (int signum, sighandler_t handler)) {
              : old.sa_handler;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/linux/signal_utils.h b/src/signal/linux/signal_utils.h
index 3fd0cc0..8102127 100644
--- a/src/signal/linux/signal_utils.h
+++ b/src/signal/linux/signal_utils.h
@@ -12,12 +12,13 @@
 #include "hdr/types/sigset_t.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <signal.h> // sigaction
 #include <stddef.h>
 #include <sys/syscall.h>          // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The POSIX definition of struct sigaction and the sigaction data structure
 // expected by the rt_sigaction syscall differ in their definition. So, we
@@ -106,6 +107,6 @@ LIBC_INLINE int restore_signals(const sigset_t &set) {
                                            &set, nullptr, sizeof(sigset_t));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_LINUX_SIGNAL_UTILS_H
diff --git a/src/signal/linux/sigprocmask.cpp b/src/signal/linux/sigprocmask.cpp
index 0e94efb..8838379 100644
--- a/src/signal/linux/sigprocmask.cpp
+++ b/src/signal/linux/sigprocmask.cpp
@@ -11,12 +11,13 @@
 #include "hdr/types/sigset_t.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sigprocmask,
                    (int how, const sigset_t *__restrict set,
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, sigprocmask,
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/signal/raise.h b/src/signal/raise.h
index ee4f3c9..8e6894c 100644
--- a/src/signal/raise.h
+++ b/src/signal/raise.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_RAISE_H
 #define LLVM_LIBC_SRC_SIGNAL_RAISE_H
 
+#include "src/__support/macros/config.h"
 #include <signal.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int raise(int sig);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_RAISE_H
diff --git a/src/signal/sigaction.h b/src/signal/sigaction.h
index c36a3ec..363be84 100644
--- a/src/signal/sigaction.h
+++ b/src/signal/sigaction.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_SIGACTION_H
 #define LLVM_LIBC_SRC_SIGNAL_SIGACTION_H
 
-#include <signal.h>
+#include "hdr/types/struct_sigaction.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigaction(int signal, const struct sigaction *__restrict libc_new,
               struct sigaction *__restrict libc_old);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGACTION_H
diff --git a/src/signal/sigaddset.h b/src/signal/sigaddset.h
index c703b46..057afaa 100644
--- a/src/signal/sigaddset.h
+++ b/src/signal/sigaddset.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_SIGNAL_SIGADDSET_H
 
 #include "hdr/types/sigset_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigaddset(sigset_t *set, int signum);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGADDSET_H
diff --git a/src/signal/sigaltstack.h b/src/signal/sigaltstack.h
index 705bd36..7a82c0e 100644
--- a/src/signal/sigaltstack.h
+++ b/src/signal/sigaltstack.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_SIGALTSTACK_H
 #define LLVM_LIBC_SRC_SIGNAL_SIGALTSTACK_H
 
-#include <signal.h>
+#include "hdr/types/stack_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigaltstack(const stack_t *__restrict ss, stack_t *__restrict oss);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGALTSTACK_H
diff --git a/src/signal/sigdelset.h b/src/signal/sigdelset.h
index 7bdb6e6..27f831a 100644
--- a/src/signal/sigdelset.h
+++ b/src/signal/sigdelset.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_SIGNAL_SIGDELSET_H
 
 #include "hdr/types/sigset_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigdelset(sigset_t *set, int signum);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGDELSET_H
diff --git a/src/signal/sigemptyset.h b/src/signal/sigemptyset.h
index 661fd33..8865376 100644
--- a/src/signal/sigemptyset.h
+++ b/src/signal/sigemptyset.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_SIGNAL_SIGEMPTYSET_H
 
 #include "hdr/types/sigset_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigemptyset(sigset_t *set);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGEMPTYSET_H
diff --git a/src/signal/sigfillset.h b/src/signal/sigfillset.h
index 2849aac..fdd1580 100644
--- a/src/signal/sigfillset.h
+++ b/src/signal/sigfillset.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_SIGNAL_SIGFILLSET_H
 
 #include "hdr/types/sigset_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigfillset(sigset_t *set);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGFILLSET_H
diff --git a/src/signal/signal.h b/src/signal/signal.h
index 15bb5f0..06e77e1 100644
--- a/src/signal/signal.h
+++ b/src/signal/signal.h
@@ -9,14 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_SIGNAL_H
 #define LLVM_LIBC_SRC_SIGNAL_SIGNAL_H
 
-#include <signal.h>
+#include "hdr/types/sighandler_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
-
-using sighandler_t = __sighandler_t;
+namespace LIBC_NAMESPACE_DECL {
 
 sighandler_t signal(int signum, sighandler_t handler);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGNAL_H
diff --git a/src/signal/sigprocmask.h b/src/signal/sigprocmask.h
index 8569578..9b12846 100644
--- a/src/signal/sigprocmask.h
+++ b/src/signal/sigprocmask.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC_SIGNAL_SIGPROCMASK_H
 
 #include "hdr/types/sigset_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int sigprocmask(int how, const sigset_t *__restrict set,
                 sigset_t *__restrict oldset);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SIGNAL_SIGPROCMASK_H
diff --git a/src/spawn/file_actions.h b/src/spawn/file_actions.h
index 7113256..80b9295 100644
--- a/src/spawn/file_actions.h
+++ b/src/spawn/file_actions.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_FILE_ACTIONS_H
 #define LLVM_LIBC_SRC_SPAWN_FILE_ACTIONS_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h> // For mode_t
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct BaseSpawnFileAction {
   enum ActionType {
@@ -67,6 +68,6 @@ struct SpawnFileDup2Action : public BaseSpawnFileAction {
         newfd(new_fdesc) {}
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_FILE_ACTIONS_H
diff --git a/src/spawn/linux/posix_spawn.cpp b/src/spawn/linux/posix_spawn.cpp
index 0a0467d..fe82ba2 100644
--- a/src/spawn/linux/posix_spawn.cpp
+++ b/src/spawn/linux/posix_spawn.cpp
@@ -11,14 +11,16 @@
 #include "src/__support/CPP/optional.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/spawn/file_actions.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
+#include "hdr/types/mode_t.h"
 #include <signal.h> // For SIGCHLD
 #include <spawn.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -145,4 +147,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn.h b/src/spawn/posix_spawn.h
index 354b94c..d521c2a 100644
--- a/src/spawn/posix_spawn.h
+++ b/src/spawn/posix_spawn.h
@@ -9,15 +9,16 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn(pid_t *__restrict pid, const char *__restrict path,
                 const posix_spawn_file_actions_t *file_actions,
                 const posix_spawnattr_t *__restrict attr,
                 char *const *__restrict argv, char *const *__restrict envp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_H
diff --git a/src/spawn/posix_spawn_file_actions_addclose.cpp b/src/spawn/posix_spawn_file_actions_addclose.cpp
index 9b3c488..bb8504f 100644
--- a/src/spawn/posix_spawn_file_actions_addclose.cpp
+++ b/src/spawn/posix_spawn_file_actions_addclose.cpp
@@ -11,11 +11,12 @@
 #include "file_actions.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_addclose,
                    (posix_spawn_file_actions_t *__restrict actions, int fd)) {
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_addclose,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn_file_actions_addclose.h b/src/spawn/posix_spawn_file_actions_addclose.h
index c849651..8d4c4ed 100644
--- a/src/spawn/posix_spawn_file_actions_addclose.h
+++ b/src/spawn/posix_spawn_file_actions_addclose.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSE_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSE_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn_file_actions_addclose(
     posix_spawn_file_actions_t *__restrict actions, int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSE_H
diff --git a/src/spawn/posix_spawn_file_actions_adddup2.cpp b/src/spawn/posix_spawn_file_actions_adddup2.cpp
index caa558e..710063d 100644
--- a/src/spawn/posix_spawn_file_actions_adddup2.cpp
+++ b/src/spawn/posix_spawn_file_actions_adddup2.cpp
@@ -11,11 +11,12 @@
 #include "file_actions.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_adddup2,
                    (posix_spawn_file_actions_t * actions, int fd, int newfd)) {
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_adddup2,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn_file_actions_adddup2.h b/src/spawn/posix_spawn_file_actions_adddup2.h
index 7a7f3a5..1cbf3dc 100644
--- a/src/spawn/posix_spawn_file_actions_adddup2.h
+++ b/src/spawn/posix_spawn_file_actions_adddup2.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDDUP2_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDDUP2_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *actions,
                                      int fd, int newfd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDDUP2_H
diff --git a/src/spawn/posix_spawn_file_actions_addopen.cpp b/src/spawn/posix_spawn_file_actions_addopen.cpp
index c544f04..028d6e8 100644
--- a/src/spawn/posix_spawn_file_actions_addopen.cpp
+++ b/src/spawn/posix_spawn_file_actions_addopen.cpp
@@ -11,11 +11,12 @@
 #include "file_actions.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_addopen,
                    (posix_spawn_file_actions_t *__restrict actions, int fd,
@@ -34,4 +35,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_addopen,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn_file_actions_addopen.h b/src/spawn/posix_spawn_file_actions_addopen.h
index 121213a..d51434c 100644
--- a/src/spawn/posix_spawn_file_actions_addopen.h
+++ b/src/spawn/posix_spawn_file_actions_addopen.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDOPEN_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDOPEN_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn_file_actions_addopen(
     posix_spawn_file_actions_t *__restrict actions, int fd,
     const char *__restrict path, int oflag, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_ADDOPEN_H
diff --git a/src/spawn/posix_spawn_file_actions_destroy.cpp b/src/spawn/posix_spawn_file_actions_destroy.cpp
index 73e0ac8..168118d 100644
--- a/src/spawn/posix_spawn_file_actions_destroy.cpp
+++ b/src/spawn/posix_spawn_file_actions_destroy.cpp
@@ -9,13 +9,15 @@
 #include "posix_spawn_file_actions_destroy.h"
 
 #include "file_actions.h"
+
 #include "src/__support/CPP/new.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_destroy,
                    (posix_spawn_file_actions_t * actions)) {
@@ -49,4 +51,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_destroy,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn_file_actions_destroy.h b/src/spawn/posix_spawn_file_actions_destroy.h
index 28b9b05..7bbcfc3 100644
--- a/src/spawn/posix_spawn_file_actions_destroy.h
+++ b/src/spawn/posix_spawn_file_actions_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_DESTROY_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *actions);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_DESTROY_H
diff --git a/src/spawn/posix_spawn_file_actions_init.cpp b/src/spawn/posix_spawn_file_actions_init.cpp
index 04e5610..14242fc 100644
--- a/src/spawn/posix_spawn_file_actions_init.cpp
+++ b/src/spawn/posix_spawn_file_actions_init.cpp
@@ -9,10 +9,11 @@
 #include "posix_spawn_file_actions_init.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_init,
                    (posix_spawn_file_actions_t * actions)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, posix_spawn_file_actions_init,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/spawn/posix_spawn_file_actions_init.h b/src/spawn/posix_spawn_file_actions_init.h
index d7b228f..7945140 100644
--- a/src/spawn/posix_spawn_file_actions_init.h
+++ b/src/spawn/posix_spawn_file_actions_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_INIT_H
 #define LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <spawn.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_spawn_file_actions_init(posix_spawn_file_actions_t *actions);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SPAWN_POSIX_SPAWN_FILE_ACTIONS_INIT_H
diff --git a/src/stdbit/stdc_bit_ceil_uc.cpp b/src/stdbit/stdc_bit_ceil_uc.cpp
index 675ae4a..8febabf 100644
--- a/src/stdbit/stdc_bit_ceil_uc.cpp
+++ b/src/stdbit/stdc_bit_ceil_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned char, stdc_bit_ceil_uc, (unsigned char value)) {
   return cpp::bit_ceil(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_ceil_uc.h b/src/stdbit/stdc_bit_ceil_uc.h
index 204261e..211073c 100644
--- a/src/stdbit/stdc_bit_ceil_uc.h
+++ b/src/stdbit/stdc_bit_ceil_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned char stdc_bit_ceil_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UC_H
diff --git a/src/stdbit/stdc_bit_ceil_ui.cpp b/src/stdbit/stdc_bit_ceil_ui.cpp
index a8ac972..257adcd 100644
--- a/src/stdbit/stdc_bit_ceil_ui.cpp
+++ b/src/stdbit/stdc_bit_ceil_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_ceil_ui, (unsigned value)) {
   return cpp::bit_ceil(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_ceil_ui.h b/src/stdbit/stdc_bit_ceil_ui.h
index db66c33..d2da377 100644
--- a/src/stdbit/stdc_bit_ceil_ui.h
+++ b/src/stdbit/stdc_bit_ceil_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_ceil_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UI_H
diff --git a/src/stdbit/stdc_bit_ceil_ul.cpp b/src/stdbit/stdc_bit_ceil_ul.cpp
index 18a9c38..7b24559 100644
--- a/src/stdbit/stdc_bit_ceil_ul.cpp
+++ b/src/stdbit/stdc_bit_ceil_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long, stdc_bit_ceil_ul, (unsigned long value)) {
   return cpp::bit_ceil(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_ceil_ul.h b/src/stdbit/stdc_bit_ceil_ul.h
index f8393a4..fe22d79 100644
--- a/src/stdbit/stdc_bit_ceil_ul.h
+++ b/src/stdbit/stdc_bit_ceil_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long stdc_bit_ceil_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_UL_H
diff --git a/src/stdbit/stdc_bit_ceil_ull.cpp b/src/stdbit/stdc_bit_ceil_ull.cpp
index 0989f36..dd94da4 100644
--- a/src/stdbit/stdc_bit_ceil_ull.cpp
+++ b/src/stdbit/stdc_bit_ceil_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long long, stdc_bit_ceil_ull,
                    (unsigned long long value)) {
   return cpp::bit_ceil(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_ceil_ull.h b/src/stdbit/stdc_bit_ceil_ull.h
index e65f537..80a6d3c 100644
--- a/src/stdbit/stdc_bit_ceil_ull.h
+++ b/src/stdbit/stdc_bit_ceil_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long long stdc_bit_ceil_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_ULL_H
diff --git a/src/stdbit/stdc_bit_ceil_us.cpp b/src/stdbit/stdc_bit_ceil_us.cpp
index f86a216..4d35e18 100644
--- a/src/stdbit/stdc_bit_ceil_us.cpp
+++ b/src/stdbit/stdc_bit_ceil_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short, stdc_bit_ceil_us, (unsigned short value)) {
   return cpp::bit_ceil(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_ceil_us.h b/src/stdbit/stdc_bit_ceil_us.h
index 16a14e5..6001e7a 100644
--- a/src/stdbit/stdc_bit_ceil_us.h
+++ b/src/stdbit/stdc_bit_ceil_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short stdc_bit_ceil_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_CEIL_US_H
diff --git a/src/stdbit/stdc_bit_floor_uc.cpp b/src/stdbit/stdc_bit_floor_uc.cpp
index 6cb04c9..54959ec 100644
--- a/src/stdbit/stdc_bit_floor_uc.cpp
+++ b/src/stdbit/stdc_bit_floor_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned char, stdc_bit_floor_uc, (unsigned char value)) {
   return cpp::bit_floor(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_floor_uc.h b/src/stdbit/stdc_bit_floor_uc.h
index d6f53c5..baa4af8 100644
--- a/src/stdbit/stdc_bit_floor_uc.h
+++ b/src/stdbit/stdc_bit_floor_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned char stdc_bit_floor_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UC_H
diff --git a/src/stdbit/stdc_bit_floor_ui.cpp b/src/stdbit/stdc_bit_floor_ui.cpp
index 149b63f..a3458bc 100644
--- a/src/stdbit/stdc_bit_floor_ui.cpp
+++ b/src/stdbit/stdc_bit_floor_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_floor_ui, (unsigned value)) {
   return cpp::bit_floor(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_floor_ui.h b/src/stdbit/stdc_bit_floor_ui.h
index fcc6063..aaf9c73 100644
--- a/src/stdbit/stdc_bit_floor_ui.h
+++ b/src/stdbit/stdc_bit_floor_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_floor_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UI_H
diff --git a/src/stdbit/stdc_bit_floor_ul.cpp b/src/stdbit/stdc_bit_floor_ul.cpp
index a29a044..3f28bee 100644
--- a/src/stdbit/stdc_bit_floor_ul.cpp
+++ b/src/stdbit/stdc_bit_floor_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long, stdc_bit_floor_ul, (unsigned long value)) {
   return cpp::bit_floor(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_floor_ul.h b/src/stdbit/stdc_bit_floor_ul.h
index 08327aa..20ab34e 100644
--- a/src/stdbit/stdc_bit_floor_ul.h
+++ b/src/stdbit/stdc_bit_floor_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long stdc_bit_floor_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_UL_H
diff --git a/src/stdbit/stdc_bit_floor_ull.cpp b/src/stdbit/stdc_bit_floor_ull.cpp
index d1084b6..5470045 100644
--- a/src/stdbit/stdc_bit_floor_ull.cpp
+++ b/src/stdbit/stdc_bit_floor_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long long, stdc_bit_floor_ull,
                    (unsigned long long value)) {
   return cpp::bit_floor(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_floor_ull.h b/src/stdbit/stdc_bit_floor_ull.h
index 8f360b2..4c49a07 100644
--- a/src/stdbit/stdc_bit_floor_ull.h
+++ b/src/stdbit/stdc_bit_floor_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long long stdc_bit_floor_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_ULL_H
diff --git a/src/stdbit/stdc_bit_floor_us.cpp b/src/stdbit/stdc_bit_floor_us.cpp
index d1357a9..a4f3929 100644
--- a/src/stdbit/stdc_bit_floor_us.cpp
+++ b/src/stdbit/stdc_bit_floor_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short, stdc_bit_floor_us, (unsigned short value)) {
   return cpp::bit_floor(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_floor_us.h b/src/stdbit/stdc_bit_floor_us.h
index fcd0b9e..1494013 100644
--- a/src/stdbit/stdc_bit_floor_us.h
+++ b/src/stdbit/stdc_bit_floor_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short stdc_bit_floor_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_FLOOR_US_H
diff --git a/src/stdbit/stdc_bit_width_uc.cpp b/src/stdbit/stdc_bit_width_uc.cpp
index 2c361c1..71894bf 100644
--- a/src/stdbit/stdc_bit_width_uc.cpp
+++ b/src/stdbit/stdc_bit_width_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_width_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::bit_width(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_width_uc.h b/src/stdbit/stdc_bit_width_uc.h
index 70c038a..869cce2 100644
--- a/src/stdbit/stdc_bit_width_uc.h
+++ b/src/stdbit/stdc_bit_width_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_width_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UC_H
diff --git a/src/stdbit/stdc_bit_width_ui.cpp b/src/stdbit/stdc_bit_width_ui.cpp
index b94452b..c073e75 100644
--- a/src/stdbit/stdc_bit_width_ui.cpp
+++ b/src/stdbit/stdc_bit_width_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_width_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::bit_width(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_width_ui.h b/src/stdbit/stdc_bit_width_ui.h
index 9e8de3d..71cfb36 100644
--- a/src/stdbit/stdc_bit_width_ui.h
+++ b/src/stdbit/stdc_bit_width_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_width_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UI_H
diff --git a/src/stdbit/stdc_bit_width_ul.cpp b/src/stdbit/stdc_bit_width_ul.cpp
index 8004431..69630d9 100644
--- a/src/stdbit/stdc_bit_width_ul.cpp
+++ b/src/stdbit/stdc_bit_width_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_width_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::bit_width(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_width_ul.h b/src/stdbit/stdc_bit_width_ul.h
index 447a291..e13e3be 100644
--- a/src/stdbit/stdc_bit_width_ul.h
+++ b/src/stdbit/stdc_bit_width_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_width_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_UL_H
diff --git a/src/stdbit/stdc_bit_width_ull.cpp b/src/stdbit/stdc_bit_width_ull.cpp
index 006fa20..b720b45 100644
--- a/src/stdbit/stdc_bit_width_ull.cpp
+++ b/src/stdbit/stdc_bit_width_ull.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_width_ull, (unsigned long long value)) {
   return static_cast<unsigned>(cpp::bit_width(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_width_ull.h b/src/stdbit/stdc_bit_width_ull.h
index bc51897..91c935a 100644
--- a/src/stdbit/stdc_bit_width_ull.h
+++ b/src/stdbit/stdc_bit_width_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_width_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_ULL_H
diff --git a/src/stdbit/stdc_bit_width_us.cpp b/src/stdbit/stdc_bit_width_us.cpp
index 3d9f72b..ba00481 100644
--- a/src/stdbit/stdc_bit_width_us.cpp
+++ b/src/stdbit/stdc_bit_width_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_bit_width_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::bit_width(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_bit_width_us.h b/src/stdbit/stdc_bit_width_us.h
index 02cd374..3d9bfe9 100644
--- a/src/stdbit/stdc_bit_width_us.h
+++ b/src/stdbit/stdc_bit_width_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_bit_width_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_BIT_WIDTH_US_H
diff --git a/src/stdbit/stdc_count_ones_uc.cpp b/src/stdbit/stdc_count_ones_uc.cpp
index 1e998ff..9df8bcd 100644
--- a/src/stdbit/stdc_count_ones_uc.cpp
+++ b/src/stdbit/stdc_count_ones_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_ones_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::popcount(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_ones_uc.h b/src/stdbit/stdc_count_ones_uc.h
index eed3ee5..c982d0b 100644
--- a/src/stdbit/stdc_count_ones_uc.h
+++ b/src/stdbit/stdc_count_ones_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_ones_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UC_H
diff --git a/src/stdbit/stdc_count_ones_ui.cpp b/src/stdbit/stdc_count_ones_ui.cpp
index e457dd7..9b012e2 100644
--- a/src/stdbit/stdc_count_ones_ui.cpp
+++ b/src/stdbit/stdc_count_ones_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_ones_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::popcount(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_ones_ui.h b/src/stdbit/stdc_count_ones_ui.h
index 1f7ccb9..f5bc2db 100644
--- a/src/stdbit/stdc_count_ones_ui.h
+++ b/src/stdbit/stdc_count_ones_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_ones_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UI_H
diff --git a/src/stdbit/stdc_count_ones_ul.cpp b/src/stdbit/stdc_count_ones_ul.cpp
index ed86653..ac30c9e 100644
--- a/src/stdbit/stdc_count_ones_ul.cpp
+++ b/src/stdbit/stdc_count_ones_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_ones_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::popcount(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_ones_ul.h b/src/stdbit/stdc_count_ones_ul.h
index bde349a..014a155 100644
--- a/src/stdbit/stdc_count_ones_ul.h
+++ b/src/stdbit/stdc_count_ones_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_ones_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_UL_H
diff --git a/src/stdbit/stdc_count_ones_ull.cpp b/src/stdbit/stdc_count_ones_ull.cpp
index c5ecc3c..d27d0d3 100644
--- a/src/stdbit/stdc_count_ones_ull.cpp
+++ b/src/stdbit/stdc_count_ones_ull.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_ones_ull, (unsigned long long value)) {
   return static_cast<unsigned>(cpp::popcount(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_ones_ull.h b/src/stdbit/stdc_count_ones_ull.h
index 830239f..652e8d1 100644
--- a/src/stdbit/stdc_count_ones_ull.h
+++ b/src/stdbit/stdc_count_ones_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_ones_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_ULL_H
diff --git a/src/stdbit/stdc_count_ones_us.cpp b/src/stdbit/stdc_count_ones_us.cpp
index 465c5c3..9b925ba 100644
--- a/src/stdbit/stdc_count_ones_us.cpp
+++ b/src/stdbit/stdc_count_ones_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_ones_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::popcount(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_ones_us.h b/src/stdbit/stdc_count_ones_us.h
index 08fd4e7..24485dd 100644
--- a/src/stdbit/stdc_count_ones_us.h
+++ b/src/stdbit/stdc_count_ones_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_ones_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ONES_US_H
diff --git a/src/stdbit/stdc_count_zeros_uc.cpp b/src/stdbit/stdc_count_zeros_uc.cpp
index 309ebb5..ab5f0f3 100644
--- a/src/stdbit/stdc_count_zeros_uc.cpp
+++ b/src/stdbit/stdc_count_zeros_uc.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_count_zeros_uc.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_zeros_uc, (unsigned char value)) {
   return static_cast<unsigned>(count_zeros(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_zeros_uc.h b/src/stdbit/stdc_count_zeros_uc.h
index 34b4636..12f754b 100644
--- a/src/stdbit/stdc_count_zeros_uc.h
+++ b/src/stdbit/stdc_count_zeros_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_zeros_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UC_H
diff --git a/src/stdbit/stdc_count_zeros_ui.cpp b/src/stdbit/stdc_count_zeros_ui.cpp
index 31ea907..28efc54 100644
--- a/src/stdbit/stdc_count_zeros_ui.cpp
+++ b/src/stdbit/stdc_count_zeros_ui.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_count_zeros_ui.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_zeros_ui, (unsigned value)) {
   return static_cast<unsigned>(count_zeros(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_zeros_ui.h b/src/stdbit/stdc_count_zeros_ui.h
index 48e8630..df3562f 100644
--- a/src/stdbit/stdc_count_zeros_ui.h
+++ b/src/stdbit/stdc_count_zeros_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_zeros_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UI_H
diff --git a/src/stdbit/stdc_count_zeros_ul.cpp b/src/stdbit/stdc_count_zeros_ul.cpp
index f5df5c4..25c9b8d 100644
--- a/src/stdbit/stdc_count_zeros_ul.cpp
+++ b/src/stdbit/stdc_count_zeros_ul.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_count_zeros_ul.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_zeros_ul, (unsigned long value)) {
   return static_cast<unsigned>(count_zeros(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_zeros_ul.h b/src/stdbit/stdc_count_zeros_ul.h
index b883877..962eed5 100644
--- a/src/stdbit/stdc_count_zeros_ul.h
+++ b/src/stdbit/stdc_count_zeros_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_zeros_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_UL_H
diff --git a/src/stdbit/stdc_count_zeros_ull.cpp b/src/stdbit/stdc_count_zeros_ull.cpp
index 6a9c8f0..c0d641e 100644
--- a/src/stdbit/stdc_count_zeros_ull.cpp
+++ b/src/stdbit/stdc_count_zeros_ull.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_count_zeros_ull.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_zeros_ull, (unsigned long long value)) {
   return static_cast<unsigned>(count_zeros(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_zeros_ull.h b/src/stdbit/stdc_count_zeros_ull.h
index e15b330..3db13a1 100644
--- a/src/stdbit/stdc_count_zeros_ull.h
+++ b/src/stdbit/stdc_count_zeros_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_zeros_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_ULL_H
diff --git a/src/stdbit/stdc_count_zeros_us.cpp b/src/stdbit/stdc_count_zeros_us.cpp
index c08186e..fb352b0 100644
--- a/src/stdbit/stdc_count_zeros_us.cpp
+++ b/src/stdbit/stdc_count_zeros_us.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_count_zeros_us.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_count_zeros_us, (unsigned short value)) {
   return static_cast<unsigned>(count_zeros(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_count_zeros_us.h b/src/stdbit/stdc_count_zeros_us.h
index d422377..9e0f252 100644
--- a/src/stdbit/stdc_count_zeros_us.h
+++ b/src/stdbit/stdc_count_zeros_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_count_zeros_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_COUNT_ZEROS_US_H
diff --git a/src/stdbit/stdc_first_leading_one_uc.cpp b/src/stdbit/stdc_first_leading_one_uc.cpp
index 2e28ed3..0d73f5c 100644
--- a/src/stdbit/stdc_first_leading_one_uc.cpp
+++ b/src/stdbit/stdc_first_leading_one_uc.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_leading_one_uc.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_one_uc, (unsigned char value)) {
   return static_cast<unsigned>(first_leading_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_one_uc.h b/src/stdbit/stdc_first_leading_one_uc.h
index 58892c3..bc1025b 100644
--- a/src/stdbit/stdc_first_leading_one_uc.h
+++ b/src/stdbit/stdc_first_leading_one_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_one_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UC_H
diff --git a/src/stdbit/stdc_first_leading_one_ui.cpp b/src/stdbit/stdc_first_leading_one_ui.cpp
index a07a39b..cd33a19 100644
--- a/src/stdbit/stdc_first_leading_one_ui.cpp
+++ b/src/stdbit/stdc_first_leading_one_ui.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_leading_one_ui.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_one_ui, (unsigned value)) {
   return static_cast<unsigned>(first_leading_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_one_ui.h b/src/stdbit/stdc_first_leading_one_ui.h
index 613adf4..f1687ac 100644
--- a/src/stdbit/stdc_first_leading_one_ui.h
+++ b/src/stdbit/stdc_first_leading_one_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_one_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UI_H
diff --git a/src/stdbit/stdc_first_leading_one_ul.cpp b/src/stdbit/stdc_first_leading_one_ul.cpp
index 4350fb7..a7a7453 100644
--- a/src/stdbit/stdc_first_leading_one_ul.cpp
+++ b/src/stdbit/stdc_first_leading_one_ul.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_leading_one_ul.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_one_ul, (unsigned long value)) {
   return static_cast<unsigned>(first_leading_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_one_ul.h b/src/stdbit/stdc_first_leading_one_ul.h
index 47c179f..53e02f2 100644
--- a/src/stdbit/stdc_first_leading_one_ul.h
+++ b/src/stdbit/stdc_first_leading_one_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_one_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_UL_H
diff --git a/src/stdbit/stdc_first_leading_one_ull.cpp b/src/stdbit/stdc_first_leading_one_ull.cpp
index 57a5ae3..07d7330 100644
--- a/src/stdbit/stdc_first_leading_one_ull.cpp
+++ b/src/stdbit/stdc_first_leading_one_ull.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_one_ull.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_one_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(first_leading_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_one_ull.h b/src/stdbit/stdc_first_leading_one_ull.h
index 344d03f..96dc8c4 100644
--- a/src/stdbit/stdc_first_leading_one_ull.h
+++ b/src/stdbit/stdc_first_leading_one_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_one_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_ULL_H
diff --git a/src/stdbit/stdc_first_leading_one_us.cpp b/src/stdbit/stdc_first_leading_one_us.cpp
index f14433b..4c88abd 100644
--- a/src/stdbit/stdc_first_leading_one_us.cpp
+++ b/src/stdbit/stdc_first_leading_one_us.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_one_us.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_one_us,
                    (unsigned short value)) {
   return static_cast<unsigned>(first_leading_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_one_us.h b/src/stdbit/stdc_first_leading_one_us.h
index 9d5feaf..c213c3d 100644
--- a/src/stdbit/stdc_first_leading_one_us.h
+++ b/src/stdbit/stdc_first_leading_one_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_one_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ONE_US_H
diff --git a/src/stdbit/stdc_first_leading_zero_uc.cpp b/src/stdbit/stdc_first_leading_zero_uc.cpp
index 6e21642..0337135 100644
--- a/src/stdbit/stdc_first_leading_zero_uc.cpp
+++ b/src/stdbit/stdc_first_leading_zero_uc.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_zero_uc.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_zero_uc,
                    (unsigned char value)) {
   return static_cast<unsigned>(first_leading_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_zero_uc.h b/src/stdbit/stdc_first_leading_zero_uc.h
index 63ecd20..e20cf30 100644
--- a/src/stdbit/stdc_first_leading_zero_uc.h
+++ b/src/stdbit/stdc_first_leading_zero_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_zero_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UC_H
diff --git a/src/stdbit/stdc_first_leading_zero_ui.cpp b/src/stdbit/stdc_first_leading_zero_ui.cpp
index cb733a9..c9e55e6 100644
--- a/src/stdbit/stdc_first_leading_zero_ui.cpp
+++ b/src/stdbit/stdc_first_leading_zero_ui.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_leading_zero_ui.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_zero_ui, (unsigned value)) {
   return static_cast<unsigned>(first_leading_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_zero_ui.h b/src/stdbit/stdc_first_leading_zero_ui.h
index d8d5d93..204901e 100644
--- a/src/stdbit/stdc_first_leading_zero_ui.h
+++ b/src/stdbit/stdc_first_leading_zero_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_zero_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UI_H
diff --git a/src/stdbit/stdc_first_leading_zero_ul.cpp b/src/stdbit/stdc_first_leading_zero_ul.cpp
index 8a3930a..cb5231c 100644
--- a/src/stdbit/stdc_first_leading_zero_ul.cpp
+++ b/src/stdbit/stdc_first_leading_zero_ul.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_zero_ul.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_zero_ul,
                    (unsigned long value)) {
   return static_cast<unsigned>(first_leading_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_zero_ul.h b/src/stdbit/stdc_first_leading_zero_ul.h
index 8df1b55..f0d2b32 100644
--- a/src/stdbit/stdc_first_leading_zero_ul.h
+++ b/src/stdbit/stdc_first_leading_zero_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_zero_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_UL_H
diff --git a/src/stdbit/stdc_first_leading_zero_ull.cpp b/src/stdbit/stdc_first_leading_zero_ull.cpp
index 5a69197..6559143 100644
--- a/src/stdbit/stdc_first_leading_zero_ull.cpp
+++ b/src/stdbit/stdc_first_leading_zero_ull.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_zero_ull.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_zero_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(first_leading_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_zero_ull.h b/src/stdbit/stdc_first_leading_zero_ull.h
index 9aec5e7..6cdb179 100644
--- a/src/stdbit/stdc_first_leading_zero_ull.h
+++ b/src/stdbit/stdc_first_leading_zero_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_zero_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_ULL_H
diff --git a/src/stdbit/stdc_first_leading_zero_us.cpp b/src/stdbit/stdc_first_leading_zero_us.cpp
index 6482c86..25c3d89 100644
--- a/src/stdbit/stdc_first_leading_zero_us.cpp
+++ b/src/stdbit/stdc_first_leading_zero_us.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_leading_zero_us.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_leading_zero_us,
                    (unsigned short value)) {
   return static_cast<unsigned>(first_leading_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_leading_zero_us.h b/src/stdbit/stdc_first_leading_zero_us.h
index 8587378..eacd406 100644
--- a/src/stdbit/stdc_first_leading_zero_us.h
+++ b/src/stdbit/stdc_first_leading_zero_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_leading_zero_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_LEADING_ZERO_US_H
diff --git a/src/stdbit/stdc_first_trailing_one_uc.cpp b/src/stdbit/stdc_first_trailing_one_uc.cpp
index d3e8825..cd88024 100644
--- a/src/stdbit/stdc_first_trailing_one_uc.cpp
+++ b/src/stdbit/stdc_first_trailing_one_uc.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_one_uc.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_one_uc,
                    (unsigned char value)) {
   return static_cast<unsigned>(first_trailing_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_one_uc.h b/src/stdbit/stdc_first_trailing_one_uc.h
index d733ce8..b54ca47 100644
--- a/src/stdbit/stdc_first_trailing_one_uc.h
+++ b/src/stdbit/stdc_first_trailing_one_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_one_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UC_H
diff --git a/src/stdbit/stdc_first_trailing_one_ui.cpp b/src/stdbit/stdc_first_trailing_one_ui.cpp
index 842bd69..03233d5 100644
--- a/src/stdbit/stdc_first_trailing_one_ui.cpp
+++ b/src/stdbit/stdc_first_trailing_one_ui.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_trailing_one_ui.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_one_ui, (unsigned value)) {
   return static_cast<unsigned>(first_trailing_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_one_ui.h b/src/stdbit/stdc_first_trailing_one_ui.h
index 6a6a504..be3eaf8 100644
--- a/src/stdbit/stdc_first_trailing_one_ui.h
+++ b/src/stdbit/stdc_first_trailing_one_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_one_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UI_H
diff --git a/src/stdbit/stdc_first_trailing_one_ul.cpp b/src/stdbit/stdc_first_trailing_one_ul.cpp
index 0497d1d..0e5080d 100644
--- a/src/stdbit/stdc_first_trailing_one_ul.cpp
+++ b/src/stdbit/stdc_first_trailing_one_ul.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_one_ul.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_one_ul,
                    (unsigned long value)) {
   return static_cast<unsigned>(first_trailing_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_one_ul.h b/src/stdbit/stdc_first_trailing_one_ul.h
index 09b6a9b..c0ad0da 100644
--- a/src/stdbit/stdc_first_trailing_one_ul.h
+++ b/src/stdbit/stdc_first_trailing_one_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_one_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_UL_H
diff --git a/src/stdbit/stdc_first_trailing_one_ull.cpp b/src/stdbit/stdc_first_trailing_one_ull.cpp
index 6e062dd..3336983 100644
--- a/src/stdbit/stdc_first_trailing_one_ull.cpp
+++ b/src/stdbit/stdc_first_trailing_one_ull.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_one_ull.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_one_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(first_trailing_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_one_ull.h b/src/stdbit/stdc_first_trailing_one_ull.h
index 3e12a1d..7cf961c 100644
--- a/src/stdbit/stdc_first_trailing_one_ull.h
+++ b/src/stdbit/stdc_first_trailing_one_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_one_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_ULL_H
diff --git a/src/stdbit/stdc_first_trailing_one_us.cpp b/src/stdbit/stdc_first_trailing_one_us.cpp
index e90158f..01cf247 100644
--- a/src/stdbit/stdc_first_trailing_one_us.cpp
+++ b/src/stdbit/stdc_first_trailing_one_us.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_one_us.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_one_us,
                    (unsigned short value)) {
   return static_cast<unsigned>(first_trailing_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_one_us.h b/src/stdbit/stdc_first_trailing_one_us.h
index f380898..24b1db5 100644
--- a/src/stdbit/stdc_first_trailing_one_us.h
+++ b/src/stdbit/stdc_first_trailing_one_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_one_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ONE_US_H
diff --git a/src/stdbit/stdc_first_trailing_zero_uc.cpp b/src/stdbit/stdc_first_trailing_zero_uc.cpp
index a6939f6..617839b 100644
--- a/src/stdbit/stdc_first_trailing_zero_uc.cpp
+++ b/src/stdbit/stdc_first_trailing_zero_uc.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_zero_uc.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_zero_uc,
                    (unsigned char value)) {
   return static_cast<unsigned>(first_trailing_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_zero_uc.h b/src/stdbit/stdc_first_trailing_zero_uc.h
index 242472a..39f61df 100644
--- a/src/stdbit/stdc_first_trailing_zero_uc.h
+++ b/src/stdbit/stdc_first_trailing_zero_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_zero_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UC_H
diff --git a/src/stdbit/stdc_first_trailing_zero_ui.cpp b/src/stdbit/stdc_first_trailing_zero_ui.cpp
index 7a50b69..c852f51 100644
--- a/src/stdbit/stdc_first_trailing_zero_ui.cpp
+++ b/src/stdbit/stdc_first_trailing_zero_ui.cpp
@@ -9,12 +9,13 @@
 #include "src/stdbit/stdc_first_trailing_zero_ui.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_zero_ui, (unsigned value)) {
   return static_cast<unsigned>(first_trailing_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_zero_ui.h b/src/stdbit/stdc_first_trailing_zero_ui.h
index cc308f7..d43399b 100644
--- a/src/stdbit/stdc_first_trailing_zero_ui.h
+++ b/src/stdbit/stdc_first_trailing_zero_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_zero_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UI_H
diff --git a/src/stdbit/stdc_first_trailing_zero_ul.cpp b/src/stdbit/stdc_first_trailing_zero_ul.cpp
index 88acbab..42dccdf 100644
--- a/src/stdbit/stdc_first_trailing_zero_ul.cpp
+++ b/src/stdbit/stdc_first_trailing_zero_ul.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_zero_ul.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_zero_ul,
                    (unsigned long value)) {
   return static_cast<unsigned>(first_trailing_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_zero_ul.h b/src/stdbit/stdc_first_trailing_zero_ul.h
index 8241337..f6c9fdf 100644
--- a/src/stdbit/stdc_first_trailing_zero_ul.h
+++ b/src/stdbit/stdc_first_trailing_zero_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_zero_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_UL_H
diff --git a/src/stdbit/stdc_first_trailing_zero_ull.cpp b/src/stdbit/stdc_first_trailing_zero_ull.cpp
index 92df8f2..4282eb4 100644
--- a/src/stdbit/stdc_first_trailing_zero_ull.cpp
+++ b/src/stdbit/stdc_first_trailing_zero_ull.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_zero_ull.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_zero_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(first_trailing_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_zero_ull.h b/src/stdbit/stdc_first_trailing_zero_ull.h
index 3737fc1..ddd8b2e 100644
--- a/src/stdbit/stdc_first_trailing_zero_ull.h
+++ b/src/stdbit/stdc_first_trailing_zero_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_zero_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_ULL_H
diff --git a/src/stdbit/stdc_first_trailing_zero_us.cpp b/src/stdbit/stdc_first_trailing_zero_us.cpp
index 86caa20..c49c985 100644
--- a/src/stdbit/stdc_first_trailing_zero_us.cpp
+++ b/src/stdbit/stdc_first_trailing_zero_us.cpp
@@ -9,13 +9,14 @@
 #include "src/stdbit/stdc_first_trailing_zero_us.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_first_trailing_zero_us,
                    (unsigned short value)) {
   return static_cast<unsigned>(first_trailing_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_first_trailing_zero_us.h b/src/stdbit/stdc_first_trailing_zero_us.h
index 608b052..8b95888 100644
--- a/src/stdbit/stdc_first_trailing_zero_us.h
+++ b/src/stdbit/stdc_first_trailing_zero_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_first_trailing_zero_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_FIRST_TRAILING_ZERO_US_H
diff --git a/src/stdbit/stdc_has_single_bit_uc.cpp b/src/stdbit/stdc_has_single_bit_uc.cpp
index e5acdc2..cf3011a 100644
--- a/src/stdbit/stdc_has_single_bit_uc.cpp
+++ b/src/stdbit/stdc_has_single_bit_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(bool, stdc_has_single_bit_uc, (unsigned char value)) {
   return cpp::has_single_bit(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_has_single_bit_uc.h b/src/stdbit/stdc_has_single_bit_uc.h
index 028d4ee..89b09b4 100644
--- a/src/stdbit/stdc_has_single_bit_uc.h
+++ b/src/stdbit/stdc_has_single_bit_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 bool stdc_has_single_bit_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UC_H
diff --git a/src/stdbit/stdc_has_single_bit_ui.cpp b/src/stdbit/stdc_has_single_bit_ui.cpp
index 3757888..06de583 100644
--- a/src/stdbit/stdc_has_single_bit_ui.cpp
+++ b/src/stdbit/stdc_has_single_bit_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(bool, stdc_has_single_bit_ui, (unsigned value)) {
   return cpp::has_single_bit(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_has_single_bit_ui.h b/src/stdbit/stdc_has_single_bit_ui.h
index 1e8cd9a..e7dab6a 100644
--- a/src/stdbit/stdc_has_single_bit_ui.h
+++ b/src/stdbit/stdc_has_single_bit_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 bool stdc_has_single_bit_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UI_H
diff --git a/src/stdbit/stdc_has_single_bit_ul.cpp b/src/stdbit/stdc_has_single_bit_ul.cpp
index 85133ab..b2e586f 100644
--- a/src/stdbit/stdc_has_single_bit_ul.cpp
+++ b/src/stdbit/stdc_has_single_bit_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(bool, stdc_has_single_bit_ul, (unsigned long value)) {
   return cpp::has_single_bit(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_has_single_bit_ul.h b/src/stdbit/stdc_has_single_bit_ul.h
index 9b924fc..4614cc0 100644
--- a/src/stdbit/stdc_has_single_bit_ul.h
+++ b/src/stdbit/stdc_has_single_bit_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 bool stdc_has_single_bit_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_UL_H
diff --git a/src/stdbit/stdc_has_single_bit_ull.cpp b/src/stdbit/stdc_has_single_bit_ull.cpp
index 4491cf2..45aeda8 100644
--- a/src/stdbit/stdc_has_single_bit_ull.cpp
+++ b/src/stdbit/stdc_has_single_bit_ull.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(bool, stdc_has_single_bit_ull, (unsigned long long value)) {
   return cpp::has_single_bit(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_has_single_bit_ull.h b/src/stdbit/stdc_has_single_bit_ull.h
index d4802bc..84d4702 100644
--- a/src/stdbit/stdc_has_single_bit_ull.h
+++ b/src/stdbit/stdc_has_single_bit_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 bool stdc_has_single_bit_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_ULL_H
diff --git a/src/stdbit/stdc_has_single_bit_us.cpp b/src/stdbit/stdc_has_single_bit_us.cpp
index 7a42ae5..e915293 100644
--- a/src/stdbit/stdc_has_single_bit_us.cpp
+++ b/src/stdbit/stdc_has_single_bit_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(bool, stdc_has_single_bit_us, (unsigned short value)) {
   return cpp::has_single_bit(value);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_has_single_bit_us.h b/src/stdbit/stdc_has_single_bit_us.h
index 201ff49..d0fc519 100644
--- a/src/stdbit/stdc_has_single_bit_us.h
+++ b/src/stdbit/stdc_has_single_bit_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 bool stdc_has_single_bit_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_HAS_SINGLE_BIT_US_H
diff --git a/src/stdbit/stdc_leading_ones_uc.cpp b/src/stdbit/stdc_leading_ones_uc.cpp
index 69322d9..020bd40 100644
--- a/src/stdbit/stdc_leading_ones_uc.cpp
+++ b/src/stdbit/stdc_leading_ones_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_ones_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::countl_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_ones_uc.h b/src/stdbit/stdc_leading_ones_uc.h
index fc4d2bd..7daaf67 100644
--- a/src/stdbit/stdc_leading_ones_uc.h
+++ b/src/stdbit/stdc_leading_ones_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_ones_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UC_H
diff --git a/src/stdbit/stdc_leading_ones_ui.cpp b/src/stdbit/stdc_leading_ones_ui.cpp
index 2a73c2c..2c51755 100644
--- a/src/stdbit/stdc_leading_ones_ui.cpp
+++ b/src/stdbit/stdc_leading_ones_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_ones_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::countl_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_ones_ui.h b/src/stdbit/stdc_leading_ones_ui.h
index c381eb5..93b042c 100644
--- a/src/stdbit/stdc_leading_ones_ui.h
+++ b/src/stdbit/stdc_leading_ones_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_ones_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UI_H
diff --git a/src/stdbit/stdc_leading_ones_ul.cpp b/src/stdbit/stdc_leading_ones_ul.cpp
index 5b2f61d..50570a5 100644
--- a/src/stdbit/stdc_leading_ones_ul.cpp
+++ b/src/stdbit/stdc_leading_ones_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_ones_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::countl_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_ones_ul.h b/src/stdbit/stdc_leading_ones_ul.h
index 3441edf..d4cf91c 100644
--- a/src/stdbit/stdc_leading_ones_ul.h
+++ b/src/stdbit/stdc_leading_ones_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_ones_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_UL_H
diff --git a/src/stdbit/stdc_leading_ones_ull.cpp b/src/stdbit/stdc_leading_ones_ull.cpp
index 05660b9..aff91a4 100644
--- a/src/stdbit/stdc_leading_ones_ull.cpp
+++ b/src/stdbit/stdc_leading_ones_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_ones_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(cpp::countl_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_ones_ull.h b/src/stdbit/stdc_leading_ones_ull.h
index 167eb73..e459e4b 100644
--- a/src/stdbit/stdc_leading_ones_ull.h
+++ b/src/stdbit/stdc_leading_ones_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_ones_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_ULL_H
diff --git a/src/stdbit/stdc_leading_ones_us.cpp b/src/stdbit/stdc_leading_ones_us.cpp
index d93327d..34db4ec 100644
--- a/src/stdbit/stdc_leading_ones_us.cpp
+++ b/src/stdbit/stdc_leading_ones_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_ones_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::countl_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_ones_us.h b/src/stdbit/stdc_leading_ones_us.h
index 2a552d7..206756b 100644
--- a/src/stdbit/stdc_leading_ones_us.h
+++ b/src/stdbit/stdc_leading_ones_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_ones_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ONES_US_H
diff --git a/src/stdbit/stdc_leading_zeros_uc.cpp b/src/stdbit/stdc_leading_zeros_uc.cpp
index dbd2d76..d9b1628 100644
--- a/src/stdbit/stdc_leading_zeros_uc.cpp
+++ b/src/stdbit/stdc_leading_zeros_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_zeros_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::countl_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_zeros_uc.h b/src/stdbit/stdc_leading_zeros_uc.h
index 1edca66..6bc1f30 100644
--- a/src/stdbit/stdc_leading_zeros_uc.h
+++ b/src/stdbit/stdc_leading_zeros_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_zeros_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UC_H
diff --git a/src/stdbit/stdc_leading_zeros_ui.cpp b/src/stdbit/stdc_leading_zeros_ui.cpp
index 99bc0eb..05a1a50 100644
--- a/src/stdbit/stdc_leading_zeros_ui.cpp
+++ b/src/stdbit/stdc_leading_zeros_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_zeros_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::countl_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_zeros_ui.h b/src/stdbit/stdc_leading_zeros_ui.h
index 14113d4..ce7f266 100644
--- a/src/stdbit/stdc_leading_zeros_ui.h
+++ b/src/stdbit/stdc_leading_zeros_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_zeros_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UI_H
diff --git a/src/stdbit/stdc_leading_zeros_ul.cpp b/src/stdbit/stdc_leading_zeros_ul.cpp
index 0d5ff88..e560889 100644
--- a/src/stdbit/stdc_leading_zeros_ul.cpp
+++ b/src/stdbit/stdc_leading_zeros_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_zeros_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::countl_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_zeros_ul.h b/src/stdbit/stdc_leading_zeros_ul.h
index 5bac6df..a4c671f 100644
--- a/src/stdbit/stdc_leading_zeros_ul.h
+++ b/src/stdbit/stdc_leading_zeros_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_zeros_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_UL_H
diff --git a/src/stdbit/stdc_leading_zeros_ull.cpp b/src/stdbit/stdc_leading_zeros_ull.cpp
index b23cea7..0bf3f13 100644
--- a/src/stdbit/stdc_leading_zeros_ull.cpp
+++ b/src/stdbit/stdc_leading_zeros_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_zeros_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(cpp::countl_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_zeros_ull.h b/src/stdbit/stdc_leading_zeros_ull.h
index e136243..a59fe2e 100644
--- a/src/stdbit/stdc_leading_zeros_ull.h
+++ b/src/stdbit/stdc_leading_zeros_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_zeros_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_ULL_H
diff --git a/src/stdbit/stdc_leading_zeros_us.cpp b/src/stdbit/stdc_leading_zeros_us.cpp
index 424fdc7..00ac7c3 100644
--- a/src/stdbit/stdc_leading_zeros_us.cpp
+++ b/src/stdbit/stdc_leading_zeros_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_leading_zeros_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::countl_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_leading_zeros_us.h b/src/stdbit/stdc_leading_zeros_us.h
index 6a39690..1ee4732 100644
--- a/src/stdbit/stdc_leading_zeros_us.h
+++ b/src/stdbit/stdc_leading_zeros_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_leading_zeros_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_LEADING_ZEROS_US_H
diff --git a/src/stdbit/stdc_trailing_ones_uc.cpp b/src/stdbit/stdc_trailing_ones_uc.cpp
index eabb213..302a766 100644
--- a/src/stdbit/stdc_trailing_ones_uc.cpp
+++ b/src/stdbit/stdc_trailing_ones_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_ones_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::countr_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_ones_uc.h b/src/stdbit/stdc_trailing_ones_uc.h
index 9736e21..8eced3b 100644
--- a/src/stdbit/stdc_trailing_ones_uc.h
+++ b/src/stdbit/stdc_trailing_ones_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_ones_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UC_H
diff --git a/src/stdbit/stdc_trailing_ones_ui.cpp b/src/stdbit/stdc_trailing_ones_ui.cpp
index 87eb54f..8ad6e78 100644
--- a/src/stdbit/stdc_trailing_ones_ui.cpp
+++ b/src/stdbit/stdc_trailing_ones_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_ones_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::countr_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_ones_ui.h b/src/stdbit/stdc_trailing_ones_ui.h
index aad7fcf..de7c931 100644
--- a/src/stdbit/stdc_trailing_ones_ui.h
+++ b/src/stdbit/stdc_trailing_ones_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_ones_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UI_H
diff --git a/src/stdbit/stdc_trailing_ones_ul.cpp b/src/stdbit/stdc_trailing_ones_ul.cpp
index 6d358a2..af398a1 100644
--- a/src/stdbit/stdc_trailing_ones_ul.cpp
+++ b/src/stdbit/stdc_trailing_ones_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_ones_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::countr_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_ones_ul.h b/src/stdbit/stdc_trailing_ones_ul.h
index 8058950..64da538 100644
--- a/src/stdbit/stdc_trailing_ones_ul.h
+++ b/src/stdbit/stdc_trailing_ones_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_ones_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_UL_H
diff --git a/src/stdbit/stdc_trailing_ones_ull.cpp b/src/stdbit/stdc_trailing_ones_ull.cpp
index fb5fffe..ef6927e 100644
--- a/src/stdbit/stdc_trailing_ones_ull.cpp
+++ b/src/stdbit/stdc_trailing_ones_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_ones_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(cpp::countr_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_ones_ull.h b/src/stdbit/stdc_trailing_ones_ull.h
index 3d3f0b3..f93bd57 100644
--- a/src/stdbit/stdc_trailing_ones_ull.h
+++ b/src/stdbit/stdc_trailing_ones_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_ones_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_ULL_H
diff --git a/src/stdbit/stdc_trailing_ones_us.cpp b/src/stdbit/stdc_trailing_ones_us.cpp
index ee7ff4f..3a54d8e 100644
--- a/src/stdbit/stdc_trailing_ones_us.cpp
+++ b/src/stdbit/stdc_trailing_ones_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_ones_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::countr_one(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_ones_us.h b/src/stdbit/stdc_trailing_ones_us.h
index b783cd2..3dad460 100644
--- a/src/stdbit/stdc_trailing_ones_us.h
+++ b/src/stdbit/stdc_trailing_ones_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_ones_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ONES_US_H
diff --git a/src/stdbit/stdc_trailing_zeros_uc.cpp b/src/stdbit/stdc_trailing_zeros_uc.cpp
index 36924c5..fcc05d4 100644
--- a/src/stdbit/stdc_trailing_zeros_uc.cpp
+++ b/src/stdbit/stdc_trailing_zeros_uc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_zeros_uc, (unsigned char value)) {
   return static_cast<unsigned>(cpp::countr_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_zeros_uc.h b/src/stdbit/stdc_trailing_zeros_uc.h
index 866201e..114c05c 100644
--- a/src/stdbit/stdc_trailing_zeros_uc.h
+++ b/src/stdbit/stdc_trailing_zeros_uc.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UC_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_zeros_uc(unsigned char value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UC_H
diff --git a/src/stdbit/stdc_trailing_zeros_ui.cpp b/src/stdbit/stdc_trailing_zeros_ui.cpp
index a264fd9..94bca3e 100644
--- a/src/stdbit/stdc_trailing_zeros_ui.cpp
+++ b/src/stdbit/stdc_trailing_zeros_ui.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_zeros_ui, (unsigned value)) {
   return static_cast<unsigned>(cpp::countr_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_zeros_ui.h b/src/stdbit/stdc_trailing_zeros_ui.h
index 0642e31..0d8f5ee 100644
--- a/src/stdbit/stdc_trailing_zeros_ui.h
+++ b/src/stdbit/stdc_trailing_zeros_ui.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UI_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_zeros_ui(unsigned value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UI_H
diff --git a/src/stdbit/stdc_trailing_zeros_ul.cpp b/src/stdbit/stdc_trailing_zeros_ul.cpp
index 8e0c36c..407eb85 100644
--- a/src/stdbit/stdc_trailing_zeros_ul.cpp
+++ b/src/stdbit/stdc_trailing_zeros_ul.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_zeros_ul, (unsigned long value)) {
   return static_cast<unsigned>(cpp::countr_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_zeros_ul.h b/src/stdbit/stdc_trailing_zeros_ul.h
index e10b447..368cd67 100644
--- a/src/stdbit/stdc_trailing_zeros_ul.h
+++ b/src/stdbit/stdc_trailing_zeros_ul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_zeros_ul(unsigned long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_UL_H
diff --git a/src/stdbit/stdc_trailing_zeros_ull.cpp b/src/stdbit/stdc_trailing_zeros_ull.cpp
index 77cb20c..eba3dff 100644
--- a/src/stdbit/stdc_trailing_zeros_ull.cpp
+++ b/src/stdbit/stdc_trailing_zeros_ull.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_zeros_ull,
                    (unsigned long long value)) {
   return static_cast<unsigned>(cpp::countr_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_zeros_ull.h b/src/stdbit/stdc_trailing_zeros_ull.h
index f95169d..896c33b 100644
--- a/src/stdbit/stdc_trailing_zeros_ull.h
+++ b/src/stdbit/stdc_trailing_zeros_ull.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_ULL_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_ULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_zeros_ull(unsigned long long value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_ULL_H
diff --git a/src/stdbit/stdc_trailing_zeros_us.cpp b/src/stdbit/stdc_trailing_zeros_us.cpp
index a5b9f4a..82eba56 100644
--- a/src/stdbit/stdc_trailing_zeros_us.cpp
+++ b/src/stdbit/stdc_trailing_zeros_us.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned, stdc_trailing_zeros_us, (unsigned short value)) {
   return static_cast<unsigned>(cpp::countr_zero(value));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdbit/stdc_trailing_zeros_us.h b/src/stdbit/stdc_trailing_zeros_us.h
index ddbdf0d..0241192 100644
--- a/src/stdbit/stdc_trailing_zeros_us.h
+++ b/src/stdbit/stdc_trailing_zeros_us.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_US_H
 #define LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_US_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned stdc_trailing_zeros_us(unsigned short value);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDBIT_STDC_TRAILING_ZEROS_US_H
diff --git a/src/stdfix/abshk.cpp b/src/stdfix/abshk.cpp
index d76a5e6..3849889 100644
--- a/src/stdfix/abshk.cpp
+++ b/src/stdfix/abshk.cpp
@@ -9,11 +9,12 @@
 #include "abshk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(short accum, abshk, (short accum x)) {
   return fixed_point::abs(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/abshk.h b/src/stdfix/abshk.h
index 13c9300..060abed 100644
--- a/src/stdfix/abshk.h
+++ b/src/stdfix/abshk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSHK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 short accum abshk(short accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSHK_H
diff --git a/src/stdfix/abshr.cpp b/src/stdfix/abshr.cpp
index db88704..d428980 100644
--- a/src/stdfix/abshr.cpp
+++ b/src/stdfix/abshr.cpp
@@ -9,11 +9,12 @@
 #include "abshr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(short fract, abshr, (short fract x)) {
   return fixed_point::abs(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/abshr.h b/src/stdfix/abshr.h
index 5acd0cf..162c439 100644
--- a/src/stdfix/abshr.h
+++ b/src/stdfix/abshr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSHR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 short fract abshr(short fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSHR_H
diff --git a/src/stdfix/absk.cpp b/src/stdfix/absk.cpp
index ca231d9..8c18175 100644
--- a/src/stdfix/absk.cpp
+++ b/src/stdfix/absk.cpp
@@ -9,9 +9,10 @@
 #include "absk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(accum, absk, (accum x)) { return fixed_point::abs(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/absk.h b/src/stdfix/absk.h
index 73dfcac..266a4fa 100644
--- a/src/stdfix/absk.h
+++ b/src/stdfix/absk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 accum absk(accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSK_H
diff --git a/src/stdfix/abslk.cpp b/src/stdfix/abslk.cpp
index 5e08519..c24d216 100644
--- a/src/stdfix/abslk.cpp
+++ b/src/stdfix/abslk.cpp
@@ -9,11 +9,12 @@
 #include "abslk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long accum, abslk, (long accum x)) {
   return fixed_point::abs(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/abslk.h b/src/stdfix/abslk.h
index 7de116f..a1ee8ca 100644
--- a/src/stdfix/abslk.h
+++ b/src/stdfix/abslk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSLK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long accum abslk(long accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSLK_H
diff --git a/src/stdfix/abslr.cpp b/src/stdfix/abslr.cpp
index 0f89695..3f84fc7 100644
--- a/src/stdfix/abslr.cpp
+++ b/src/stdfix/abslr.cpp
@@ -9,11 +9,12 @@
 #include "abslr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long fract, abslr, (long fract x)) {
   return fixed_point::abs(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/abslr.h b/src/stdfix/abslr.h
index bf5b585..961409a 100644
--- a/src/stdfix/abslr.h
+++ b/src/stdfix/abslr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSLR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long fract abslr(long fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSLR_H
diff --git a/src/stdfix/absr.cpp b/src/stdfix/absr.cpp
index dbbecb4..42f639d 100644
--- a/src/stdfix/absr.cpp
+++ b/src/stdfix/absr.cpp
@@ -9,9 +9,10 @@
 #include "absr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(fract, absr, (fract x)) { return fixed_point::abs(x); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/absr.h b/src/stdfix/absr.h
index b5ead7c..0b47ab1 100644
--- a/src/stdfix/absr.h
+++ b/src/stdfix/absr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ABSR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 fract absr(fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ABSR_H
diff --git a/src/stdfix/exphk.cpp b/src/stdfix/exphk.cpp
index 19a972b..0b17a40 100644
--- a/src/stdfix/exphk.cpp
+++ b/src/stdfix/exphk.cpp
@@ -10,8 +10,9 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -89,4 +90,4 @@ LLVM_LIBC_FUNCTION(short accum, exphk, (short accum x)) {
   return (exp_hi * (exp_mid * (0x1.0p0hk + lo)));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/exphk.h b/src/stdfix/exphk.h
index da03bb7..d10dda1 100644
--- a/src/stdfix/exphk.h
+++ b/src/stdfix/exphk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_EXPHK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 short accum exphk(short accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_EXPHK_H
diff --git a/src/stdfix/expk.cpp b/src/stdfix/expk.cpp
index 57227fd..0851c7f 100644
--- a/src/stdfix/expk.cpp
+++ b/src/stdfix/expk.cpp
@@ -10,8 +10,9 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -101,4 +102,4 @@ LLVM_LIBC_FUNCTION(accum, expk, (accum x)) {
   return (exp_hi * (exp_mid * l2));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/expk.h b/src/stdfix/expk.h
index 4526686..4fd1dd5 100644
--- a/src/stdfix/expk.h
+++ b/src/stdfix/expk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_EXPK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 accum expk(accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_EXPK_H
diff --git a/src/stdfix/hkbits.cpp b/src/stdfix/hkbits.cpp
new file mode 100644
index 0000000..a2167e8
--- /dev/null
+++ b/src/stdfix/hkbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of hkbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hkbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(short accum, hkbits, (int_hk_t x)) {
+  return cpp::bit_cast<short accum, int_hk_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/hkbits.h b/src/stdfix/hkbits.h
new file mode 100644
index 0000000..bf1bf82
--- /dev/null
+++ b/src/stdfix/hkbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for hkbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_HKBITS_H
+#define LLVM_LIBC_SRC_STDFIX_HKBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+short accum hkbits(int_hk_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_HKBITS_H
diff --git a/src/stdfix/hrbits.cpp b/src/stdfix/hrbits.cpp
new file mode 100644
index 0000000..cc314fe
--- /dev/null
+++ b/src/stdfix/hrbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of hrbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hrbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(short fract, hrbits, (int_hr_t x)) {
+  return cpp::bit_cast<short fract, int_hr_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/hrbits.h b/src/stdfix/hrbits.h
new file mode 100644
index 0000000..c6bd99a
--- /dev/null
+++ b/src/stdfix/hrbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for hrbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_HRBITS_H
+#define LLVM_LIBC_SRC_STDFIX_HRBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+short fract hrbits(int_hr_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_HRBITS_H
diff --git a/src/stdfix/kbits.cpp b/src/stdfix/kbits.cpp
new file mode 100644
index 0000000..61fd4f6
--- /dev/null
+++ b/src/stdfix/kbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of kbits function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "kbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(accum, kbits, (int_k_t x)) {
+  return cpp::bit_cast<accum, int_k_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/kbits.h b/src/stdfix/kbits.h
new file mode 100644
index 0000000..7e709af
--- /dev/null
+++ b/src/stdfix/kbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for kbits -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_KBITS_H
+#define LLVM_LIBC_SRC_STDFIX_KBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+accum kbits(int_k_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_KBITS_H
diff --git a/src/stdfix/lkbits.cpp b/src/stdfix/lkbits.cpp
new file mode 100644
index 0000000..83f3433
--- /dev/null
+++ b/src/stdfix/lkbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of lkbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "lkbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(long accum, lkbits, (int_lk_t x)) {
+  return cpp::bit_cast<long accum, int_lk_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/lkbits.h b/src/stdfix/lkbits.h
new file mode 100644
index 0000000..177f121
--- /dev/null
+++ b/src/stdfix/lkbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for lkbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_LKBITS_H
+#define LLVM_LIBC_SRC_STDFIX_LKBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long accum lkbits(int_lk_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_LKBITS_H
diff --git a/src/stdfix/lrbits.cpp b/src/stdfix/lrbits.cpp
new file mode 100644
index 0000000..a726816
--- /dev/null
+++ b/src/stdfix/lrbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of lrbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "lrbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(long fract, lrbits, (int_lr_t x)) {
+  return cpp::bit_cast<long fract, int_lr_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/lrbits.h b/src/stdfix/lrbits.h
new file mode 100644
index 0000000..087aa19
--- /dev/null
+++ b/src/stdfix/lrbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for lrbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_LRBITS_H
+#define LLVM_LIBC_SRC_STDFIX_LRBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long fract lrbits(int_lr_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_LRBITS_H
diff --git a/src/stdfix/rbits.cpp b/src/stdfix/rbits.cpp
new file mode 100644
index 0000000..c31df6e
--- /dev/null
+++ b/src/stdfix/rbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of rbits function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "rbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(fract, rbits, (int_r_t x)) {
+  return cpp::bit_cast<fract, int_r_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/rbits.h b/src/stdfix/rbits.h
new file mode 100644
index 0000000..4922e1c
--- /dev/null
+++ b/src/stdfix/rbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for rbits -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_RBITS_H
+#define LLVM_LIBC_SRC_STDFIX_RBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+fract rbits(int_r_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_RBITS_H
diff --git a/src/stdfix/roundhk.cpp b/src/stdfix/roundhk.cpp
index a4f459e..c94aa6d 100644
--- a/src/stdfix/roundhk.cpp
+++ b/src/stdfix/roundhk.cpp
@@ -9,11 +9,12 @@
 #include "roundhk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(short accum, roundhk, (short accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundhk.h b/src/stdfix/roundhk.h
index 9a5c874..0c1e378 100644
--- a/src/stdfix/roundhk.h
+++ b/src/stdfix/roundhk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDHK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 short accum roundhk(short accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDHK_H
diff --git a/src/stdfix/roundhr.cpp b/src/stdfix/roundhr.cpp
index 7757d1c..539f951 100644
--- a/src/stdfix/roundhr.cpp
+++ b/src/stdfix/roundhr.cpp
@@ -9,11 +9,12 @@
 #include "roundhr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(short fract, roundhr, (short fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundhr.h b/src/stdfix/roundhr.h
index ba5a679..a3a4ace 100644
--- a/src/stdfix/roundhr.h
+++ b/src/stdfix/roundhr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDHR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 short fract roundhr(short fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDHR_H
diff --git a/src/stdfix/roundk.cpp b/src/stdfix/roundk.cpp
index bf47dd9..3aedfa3 100644
--- a/src/stdfix/roundk.cpp
+++ b/src/stdfix/roundk.cpp
@@ -9,11 +9,12 @@
 #include "roundk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(accum, roundk, (accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundk.h b/src/stdfix/roundk.h
index e9fa6d8..36d3499 100644
--- a/src/stdfix/roundk.h
+++ b/src/stdfix/roundk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 accum roundk(accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDK_H
diff --git a/src/stdfix/roundlk.cpp b/src/stdfix/roundlk.cpp
index d2ffe8a..94dceb4 100644
--- a/src/stdfix/roundlk.cpp
+++ b/src/stdfix/roundlk.cpp
@@ -9,11 +9,12 @@
 #include "roundlk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long accum, roundlk, (long accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundlk.h b/src/stdfix/roundlk.h
index 5fa0e90..e1661ec 100644
--- a/src/stdfix/roundlk.h
+++ b/src/stdfix/roundlk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDLK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long accum roundlk(long accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDLK_H
diff --git a/src/stdfix/roundlr.cpp b/src/stdfix/roundlr.cpp
index cd4c911..5a7737d 100644
--- a/src/stdfix/roundlr.cpp
+++ b/src/stdfix/roundlr.cpp
@@ -9,11 +9,12 @@
 #include "roundlr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long fract, roundlr, (long fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundlr.h b/src/stdfix/roundlr.h
index c015292..58d6ffa 100644
--- a/src/stdfix/roundlr.h
+++ b/src/stdfix/roundlr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDLR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long fract roundlr(long fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDLR_H
diff --git a/src/stdfix/roundr.cpp b/src/stdfix/roundr.cpp
index 2421693..d4ade17 100644
--- a/src/stdfix/roundr.cpp
+++ b/src/stdfix/roundr.cpp
@@ -9,11 +9,12 @@
 #include "roundr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(fract, roundr, (fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundr.h b/src/stdfix/roundr.h
index b5b1375..105314d 100644
--- a/src/stdfix/roundr.h
+++ b/src/stdfix/roundr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 fract roundr(fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDR_H
diff --git a/src/stdfix/rounduhk.cpp b/src/stdfix/rounduhk.cpp
index 2256158..3c13a31 100644
--- a/src/stdfix/rounduhk.cpp
+++ b/src/stdfix/rounduhk.cpp
@@ -9,12 +9,13 @@
 #include "rounduhk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short accum, rounduhk,
                    (unsigned short accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/rounduhk.h b/src/stdfix/rounduhk.h
index 85ebf29..e6cbc21 100644
--- a/src/stdfix/rounduhk.h
+++ b/src/stdfix/rounduhk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDUHK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short accum rounduhk(unsigned short accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDUHK_H
diff --git a/src/stdfix/rounduhr.cpp b/src/stdfix/rounduhr.cpp
index e2e3435..8c7abaf 100644
--- a/src/stdfix/rounduhr.cpp
+++ b/src/stdfix/rounduhr.cpp
@@ -9,12 +9,13 @@
 #include "rounduhr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short fract, rounduhr,
                    (unsigned short fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/rounduhr.h b/src/stdfix/rounduhr.h
index 1be0aab..2d8c85a 100644
--- a/src/stdfix/rounduhr.h
+++ b/src/stdfix/rounduhr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDUHR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short fract rounduhr(unsigned short fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDUHR_H
diff --git a/src/stdfix/rounduk.cpp b/src/stdfix/rounduk.cpp
index b9f8522..d543a68 100644
--- a/src/stdfix/rounduk.cpp
+++ b/src/stdfix/rounduk.cpp
@@ -9,11 +9,12 @@
 #include "rounduk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned accum, rounduk, (unsigned accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/rounduk.h b/src/stdfix/rounduk.h
index 8dae895..51f0f9c 100644
--- a/src/stdfix/rounduk.h
+++ b/src/stdfix/rounduk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDUK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned accum rounduk(unsigned accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDUK_H
diff --git a/src/stdfix/roundulk.cpp b/src/stdfix/roundulk.cpp
index 241b2c2..09c1d86 100644
--- a/src/stdfix/roundulk.cpp
+++ b/src/stdfix/roundulk.cpp
@@ -9,12 +9,13 @@
 #include "roundulk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long accum, roundulk,
                    (unsigned long accum x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundulk.h b/src/stdfix/roundulk.h
index 81dfd1d..797ce9f 100644
--- a/src/stdfix/roundulk.h
+++ b/src/stdfix/roundulk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDULK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long accum roundulk(unsigned long accum x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDULK_H
diff --git a/src/stdfix/roundulr.cpp b/src/stdfix/roundulr.cpp
index 6c32074..e654b19 100644
--- a/src/stdfix/roundulr.cpp
+++ b/src/stdfix/roundulr.cpp
@@ -9,12 +9,13 @@
 #include "roundulr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long fract, roundulr,
                    (unsigned long fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundulr.h b/src/stdfix/roundulr.h
index 002fc94..1f6165b 100644
--- a/src/stdfix/roundulr.h
+++ b/src/stdfix/roundulr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDULR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long fract roundulr(unsigned long fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDULR_H
diff --git a/src/stdfix/roundur.cpp b/src/stdfix/roundur.cpp
index e91b7f1..1d34854 100644
--- a/src/stdfix/roundur.cpp
+++ b/src/stdfix/roundur.cpp
@@ -9,11 +9,12 @@
 #include "roundur.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned fract, roundur, (unsigned fract x, int n)) {
   return fixed_point::round(x, n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/roundur.h b/src/stdfix/roundur.h
index 72de44b..815fd14 100644
--- a/src/stdfix/roundur.h
+++ b/src/stdfix/roundur.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_ROUNDUR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned fract roundur(unsigned fract x, int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_ROUNDUR_H
diff --git a/src/stdfix/sqrtuhk.cpp b/src/stdfix/sqrtuhk.cpp
index e8dc842..312846a 100644
--- a/src/stdfix/sqrtuhk.cpp
+++ b/src/stdfix/sqrtuhk.cpp
@@ -9,11 +9,12 @@
 #include "sqrtuhk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short accum, sqrtuhk, (unsigned short accum x)) {
   return fixed_point::sqrt(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/sqrtuhk.h b/src/stdfix/sqrtuhk.h
index 80000a0..5b8f9ea 100644
--- a/src/stdfix/sqrtuhk.h
+++ b/src/stdfix/sqrtuhk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_SQRTUHK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short accum sqrtuhk(unsigned short accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_SQRTUHK_H
diff --git a/src/stdfix/sqrtuhr.cpp b/src/stdfix/sqrtuhr.cpp
index 6bba07a..87e151c 100644
--- a/src/stdfix/sqrtuhr.cpp
+++ b/src/stdfix/sqrtuhr.cpp
@@ -9,11 +9,12 @@
 #include "sqrtuhr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short fract, sqrtuhr, (unsigned short fract x)) {
   return fixed_point::sqrt(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/sqrtuhr.h b/src/stdfix/sqrtuhr.h
index fd95f09..390c369 100644
--- a/src/stdfix/sqrtuhr.h
+++ b/src/stdfix/sqrtuhr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_SQRTUHR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short fract sqrtuhr(unsigned short fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_SQRTUHR_H
diff --git a/src/stdfix/sqrtuk.cpp b/src/stdfix/sqrtuk.cpp
index 6e5d811..857f75f 100644
--- a/src/stdfix/sqrtuk.cpp
+++ b/src/stdfix/sqrtuk.cpp
@@ -9,11 +9,12 @@
 #include "sqrtuk.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned accum, sqrtuk, (unsigned accum x)) {
   return fixed_point::sqrt(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/sqrtuk.h b/src/stdfix/sqrtuk.h
index 04d0ada..2b043c1 100644
--- a/src/stdfix/sqrtuk.h
+++ b/src/stdfix/sqrtuk.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_SQRTUK_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned accum sqrtuk(unsigned accum x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_SQRTUK_H
diff --git a/src/stdfix/sqrtulr.cpp b/src/stdfix/sqrtulr.cpp
index c9e5cd5..db9b063 100644
--- a/src/stdfix/sqrtulr.cpp
+++ b/src/stdfix/sqrtulr.cpp
@@ -9,11 +9,12 @@
 #include "sqrtulr.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long fract, sqrtulr, (unsigned long fract x)) {
   return fixed_point::sqrt(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/sqrtulr.h b/src/stdfix/sqrtulr.h
index 284adaa..a43cc44 100644
--- a/src/stdfix/sqrtulr.h
+++ b/src/stdfix/sqrtulr.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_SQRTULR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long fract sqrtulr(unsigned long fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_SQRTULR_H
diff --git a/src/stdfix/sqrtur.cpp b/src/stdfix/sqrtur.cpp
index ac5be84..4c696b2 100644
--- a/src/stdfix/sqrtur.cpp
+++ b/src/stdfix/sqrtur.cpp
@@ -9,11 +9,12 @@
 #include "sqrtur.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned fract, sqrtur, (unsigned fract x)) {
   return fixed_point::sqrt(x);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/sqrtur.h b/src/stdfix/sqrtur.h
index df9dfe5..47a9ab6 100644
--- a/src/stdfix/sqrtur.h
+++ b/src/stdfix/sqrtur.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_SQRTUR_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned fract sqrtur(unsigned fract x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_SQRTUR_H
diff --git a/src/stdfix/uhkbits.cpp b/src/stdfix/uhkbits.cpp
new file mode 100644
index 0000000..8a91c41
--- /dev/null
+++ b/src/stdfix/uhkbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of uhkbits function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "uhkbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned short accum, uhkbits, (uint_uhk_t x)) {
+  return cpp::bit_cast<unsigned short accum, uint_uhk_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/uhkbits.h b/src/stdfix/uhkbits.h
new file mode 100644
index 0000000..7ef1598
--- /dev/null
+++ b/src/stdfix/uhkbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for uhkbits -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_UHKBITS_H
+#define LLVM_LIBC_SRC_STDFIX_UHKBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned short accum uhkbits(uint_uhk_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_UHKBITS_H
diff --git a/src/stdfix/uhksqrtus.cpp b/src/stdfix/uhksqrtus.cpp
index 335750a..f41e879 100644
--- a/src/stdfix/uhksqrtus.cpp
+++ b/src/stdfix/uhksqrtus.cpp
@@ -9,8 +9,9 @@
 #include "uhksqrtus.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned short accum, uhksqrtus, (unsigned short x)) {
 #ifdef LIBC_FAST_MATH
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(unsigned short accum, uhksqrtus, (unsigned short x)) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/uhksqrtus.h b/src/stdfix/uhksqrtus.h
index c24846a..0633f7e 100644
--- a/src/stdfix/uhksqrtus.h
+++ b/src/stdfix/uhksqrtus.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_UHKSQRTUS_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned short accum uhksqrtus(unsigned short x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_UHKSQRTUS_H
diff --git a/src/stdfix/uhrbits.cpp b/src/stdfix/uhrbits.cpp
new file mode 100644
index 0000000..fd6bb13
--- /dev/null
+++ b/src/stdfix/uhrbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of uhrbits function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "uhrbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned short fract, uhrbits, (uint_uhr_t x)) {
+  return cpp::bit_cast<unsigned short fract, uint_uhr_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/uhrbits.h b/src/stdfix/uhrbits.h
new file mode 100644
index 0000000..4011a0e
--- /dev/null
+++ b/src/stdfix/uhrbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for uhrbits -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_UHRBITS_H
+#define LLVM_LIBC_SRC_STDFIX_UHRBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned short fract uhrbits(uint_uhr_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_UHRBITS_H
diff --git a/src/stdfix/ukbits.cpp b/src/stdfix/ukbits.cpp
new file mode 100644
index 0000000..f83a354
--- /dev/null
+++ b/src/stdfix/ukbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of ukbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ukbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned accum, ukbits, (uint_uk_t x)) {
+  return cpp::bit_cast<unsigned accum, uint_uk_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/ukbits.h b/src/stdfix/ukbits.h
new file mode 100644
index 0000000..2374f48
--- /dev/null
+++ b/src/stdfix/ukbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for ukbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_UKBITS_H
+#define LLVM_LIBC_SRC_STDFIX_UKBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned accum ukbits(uint_uk_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_UKBITS_H
diff --git a/src/stdfix/uksqrtui.cpp b/src/stdfix/uksqrtui.cpp
index ee1ae13..504bd06 100644
--- a/src/stdfix/uksqrtui.cpp
+++ b/src/stdfix/uksqrtui.cpp
@@ -9,8 +9,9 @@
 #include "uksqrtui.h"
 #include "src/__support/common.h"
 #include "src/__support/fixed_point/sqrt.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned accum, uksqrtui, (unsigned int x)) {
 #ifdef LIBC_FAST_MATH
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(unsigned accum, uksqrtui, (unsigned int x)) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/uksqrtui.h b/src/stdfix/uksqrtui.h
index cd4ff41..f9fb0e0 100644
--- a/src/stdfix/uksqrtui.h
+++ b/src/stdfix/uksqrtui.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDFIX_UKSQRTUI_H
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned accum uksqrtui(unsigned int x);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDFIX_UKSQRTUI_H
diff --git a/src/stdfix/ulkbits.cpp b/src/stdfix/ulkbits.cpp
new file mode 100644
index 0000000..eaf4057
--- /dev/null
+++ b/src/stdfix/ulkbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of ulkbits function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ulkbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned long accum, ulkbits, (uint_ulk_t x)) {
+  return cpp::bit_cast<unsigned long accum, uint_ulk_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/ulkbits.h b/src/stdfix/ulkbits.h
new file mode 100644
index 0000000..955c96c
--- /dev/null
+++ b/src/stdfix/ulkbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for ulkbits -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_ULKBITS_H
+#define LLVM_LIBC_SRC_STDFIX_ULKBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned long accum ulkbits(uint_ulk_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_ULKBITS_H
diff --git a/src/stdfix/ulrbits.cpp b/src/stdfix/ulrbits.cpp
new file mode 100644
index 0000000..92f3470
--- /dev/null
+++ b/src/stdfix/ulrbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of ulrbits function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ulrbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned long fract, ulrbits, (uint_ulr_t x)) {
+  return cpp::bit_cast<unsigned long fract, uint_ulr_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/ulrbits.h b/src/stdfix/ulrbits.h
new file mode 100644
index 0000000..7ae49ba
--- /dev/null
+++ b/src/stdfix/ulrbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for ulrbits -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_ULRBITS_H
+#define LLVM_LIBC_SRC_STDFIX_ULRBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned long fract ulrbits(uint_ulr_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_ULRBITS_H
diff --git a/src/stdfix/urbits.cpp b/src/stdfix/urbits.cpp
new file mode 100644
index 0000000..25801e3
--- /dev/null
+++ b/src/stdfix/urbits.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of urbits function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "urbits.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(unsigned fract, urbits, (uint_ur_t x)) {
+  return cpp::bit_cast<unsigned fract, uint_ur_t>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/urbits.h b/src/stdfix/urbits.h
new file mode 100644
index 0000000..8fc0881
--- /dev/null
+++ b/src/stdfix/urbits.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for urbits ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_URBITS_H
+#define LLVM_LIBC_SRC_STDFIX_URBITS_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned fract urbits(uint_ur_t x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_URBITS_H
diff --git a/src/stdio/asprintf.cpp b/src/stdio/asprintf.cpp
new file mode 100644
index 0000000..f8cfb74
--- /dev/null
+++ b/src/stdio/asprintf.cpp
@@ -0,0 +1,29 @@
+//===-- Implementation of asprintf -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/asprintf.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/vasprintf_internal.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, asprintf,
+                   (char **__restrict buffer, const char *__restrict format,
+                    ...)) {
+  va_list vlist;
+  va_start(vlist, format);
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  va_end(vlist);
+  int ret = printf_core::vasprintf_internal(buffer, format, args);
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/asprintf.h b/src/stdio/asprintf.h
new file mode 100644
index 0000000..168721c
--- /dev/null
+++ b/src/stdio/asprintf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header of asprintf ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_ASPRINTF_H
+#define LLVM_LIBC_SRC_STDIO_ASPRINTF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int asprintf(char **__restrict s, const char *__restrict format, ...);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_ASPRINTF_H
diff --git a/src/stdio/baremetal/getchar.cpp b/src/stdio/baremetal/getchar.cpp
new file mode 100644
index 0000000..0a78a1f
--- /dev/null
+++ b/src/stdio/baremetal/getchar.cpp
@@ -0,0 +1,25 @@
+//===-- Baremetal implementation of getchar -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/getchar.h"
+#include "src/__support/OSUtil/io.h"
+#include "src/__support/macros/config.h"
+
+#include "hdr/stdio_macros.h" // for EOF.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, getchar, ()) {
+  char buf[1];
+  auto result = read_from_stdin(buf, sizeof(buf));
+  if (result < 0)
+    return EOF;
+  return buf[0];
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/printf.cpp b/src/stdio/baremetal/printf.cpp
index b240371..04aa284 100644
--- a/src/stdio/baremetal/printf.cpp
+++ b/src/stdio/baremetal/printf.cpp
@@ -9,13 +9,15 @@
 #include "src/stdio/printf.h"
 #include "src/__support/OSUtil/io.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -48,4 +50,4 @@ LLVM_LIBC_FUNCTION(int, printf, (const char *__restrict format, ...)) {
   return retval;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/putchar.cpp b/src/stdio/baremetal/putchar.cpp
index 23e9745..0ba46a5 100644
--- a/src/stdio/baremetal/putchar.cpp
+++ b/src/stdio/baremetal/putchar.cpp
@@ -9,8 +9,9 @@
 #include "src/stdio/putchar.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/OSUtil/io.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   char uc = static_cast<char>(c);
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/puts.cpp b/src/stdio/baremetal/puts.cpp
new file mode 100644
index 0000000..5062efd
--- /dev/null
+++ b/src/stdio/baremetal/puts.cpp
@@ -0,0 +1,26 @@
+//===-- Implementation of puts for baremetal-------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/puts.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/OSUtil/io.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, puts, (const char *__restrict str)) {
+  cpp::string_view str_view(str);
+
+  // TODO: Can we combine these to avoid needing two writes?
+  write_to_stderr(str_view);
+  write_to_stderr("\n");
+
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/remove.cpp b/src/stdio/baremetal/remove.cpp
index f4f2cdc..d383d0c 100644
--- a/src/stdio/baremetal/remove.cpp
+++ b/src/stdio/baremetal/remove.cpp
@@ -9,11 +9,12 @@
 #include "src/stdio/remove.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: This is a temporary workaround for issue #85335.
 
 LLVM_LIBC_FUNCTION(int, remove, (const char *)) { return -1; }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/vprintf.cpp b/src/stdio/baremetal/vprintf.cpp
index cd15412..617b5f4 100644
--- a/src/stdio/baremetal/vprintf.cpp
+++ b/src/stdio/baremetal/vprintf.cpp
@@ -9,13 +9,15 @@
 #include "src/stdio/vprintf.h"
 #include "src/__support/OSUtil/io.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -46,4 +48,4 @@ LLVM_LIBC_FUNCTION(int, vprintf,
   return retval;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/clearerr.h b/src/stdio/clearerr.h
index b8e8d7c..790d923 100644
--- a/src/stdio/clearerr.h
+++ b/src/stdio/clearerr.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_CLEARERR_H
 #define LLVM_LIBC_SRC_STDIO_CLEARERR_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void clearerr(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_CLEARERR_H
diff --git a/src/stdio/clearerr_unlocked.h b/src/stdio/clearerr_unlocked.h
index ff447ce..2a57e76 100644
--- a/src/stdio/clearerr_unlocked.h
+++ b/src/stdio/clearerr_unlocked.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_CLEARERR_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_CLEARERR_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void clearerr_unlocked(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_CLEARERR_UNLOCKED_H
diff --git a/src/stdio/fclose.h b/src/stdio/fclose.h
index 7fe6951..0b1a36d 100644
--- a/src/stdio/fclose.h
+++ b/src/stdio/fclose.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FCLOSE_H
 #define LLVM_LIBC_SRC_STDIO_FCLOSE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fclose(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FCLOSE_H
diff --git a/src/stdio/fdopen.h b/src/stdio/fdopen.h
index 158a133..9917c2b 100644
--- a/src/stdio/fdopen.h
+++ b/src/stdio/fdopen.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FDOPEN_H
 #define LLVM_LIBC_SRC_STDIO_FDOPEN_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-FILE *fdopen(int fd, const char *mode);
+::FILE *fdopen(int fd, const char *mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FDOPEN_H
diff --git a/src/stdio/feof.h b/src/stdio/feof.h
index 66a49bd..6a88d3b 100644
--- a/src/stdio/feof.h
+++ b/src/stdio/feof.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FEOF_H
 #define LLVM_LIBC_SRC_STDIO_FEOF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int feof(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FEOF_H
diff --git a/src/stdio/feof_unlocked.h b/src/stdio/feof_unlocked.h
index 359609c..0c14439 100644
--- a/src/stdio/feof_unlocked.h
+++ b/src/stdio/feof_unlocked.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FEOF_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_FEOF_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int feof_unlocked(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FEOF_UNLOCKED_H
diff --git a/src/stdio/ferror.h b/src/stdio/ferror.h
index 194dff6..d613c37 100644
--- a/src/stdio/ferror.h
+++ b/src/stdio/ferror.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FERROR_H
 #define LLVM_LIBC_SRC_STDIO_FERROR_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ferror(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FERROR_H
diff --git a/src/stdio/ferror_unlocked.h b/src/stdio/ferror_unlocked.h
index 8628102..13cfd23 100644
--- a/src/stdio/ferror_unlocked.h
+++ b/src/stdio/ferror_unlocked.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FERROR_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_FERROR_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ferror_unlocked(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FERROR_UNLOCKED_H
diff --git a/src/stdio/fflush.h b/src/stdio/fflush.h
index 839fd98..e810484 100644
--- a/src/stdio/fflush.h
+++ b/src/stdio/fflush.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FFLUSH_H
 #define LLVM_LIBC_SRC_STDIO_FFLUSH_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fflush(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FFLUSH_H
diff --git a/src/stdio/fgetc.h b/src/stdio/fgetc.h
index 26a3248..f17a88a 100644
--- a/src/stdio/fgetc.h
+++ b/src/stdio/fgetc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FGETC_H
 #define LLVM_LIBC_SRC_STDIO_FGETC_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fgetc(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FGETC_H
diff --git a/src/stdio/fgetc_unlocked.h b/src/stdio/fgetc_unlocked.h
index f765e8d..5643ee2 100644
--- a/src/stdio/fgetc_unlocked.h
+++ b/src/stdio/fgetc_unlocked.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FGETC_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_FGETC_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fgetc_unlocked(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FGETC_UNLOCKED_H
diff --git a/src/stdio/fgets.h b/src/stdio/fgets.h
index 4264557..499c27c 100644
--- a/src/stdio/fgets.h
+++ b/src/stdio/fgets.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FGETS_H
 #define LLVM_LIBC_SRC_STDIO_FGETS_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *fgets(char *__restrict str, int count, ::FILE *__restrict raw_stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FGETS_H
diff --git a/src/stdio/fileno.h b/src/stdio/fileno.h
index d41f112..7e49e71 100644
--- a/src/stdio/fileno.h
+++ b/src/stdio/fileno.h
@@ -1,5 +1,4 @@
-//===-- Implementation header of fileno --------------------------*- C++
-//-*-===//
+//===-- Implementation header of fileno -------------------------*- C++ -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -10,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FILENO_H
 #define LLVM_LIBC_SRC_STDIO_FILENO_H
 
-#include "include/llvm-libc-types/FILE.h"
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fileno(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FILENO_H
diff --git a/src/stdio/flockfile.cpp b/src/stdio/flockfile.cpp
index 62606c9..4fc0af5 100644
--- a/src/stdio/flockfile.cpp
+++ b/src/stdio/flockfile.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/flockfile.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, flockfile, (::FILE * stream)) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->lock();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/flockfile.h b/src/stdio/flockfile.h
index 1509c14..b7e2b5f 100644
--- a/src/stdio/flockfile.h
+++ b/src/stdio/flockfile.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FLOCKFILE_H
 #define LLVM_LIBC_SRC_STDIO_FLOCKFILE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void flockfile(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FLOCKFILE_H
diff --git a/src/stdio/fopen.h b/src/stdio/fopen.h
index 68f93f5..a76c3a9 100644
--- a/src/stdio/fopen.h
+++ b/src/stdio/fopen.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FOPEN_H
 #define LLVM_LIBC_SRC_STDIO_FOPEN_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ::FILE *fopen(const char *__restrict name, const char *__restrict mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FOPEN_H
diff --git a/src/stdio/fopencookie.cpp b/src/stdio/fopencookie.cpp
index 2cb7ad2..9f5694e 100644
--- a/src/stdio/fopencookie.cpp
+++ b/src/stdio/fopencookie.cpp
@@ -7,14 +7,17 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/fopencookie.h"
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
+#include "hdr/types/cookie_io_functions_t.h"
+#include "hdr/types/off_t.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/File/file.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
-#include <stdlib.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -24,7 +27,7 @@ class CookieFile : public LIBC_NAMESPACE::File {
 
   static FileIOResult cookie_write(File *f, const void *data, size_t size);
   static FileIOResult cookie_read(File *f, void *data, size_t size);
-  static ErrorOr<long> cookie_seek(File *f, long offset, int whence);
+  static ErrorOr<off_t> cookie_seek(File *f, off_t offset, int whence);
   static int cookie_close(File *f);
 
 public:
@@ -40,19 +43,19 @@ FileIOResult CookieFile::cookie_write(File *f, const void *data, size_t size) {
   auto cookie_file = reinterpret_cast<CookieFile *>(f);
   if (cookie_file->ops.write == nullptr)
     return 0;
-  return cookie_file->ops.write(cookie_file->cookie,
-                                reinterpret_cast<const char *>(data), size);
+  return static_cast<size_t>(cookie_file->ops.write(
+      cookie_file->cookie, reinterpret_cast<const char *>(data), size));
 }
 
 FileIOResult CookieFile::cookie_read(File *f, void *data, size_t size) {
   auto cookie_file = reinterpret_cast<CookieFile *>(f);
   if (cookie_file->ops.read == nullptr)
     return 0;
-  return cookie_file->ops.read(cookie_file->cookie,
-                               reinterpret_cast<char *>(data), size);
+  return static_cast<size_t>(cookie_file->ops.read(
+      cookie_file->cookie, reinterpret_cast<char *>(data), size));
 }
 
-ErrorOr<long> CookieFile::cookie_seek(File *f, long offset, int whence) {
+ErrorOr<off_t> CookieFile::cookie_seek(File *f, off_t offset, int whence) {
   auto cookie_file = reinterpret_cast<CookieFile *>(f);
   if (cookie_file->ops.seek == nullptr) {
     return Error(EINVAL);
@@ -61,8 +64,7 @@ ErrorOr<long> CookieFile::cookie_seek(File *f, long offset, int whence) {
   int result = cookie_file->ops.seek(cookie_file->cookie, &offset64, whence);
   if (result == 0)
     return offset64;
-  else
-    return -1;
+  return -1;
 }
 
 int CookieFile::cookie_close(File *f) {
@@ -96,4 +98,4 @@ LLVM_LIBC_FUNCTION(::FILE *, fopencookie,
   return reinterpret_cast<::FILE *>(file);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/fopencookie.h b/src/stdio/fopencookie.h
index 3dff894..15b377f 100644
--- a/src/stdio/fopencookie.h
+++ b/src/stdio/fopencookie.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FOPENCOOKIE_H
 #define LLVM_LIBC_SRC_STDIO_FOPENCOOKIE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "hdr/types/cookie_io_functions_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ::FILE *fopencookie(void *cookie, const char *__restrict mode,
                     cookie_io_functions_t desc);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FOPENCOOKIE_H
diff --git a/src/stdio/fprintf.h b/src/stdio/fprintf.h
index 41cd8a8..4ab90e3 100644
--- a/src/stdio/fprintf.h
+++ b/src/stdio/fprintf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_FPRINTF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fprintf(::FILE *__restrict stream, const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FPRINTF_H
diff --git a/src/stdio/fputc.h b/src/stdio/fputc.h
index 578e569..5dde302 100644
--- a/src/stdio/fputc.h
+++ b/src/stdio/fputc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FPUTC_H
 #define LLVM_LIBC_SRC_STDIO_FPUTC_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fputc(int c, ::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FPUTC_H
diff --git a/src/stdio/fputs.h b/src/stdio/fputs.h
index 0238e46..4b5534f 100644
--- a/src/stdio/fputs.h
+++ b/src/stdio/fputs.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FPUTS_H
 #define LLVM_LIBC_SRC_STDIO_FPUTS_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fputs(const char *__restrict str, ::FILE *__restrict stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FPUTS_H
diff --git a/src/stdio/fread.h b/src/stdio/fread.h
index ae22950..ab11af3 100644
--- a/src/stdio/fread.h
+++ b/src/stdio/fread.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FREAD_H
 #define LLVM_LIBC_SRC_STDIO_FREAD_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t fread(void *__restrict buffer, size_t size, size_t nmemb,
              ::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FREAD_H
diff --git a/src/stdio/fread_unlocked.h b/src/stdio/fread_unlocked.h
index 7cd0ed3..ff5561e 100644
--- a/src/stdio/fread_unlocked.h
+++ b/src/stdio/fread_unlocked.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FREAD_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_FREAD_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t fread_unlocked(void *__restrict buffer, size_t size, size_t nmemb,
                       ::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FREAD_UNLOCKED_H
diff --git a/src/stdio/fscanf.cpp b/src/stdio/fscanf.cpp
index 188e28e..94b8439 100644
--- a/src/stdio/fscanf.cpp
+++ b/src/stdio/fscanf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/vfscanf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fscanf,
                    (::FILE *__restrict stream, const char *__restrict format,
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, fscanf,
   return (ret_val == -1) ? EOF : ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/fscanf.h b/src/stdio/fscanf.h
index 0e2247d..3a8b86b 100644
--- a/src/stdio/fscanf.h
+++ b/src/stdio/fscanf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FSCANF_H
 #define LLVM_LIBC_SRC_STDIO_FSCANF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fscanf(::FILE *__restrict stream, const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FSCANF_H
diff --git a/src/stdio/fseek.h b/src/stdio/fseek.h
index 6a7f715..a979b41 100644
--- a/src/stdio/fseek.h
+++ b/src/stdio/fseek.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FSEEK_H
 #define LLVM_LIBC_SRC_STDIO_FSEEK_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fseek(::FILE *stream, long offset, int whence);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FSEEK_H
diff --git a/src/stdio/fseeko.h b/src/stdio/fseeko.h
index 77fb412..6b83d4a 100644
--- a/src/stdio/fseeko.h
+++ b/src/stdio/fseeko.h
@@ -9,12 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FSEEKO_H
 #define LLVM_LIBC_SRC_STDIO_FSEEKO_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "hdr/types/off_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fseeko(::FILE *stream, off_t offset, int whence);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FSEEKO_H
diff --git a/src/stdio/ftell.h b/src/stdio/ftell.h
index e72bb8b..813d9a1 100644
--- a/src/stdio/ftell.h
+++ b/src/stdio/ftell.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FTELL_H
 #define LLVM_LIBC_SRC_STDIO_FTELL_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long ftell(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FTELL_H
diff --git a/src/stdio/ftello.h b/src/stdio/ftello.h
index 5ab17f9..92732d5 100644
--- a/src/stdio/ftello.h
+++ b/src/stdio/ftello.h
@@ -9,12 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FTELLO_H
 #define LLVM_LIBC_SRC_STDIO_FTELLO_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "hdr/types/off_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 off_t ftello(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FTELLO_H
diff --git a/src/stdio/funlockfile.cpp b/src/stdio/funlockfile.cpp
index 88e2eae..7a0712a 100644
--- a/src/stdio/funlockfile.cpp
+++ b/src/stdio/funlockfile.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/funlockfile.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, funlockfile, (::FILE * stream)) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->unlock();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/funlockfile.h b/src/stdio/funlockfile.h
index c50f9dd..0949ca0 100644
--- a/src/stdio/funlockfile.h
+++ b/src/stdio/funlockfile.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FUNLOCKFILE_H
 #define LLVM_LIBC_SRC_STDIO_FUNLOCKFILE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void funlockfile(::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FUNLOCKFILE_H
diff --git a/src/stdio/fwrite.h b/src/stdio/fwrite.h
index a71f20c..8ba5e4d 100644
--- a/src/stdio/fwrite.h
+++ b/src/stdio/fwrite.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FWRITE_H
 #define LLVM_LIBC_SRC_STDIO_FWRITE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t fwrite(const void *__restrict ptr, size_t size, size_t nmemb,
               ::FILE *__restrict stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FWRITE_H
diff --git a/src/stdio/fwrite_unlocked.h b/src/stdio/fwrite_unlocked.h
index 7012e0d..5ee6d38 100644
--- a/src/stdio/fwrite_unlocked.h
+++ b/src/stdio/fwrite_unlocked.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_FWRITE_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_FWRITE_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t fwrite_unlocked(const void *__restrict ptr, size_t size, size_t nmemb,
                        ::FILE *__restrict stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_FWRITE_UNLOCKED_H
diff --git a/src/stdio/generic/clearerr.cpp b/src/stdio/generic/clearerr.cpp
index 1f1ce38..583181a 100644
--- a/src/stdio/generic/clearerr.cpp
+++ b/src/stdio/generic/clearerr.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/clearerr.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, clearerr, (::FILE * stream)) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->clearerr();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/clearerr_unlocked.cpp b/src/stdio/generic/clearerr_unlocked.cpp
index 2840e37..313604c 100644
--- a/src/stdio/generic/clearerr_unlocked.cpp
+++ b/src/stdio/generic/clearerr_unlocked.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/clearerr_unlocked.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, clearerr_unlocked, (::FILE * stream)) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->clearerr_unlocked();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fclose.cpp b/src/stdio/generic/fclose.cpp
index cc163ab..388407a 100644
--- a/src/stdio/generic/fclose.cpp
+++ b/src/stdio/generic/fclose.cpp
@@ -9,10 +9,11 @@
 #include "src/stdio/fclose.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fclose, (::FILE * stream)) {
   int result = reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->close();
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fclose, (::FILE * stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/feof.cpp b/src/stdio/generic/feof.cpp
index 311561c..8c7d195 100644
--- a/src/stdio/generic/feof.cpp
+++ b/src/stdio/generic/feof.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/feof.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feof, (::FILE * stream)) {
   return reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->iseof();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/feof_unlocked.cpp b/src/stdio/generic/feof_unlocked.cpp
index e8c718c..0ce827b 100644
--- a/src/stdio/generic/feof_unlocked.cpp
+++ b/src/stdio/generic/feof_unlocked.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/feof_unlocked.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feof_unlocked, (::FILE * stream)) {
   return reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->iseof_unlocked();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/ferror.cpp b/src/stdio/generic/ferror.cpp
index 65cf99f..33e778e 100644
--- a/src/stdio/generic/ferror.cpp
+++ b/src/stdio/generic/ferror.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/ferror.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ferror, (::FILE * stream)) {
   return reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->error();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/ferror_unlocked.cpp b/src/stdio/generic/ferror_unlocked.cpp
index 089ea4a..f567f05 100644
--- a/src/stdio/generic/ferror_unlocked.cpp
+++ b/src/stdio/generic/ferror_unlocked.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/ferror_unlocked.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ferror_unlocked, (::FILE * stream)) {
   return reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->error_unlocked();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fflush.cpp b/src/stdio/generic/fflush.cpp
index dc5275b..5bdf71a 100644
--- a/src/stdio/generic/fflush.cpp
+++ b/src/stdio/generic/fflush.cpp
@@ -9,10 +9,11 @@
 #include "src/stdio/fflush.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fflush, (::FILE * stream)) {
   int result = reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->flush();
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fflush, (::FILE * stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fgetc.cpp b/src/stdio/generic/fgetc.cpp
index 7718113..aa6660c 100644
--- a/src/stdio/generic/fgetc.cpp
+++ b/src/stdio/generic/fgetc.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fgetc.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fgetc, (::FILE * stream)) {
   unsigned char c;
@@ -26,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, fgetc, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fgetc_unlocked.cpp b/src/stdio/generic/fgetc_unlocked.cpp
index e7aaf9d..34a27f1 100644
--- a/src/stdio/generic/fgetc_unlocked.cpp
+++ b/src/stdio/generic/fgetc_unlocked.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fgetc_unlocked.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fgetc_unlocked, (::FILE * stream)) {
   unsigned char c;
@@ -26,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, fgetc_unlocked, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fgets.cpp b/src/stdio/generic/fgets.cpp
index 8c9dac8..de64740 100644
--- a/src/stdio/generic/fgets.cpp
+++ b/src/stdio/generic/fgets.cpp
@@ -9,11 +9,12 @@
 #include "src/stdio/fgets.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <stddef.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, fgets,
                    (char *__restrict str, int count,
@@ -52,4 +53,4 @@ LLVM_LIBC_FUNCTION(char *, fgets,
   return str;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fileno.cpp b/src/stdio/generic/fileno.cpp
index 663ba92..0bec180 100644
--- a/src/stdio/generic/fileno.cpp
+++ b/src/stdio/generic/fileno.cpp
@@ -9,13 +9,14 @@
 
 #include "src/stdio/fileno.h"
 
-#include "include/llvm-libc-types/FILE.h"
+#include "hdr/types/FILE.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fileno, (::FILE * stream)) {
   return get_fileno(reinterpret_cast<LIBC_NAMESPACE::File *>(stream));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fopen.cpp b/src/stdio/generic/fopen.cpp
index 794ef03..d6e418b 100644
--- a/src/stdio/generic/fopen.cpp
+++ b/src/stdio/generic/fopen.cpp
@@ -9,10 +9,11 @@
 #include "src/stdio/fopen.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(::FILE *, fopen,
                    (const char *__restrict name, const char *__restrict mode)) {
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(::FILE *, fopen,
   return reinterpret_cast<::FILE *>(result.value());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/fprintf.cpp b/src/stdio/generic/fprintf.cpp
similarity index 88%
rename from src/stdio/fprintf.cpp
rename to src/stdio/generic/fprintf.cpp
index 87b0e74..087aead 100644
--- a/src/stdio/fprintf.cpp
+++ b/src/stdio/generic/fprintf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/vfprintf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fprintf,
                    (::FILE *__restrict stream, const char *__restrict format,
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, fprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fputc.cpp b/src/stdio/generic/fputc.cpp
index ecbe45e..54a38ae 100644
--- a/src/stdio/generic/fputc.cpp
+++ b/src/stdio/generic/fputc.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fputc.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fputc, (int c, ::FILE *stream)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -29,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, fputc, (int c, ::FILE *stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fputs.cpp b/src/stdio/generic/fputs.cpp
index ef77ad4..8aef768 100644
--- a/src/stdio/generic/fputs.cpp
+++ b/src/stdio/generic/fputs.cpp
@@ -10,10 +10,12 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fputs,
                    (const char *__restrict str, ::FILE *__restrict stream)) {
@@ -32,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, fputs,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fread.cpp b/src/stdio/generic/fread.cpp
index e8bd251..3a04094 100644
--- a/src/stdio/generic/fread.cpp
+++ b/src/stdio/generic/fread.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fread.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fread,
                    (void *__restrict buffer, size_t size, size_t nmemb,
@@ -26,4 +28,4 @@ LLVM_LIBC_FUNCTION(size_t, fread,
   return result.value / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fread_unlocked.cpp b/src/stdio/generic/fread_unlocked.cpp
index 9810c9d..151f43c 100644
--- a/src/stdio/generic/fread_unlocked.cpp
+++ b/src/stdio/generic/fread_unlocked.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fread_unlocked.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fread_unlocked,
                    (void *__restrict buffer, size_t size, size_t nmemb,
@@ -26,4 +28,4 @@ LLVM_LIBC_FUNCTION(size_t, fread_unlocked,
   return result.value / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fseek.cpp b/src/stdio/generic/fseek.cpp
index c5edc8d..21820da 100644
--- a/src/stdio/generic/fseek.cpp
+++ b/src/stdio/generic/fseek.cpp
@@ -9,9 +9,10 @@
 #include "src/stdio/fseek.h"
 #include "src/__support/File/file.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fseek, (::FILE * stream, long offset, int whence)) {
   auto result =
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fseek, (::FILE * stream, long offset, int whence)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fseeko.cpp b/src/stdio/generic/fseeko.cpp
index 215da75..7456b4a 100644
--- a/src/stdio/generic/fseeko.cpp
+++ b/src/stdio/generic/fseeko.cpp
@@ -9,9 +9,10 @@
 #include "src/stdio/fseeko.h"
 #include "src/__support/File/file.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fseeko, (::FILE * stream, off_t offset, int whence)) {
   auto result =
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fseeko, (::FILE * stream, off_t offset, int whence)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/ftell.cpp b/src/stdio/generic/ftell.cpp
index d55bad2..ec15ca4 100644
--- a/src/stdio/generic/ftell.cpp
+++ b/src/stdio/generic/ftell.cpp
@@ -9,9 +9,10 @@
 #include "src/stdio/ftell.h"
 #include "src/__support/File/file.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, ftell, (::FILE * stream)) {
   auto result = reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->tell();
@@ -19,7 +20,11 @@ LLVM_LIBC_FUNCTION(long, ftell, (::FILE * stream)) {
     libc_errno = result.error();
     return -1;
   }
-  return result.value();
+  // tell() returns an off_t (64-bit signed integer), but this function returns
+  // a long (32-bit signed integer in 32-bit systems). We add a cast here to
+  // silence a "implicit conversion loses integer precision" warning when
+  // compiling for 32-bit systems.
+  return static_cast<long>(result.value());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/ftello.cpp b/src/stdio/generic/ftello.cpp
index c72e56e..e3d0726 100644
--- a/src/stdio/generic/ftello.cpp
+++ b/src/stdio/generic/ftello.cpp
@@ -9,9 +9,10 @@
 #include "src/stdio/ftello.h"
 #include "src/__support/File/file.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(off_t, ftello, (::FILE * stream)) {
   auto result = reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->tell();
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(off_t, ftello, (::FILE * stream)) {
   return result.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fwrite.cpp b/src/stdio/generic/fwrite.cpp
index bd11f62..66eb9a3 100644
--- a/src/stdio/generic/fwrite.cpp
+++ b/src/stdio/generic/fwrite.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fwrite.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fwrite,
                    (const void *__restrict buffer, size_t size, size_t nmemb,
@@ -27,4 +29,4 @@ LLVM_LIBC_FUNCTION(size_t, fwrite,
   return result.value / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fwrite_unlocked.cpp b/src/stdio/generic/fwrite_unlocked.cpp
index 5ab7c76..a0d9014 100644
--- a/src/stdio/generic/fwrite_unlocked.cpp
+++ b/src/stdio/generic/fwrite_unlocked.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/fwrite_unlocked.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fwrite_unlocked,
                    (const void *__restrict buffer, size_t size, size_t nmemb,
@@ -29,4 +31,4 @@ LLVM_LIBC_FUNCTION(size_t, fwrite_unlocked,
   return result.value / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/getc.cpp b/src/stdio/generic/getc.cpp
index 5cea28d..e988468 100644
--- a/src/stdio/generic/getc.cpp
+++ b/src/stdio/generic/getc.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/getc.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getc, (::FILE * stream)) {
   unsigned char c;
@@ -26,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, getc, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/getc_unlocked.cpp b/src/stdio/generic/getc_unlocked.cpp
index 883405e..92d5092 100644
--- a/src/stdio/generic/getc_unlocked.cpp
+++ b/src/stdio/generic/getc_unlocked.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/getc_unlocked.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getc_unlocked, (::FILE * stream)) {
   unsigned char c;
@@ -27,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, getc_unlocked, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/getchar.cpp b/src/stdio/generic/getchar.cpp
index 181999f..371fc70 100644
--- a/src/stdio/generic/getchar.cpp
+++ b/src/stdio/generic/getchar.cpp
@@ -9,10 +9,11 @@
 #include "src/stdio/getchar.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getchar, ()) {
   unsigned char c;
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, getchar, ()) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/getchar_unlocked.cpp b/src/stdio/generic/getchar_unlocked.cpp
index be98d03..b898f5c 100644
--- a/src/stdio/generic/getchar_unlocked.cpp
+++ b/src/stdio/generic/getchar_unlocked.cpp
@@ -9,10 +9,11 @@
 #include "src/stdio/getchar_unlocked.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getchar_unlocked, ()) {
   unsigned char c;
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, getchar_unlocked, ()) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/printf.cpp b/src/stdio/generic/printf.cpp
index 5701ca9..bb7c7c8 100644
--- a/src/stdio/generic/printf.cpp
+++ b/src/stdio/generic/printf.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/vfprintf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 #define PRINTF_STDOUT LIBC_NAMESPACE::stdout
@@ -21,7 +22,7 @@
 #define PRINTF_STDOUT ::stdout
 #endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, printf, (const char *__restrict format, ...)) {
   va_list vlist;
@@ -35,4 +36,4 @@ LLVM_LIBC_FUNCTION(int, printf, (const char *__restrict format, ...)) {
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/putc.cpp b/src/stdio/generic/putc.cpp
index 58e3b4d..b5f008f 100644
--- a/src/stdio/generic/putc.cpp
+++ b/src/stdio/generic/putc.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/putc.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, putc, (int c, ::FILE *stream)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -29,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, putc, (int c, ::FILE *stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/putchar.cpp b/src/stdio/generic/putchar.cpp
index 4a4aeb5..e86df23 100644
--- a/src/stdio/generic/putchar.cpp
+++ b/src/stdio/generic/putchar.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/putchar.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -29,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/puts.cpp b/src/stdio/generic/puts.cpp
index 0f19ec5..7dbe2c7 100644
--- a/src/stdio/generic/puts.cpp
+++ b/src/stdio/generic/puts.cpp
@@ -10,10 +10,12 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -53,4 +55,4 @@ LLVM_LIBC_FUNCTION(int, puts, (const char *__restrict str)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/stderr.cpp b/src/stdio/generic/stderr.cpp
index 31b618f..65ba305 100644
--- a/src/stdio/generic/stderr.cpp
+++ b/src/stdio/generic/stderr.cpp
@@ -8,6 +8,6 @@
 
 #include "src/__support/File/file.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
 extern "C" FILE *stderr;
diff --git a/src/stdio/generic/stdin.cpp b/src/stdio/generic/stdin.cpp
index f99ea89..ce1ae2d 100644
--- a/src/stdio/generic/stdin.cpp
+++ b/src/stdio/generic/stdin.cpp
@@ -8,6 +8,6 @@
 
 #include "src/__support/File/file.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
 extern "C" FILE *stdin;
diff --git a/src/stdio/generic/stdout.cpp b/src/stdio/generic/stdout.cpp
index 2d5aaf5..8ad8f64 100644
--- a/src/stdio/generic/stdout.cpp
+++ b/src/stdio/generic/stdout.cpp
@@ -8,6 +8,6 @@
 
 #include "src/__support/File/file.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
 extern "C" FILE *stdout;
diff --git a/src/stdio/generic/ungetc.cpp b/src/stdio/generic/ungetc.cpp
index ccfbfb0..44ffdfc 100644
--- a/src/stdio/generic/ungetc.cpp
+++ b/src/stdio/generic/ungetc.cpp
@@ -8,13 +8,14 @@
 
 #include "src/stdio/ungetc.h"
 #include "src/__support/File/file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ungetc, (int c, ::FILE *stream)) {
   return reinterpret_cast<LIBC_NAMESPACE::File *>(stream)->ungetc(c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vfprintf.cpp b/src/stdio/generic/vfprintf.cpp
similarity index 88%
rename from src/stdio/vfprintf.cpp
rename to src/stdio/generic/vfprintf.cpp
index 2504ce8..01f4265 100644
--- a/src/stdio/vfprintf.cpp
+++ b/src/stdio/generic/vfprintf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/vfprintf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, vfprintf,
                    (::FILE *__restrict stream, const char *__restrict format,
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, vfprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/vprintf.cpp b/src/stdio/generic/vprintf.cpp
index eff968d..08d7151 100644
--- a/src/stdio/generic/vprintf.cpp
+++ b/src/stdio/generic/vprintf.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/vfprintf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 #define PRINTF_STDOUT LIBC_NAMESPACE::stdout
@@ -21,7 +22,7 @@
 #define PRINTF_STDOUT ::stdout
 #endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, vprintf,
                    (const char *__restrict format, va_list vlist)) {
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, vprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/getc.h b/src/stdio/getc.h
index c085d35..823f319 100644
--- a/src/stdio/getc.h
+++ b/src/stdio/getc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_GETC_H
 #define LLVM_LIBC_SRC_STDIO_GETC_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int getc(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_GETC_H
diff --git a/src/stdio/getc_unlocked.h b/src/stdio/getc_unlocked.h
index f4e1165..2e0abac 100644
--- a/src/stdio/getc_unlocked.h
+++ b/src/stdio/getc_unlocked.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_GETC_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_GETC_UNLOCKED_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int getc_unlocked(::FILE *f);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_GETC_UNLOCKED_H
diff --git a/src/stdio/getchar.h b/src/stdio/getchar.h
index 4168808..c9497fe 100644
--- a/src/stdio/getchar.h
+++ b/src/stdio/getchar.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_GETCHAR_H
 #define LLVM_LIBC_SRC_STDIO_GETCHAR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int getchar();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_GETCHAR_H
diff --git a/src/stdio/getchar_unlocked.h b/src/stdio/getchar_unlocked.h
index 24fdb75..96fae85 100644
--- a/src/stdio/getchar_unlocked.h
+++ b/src/stdio/getchar_unlocked.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_GETCHAR_UNLOCKED_H
 #define LLVM_LIBC_SRC_STDIO_GETCHAR_UNLOCKED_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int getchar_unlocked();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_GETCHAR_UNLOCKED_H
diff --git a/src/stdio/gpu/clearerr.cpp b/src/stdio/gpu/clearerr.cpp
index 2267fdf..4c631b9 100644
--- a/src/stdio/gpu/clearerr.cpp
+++ b/src/stdio/gpu/clearerr.cpp
@@ -8,17 +8,20 @@
 
 #include "src/stdio/clearerr.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, clearerr, (::FILE * stream)) {
   rpc::Client::Port port = rpc::client.open<RPC_CLEARERR>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) { buffer->data[0] = file::from_stream(stream); },
-      [&](rpc::Buffer *) {});
+      [=](rpc::Buffer *buffer, uint32_t) {
+        buffer->data[0] = file::from_stream(stream);
+      },
+      [&](rpc::Buffer *, uint32_t) {});
   port.close();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fclose.cpp b/src/stdio/gpu/fclose.cpp
index bdedbe5..683e054 100644
--- a/src/stdio/gpu/fclose.cpp
+++ b/src/stdio/gpu/fclose.cpp
@@ -7,18 +7,21 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/fclose.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/gpu/file.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fclose, (::FILE * stream)) {
   uint64_t ret = 0;
   uintptr_t file = reinterpret_cast<uintptr_t>(stream);
   rpc::Client::Port port = rpc::client.open<RPC_CLOSE_FILE>();
-  port.send_and_recv([=](rpc::Buffer *buffer) { buffer->data[0] = file; },
-                     [&](rpc::Buffer *buffer) { ret = buffer->data[0]; });
+  port.send_and_recv(
+      [=](rpc::Buffer *buffer, uint32_t) { buffer->data[0] = file; },
+      [&](rpc::Buffer *buffer, uint32_t) { ret = buffer->data[0]; });
   port.close();
 
   if (ret != 0)
@@ -26,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, fclose, (::FILE * stream)) {
   return static_cast<int>(ret);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/feof.cpp b/src/stdio/gpu/feof.cpp
index ddcef38..02adb4c 100644
--- a/src/stdio/gpu/feof.cpp
+++ b/src/stdio/gpu/feof.cpp
@@ -8,19 +8,24 @@
 
 #include "src/stdio/feof.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feof, (::FILE * stream)) {
   int ret;
   rpc::Client::Port port = rpc::client.open<RPC_FEOF>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) { buffer->data[0] = file::from_stream(stream); },
-      [&](rpc::Buffer *buffer) { ret = static_cast<int>(buffer->data[0]); });
+      [=](rpc::Buffer *buffer, uint32_t) {
+        buffer->data[0] = file::from_stream(stream);
+      },
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<int>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/ferror.cpp b/src/stdio/gpu/ferror.cpp
index 9ed598f..ca77713 100644
--- a/src/stdio/gpu/ferror.cpp
+++ b/src/stdio/gpu/ferror.cpp
@@ -8,19 +8,24 @@
 
 #include "src/stdio/ferror.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ferror, (::FILE * stream)) {
   int ret;
   rpc::Client::Port port = rpc::client.open<RPC_FERROR>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) { buffer->data[0] = file::from_stream(stream); },
-      [&](rpc::Buffer *buffer) { ret = static_cast<int>(buffer->data[0]); });
+      [=](rpc::Buffer *buffer, uint32_t) {
+        buffer->data[0] = file::from_stream(stream);
+      },
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<int>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fflush.cpp b/src/stdio/gpu/fflush.cpp
index 6819217..577325b 100644
--- a/src/stdio/gpu/fflush.cpp
+++ b/src/stdio/gpu/fflush.cpp
@@ -8,19 +8,24 @@
 
 #include "src/stdio/fflush.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fflush, (::FILE * stream)) {
   int ret;
   rpc::Client::Port port = rpc::client.open<RPC_FFLUSH>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) { buffer->data[0] = file::from_stream(stream); },
-      [&](rpc::Buffer *buffer) { ret = static_cast<int>(buffer->data[0]); });
+      [=](rpc::Buffer *buffer, uint32_t) {
+        buffer->data[0] = file::from_stream(stream);
+      },
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<int>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fgetc.cpp b/src/stdio/gpu/fgetc.cpp
index 56f42a0..cb42f31 100644
--- a/src/stdio/gpu/fgetc.cpp
+++ b/src/stdio/gpu/fgetc.cpp
@@ -8,10 +8,12 @@
 
 #include "src/stdio/fgetc.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fgetc, (::FILE * stream)) {
   unsigned char c;
@@ -22,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fgetc, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fgets.cpp b/src/stdio/gpu/fgets.cpp
index 5ea4bdc..fbc1b0c 100644
--- a/src/stdio/gpu/fgets.cpp
+++ b/src/stdio/gpu/fgets.cpp
@@ -8,13 +8,15 @@
 
 #include "src/stdio/fgets.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/feof.h"
 #include "src/stdio/ferror.h"
 
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 #include <stddef.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, fgets,
                    (char *__restrict str, int count,
@@ -25,7 +27,7 @@ LLVM_LIBC_FUNCTION(char *, fgets,
   uint64_t recv_size;
   void *buf = nullptr;
   rpc::Client::Port port = rpc::client.open<RPC_READ_FGETS>();
-  port.send([=](rpc::Buffer *buffer) {
+  port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = count;
     buffer->data[1] = file::from_stream(stream);
   });
@@ -39,4 +41,4 @@ LLVM_LIBC_FUNCTION(char *, fgets,
   return str;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/file.h b/src/stdio/gpu/file.h
index 2cab2e6..6ca792b 100644
--- a/src/stdio/gpu/file.h
+++ b/src/stdio/gpu/file.h
@@ -7,11 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/RPC/rpc_client.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // For stdin/out/err
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace file {
 
 enum Stream {
@@ -47,19 +49,19 @@ LIBC_INLINE ::FILE *to_stream(uintptr_t f) {
   return stream;
 }
 
-template <uint16_t opcode>
+template <uint32_t opcode>
 LIBC_INLINE uint64_t write_impl(::FILE *file, const void *data, size_t size) {
   uint64_t ret = 0;
   rpc::Client::Port port = rpc::client.open<opcode>();
 
   if constexpr (opcode == RPC_WRITE_TO_STREAM) {
-    port.send([&](rpc::Buffer *buffer) {
+    port.send([&](rpc::Buffer *buffer, uint32_t) {
       buffer->data[0] = reinterpret_cast<uintptr_t>(file);
     });
   }
 
   port.send_n(data, size);
-  port.recv([&](rpc::Buffer *buffer) {
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
     ret = reinterpret_cast<uint64_t *>(buffer->data)[0];
   });
   port.close();
@@ -79,12 +81,12 @@ LIBC_INLINE uint64_t read_from_stream(::FILE *file, void *buf, size_t size) {
   uint64_t ret = 0;
   uint64_t recv_size;
   rpc::Client::Port port = rpc::client.open<RPC_READ_FROM_STREAM>();
-  port.send([=](rpc::Buffer *buffer) {
+  port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = size;
     buffer->data[1] = from_stream(file);
   });
   port.recv_n(&buf, &recv_size, [&](uint64_t) { return buf; });
-  port.recv([&](rpc::Buffer *buffer) { ret = buffer->data[0]; });
+  port.recv([&](rpc::Buffer *buffer, uint32_t) { ret = buffer->data[0]; });
   port.close();
   return ret;
 }
@@ -94,4 +96,4 @@ LIBC_INLINE uint64_t read(::FILE *f, void *data, size_t size) {
 }
 
 } // namespace file
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fopen.cpp b/src/stdio/gpu/fopen.cpp
index 41d2c89..e165d2a 100644
--- a/src/stdio/gpu/fopen.cpp
+++ b/src/stdio/gpu/fopen.cpp
@@ -8,11 +8,12 @@
 
 #include "src/stdio/fopen.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/gpu/file.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(::FILE *, fopen,
                    (const char *__restrict path, const char *__restrict mode)) {
@@ -20,13 +21,13 @@ LLVM_LIBC_FUNCTION(::FILE *, fopen,
   rpc::Client::Port port = rpc::client.open<RPC_OPEN_FILE>();
   port.send_n(path, internal::string_length(path) + 1);
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) {
+      [=](rpc::Buffer *buffer, uint32_t) {
         inline_memcpy(buffer->data, mode, internal::string_length(mode) + 1);
       },
-      [&](rpc::Buffer *buffer) { file = buffer->data[0]; });
+      [&](rpc::Buffer *buffer, uint32_t) { file = buffer->data[0]; });
   port.close();
 
   return reinterpret_cast<FILE *>(file);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fprintf.cpp b/src/stdio/gpu/fprintf.cpp
new file mode 100644
index 0000000..46196d7
--- /dev/null
+++ b/src/stdio/gpu/fprintf.cpp
@@ -0,0 +1,32 @@
+//===-- GPU Implementation of fprintf -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/fprintf.h"
+
+#include "hdr/types/FILE.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/arg_list.h"
+#include "src/errno/libc_errno.h"
+#include "src/stdio/gpu/vfprintf_utils.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, fprintf,
+                   (::FILE *__restrict stream, const char *__restrict format,
+                    ...)) {
+  va_list vlist;
+  va_start(vlist, format);
+  cpp::string_view str_view(format);
+  int ret_val = vfprintf_internal(stream, format, str_view.size() + 1, vlist);
+  va_end(vlist);
+  return ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fputc.cpp b/src/stdio/gpu/fputc.cpp
index e6ef12f..ad2db03 100644
--- a/src/stdio/gpu/fputc.cpp
+++ b/src/stdio/gpu/fputc.cpp
@@ -6,12 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "file.h"
 #include "src/stdio/fputc.h"
+#include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fputc, (int c, ::FILE *stream)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -23,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, fputc, (int c, ::FILE *stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fputs.cpp b/src/stdio/gpu/fputs.cpp
index 1b6e073..7a08244 100644
--- a/src/stdio/gpu/fputs.cpp
+++ b/src/stdio/gpu/fputs.cpp
@@ -8,12 +8,14 @@
 
 #include "src/stdio/fputs.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/stdio/gpu/file.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fputs,
                    (const char *__restrict str, ::FILE *__restrict stream)) {
@@ -24,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, fputs,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fread.cpp b/src/stdio/gpu/fread.cpp
index fe367ae..57fa5b6 100644
--- a/src/stdio/gpu/fread.cpp
+++ b/src/stdio/gpu/fread.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/fread.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/gpu/file.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fread,
                    (void *__restrict buffer, size_t size, size_t nmemb,
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(size_t, fread,
   return result / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fseek.cpp b/src/stdio/gpu/fseek.cpp
index 3e93ddb..37c40bc 100644
--- a/src/stdio/gpu/fseek.cpp
+++ b/src/stdio/gpu/fseek.cpp
@@ -8,23 +8,26 @@
 
 #include "src/stdio/fseek.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fseek, (::FILE * stream, long offset, int whence)) {
   int ret;
   rpc::Client::Port port = rpc::client.open<RPC_FSEEK>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) {
+      [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
         buffer->data[1] = static_cast<uint64_t>(offset);
         buffer->data[2] = static_cast<uint64_t>(whence);
       },
-      [&](rpc::Buffer *buffer) { ret = static_cast<int>(buffer->data[0]); });
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<int>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/ftell.cpp b/src/stdio/gpu/ftell.cpp
index aea3e8b..226aeda 100644
--- a/src/stdio/gpu/ftell.cpp
+++ b/src/stdio/gpu/ftell.cpp
@@ -8,19 +8,24 @@
 
 #include "src/stdio/ftell.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, ftell, (::FILE * stream)) {
   long ret;
   rpc::Client::Port port = rpc::client.open<RPC_FSEEK>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) { buffer->data[0] = file::from_stream(stream); },
-      [&](rpc::Buffer *buffer) { ret = static_cast<long>(buffer->data[0]); });
+      [=](rpc::Buffer *buffer, uint32_t) {
+        buffer->data[0] = file::from_stream(stream);
+      },
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<long>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/fwrite.cpp b/src/stdio/gpu/fwrite.cpp
index a059bd5..6c54869 100644
--- a/src/stdio/gpu/fwrite.cpp
+++ b/src/stdio/gpu/fwrite.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdio/fwrite.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, fwrite,
                    (const void *__restrict buffer, size_t size, size_t nmemb,
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(size_t, fwrite,
   return result / size;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/getc.cpp b/src/stdio/gpu/getc.cpp
index b50e396..9c32974 100644
--- a/src/stdio/gpu/getc.cpp
+++ b/src/stdio/gpu/getc.cpp
@@ -8,10 +8,12 @@
 
 #include "src/stdio/getc.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getc, (::FILE * stream)) {
   unsigned char c;
@@ -22,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, getc, (::FILE * stream)) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/getchar.cpp b/src/stdio/gpu/getchar.cpp
index c8a0041..d99b97b 100644
--- a/src/stdio/gpu/getchar.cpp
+++ b/src/stdio/gpu/getchar.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdio/getchar.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF and stdin.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getchar, ()) {
   unsigned char c;
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, getchar, ()) {
   return c;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/printf.cpp b/src/stdio/gpu/printf.cpp
new file mode 100644
index 0000000..be1885f
--- /dev/null
+++ b/src/stdio/gpu/printf.cpp
@@ -0,0 +1,29 @@
+//===-- GPU Implementation of printf --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/printf.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/arg_list.h"
+#include "src/errno/libc_errno.h"
+#include "src/stdio/gpu/vfprintf_utils.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, printf, (const char *__restrict format, ...)) {
+  va_list vlist;
+  va_start(vlist, format);
+  cpp::string_view str_view(format);
+  int ret_val = vfprintf_internal(stdout, format, str_view.size() + 1, vlist);
+  va_end(vlist);
+  return ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/putc.cpp b/src/stdio/gpu/putc.cpp
index b5ecbfc..f8ae98d 100644
--- a/src/stdio/gpu/putc.cpp
+++ b/src/stdio/gpu/putc.cpp
@@ -8,10 +8,12 @@
 
 #include "src/stdio/putc.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, putc, (int c, ::FILE *stream)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -23,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, putc, (int c, ::FILE *stream)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/putchar.cpp b/src/stdio/gpu/putchar.cpp
index 57663ee..c49b02e 100644
--- a/src/stdio/gpu/putchar.cpp
+++ b/src/stdio/gpu/putchar.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "file.h"
 #include "src/stdio/putchar.h"
+#include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF and stdout.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   unsigned char uc = static_cast<unsigned char>(c);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, putchar, (int c)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/puts.cpp b/src/stdio/gpu/puts.cpp
index 10573a8..20f7a88 100644
--- a/src/stdio/gpu/puts.cpp
+++ b/src/stdio/gpu/puts.cpp
@@ -8,12 +8,13 @@
 
 #include "src/stdio/puts.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/stdio/gpu/file.h"
 
-#include <stdio.h>
+#include "hdr/stdio_macros.h" // for EOF and stdout.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, puts, (const char *__restrict str)) {
   cpp::string_view str_view(str);
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, puts, (const char *__restrict str)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/remove.cpp b/src/stdio/gpu/remove.cpp
new file mode 100644
index 0000000..6604be1
--- /dev/null
+++ b/src/stdio/gpu/remove.cpp
@@ -0,0 +1,28 @@
+//===-- Implementation of remove ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/remove.h"
+#include "file.h"
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/FILE.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, remove, (const char *path)) {
+  int ret;
+  rpc::Client::Port port = rpc::client.open<RPC_REMOVE>();
+  port.send_n(path, internal::string_length(path) + 1);
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
+    ret = static_cast<int>(buffer->data[0]);
+  });
+  port.close();
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/rename.cpp b/src/stdio/gpu/rename.cpp
new file mode 100644
index 0000000..e6396e2
--- /dev/null
+++ b/src/stdio/gpu/rename.cpp
@@ -0,0 +1,31 @@
+//===-- GPU Implementation of rename --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/rename.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/gpu/file.h"
+
+#include "hdr/types/FILE.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, rename, (const char *oldpath, const char *newpath)) {
+  int ret;
+  rpc::Client::Port port = rpc::client.open<RPC_RENAME>();
+  port.send_n(oldpath, internal::string_length(oldpath) + 1);
+  port.send_n(newpath, internal::string_length(newpath) + 1);
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
+    ret = static_cast<int>(buffer->data[0]);
+  });
+  port.close();
+
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/stderr.cpp b/src/stdio/gpu/stderr.cpp
index 7084682..efbc3b4 100644
--- a/src/stdio/gpu/stderr.cpp
+++ b/src/stdio/gpu/stderr.cpp
@@ -6,11 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 static struct {
 } stub;
 FILE *stderr = reinterpret_cast<FILE *>(&stub);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 extern "C" FILE *stderr = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::stub);
diff --git a/src/stdio/gpu/stdin.cpp b/src/stdio/gpu/stdin.cpp
index 1a58461..66618fd 100644
--- a/src/stdio/gpu/stdin.cpp
+++ b/src/stdio/gpu/stdin.cpp
@@ -6,11 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 static struct {
 } stub;
 FILE *stdin = reinterpret_cast<FILE *>(&stub);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 extern "C" FILE *stdin = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::stub);
diff --git a/src/stdio/gpu/stdout.cpp b/src/stdio/gpu/stdout.cpp
index abeeff2..e3869f9 100644
--- a/src/stdio/gpu/stdout.cpp
+++ b/src/stdio/gpu/stdout.cpp
@@ -6,11 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 static struct {
 } stub;
 FILE *stdout = reinterpret_cast<FILE *>(&stub);
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 extern "C" FILE *stdout = reinterpret_cast<FILE *>(&LIBC_NAMESPACE::stub);
diff --git a/src/stdio/gpu/ungetc.cpp b/src/stdio/gpu/ungetc.cpp
index 373164a..dce1439 100644
--- a/src/stdio/gpu/ungetc.cpp
+++ b/src/stdio/gpu/ungetc.cpp
@@ -8,22 +8,25 @@
 
 #include "src/stdio/ungetc.h"
 #include "file.h"
+#include "src/__support/macros/config.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ungetc, (int c, ::FILE *stream)) {
   int ret;
   rpc::Client::Port port = rpc::client.open<RPC_UNGETC>();
   port.send_and_recv(
-      [=](rpc::Buffer *buffer) {
+      [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = c;
         buffer->data[1] = file::from_stream(stream);
       },
-      [&](rpc::Buffer *buffer) { ret = static_cast<int>(buffer->data[0]); });
+      [&](rpc::Buffer *buffer, uint32_t) {
+        ret = static_cast<int>(buffer->data[0]);
+      });
   port.close();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/vfprintf.cpp b/src/stdio/gpu/vfprintf.cpp
new file mode 100644
index 0000000..c92685f
--- /dev/null
+++ b/src/stdio/gpu/vfprintf.cpp
@@ -0,0 +1,27 @@
+//===-- GPU Implementation of vfprintf ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vfprintf.h"
+
+#include "hdr/types/FILE.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/arg_list.h"
+#include "src/errno/libc_errno.h"
+#include "src/stdio/gpu/vfprintf_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vfprintf,
+                   (::FILE *__restrict stream, const char *__restrict format,
+                    va_list vlist)) {
+  cpp::string_view str_view(format);
+  int ret_val = vfprintf_internal(stream, format, str_view.size() + 1, vlist);
+  return ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/vfprintf_utils.h b/src/stdio/gpu/vfprintf_utils.h
new file mode 100644
index 0000000..a0a8c39
--- /dev/null
+++ b/src/stdio/gpu/vfprintf_utils.h
@@ -0,0 +1,87 @@
+//===--- GPU helper functions for printf using RPC ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/FILE.h"
+#include "src/__support/GPU/utils.h"
+#include "src/__support/RPC/rpc_client.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/gpu/file.h"
+#include "src/string/string_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+template <uint32_t opcode>
+LIBC_INLINE int vfprintf_impl(::FILE *__restrict file,
+                              const char *__restrict format, size_t format_size,
+                              va_list vlist) {
+  uint64_t mask = gpu::get_lane_mask();
+  rpc::Client::Port port = rpc::client.open<opcode>();
+
+  if constexpr (opcode == RPC_PRINTF_TO_STREAM ||
+                opcode == RPC_PRINTF_TO_STREAM_PACKED) {
+    port.send([&](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = reinterpret_cast<uintptr_t>(file);
+    });
+  }
+
+  size_t args_size = 0;
+  port.send_n(format, format_size);
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
+    args_size = static_cast<size_t>(buffer->data[0]);
+  });
+  port.send_n(vlist, args_size);
+
+  uint32_t ret = 0;
+  for (;;) {
+    const char *str = nullptr;
+    port.recv([&](rpc::Buffer *buffer, uint32_t) {
+      ret = static_cast<uint32_t>(buffer->data[0]);
+      str = reinterpret_cast<const char *>(buffer->data[1]);
+    });
+    // If any lanes have a string argument it needs to be copied back.
+    if (!gpu::ballot(mask, str))
+      break;
+
+    uint64_t size = str ? internal::string_length(str) + 1 : 0;
+    port.send_n(str, size);
+  }
+
+  port.close();
+  return ret;
+}
+
+LIBC_INLINE int vfprintf_internal(::FILE *__restrict stream,
+                                  const char *__restrict format,
+                                  size_t format_size, va_list vlist) {
+  // The AMDPGU backend uses a packed struct for its varargs. We pass it as a
+  // separate opcode so the server knows how much to advance the pointers.
+#if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
+  if (stream == stdout)
+    return vfprintf_impl<RPC_PRINTF_TO_STDOUT_PACKED>(stream, format,
+                                                      format_size, vlist);
+  else if (stream == stderr)
+    return vfprintf_impl<RPC_PRINTF_TO_STDERR_PACKED>(stream, format,
+                                                      format_size, vlist);
+  else
+    return vfprintf_impl<RPC_PRINTF_TO_STREAM_PACKED>(stream, format,
+                                                      format_size, vlist);
+#else
+  if (stream == stdout)
+    return vfprintf_impl<RPC_PRINTF_TO_STDOUT>(stream, format, format_size,
+                                               vlist);
+  else if (stream == stderr)
+    return vfprintf_impl<RPC_PRINTF_TO_STDERR>(stream, format, format_size,
+                                               vlist);
+  else
+    return vfprintf_impl<RPC_PRINTF_TO_STREAM>(stream, format, format_size,
+                                               vlist);
+#endif
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/gpu/vprintf.cpp b/src/stdio/gpu/vprintf.cpp
new file mode 100644
index 0000000..54012f3
--- /dev/null
+++ b/src/stdio/gpu/vprintf.cpp
@@ -0,0 +1,25 @@
+//===-- GPU Implementation of vprintf -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vprintf.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/arg_list.h"
+#include "src/errno/libc_errno.h"
+#include "src/stdio/gpu/vfprintf_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vprintf,
+                   (const char *__restrict format, va_list vlist)) {
+  cpp::string_view str_view(format);
+  int ret_val = vfprintf_internal(stdout, format, str_view.size() + 1, vlist);
+  return ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/linux/fdopen.cpp b/src/stdio/linux/fdopen.cpp
index a1d08ee..7d72fdc 100644
--- a/src/stdio/linux/fdopen.cpp
+++ b/src/stdio/linux/fdopen.cpp
@@ -9,9 +9,10 @@
 #include "src/stdio/fdopen.h"
 
 #include "src/__support/File/linux/file.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(::FILE *, fdopen, (int fd, const char *mode)) {
   auto result = LIBC_NAMESPACE::create_file_from_fd(fd, mode);
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(::FILE *, fdopen, (int fd, const char *mode)) {
   return reinterpret_cast<::FILE *>(result.value());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/linux/remove.cpp b/src/stdio/linux/remove.cpp
index b2742c2..dbb4491 100644
--- a/src/stdio/linux/remove.cpp
+++ b/src/stdio/linux/remove.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h" // For AT_* macros.
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>       // For AT_* macros.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, remove, (const char *path)) {
   // We first try unlinking it as a file. If it is ia file, it will succeed. If
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, remove, (const char *path)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/linux/rename.cpp b/src/stdio/linux/rename.cpp
index 379a6ef..fbcb29b 100644
--- a/src/stdio/linux/rename.cpp
+++ b/src/stdio/linux/rename.cpp
@@ -7,13 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/rename.h"
-#include "include/llvm-libc-macros/linux/fcntl-macros.h"
+#include "hdr/fcntl_macros.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, rename, (const char *oldpath, const char *newpath)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_renameat2, AT_FDCWD, oldpath,
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, rename, (const char *oldpath, const char *newpath)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf.h b/src/stdio/printf.h
index c5b4603..9e47ad8 100644
--- a/src/stdio/printf.h
+++ b/src/stdio/printf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PRINTF_H
 #define LLVM_LIBC_SRC_STDIO_PRINTF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int printf(const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_H
diff --git a/src/stdio/printf_core/char_converter.h b/src/stdio/printf_core/char_converter.h
index 13596b8..2596cba 100644
--- a/src/stdio/printf_core/char_converter.h
+++ b/src/stdio/printf_core/char_converter.h
@@ -9,11 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CHAR_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CHAR_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int convert_char(Writer *writer, const FormatSection &to_conv) {
@@ -42,6 +43,6 @@ LIBC_INLINE int convert_char(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CHAR_CONVERTER_H
diff --git a/src/stdio/printf_core/converter.cpp b/src/stdio/printf_core/converter.cpp
index 613d693..b1c6645 100644
--- a/src/stdio/printf_core/converter.cpp
+++ b/src/stdio/printf_core/converter.cpp
@@ -8,8 +8,10 @@
 
 #include "src/stdio/printf_core/converter.h"
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/printf_config.h"
+#include "src/stdio/printf_core/strerror_converter.h"
 #include "src/stdio/printf_core/writer.h"
 
 // This option allows for replacing all of the conversion functions with custom
@@ -22,7 +24,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 int convert(Writer *writer, const FormatSection &to_conv) {
@@ -83,6 +85,10 @@ int convert(Writer *writer, const FormatSection &to_conv) {
   case 'K':
     return convert_fixed(writer, to_conv);
 #endif // LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+  case 'm':
+    return convert_strerror(writer, to_conv);
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
 #ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
   case 'n':
     return convert_write_int(writer, to_conv);
@@ -96,4 +102,4 @@ int convert(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/converter.h b/src/stdio/printf_core/converter.h
index d653f1e..2b3f06d 100644
--- a/src/stdio/printf_core/converter.h
+++ b/src/stdio/printf_core/converter.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 // convert will call a conversion function to convert the FormatSection into
@@ -23,6 +24,6 @@ namespace printf_core {
 int convert(Writer *writer, const FormatSection &to_conv);
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_H
diff --git a/src/stdio/printf_core/converter_atlas.h b/src/stdio/printf_core/converter_atlas.h
index 2189ed1..18cfe1e 100644
--- a/src/stdio/printf_core/converter_atlas.h
+++ b/src/stdio/printf_core/converter_atlas.h
@@ -43,4 +43,9 @@
 // defines convert_pointer
 #include "src/stdio/printf_core/ptr_converter.h"
 
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+// defines convert_strerror
+#include "src/stdio/printf_core/strerror_converter.h"
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
+
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_ATLAS_H
diff --git a/src/stdio/printf_core/converter_utils.h b/src/stdio/printf_core/converter_utils.h
index a0e96a1..3f25ebf 100644
--- a/src/stdio/printf_core/converter_utils.h
+++ b/src/stdio/printf_core/converter_utils.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_UTILS_H
 
 #include "src/__support/CPP/limits.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE uintmax_t apply_length_modifier(uintmax_t num,
@@ -69,6 +70,6 @@ LIBC_INLINE uintmax_t apply_length_modifier(uintmax_t num,
 enum class RoundDirection { Up, Down, Even };
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CONVERTER_UTILS_H
diff --git a/src/stdio/printf_core/core_structs.h b/src/stdio/printf_core/core_structs.h
index bfe362b..4c3b81f 100644
--- a/src/stdio/printf_core/core_structs.h
+++ b/src/stdio/printf_core/core_structs.h
@@ -19,7 +19,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 // These length modifiers match the length modifiers in the format string, which
@@ -134,8 +134,8 @@ constexpr int FILE_STATUS_ERROR = -2;
 constexpr int NULLPTR_WRITE_ERROR = -3;
 constexpr int INT_CONVERSION_ERROR = -4;
 constexpr int FIXED_POINT_CONVERSION_ERROR = -5;
-
+constexpr int ALLOCATION_ERROR = -6;
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_CORE_STRUCTS_H
diff --git a/src/stdio/printf_core/fixed_converter.h b/src/stdio/printf_core/fixed_converter.h
index de69c60..c8812d7 100644
--- a/src/stdio/printf_core/fixed_converter.h
+++ b/src/stdio/printf_core/fixed_converter.h
@@ -15,6 +15,7 @@
 #include "src/__support/fixed_point/fx_rep.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
@@ -22,7 +23,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 // This is just for assertions. It will be compiled out for release builds.
@@ -304,6 +305,6 @@ LIBC_INLINE int convert_fixed(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FIXED_CONVERTER_H
diff --git a/src/stdio/printf_core/float_dec_converter.h b/src/stdio/printf_core/float_dec_converter.h
index 1237db6..e39ba6e 100644
--- a/src/stdio/printf_core/float_dec_converter.h
+++ b/src/stdio/printf_core/float_dec_converter.h
@@ -16,6 +16,7 @@
 #include "src/__support/float_to_string.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/float_inf_nan_converter.h"
@@ -24,7 +25,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 using StorageType = fputil::FPBits<long double>::StorageType;
@@ -1170,6 +1171,6 @@ LIBC_INLINE int convert_float_dec_auto(Writer *writer,
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_DEC_CONVERTER_H
diff --git a/src/stdio/printf_core/float_hex_converter.h b/src/stdio/printf_core/float_hex_converter.h
index 8fac36d..0b3ff3d 100644
--- a/src/stdio/printf_core/float_hex_converter.h
+++ b/src/stdio/printf_core/float_hex_converter.h
@@ -12,6 +12,7 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/float_inf_nan_converter.h"
@@ -20,7 +21,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int convert_float_hex_exp(Writer *writer,
@@ -255,6 +256,6 @@ LIBC_INLINE int convert_float_hex_exp(Writer *writer,
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_HEX_CONVERTER_H
diff --git a/src/stdio/printf_core/float_inf_nan_converter.h b/src/stdio/printf_core/float_inf_nan_converter.h
index f755ef6..a7da682 100644
--- a/src/stdio/printf_core/float_inf_nan_converter.h
+++ b/src/stdio/printf_core/float_inf_nan_converter.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_INF_NAN_CONVERTER_H
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
@@ -17,7 +18,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 using StorageType = fputil::FPBits<long double>::StorageType;
@@ -78,6 +79,6 @@ LIBC_INLINE int convert_inf_nan(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_INF_NAN_CONVERTER_H
diff --git a/src/stdio/printf_core/int_converter.h b/src/stdio/printf_core/int_converter.h
index 496e7bd..f345e86 100644
--- a/src/stdio/printf_core/int_converter.h
+++ b/src/stdio/printf_core/int_converter.h
@@ -12,6 +12,7 @@
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/integer_to_string.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
@@ -19,7 +20,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 // These functions only work on characters that are already known to be in the
@@ -209,6 +210,6 @@ LIBC_INLINE int convert_int(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_INT_CONVERTER_H
diff --git a/src/stdio/printf_core/parser.h b/src/stdio/printf_core/parser.h
index b9a8f30..acbbaa2 100644
--- a/src/stdio/printf_core/parser.h
+++ b/src/stdio/printf_core/parser.h
@@ -11,8 +11,10 @@
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
 #include "src/__support/CPP/algorithm.h" // max
+#include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/printf_config.h"
@@ -22,8 +24,11 @@
 #ifdef LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
 #include "src/__support/fixed_point/fx_rep.h"
 #endif // LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+#include "src/errno/libc_errno.h"
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 template <typename T> struct int_type_of {
@@ -128,7 +133,8 @@ public:
         cur_pos = cur_pos + result.parsed_len;
       }
       if (section.min_width < 0) {
-        section.min_width = -section.min_width;
+        section.min_width =
+            (section.min_width == INT_MIN) ? INT_MAX : -section.min_width;
         section.flags = static_cast<FormatFlags>(section.flags |
                                                  FormatFlags::LEFT_JUSTIFIED);
       }
@@ -208,11 +214,11 @@ public:
         case (LengthModifier::wf):
           if (bw == 0) {
             section.has_conv = false;
-          } else if (bw <= INT_WIDTH) {
+          } else if (bw <= cpp::numeric_limits<unsigned int>::digits) {
             WRITE_ARG_VAL_SIMPLEST(section.conv_val_raw, int, conv_index);
-          } else if (bw <= LONG_WIDTH) {
+          } else if (bw <= cpp::numeric_limits<unsigned long>::digits) {
             WRITE_ARG_VAL_SIMPLEST(section.conv_val_raw, long, conv_index);
-          } else if (bw <= LLONG_WIDTH) {
+          } else if (bw <= cpp::numeric_limits<unsigned long long>::digits) {
             WRITE_ARG_VAL_SIMPLEST(section.conv_val_raw, long long, conv_index);
           } else {
             WRITE_ARG_VAL_SIMPLEST(section.conv_val_raw, intmax_t, conv_index);
@@ -255,9 +261,16 @@ public:
         }
         break;
 #endif // LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+      case ('m'):
+        // %m is an odd conversion in that it doesn't consume an argument, it
+        // just takes the current value of errno as its argument.
+        section.conv_val_raw = static_cast<int>(libc_errno);
+        break;
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
 #ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
-      case ('n'):
-#endif // LIBC_COPT_PRINTF_DISABLE_WRITE_INT
+      case ('n'): // Intentional fallthrough
+#endif            // LIBC_COPT_PRINTF_DISABLE_WRITE_INT
       case ('p'):
         WRITE_ARG_VAL_SIMPLEST(section.conv_val_ptr, void *, conv_index);
         break;
@@ -594,11 +607,11 @@ private:
             break;
           case (LengthModifier::w):
           case (LengthModifier::wf):
-            if (bw <= INT_WIDTH) {
+            if (bw <= cpp::numeric_limits<unsigned int>::digits) {
               conv_size = type_desc_from_type<int>();
-            } else if (bw <= LONG_WIDTH) {
+            } else if (bw <= cpp::numeric_limits<unsigned long>::digits) {
               conv_size = type_desc_from_type<long>();
-            } else if (bw <= LLONG_WIDTH) {
+            } else if (bw <= cpp::numeric_limits<unsigned long long>::digits) {
               conv_size = type_desc_from_type<long long>();
             } else {
               conv_size = type_desc_from_type<intmax_t>();
@@ -668,6 +681,6 @@ private:
 };
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PARSER_H
diff --git a/src/stdio/printf_core/printf_main.cpp b/src/stdio/printf_core/printf_main.cpp
index 54e70f5..bd4a5a1 100644
--- a/src/stdio/printf_core/printf_main.cpp
+++ b/src/stdio/printf_core/printf_main.cpp
@@ -9,6 +9,7 @@
 #include "src/stdio/printf_core/printf_main.h"
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/parser.h"
@@ -16,7 +17,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 int printf_main(Writer *writer, const char *__restrict str,
@@ -39,4 +40,4 @@ int printf_main(Writer *writer, const char *__restrict str,
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/printf_main.h b/src/stdio/printf_core/printf_main.h
index 15c6977..3e73bf3 100644
--- a/src/stdio/printf_core/printf_main.h
+++ b/src/stdio/printf_core/printf_main.h
@@ -10,17 +10,18 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PRINTF_MAIN_H
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 int printf_main(Writer *writer, const char *__restrict str,
                 internal::ArgList &args);
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PRINTF_MAIN_H
diff --git a/src/stdio/printf_core/ptr_converter.h b/src/stdio/printf_core/ptr_converter.h
index c5d4086..bf84718 100644
--- a/src/stdio/printf_core/ptr_converter.h
+++ b/src/stdio/printf_core/ptr_converter.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PTR_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PTR_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/int_converter.h"
 #include "src/stdio/printf_core/string_converter.h"
 #include "src/stdio/printf_core/writer.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int convert_pointer(Writer *writer, const FormatSection &to_conv) {
@@ -35,6 +36,6 @@ LIBC_INLINE int convert_pointer(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_PTR_CONVERTER_H
diff --git a/src/stdio/printf_core/strerror_converter.h b/src/stdio/printf_core/strerror_converter.h
new file mode 100644
index 0000000..2902fd3
--- /dev/null
+++ b/src/stdio/printf_core/strerror_converter.h
@@ -0,0 +1,74 @@
+//===-- Strerror Converter for printf ---------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_STRERROR_CONVERTER_H
+#define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_STRERROR_CONVERTER_H
+
+#include "src/__support/StringUtil/error_to_string.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/core_structs.h"
+#include "src/stdio/printf_core/int_converter.h"
+#include "src/stdio/printf_core/string_converter.h"
+#include "src/stdio/printf_core/writer.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace printf_core {
+
+LIBC_INLINE int convert_strerror(Writer *writer, const FormatSection &to_conv) {
+  FormatSection new_conv = to_conv;
+  const int error_num = static_cast<int>(to_conv.conv_val_raw);
+
+  // The %m conversion takes no arguments passes the result of strerror(errno)
+  // to a string conversion (including all options). If the alternate form flag
+  // is set, then if errno is a valid error number the string of the errno macro
+  // is passed to a string conversion, else the integer value of errno is passed
+  // to an integer conversion.
+
+  // It's assumed that errno is passed in to_conv.conv_val_raw.
+
+  // normal form
+  if ((to_conv.flags & FormatFlags::ALTERNATE_FORM) == 0) {
+    char strerror_buff[64];
+    auto strerror_result = get_error_string(error_num, strerror_buff);
+    new_conv.conv_val_ptr =
+        reinterpret_cast<void *>(const_cast<char *>(strerror_result.data()));
+    new_conv.conv_name = 's';
+    return convert_string(writer, new_conv);
+  } else {
+    // alt form
+
+    // The handling of errno = 0 is in alt form weird. The rule for %m in alt
+    // form is "named macros print their name, else print errno as int." There
+    // isn't a specific name for errno = 0, but it does have an explicit meaning
+    // (success). Due to the way the string mappings work, it's easiest to just
+    // say that 0 is a valid macro with a string of "0". This works fine for
+    // most cases, but for precision and the int flags it changes the behavior.
+    // Given that this behavior is so incredibly deep in the weeds I doubt
+    // anyone would notice, I'm going to leave it as the simplest to implement
+    // (0 maps to "0"), which also happens to match what other libc
+    // implementations have done.
+
+    auto errno_name = try_get_errno_name(error_num);
+    // if there's a name available, use it.
+    if (errno_name) {
+      new_conv.conv_val_ptr =
+          reinterpret_cast<void *>(const_cast<char *>(errno_name->data()));
+      new_conv.conv_name = 's';
+      return convert_string(writer, new_conv);
+    } else {
+      // else do an int conversion
+      new_conv.conv_name = 'd';
+      return convert_int(writer, new_conv);
+    }
+  }
+}
+
+} // namespace printf_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_STRERROR_CONVERTER_H
diff --git a/src/stdio/printf_core/string_converter.h b/src/stdio/printf_core/string_converter.h
index 9e05591..1f36d51 100644
--- a/src/stdio/printf_core/string_converter.h
+++ b/src/stdio/printf_core/string_converter.h
@@ -10,13 +10,14 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_STRING_CONVERTER_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int convert_string(Writer *writer, const FormatSection &to_conv) {
@@ -58,6 +59,6 @@ LIBC_INLINE int convert_string(Writer *writer, const FormatSection &to_conv) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_STRING_CONVERTER_H
diff --git a/src/stdio/printf_core/vasprintf_internal.h b/src/stdio/printf_core/vasprintf_internal.h
new file mode 100644
index 0000000..0e446f8
--- /dev/null
+++ b/src/stdio/printf_core/vasprintf_internal.h
@@ -0,0 +1,69 @@
+//===-- Internal Implementation of asprintf ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/func/free.h"
+#include "hdr/func/malloc.h"
+#include "hdr/func/realloc.h"
+#include "src/__support/arg_list.h"
+#include "src/stdio/printf.h"
+#include "src/stdio/printf_core/core_structs.h"
+#include "src/stdio/printf_core/printf_main.h"
+#include "src/stdio/printf_core/writer.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace printf_core {
+
+LIBC_INLINE int resize_overflow_hook(cpp::string_view new_str, void *target) {
+  printf_core::WriteBuffer *wb =
+      reinterpret_cast<printf_core::WriteBuffer *>(target);
+  size_t new_size = new_str.size() + wb->buff_cur;
+  const bool isBuffOnStack = (wb->buff == wb->init_buff);
+  char *new_buff = static_cast<char *>(
+      isBuffOnStack ? malloc(new_size + 1)
+                    : realloc(wb->buff, new_size + 1)); // +1 for null
+  if (new_buff == nullptr) {
+    if (wb->buff != wb->init_buff)
+      free(wb->buff);
+    return printf_core::ALLOCATION_ERROR;
+  }
+  if (isBuffOnStack)
+    inline_memcpy(new_buff, wb->buff, wb->buff_cur);
+  wb->buff = new_buff;
+  inline_memcpy(wb->buff + wb->buff_cur, new_str.data(), new_str.size());
+  wb->buff_cur = new_size;
+  wb->buff_len = new_size;
+  return printf_core::WRITE_OK;
+}
+
+constexpr size_t DEFAULT_BUFFER_SIZE = 200;
+
+LIBC_INLINE int vasprintf_internal(char **ret, const char *__restrict format,
+                                   internal::ArgList args) {
+  char init_buff_on_stack[DEFAULT_BUFFER_SIZE];
+  printf_core::WriteBuffer wb(init_buff_on_stack, DEFAULT_BUFFER_SIZE,
+                              resize_overflow_hook);
+  printf_core::Writer writer(&wb);
+
+  auto ret_val = printf_core::printf_main(&writer, format, args);
+  if (ret_val < 0) {
+    *ret = nullptr;
+    return -1;
+  }
+  if (wb.buff == init_buff_on_stack) {
+    *ret = static_cast<char *>(malloc(ret_val + 1));
+    if (ret == nullptr)
+      return printf_core::ALLOCATION_ERROR;
+    inline_memcpy(*ret, wb.buff, ret_val);
+  } else {
+    *ret = wb.buff;
+  }
+  (*ret)[ret_val] = '\0';
+  return ret_val;
+}
+} // namespace printf_core
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/vfprintf_internal.h b/src/stdio/printf_core/vfprintf_internal.h
index c16c3ae..3becfee 100644
--- a/src/stdio/printf_core/vfprintf_internal.h
+++ b/src/stdio/printf_core/vfprintf_internal.h
@@ -12,13 +12,14 @@
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
 #include "src/__support/macros/attributes.h" // For LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace internal {
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
@@ -84,6 +85,6 @@ LIBC_INLINE int vfprintf_internal(::FILE *__restrict stream,
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_VFPRINTF_INTERNAL_H
diff --git a/src/stdio/printf_core/write_int_converter.h b/src/stdio/printf_core/write_int_converter.h
index 18aa5c7..a47cb41 100644
--- a/src/stdio/printf_core/write_int_converter.h
+++ b/src/stdio/printf_core/write_int_converter.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_WRITE_INT_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_WRITE_INT_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int convert_write_int(Writer *writer,
@@ -64,6 +65,6 @@ LIBC_INLINE int convert_write_int(Writer *writer,
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_WRITE_INT_CONVERTER_H
diff --git a/src/stdio/printf_core/writer.cpp b/src/stdio/printf_core/writer.cpp
index f8ecd82..d1cf85d 100644
--- a/src/stdio/printf_core/writer.cpp
+++ b/src/stdio/printf_core/writer.cpp
@@ -8,11 +8,12 @@
 
 #include "writer.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/string/memory_utils/inline_memset.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 int Writer::pad(char new_char, size_t length) {
@@ -42,4 +43,4 @@ int Writer::pad(char new_char, size_t length) {
 }
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/writer.h b/src/stdio/printf_core/writer.h
index 67513ec..5526a47 100644
--- a/src/stdio/printf_core/writer.h
+++ b/src/stdio/printf_core/writer.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_WRITER_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "src/string/memory_utils/inline_memcpy.h"
@@ -17,65 +18,89 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 struct WriteBuffer {
+  enum class WriteMode {
+    FILL_BUFF_AND_DROP_OVERFLOW,
+    FLUSH_TO_STREAM,
+    RESIZE_AND_FILL_BUFF,
+  };
   using StreamWriter = int (*)(cpp::string_view, void *);
   char *buff;
-  const size_t buff_len;
+  const char *init_buff; // for checking when resize.
+  size_t buff_len;
   size_t buff_cur = 0;
 
   // The stream writer will be called when the buffer is full. It will be passed
   // string_views to write to the stream.
   StreamWriter stream_writer;
   void *output_target;
+  WriteMode write_mode;
 
   LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len, StreamWriter hook,
                           void *target)
-      : buff(Buff), buff_len(Buff_len), stream_writer(hook),
-        output_target(target) {}
+      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(hook),
+        output_target(target), write_mode(WriteMode::FLUSH_TO_STREAM) {}
 
   LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len)
-      : buff(Buff), buff_len(Buff_len), stream_writer(nullptr),
-        output_target(nullptr) {}
+      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(nullptr),
+        output_target(nullptr),
+        write_mode(WriteMode::FILL_BUFF_AND_DROP_OVERFLOW) {}
+
+  LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len, StreamWriter hook)
+      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(hook),
+        output_target(this), write_mode(WriteMode::RESIZE_AND_FILL_BUFF) {}
+
+  LIBC_INLINE int flush_to_stream(cpp::string_view new_str) {
+    if (buff_cur > 0) {
+      int retval = stream_writer({buff, buff_cur}, output_target);
+      if (retval < 0)
+        return retval;
+    }
+    if (new_str.size() > 0) {
+      int retval = stream_writer(new_str, output_target);
+      if (retval < 0)
+        return retval;
+    }
+    buff_cur = 0;
+    return WRITE_OK;
+  }
+
+  LIBC_INLINE int fill_remaining_to_buff(cpp::string_view new_str) {
+    if (buff_cur < buff_len) {
+      size_t bytes_to_write = buff_len - buff_cur;
+      if (bytes_to_write > new_str.size()) {
+        bytes_to_write = new_str.size();
+      }
+      inline_memcpy(buff + buff_cur, new_str.data(), bytes_to_write);
+      buff_cur += bytes_to_write;
+    }
+    return WRITE_OK;
+  }
+
+  LIBC_INLINE int resize_and_write(cpp::string_view new_str) {
+    return stream_writer(new_str, output_target);
+  }
 
   // The overflow_write method is intended to be called to write the contents of
-  // the buffer and new_str to the stream_writer if it exists, else it will
-  // write as much of new_str to the buffer as it can. The current position in
-  // the buffer will be reset iff stream_writer is called. Calling this with an
-  // empty string will flush the buffer if relevant.
+  // the buffer and new_str to the stream_writer if it exists. If a resizing
+  // hook is provided, it will resize the buffer and write the contents. If
+  // neither a stream_writer nor a resizing hook is provided, it will fill the
+  // remaining space in the buffer with new_str and drop the overflow. Calling
+  // this with an empty string will flush the buffer if relevant.
+
   LIBC_INLINE int overflow_write(cpp::string_view new_str) {
-    // If there is a stream_writer, write the contents of the buffer, then
-    // new_str, then clear the buffer.
-    if (stream_writer != nullptr) {
-      if (buff_cur > 0) {
-        int retval = stream_writer({buff, buff_cur}, output_target);
-        if (retval < 0) {
-          return retval;
-        }
-      }
-      if (new_str.size() > 0) {
-        int retval = stream_writer(new_str, output_target);
-        if (retval < 0) {
-          return retval;
-        }
-      }
-      buff_cur = 0;
-      return WRITE_OK;
-    } else {
-      // We can't flush to the stream, so fill the rest of the buffer, then drop
-      // the overflow.
-      if (buff_cur < buff_len) {
-        size_t bytes_to_write = buff_len - buff_cur;
-        if (bytes_to_write > new_str.size()) {
-          bytes_to_write = new_str.size();
-        }
-        inline_memcpy(buff + buff_cur, new_str.data(), bytes_to_write);
-        buff_cur += bytes_to_write;
-      }
-      return WRITE_OK;
+    switch (write_mode) {
+    case WriteMode::FILL_BUFF_AND_DROP_OVERFLOW:
+      return fill_remaining_to_buff(new_str);
+    case WriteMode::FLUSH_TO_STREAM:
+      return flush_to_stream(new_str);
+    case WriteMode::RESIZE_AND_FILL_BUFF:
+      return resize_and_write(new_str);
     }
+    __builtin_unreachable();
   }
 };
 
@@ -134,6 +159,6 @@ public:
 };
 
 } // namespace printf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_WRITER_H
diff --git a/src/stdio/putc.h b/src/stdio/putc.h
index a8fb5b7..35ec07b 100644
--- a/src/stdio/putc.h
+++ b/src/stdio/putc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PUTC_H
 #define LLVM_LIBC_SRC_STDIO_PUTC_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int putc(int c, ::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PUTC_H
diff --git a/src/stdio/putchar.h b/src/stdio/putchar.h
index e458e31..84a5ea8 100644
--- a/src/stdio/putchar.h
+++ b/src/stdio/putchar.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PUTCHAR_H
 #define LLVM_LIBC_SRC_STDIO_PUTCHAR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int putchar(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PUTCHAR_H
diff --git a/src/stdio/puts.h b/src/stdio/puts.h
index 11fbd0b..d93495b 100644
--- a/src/stdio/puts.h
+++ b/src/stdio/puts.h
@@ -9,12 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_PUTS_H
 #define LLVM_LIBC_SRC_STDIO_PUTS_H
 
-#include <stdio.h>
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int puts(const char *__restrict str);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_PUTS_H
diff --git a/src/stdio/remove.h b/src/stdio/remove.h
index 8c52fe5..267946f 100644
--- a/src/stdio/remove.h
+++ b/src/stdio/remove.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_REMOVE_H
 #define LLVM_LIBC_SRC_STDIO_REMOVE_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int remove(const char *path);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_REMOVE_H
diff --git a/src/stdio/rename.h b/src/stdio/rename.h
index eadda7c..5c9ab88 100644
--- a/src/stdio/rename.h
+++ b/src/stdio/rename.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_RENAME_H
 #define LLVM_LIBC_SRC_STDIO_RENAME_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int rename(const char *oldpath, const char *newpath);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_RENAME_H
diff --git a/src/stdio/scanf.cpp b/src/stdio/scanf.cpp
index 3a9fafa..86a8851 100644
--- a/src/stdio/scanf.cpp
+++ b/src/stdio/scanf.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/vfscanf_internal.h"
 
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 #define SCANF_STDIN LIBC_NAMESPACE::stdin
@@ -21,7 +22,7 @@
 #define SCANF_STDIN ::stdin
 #endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, scanf, (const char *__restrict format, ...)) {
   va_list vlist;
@@ -37,4 +38,4 @@ LLVM_LIBC_FUNCTION(int, scanf, (const char *__restrict format, ...)) {
   return (ret_val == -1) ? EOF : ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf.h b/src/stdio/scanf.h
index 58e42d1..f3349c7 100644
--- a/src/stdio/scanf.h
+++ b/src/stdio/scanf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int scanf(const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_H
diff --git a/src/stdio/scanf_core/converter.cpp b/src/stdio/scanf_core/converter.cpp
index 5334af1..b1ee8cd 100644
--- a/src/stdio/scanf_core/converter.cpp
+++ b/src/stdio/scanf_core/converter.cpp
@@ -9,6 +9,7 @@
 #include "src/stdio/scanf_core/converter.h"
 
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
@@ -22,7 +23,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert(Reader *reader, const FormatSection &to_conv) {
@@ -99,4 +100,4 @@ int raw_match(Reader *reader, cpp::string_view raw_string) {
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/converter.h b/src/stdio/scanf_core/converter.h
index f741840..3f514ee 100644
--- a/src/stdio/scanf_core/converter.h
+++ b/src/stdio/scanf_core/converter.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_CONVERTER_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 // convert will call a conversion function to convert the FormatSection into
@@ -28,6 +29,6 @@ int convert(Reader *reader, const FormatSection &to_conv);
 int raw_match(Reader *reader, cpp::string_view raw_string);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_CONVERTER_H
diff --git a/src/stdio/scanf_core/converter_utils.h b/src/stdio/scanf_core/converter_utils.h
index a25e8a7..6195455 100644
--- a/src/stdio/scanf_core/converter_utils.h
+++ b/src/stdio/scanf_core/converter_utils.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_CONVERTER_UTILS_H
 
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/stdio/scanf_core/core_structs.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 LIBC_INLINE constexpr char to_lower(char a) { return a | 32; }
@@ -106,6 +107,6 @@ LIBC_INLINE void write_float_with_length(char *str,
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_CONVERTER_UTILS_H
diff --git a/src/stdio/scanf_core/core_structs.h b/src/stdio/scanf_core/core_structs.h
index 29e1bf2..87b2429 100644
--- a/src/stdio/scanf_core/core_structs.h
+++ b/src/stdio/scanf_core/core_structs.h
@@ -11,11 +11,12 @@
 
 #include "src/__support/CPP/bitset.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 
 #include <inttypes.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 // These length modifiers match the length modifiers in the format string, which
@@ -86,6 +87,6 @@ enum ErrorCodes : int {
   ALLOCATION_FAILURE = -4,
 };
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_CORE_STRUCTS_H
diff --git a/src/stdio/scanf_core/current_pos_converter.h b/src/stdio/scanf_core/current_pos_converter.h
index be25cef..8af1cc0 100644
--- a/src/stdio/scanf_core/current_pos_converter.h
+++ b/src/stdio/scanf_core/current_pos_converter.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_CURRENT_POS_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_CURRENT_POS_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 LIBC_INLINE int convert_current_pos(Reader *reader,
@@ -25,6 +26,6 @@ LIBC_INLINE int convert_current_pos(Reader *reader,
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_CURRENT_POS_CONVERTER_H
diff --git a/src/stdio/scanf_core/float_converter.cpp b/src/stdio/scanf_core/float_converter.cpp
index 8500d98..b2d60a2 100644
--- a/src/stdio/scanf_core/float_converter.cpp
+++ b/src/stdio/scanf_core/float_converter.cpp
@@ -11,13 +11,14 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/char_vector.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 // All of the floating point conversions are the same for scanf, every name will
@@ -223,4 +224,4 @@ int convert_float(Reader *reader, const FormatSection &to_conv) {
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/float_converter.h b/src/stdio/scanf_core/float_converter.h
index a3ea1da..bd44847 100644
--- a/src/stdio/scanf_core/float_converter.h
+++ b/src/stdio/scanf_core/float_converter.h
@@ -9,17 +9,18 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_FLOAT_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_FLOAT_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert_float(Reader *reader, const FormatSection &to_conv);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_FLOAT_CONVERTER_H
diff --git a/src/stdio/scanf_core/int_converter.cpp b/src/stdio/scanf_core/int_converter.cpp
index 05d6ed6..ecdac52 100644
--- a/src/stdio/scanf_core/int_converter.cpp
+++ b/src/stdio/scanf_core/int_converter.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 // This code is very similar to the code in __support/str_to_integer.h but is
@@ -123,13 +124,24 @@ int convert_int(Reader *reader, const FormatSection &to_conv) {
 
       if (to_lower(cur_char) == 'x') {
         // This is a valid hex prefix.
+
+        is_number = false;
+        // A valid hex prefix is not necessarily a valid number. For the
+        // conversion to be valid it needs to use all of the characters it
+        // consumes. From the standard:
+        // 7.23.6.2 paragraph 9: "An input item is defined as the longest
+        // sequence of input characters which does not exceed any specified
+        // field width and which is, or is a prefix of, a matching input
+        // sequence."
+        // 7.23.6.2 paragraph 10: "If the input item is not a matching sequence,
+        // the execution of the directive fails: this condition is a matching
+        // failure"
         base = 16;
         if (max_width > 1) {
           --max_width;
           cur_char = reader->getc();
         } else {
-          write_int_with_length(0, to_conv);
-          return READ_OK;
+          return MATCHING_FAILURE;
         }
 
       } else {
@@ -197,6 +209,9 @@ int convert_int(Reader *reader, const FormatSection &to_conv) {
   // last one back.
   reader->ungetc(cur_char);
 
+  if (!is_number)
+    return MATCHING_FAILURE;
+
   if (has_overflow) {
     write_int_with_length(MAX, to_conv);
   } else {
@@ -206,10 +221,8 @@ int convert_int(Reader *reader, const FormatSection &to_conv) {
     write_int_with_length(result, to_conv);
   }
 
-  if (!is_number)
-    return MATCHING_FAILURE;
   return READ_OK;
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/int_converter.h b/src/stdio/scanf_core/int_converter.h
index 7c9d8b4..5fc27ad 100644
--- a/src/stdio/scanf_core/int_converter.h
+++ b/src/stdio/scanf_core/int_converter.h
@@ -9,17 +9,18 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_INT_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_INT_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert_int(Reader *reader, const FormatSection &to_conv);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_INT_CONVERTER_H
diff --git a/src/stdio/scanf_core/parser.h b/src/stdio/scanf_core/parser.h
index 5ae9009..6cc5b30 100644
--- a/src/stdio/scanf_core/parser.h
+++ b/src/stdio/scanf_core/parser.h
@@ -11,13 +11,14 @@
 
 #include "src/__support/arg_list.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/scanf_config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 #ifndef LIBC_COPT_SCANF_DISABLE_INDEX_MODE
@@ -279,6 +280,6 @@ private:
 };
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_PARSER_H
diff --git a/src/stdio/scanf_core/ptr_converter.cpp b/src/stdio/scanf_core/ptr_converter.cpp
index cc233c3..1a42a38 100644
--- a/src/stdio/scanf_core/ptr_converter.cpp
+++ b/src/stdio/scanf_core/ptr_converter.cpp
@@ -8,6 +8,7 @@
 
 #include "src/stdio/scanf_core/ptr_converter.h"
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/int_converter.h"
@@ -15,7 +16,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 int convert_pointer(Reader *reader, const FormatSection &to_conv) {
   static const char nullptr_string[] = "(nullptr)";
@@ -40,4 +41,4 @@ int convert_pointer(Reader *reader, const FormatSection &to_conv) {
   return convert_int(reader, to_conv);
 }
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/ptr_converter.h b/src/stdio/scanf_core/ptr_converter.h
index 363d9aa..0732c1c 100644
--- a/src/stdio/scanf_core/ptr_converter.h
+++ b/src/stdio/scanf_core/ptr_converter.h
@@ -9,17 +9,18 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_PTR_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_PTR_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert_pointer(Reader *reader, const FormatSection &to_conv);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_PTR_CONVERTER_H
diff --git a/src/stdio/scanf_core/reader.cpp b/src/stdio/scanf_core/reader.cpp
index eca0e37..ec1f5c0 100644
--- a/src/stdio/scanf_core/reader.cpp
+++ b/src/stdio/scanf_core/reader.cpp
@@ -7,9 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/scanf_core/reader.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 void Reader::ungetc(char c) {
@@ -25,4 +26,4 @@ void Reader::ungetc(char c) {
   stream_ungetc(static_cast<int>(c), input_stream);
 }
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/reader.h b/src/stdio/scanf_core/reader.h
index f750c43..f984fd9 100644
--- a/src/stdio/scanf_core/reader.h
+++ b/src/stdio/scanf_core/reader.h
@@ -10,9 +10,10 @@
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_READER_H
 
 #include "src/__support/macros/attributes.h" // For LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 using StreamGetc = int (*)(void *);
@@ -21,7 +22,7 @@ using StreamUngetc = void (*)(int, void *);
 // This is intended to be either a raw string or a buffer syncronized with the
 // file's internal buffer.
 struct ReadBuffer {
-  char *buffer;
+  const char *buffer;
   size_t buff_len;
   size_t buff_cur = 0;
 };
@@ -31,6 +32,7 @@ class Reader {
 
   void *input_stream = nullptr;
 
+  // TODO: Remove these unnecessary function pointers
   StreamGetc stream_getc = nullptr;
   StreamUngetc stream_ungetc = nullptr;
 
@@ -68,6 +70,6 @@ public:
 };
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_READER_H
diff --git a/src/stdio/scanf_core/scanf_main.cpp b/src/stdio/scanf_core/scanf_main.cpp
index dc7740d..eb48094 100644
--- a/src/stdio/scanf_core/scanf_main.cpp
+++ b/src/stdio/scanf_core/scanf_main.cpp
@@ -9,6 +9,7 @@
 #include "src/stdio/scanf_core/scanf_main.h"
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/converter.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/parser.h"
@@ -16,7 +17,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int scanf_main(Reader *reader, const char *__restrict str,
@@ -42,4 +43,4 @@ int scanf_main(Reader *reader, const char *__restrict str,
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/scanf_main.h b/src/stdio/scanf_core/scanf_main.h
index f1688d6..27c2469 100644
--- a/src/stdio/scanf_core/scanf_main.h
+++ b/src/stdio/scanf_core/scanf_main.h
@@ -10,17 +10,18 @@
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_SCANF_MAIN_H
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int scanf_main(Reader *reader, const char *__restrict str,
                internal::ArgList &args);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_SCANF_MAIN_H
diff --git a/src/stdio/scanf_core/string_converter.cpp b/src/stdio/scanf_core/string_converter.cpp
index 94a7fc4..0de2eee 100644
--- a/src/stdio/scanf_core/string_converter.cpp
+++ b/src/stdio/scanf_core/string_converter.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert_string(Reader *reader, const FormatSection &to_conv) {
@@ -73,4 +74,4 @@ int convert_string(Reader *reader, const FormatSection &to_conv) {
 }
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/string_converter.h b/src/stdio/scanf_core/string_converter.h
index 165fc47..552dc22 100644
--- a/src/stdio/scanf_core/string_converter.h
+++ b/src/stdio/scanf_core/string_converter.h
@@ -9,17 +9,18 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_CONVERTER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
 int convert_string(Reader *reader, const FormatSection &to_conv);
 
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_CONVERTER_H
diff --git a/src/stdio/scanf_core/vfscanf_internal.h b/src/stdio/scanf_core/vfscanf_internal.h
index 8081136..6712643 100644
--- a/src/stdio/scanf_core/vfscanf_internal.h
+++ b/src/stdio/scanf_core/vfscanf_internal.h
@@ -11,16 +11,44 @@
 
 #include "src/__support/File/file.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/architectures.h"
 #include "src/stdio/scanf_core/reader.h"
 #include "src/stdio/scanf_core/scanf_main.h"
 
-#include <stdio.h>
+#if defined(LIBC_TARGET_ARCH_IS_GPU)
+#include "src/stdio/ferror.h"
+#include "src/stdio/getc.h"
+#include "src/stdio/ungetc.h"
+#endif
 
-namespace LIBC_NAMESPACE {
+#include "hdr/types/FILE.h"
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
 
 namespace internal {
 
-#ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
+#if defined(LIBC_TARGET_ARCH_IS_GPU)
+// The GPU build provides FILE access through the host operating system's
+// library. So here we simply use the public entrypoints like in the SYSTEM_FILE
+// interface. Entrypoints should normally not call others, this is an exception.
+// FIXME: We do not acquire any locks here, so this is not thread safe.
+LIBC_INLINE void flockfile(::FILE *) { return; }
+
+LIBC_INLINE void funlockfile(::FILE *) { return; }
+
+LIBC_INLINE int getc(void *f) {
+  return LIBC_NAMESPACE::getc(reinterpret_cast<::FILE *>(f));
+}
+
+LIBC_INLINE void ungetc(int c, void *f) {
+  LIBC_NAMESPACE::ungetc(c, reinterpret_cast<::FILE *>(f));
+}
+
+LIBC_INLINE int ferror_unlocked(::FILE *f) { return LIBC_NAMESPACE::ferror(f); }
+
+#elif !defined(LIBC_COPT_STDIO_USE_SYSTEM_FILE)
 
 LIBC_INLINE void flockfile(FILE *f) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(f)->lock();
@@ -84,6 +112,6 @@ LIBC_INLINE int vfscanf_internal(::FILE *__restrict stream,
   return retval;
 }
 } // namespace scanf_core
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_VFSCANF_INTERNAL_H
diff --git a/src/stdio/setbuf.cpp b/src/stdio/setbuf.cpp
index 8819901..f3db97d 100644
--- a/src/stdio/setbuf.cpp
+++ b/src/stdio/setbuf.cpp
@@ -7,12 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdio/setbuf.h"
+#include "hdr/stdio_macros.h"
 #include "src/__support/File/file.h"
-
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, setbuf,
                    (::FILE *__restrict stream, char *__restrict buf)) {
@@ -25,4 +25,4 @@ LLVM_LIBC_FUNCTION(void, setbuf,
     libc_errno = err;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/setbuf.h b/src/stdio/setbuf.h
index 9c7aab9..f9d8e89 100644
--- a/src/stdio/setbuf.h
+++ b/src/stdio/setbuf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SETBUF_H
 #define LLVM_LIBC_SRC_STDIO_SETBUF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void setbuf(::FILE *__restrict stream, char *__restrict buf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SETBUF_H
diff --git a/src/stdio/setvbuf.cpp b/src/stdio/setvbuf.cpp
index 5fdaebc..0a6b8ca 100644
--- a/src/stdio/setvbuf.cpp
+++ b/src/stdio/setvbuf.cpp
@@ -9,10 +9,12 @@
 #include "src/stdio/setvbuf.h"
 #include "src/__support/File/file.h"
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, setvbuf,
                    (::FILE *__restrict stream, char *__restrict buf, int type,
@@ -24,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, setvbuf,
   return err;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/setvbuf.h b/src/stdio/setvbuf.h
index 21d9c99..50bfc5c 100644
--- a/src/stdio/setvbuf.h
+++ b/src/stdio/setvbuf.h
@@ -9,13 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SETVBUF_H
 #define LLVM_LIBC_SRC_STDIO_SETVBUF_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int setvbuf(::FILE *__restrict stream, char *__restrict buf, int type,
             size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SETVBUF_H
diff --git a/src/stdio/snprintf.cpp b/src/stdio/snprintf.cpp
index fbfc2b2..12ad3cd 100644
--- a/src/stdio/snprintf.cpp
+++ b/src/stdio/snprintf.cpp
@@ -9,13 +9,14 @@
 #include "src/stdio/snprintf.h"
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, snprintf,
                    (char *__restrict buffer, size_t buffsz,
@@ -35,4 +36,4 @@ LLVM_LIBC_FUNCTION(int, snprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/snprintf.h b/src/stdio/snprintf.h
index 0e4e398..92a6529 100644
--- a/src/stdio/snprintf.h
+++ b/src/stdio/snprintf.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SNPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_SNPRINTF_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int snprintf(char *__restrict buffer, size_t buffsz,
              const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SNPRINTF_H
diff --git a/src/stdio/sprintf.cpp b/src/stdio/sprintf.cpp
index 11f2f1a..1f59e6b 100644
--- a/src/stdio/sprintf.cpp
+++ b/src/stdio/sprintf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sprintf,
                    (char *__restrict buffer, const char *__restrict format,
@@ -35,4 +36,4 @@ LLVM_LIBC_FUNCTION(int, sprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/sprintf.h b/src/stdio/sprintf.h
index 14bb4fa..ef65de3 100644
--- a/src/stdio/sprintf.h
+++ b/src/stdio/sprintf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_SPRINTF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int sprintf(char *__restrict buffer, const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SPRINTF_H
diff --git a/src/stdio/sscanf.cpp b/src/stdio/sscanf.cpp
index 9bbd813..82de8a2 100644
--- a/src/stdio/sscanf.cpp
+++ b/src/stdio/sscanf.cpp
@@ -10,13 +10,15 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/reader.h"
 #include "src/stdio/scanf_core/scanf_main.h"
 
+#include "hdr/stdio_macros.h"
+#include "hdr/types/FILE.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, sscanf,
                    (const char *__restrict buffer,
@@ -27,8 +29,7 @@ LLVM_LIBC_FUNCTION(int, sscanf,
                                  // and pointer semantics, as well as handling
                                  // destruction automatically.
   va_end(vlist);
-  scanf_core::ReadBuffer rb{const_cast<char *>(buffer),
-                            cpp::numeric_limits<size_t>::max()};
+  scanf_core::ReadBuffer rb{buffer, cpp::numeric_limits<size_t>::max()};
   scanf_core::Reader reader(&rb);
   int ret_val = scanf_core::scanf_main(&reader, format, args);
   // This is done to avoid including stdio.h in the internals. On most systems
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, sscanf,
   return (ret_val == -1) ? EOF : ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/sscanf.h b/src/stdio/sscanf.h
index 9e4b28e..690b260 100644
--- a/src/stdio/sscanf.h
+++ b/src/stdio/sscanf.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SSCANF_H
 #define LLVM_LIBC_SRC_STDIO_SSCANF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int sscanf(const char *__restrict buffer, const char *__restrict format, ...);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_SSCANF_H
diff --git a/src/stdio/ungetc.h b/src/stdio/ungetc.h
index c24d8e5..9e29b2e 100644
--- a/src/stdio/ungetc.h
+++ b/src/stdio/ungetc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDIO_UNGETC_H
 #define LLVM_LIBC_SRC_STDIO_UNGETC_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ungetc(int c, ::FILE *stream);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_UNGETC_H
diff --git a/src/stdio/vasprintf.cpp b/src/stdio/vasprintf.cpp
new file mode 100644
index 0000000..4a44d4a
--- /dev/null
+++ b/src/stdio/vasprintf.cpp
@@ -0,0 +1,24 @@
+//===-- Implementation of vasprintf -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vasprintf.h"
+#include "src/__support/arg_list.h"
+#include "src/stdio/printf_core/vasprintf_internal.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vasprintf,
+                   (char **__restrict ret, const char *__restrict format,
+                    va_list vlist)) {
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  return printf_core::vasprintf_internal(ret, format, args);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vasprintf.h b/src/stdio/vasprintf.h
new file mode 100644
index 0000000..7a98568
--- /dev/null
+++ b/src/stdio/vasprintf.h
@@ -0,0 +1,22 @@
+//===-- Implementation header of vasprintf ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_VASPRINTF_H
+#define LLVM_LIBC_SRC_STDIO_VASPRINTF_H
+
+#include "src/__support/macros/config.h"
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int vasprintf(char **__restrict s, const char *__restrict format,
+              va_list vlist);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_VASPRINTF_H
diff --git a/src/stdio/vfprintf.h b/src/stdio/vfprintf.h
index 01827c5..91418c6 100644
--- a/src/stdio/vfprintf.h
+++ b/src/stdio/vfprintf.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_VFPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_VFPRINTF_H
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int vfprintf(::FILE *__restrict stream, const char *__restrict format,
              va_list vlist);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_VFPRINTF_H
diff --git a/src/stdio/vfscanf.cpp b/src/stdio/vfscanf.cpp
new file mode 100644
index 0000000..2205765
--- /dev/null
+++ b/src/stdio/vfscanf.cpp
@@ -0,0 +1,34 @@
+//===-- Implementation of vfscanf -------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vfscanf.h"
+
+#include "src/__support/File/file.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/vfscanf_internal.h"
+
+#include "hdr/types/FILE.h"
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vfscanf,
+                   (::FILE *__restrict stream, const char *__restrict format,
+                    va_list vlist)) {
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  va_end(vlist);
+  int ret_val = scanf_core::vfscanf_internal(stream, format, args);
+  // This is done to avoid including stdio.h in the internals. On most systems
+  // EOF is -1, so this will be transformed into just "return ret_val".
+  return (ret_val == -1) ? EOF : ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vfscanf.h b/src/stdio/vfscanf.h
new file mode 100644
index 0000000..1a0a12d
--- /dev/null
+++ b/src/stdio/vfscanf.h
@@ -0,0 +1,24 @@
+//===-- Implementation header of vfscanf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_VFSCANF_H
+#define LLVM_LIBC_SRC_STDIO_VFSCANF_H
+
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int vfscanf(::FILE *__restrict stream, const char *__restrict format,
+            va_list vlist);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_VFSCANF_H
diff --git a/src/stdio/vprintf.h b/src/stdio/vprintf.h
index fe4252b..63f0f3a 100644
--- a/src/stdio/vprintf.h
+++ b/src/stdio/vprintf.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_VPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_VPRINTF_H
 
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include <stdarg.h>
-#include <stdio.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int vprintf(const char *__restrict format, va_list vlist);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_VPRINTF_H
diff --git a/src/stdio/vscanf.cpp b/src/stdio/vscanf.cpp
new file mode 100644
index 0000000..64f5cc1
--- /dev/null
+++ b/src/stdio/vscanf.cpp
@@ -0,0 +1,40 @@
+//===-- Implementation of vscanf --------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vscanf.h"
+
+#include "src/__support/File/file.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/vfscanf_internal.h"
+
+#include "hdr/types/FILE.h"
+#include <stdarg.h>
+
+#ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
+#define SCANF_STDIN LIBC_NAMESPACE::stdin
+#else // LIBC_COPT_STDIO_USE_SYSTEM_FILE
+#define SCANF_STDIN ::stdin
+#endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vscanf,
+                   (const char *__restrict format, va_list vlist)) {
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  va_end(vlist);
+  int ret_val = scanf_core::vfscanf_internal(
+      reinterpret_cast<::FILE *>(SCANF_STDIN), format, args);
+  // This is done to avoid including stdio.h in the internals. On most systems
+  // EOF is -1, so this will be transformed into just "return ret_val".
+  return (ret_val == -1) ? EOF : ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vscanf.h b/src/stdio/vscanf.h
new file mode 100644
index 0000000..5c59b91
--- /dev/null
+++ b/src/stdio/vscanf.h
@@ -0,0 +1,23 @@
+//===-- Implementation header of vscanf -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_VSCANF_H
+#define LLVM_LIBC_SRC_STDIO_VSCANF_H
+
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int vscanf(const char *__restrict format, va_list vlist);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_VSCANF_H
diff --git a/src/stdio/vsnprintf.cpp b/src/stdio/vsnprintf.cpp
index 9446d3b..a584c76 100644
--- a/src/stdio/vsnprintf.cpp
+++ b/src/stdio/vsnprintf.cpp
@@ -9,13 +9,14 @@
 #include "src/stdio/vsnprintf.h"
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, vsnprintf,
                    (char *__restrict buffer, size_t buffsz,
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, vsnprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vsnprintf.h b/src/stdio/vsnprintf.h
index 6da25fc..27ae763 100644
--- a/src/stdio/vsnprintf.h
+++ b/src/stdio/vsnprintf.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_STDIO_VSNPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_VSNPRINTF_H
 
+#include "src/__support/macros/config.h"
 #include <stdarg.h>
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int vsnprintf(char *__restrict buffer, size_t buffsz,
               const char *__restrict format, va_list vlist);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_VSNPRINTF_H
diff --git a/src/stdio/vsprintf.cpp b/src/stdio/vsprintf.cpp
index 5ebdf9a..b3978a0 100644
--- a/src/stdio/vsprintf.cpp
+++ b/src/stdio/vsprintf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/printf_main.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stdarg.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, vsprintf,
                    (char *__restrict buffer, const char *__restrict format,
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, vsprintf,
   return ret_val;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vsprintf.h b/src/stdio/vsprintf.h
index fe8def5..abb89ba 100644
--- a/src/stdio/vsprintf.h
+++ b/src/stdio/vsprintf.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDIO_VSPRINTF_H
 #define LLVM_LIBC_SRC_STDIO_VSPRINTF_H
 
+#include "src/__support/macros/config.h"
 #include <stdarg.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int vsprintf(char *__restrict buffer, const char *__restrict format,
              va_list vlist);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDIO_VSPRINTF_H
diff --git a/src/stdio/vsscanf.cpp b/src/stdio/vsscanf.cpp
new file mode 100644
index 0000000..f3f56bc
--- /dev/null
+++ b/src/stdio/vsscanf.cpp
@@ -0,0 +1,33 @@
+//===-- Implementation of vsscanf -------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vsscanf.h"
+
+#include "hdr/stdio_macros.h"
+#include "src/__support/CPP/limits.h"
+#include "src/__support/arg_list.h"
+#include "src/stdio/scanf_core/reader.h"
+#include "src/stdio/scanf_core/scanf_main.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vsscanf,
+                   (const char *buffer, const char *format, va_list vlist)) {
+  internal::ArgList args(vlist);
+  scanf_core::ReadBuffer rb{const_cast<char *>(buffer),
+                            cpp::numeric_limits<size_t>::max()};
+  scanf_core::Reader reader(&rb);
+  int ret_val = scanf_core::scanf_main(&reader, format, args);
+  // This is done to avoid including stdio.h in the internals. On most systems
+  // EOF is -1, so this will be transformed into just "return ret_val".
+  return (ret_val == -1) ? EOF : ret_val;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/vsscanf.h b/src/stdio/vsscanf.h
new file mode 100644
index 0000000..c57b174
--- /dev/null
+++ b/src/stdio/vsscanf.h
@@ -0,0 +1,22 @@
+//===-- Implementation header of vsscanf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_VSSCANF_H
+#define LLVM_LIBC_SRC_STDIO_VSSCANF_H
+
+#include "src/__support/macros/config.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int vsscanf(const char *s, const char *format, va_list vlist);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_VSSCANF_H
diff --git a/src/stdlib/_Exit.cpp b/src/stdlib/_Exit.cpp
index 03a7662..859598c 100644
--- a/src/stdlib/_Exit.cpp
+++ b/src/stdlib/_Exit.cpp
@@ -8,13 +8,14 @@
 
 #include "src/__support/OSUtil/exit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include "src/stdlib/_Exit.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] LLVM_LIBC_FUNCTION(void, _Exit, (int status)) {
   internal::exit(status);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/_Exit.h b/src/stdlib/_Exit.h
index bc05faf..398ab53 100644
--- a/src/stdlib/_Exit.h
+++ b/src/stdlib/_Exit.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB__EXIT_H
 #define LLVM_LIBC_SRC_STDLIB__EXIT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void _Exit(int status);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB__EXIT_H
diff --git a/src/stdlib/abort.h b/src/stdlib/abort.h
index d3bf1e9..2bb292b 100644
--- a/src/stdlib/abort.h
+++ b/src/stdlib/abort.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ABORT_H
 #define LLVM_LIBC_SRC_STDLIB_ABORT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void abort();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ABORT_H
diff --git a/src/stdlib/abs.cpp b/src/stdlib/abs.cpp
index 6be63e0..688c504 100644
--- a/src/stdlib/abs.cpp
+++ b/src/stdlib/abs.cpp
@@ -9,9 +9,10 @@
 #include "src/stdlib/abs.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, abs, (int n)) { return integer_abs(n); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/abs.h b/src/stdlib/abs.h
index 19cef14..56ab04b 100644
--- a/src/stdlib/abs.h
+++ b/src/stdlib/abs.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ABS_H
 #define LLVM_LIBC_SRC_STDLIB_ABS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int abs(int n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ABS_H
diff --git a/src/stdlib/aligned_alloc.h b/src/stdlib/aligned_alloc.h
new file mode 100644
index 0000000..0205c02
--- /dev/null
+++ b/src/stdlib/aligned_alloc.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for aligned_alloc -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
+#include <stddef.h>
+
+#ifndef LLVM_LIBC_SRC_STDLIB_ALIGNED_ALLOC_H
+#define LLVM_LIBC_SRC_STDLIB_ALIGNED_ALLOC_H
+
+namespace LIBC_NAMESPACE_DECL {
+
+void *aligned_alloc(size_t alignment, size_t size);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_ALIGNED_ALLOC_H
diff --git a/src/stdlib/at_quick_exit.cpp b/src/stdlib/at_quick_exit.cpp
index 752d67e..d2b4c0c 100644
--- a/src/stdlib/at_quick_exit.cpp
+++ b/src/stdlib/at_quick_exit.cpp
@@ -9,9 +9,12 @@
 #include "src/stdlib/at_quick_exit.h"
 #include "hdr/types/atexithandler_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/exit_handler.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
+
+constinit ExitCallbackList at_quick_exit_callbacks;
 
 LLVM_LIBC_FUNCTION(int, at_quick_exit, (__atexithandler_t callback)) {
   return add_atexit_unit(
@@ -19,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, at_quick_exit, (__atexithandler_t callback)) {
       {&stdc_at_exit_func, reinterpret_cast<void *>(callback)});
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/at_quick_exit.h b/src/stdlib/at_quick_exit.h
index c36c797..0bfd4ff 100644
--- a/src/stdlib/at_quick_exit.h
+++ b/src/stdlib/at_quick_exit.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STDLIB_AT_QUICK_EXIT_H
 
 #include "hdr/types/atexithandler_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int at_quick_exit(__atexithandler_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_AT_QUICK_EXIT_H
diff --git a/src/stdlib/atexit.cpp b/src/stdlib/atexit.cpp
index ca3cbfe..799aad1 100644
--- a/src/stdlib/atexit.cpp
+++ b/src/stdlib/atexit.cpp
@@ -9,9 +9,14 @@
 #include "src/stdlib/atexit.h"
 #include "hdr/types/atexithandler_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/exit_handler.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
+
+constinit ExitCallbackList atexit_callbacks;
+Mutex handler_list_mtx(false, false, false, false);
+[[gnu::weak]] extern void teardown_main_tls();
 
 extern "C" {
 
@@ -20,8 +25,11 @@ int __cxa_atexit(AtExitCallback *callback, void *payload, void *) {
 }
 
 void __cxa_finalize(void *dso) {
-  if (!dso)
+  if (!dso) {
     call_exit_callbacks(atexit_callbacks);
+    if (teardown_main_tls)
+      teardown_main_tls();
+  }
 }
 
 } // extern "C"
@@ -32,4 +40,4 @@ LLVM_LIBC_FUNCTION(int, atexit, (__atexithandler_t callback)) {
       {&stdc_at_exit_func, reinterpret_cast<void *>(callback)});
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/atexit.h b/src/stdlib/atexit.h
index 7faaf65..39ce2dc 100644
--- a/src/stdlib/atexit.h
+++ b/src/stdlib/atexit.h
@@ -10,10 +10,12 @@
 #define LLVM_LIBC_SRC_STDLIB_ATEXIT_H
 
 #include "hdr/types/atexithandler_t.h"
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int atexit(__atexithandler_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ATEXIT_H
diff --git a/src/stdlib/atof.cpp b/src/stdlib/atof.cpp
index 61eb7db..18a65c6 100644
--- a/src/stdlib/atof.cpp
+++ b/src/stdlib/atof.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/atof.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, atof, (const char *str)) {
   auto result = internal::strtofloatingpoint<double>(str);
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(double, atof, (const char *str)) {
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/atof.h b/src/stdlib/atof.h
index cc9ae51..dfa97c3 100644
--- a/src/stdlib/atof.h
+++ b/src/stdlib/atof.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ATOF_H
 #define LLVM_LIBC_SRC_STDLIB_ATOF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double atof(const char *str);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ATOF_H
diff --git a/src/stdlib/atoi.cpp b/src/stdlib/atoi.cpp
index d1dc320..9e46b53 100644
--- a/src/stdlib/atoi.cpp
+++ b/src/stdlib/atoi.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/atoi.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, atoi, (const char *str)) {
   // This is done because the standard specifies that atoi is identical to
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, atoi, (const char *str)) {
   return static_cast<int>(result);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/atoi.h b/src/stdlib/atoi.h
index fb5de31..218c051 100644
--- a/src/stdlib/atoi.h
+++ b/src/stdlib/atoi.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ATOI_H
 #define LLVM_LIBC_SRC_STDLIB_ATOI_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int atoi(const char *str);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ATOI_H
diff --git a/src/stdlib/atol.cpp b/src/stdlib/atol.cpp
index 5586db7..7f3414a 100644
--- a/src/stdlib/atol.cpp
+++ b/src/stdlib/atol.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/atol.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, atol, (const char *str)) {
   auto result = internal::strtointeger<long>(str, 10);
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(long, atol, (const char *str)) {
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/atol.h b/src/stdlib/atol.h
index 690731f..3787dc1 100644
--- a/src/stdlib/atol.h
+++ b/src/stdlib/atol.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ATOL_H
 #define LLVM_LIBC_SRC_STDLIB_ATOL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long atol(const char *str);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ATOL_H
diff --git a/src/stdlib/atoll.cpp b/src/stdlib/atoll.cpp
index 921459d..4f1a02a 100644
--- a/src/stdlib/atoll.cpp
+++ b/src/stdlib/atoll.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/atoll.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, atoll, (const char *str)) {
   auto result = internal::strtointeger<long long>(str, 10);
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(long long, atoll, (const char *str)) {
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/atoll.h b/src/stdlib/atoll.h
index 4746eb1..b3035fd 100644
--- a/src/stdlib/atoll.h
+++ b/src/stdlib/atoll.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_ATOLL_H
 #define LLVM_LIBC_SRC_STDLIB_ATOLL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long atoll(const char *str);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_ATOLL_H
diff --git a/src/stdlib/baremetal/abort.cpp b/src/stdlib/baremetal/abort.cpp
index 4dd8536..98cf710 100644
--- a/src/stdlib/baremetal/abort.cpp
+++ b/src/stdlib/baremetal/abort.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include "src/stdlib/abort.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, abort, ()) { __builtin_trap(); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/bsearch.cpp b/src/stdlib/bsearch.cpp
index 4292d6b..69b3e74 100644
--- a/src/stdlib/bsearch.cpp
+++ b/src/stdlib/bsearch.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/bsearch.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, bsearch,
                    (const void *key, const void *array, size_t array_size,
@@ -44,4 +45,4 @@ LLVM_LIBC_FUNCTION(void *, bsearch,
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/bsearch.h b/src/stdlib/bsearch.h
index 3590198..cef37ea 100644
--- a/src/stdlib/bsearch.h
+++ b/src/stdlib/bsearch.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_BSEARCH_H
 #define LLVM_LIBC_SRC_STDLIB_BSEARCH_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *bsearch(const void *key, const void *array, size_t array_size,
               size_t elem_size, int (*compare)(const void *, const void *));
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //LLVM_LIBC_SRC_STDLIB_BSEARCH_H
diff --git a/src/stdlib/calloc.h b/src/stdlib/calloc.h
index bdb025b..a8cf734 100644
--- a/src/stdlib/calloc.h
+++ b/src/stdlib/calloc.h
@@ -6,15 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
 #ifndef LLVM_LIBC_SRC_STDLIB_CALLOC_H
 #define LLVM_LIBC_SRC_STDLIB_CALLOC_H
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *calloc(size_t num, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_CALLOC_H
diff --git a/src/stdlib/div.cpp b/src/stdlib/div.cpp
index ee7c335..766e8ae 100644
--- a/src/stdlib/div.cpp
+++ b/src/stdlib/div.cpp
@@ -9,8 +9,9 @@
 #include "src/stdlib/div.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(div_t, div, (int x, int y)) {
   div_t res;
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(div_t, div, (int x, int y)) {
   return res;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/div.h b/src/stdlib/div.h
index 3a6853f..4917ac1 100644
--- a/src/stdlib/div.h
+++ b/src/stdlib/div.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_DIV_H
 #define LLVM_LIBC_SRC_STDLIB_DIV_H
 
-#include <stdlib.h>
+#include "hdr/types/div_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 div_t div(int x, int y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_DIV_H
diff --git a/src/stdlib/exit.cpp b/src/stdlib/exit.cpp
index 1f7ccbb..28a6f8a 100644
--- a/src/stdlib/exit.cpp
+++ b/src/stdlib/exit.cpp
@@ -9,14 +9,15 @@
 #include "src/stdlib/exit.h"
 #include "src/__support/OSUtil/exit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-extern "C" void __cxa_finalize(void *);
+namespace LIBC_NAMESPACE_DECL {
 
-namespace LIBC_NAMESPACE {
+extern "C" void __cxa_finalize(void *);
 
 [[noreturn]] LLVM_LIBC_FUNCTION(void, exit, (int status)) {
   __cxa_finalize(nullptr);
   internal::exit(status);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/exit.h b/src/stdlib/exit.h
index b135735..3c9d37a 100644
--- a/src/stdlib/exit.h
+++ b/src/stdlib/exit.h
@@ -9,12 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_EXIT_H
 #define LLVM_LIBC_SRC_STDLIB_EXIT_H
 
-#include <stdlib.h>
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void exit(int status);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_EXIT_H
diff --git a/src/stdlib/exit_handler.cpp b/src/stdlib/exit_handler.cpp
deleted file mode 100644
index ed41247..0000000
--- a/src/stdlib/exit_handler.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-//===--- Implementation of exit_handler------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdlib/exit_handler.h"
-#include "src/__support/CPP/mutex.h" // lock_guard
-
-namespace LIBC_NAMESPACE {
-
-constinit ExitCallbackList at_quick_exit_callbacks;
-constinit ExitCallbackList atexit_callbacks;
-
-Mutex handler_list_mtx(false, false, false, false);
-
-void stdc_at_exit_func(void *payload) {
-  reinterpret_cast<StdCAtExitCallback *>(payload)();
-}
-
-void call_exit_callbacks(ExitCallbackList &callbacks) {
-  handler_list_mtx.lock();
-  while (!callbacks.empty()) {
-    AtExitUnit &unit = callbacks.back();
-    callbacks.pop_back();
-    handler_list_mtx.unlock();
-    unit.callback(unit.payload);
-    handler_list_mtx.lock();
-  }
-  ExitCallbackList::destroy(&callbacks);
-}
-
-int add_atexit_unit(ExitCallbackList &callbacks, const AtExitUnit &unit) {
-  cpp::lock_guard lock(handler_list_mtx);
-  if (callbacks.push_back(unit))
-    return 0;
-  return -1;
-}
-
-} // namespace LIBC_NAMESPACE
diff --git a/src/stdlib/exit_handler.h b/src/stdlib/exit_handler.h
index 8494c2f..9720c54 100644
--- a/src/stdlib/exit_handler.h
+++ b/src/stdlib/exit_handler.h
@@ -13,9 +13,10 @@
 #include "src/__support/blockstore.h"
 #include "src/__support/common.h"
 #include "src/__support/fixedvector.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using AtExitCallback = void(void *);
 using StdCAtExitCallback = void(void);
@@ -37,17 +38,33 @@ using ExitCallbackList = ReverseOrderBlockStore<AtExitUnit, 32>;
 using ExitCallbackList = FixedVector<AtExitUnit, CALLBACK_LIST_SIZE_FOR_TESTS>;
 #endif
 
-extern ExitCallbackList atexit_callbacks;
-extern ExitCallbackList at_quick_exit_callbacks;
-
+// This is handled by the 'atexit' implementation and shared by 'at_quick_exit'.
 extern Mutex handler_list_mtx;
 
-void stdc_at_exit_func(void *payload);
+LIBC_INLINE void stdc_at_exit_func(void *payload) {
+  reinterpret_cast<StdCAtExitCallback *>(payload)();
+}
 
-void call_exit_callbacks(ExitCallbackList &callbacks);
+LIBC_INLINE void call_exit_callbacks(ExitCallbackList &callbacks) {
+  handler_list_mtx.lock();
+  while (!callbacks.empty()) {
+    AtExitUnit &unit = callbacks.back();
+    callbacks.pop_back();
+    handler_list_mtx.unlock();
+    unit.callback(unit.payload);
+    handler_list_mtx.lock();
+  }
+  ExitCallbackList::destroy(&callbacks);
+}
 
-int add_atexit_unit(ExitCallbackList &callbacks, const AtExitUnit &unit);
+LIBC_INLINE int add_atexit_unit(ExitCallbackList &callbacks,
+                                const AtExitUnit &unit) {
+  cpp::lock_guard lock(handler_list_mtx);
+  if (callbacks.push_back(unit))
+    return 0;
+  return -1;
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_EXIT_HANDLER_H
diff --git a/src/stdlib/free.h b/src/stdlib/free.h
index b3970fd..77d00a5 100644
--- a/src/stdlib/free.h
+++ b/src/stdlib/free.h
@@ -6,15 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdlib.h>
+#include "src/__support/macros/config.h"
 
 #ifndef LLVM_LIBC_SRC_STDLIB_FREE_H
 #define LLVM_LIBC_SRC_STDLIB_FREE_H
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void free(void *ptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_FREE_H
diff --git a/src/stdlib/freelist_malloc.cpp b/src/stdlib/freelist_malloc.cpp
index 4d3c42c..fe56fad 100644
--- a/src/stdlib/freelist_malloc.cpp
+++ b/src/stdlib/freelist_malloc.cpp
@@ -7,6 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+#include "src/stdlib/aligned_alloc.h"
 #include "src/stdlib/calloc.h"
 #include "src/stdlib/free.h"
 #include "src/stdlib/malloc.h"
@@ -14,19 +16,10 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-namespace {
-#ifdef LIBC_FREELIST_MALLOC_SIZE
-// This is set via the LIBC_CONF_FREELIST_MALLOC_BUFFER_SIZE configuration.
-constexpr size_t SIZE = LIBC_FREELIST_MALLOC_SIZE;
-#else
-#error "LIBC_FREELIST_MALLOC_SIZE was not defined for this build."
-#endif
-LIBC_CONSTINIT FreeListHeapBuffer<SIZE> freelist_heap_buffer;
-} // namespace
-
-FreeListHeap<> *freelist_heap = &freelist_heap_buffer;
+static LIBC_CONSTINIT FreeListHeap freelist_heap_symbols;
+FreeListHeap *freelist_heap = &freelist_heap_symbols;
 
 LLVM_LIBC_FUNCTION(void *, malloc, (size_t size)) {
   return freelist_heap->allocate(size);
@@ -42,4 +35,8 @@ LLVM_LIBC_FUNCTION(void *, realloc, (void *ptr, size_t size)) {
   return freelist_heap->realloc(ptr, size);
 }
 
-} // namespace LIBC_NAMESPACE
+LLVM_LIBC_FUNCTION(void *, aligned_alloc, (size_t alignment, size_t size)) {
+  return freelist_heap->aligned_allocate(alignment, size);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/getenv.cpp b/src/stdlib/getenv.cpp
index 7a8eb19..e6ef03f 100644
--- a/src/stdlib/getenv.cpp
+++ b/src/stdlib/getenv.cpp
@@ -7,13 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdlib/getenv.h"
-#include "config/linux/app.h"
+#include "config/app.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, getenv, (const char *name)) {
   char **env_ptr = reinterpret_cast<char **>(LIBC_NAMESPACE::app.env_ptr);
@@ -41,4 +42,4 @@ LLVM_LIBC_FUNCTION(char *, getenv, (const char *name)) {
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/getenv.h b/src/stdlib/getenv.h
index adb386b..a5d41fe 100644
--- a/src/stdlib/getenv.h
+++ b/src/stdlib/getenv.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_GETENV_H
 #define LLVM_LIBC_SRC_STDLIB_GETENV_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *getenv(const char *name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_GETENV_H
diff --git a/src/stdlib/gpu/abort.cpp b/src/stdlib/gpu/abort.cpp
index f3b052b..3a06fb3 100644
--- a/src/stdlib/gpu/abort.cpp
+++ b/src/stdlib/gpu/abort.cpp
@@ -6,21 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/GPU/utils.h"
 #include "src/__support/RPC/rpc_client.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include "src/stdlib/abort.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, abort, ()) {
   // We want to first make sure the server is listening before we abort.
   rpc::Client::Port port = rpc::client.open<RPC_ABORT>();
-  port.send_and_recv([](rpc::Buffer *) {}, [](rpc::Buffer *) {});
-  port.send([&](rpc::Buffer *) {});
+  port.send_and_recv([](rpc::Buffer *, uint32_t) {},
+                     [](rpc::Buffer *, uint32_t) {});
+  port.send([&](rpc::Buffer *, uint32_t) {});
   port.close();
 
   gpu::end_program();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/aligned_alloc.cpp b/src/stdlib/gpu/aligned_alloc.cpp
new file mode 100644
index 0000000..cd2c7e5
--- /dev/null
+++ b/src/stdlib/gpu/aligned_alloc.cpp
@@ -0,0 +1,29 @@
+//===-- GPU Implementation of aligned_alloc -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/aligned_alloc.h"
+
+#include "src/__support/GPU/allocator.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, aligned_alloc, (size_t alignment, size_t size)) {
+  if ((alignment & -alignment) != alignment)
+    return nullptr;
+
+  void *ptr = gpu::allocate(size);
+  if ((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) != 0) {
+    gpu::deallocate(ptr);
+    return nullptr;
+  }
+  return ptr;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/calloc.cpp b/src/stdlib/gpu/calloc.cpp
new file mode 100644
index 0000000..9150aff
--- /dev/null
+++ b/src/stdlib/gpu/calloc.cpp
@@ -0,0 +1,31 @@
+//===-- GPU Implementation of calloc --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/calloc.h"
+
+#include "src/__support/GPU/allocator.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_memset.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, calloc, (size_t num, size_t size)) {
+  size_t bytes = num * size;
+  if (bytes == 0)
+    return nullptr;
+
+  void *ptr = gpu::allocate(bytes);
+  if (!ptr)
+    return nullptr;
+
+  inline_memset(ptr, 0, bytes);
+  return ptr;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/free.cpp b/src/stdlib/gpu/free.cpp
index fb5703b..1f0e9ec 100644
--- a/src/stdlib/gpu/free.cpp
+++ b/src/stdlib/gpu/free.cpp
@@ -10,9 +10,10 @@
 
 #include "src/__support/GPU/allocator.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, free, (void *ptr)) { gpu::deallocate(ptr); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/malloc.cpp b/src/stdlib/gpu/malloc.cpp
index 9355823..54f2d88 100644
--- a/src/stdlib/gpu/malloc.cpp
+++ b/src/stdlib/gpu/malloc.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/GPU/allocator.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, malloc, (size_t size)) {
   return gpu::allocate(size);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/realloc.cpp b/src/stdlib/gpu/realloc.cpp
new file mode 100644
index 0000000..4fd4d6b
--- /dev/null
+++ b/src/stdlib/gpu/realloc.cpp
@@ -0,0 +1,32 @@
+//===-- GPU Implementation of realloc -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/realloc.h"
+
+#include "src/__support/GPU/allocator.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_memcpy.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, realloc, (void *ptr, size_t size)) {
+  if (ptr == nullptr)
+    return gpu::allocate(size);
+
+  void *newmem = gpu::allocate(size);
+  if (newmem == nullptr)
+    return nullptr;
+
+  // This will copy garbage if it goes beyond the old allocation size.
+  inline_memcpy(newmem, ptr, size);
+  gpu::deallocate(ptr);
+  return newmem;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/system.cpp b/src/stdlib/gpu/system.cpp
new file mode 100644
index 0000000..1890006
--- /dev/null
+++ b/src/stdlib/gpu/system.cpp
@@ -0,0 +1,30 @@
+//===-- GPU implementation of system --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/RPC/rpc_client.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/string/string_utils.h"
+
+#include "src/stdlib/system.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, system, (const char *command)) {
+  int ret;
+  rpc::Client::Port port = rpc::client.open<RPC_SYSTEM>();
+  port.send_n(command, internal::string_length(command) + 1);
+  port.recv([&](rpc::Buffer *buffer, uint32_t) {
+    ret = static_cast<int>(buffer->data[0]);
+  });
+  port.close();
+
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/heap_sort.h b/src/stdlib/heap_sort.h
new file mode 100644
index 0000000..ccb9ec5
--- /dev/null
+++ b/src/stdlib/heap_sort.h
@@ -0,0 +1,61 @@
+//===-- Implementation of heap sort -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_HEAP_SORT_H
+#define LLVM_LIBC_SRC_STDLIB_HEAP_SORT_H
+
+#include "src/__support/CPP/cstddef.h"
+#include "src/stdlib/qsort_data.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+// A simple in-place heapsort implementation.
+// Follow the implementation in https://en.wikipedia.org/wiki/Heapsort.
+
+LIBC_INLINE void heap_sort(const Array &array) {
+  size_t end = array.size();
+  size_t start = end / 2;
+
+  auto left_child = [](size_t i) -> size_t { return 2 * i + 1; };
+
+  while (end > 1) {
+    if (start > 0) {
+      // Select the next unheapified element to sift down.
+      --start;
+    } else {
+      // Extract the max element of the heap, moving a leaf to root to be sifted
+      // down.
+      --end;
+      array.swap(0, end);
+    }
+
+    // Sift start down the heap.
+    size_t root = start;
+    while (left_child(root) < end) {
+      size_t child = left_child(root);
+      // If there are two children, set child to the greater.
+      if (child + 1 < end &&
+          array.elem_compare(child, array.get(child + 1)) < 0)
+        ++child;
+
+      // If the root is less than the greater child
+      if (array.elem_compare(root, array.get(child)) >= 0)
+        break;
+
+      // Swap the root with the greater child and continue sifting down.
+      array.swap(root, child);
+      root = child;
+    }
+  }
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_HEAP_SORT_H
diff --git a/src/stdlib/labs.cpp b/src/stdlib/labs.cpp
index d9237fa..a8265e4 100644
--- a/src/stdlib/labs.cpp
+++ b/src/stdlib/labs.cpp
@@ -9,9 +9,10 @@
 #include "src/stdlib/labs.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, labs, (long n)) { return integer_abs(n); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/labs.h b/src/stdlib/labs.h
index b7af538..c15af79 100644
--- a/src/stdlib/labs.h
+++ b/src/stdlib/labs.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_LABS_H
 #define LLVM_LIBC_SRC_STDLIB_LABS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long labs(long n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_LABS_H
diff --git a/src/stdlib/ldiv.cpp b/src/stdlib/ldiv.cpp
index 57e2250..94f385f 100644
--- a/src/stdlib/ldiv.cpp
+++ b/src/stdlib/ldiv.cpp
@@ -9,8 +9,9 @@
 #include "src/stdlib/ldiv.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ldiv_t, ldiv, (long x, long y)) {
   ldiv_t res;
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(ldiv_t, ldiv, (long x, long y)) {
   return res;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/ldiv.h b/src/stdlib/ldiv.h
index 0f0fafa..b6b7997 100644
--- a/src/stdlib/ldiv.h
+++ b/src/stdlib/ldiv.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_LDIV_H
 #define LLVM_LIBC_SRC_STDLIB_LDIV_H
 
-#include <stdlib.h>
+#include "hdr/types/ldiv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ldiv_t ldiv(long x, long y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_LDIV_H
diff --git a/src/stdlib/linux/abort.cpp b/src/stdlib/linux/abort.cpp
index 59feec3..d78ea67 100644
--- a/src/stdlib/linux/abort.cpp
+++ b/src/stdlib/linux/abort.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/signal/raise.h"
 #include "src/stdlib/_Exit.h"
 
 #include "src/stdlib/abort.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, abort, ()) {
   // TODO: When sigprocmask and sigaction land:
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(void, abort, ()) {
   LIBC_NAMESPACE::_Exit(127);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/llabs.cpp b/src/stdlib/llabs.cpp
index f42c2b8..09636f1 100644
--- a/src/stdlib/llabs.cpp
+++ b/src/stdlib/llabs.cpp
@@ -9,9 +9,10 @@
 #include "src/stdlib/llabs.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, llabs, (long long n)) { return integer_abs(n); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/llabs.h b/src/stdlib/llabs.h
index 953fe17..b0cabdd 100644
--- a/src/stdlib/llabs.h
+++ b/src/stdlib/llabs.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_LLABS_H
 #define LLVM_LIBC_SRC_STDLIB_LLABS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long llabs(long long n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_LLABS_H
diff --git a/src/stdlib/lldiv.cpp b/src/stdlib/lldiv.cpp
index ff2fdf8..f55a4f6 100644
--- a/src/stdlib/lldiv.cpp
+++ b/src/stdlib/lldiv.cpp
@@ -9,8 +9,9 @@
 #include "src/stdlib/lldiv.h"
 #include "src/__support/common.h"
 #include "src/__support/integer_operations.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(lldiv_t, lldiv, (long long x, long long y)) {
   lldiv_t res;
@@ -18,4 +19,4 @@ LLVM_LIBC_FUNCTION(lldiv_t, lldiv, (long long x, long long y)) {
   return res;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/lldiv.h b/src/stdlib/lldiv.h
index ee7f4d3..9c48991 100644
--- a/src/stdlib/lldiv.h
+++ b/src/stdlib/lldiv.h
@@ -8,12 +8,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_LLDIV_H
 #define LLVM_LIBC_SRC_STDLIB_LLDIV_H
 
-#include <stdlib.h>
+#include "hdr/types/lldiv_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 lldiv_t lldiv(long long x, long long y);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_LLDIV_H
diff --git a/src/stdlib/malloc.h b/src/stdlib/malloc.h
index 514e2b1..074df25 100644
--- a/src/stdlib/malloc.h
+++ b/src/stdlib/malloc.h
@@ -6,15 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
+#include "src/__support/macros/config.h"
 
 #ifndef LLVM_LIBC_SRC_STDLIB_MALLOC_H
 #define LLVM_LIBC_SRC_STDLIB_MALLOC_H
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *malloc(size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_MALLOC_H
diff --git a/src/stdlib/qsort.cpp b/src/stdlib/qsort.cpp
index f040f37..65a63c2 100644
--- a/src/stdlib/qsort.cpp
+++ b/src/stdlib/qsort.cpp
@@ -8,11 +8,12 @@
 
 #include "src/stdlib/qsort.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/qsort_util.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, qsort,
                    (void *array, size_t array_size, size_t elem_size,
@@ -20,8 +21,11 @@ LLVM_LIBC_FUNCTION(void, qsort,
   if (array == nullptr || array_size == 0 || elem_size == 0)
     return;
   internal::Comparator c(compare);
-  internal::quicksort(internal::Array(reinterpret_cast<uint8_t *>(array),
-                                      array_size, elem_size, c));
+
+  auto arr = internal::Array(reinterpret_cast<uint8_t *>(array), array_size,
+                             elem_size, c);
+
+  internal::sort(arr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/qsort.h b/src/stdlib/qsort.h
index 5c78481..2060584 100644
--- a/src/stdlib/qsort.h
+++ b/src/stdlib/qsort.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_QSORT_H
 #define LLVM_LIBC_SRC_STDLIB_QSORT_H
 
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void qsort(void *array, size_t array_size, size_t elem_size,
            int (*compare)(const void *, const void *));
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_QSORT_H
diff --git a/src/stdlib/qsort_data.h b/src/stdlib/qsort_data.h
new file mode 100644
index 0000000..c529d55
--- /dev/null
+++ b/src/stdlib/qsort_data.h
@@ -0,0 +1,108 @@
+//===-- Data structures for sorting routines --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_QSORT_DATA_H
+#define LLVM_LIBC_SRC_STDLIB_QSORT_DATA_H
+
+#include "src/__support/CPP/cstddef.h"
+#include "src/__support/macros/config.h"
+
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+using Compare = int(const void *, const void *);
+using CompareWithState = int(const void *, const void *, void *);
+
+enum class CompType { COMPARE, COMPARE_WITH_STATE };
+
+struct Comparator {
+  union {
+    Compare *comp_func;
+    CompareWithState *comp_func_r;
+  };
+  const CompType comp_type;
+
+  void *arg;
+
+  Comparator(Compare *func)
+      : comp_func(func), comp_type(CompType::COMPARE), arg(nullptr) {}
+
+  Comparator(CompareWithState *func, void *arg_val)
+      : comp_func_r(func), comp_type(CompType::COMPARE_WITH_STATE),
+        arg(arg_val) {}
+
+#if defined(__clang__)
+  // Recent upstream changes to -fsanitize=function find more instances of
+  // function type mismatches. One case is with the comparator passed to this
+  // class. Libraries will tend to pass comparators that take pointers to
+  // varying types while this comparator expects to accept const void pointers.
+  // Ideally those tools would pass a function that strictly accepts const
+  // void*s to avoid UB, or would use qsort_r to pass their own comparator.
+  [[clang::no_sanitize("function")]]
+#endif
+  int comp_vals(const void *a, const void *b) const {
+    if (comp_type == CompType::COMPARE) {
+      return comp_func(a, b);
+    } else {
+      return comp_func_r(a, b, arg);
+    }
+  }
+};
+
+class Array {
+  uint8_t *array;
+  size_t array_size;
+  size_t elem_size;
+  Comparator compare;
+
+public:
+  Array(uint8_t *a, size_t s, size_t e, Comparator c)
+      : array(a), array_size(s), elem_size(e), compare(c) {}
+
+  uint8_t *get(size_t i) const { return array + i * elem_size; }
+
+  void swap(size_t i, size_t j) const {
+    uint8_t *elem_i = get(i);
+    uint8_t *elem_j = get(j);
+    for (size_t b = 0; b < elem_size; ++b) {
+      uint8_t temp = elem_i[b];
+      elem_i[b] = elem_j[b];
+      elem_j[b] = temp;
+    }
+  }
+
+  int elem_compare(size_t i, const uint8_t *other) const {
+    // An element must compare equal to itself so we don't need to consult the
+    // user provided comparator.
+    if (get(i) == other)
+      return 0;
+    return compare.comp_vals(get(i), other);
+  }
+
+  size_t size() const { return array_size; }
+
+  // Make an Array starting at index |i| and size |s|.
+  LIBC_INLINE Array make_array(size_t i, size_t s) const {
+    return Array(get(i), s, elem_size, compare);
+  }
+
+  // Reset this Array to point at a different interval of the same items.
+  LIBC_INLINE void reset_bounds(uint8_t *a, size_t s) {
+    array = a;
+    array_size = s;
+  }
+};
+
+using SortingRoutine = void(const Array &);
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_QSORT_DATA_H
diff --git a/src/stdlib/qsort_r.cpp b/src/stdlib/qsort_r.cpp
index 7589918..bf61a40 100644
--- a/src/stdlib/qsort_r.cpp
+++ b/src/stdlib/qsort_r.cpp
@@ -8,11 +8,12 @@
 
 #include "src/stdlib/qsort_r.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/qsort_util.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, qsort_r,
                    (void *array, size_t array_size, size_t elem_size,
@@ -21,8 +22,10 @@ LLVM_LIBC_FUNCTION(void, qsort_r,
   if (array == nullptr || array_size == 0 || elem_size == 0)
     return;
   internal::Comparator c(compare, arg);
-  internal::quicksort(internal::Array(reinterpret_cast<uint8_t *>(array),
-                                      array_size, elem_size, c));
+  auto arr = internal::Array(reinterpret_cast<uint8_t *>(array), array_size,
+                             elem_size, c);
+
+  internal::sort(arr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/qsort_r.h b/src/stdlib/qsort_r.h
index fab0576..51a459c 100644
--- a/src/stdlib/qsort_r.h
+++ b/src/stdlib/qsort_r.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_QSORT_R_H
 #define LLVM_LIBC_SRC_STDLIB_QSORT_R_H
 
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This qsort_r uses the glibc argument ordering instead of the BSD argument
 // ordering (which puts arg before the function pointer). Putting arg after the
@@ -21,6 +22,6 @@ namespace LIBC_NAMESPACE {
 void qsort_r(void *array, size_t array_size, size_t elem_size,
              int (*compare)(const void *, const void *, void *), void *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_QSORT_R_H
diff --git a/src/stdlib/qsort_util.h b/src/stdlib/qsort_util.h
index f4b8094..d42adde 100644
--- a/src/stdlib/qsort_util.h
+++ b/src/stdlib/qsort_util.h
@@ -9,144 +9,31 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_QSORT_UTIL_H
 #define LLVM_LIBC_SRC_STDLIB_QSORT_UTIL_H
 
-#include "src/__support/macros/attributes.h"
-#include <stdint.h>
-#include <stdlib.h>
+#include "src/stdlib/heap_sort.h"
+#include "src/stdlib/quick_sort.h"
 
-namespace LIBC_NAMESPACE::internal {
+#define LIBC_QSORT_QUICK_SORT 1
+#define LIBC_QSORT_HEAP_SORT 2
 
-// A simple quicksort implementation using the Hoare partition scheme.
+#ifndef LIBC_QSORT_IMPL
+#define LIBC_QSORT_IMPL LIBC_QSORT_QUICK_SORT
+#endif // LIBC_QSORT_IMPL
 
-using Compare = int(const void *, const void *);
-using CompareWithState = int(const void *, const void *, void *);
-
-enum class CompType { COMPARE, COMPARE_WITH_STATE };
-
-struct Comparator {
-  union {
-    Compare *comp_func;
-    CompareWithState *comp_func_r;
-  };
-  const CompType comp_type;
-
-  void *arg;
-
-  Comparator(Compare *func)
-      : comp_func(func), comp_type(CompType::COMPARE), arg(nullptr) {}
-
-  Comparator(CompareWithState *func, void *arg_val)
-      : comp_func_r(func), comp_type(CompType::COMPARE_WITH_STATE),
-        arg(arg_val) {}
-
-#if defined(__clang__)
-  // Recent upstream changes to -fsanitize=function find more instances of
-  // function type mismatches. One case is with the comparator passed to this
-  // class. Libraries will tend to pass comparators that take pointers to
-  // varying types while this comparator expects to accept const void pointers.
-  // Ideally those tools would pass a function that strictly accepts const
-  // void*s to avoid UB, or would use qsort_r to pass their own comparator.
-  [[clang::no_sanitize("function")]]
+#if (LIBC_QSORT_IMPL != LIBC_QSORT_QUICK_SORT &&                               \
+     LIBC_QSORT_IMPL != LIBC_QSORT_HEAP_SORT)
+#error "LIBC_QSORT_IMPL is not recognized."
 #endif
-  int comp_vals(const void *a, const void *b) const {
-    if (comp_type == CompType::COMPARE) {
-      return comp_func(a, b);
-    } else {
-      return comp_func_r(a, b, arg);
-    }
-  }
-};
-
-class Array {
-  uint8_t *array;
-  size_t array_size;
-  size_t elem_size;
-  Comparator compare;
-
-public:
-  Array(uint8_t *a, size_t s, size_t e, Comparator c)
-      : array(a), array_size(s), elem_size(e), compare(c) {}
-
-  uint8_t *get(size_t i) const { return array + i * elem_size; }
-
-  void swap(size_t i, size_t j) const {
-    uint8_t *elem_i = get(i);
-    uint8_t *elem_j = get(j);
-    for (size_t b = 0; b < elem_size; ++b) {
-      uint8_t temp = elem_i[b];
-      elem_i[b] = elem_j[b];
-      elem_j[b] = temp;
-    }
-  }
 
-  int elem_compare(size_t i, const uint8_t *other) const {
-    // An element must compare equal to itself so we don't need to consult the
-    // user provided comparator.
-    if (get(i) == other)
-      return 0;
-    return compare.comp_vals(get(i), other);
-  }
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
-  size_t size() const { return array_size; }
-
-  // Make an Array starting at index |i| and size |s|.
-  Array make_array(size_t i, size_t s) const {
-    return Array(get(i), s, elem_size, compare);
-  }
-};
-
-static size_t partition(const Array &array) {
-  const size_t array_size = array.size();
-  size_t pivot_index = array_size / 2;
-  uint8_t *pivot = array.get(pivot_index);
-  size_t i = 0;
-  size_t j = array_size - 1;
-
-  while (true) {
-    int compare_i, compare_j;
-
-    while ((compare_i = array.elem_compare(i, pivot)) < 0)
-      ++i;
-    while ((compare_j = array.elem_compare(j, pivot)) > 0)
-      --j;
-
-    // At some point i will crossover j so we will definitely break out of
-    // this while loop.
-    if (i >= j)
-      return j + 1;
-
-    array.swap(i, j);
-
-    // The pivot itself might have got swapped so we will update the pivot.
-    if (i == pivot_index) {
-      pivot = array.get(j);
-      pivot_index = j;
-    } else if (j == pivot_index) {
-      pivot = array.get(i);
-      pivot_index = i;
-    }
-
-    if (compare_i == 0 && compare_j == 0) {
-      // If we do not move the pointers, we will end up with an
-      // infinite loop as i and j will be stuck without advancing.
-      ++i;
-      --j;
-    }
-  }
-}
-
-LIBC_INLINE void quicksort(const Array &array) {
-  const size_t array_size = array.size();
-  if (array_size <= 1)
-    return;
-  size_t split_index = partition(array);
-  if (array_size <= 2) {
-    // The partition operation sorts the two element array.
-    return;
-  }
-  quicksort(array.make_array(0, split_index));
-  quicksort(array.make_array(split_index, array.size() - split_index));
-}
+#if LIBC_QSORT_IMPL == LIBC_QSORT_QUICK_SORT
+constexpr auto sort = quick_sort;
+#elif LIBC_QSORT_IMPL == LIBC_QSORT_HEAP_SORT
+constexpr auto sort = heap_sort;
+#endif
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_QSORT_UTIL_H
diff --git a/src/stdlib/quick_exit.cpp b/src/stdlib/quick_exit.cpp
index 38f0a3d..29110b3 100644
--- a/src/stdlib/quick_exit.cpp
+++ b/src/stdlib/quick_exit.cpp
@@ -9,16 +9,20 @@
 #include "src/stdlib/quick_exit.h"
 #include "src/__support/OSUtil/exit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/exit_handler.h"
 
 // extern "C" void __cxa_finalize(void *);
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 extern ExitCallbackList at_quick_exit_callbacks;
+[[gnu::weak]] extern void teardown_main_tls();
 
 [[noreturn]] LLVM_LIBC_FUNCTION(void, quick_exit, (int status)) {
   call_exit_callbacks(at_quick_exit_callbacks);
+  if (teardown_main_tls)
+    teardown_main_tls();
   internal::exit(status);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/quick_exit.h b/src/stdlib/quick_exit.h
index 9a3c20c..f41bbaa 100644
--- a/src/stdlib/quick_exit.h
+++ b/src/stdlib/quick_exit.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_QUICK_EXIT_H
 #define LLVM_LIBC_SRC_STDLIB_QUICK_EXIT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void quick_exit(int status);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_QUICK_EXIT_H
diff --git a/src/stdlib/quick_sort.h b/src/stdlib/quick_sort.h
new file mode 100644
index 0000000..82b90a7
--- /dev/null
+++ b/src/stdlib/quick_sort.h
@@ -0,0 +1,93 @@
+//===-- Implementation header for qsort utilities ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_QUICK_SORT_H
+#define LLVM_LIBC_SRC_STDLIB_QUICK_SORT_H
+
+#include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
+#include "src/stdlib/qsort_data.h"
+
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+// A simple quicksort implementation using the Hoare partition scheme.
+LIBC_INLINE size_t partition(const Array &array) {
+  const size_t array_size = array.size();
+  size_t pivot_index = array_size / 2;
+  uint8_t *pivot = array.get(pivot_index);
+  size_t i = 0;
+  size_t j = array_size - 1;
+
+  while (true) {
+    int compare_i, compare_j;
+
+    while ((compare_i = array.elem_compare(i, pivot)) < 0)
+      ++i;
+    while ((compare_j = array.elem_compare(j, pivot)) > 0)
+      --j;
+
+    // At some point i will crossover j so we will definitely break out of
+    // this while loop.
+    if (i >= j)
+      return j + 1;
+
+    array.swap(i, j);
+
+    // The pivot itself might have got swapped so we will update the pivot.
+    if (i == pivot_index) {
+      pivot = array.get(j);
+      pivot_index = j;
+    } else if (j == pivot_index) {
+      pivot = array.get(i);
+      pivot_index = i;
+    }
+
+    if (compare_i == 0 && compare_j == 0) {
+      // If we do not move the pointers, we will end up with an
+      // infinite loop as i and j will be stuck without advancing.
+      ++i;
+      --j;
+    }
+  }
+}
+
+LIBC_INLINE void quick_sort(Array array) {
+  while (true) {
+    const size_t array_size = array.size();
+    if (array_size <= 1)
+      return;
+    size_t split_index = partition(array);
+    if (array_size == 2)
+      // The partition operation sorts the two element array.
+      return;
+
+    // Make Arrays describing the two sublists that still need sorting.
+    Array left = array.make_array(0, split_index);
+    Array right = array.make_array(split_index, array.size() - split_index);
+
+    // Recurse to sort the smaller of the two, and then loop round within this
+    // function to sort the larger. This way, recursive call depth is bounded
+    // by log2 of the total array size, because every recursive call is sorting
+    // a list at most half the length of the one in its caller.
+    if (left.size() < right.size()) {
+      quick_sort(left);
+      array.reset_bounds(right.get(0), right.size());
+    } else {
+      quick_sort(right);
+      array.reset_bounds(left.get(0), left.size());
+    }
+  }
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_QUICK_SORT_H
diff --git a/src/stdlib/rand.cpp b/src/stdlib/rand.cpp
index ad543b4..a8a4fab 100644
--- a/src/stdlib/rand.cpp
+++ b/src/stdlib/rand.cpp
@@ -8,19 +8,45 @@
 
 #include "src/stdlib/rand.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/threads/sleep.h"
 #include "src/stdlib/rand_util.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-// An implementation of the xorshift64star pseudo random number generator. This
-// is a good general purpose generator for most non-cryptographics applications.
 LLVM_LIBC_FUNCTION(int, rand, (void)) {
-  unsigned long x = rand_next;
-  x ^= x >> 12;
-  x ^= x << 25;
-  x ^= x >> 27;
-  rand_next = x;
-  return static_cast<int>((x * 0x2545F4914F6CDD1Dul) >> 32) & RAND_MAX;
+  unsigned long orig = rand_next.load(cpp::MemoryOrder::RELAXED);
+
+  // An implementation of the xorshift64star pseudo random number generator.
+  // This is a good general purpose generator for most non-cryptographics
+  // applications.
+  if constexpr (sizeof(void *) == sizeof(uint64_t)) {
+    for (;;) {
+      unsigned long x = orig;
+      x ^= x >> 12;
+      x ^= x << 25;
+      x ^= x >> 27;
+      if (rand_next.compare_exchange_strong(orig, x, cpp::MemoryOrder::ACQUIRE,
+                                            cpp::MemoryOrder::RELAXED))
+        return static_cast<int>((x * 0x2545F4914F6CDD1Dul) >> 32) & RAND_MAX;
+      sleep_briefly();
+    }
+  } else {
+    // This is the xorshift32 pseudo random number generator, slightly different
+    // from the 64-bit star version above, as the previous version fails to
+    // generate uniform enough LSB in 32-bit systems.
+    for (;;) {
+      unsigned long x = orig;
+      x ^= x >> 13;
+      x ^= x << 27;
+      x ^= x >> 5;
+      if (rand_next.compare_exchange_strong(orig, x, cpp::MemoryOrder::ACQUIRE,
+                                            cpp::MemoryOrder::RELAXED))
+        return static_cast<int>(x * 1597334677ul) & RAND_MAX;
+      sleep_briefly();
+    }
+  }
+  __builtin_unreachable();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/rand.h b/src/stdlib/rand.h
index 72bb147..6569319 100644
--- a/src/stdlib/rand.h
+++ b/src/stdlib/rand.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_RAND_H
 #define LLVM_LIBC_SRC_STDLIB_RAND_H
 
-#include <stdlib.h>
+#include "hdr/stdlib_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int rand(void);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_RAND_H
diff --git a/src/stdlib/rand_util.cpp b/src/stdlib/rand_util.cpp
index 1f3dbce..c05bdc7 100644
--- a/src/stdlib/rand_util.cpp
+++ b/src/stdlib/rand_util.cpp
@@ -7,18 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdlib/rand_util.h"
+#include "src/__support/CPP/atomic.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_ARCH_IS_GPU
-// FIXME: Local GPU memory cannot be initialized so we cannot currently provide
-// a standard compliant default value.
-ThreadLocal<unsigned long> rand_next;
-#else
-// C standard 7.10p2: If 'rand' is called before 'srand' it is to proceed as if
-// the 'srand' function was called with a value of '1'.
-LIBC_THREAD_LOCAL unsigned long rand_next = 1;
-#endif
+// C standard 7.10p2: If 'rand' is called before 'srand' it is to
+// proceed as if the 'srand' function was called with a value of '1'.
+cpp::Atomic<unsigned long> rand_next = 1;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/rand_util.h b/src/stdlib/rand_util.h
index cadd6b5..8bf7e58 100644
--- a/src/stdlib/rand_util.h
+++ b/src/stdlib/rand_util.h
@@ -9,34 +9,17 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_RAND_UTIL_H
 #define LLVM_LIBC_SRC_STDLIB_RAND_UTIL_H
 
-#include "src/__support/GPU/utils.h"
+#include "src/__support/CPP/atomic.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_ARCH_IS_GPU
-// Implement thread local storage on the GPU using local memory. Each thread
-// gets its slot in the local memory array and is private to the group.
-// TODO: We need to implement the 'thread_local' keyword on the GPU. This is an
-// inefficient and incomplete stand-in until that is done.
-template <typename T> class ThreadLocal {
-private:
-  static constexpr long MAX_THREADS = 1024;
-  [[clang::loader_uninitialized]] static inline gpu::Local<T>
-      storage[MAX_THREADS];
+// The ISO C standard does not explicitly require thread-safe behavior for the
+// generic `rand()` function. Some implementations expect it however, so we
+// provide it here.
+extern cpp::Atomic<unsigned long> rand_next;
 
-public:
-  LIBC_INLINE operator T() const { return storage[gpu::get_thread_id()]; }
-  LIBC_INLINE void operator=(const T &value) {
-    storage[gpu::get_thread_id()] = value;
-  }
-};
-
-extern ThreadLocal<unsigned long> rand_next;
-#else
-extern LIBC_THREAD_LOCAL unsigned long rand_next;
-#endif
-
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_RAND_UTIL_H
diff --git a/src/stdlib/realloc.h b/src/stdlib/realloc.h
index 6e025fa..4d675a6 100644
--- a/src/stdlib/realloc.h
+++ b/src/stdlib/realloc.h
@@ -6,15 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
 #ifndef LLVM_LIBC_SRC_STDLIB_REALLOC_H
 #define LLVM_LIBC_SRC_STDLIB_REALLOC_H
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *realloc(void *ptr, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_REALLOC_H
diff --git a/src/stdlib/srand.cpp b/src/stdlib/srand.cpp
index 008c7a9..d11c18e 100644
--- a/src/stdlib/srand.cpp
+++ b/src/stdlib/srand.cpp
@@ -8,10 +8,13 @@
 
 #include "src/stdlib/srand.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/rand_util.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(void, srand, (unsigned int seed)) { rand_next = seed; }
+LLVM_LIBC_FUNCTION(void, srand, (unsigned int seed)) {
+  rand_next.store(seed, cpp::MemoryOrder::RELAXED);
+}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/srand.h b/src/stdlib/srand.h
index 1bcf8de..3c40c74 100644
--- a/src/stdlib/srand.h
+++ b/src/stdlib/srand.h
@@ -9,12 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_SRAND_H
 #define LLVM_LIBC_SRC_STDLIB_SRAND_H
 
-#include <stdlib.h>
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void srand(unsigned int seed);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_SRAND_H
diff --git a/src/stdlib/str_from_util.h b/src/stdlib/str_from_util.h
index 58afa98..7f54bdf 100644
--- a/src/stdlib/str_from_util.h
+++ b/src/stdlib/str_from_util.h
@@ -18,6 +18,7 @@
 #define LLVM_LIBC_SRC_STDLIB_STRFROM_UTIL_H
 
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/stdio/printf_core/converter_atlas.h"
 #include "src/stdio/printf_core/core_structs.h"
@@ -25,7 +26,8 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE::internal {
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
 
 template <typename T>
 using storage_type = typename fputil::FPBits<T>::StorageType;
@@ -133,6 +135,7 @@ int strfromfloat_convert(printf_core::Writer *writer,
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE::internal
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRFROM_UTIL_H
diff --git a/src/stdlib/strfromd.cpp b/src/stdlib/strfromd.cpp
index 329f6fd..4c51e4c 100644
--- a/src/stdlib/strfromd.cpp
+++ b/src/stdlib/strfromd.cpp
@@ -7,9 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdlib/strfromd.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/str_from_util.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strfromd,
                    (char *__restrict s, size_t n, const char *__restrict format,
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, strfromd,
   return writer.get_chars_written();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strfromd.h b/src/stdlib/strfromd.h
index d2c3fef..8a68ff5 100644
--- a/src/stdlib/strfromd.h
+++ b/src/stdlib/strfromd.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRFROMD_H
 #define LLVM_LIBC_SRC_STDLIB_STRFROMD_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int strfromd(char *__restrict s, size_t n, const char *__restrict format,
              double fp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRFROMD_H
diff --git a/src/stdlib/strfromf.cpp b/src/stdlib/strfromf.cpp
index 80e1d74..ea98a69 100644
--- a/src/stdlib/strfromf.cpp
+++ b/src/stdlib/strfromf.cpp
@@ -7,9 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdlib/strfromf.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/str_from_util.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strfromf,
                    (char *__restrict s, size_t n, const char *__restrict format,
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, strfromf,
   return writer.get_chars_written();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strfromf.h b/src/stdlib/strfromf.h
index 492c2c3..e65e6b3 100644
--- a/src/stdlib/strfromf.h
+++ b/src/stdlib/strfromf.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRFROMF_H
 #define LLVM_LIBC_SRC_STDLIB_STRFROMF_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int strfromf(char *__restrict s, size_t n, const char *__restrict format,
              float fp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRFROMF_H
diff --git a/src/stdlib/strfroml.cpp b/src/stdlib/strfroml.cpp
index f0bc935..d5bee76 100644
--- a/src/stdlib/strfroml.cpp
+++ b/src/stdlib/strfroml.cpp
@@ -7,9 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/stdlib/strfroml.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/str_from_util.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strfroml,
                    (char *__restrict s, size_t n, const char *__restrict format,
@@ -41,4 +42,4 @@ LLVM_LIBC_FUNCTION(int, strfroml,
   return writer.get_chars_written();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strfroml.h b/src/stdlib/strfroml.h
index e99d035..1bff12e 100644
--- a/src/stdlib/strfroml.h
+++ b/src/stdlib/strfroml.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRFROML_H
 #define LLVM_LIBC_SRC_STDLIB_STRFROML_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int strfroml(char *__restrict s, size_t n, const char *__restrict format,
              long double fp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRFROML_H
diff --git a/src/stdlib/strtod.cpp b/src/stdlib/strtod.cpp
index 461f7fe..2c68191 100644
--- a/src/stdlib/strtod.cpp
+++ b/src/stdlib/strtod.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtod.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, strtod,
                    (const char *__restrict str, char **__restrict str_end)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(double, strtod,
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtod.h b/src/stdlib/strtod.h
index 5efad84..1a32e38 100644
--- a/src/stdlib/strtod.h
+++ b/src/stdlib/strtod.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOD_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOD_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 double strtod(const char *__restrict str, char **__restrict str_end);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOD_H
diff --git a/src/stdlib/strtod_l.cpp b/src/stdlib/strtod_l.cpp
new file mode 100644
index 0000000..2473143
--- /dev/null
+++ b/src/stdlib/strtod_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtod_l ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtod_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_float.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(double, strtod_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    locale_t)) {
+  auto result = internal::strtofloatingpoint<double>(str);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result.value;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtod_l.h b/src/stdlib/strtod_l.h
new file mode 100644
index 0000000..06a8c89
--- /dev/null
+++ b/src/stdlib/strtod_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtod_l ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOD_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOD_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+double strtod_l(const char *__restrict str, char **__restrict str_end,
+                locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOD_L_H
diff --git a/src/stdlib/strtof.cpp b/src/stdlib/strtof.cpp
index 554d096..351bf64 100644
--- a/src/stdlib/strtof.cpp
+++ b/src/stdlib/strtof.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtof.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(float, strtof,
                    (const char *__restrict str, char **__restrict str_end)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(float, strtof,
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtof.h b/src/stdlib/strtof.h
index d800b22..2e7645f 100644
--- a/src/stdlib/strtof.h
+++ b/src/stdlib/strtof.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOF_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOF_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 float strtof(const char *__restrict str, char **__restrict str_end);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOF_H
diff --git a/src/stdlib/strtof_l.cpp b/src/stdlib/strtof_l.cpp
new file mode 100644
index 0000000..d54efa6
--- /dev/null
+++ b/src/stdlib/strtof_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtof_l ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtof_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_float.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(float, strtof_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    locale_t)) {
+  auto result = internal::strtofloatingpoint<float>(str);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result.value;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtof_l.h b/src/stdlib/strtof_l.h
new file mode 100644
index 0000000..de629e3
--- /dev/null
+++ b/src/stdlib/strtof_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtof_l ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOF_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOF_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float strtof_l(const char *__restrict str, char **__restrict str_end,
+               locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOF_L_H
diff --git a/src/stdlib/strtol.cpp b/src/stdlib/strtol.cpp
index e9bedf2..77f8712 100644
--- a/src/stdlib/strtol.cpp
+++ b/src/stdlib/strtol.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtol.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, strtol,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(long, strtol,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtol.h b/src/stdlib/strtol.h
index c46c650..54779d4 100644
--- a/src/stdlib/strtol.h
+++ b/src/stdlib/strtol.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOL_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long strtol(const char *__restrict str, char **__restrict str_end, int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOL_H
diff --git a/src/stdlib/strtol_l.cpp b/src/stdlib/strtol_l.cpp
new file mode 100644
index 0000000..f94aff1
--- /dev/null
+++ b/src/stdlib/strtol_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtol_l ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtol_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_integer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long, strtol_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    int base, locale_t)) {
+  auto result = internal::strtointeger<long>(str, base);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtol_l.h b/src/stdlib/strtol_l.h
new file mode 100644
index 0000000..9f8c855
--- /dev/null
+++ b/src/stdlib/strtol_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtol_l ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOL_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOL_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long strtol_l(const char *__restrict str, char **__restrict str_end, int base,
+              locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOL_L_H
diff --git a/src/stdlib/strtold.cpp b/src/stdlib/strtold.cpp
index 9c3e1db..88d29c9 100644
--- a/src/stdlib/strtold.cpp
+++ b/src/stdlib/strtold.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtold.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long double, strtold,
                    (const char *__restrict str, char **__restrict str_end)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(long double, strtold,
   return result.value;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtold.h b/src/stdlib/strtold.h
index 6a0b5d4..4b663ca 100644
--- a/src/stdlib/strtold.h
+++ b/src/stdlib/strtold.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOLD_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOLD_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long double strtold(const char *__restrict str, char **__restrict str_end);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOLD_H
diff --git a/src/stdlib/strtold_l.cpp b/src/stdlib/strtold_l.cpp
new file mode 100644
index 0000000..d0c57f5
--- /dev/null
+++ b/src/stdlib/strtold_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtold_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtold_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_float.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long double, strtold_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    locale_t)) {
+  auto result = internal::strtofloatingpoint<long double>(str);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result.value;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtold_l.h b/src/stdlib/strtold_l.h
new file mode 100644
index 0000000..d694ce2
--- /dev/null
+++ b/src/stdlib/strtold_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtold_l ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOLD_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOLD_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long double strtold_l(const char *__restrict str, char **__restrict str_end,
+                      locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOLD_L_H
diff --git a/src/stdlib/strtoll.cpp b/src/stdlib/strtoll.cpp
index 99e8205..8d1b3ef 100644
--- a/src/stdlib/strtoll.cpp
+++ b/src/stdlib/strtoll.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtoll.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long long, strtoll,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(long long, strtoll,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoll.h b/src/stdlib/strtoll.h
index d699785..399c20b 100644
--- a/src/stdlib/strtoll.h
+++ b/src/stdlib/strtoll.h
@@ -9,11 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOLL_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOLL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 long long strtoll(const char *__restrict str, char **__restrict str_end,
                   int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOLL_H
diff --git a/src/stdlib/strtoll_l.cpp b/src/stdlib/strtoll_l.cpp
new file mode 100644
index 0000000..e82971d
--- /dev/null
+++ b/src/stdlib/strtoll_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtoll_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtoll_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_integer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long long, strtoll_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    int base, locale_t)) {
+  auto result = internal::strtointeger<long long>(str, base);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoll_l.h b/src/stdlib/strtoll_l.h
new file mode 100644
index 0000000..461fedb
--- /dev/null
+++ b/src/stdlib/strtoll_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtoll_l ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOLL_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOLL_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long long strtoll_l(const char *__restrict str, char **__restrict str_end,
+                    int base, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOLL_L_H
diff --git a/src/stdlib/strtoul.cpp b/src/stdlib/strtoul.cpp
index f50ed7e..1d83231 100644
--- a/src/stdlib/strtoul.cpp
+++ b/src/stdlib/strtoul.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtoul.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long, strtoul,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(unsigned long, strtoul,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoul.h b/src/stdlib/strtoul.h
index af83992..ca1911a 100644
--- a/src/stdlib/strtoul.h
+++ b/src/stdlib/strtoul.h
@@ -9,11 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOUL_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOUL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long strtoul(const char *__restrict str, char **__restrict str_end,
                       int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOUL_H
diff --git a/src/stdlib/strtoul_l.cpp b/src/stdlib/strtoul_l.cpp
new file mode 100644
index 0000000..74fce00
--- /dev/null
+++ b/src/stdlib/strtoul_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtoul_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtoul_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_integer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(unsigned long, strtoul_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    int base, locale_t)) {
+  auto result = internal::strtointeger<unsigned long>(str, base);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoul_l.h b/src/stdlib/strtoul_l.h
new file mode 100644
index 0000000..7c9f53a
--- /dev/null
+++ b/src/stdlib/strtoul_l.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for strtoul_l ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOUL_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOUL_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned long strtoul_l(const char *__restrict str, char **__restrict str_end,
+                        int base, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOUL_L_H
diff --git a/src/stdlib/strtoull.cpp b/src/stdlib/strtoull.cpp
index de3a0d0..dba2261 100644
--- a/src/stdlib/strtoull.cpp
+++ b/src/stdlib/strtoull.cpp
@@ -8,10 +8,11 @@
 
 #include "src/stdlib/strtoull.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(unsigned long long, strtoull,
                    (const char *__restrict str, char **__restrict str_end,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(unsigned long long, strtoull,
   return result;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoull.h b/src/stdlib/strtoull.h
index 47ed101..58801e5 100644
--- a/src/stdlib/strtoull.h
+++ b/src/stdlib/strtoull.h
@@ -9,11 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_STRTOULL_H
 #define LLVM_LIBC_SRC_STDLIB_STRTOULL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long long strtoull(const char *__restrict str,
                             char **__restrict str_end, int base);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STDLIB_STRTOULL_H
diff --git a/src/stdlib/strtoull_l.cpp b/src/stdlib/strtoull_l.cpp
new file mode 100644
index 0000000..2ea8a43
--- /dev/null
+++ b/src/stdlib/strtoull_l.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of strtoull_l --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/strtoull_l.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_integer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(unsigned long long, strtoull_l,
+                   (const char *__restrict str, char **__restrict str_end,
+                    int base, locale_t)) {
+  auto result = internal::strtointeger<unsigned long long>(str, base);
+  if (result.has_error())
+    libc_errno = result.error;
+
+  if (str_end != nullptr)
+    *str_end = const_cast<char *>(str + result.parsed_len);
+
+  return result;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/strtoull_l.h b/src/stdlib/strtoull_l.h
new file mode 100644
index 0000000..c40f83e
--- /dev/null
+++ b/src/stdlib/strtoull_l.h
@@ -0,0 +1,23 @@
+//===-- Implementation header for strtoull_l --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_STRTOULL_L_H
+#define LLVM_LIBC_SRC_STDLIB_STRTOULL_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+unsigned long long strtoull_l(const char *__restrict str,
+                              char **__restrict str_end, int base,
+                              locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_STRTOULL_L_H
diff --git a/src/stdlib/system.h b/src/stdlib/system.h
new file mode 100644
index 0000000..3358ca7
--- /dev/null
+++ b/src/stdlib/system.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for system ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_SYSTEM_H
+#define LLVM_LIBC_SRC_STDLIB_SYSTEM_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int system(const char *command);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_SYSTEM_H
diff --git a/src/string/allocating_string_utils.h b/src/string/allocating_string_utils.h
index 4112b79..b3a8663 100644
--- a/src/string/allocating_string_utils.h
+++ b/src/string/allocating_string_utils.h
@@ -17,7 +17,7 @@
 
 #include <stddef.h> // For size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 LIBC_INLINE cpp::optional<char *> strdup(const char *src) {
@@ -33,6 +33,6 @@ LIBC_INLINE cpp::optional<char *> strdup(const char *src) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_ALLOCATING_STRING_UTILS_H
diff --git a/src/string/bcmp.cpp b/src/string/bcmp.cpp
index f18fa0c..6e9c9ae 100644
--- a/src/string/bcmp.cpp
+++ b/src/string/bcmp.cpp
@@ -8,13 +8,14 @@
 
 #include "src/string/bcmp.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_bcmp.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, bcmp,
                    (const void *lhs, const void *rhs, size_t count)) {
   return inline_bcmp(lhs, rhs, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/bcmp.h b/src/string/bcmp.h
index 711aecf..a82b529 100644
--- a/src/string/bcmp.h
+++ b/src/string/bcmp.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_BCMP_H
 #define LLVM_LIBC_SRC_STRING_BCMP_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int bcmp(const void *lhs, const void *rhs, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_BCMP_H
diff --git a/src/string/bcopy.cpp b/src/string/bcopy.cpp
index 9399d33..89aad71 100644
--- a/src/string/bcopy.cpp
+++ b/src/string/bcopy.cpp
@@ -8,12 +8,13 @@
 
 #include "src/string/bcopy.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memmove.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, bcopy, (const void *src, void *dst, size_t count)) {
   return inline_memmove(dst, src, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/bcopy.h b/src/string/bcopy.h
index ec4d8cd..4cf0263 100644
--- a/src/string/bcopy.h
+++ b/src/string/bcopy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_BCOPY_H
 #define LLVM_LIBC_SRC_STRING_BCOPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void bcopy(const void *src, void *dest, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_BCOPY_H
diff --git a/src/string/bzero.cpp b/src/string/bzero.cpp
index c833cd8..7bcbee3 100644
--- a/src/string/bzero.cpp
+++ b/src/string/bzero.cpp
@@ -8,12 +8,13 @@
 
 #include "src/string/bzero.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_bzero.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, bzero, (void *ptr, size_t count)) {
   inline_bzero(reinterpret_cast<char *>(ptr), count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/bzero.h b/src/string/bzero.h
index 3f52fe2..d972219 100644
--- a/src/string/bzero.h
+++ b/src/string/bzero.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_BZERO_H
 #define LLVM_LIBC_SRC_STRING_BZERO_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void bzero(void *ptr, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_BZERO_H
diff --git a/src/string/index.cpp b/src/string/index.cpp
index 4b2a352..46cf548 100644
--- a/src/string/index.cpp
+++ b/src/string/index.cpp
@@ -9,12 +9,13 @@
 #include "src/string/index.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, index, (const char *src, int c)) {
   return internal::strchr_implementation(src, c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/index.h b/src/string/index.h
index 993f060..9843bcd 100644
--- a/src/string/index.h
+++ b/src/string/index.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_INDEX_H
 #define LLVM_LIBC_SRC_STRING_INDEX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *index(const char *src, int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_INDEX_H
diff --git a/src/string/memccpy.cpp b/src/string/memccpy.cpp
index 200384e..ae90cf9 100644
--- a/src/string/memccpy.cpp
+++ b/src/string/memccpy.cpp
@@ -9,9 +9,10 @@
 #include "src/string/memccpy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memccpy,
                    (void *__restrict dest, const void *__restrict src, int c,
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(void *, memccpy,
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memccpy.h b/src/string/memccpy.h
index ce12dfb..d6d2ea4 100644
--- a/src/string/memccpy.h
+++ b/src/string/memccpy.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMCCPY_H
 #define LLVM_LIBC_SRC_STRING_MEMCCPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memccpy(void *__restrict dest, const void *__restrict src, int c,
               size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMCCPY_H
diff --git a/src/string/memchr.cpp b/src/string/memchr.cpp
index 918bdd9..ba52f14 100644
--- a/src/string/memchr.cpp
+++ b/src/string/memchr.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/memchr.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: Look at performance benefits of comparing words.
 LLVM_LIBC_FUNCTION(void *, memchr, (const void *src, int c, size_t n)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(void *, memchr, (const void *src, int c, size_t n)) {
       static_cast<unsigned char>(c), n);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memchr.h b/src/string/memchr.h
index b84c831..748fd64 100644
--- a/src/string/memchr.h
+++ b/src/string/memchr.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMCHR_H
 #define LLVM_LIBC_SRC_STRING_MEMCHR_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memchr(const void *src, int c, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMCHR_H
diff --git a/src/string/memcmp.cpp b/src/string/memcmp.cpp
index adfbc1e..68996fb 100644
--- a/src/string/memcmp.cpp
+++ b/src/string/memcmp.cpp
@@ -7,15 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/memcmp.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcmp.h"
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, memcmp,
                    (const void *lhs, const void *rhs, size_t count)) {
   return inline_memcmp(lhs, rhs, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memcmp.h b/src/string/memcmp.h
index f2c1dd3..b934ee3 100644
--- a/src/string/memcmp.h
+++ b/src/string/memcmp.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMCMP_H
 #define LLVM_LIBC_SRC_STRING_MEMCMP_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int memcmp(const void *lhs, const void *rhs, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMCMP_H
diff --git a/src/string/memcpy.cpp b/src/string/memcpy.cpp
index e6cf978..0eb7f2c 100644
--- a/src/string/memcpy.cpp
+++ b/src/string/memcpy.cpp
@@ -8,9 +8,10 @@
 
 #include "src/string/memcpy.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memcpy,
                    (void *__restrict dst, const void *__restrict src,
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(void *, memcpy,
   return dst;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memcpy.h b/src/string/memcpy.h
index ea34a2d..d624878 100644
--- a/src/string/memcpy.h
+++ b/src/string/memcpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMCPY_H
 #define LLVM_LIBC_SRC_STRING_MEMCPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memcpy(void *__restrict, const void *__restrict, size_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMCPY_H
diff --git a/src/string/memmem.cpp b/src/string/memmem.cpp
index c695a8d..c38df8f 100644
--- a/src/string/memmem.cpp
+++ b/src/string/memmem.cpp
@@ -8,9 +8,10 @@
 
 #include "src/string/memmem.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memmem.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memmem,
                    (const void *haystack, size_t haystack_len,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(void *, memmem,
   return inline_memmem(haystack, haystack_len, needle, needle_len, COMP);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memmem.h b/src/string/memmem.h
index b1f84c8..ce1bd61 100644
--- a/src/string/memmem.h
+++ b/src/string/memmem.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMMEM_H
 #define LLVM_LIBC_SRC_STRING_MEMMEM_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memmem(const void *haystack, size_t haystack_len, const void *needle,
              size_t needle_len);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMMEM_H
diff --git a/src/string/memmove.cpp b/src/string/memmove.cpp
index 19e38a3..26a8c41 100644
--- a/src/string/memmove.cpp
+++ b/src/string/memmove.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/memmove.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/memory_utils/inline_memmove.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memmove,
                    (void *dst, const void *src, size_t count)) {
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(void *, memmove,
   return dst;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memmove.h b/src/string/memmove.h
index 4d78aad..56b071a 100644
--- a/src/string/memmove.h
+++ b/src/string/memmove.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMMOVE_H
 #define LLVM_LIBC_SRC_STRING_MEMMOVE_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memmove(void *dst, const void *src, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMMOVE_H
diff --git a/src/string/memory_utils/aarch64/inline_bcmp.h b/src/string/memory_utils/aarch64/inline_bcmp.h
index b80b578..9319641 100644
--- a/src/string/memory_utils/aarch64/inline_bcmp.h
+++ b/src/string/memory_utils/aarch64/inline_bcmp.h
@@ -9,6 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h"   // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_generic.h"
@@ -16,7 +17,7 @@
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE BcmpReturnType inline_bcmp_aarch64(CPtr p1,
                                                                 CPtr p2,
@@ -65,6 +66,6 @@ namespace LIBC_NAMESPACE {
   return aarch64::Bcmp<32>::loop_and_tail(p1, p2, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_BCMP_H
diff --git a/src/string/memory_utils/aarch64/inline_memcmp.h b/src/string/memory_utils/aarch64/inline_memcmp.h
index d0e0bd7..35ca077 100644
--- a/src/string/memory_utils/aarch64/inline_memcmp.h
+++ b/src/string/memory_utils/aarch64/inline_memcmp.h
@@ -8,13 +8,13 @@
 #ifndef LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
 #define LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
 
-#include "src/__support/macros/config.h"       // LIBC_INLINE
+#include "src/__support/macros/attributes.h"   // LIBC_INLINE
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/utils.h" // MemcmpReturnType
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE MemcmpReturnType
 inline_memcmp_generic_gt16(CPtr p1, CPtr p2, size_t count) {
@@ -66,6 +66,6 @@ LIBC_INLINE MemcmpReturnType inline_memcmp_aarch64(CPtr p1, CPtr p2,
   else
     return inline_memcmp_generic_gt16(p1, p2, count);
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
diff --git a/src/string/memory_utils/aarch64/inline_memcpy.h b/src/string/memory_utils/aarch64/inline_memcpy.h
index ea1a03f..11cf022 100644
--- a/src/string/memory_utils/aarch64/inline_memcpy.h
+++ b/src/string/memory_utils/aarch64/inline_memcpy.h
@@ -8,13 +8,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMCPY_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMCPY_H
 
-#include "src/__support/macros/config.h" // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
 #include "src/string/memory_utils/op_builtin.h"
 #include "src/string/memory_utils/utils.h"
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE void
 inline_memcpy_aarch64(Ptr __restrict dst, CPtr __restrict src, size_t count) {
@@ -43,6 +43,6 @@ inline_memcpy_aarch64(Ptr __restrict dst, CPtr __restrict src, size_t count) {
   return builtin::Memcpy<64>::loop_and_tail(dst, src, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMCPY_H
diff --git a/src/string/memory_utils/aarch64/inline_memmove.h b/src/string/memory_utils/aarch64/inline_memmove.h
index ca28655..2b23803 100644
--- a/src/string/memory_utils/aarch64/inline_memmove.h
+++ b/src/string/memory_utils/aarch64/inline_memmove.h
@@ -8,7 +8,7 @@
 #ifndef LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMMOVE_H
 #define LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMMOVE_H
 
-#include "src/__support/macros/config.h"        // LIBC_INLINE
+#include "src/__support/macros/attributes.h"    // LIBC_INLINE
 #include "src/string/memory_utils/op_aarch64.h" // aarch64::kNeon
 #include "src/string/memory_utils/op_builtin.h"
 #include "src/string/memory_utils/op_generic.h"
@@ -16,7 +16,7 @@
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE void inline_memmove_aarch64(Ptr dst, CPtr src, size_t count) {
   static_assert(aarch64::kNeon, "aarch64 supports vector types");
@@ -48,6 +48,6 @@ LIBC_INLINE void inline_memmove_aarch64(Ptr dst, CPtr src, size_t count) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMMOVE_H
diff --git a/src/string/memory_utils/aarch64/inline_memset.h b/src/string/memory_utils/aarch64/inline_memset.h
index 91512ac..a2c0553 100644
--- a/src/string/memory_utils/aarch64/inline_memset.h
+++ b/src/string/memory_utils/aarch64/inline_memset.h
@@ -9,13 +9,14 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMSET_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE static void
 inline_memset_aarch64(Ptr dst, uint8_t value, size_t count) {
@@ -56,6 +57,6 @@ inline_memset_aarch64(Ptr dst, uint8_t value, size_t count) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMSET_H
diff --git a/src/string/memory_utils/generic/aligned_access.h b/src/string/memory_utils/generic/aligned_access.h
index b6ece81..49a318d 100644
--- a/src/string/memory_utils/generic/aligned_access.h
+++ b/src/string/memory_utils/generic/aligned_access.h
@@ -13,14 +13,14 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_ALIGNED_ACCESS_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_ALIGNED_ACCESS_H
 
-#include "src/__support/macros/config.h" // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
 #include "src/string/memory_utils/generic/byte_per_byte.h"
 #include "src/string/memory_utils/op_generic.h" // generic::splat
 #include "src/string/memory_utils/utils.h"      // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE uint32_t load32_aligned(CPtr ptr, size_t offset,
                                                      size_t alignment) {
@@ -202,6 +202,6 @@ inline_memcmp_aligned_access_64bit(CPtr p1, CPtr p2, size_t count) {
   return inline_memcmp_byte_per_byte(p1, p2, count, offset);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_ALIGNED_ACCESS_H
diff --git a/src/string/memory_utils/generic/builtin.h b/src/string/memory_utils/generic/builtin.h
index ba4f4b8..5670a4e 100644
--- a/src/string/memory_utils/generic/builtin.h
+++ b/src/string/memory_utils/generic/builtin.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BUILTIN_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/string/memory_utils/utils.h"   // Ptr, CPtr
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #if !__has_builtin(__builtin_memcpy) || !__has_builtin(__builtin_memset) ||    \
     !__has_builtin(__builtin_memmove)
@@ -36,6 +37,6 @@ inline_memset_builtin(Ptr dst, uint8_t value, size_t count, size_t offset = 0) {
   __builtin_memset(dst + offset, value, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BUILTIN_H
diff --git a/src/string/memory_utils/generic/byte_per_byte.h b/src/string/memory_utils/generic/byte_per_byte.h
index 9515398..2aecf01 100644
--- a/src/string/memory_utils/generic/byte_per_byte.h
+++ b/src/string/memory_utils/generic/byte_per_byte.h
@@ -12,13 +12,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BYTE_PER_BYTE_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BYTE_PER_BYTE_H
 
-#include "src/__support/macros/config.h"       // LIBC_INLINE
+#include "src/__support/macros/attributes.h"   // LIBC_INLINE
 #include "src/__support/macros/optimization.h" // LIBC_LOOP_NOUNROLL
 #include "src/string/memory_utils/utils.h"     // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE void
 inline_memcpy_byte_per_byte(Ptr dst, CPtr src, size_t count,
@@ -73,6 +73,6 @@ inline_memcmp_byte_per_byte(CPtr p1, CPtr p2, size_t count, size_t offset = 0) {
   return MemcmpReturnType::zero();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BYTE_PER_BYTE_H
diff --git a/src/string/memory_utils/inline_bcmp.h b/src/string/memory_utils/inline_bcmp.h
index 69aa2ac..14cf16e 100644
--- a/src/string/memory_utils/inline_bcmp.h
+++ b/src/string/memory_utils/inline_bcmp.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_BCMP_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_
 
 #include <stddef.h> // size_t
@@ -30,7 +31,7 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::flatten]] LIBC_INLINE int inline_bcmp(const void *p1, const void *p2,
                                              size_t count) {
@@ -38,7 +39,7 @@ namespace LIBC_NAMESPACE {
       reinterpret_cast<CPtr>(p1), reinterpret_cast<CPtr>(p2), count));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef LIBC_SRC_STRING_MEMORY_UTILS_BCMP
 
diff --git a/src/string/memory_utils/inline_bzero.h b/src/string/memory_utils/inline_bzero.h
index d760bac..4a92e8b 100644
--- a/src/string/memory_utils/inline_bzero.h
+++ b/src/string/memory_utils/inline_bzero.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_BZERO_H
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memset.h"
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::flatten]] LIBC_INLINE static void inline_bzero(Ptr dst, size_t count) {
   inline_memset(dst, 0, count);
@@ -24,6 +25,6 @@ namespace LIBC_NAMESPACE {
   inline_bzero(reinterpret_cast<Ptr>(dst), count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_BZERO_H
diff --git a/src/string/memory_utils/inline_memcmp.h b/src/string/memory_utils/inline_memcmp.h
index 1fdc139..cb7a07c 100644
--- a/src/string/memory_utils/inline_memcmp.h
+++ b/src/string/memory_utils/inline_memcmp.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMCMP_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMCMP_H
 
-#include "src/__support/macros/config.h"                   // LIBC_INLINE
+#include "src/__support/macros/attributes.h"               // LIBC_INLINE
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_
 #include "src/string/memory_utils/utils.h"                 // Ptr, CPtr
 
@@ -31,7 +31,7 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::flatten]] LIBC_INLINE int inline_memcmp(const void *p1, const void *p2,
                                                size_t count) {
@@ -39,7 +39,7 @@ namespace LIBC_NAMESPACE {
       reinterpret_cast<CPtr>(p1), reinterpret_cast<CPtr>(p2), count));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef LIBC_SRC_STRING_MEMORY_UTILS_MEMCMP
 
diff --git a/src/string/memory_utils/inline_memcpy.h b/src/string/memory_utils/inline_memcpy.h
index c88fd55..3e84397 100644
--- a/src/string/memory_utils/inline_memcpy.h
+++ b/src/string/memory_utils/inline_memcpy.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMCPY_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMCPY_H
 
-#include "src/__support/macros/config.h"                   // LIBC_INLINE
+#include "src/__support/macros/attributes.h"               // LIBC_INLINE
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_
 #include "src/string/memory_utils/utils.h"                 // Ptr, CPtr
 
@@ -38,7 +38,7 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::flatten]] LIBC_INLINE void
 inline_memcpy(void *__restrict dst, const void *__restrict src, size_t count) {
@@ -46,6 +46,6 @@ inline_memcpy(void *__restrict dst, const void *__restrict src, size_t count) {
                                       reinterpret_cast<CPtr>(src), count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMCPY_H
diff --git a/src/string/memory_utils/inline_memmem.h b/src/string/memory_utils/inline_memmem.h
index eaddee5..15e3d63 100644
--- a/src/string/memory_utils/inline_memmem.h
+++ b/src/string/memory_utils/inline_memmem.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMEM_H
 
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename Comp>
 LIBC_INLINE constexpr static void *
@@ -39,6 +40,6 @@ inline_memmem(const void *haystack, size_t haystack_len, const void *needle,
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMEM_H
diff --git a/src/string/memory_utils/inline_memmove.h b/src/string/memory_utils/inline_memmove.h
index 3cbc3e0..85d0159 100644
--- a/src/string/memory_utils/inline_memmove.h
+++ b/src/string/memory_utils/inline_memmove.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMOVE_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMOVE_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t, ptrdiff_t
 
 #if defined(LIBC_TARGET_ARCH_IS_X86)
@@ -42,7 +43,7 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE constexpr bool inline_memmove_no_small_size(void *, const void *,
                                                         size_t) {
@@ -67,6 +68,6 @@ LIBC_INLINE void inline_memmove(void *dst, const void *src, size_t count) {
   inline_memmove_follow_up(dst, src, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif /* LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMOVE_H */
diff --git a/src/string/memory_utils/inline_memset.h b/src/string/memory_utils/inline_memset.h
index 1c07c1c..0206a02 100644
--- a/src/string/memory_utils/inline_memset.h
+++ b/src/string/memory_utils/inline_memset.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMSET_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMSET_H
 
-#include "src/__support/macros/config.h"                   // LIBC_INLINE
+#include "src/__support/macros/attributes.h"               // LIBC_INLINE
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_
 #include "src/string/memory_utils/utils.h"                 // Ptr, CPtr
 
@@ -34,13 +34,13 @@
 #error "Unsupported architecture"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE static void inline_memset(void *dst, uint8_t value, size_t count) {
   LIBC_SRC_STRING_MEMORY_UTILS_MEMSET(reinterpret_cast<Ptr>(dst), value, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #undef LIBC_SRC_STRING_MEMORY_UTILS_MEMSET
 
diff --git a/src/string/memory_utils/inline_strcmp.h b/src/string/memory_utils/inline_strcmp.h
index 2bcd56a..281d5b1 100644
--- a/src/string/memory_utils/inline_strcmp.h
+++ b/src/string/memory_utils/inline_strcmp.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRCMP_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRCMP_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename Comp>
 LIBC_INLINE constexpr int inline_strcmp(const char *left, const char *right,
@@ -39,6 +40,6 @@ LIBC_INLINE constexpr int inline_strncmp(const char *left, const char *right,
               *reinterpret_cast<const unsigned char *>(right));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRCMP_H
diff --git a/src/string/memory_utils/inline_strstr.h b/src/string/memory_utils/inline_strstr.h
index f0f8e2b..9c99e92 100644
--- a/src/string/memory_utils/inline_strstr.h
+++ b/src/string/memory_utils/inline_strstr.h
@@ -9,11 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRSTR_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRSTR_H
 
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memmem.h"
 #include "src/string/string_utils.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename Comp>
 LIBC_INLINE constexpr char *inline_strstr(const char *haystack,
@@ -24,6 +25,6 @@ LIBC_INLINE constexpr char *inline_strstr(const char *haystack,
   return static_cast<char *>(result);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRSTR_H
diff --git a/src/string/memory_utils/op_aarch64.h b/src/string/memory_utils/op_aarch64.h
index 6a2013b..1090ea2 100644
--- a/src/string/memory_utils/op_aarch64.h
+++ b/src/string/memory_utils/op_aarch64.h
@@ -13,6 +13,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_AARCH64_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_AARCH64_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_AARCH64)
@@ -25,7 +26,8 @@
 #include <arm_neon.h>
 #endif //__ARM_NEON
 
-namespace LIBC_NAMESPACE::aarch64 {
+namespace LIBC_NAMESPACE_DECL {
+namespace aarch64 {
 
 LIBC_INLINE_VAR constexpr bool kNeon = LLVM_LIBC_IS_DEFINED(__ARM_NEON);
 
@@ -170,9 +172,11 @@ template <size_t Size> struct Bcmp {
   }
 };
 
-} // namespace LIBC_NAMESPACE::aarch64
+} // namespace aarch64
+} // namespace LIBC_NAMESPACE_DECL
 
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
 
 ///////////////////////////////////////////////////////////////////////////////
 // Specializations for uint16_t
@@ -264,7 +268,8 @@ LIBC_INLINE MemcmpReturnType cmp<uint8x16x2_t>(CPtr p1, CPtr p2,
   }
   return MemcmpReturnType::zero();
 }
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TARGET_ARCH_IS_AARCH64
 
diff --git a/src/string/memory_utils/op_builtin.h b/src/string/memory_utils/op_builtin.h
index 75dd4de..d7c1b1f 100644
--- a/src/string/memory_utils/op_builtin.h
+++ b/src/string/memory_utils/op_builtin.h
@@ -16,9 +16,11 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_BUILTIN_H
 
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/utils.h"
 
-namespace LIBC_NAMESPACE::builtin {
+namespace LIBC_NAMESPACE_DECL {
+namespace builtin {
 
 ///////////////////////////////////////////////////////////////////////////////
 // Memcpy
@@ -151,6 +153,7 @@ template <size_t Size> struct Memcmp {
   }
 };
 
-} // namespace LIBC_NAMESPACE::builtin
+} // namespace builtin
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_BUILTIN_H
diff --git a/src/string/memory_utils/op_generic.h b/src/string/memory_utils/op_generic.h
index efaff80..da20a84 100644
--- a/src/string/memory_utils/op_generic.h
+++ b/src/string/memory_utils/op_generic.h
@@ -26,7 +26,8 @@
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT64
 #include "src/string/memory_utils/op_builtin.h"
@@ -38,14 +39,15 @@ static_assert((UINTPTR_MAX == 4294967295U) ||
                   (UINTPTR_MAX == 18446744073709551615UL),
               "We currently only support 32- or 64-bit platforms");
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 // Compiler types using the vector attributes.
 using generic_v128 = uint8_t __attribute__((__vector_size__(16)));
 using generic_v256 = uint8_t __attribute__((__vector_size__(32)));
 using generic_v512 = uint8_t __attribute__((__vector_size__(64)));
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
 
 // We accept three types of values as elements for generic operations:
 // - scalar : unsigned integral types,
@@ -578,6 +580,7 @@ LIBC_INLINE MemcmpReturnType cmp<uint8_t>(CPtr p1, CPtr p2, size_t offset) {
 template <>
 LIBC_INLINE MemcmpReturnType cmp_neq<uint8_t>(CPtr p1, CPtr p2, size_t offset);
 
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_GENERIC_H
diff --git a/src/string/memory_utils/op_riscv.h b/src/string/memory_utils/op_riscv.h
index 313d55e..2d211de 100644
--- a/src/string/memory_utils/op_riscv.h
+++ b/src/string/memory_utils/op_riscv.h
@@ -12,6 +12,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_RISCV_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_RISCV_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
@@ -19,7 +20,8 @@
 #include "src/__support/common.h"
 #include "src/string/memory_utils/op_generic.h"
 
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
 
 ///////////////////////////////////////////////////////////////////////////////
 // Specializations for uint16_t
@@ -78,7 +80,8 @@ LIBC_INLINE MemcmpReturnType cmp_neq<uint64_t>(CPtr p1, CPtr p2,
   return cmp_neq_uint64_t(a, b);
 }
 
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TARGET_ARCH_IS_ANY_RISCV
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_RISCV_H
diff --git a/src/string/memory_utils/op_x86.h b/src/string/memory_utils/op_x86.h
index 2d9cebb..309610e 100644
--- a/src/string/memory_utils/op_x86.h
+++ b/src/string/memory_utils/op_x86.h
@@ -12,6 +12,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_X86_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_X86_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_X86)
@@ -28,16 +29,20 @@
 // Define fake functions to prevent the compiler from failing on undefined
 // functions in case the CPU extension is not present.
 #if !defined(__AVX512BW__) && (defined(_MSC_VER) || defined(__SCE__))
+#undef _mm512_cmpneq_epi8_mask
 #define _mm512_cmpneq_epi8_mask(A, B) 0
 #endif
 #if !defined(__AVX2__) && (defined(_MSC_VER) || defined(__SCE__))
+#undef _mm256_movemask_epi8
 #define _mm256_movemask_epi8(A) 0
 #endif
 #if !defined(__SSE2__) && (defined(_MSC_VER) || defined(__SCE__))
+#undef _mm_movemask_epi8
 #define _mm_movemask_epi8(A) 0
 #endif
 
-namespace LIBC_NAMESPACE::x86 {
+namespace LIBC_NAMESPACE_DECL {
+namespace x86 {
 
 // A set of constants to check compile time features.
 LIBC_INLINE_VAR constexpr bool K_SSE2 = LLVM_LIBC_IS_DEFINED(__SSE2__);
@@ -55,9 +60,20 @@ struct Memcpy {
   }
 };
 
-} // namespace LIBC_NAMESPACE::x86
+} // namespace x86
+} // namespace LIBC_NAMESPACE_DECL
 
-namespace LIBC_NAMESPACE::generic {
+namespace LIBC_NAMESPACE_DECL {
+namespace generic {
+
+// Not equals: returns non-zero iff values at head or tail differ.
+// This function typically loads more data than necessary when the two buffer
+// differs.
+template <typename T>
+LIBC_INLINE uint32_t branchless_head_tail_neq(CPtr p1, CPtr p2, size_t count) {
+  static_assert(cpp::is_integral_v<T>);
+  return neq<T>(p1, p2, 0) | neq<T>(p1, p2, count - sizeof(T));
+}
 
 ///////////////////////////////////////////////////////////////////////////////
 // Specializations for uint16_t
@@ -129,6 +145,11 @@ LIBC_INLINE MemcmpReturnType cmp_neq<uint64_t>(CPtr p1, CPtr p2,
 #if defined(__SSE4_1__)
 template <> struct is_vector<__m128i> : cpp::true_type {};
 template <> struct cmp_is_expensive<__m128i> : cpp::true_type {};
+LIBC_INLINE __m128i load_and_xor_m128i(CPtr p1, CPtr p2, size_t offset) {
+  const auto a = load<__m128i>(p1, offset);
+  const auto b = load<__m128i>(p2, offset);
+  return _mm_xor_si128(a, b);
+}
 LIBC_INLINE __m128i bytewise_max(__m128i a, __m128i b) {
   return _mm_max_epu8(a, b);
 }
@@ -140,17 +161,21 @@ LIBC_INLINE uint16_t big_endian_cmp_mask(__m128i max, __m128i value) {
   return static_cast<uint16_t>(
       _mm_movemask_epi8(bytewise_reverse(_mm_cmpeq_epi8(max, value))));
 }
+LIBC_INLINE bool is_zero(__m128i value) {
+  return _mm_testz_si128(value, value) == 1;
+}
 template <> LIBC_INLINE bool eq<__m128i>(CPtr p1, CPtr p2, size_t offset) {
-  const auto a = load<__m128i>(p1, offset);
-  const auto b = load<__m128i>(p2, offset);
-  const auto xored = _mm_xor_si128(a, b);
-  return _mm_testz_si128(xored, xored) == 1; // 1 iff xored == 0
+  return is_zero(load_and_xor_m128i(p1, p2, offset));
 }
 template <> LIBC_INLINE uint32_t neq<__m128i>(CPtr p1, CPtr p2, size_t offset) {
-  const auto a = load<__m128i>(p1, offset);
-  const auto b = load<__m128i>(p2, offset);
-  const auto xored = _mm_xor_si128(a, b);
-  return _mm_testz_si128(xored, xored) == 0; // 0 iff xored != 0
+  return !is_zero(load_and_xor_m128i(p1, p2, offset));
+}
+template <>
+LIBC_INLINE uint32_t branchless_head_tail_neq<__m128i>(CPtr p1, CPtr p2,
+                                                       size_t count) {
+  const __m128i head = load_and_xor_m128i(p1, p2, 0);
+  const __m128i tail = load_and_xor_m128i(p1, p2, count - sizeof(__m128i));
+  return !is_zero(_mm_or_si128(head, tail));
 }
 template <>
 LIBC_INLINE MemcmpReturnType cmp_neq<__m128i>(CPtr p1, CPtr p2, size_t offset) {
@@ -169,19 +194,34 @@ LIBC_INLINE MemcmpReturnType cmp_neq<__m128i>(CPtr p1, CPtr p2, size_t offset) {
 #if defined(__AVX__)
 template <> struct is_vector<__m256i> : cpp::true_type {};
 template <> struct cmp_is_expensive<__m256i> : cpp::true_type {};
-template <> LIBC_INLINE bool eq<__m256i>(CPtr p1, CPtr p2, size_t offset) {
-  const auto a = load<__m256i>(p1, offset);
-  const auto b = load<__m256i>(p2, offset);
-  const auto xored = _mm256_castps_si256(
+LIBC_INLINE __m256i xor_m256i(__m256i a, __m256i b) {
+  return _mm256_castps_si256(
       _mm256_xor_ps(_mm256_castsi256_ps(a), _mm256_castsi256_ps(b)));
-  return _mm256_testz_si256(xored, xored) == 1; // 1 iff xored == 0
 }
-template <> LIBC_INLINE uint32_t neq<__m256i>(CPtr p1, CPtr p2, size_t offset) {
+LIBC_INLINE __m256i or_m256i(__m256i a, __m256i b) {
+  return _mm256_castps_si256(
+      _mm256_or_ps(_mm256_castsi256_ps(a), _mm256_castsi256_ps(b)));
+}
+LIBC_INLINE __m256i load_and_xor_m256i(CPtr p1, CPtr p2, size_t offset) {
   const auto a = load<__m256i>(p1, offset);
   const auto b = load<__m256i>(p2, offset);
-  const auto xored = _mm256_castps_si256(
-      _mm256_xor_ps(_mm256_castsi256_ps(a), _mm256_castsi256_ps(b)));
-  return _mm256_testz_si256(xored, xored) == 0; // 0 iff xored != 0
+  return xor_m256i(a, b);
+}
+LIBC_INLINE bool is_zero(__m256i value) {
+  return _mm256_testz_si256(value, value) == 1;
+}
+template <> LIBC_INLINE bool eq<__m256i>(CPtr p1, CPtr p2, size_t offset) {
+  return is_zero(load_and_xor_m256i(p1, p2, offset));
+}
+template <> LIBC_INLINE uint32_t neq<__m256i>(CPtr p1, CPtr p2, size_t offset) {
+  return !is_zero(load_and_xor_m256i(p1, p2, offset));
+}
+template <>
+LIBC_INLINE uint32_t branchless_head_tail_neq<__m256i>(CPtr p1, CPtr p2,
+                                                       size_t count) {
+  const __m256i head = load_and_xor_m256i(p1, p2, 0);
+  const __m256i tail = load_and_xor_m256i(p1, p2, count - sizeof(__m256i));
+  return !is_zero(or_m256i(head, tail));
 }
 #endif // __AVX__
 
@@ -296,9 +336,22 @@ template <> LIBC_INLINE bool eq<__m512i>(CPtr p1, CPtr p2, size_t offset) {
 template <> LIBC_INLINE uint32_t neq<__m512i>(CPtr p1, CPtr p2, size_t offset) {
   const auto a = load<__m512i>(p1, offset);
   const auto b = load<__m512i>(p2, offset);
-  const uint64_t xored = _mm512_cmpneq_epi8_mask(a, b);
-  return static_cast<uint32_t>(xored >> 32) |
-         static_cast<uint32_t>(xored & 0xFFFFFFFF);
+  return _mm512_cmpneq_epi8_mask(a, b) != 0;
+}
+LIBC_INLINE __m512i load_and_xor_m512i(CPtr p1, CPtr p2, size_t offset) {
+  const auto a = load<__m512i>(p1, offset);
+  const auto b = load<__m512i>(p2, offset);
+  return _mm512_xor_epi64(a, b);
+}
+LIBC_INLINE bool is_zero(__m512i value) {
+  return _mm512_test_epi32_mask(value, value) == 0;
+}
+template <>
+LIBC_INLINE uint32_t branchless_head_tail_neq<__m512i>(CPtr p1, CPtr p2,
+                                                       size_t count) {
+  const __m512i head = load_and_xor_m512i(p1, p2, 0);
+  const __m512i tail = load_and_xor_m512i(p1, p2, count - sizeof(__m512i));
+  return !is_zero(_mm512_or_epi64(head, tail));
 }
 template <>
 LIBC_INLINE MemcmpReturnType cmp_neq<__m512i>(CPtr p1, CPtr p2, size_t offset) {
@@ -314,7 +367,8 @@ LIBC_INLINE MemcmpReturnType cmp_neq<__m512i>(CPtr p1, CPtr p2, size_t offset) {
 
 #pragma GCC diagnostic pop
 
-} // namespace LIBC_NAMESPACE::generic
+} // namespace generic
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TARGET_ARCH_IS_X86
 
diff --git a/src/string/memory_utils/riscv/inline_bcmp.h b/src/string/memory_utils/riscv/inline_bcmp.h
index d66f0a7..4bdde27 100644
--- a/src/string/memory_utils/riscv/inline_bcmp.h
+++ b/src/string/memory_utils/riscv/inline_bcmp.h
@@ -9,13 +9,14 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE BcmpReturnType inline_bcmp_riscv(CPtr p1, CPtr p2,
                                                               size_t count) {
@@ -28,6 +29,6 @@ namespace LIBC_NAMESPACE {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_BCMP_H
diff --git a/src/string/memory_utils/riscv/inline_memcmp.h b/src/string/memory_utils/riscv/inline_memcmp.h
index 0b28ad9..ca83495 100644
--- a/src/string/memory_utils/riscv/inline_memcmp.h
+++ b/src/string/memory_utils/riscv/inline_memcmp.h
@@ -9,13 +9,14 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCMP_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE MemcmpReturnType
 inline_memcmp_riscv(CPtr p1, CPtr p2, size_t count) {
@@ -28,6 +29,6 @@ inline_memcmp_riscv(CPtr p1, CPtr p2, size_t count) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCMP_H
diff --git a/src/string/memory_utils/riscv/inline_memcpy.h b/src/string/memory_utils/riscv/inline_memcpy.h
index 05531c8..8eb87e0 100644
--- a/src/string/memory_utils/riscv/inline_memcpy.h
+++ b/src/string/memory_utils/riscv/inline_memcpy.h
@@ -9,13 +9,14 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCPY_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE void
 inline_memcpy_riscv(Ptr __restrict dst, CPtr __restrict src, size_t count) {
@@ -28,6 +29,6 @@ inline_memcpy_riscv(Ptr __restrict dst, CPtr __restrict src, size_t count) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCPY_H
diff --git a/src/string/memory_utils/riscv/inline_memmove.h b/src/string/memory_utils/riscv/inline_memmove.h
index 1a95a8e..28de4c2 100644
--- a/src/string/memory_utils/riscv/inline_memmove.h
+++ b/src/string/memory_utils/riscv/inline_memmove.h
@@ -9,19 +9,20 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMMOVE_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/byte_per_byte.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE void
 inline_memmove_riscv(Ptr __restrict dst, CPtr __restrict src, size_t count) {
   return inline_memmove_byte_per_byte(dst, src, count);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMMOVE_H
diff --git a/src/string/memory_utils/riscv/inline_memset.h b/src/string/memory_utils/riscv/inline_memset.h
index b9b8a18..d6ab523 100644
--- a/src/string/memory_utils/riscv/inline_memset.h
+++ b/src/string/memory_utils/riscv/inline_memset.h
@@ -9,13 +9,14 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMSET_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE static void inline_memset_riscv(Ptr dst, uint8_t value,
                                             size_t count) {
@@ -28,6 +29,6 @@ LIBC_INLINE static void inline_memset_riscv(Ptr dst, uint8_t value,
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMSET_H
diff --git a/src/string/memory_utils/utils.h b/src/string/memory_utils/utils.h
index cb1fd89..cae65bd 100644
--- a/src/string/memory_utils/utils.h
+++ b/src/string/memory_utils/utils.h
@@ -12,14 +12,15 @@
 #include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/cstddef.h"
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
 #include <stddef.h> // size_t
 #include <stdint.h> // intptr_t / uintptr_t / INT32_MAX / INT32_MIN
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Returns the number of bytes to substract from ptr to get to the previous
 // multiple of alignment. If ptr is already aligned returns 0.
@@ -349,6 +350,6 @@ LIBC_INLINE void prefetch_to_local_cache(CPtr dst) {
   __builtin_prefetch(dst, /*read*/ 0, /*max locality*/ 3);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_UTILS_H
diff --git a/src/string/memory_utils/x86_64/inline_bcmp.h b/src/string/memory_utils/x86_64/inline_bcmp.h
index 58eaedb..cc54c41 100644
--- a/src/string/memory_utils/x86_64/inline_bcmp.h
+++ b/src/string/memory_utils/x86_64/inline_bcmp.h
@@ -9,13 +9,14 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE BcmpReturnType
 inline_bcmp_generic_gt16(CPtr p1, CPtr p2, size_t count) {
@@ -26,7 +27,7 @@ inline_bcmp_generic_gt16(CPtr p1, CPtr p2, size_t count) {
 [[maybe_unused]] LIBC_INLINE BcmpReturnType
 inline_bcmp_x86_sse41_gt16(CPtr p1, CPtr p2, size_t count) {
   if (count <= 32)
-    return generic::Bcmp<__m128i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m128i>(p1, p2, count);
   return generic::Bcmp<__m128i>::loop_and_tail_align_above(256, p1, p2, count);
 }
 #endif // __SSE4_1__
@@ -35,9 +36,9 @@ inline_bcmp_x86_sse41_gt16(CPtr p1, CPtr p2, size_t count) {
 [[maybe_unused]] LIBC_INLINE BcmpReturnType
 inline_bcmp_x86_avx_gt16(CPtr p1, CPtr p2, size_t count) {
   if (count <= 32)
-    return generic::Bcmp<__m128i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m128i>(p1, p2, count);
   if (count <= 64)
-    return generic::Bcmp<__m256i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m256i>(p1, p2, count);
   return generic::Bcmp<__m256i>::loop_and_tail_align_above(256, p1, p2, count);
 }
 #endif // __AVX__
@@ -46,11 +47,11 @@ inline_bcmp_x86_avx_gt16(CPtr p1, CPtr p2, size_t count) {
 [[maybe_unused]] LIBC_INLINE BcmpReturnType
 inline_bcmp_x86_avx512bw_gt16(CPtr p1, CPtr p2, size_t count) {
   if (count <= 32)
-    return generic::Bcmp<__m128i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m128i>(p1, p2, count);
   if (count <= 64)
-    return generic::Bcmp<__m256i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m256i>(p1, p2, count);
   if (count <= 128)
-    return generic::Bcmp<__m512i>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<__m512i>(p1, p2, count);
   return generic::Bcmp<__m512i>::loop_and_tail_align_above(256, p1, p2, count);
 }
 #endif // __AVX512BW__
@@ -61,22 +62,12 @@ inline_bcmp_x86_avx512bw_gt16(CPtr p1, CPtr p2, size_t count) {
     return BcmpReturnType::zero();
   if (count == 1)
     return generic::Bcmp<uint8_t>::block(p1, p2);
-  if (count == 2)
-    return generic::Bcmp<uint16_t>::block(p1, p2);
-  if (count == 3)
-    return generic::BcmpSequence<uint16_t, uint8_t>::block(p1, p2);
-  if (count == 4)
-    return generic::Bcmp<uint32_t>::block(p1, p2);
-  if (count == 5)
-    return generic::BcmpSequence<uint32_t, uint8_t>::block(p1, p2);
-  if (count == 6)
-    return generic::BcmpSequence<uint32_t, uint16_t>::block(p1, p2);
-  if (count == 7)
-    return generic::BcmpSequence<uint32_t, uint16_t, uint8_t>::block(p1, p2);
-  if (count == 8)
-    return generic::Bcmp<uint64_t>::block(p1, p2);
+  if (count <= 4)
+    return generic::branchless_head_tail_neq<uint16_t>(p1, p2, count);
+  if (count <= 8)
+    return generic::branchless_head_tail_neq<uint32_t>(p1, p2, count);
   if (count <= 16)
-    return generic::Bcmp<uint64_t>::head_tail(p1, p2, count);
+    return generic::branchless_head_tail_neq<uint64_t>(p1, p2, count);
 #if defined(__AVX512BW__)
   return inline_bcmp_x86_avx512bw_gt16(p1, p2, count);
 #elif defined(__AVX__)
@@ -88,6 +79,6 @@ inline_bcmp_x86_avx512bw_gt16(CPtr p1, CPtr p2, size_t count) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_BCMP_H
diff --git a/src/string/memory_utils/x86_64/inline_memcmp.h b/src/string/memory_utils/x86_64/inline_memcmp.h
index 6a315ad..5c18be2 100644
--- a/src/string/memory_utils/x86_64/inline_memcmp.h
+++ b/src/string/memory_utils/x86_64/inline_memcmp.h
@@ -9,13 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
 
-#include "src/__support/macros/config.h"       // LIBC_INLINE
+#include "src/__support/macros/attributes.h"   // LIBC_INLINE
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
 #include "src/string/memory_utils/utils.h" // MemcmpReturnType
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[maybe_unused]] LIBC_INLINE MemcmpReturnType
 inline_memcmp_generic_gt16(CPtr p1, CPtr p2, size_t count) {
@@ -89,6 +89,6 @@ LIBC_INLINE MemcmpReturnType inline_memcmp_x86(CPtr p1, CPtr p2, size_t count) {
 #endif
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCMP_H
diff --git a/src/string/memory_utils/x86_64/inline_memcpy.h b/src/string/memory_utils/x86_64/inline_memcpy.h
index 507b3e2..68f64fb 100644
--- a/src/string/memory_utils/x86_64/inline_memcpy.h
+++ b/src/string/memory_utils/x86_64/inline_memcpy.h
@@ -9,7 +9,6 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCPY_H
 
 #include "src/__support/macros/attributes.h"   // LIBC_INLINE_VAR
-#include "src/__support/macros/config.h"       // LIBC_INLINE
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/op_builtin.h"
 #include "src/string/memory_utils/op_x86.h"
@@ -26,7 +25,7 @@
 #error LLVM_LIBC_MEMCPY_X86_USE_REPMOVSB_FROM_SIZE is deprecated use LIBC_COPT_MEMCPY_X86_USE_REPMOVSB_FROM_SIZE=0 instead.
 #endif // LLVM_LIBC_MEMCPY_X86_USE_REPMOVSB_FROM_SIZE
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace x86 {
 
@@ -69,14 +68,21 @@ inline_memcpy_x86_avx_ge64(Ptr __restrict dst, CPtr __restrict src,
   return builtin::Memcpy<64>::loop_and_tail(dst, src, count);
 }
 
+[[maybe_unused]] LIBC_INLINE void inline_memcpy_prefetch(Ptr __restrict dst,
+                                                         CPtr __restrict src,
+                                                         size_t distance) {
+  prefetch_to_local_cache(src + distance);
+  prefetch_for_write(dst + distance);
+}
+
 [[maybe_unused]] LIBC_INLINE void
 inline_memcpy_x86_sse2_ge64_sw_prefetching(Ptr __restrict dst,
                                            CPtr __restrict src, size_t count) {
   using namespace LIBC_NAMESPACE::x86;
-  prefetch_to_local_cache(src + K_ONE_CACHELINE);
+  inline_memcpy_prefetch(dst, src, K_ONE_CACHELINE);
   if (count <= 128)
     return builtin::Memcpy<64>::head_tail(dst, src, count);
-  prefetch_to_local_cache(src + K_TWO_CACHELINES);
+  inline_memcpy_prefetch(dst, src, K_TWO_CACHELINES);
   // Aligning 'dst' on a 32B boundary.
   builtin::Memcpy<32>::block(dst, src);
   align_to_next_boundary<32, Arg::Dst>(dst, src, count);
@@ -90,21 +96,21 @@ inline_memcpy_x86_sse2_ge64_sw_prefetching(Ptr __restrict dst,
   if (count < 352) {
     // Two cache lines at a time.
     while (offset + K_TWO_CACHELINES + 32 <= count) {
-      prefetch_to_local_cache(src + offset + K_ONE_CACHELINE);
-      prefetch_to_local_cache(src + offset + K_TWO_CACHELINES);
-      builtin::Memcpy<K_TWO_CACHELINES>::block_offset(dst, src, offset);
-      offset += K_TWO_CACHELINES;
+      inline_memcpy_prefetch(dst, src, offset + K_ONE_CACHELINE);
+      inline_memcpy_prefetch(dst, src, offset + K_TWO_CACHELINES);
+      // Copy one cache line at a time to prevent the use of `rep;movsb`.
+      for (size_t i = 0; i < 2; ++i, offset += K_ONE_CACHELINE)
+        builtin::Memcpy<K_ONE_CACHELINE>::block_offset(dst, src, offset);
     }
   } else {
     // Three cache lines at a time.
     while (offset + K_THREE_CACHELINES + 32 <= count) {
-      prefetch_to_local_cache(src + offset + K_ONE_CACHELINE);
-      prefetch_to_local_cache(src + offset + K_TWO_CACHELINES);
-      prefetch_to_local_cache(src + offset + K_THREE_CACHELINES);
-      // It is likely that this copy will be turned into a 'rep;movsb' on
-      // non-AVX machines.
-      builtin::Memcpy<K_THREE_CACHELINES>::block_offset(dst, src, offset);
-      offset += K_THREE_CACHELINES;
+      inline_memcpy_prefetch(dst, src, offset + K_ONE_CACHELINE);
+      inline_memcpy_prefetch(dst, src, offset + K_TWO_CACHELINES);
+      inline_memcpy_prefetch(dst, src, offset + K_THREE_CACHELINES);
+      // Copy one cache line at a time to prevent the use of `rep;movsb`.
+      for (size_t i = 0; i < 3; ++i, offset += K_ONE_CACHELINE)
+        builtin::Memcpy<K_ONE_CACHELINE>::block_offset(dst, src, offset);
     }
   }
   // We don't use 'loop_and_tail_offset' because it assumes at least one
@@ -120,11 +126,11 @@ inline_memcpy_x86_sse2_ge64_sw_prefetching(Ptr __restrict dst,
 inline_memcpy_x86_avx_ge64_sw_prefetching(Ptr __restrict dst,
                                           CPtr __restrict src, size_t count) {
   using namespace LIBC_NAMESPACE::x86;
-  prefetch_to_local_cache(src + K_ONE_CACHELINE);
+  inline_memcpy_prefetch(dst, src, K_ONE_CACHELINE);
   if (count <= 128)
     return builtin::Memcpy<64>::head_tail(dst, src, count);
-  prefetch_to_local_cache(src + K_TWO_CACHELINES);
-  prefetch_to_local_cache(src + K_THREE_CACHELINES);
+  inline_memcpy_prefetch(dst, src, K_TWO_CACHELINES);
+  inline_memcpy_prefetch(dst, src, K_THREE_CACHELINES);
   if (count < 256)
     return builtin::Memcpy<128>::head_tail(dst, src, count);
   // Aligning 'dst' on a 32B boundary.
@@ -139,11 +145,12 @@ inline_memcpy_x86_avx_ge64_sw_prefetching(Ptr __restrict dst,
   // - count >= 128.
   while (offset + K_THREE_CACHELINES + 64 <= count) {
     // Three cache lines at a time.
-    prefetch_to_local_cache(src + offset + K_ONE_CACHELINE);
-    prefetch_to_local_cache(src + offset + K_TWO_CACHELINES);
-    prefetch_to_local_cache(src + offset + K_THREE_CACHELINES);
-    builtin::Memcpy<K_THREE_CACHELINES>::block_offset(dst, src, offset);
-    offset += K_THREE_CACHELINES;
+    inline_memcpy_prefetch(dst, src, offset + K_ONE_CACHELINE);
+    inline_memcpy_prefetch(dst, src, offset + K_TWO_CACHELINES);
+    inline_memcpy_prefetch(dst, src, offset + K_THREE_CACHELINES);
+    // Copy one cache line at a time to prevent the use of `rep;movsb`.
+    for (size_t i = 0; i < 3; ++i, offset += K_ONE_CACHELINE)
+      builtin::Memcpy<K_ONE_CACHELINE>::block_offset(dst, src, offset);
   }
   // We don't use 'loop_and_tail_offset' because it assumes at least one
   // iteration of the loop.
@@ -222,6 +229,6 @@ inline_memcpy_x86_maybe_interpose_repmovsb(Ptr __restrict dst,
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMCPY_H
diff --git a/src/string/memory_utils/x86_64/inline_memmove.h b/src/string/memory_utils/x86_64/inline_memmove.h
index 879b36e..cec8e96 100644
--- a/src/string/memory_utils/x86_64/inline_memmove.h
+++ b/src/string/memory_utils/x86_64/inline_memmove.h
@@ -8,7 +8,7 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMMOVE_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMMOVE_H
 
-#include "src/__support/macros/config.h" // LIBC_INLINE
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
 #include "src/string/memory_utils/op_builtin.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
@@ -16,7 +16,7 @@
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE bool inline_memmove_small_size_x86(Ptr dst, CPtr src,
                                                size_t count) {
@@ -115,6 +115,6 @@ LIBC_INLINE void inline_memmove_follow_up_x86(Ptr dst, CPtr src, size_t count) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMMOVE_H
diff --git a/src/string/memory_utils/x86_64/inline_memset.h b/src/string/memory_utils/x86_64/inline_memset.h
index 584efcb..9f8e584 100644
--- a/src/string/memory_utils/x86_64/inline_memset.h
+++ b/src/string/memory_utils/x86_64/inline_memset.h
@@ -9,13 +9,14 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMSET_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace x86 {
 // Size of one cache line for software prefetching
 LIBC_INLINE_VAR constexpr size_t K_ONE_CACHELINE_SIZE = 64;
@@ -104,6 +105,6 @@ inline_memset_x86(Ptr dst, uint8_t value, size_t count) {
   align_to_next_boundary<32>(dst, count);
   return generic::Memset<uint256_t>::loop_and_tail(dst, value, count);
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMSET_H
diff --git a/src/string/mempcpy.cpp b/src/string/mempcpy.cpp
index 47cc3d6..09392ce 100644
--- a/src/string/mempcpy.cpp
+++ b/src/string/mempcpy.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/mempcpy.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 
 #include "src/__support/common.h"
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, mempcpy,
                    (void *__restrict dst, const void *__restrict src,
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(void *, mempcpy,
   return reinterpret_cast<char *>(dst) + count;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/mempcpy.h b/src/string/mempcpy.h
index 317e0fc..a6fd457 100644
--- a/src/string/mempcpy.h
+++ b/src/string/mempcpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMPCPY_H
 #define LLVM_LIBC_SRC_STRING_MEMPCPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *mempcpy(void *__restrict dest, const void *__restrict src, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMPCPY_H
diff --git a/src/string/memrchr.cpp b/src/string/memrchr.cpp
index fad0868..d665e22 100644
--- a/src/string/memrchr.cpp
+++ b/src/string/memrchr.cpp
@@ -8,9 +8,10 @@
 
 #include "src/string/memrchr.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memrchr, (const void *src, int c, size_t n)) {
   const unsigned char *str = reinterpret_cast<const unsigned char *>(src);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(void *, memrchr, (const void *src, int c, size_t n)) {
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memrchr.h b/src/string/memrchr.h
index 5c32d6a..0ab7b3b 100644
--- a/src/string/memrchr.h
+++ b/src/string/memrchr.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMRCHR_H
 #define LLVM_LIBC_SRC_STRING_MEMRCHR_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memrchr(const void *src, int c, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMRCHR_H
diff --git a/src/string/memset.cpp b/src/string/memset.cpp
index a94e353..c2868af 100644
--- a/src/string/memset.cpp
+++ b/src/string/memset.cpp
@@ -8,13 +8,14 @@
 
 #include "src/string/memset.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memset.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, memset, (void *dst, int value, size_t count)) {
   inline_memset(dst, static_cast<uint8_t>(value), count);
   return dst;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memset.h b/src/string/memset.h
index 4c1ef9d..17062ee 100644
--- a/src/string/memset.h
+++ b/src/string/memset.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMSET_H
 #define LLVM_LIBC_SRC_STRING_MEMSET_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *memset(void *ptr, int value, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMSET_H
diff --git a/src/string/memset_explicit.cpp b/src/string/memset_explicit.cpp
index a8656d1..a3e4dad 100644
--- a/src/string/memset_explicit.cpp
+++ b/src/string/memset_explicit.cpp
@@ -8,9 +8,10 @@
 
 #include "src/string/memset_explicit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memset.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::noinline]] LLVM_LIBC_FUNCTION(void *, memset_explicit,
                                      (void *dst, int value, size_t count)) {
@@ -22,4 +23,4 @@ namespace LIBC_NAMESPACE {
   return dst;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/memset_explicit.h b/src/string/memset_explicit.h
index f6c1897..0c6ccc8 100644
--- a/src/string/memset_explicit.h
+++ b/src/string/memset_explicit.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMSET_EXPLICIT_H
 #define LLVM_LIBC_SRC_STRING_MEMSET_EXPLICIT_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[gnu::noinline]] void *memset_explicit(void *ptr, int value, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_MEMSET_EXPLICIT_H
diff --git a/src/string/rindex.cpp b/src/string/rindex.cpp
index 2c7f8dc..25879dd 100644
--- a/src/string/rindex.cpp
+++ b/src/string/rindex.cpp
@@ -9,12 +9,13 @@
 #include "src/string/rindex.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, rindex, (const char *src, int c)) {
   return internal::strrchr_implementation(src, c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/rindex.h b/src/string/rindex.h
index a2aad85..cfc35da 100644
--- a/src/string/rindex.h
+++ b/src/string/rindex.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_RINDEX_H
 #define LLVM_LIBC_SRC_STRING_RINDEX_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *rindex(const char *src, int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_RINDEX_H
diff --git a/src/string/stpcpy.cpp b/src/string/stpcpy.cpp
index bdaa689..979edd7 100644
--- a/src/string/stpcpy.cpp
+++ b/src/string/stpcpy.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/stpcpy.h"
+#include "src/__support/macros/config.h"
 #include "src/string/mempcpy.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, stpcpy,
                    (char *__restrict dest, const char *__restrict src)) {
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(char *, stpcpy,
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/stpcpy.h b/src/string/stpcpy.h
index 4352f5b..ea04a91 100644
--- a/src/string/stpcpy.h
+++ b/src/string/stpcpy.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STPCPY_H
 #define LLVM_LIBC_SRC_STRING_STPCPY_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *stpcpy(char *__restrict dest, const char *__restrict src);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STPCPY_H
diff --git a/src/string/stpncpy.cpp b/src/string/stpncpy.cpp
index 436e131..d2a6e04 100644
--- a/src/string/stpncpy.cpp
+++ b/src/string/stpncpy.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/stpncpy.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_bzero.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, stpncpy,
                    (char *__restrict dest, const char *__restrict src,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(char *, stpncpy,
   return dest + i;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/stpncpy.h b/src/string/stpncpy.h
index 5ecf65b..343ff61 100644
--- a/src/string/stpncpy.h
+++ b/src/string/stpncpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STPNCPY_H
 #define LLVM_LIBC_SRC_STRING_STPNCPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *stpncpy(char *__restrict dest, const char *__restrict src, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STPNCPY_H
diff --git a/src/string/strcasecmp.cpp b/src/string/strcasecmp.cpp
index 87636ee..1274c04 100644
--- a/src/string/strcasecmp.cpp
+++ b/src/string/strcasecmp.cpp
@@ -10,9 +10,10 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strcmp.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strcasecmp, (const char *left, const char *right)) {
   auto case_cmp = [](char a, char b) {
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, strcasecmp, (const char *left, const char *right)) {
   return inline_strcmp(left, right, case_cmp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcasecmp.h b/src/string/strcasecmp.h
index 97b1f93..2916b8d 100644
--- a/src/string/strcasecmp.h
+++ b/src/string/strcasecmp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCASECMP_H
 #define LLVM_LIBC_SRC_STRING_STRCASECMP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int strcasecmp(const char *left, const char *right);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCASECMP_H
diff --git a/src/string/strcasestr.cpp b/src/string/strcasestr.cpp
index 3119ed4..1da1e3f 100644
--- a/src/string/strcasestr.cpp
+++ b/src/string/strcasestr.cpp
@@ -10,9 +10,10 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strstr.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: This is a simple brute force implementation. This can be
 // improved upon using well known string matching algorithms.
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(char *, strcasestr,
   return inline_strstr(haystack, needle, case_cmp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcasestr.h b/src/string/strcasestr.h
index 9c8ad0f..8bcd945 100644
--- a/src/string/strcasestr.h
+++ b/src/string/strcasestr.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCASESTR_H
 #define LLVM_LIBC_SRC_STRING_STRCASESTR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strcasestr(const char *needle, const char *haystack);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCASESTR_H
diff --git a/src/string/strcat.cpp b/src/string/strcat.cpp
index 6e1baa6..0eb189c 100644
--- a/src/string/strcat.cpp
+++ b/src/string/strcat.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strcat.h"
+#include "src/__support/macros/config.h"
 #include "src/string/strcpy.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strcat,
                    (char *__restrict dest, const char *__restrict src)) {
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(char *, strcat,
   return dest;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcat.h b/src/string/strcat.h
index 3cf2e19..8286019 100644
--- a/src/string/strcat.h
+++ b/src/string/strcat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCAT_H
 #define LLVM_LIBC_SRC_STRING_STRCAT_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strcat(char *__restrict dest, const char *__restrict src);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCAT_H
diff --git a/src/string/strchr.cpp b/src/string/strchr.cpp
index 553197b..d5dbaf8 100644
--- a/src/string/strchr.cpp
+++ b/src/string/strchr.cpp
@@ -9,13 +9,14 @@
 #include "src/string/strchr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: Look at performance benefits of comparing words.
 LLVM_LIBC_FUNCTION(char *, strchr, (const char *src, int c)) {
   return internal::strchr_implementation(src, c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strchr.h b/src/string/strchr.h
index bb6a9c0..0e8094d 100644
--- a/src/string/strchr.h
+++ b/src/string/strchr.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCHR_H
 #define LLVM_LIBC_SRC_STRING_STRCHR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strchr(const char *src, int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCHR_H
diff --git a/src/string/strchrnul.cpp b/src/string/strchrnul.cpp
index 9b492a6..6a3db9c 100644
--- a/src/string/strchrnul.cpp
+++ b/src/string/strchrnul.cpp
@@ -7,14 +7,15 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strchrnul.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strchrnul, (const char *src, int c)) {
   return internal::strchr_implementation<false>(src, c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strchrnul.h b/src/string/strchrnul.h
index b847b0b..d724e73 100644
--- a/src/string/strchrnul.h
+++ b/src/string/strchrnul.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCHRNUL_H
 #define LLVM_LIBC_SRC_STRING_STRCHRNUL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strchrnul(const char *src, int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCHRNUL_H
diff --git a/src/string/strcmp.cpp b/src/string/strcmp.cpp
index 0b515b7..f303ba5 100644
--- a/src/string/strcmp.cpp
+++ b/src/string/strcmp.cpp
@@ -9,13 +9,14 @@
 #include "src/string/strcmp.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strcmp.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strcmp, (const char *left, const char *right)) {
   auto comp = [](char l, char r) -> int { return l - r; };
   return inline_strcmp(left, right, comp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcmp.h b/src/string/strcmp.h
index 9fc6fdb..8d88058 100644
--- a/src/string/strcmp.h
+++ b/src/string/strcmp.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCMP_H
 #define LLVM_LIBC_SRC_STRING_STRCMP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int strcmp(const char *left, const char *right);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCMP_H
diff --git a/src/string/strcoll.cpp b/src/string/strcoll.cpp
index 7280688..eeb2c79 100644
--- a/src/string/strcoll.cpp
+++ b/src/string/strcoll.cpp
@@ -9,8 +9,9 @@
 #include "src/string/strcoll.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: Add support for locales.
 LLVM_LIBC_FUNCTION(int, strcoll, (const char *left, const char *right)) {
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(int, strcoll, (const char *left, const char *right)) {
   return static_cast<int>(*left) - static_cast<int>(*right);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcoll.h b/src/string/strcoll.h
index d69b48a..5035807 100644
--- a/src/string/strcoll.h
+++ b/src/string/strcoll.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCOLL_H
 #define LLVM_LIBC_SRC_STRING_STRCOLL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int strcoll(const char *left, const char *right);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCOLL_H
diff --git a/src/string/strcoll_l.cpp b/src/string/strcoll_l.cpp
new file mode 100644
index 0000000..f664a3c
--- /dev/null
+++ b/src/string/strcoll_l.cpp
@@ -0,0 +1,24 @@
+//===-- Implementation of strcoll_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/string/strcoll_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO: Add support for locales.
+LLVM_LIBC_FUNCTION(int, strcoll_l,
+                   (const char *left, const char *right, locale_t)) {
+  for (; *left && *left == *right; ++left, ++right)
+    ;
+  return static_cast<int>(*left) - static_cast<int>(*right);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcoll_l.h b/src/string/strcoll_l.h
new file mode 100644
index 0000000..97230fb
--- /dev/null
+++ b/src/string/strcoll_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for strcoll_l ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRING_STRCOLL_L_H
+#define LLVM_LIBC_SRC_STRING_STRCOLL_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int strcoll_l(const char *left, const char *right, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRING_STRCOLL_L_H
diff --git a/src/string/strcpy.cpp b/src/string/strcpy.cpp
index 4fbd1a3..60b73ab 100644
--- a/src/string/strcpy.cpp
+++ b/src/string/strcpy.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strcpy.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strcpy,
                    (char *__restrict dest, const char *__restrict src)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(char *, strcpy,
   return dest;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcpy.h b/src/string/strcpy.h
index 11a26a6..9e0c3db 100644
--- a/src/string/strcpy.h
+++ b/src/string/strcpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCPY_H
 #define LLVM_LIBC_SRC_STRING_STRCPY_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strcpy(char *__restrict dest, const char *__restrict src);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCPY_H
diff --git a/src/string/strcspn.cpp b/src/string/strcspn.cpp
index ed057c3..c4a14aa 100644
--- a/src/string/strcspn.cpp
+++ b/src/string/strcspn.cpp
@@ -9,12 +9,13 @@
 #include "src/string/strcspn.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, strcspn, (const char *src, const char *segment)) {
   return internal::complementary_span(src, segment);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strcspn.h b/src/string/strcspn.h
index 21098fe..f50aeab 100644
--- a/src/string/strcspn.h
+++ b/src/string/strcspn.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRCSPN_H
 #define LLVM_LIBC_SRC_STRING_STRCSPN_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strcspn(const char *src, const char *segment);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRCSPN_H
diff --git a/src/string/strdup.cpp b/src/string/strdup.cpp
index 3530a70..4cf4173 100644
--- a/src/string/strdup.cpp
+++ b/src/string/strdup.cpp
@@ -7,15 +7,15 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strdup.h"
+#include "hdr/stdlib_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/string/allocating_string_utils.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 
 #include "src/__support/common.h"
 
-#include <stdlib.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strdup, (const char *src)) {
   auto dup = internal::strdup(src);
@@ -26,4 +26,4 @@ LLVM_LIBC_FUNCTION(char *, strdup, (const char *src)) {
   return nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strdup.h b/src/string/strdup.h
index e33a246..2744e53 100644
--- a/src/string/strdup.h
+++ b/src/string/strdup.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRDUP_H
 #define LLVM_LIBC_SRC_STRING_STRDUP_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strdup(const char *src);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRDUP_H
diff --git a/src/string/strerror.cpp b/src/string/strerror.cpp
index 01cbbeb..9576754 100644
--- a/src/string/strerror.cpp
+++ b/src/string/strerror.cpp
@@ -9,11 +9,12 @@
 #include "src/string/strerror.h"
 #include "src/__support/StringUtil/error_to_string.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strerror, (int err_num)) {
   return const_cast<char *>(get_error_string(err_num).data());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strerror.h b/src/string/strerror.h
index 36a1348..d819795 100644
--- a/src/string/strerror.h
+++ b/src/string/strerror.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRERROR_H
 #define LLVM_LIBC_SRC_STRING_STRERROR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strerror(int err_num);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRERROR_H
diff --git a/src/string/strerror_r.cpp b/src/string/strerror_r.cpp
index c514dbd..ba23f27 100644
--- a/src/string/strerror_r.cpp
+++ b/src/string/strerror_r.cpp
@@ -9,10 +9,11 @@
 #include "src/string/strerror_r.h"
 #include "src/__support/StringUtil/error_to_string.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This is the gnu version of strerror_r. The XSI version may be added later.
 LLVM_LIBC_FUNCTION(char *, strerror_r,
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(char *, strerror_r,
   return const_cast<char *>(get_error_string(err_num, {buf, buflen}).data());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strerror_r.h b/src/string/strerror_r.h
index 63f5958..5a17d29 100644
--- a/src/string/strerror_r.h
+++ b/src/string/strerror_r.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRERROR_R_H
 #define LLVM_LIBC_SRC_STRING_STRERROR_R_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strerror_r(int err_num, char *buf, size_t buflen);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRERROR_R_H
diff --git a/src/string/string_utils.h b/src/string/string_utils.h
index 17efc12..fc617bd 100644
--- a/src/string/string_utils.h
+++ b/src/string/string_utils.h
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 //
 // Standalone string utility functions. Utilities requiring memory allocations
-// should be placed in allocating_string_utils.h intead.
+// should be placed in allocating_string_utils.h instead.
 //
 //===----------------------------------------------------------------------===//
 
@@ -15,12 +15,13 @@
 #define LLVM_LIBC_SRC_STRING_STRING_UTILS_H
 
 #include "src/__support/CPP/bitset.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/inline_bzero.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include <stddef.h> // For size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 template <typename Word> LIBC_INLINE constexpr Word repeat_byte(Word byte) {
@@ -220,7 +221,7 @@ LIBC_INLINE size_t strlcpy(char *__restrict dst, const char *__restrict src,
     return len;
   size_t n = len < size - 1 ? len : size - 1;
   inline_memcpy(dst, src, n);
-  inline_bzero(dst + n, size - n);
+  dst[n] = '\0';
   return len;
 }
 
@@ -238,14 +239,16 @@ LIBC_INLINE constexpr static char *strrchr_implementation(const char *src,
                                                           int c) {
   char ch = static_cast<char>(c);
   char *last_occurrence = nullptr;
-  for (; *src; ++src) {
+  while (true) {
     if (*src == ch)
       last_occurrence = const_cast<char *>(src);
+    if (!*src)
+      return last_occurrence;
+    ++src;
   }
-  return last_occurrence;
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif //  LLVM_LIBC_SRC_STRING_STRING_UTILS_H
diff --git a/src/string/strlcat.cpp b/src/string/strlcat.cpp
index 2943f4f..b5c4c63 100644
--- a/src/string/strlcat.cpp
+++ b/src/string/strlcat.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strlcat.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, strlcat,
                    (char *__restrict dst, const char *__restrict src,
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(size_t, strlcat,
   return first_len + internal::strlcpy(new_dst, src, size - first_len);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strlcat.h b/src/string/strlcat.h
index 47f27e3..9dc8f3a 100644
--- a/src/string/strlcat.h
+++ b/src/string/strlcat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRLCAT_H
 #define LLVM_LIBC_SRC_STRING_STRLCAT_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strlcat(char *__restrict dst, const char *__restrict src, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRLCAT_H
diff --git a/src/string/strlcpy.cpp b/src/string/strlcpy.cpp
index 9b296f2..68d5b58 100644
--- a/src/string/strlcpy.cpp
+++ b/src/string/strlcpy.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strlcpy.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, strlcpy,
                    (char *__restrict dst, const char *__restrict src,
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(size_t, strlcpy,
   return internal::strlcpy(dst, src, size);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strlcpy.h b/src/string/strlcpy.h
index 0c18d85..45b2c2a 100644
--- a/src/string/strlcpy.h
+++ b/src/string/strlcpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRLCPY_H
 #define LLVM_LIBC_SRC_STRING_STRLCPY_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strlcpy(char *__restrict dst, const char *__restrict src, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRLCPY_H
diff --git a/src/string/strlen.cpp b/src/string/strlen.cpp
index b903928..ff7ab14 100644
--- a/src/string/strlen.cpp
+++ b/src/string/strlen.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strlen.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: investigate the performance of this function.
 // There might be potential for compiler optimization.
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(size_t, strlen, (const char *src)) {
   return internal::string_length(src);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strlen.h b/src/string/strlen.h
index 4dfaf8e..093edcf 100644
--- a/src/string/strlen.h
+++ b/src/string/strlen.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRLEN_H
 #define LLVM_LIBC_SRC_STRING_STRLEN_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strlen(const char *src);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRLEN_H
diff --git a/src/string/strncasecmp.cpp b/src/string/strncasecmp.cpp
index 994fb25..45f82c9 100644
--- a/src/string/strncasecmp.cpp
+++ b/src/string/strncasecmp.cpp
@@ -10,9 +10,10 @@
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strcmp.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strncasecmp,
                    (const char *left, const char *right, size_t n)) {
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, strncasecmp,
   return inline_strncmp(left, right, n, case_cmp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strncasecmp.h b/src/string/strncasecmp.h
index eb11550..15f7499 100644
--- a/src/string/strncasecmp.h
+++ b/src/string/strncasecmp.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNCASECMP_H
 #define LLVM_LIBC_SRC_STRING_STRNCASECMP_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int strncasecmp(const char *left, const char *right, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNCASECMP_H
diff --git a/src/string/strncat.cpp b/src/string/strncat.cpp
index ca86d9c..221881f 100644
--- a/src/string/strncat.cpp
+++ b/src/string/strncat.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strncat.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 #include "src/string/strncpy.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strncat,
                    (char *__restrict dest, const char *__restrict src,
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(char *, strncat,
   return dest;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strncat.h b/src/string/strncat.h
index f3d9706..f37d9a7 100644
--- a/src/string/strncat.h
+++ b/src/string/strncat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNCAT_H
 #define LLVM_LIBC_SRC_STRING_STRNCAT_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strncat(char *__restrict dest, const char *__restrict src, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNCAT_H
diff --git a/src/string/strncmp.cpp b/src/string/strncmp.cpp
index 0d2a668..16d4601 100644
--- a/src/string/strncmp.cpp
+++ b/src/string/strncmp.cpp
@@ -9,11 +9,12 @@
 #include "src/string/strncmp.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strcmp.h"
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, strncmp,
                    (const char *left, const char *right, size_t n)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, strncmp,
   return inline_strncmp(left, right, n, comp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strncmp.h b/src/string/strncmp.h
index adb270f..cf40d69 100644
--- a/src/string/strncmp.h
+++ b/src/string/strncmp.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNCMP_H
 #define LLVM_LIBC_SRC_STRING_STRNCMP_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int strncmp(const char *left, const char *right, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNCMP_H
diff --git a/src/string/strncpy.cpp b/src/string/strncpy.cpp
index 1408e7f..4976ad9 100644
--- a/src/string/strncpy.cpp
+++ b/src/string/strncpy.cpp
@@ -9,9 +9,10 @@
 #include "src/string/strncpy.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strncpy,
                    (char *__restrict dest, const char *__restrict src,
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(char *, strncpy,
   return dest;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strncpy.h b/src/string/strncpy.h
index 3152fef..5cef6d0 100644
--- a/src/string/strncpy.h
+++ b/src/string/strncpy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNCPY_H
 #define LLVM_LIBC_SRC_STRING_STRNCPY_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strncpy(char *__restrict dest, const char *__restrict src, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNCPY_H
diff --git a/src/string/strndup.cpp b/src/string/strndup.cpp
index 6648e22..b19d7c0 100644
--- a/src/string/strndup.cpp
+++ b/src/string/strndup.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strndup.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/string_utils.h"
 
@@ -15,7 +16,7 @@
 
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strndup, (const char *src, size_t size)) {
   if (src == nullptr)
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(char *, strndup, (const char *src, size_t size)) {
   return dest;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strndup.h b/src/string/strndup.h
index 3e5c951..78cde7b 100644
--- a/src/string/strndup.h
+++ b/src/string/strndup.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNDUP_H
 #define LLVM_LIBC_SRC_STRING_STRNDUP_H
 
-#include <string.h>
+#include "include/llvm-libc-types/size_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *strndup(const char *src, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNDUP_H
diff --git a/src/string/strnlen.cpp b/src/string/strnlen.cpp
index 8849fa0..26fcd5a 100644
--- a/src/string/strnlen.cpp
+++ b/src/string/strnlen.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strnlen.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, strnlen, (const char *src, size_t n)) {
   const void *temp = internal::find_first_character(
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(size_t, strnlen, (const char *src, size_t n)) {
   return temp ? reinterpret_cast<const char *>(temp) - src : n;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strnlen.h b/src/string/strnlen.h
index e18d217..37a5485 100644
--- a/src/string/strnlen.h
+++ b/src/string/strnlen.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRNLEN_H
 #define LLVM_LIBC_SRC_STRING_STRNLEN_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strnlen(const char *src, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRNLEN_H
diff --git a/src/string/strpbrk.cpp b/src/string/strpbrk.cpp
index 8bccda0..844d77e 100644
--- a/src/string/strpbrk.cpp
+++ b/src/string/strpbrk.cpp
@@ -9,13 +9,14 @@
 #include "src/string/strpbrk.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strpbrk, (const char *src, const char *breakset)) {
   src += internal::complementary_span(src, breakset);
   return *src ? const_cast<char *>(src) : nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strpbrk.h b/src/string/strpbrk.h
index c744d09..a1f329f 100644
--- a/src/string/strpbrk.h
+++ b/src/string/strpbrk.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRPBRK_H
 #define LLVM_LIBC_SRC_STRING_STRPBRK_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strpbrk(const char *src, const char *breakset);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRPBRK_H
diff --git a/src/string/strrchr.cpp b/src/string/strrchr.cpp
index d51808b..66d1aaa 100644
--- a/src/string/strrchr.cpp
+++ b/src/string/strrchr.cpp
@@ -9,12 +9,13 @@
 #include "src/string/strrchr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strrchr, (const char *src, int c)) {
   return internal::strrchr_implementation(src, c);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strrchr.h b/src/string/strrchr.h
index d4280d8..2f95e2d 100644
--- a/src/string/strrchr.h
+++ b/src/string/strrchr.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRRCHR_H
 #define LLVM_LIBC_SRC_STRING_STRRCHR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strrchr(const char *src, int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRRCHR_H
diff --git a/src/string/strsep.cpp b/src/string/strsep.cpp
index 5ebf255..4c27512 100644
--- a/src/string/strsep.cpp
+++ b/src/string/strsep.cpp
@@ -8,9 +8,10 @@
 
 #include "src/string/strsep.h"
 
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strsep,
                    (char **__restrict stringp, const char *__restrict delim)) {
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(char *, strsep,
   return internal::string_token<false>(*stringp, delim, stringp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strsep.h b/src/string/strsep.h
index 7b85202..9ee3081 100644
--- a/src/string/strsep.h
+++ b/src/string/strsep.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRSEP_H
 #define LLVM_LIBC_SRC_STRING_STRSEP_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strsep(char **__restrict stringp, const char *__restrict delim);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRSEP_H
diff --git a/src/string/strsignal.cpp b/src/string/strsignal.cpp
index f6ca0bc..a3206a5 100644
--- a/src/string/strsignal.cpp
+++ b/src/string/strsignal.cpp
@@ -10,11 +10,12 @@
 #include "src/string/strsignal.h"
 #include "src/__support/StringUtil/signal_to_string.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strsignal, (int sig_num)) {
   return const_cast<char *>(get_signal_string(sig_num).data());
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strsignal.h b/src/string/strsignal.h
index bd3f87a..9f62820 100644
--- a/src/string/strsignal.h
+++ b/src/string/strsignal.h
@@ -10,10 +10,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRSIGNAL_H
 #define LLVM_LIBC_SRC_STRING_STRSIGNAL_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strsignal(int sig_num);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRSIGNAL_H
diff --git a/src/string/strspn.cpp b/src/string/strspn.cpp
index b957f8e..66bb399 100644
--- a/src/string/strspn.cpp
+++ b/src/string/strspn.cpp
@@ -10,9 +10,10 @@
 
 #include "src/__support/CPP/bitset.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(size_t, strspn, (const char *src, const char *segment)) {
   const char *initial = src;
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(size_t, strspn, (const char *src, const char *segment)) {
   return src - initial;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strspn.h b/src/string/strspn.h
index ddb6f38..a13b504 100644
--- a/src/string/strspn.h
+++ b/src/string/strspn.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRSPN_H
 #define LLVM_LIBC_SRC_STRING_STRSPN_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strspn(const char *src, const char *segment);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRSPN_H
diff --git a/src/string/strstr.cpp b/src/string/strstr.cpp
index bfda75b..5132f06 100644
--- a/src/string/strstr.cpp
+++ b/src/string/strstr.cpp
@@ -9,9 +9,10 @@
 #include "src/string/strstr.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_strstr.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: This is a simple brute force implementation. This can be
 // improved upon using well known string matching algorithms.
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(char *, strstr, (const char *haystack, const char *needle)) {
   return inline_strstr(haystack, needle, comp);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strstr.h b/src/string/strstr.h
index 2501b00..903e02e 100644
--- a/src/string/strstr.h
+++ b/src/string/strstr.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRSTR_H
 #define LLVM_LIBC_SRC_STRING_STRSTR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strstr(const char *haystack, const char *needle);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRSTR_H
diff --git a/src/string/strtok.cpp b/src/string/strtok.cpp
index e7d3034..f491c64 100644
--- a/src/string/strtok.cpp
+++ b/src/string/strtok.cpp
@@ -9,9 +9,10 @@
 #include "src/string/strtok.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static char *strtok_str = nullptr;
 
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(char *, strtok,
   return internal::string_token(src, delimiter_string, &strtok_str);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strtok.h b/src/string/strtok.h
index 8788f33..9f44cb3 100644
--- a/src/string/strtok.h
+++ b/src/string/strtok.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRTOK_H
 #define LLVM_LIBC_SRC_STRING_STRTOK_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strtok(char *__restrict src, const char *__restrict delimiter_string);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRTOK_H
diff --git a/src/string/strtok_r.cpp b/src/string/strtok_r.cpp
index e8847b6..9594216 100644
--- a/src/string/strtok_r.cpp
+++ b/src/string/strtok_r.cpp
@@ -9,9 +9,10 @@
 #include "src/string/strtok_r.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(char *, strtok_r,
                    (char *__restrict src,
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(char *, strtok_r,
   return internal::string_token(src, delimiter_string, saveptr);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strtok_r.h b/src/string/strtok_r.h
index b3c7b3d..ae5d39a 100644
--- a/src/string/strtok_r.h
+++ b/src/string/strtok_r.h
@@ -9,11 +9,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRTOK_R_H
 #define LLVM_LIBC_SRC_STRING_STRTOK_R_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 char *strtok_r(char *__restrict src, const char *__restrict delimiter_string,
                char **__restrict saveptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRTOK_R_H
diff --git a/src/string/strxfrm.cpp b/src/string/strxfrm.cpp
index b5eb764..212124e 100644
--- a/src/string/strxfrm.cpp
+++ b/src/string/strxfrm.cpp
@@ -7,12 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/string/strxfrm.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/string_utils.h"
 
 #include "src/__support/common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: Add support for locales.
 LLVM_LIBC_FUNCTION(size_t, strxfrm,
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(size_t, strxfrm,
   return len;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strxfrm.h b/src/string/strxfrm.h
index 8178931..3c19d10 100644
--- a/src/string/strxfrm.h
+++ b/src/string/strxfrm.h
@@ -9,11 +9,12 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRXFRM_H
 #define LLVM_LIBC_SRC_STRING_STRXFRM_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h> // For size_t
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 size_t strxfrm(char *__restrict dest, const char *__restrict src, size_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_STRING_STRXFRM_H
diff --git a/src/string/strxfrm_l.cpp b/src/string/strxfrm_l.cpp
new file mode 100644
index 0000000..ae758e1
--- /dev/null
+++ b/src/string/strxfrm_l.cpp
@@ -0,0 +1,28 @@
+//===-- Implementation of strxfrm_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/string/strxfrm_l.h"
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_memcpy.h"
+#include "src/string/string_utils.h"
+
+#include "src/__support/common.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO: Add support for locales.
+LLVM_LIBC_FUNCTION(size_t, strxfrm_l,
+                   (char *__restrict dest, const char *__restrict src, size_t n,
+                    locale_t)) {
+  size_t len = internal::string_length(src);
+  if (n > len)
+    inline_memcpy(dest, src, len + 1);
+  return len;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/string/strxfrm_l.h b/src/string/strxfrm_l.h
new file mode 100644
index 0000000..af0f181
--- /dev/null
+++ b/src/string/strxfrm_l.h
@@ -0,0 +1,23 @@
+//===-- Implementation header for strxfrm_l ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRING_STRXFRM_L_H
+#define LLVM_LIBC_SRC_STRING_STRXFRM_L_H
+
+#include "include/llvm-libc-types/locale_t.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h> // For size_t
+
+namespace LIBC_NAMESPACE_DECL {
+
+size_t strxfrm_l(char *__restrict dest, const char *__restrict src, size_t n,
+                 locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRING_STRXFRM_L_H
diff --git a/src/sys/auxv/getauxval.h b/src/sys/auxv/getauxval.h
index 7c9fb84..d9da45f 100644
--- a/src/sys/auxv/getauxval.h
+++ b/src/sys/auxv/getauxval.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_AUXV_GETAUXVAL_H
 #define LLVM_LIBC_SRC_SYS_AUXV_GETAUXVAL_H
 
-#include <sys/auxv.h>
+#include "hdr/sys_auxv_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 unsigned long getauxval(unsigned long id);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_AUXV_GETAUXVAL_H
diff --git a/src/sys/auxv/linux/getauxval.cpp b/src/sys/auxv/linux/getauxval.cpp
index b0db367..236fd25 100644
--- a/src/sys/auxv/linux/getauxval.cpp
+++ b/src/sys/auxv/linux/getauxval.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/sys/auxv/getauxval.h"
-#include "config/linux/app.h"
+#include "config/app.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <linux/auxvec.h>
 
@@ -35,7 +36,7 @@
 extern "C" [[gnu::weak]] int __cxa_atexit(void (*callback)(void *),
                                           void *payload, void *);
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr static size_t MAX_AUXV_ENTRIES = 64;
 
@@ -154,7 +155,7 @@ static void initialize_auxv_once(void) {
 
 static AuxEntry read_entry(int fd) {
   AuxEntry buf;
-  ssize_t size = sizeof(AuxEntry);
+  size_t size = sizeof(AuxEntry);
   char *ptr = reinterpret_cast<char *>(&buf);
   while (size > 0) {
     ssize_t ret = read(fd, ptr, size);
@@ -214,4 +215,4 @@ LLVM_LIBC_FUNCTION(unsigned long, getauxval, (unsigned long id)) {
   errno_guard.mark_failure();
   return AT_NULL;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/epoll_create.h b/src/sys/epoll/epoll_create.h
index a1eeabd..95c4122 100644
--- a/src/sys/epoll/epoll_create.h
+++ b/src/sys/epoll/epoll_create.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE_H
 #define LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int epoll_create(int size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE_H
diff --git a/src/sys/epoll/epoll_create1.h b/src/sys/epoll/epoll_create1.h
index 70f446b..c9e0e98 100644
--- a/src/sys/epoll/epoll_create1.h
+++ b/src/sys/epoll/epoll_create1.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE1_H
 #define LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE1_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int epoll_create1(int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CREATE1_H
diff --git a/src/sys/epoll/epoll_ctl.h b/src/sys/epoll/epoll_ctl.h
index 4240294..55784bc 100644
--- a/src/sys/epoll/epoll_ctl.h
+++ b/src/sys/epoll/epoll_ctl.h
@@ -10,12 +10,13 @@
 #define LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CTL_H
 
 #include "hdr/types/struct_epoll_event.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: event should be nullable
 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_CTL_H
diff --git a/src/sys/epoll/epoll_pwait.h b/src/sys/epoll/epoll_pwait.h
index bcae72b..8b881ce 100644
--- a/src/sys/epoll/epoll_pwait.h
+++ b/src/sys/epoll/epoll_pwait.h
@@ -11,13 +11,14 @@
 
 #include "hdr/types/sigset_t.h"
 #include "hdr/types/struct_epoll_event.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: sigmask should be nullable
 int epoll_pwait(int epfd, struct epoll_event *events, int maxevents,
                 int timeout, const sigset_t *sigmask);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_PWAIT_H
diff --git a/src/sys/epoll/epoll_pwait2.h b/src/sys/epoll/epoll_pwait2.h
index 7fc528b..b7a7220 100644
--- a/src/sys/epoll/epoll_pwait2.h
+++ b/src/sys/epoll/epoll_pwait2.h
@@ -12,13 +12,14 @@
 #include "hdr/types/sigset_t.h"
 #include "hdr/types/struct_epoll_event.h"
 #include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: sigmask and timeout should be nullable
 int epoll_pwait2(int epfd, epoll_event *events, int maxevents,
                  const timespec *timeout, const sigset_t *sigmask);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_PWAIT2_H
diff --git a/src/sys/epoll/epoll_wait.h b/src/sys/epoll/epoll_wait.h
index b546e91..cd9aa8b 100644
--- a/src/sys/epoll/epoll_wait.h
+++ b/src/sys/epoll/epoll_wait.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_WAIT_H
 
 #include "hdr/types/struct_epoll_event.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_EPOLL_EPOLL_WAIT_H
diff --git a/src/sys/epoll/linux/epoll_create.cpp b/src/sys/epoll/linux/epoll_create.cpp
index d4995c4..7196ac7 100644
--- a/src/sys/epoll/linux/epoll_create.cpp
+++ b/src/sys/epoll/linux/epoll_create.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_create, ([[maybe_unused]] int size)) {
 #ifdef SYS_epoll_create
@@ -35,4 +36,4 @@ LLVM_LIBC_FUNCTION(int, epoll_create, ([[maybe_unused]] int size)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/linux/epoll_create1.cpp b/src/sys/epoll/linux/epoll_create1.cpp
index 30f1a99..efff282 100644
--- a/src/sys/epoll/linux/epoll_create1.cpp
+++ b/src/sys/epoll/linux/epoll_create1.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_create1, (int flags)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_epoll_create1, flags);
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, epoll_create1, (int flags)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/linux/epoll_ctl.cpp b/src/sys/epoll/linux/epoll_ctl.cpp
index c111c5e..5f7dbb7 100644
--- a/src/sys/epoll/linux/epoll_ctl.cpp
+++ b/src/sys/epoll/linux/epoll_ctl.cpp
@@ -11,10 +11,11 @@
 #include "hdr/types/struct_epoll_event.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_ctl,
                    (int epfd, int op, int fd, epoll_event *event)) {
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, epoll_ctl,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/linux/epoll_pwait.cpp b/src/sys/epoll/linux/epoll_pwait.cpp
index 24b66f0..d783654 100644
--- a/src/sys/epoll/linux/epoll_pwait.cpp
+++ b/src/sys/epoll/linux/epoll_pwait.cpp
@@ -13,12 +13,13 @@
 #include "hdr/types/struct_epoll_event.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_pwait,
                    (int epfd, struct epoll_event *events, int maxevents,
@@ -39,4 +40,4 @@ LLVM_LIBC_FUNCTION(int, epoll_pwait,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/linux/epoll_pwait2.cpp b/src/sys/epoll/linux/epoll_pwait2.cpp
index e13423a..14b4193 100644
--- a/src/sys/epoll/linux/epoll_pwait2.cpp
+++ b/src/sys/epoll/linux/epoll_pwait2.cpp
@@ -14,12 +14,13 @@
 #include "hdr/types/struct_timespec.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_pwait2,
                    (int epfd, struct epoll_event *events, int maxevents,
@@ -41,4 +42,4 @@ LLVM_LIBC_FUNCTION(int, epoll_pwait2,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/epoll/linux/epoll_wait.cpp b/src/sys/epoll/linux/epoll_wait.cpp
index 3ce4a92..1a63be5 100644
--- a/src/sys/epoll/linux/epoll_wait.cpp
+++ b/src/sys/epoll/linux/epoll_wait.cpp
@@ -13,12 +13,13 @@
 #include "hdr/types/struct_epoll_event.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, epoll_wait,
                    (int epfd, struct epoll_event *events, int maxevents,
@@ -45,4 +46,4 @@ LLVM_LIBC_FUNCTION(int, epoll_wait,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/madvise.cpp b/src/sys/mman/linux/madvise.cpp
index ff461c1..332d6c2 100644
--- a/src/sys/mman/linux/madvise.cpp
+++ b/src/sys/mman/linux/madvise.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is currently linux only. It has to be refactored suitably if
 // madvise is to be supported on non-linux operating systems also.
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, madvise, (void *addr, size_t size, int advice)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mincore.cpp b/src/sys/mman/linux/mincore.cpp
index 8220c69..b5436fd 100644
--- a/src/sys/mman/linux/mincore.cpp
+++ b/src/sys/mman/linux/mincore.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, mincore, (void *addr, size_t len, unsigned char *vec)) {
   long ret = syscall_impl(SYS_mincore, reinterpret_cast<long>(addr), len,
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, mincore, (void *addr, size_t len, unsigned char *vec)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mlock.cpp b/src/sys/mman/linux/mlock.cpp
index 9bc5ab9..be7eb28 100644
--- a/src/sys/mman/linux/mlock.cpp
+++ b/src/sys/mman/linux/mlock.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, mlock, (const void *addr, size_t len)) {
   long ret = syscall_impl(SYS_mlock, cpp::bit_cast<long>(addr), len);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, mlock, (const void *addr, size_t len)) {
   }
   return 0;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mlock2.cpp b/src/sys/mman/linux/mlock2.cpp
index 71b2b80..7bc557f 100644
--- a/src/sys/mman/linux/mlock2.cpp
+++ b/src/sys/mman/linux/mlock2.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 #ifdef SYS_mlock2
 LLVM_LIBC_FUNCTION(int, mlock2, (const void *addr, size_t len, int flags)) {
   long ret = syscall_impl(SYS_mlock2, cpp::bit_cast<long>(addr), len, flags);
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, mlock2, (const void *addr, size_t len, int flags)) {
   return 0;
 }
 #endif
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mlockall.cpp b/src/sys/mman/linux/mlockall.cpp
index c4af7d8..eae3a9e 100644
--- a/src/sys/mman/linux/mlockall.cpp
+++ b/src/sys/mman/linux/mlockall.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, mlockall, (int flags)) {
   long ret = syscall_impl(SYS_mlockall, flags);
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, mlockall, (int flags)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mmap.cpp b/src/sys/mman/linux/mmap.cpp
index 16111c6..ee9a0a3 100644
--- a/src/sys/mman/linux/mmap.cpp
+++ b/src/sys/mman/linux/mmap.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <linux/param.h> // For EXEC_PAGESIZE.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is currently linux only. It has to be refactored suitably if
 // mmap is to be supported on non-linux operating systems also.
@@ -39,9 +40,12 @@ LLVM_LIBC_FUNCTION(void *, mmap,
 #error "mmap or mmap2 syscalls not available."
 #endif
 
+  // We add an explicit cast to silence a "implicit conversion loses integer
+  // precision" warning when compiling for 32-bit systems.
+  long mmap_offset = static_cast<long>(offset);
   long ret =
       LIBC_NAMESPACE::syscall_impl(syscall_number, reinterpret_cast<long>(addr),
-                                   size, prot, flags, fd, offset);
+                                   size, prot, flags, fd, mmap_offset);
 
   // The mmap/mmap2 syscalls return negative values on error. These negative
   // values are actually the negative values of the error codes. So, fix them
@@ -60,4 +64,4 @@ LLVM_LIBC_FUNCTION(void *, mmap,
   return reinterpret_cast<void *>(ret);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mprotect.cpp b/src/sys/mman/linux/mprotect.cpp
index 2e6f2a3..e235102 100644
--- a/src/sys/mman/linux/mprotect.cpp
+++ b/src/sys/mman/linux/mprotect.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is currently linux only. It has to be refactored suitably if
 // mprotect is to be supported on non-linux operating systems also.
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, mprotect, (void *addr, size_t size, int prot)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/mremap.cpp b/src/sys/mman/linux/mremap.cpp
new file mode 100644
index 0000000..38bcfce
--- /dev/null
+++ b/src/sys/mman/linux/mremap.cpp
@@ -0,0 +1,45 @@
+//===---------- Linux implementation of the POSIX mremap function----------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/mman/mremap.h"
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include <linux/param.h> // For EXEC_PAGESIZE.
+#include <stdarg.h>
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, mremap,
+                   (void *old_address, size_t old_size, size_t new_size,
+                    int flags, ... /* void *new_address */)) {
+
+  long ret = 0;
+  void *new_address = nullptr;
+  if (flags & MREMAP_FIXED) {
+    va_list varargs;
+    va_start(varargs, flags);
+    new_address = va_arg(varargs, void *);
+    va_end(varargs);
+  }
+  ret = LIBC_NAMESPACE::syscall_impl<long>(SYS_mremap, old_address, old_size,
+                                           new_size, flags, new_address);
+
+  if (ret < 0 && ret > -EXEC_PAGESIZE) {
+    libc_errno = static_cast<int>(-ret);
+    return MAP_FAILED;
+  }
+
+  return reinterpret_cast<void *>(ret);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/msync.cpp b/src/sys/mman/linux/msync.cpp
index 1d2544f..e2b4f81 100644
--- a/src/sys/mman/linux/msync.cpp
+++ b/src/sys/mman/linux/msync.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, msync, (void *addr, size_t len, int flags)) {
   long ret = syscall_impl(SYS_msync, cpp::bit_cast<long>(addr), len, flags);
   if (ret < 0) {
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, msync, (void *addr, size_t len, int flags)) {
   }
   return 0;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/munlock.cpp b/src/sys/mman/linux/munlock.cpp
index 9ee5080..93c25f8 100644
--- a/src/sys/mman/linux/munlock.cpp
+++ b/src/sys/mman/linux/munlock.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, munlock, (const void *addr, size_t len)) {
   long ret = syscall_impl(SYS_munlock, cpp::bit_cast<long>(addr), len);
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, munlock, (const void *addr, size_t len)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/munlockall.cpp b/src/sys/mman/linux/munlockall.cpp
index d1619d2..f5911cb 100644
--- a/src/sys/mman/linux/munlockall.cpp
+++ b/src/sys/mman/linux/munlockall.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, munlockall, (void)) {
   long ret = syscall_impl(SYS_munlockall);
@@ -24,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, munlockall, (void)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/munmap.cpp b/src/sys/mman/linux/munmap.cpp
index 6412b41..9c01b15 100644
--- a/src/sys/mman/linux/munmap.cpp
+++ b/src/sys/mman/linux/munmap.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h>          // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is currently linux only. It has to be refactored suitably if
 // mmap is to be supported on non-linux operating systems also.
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, munmap, (void *addr, size_t size)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/posix_madvise.cpp b/src/sys/mman/linux/posix_madvise.cpp
index b7b4d35..e980ca4 100644
--- a/src/sys/mman/linux/posix_madvise.cpp
+++ b/src/sys/mman/linux/posix_madvise.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This function is currently linux only. It has to be refactored suitably if
 // posix_madvise is to be supported on non-linux operating systems also.
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, posix_madvise, (void *addr, size_t size, int advice)) {
   return ret < 0 ? -ret : 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/process_mrelease.cpp b/src/sys/mman/linux/process_mrelease.cpp
new file mode 100644
index 0000000..7660f1e
--- /dev/null
+++ b/src/sys/mman/linux/process_mrelease.cpp
@@ -0,0 +1,41 @@
+//===---------- Linux implementation of the mrelease function -----------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/mman/process_mrelease.h"
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include <linux/param.h> // For EXEC_PAGESIZE.
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, process_mrelease, (int pidfd, unsigned int flags)) {
+#ifdef SYS_process_mrelease
+  long ret =
+      LIBC_NAMESPACE::syscall_impl<int>(SYS_process_mrelease, pidfd, flags);
+
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+
+  return 0;
+#else
+  // The system call is not available.
+  (void)pidfd;
+  (void)flags;
+  libc_errno = ENOSYS;
+  return -1;
+#endif
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/remap_file_pages.cpp b/src/sys/mman/linux/remap_file_pages.cpp
new file mode 100644
index 0000000..f616e19
--- /dev/null
+++ b/src/sys/mman/linux/remap_file_pages.cpp
@@ -0,0 +1,40 @@
+//===------- Linux implementation of the remap_file_pages function --------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/mman/remap_file_pages.h"
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, remap_file_pages,
+                   (void *addr, size_t size, int prot, size_t pgoff,
+                    int flags)) {
+#ifdef SYS_remap_file_pages
+  int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_remap_file_pages,
+                                              reinterpret_cast<long>(addr),
+                                              size, prot, pgoff, flags);
+#else
+#error "remap_file_pages syscall is not available."
+#endif
+
+  // A negative return value indicates an error with the magnitude of the
+  // value being the error code.
+  if (ret < 0) {
+    libc_errno = -ret;
+    return -1;
+  }
+
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/shm_common.h b/src/sys/mman/linux/shm_common.h
index 6f2a3fd..ce75c2b 100644
--- a/src/sys/mman/linux/shm_common.h
+++ b/src/sys/mman/linux/shm_common.h
@@ -9,13 +9,14 @@
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/string/memory_utils/inline_memcpy.h"
 
 // TODO: Get PATH_MAX via https://github.com/llvm/llvm-project/issues/85121
 #include <linux/limits.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace shm_common {
 
@@ -50,4 +51,4 @@ LIBC_INLINE cpp::optional<SHMPath> translate_name(cpp::string_view name) {
 }
 } // namespace shm_common
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/shm_open.cpp b/src/sys/mman/linux/shm_open.cpp
index 0d39b8b..11de482 100644
--- a/src/sys/mman/linux/shm_open.cpp
+++ b/src/sys/mman/linux/shm_open.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/sys/mman/shm_open.h"
-#include "llvm-libc-macros/fcntl-macros.h"
+#include "hdr/types/mode_t.h"
+#include "src/__support/macros/config.h"
 #include "src/fcntl/open.h"
 #include "src/sys/mman/linux/shm_common.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static constexpr int DEFAULT_OFLAGS = O_NOFOLLOW | O_CLOEXEC | O_NONBLOCK;
 
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, shm_open, (const char *name, int oflags, mode_t mode)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/shm_unlink.cpp b/src/sys/mman/linux/shm_unlink.cpp
index 32f48d3..6a76301 100644
--- a/src/sys/mman/linux/shm_unlink.cpp
+++ b/src/sys/mman/linux/shm_unlink.cpp
@@ -7,10 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/sys/mman/shm_unlink.h"
+#include "src/__support/macros/config.h"
 #include "src/sys/mman/linux/shm_common.h"
 #include "src/unistd/unlink.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, shm_unlink, (const char *name)) {
   using namespace shm_common;
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(int, shm_unlink, (const char *name)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/madvise.h b/src/sys/mman/madvise.h
index 59a03af..fcc9289 100644
--- a/src/sys/mman/madvise.h
+++ b/src/sys/mman/madvise.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MADVISE_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MADVISE_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t and off_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int madvise(void *addr, size_t size, int advice);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MADVISE_H
diff --git a/src/sys/mman/mincore.h b/src/sys/mman/mincore.h
index 403afae..4b50a19 100644
--- a/src/sys/mman/mincore.h
+++ b/src/sys/mman/mincore.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MINCORE_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MINCORE_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mincore(void *addr, size_t len, unsigned char *vec);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MINCORE_H
diff --git a/src/sys/mman/mlock.h b/src/sys/mman/mlock.h
index 73f329a..034a4f5 100644
--- a/src/sys/mman/mlock.h
+++ b/src/sys/mman/mlock.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MLOCK_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 #include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mlock(const void *addr, size_t len);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MLOCK_H
diff --git a/src/sys/mman/mlock2.h b/src/sys/mman/mlock2.h
index 872a7bf..9bba06a 100644
--- a/src/sys/mman/mlock2.h
+++ b/src/sys/mman/mlock2.h
@@ -9,15 +9,16 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MLOCK2_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MLOCK2_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 #include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #ifdef SYS_mlock2
 int mlock2(const void *addr, size_t len, int flags);
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MLOCK2_H
diff --git a/src/sys/mman/mlockall.h b/src/sys/mman/mlockall.h
index bb4bd83..8e305bb 100644
--- a/src/sys/mman/mlockall.h
+++ b/src/sys/mman/mlockall.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MLOCKALL_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MLOCKALL_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mlockall(int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MLOCKALL_H
diff --git a/src/sys/mman/mmap.h b/src/sys/mman/mmap.h
index 4425019..b33be35 100644
--- a/src/sys/mman/mmap.h
+++ b/src/sys/mman/mmap.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MMAP_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MMAP_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t and off_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *mmap(void *addr, size_t size, int prot, int flags, int fd, off_t offset);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MMAP_H
diff --git a/src/sys/mman/mprotect.h b/src/sys/mman/mprotect.h
index 2e59c75..890e985 100644
--- a/src/sys/mman/mprotect.h
+++ b/src/sys/mman/mprotect.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MPROTECT_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MPROTECT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t and off_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mprotect(void *addr, size_t size, int prot);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MPROTECT_H
diff --git a/src/sys/mman/mremap.h b/src/sys/mman/mremap.h
new file mode 100644
index 0000000..208946b
--- /dev/null
+++ b/src/sys/mman/mremap.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for mremap function -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_MMAN_MREMAP_H
+#define LLVM_LIBC_SRC_SYS_MMAN_MREMAP_H
+
+#include "src/__support/macros/config.h"
+#include <sys/mman.h> // For size_t and off_t
+
+namespace LIBC_NAMESPACE_DECL {
+
+void *mremap(void *old_address, size_t old_size, size_t new_size, int flags,
+             ... /* void *new_address */);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_MMAN_MREMAP_H
diff --git a/src/sys/mman/msync.h b/src/sys/mman/msync.h
index 08afdd8..d20c3f3 100644
--- a/src/sys/mman/msync.h
+++ b/src/sys/mman/msync.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MSYNC_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MSYNC_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 #include <sys/syscall.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int msync(void *addr, size_t len, int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MSYNC_H
diff --git a/src/sys/mman/munlock.h b/src/sys/mman/munlock.h
index 6aca82d..07f6b3b 100644
--- a/src/sys/mman/munlock.h
+++ b/src/sys/mman/munlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MUNLOCK_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MUNLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int munlock(const void *addr, size_t len);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MUNLOCK_H
diff --git a/src/sys/mman/munlockall.h b/src/sys/mman/munlockall.h
index 5abd4b8..f0c632d 100644
--- a/src/sys/mman/munlockall.h
+++ b/src/sys/mman/munlockall.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MUNLOCKALL_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MUNLOCKALL_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int munlockall(void);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MUNLOCKALL_H
diff --git a/src/sys/mman/munmap.h b/src/sys/mman/munmap.h
index 5d7c569..c1fd5d7 100644
--- a/src/sys/mman/munmap.h
+++ b/src/sys/mman/munmap.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_MUNMAP_H
 #define LLVM_LIBC_SRC_SYS_MMAN_MUNMAP_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int munmap(void *addr, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_MUNMAP_H
diff --git a/src/sys/mman/posix_madvise.h b/src/sys/mman/posix_madvise.h
index b8a423b..31ec5f6 100644
--- a/src/sys/mman/posix_madvise.h
+++ b/src/sys/mman/posix_madvise.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_POSIX_MADVISE_H
 #define LLVM_LIBC_SRC_SYS_MMAN_POSIX_MADVISE_H
 
+#include "src/__support/macros/config.h"
 #include <sys/mman.h> // For size_t and off_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int posix_madvise(void *addr, size_t size, int advice);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_POSIX_MADVISE_H
diff --git a/src/sys/mman/process_mrelease.h b/src/sys/mman/process_mrelease.h
new file mode 100644
index 0000000..6c800f2
--- /dev/null
+++ b/src/sys/mman/process_mrelease.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for process_mrelease function -*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
+#define LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
+
+#include "src/__support/macros/config.h"
+#include <sys/mman.h> // For size_t and off_t
+
+namespace LIBC_NAMESPACE_DECL {
+
+int process_mrelease(int pidfd, unsigned int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
diff --git a/src/sys/mman/remap_file_pages.h b/src/sys/mman/remap_file_pages.h
new file mode 100644
index 0000000..5185029
--- /dev/null
+++ b/src/sys/mman/remap_file_pages.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for remap_file_pages function -----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_MMAN_REMAP_FILE_PAGES_H
+#define LLVM_LIBC_SRC_SYS_MMAN_REMAP_FILE_PAGES_H
+
+#include "src/__support/macros/config.h"
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int remap_file_pages(void *addr, size_t size, int prot, size_t pgoff,
+                     int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_MMAN_REMAP_FILE_PAGES_H
diff --git a/src/sys/mman/shm_open.h b/src/sys/mman/shm_open.h
index 91796d7..1872dd3 100644
--- a/src/sys/mman/shm_open.h
+++ b/src/sys/mman/shm_open.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_SHM_OPEN_H
 #define LLVM_LIBC_SRC_SYS_MMAN_SHM_OPEN_H
 
-#include <llvm-libc-types/mode_t.h>
+#include "hdr/types/mode_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int shm_open(const char *name, int oflag, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_SHM_OPEN_H
diff --git a/src/sys/mman/shm_unlink.h b/src/sys/mman/shm_unlink.h
index c38c06a..06ad42b 100644
--- a/src/sys/mman/shm_unlink.h
+++ b/src/sys/mman/shm_unlink.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SYS_MMAN_SHM_UNLINK_H
 #define LLVM_LIBC_SRC_SYS_MMAN_SHM_UNLINK_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int shm_unlink(const char *name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_MMAN_SHM_UNLINK_H
diff --git a/src/sys/prctl/linux/prctl.cpp b/src/sys/prctl/linux/prctl.cpp
index b68b762..5d4e904 100644
--- a/src/sys/prctl/linux/prctl.cpp
+++ b/src/sys/prctl/linux/prctl.cpp
@@ -10,10 +10,11 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, prctl,
                    (int option, unsigned long arg2, unsigned long arg3,
@@ -34,4 +35,4 @@ LLVM_LIBC_FUNCTION(int, prctl,
   return static_cast<int>(ret);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/prctl/prctl.h b/src/sys/prctl/prctl.h
index baa0676..c6b5797 100644
--- a/src/sys/prctl/prctl.h
+++ b/src/sys/prctl/prctl.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SYS_PRCTL_PRCTL_H
 #define LLVM_LIBC_SRC_SYS_PRCTL_PRCTL_H
 
+#include "src/__support/macros/config.h"
 #include <sys/prctl.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int prctl(int option, unsigned long arg2, unsigned long arg3,
           unsigned long arg4, unsigned long arg5);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_PRCTL_PRCTL_H
diff --git a/src/sys/random/getrandom.h b/src/sys/random/getrandom.h
index e1577d9..134bd0c 100644
--- a/src/sys/random/getrandom.h
+++ b/src/sys/random/getrandom.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_RANDOM_GETRANDOM_H
 #define LLVM_LIBC_SRC_SYS_RANDOM_GETRANDOM_H
 
+#include "src/__support/macros/config.h"
 #include <sys/random.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t getrandom(void *buf, size_t buflen, unsigned int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_RANDOM_GETRANDOM_H
diff --git a/src/sys/random/linux/getrandom.cpp b/src/sys/random/linux/getrandom.cpp
index 63038ad..9a8869a 100644
--- a/src/sys/random/linux/getrandom.cpp
+++ b/src/sys/random/linux/getrandom.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, getrandom,
                    (void *buf, size_t buflen, unsigned int flags)) {
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(ssize_t, getrandom,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/resource/getrlimit.h b/src/sys/resource/getrlimit.h
index f473e82..c369744 100644
--- a/src/sys/resource/getrlimit.h
+++ b/src/sys/resource/getrlimit.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_RESOURCE_GETRLIMIT_H
 #define LLVM_LIBC_SRC_SYS_RESOURCE_GETRLIMIT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/resource.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int getrlimit(int resource, struct rlimit *lim);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_RESOURCE_GETRLIMIT_H
diff --git a/src/sys/resource/linux/getrlimit.cpp b/src/sys/resource/linux/getrlimit.cpp
index 4067beb..30c2e91 100644
--- a/src/sys/resource/linux/getrlimit.cpp
+++ b/src/sys/resource/linux/getrlimit.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/resource.h> // For struct rlimit
 #include <sys/syscall.h>  // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, getrlimit, (int res, struct rlimit *limits)) {
   int ret =
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, getrlimit, (int res, struct rlimit *limits)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/resource/linux/setrlimit.cpp b/src/sys/resource/linux/setrlimit.cpp
index 0692763..85f0790 100644
--- a/src/sys/resource/linux/setrlimit.cpp
+++ b/src/sys/resource/linux/setrlimit.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/resource.h> // For struct rlimit
 #include <sys/syscall.h>  // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, setrlimit, (int res, const struct rlimit *limits)) {
   int ret =
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, setrlimit, (int res, const struct rlimit *limits)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/resource/setrlimit.h b/src/sys/resource/setrlimit.h
index d881b59..6f96679 100644
--- a/src/sys/resource/setrlimit.h
+++ b/src/sys/resource/setrlimit.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_RESOURCE_SETRLIMIT_H
 #define LLVM_LIBC_SRC_SYS_RESOURCE_SETRLIMIT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/resource.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int setrlimit(int resource, const struct rlimit *lim);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_RESOURCE_SETRLIMIT_H
diff --git a/src/sys/select/linux/select.cpp b/src/sys/select/linux/select.cpp
index 9034b75..9ccb1e9 100644
--- a/src/sys/select/linux/select.cpp
+++ b/src/sys/select/linux/select.cpp
@@ -13,12 +13,13 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <stddef.h>      // For size_t
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct pselect6_sigset_t {
   sigset_t *ss;
@@ -69,4 +70,4 @@ LLVM_LIBC_FUNCTION(int, select,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/select/select.h b/src/sys/select/select.h
index 65cd15c..be3f5eb 100644
--- a/src/sys/select/select.h
+++ b/src/sys/select/select.h
@@ -9,13 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SYS_SELECT_SELECT_H
 #define LLVM_LIBC_SRC_SYS_SELECT_SELECT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/select.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int select(int nfds, fd_set *__restrict read_set, fd_set *__restrict write_set,
            fd_set *__restrict error_set, struct timeval *__restrict timeout);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_SELECT_SELECT_H
diff --git a/src/sys/sendfile/linux/sendfile.cpp b/src/sys/sendfile/linux/sendfile.cpp
index 5a7c012..9d4174c 100644
--- a/src/sys/sendfile/linux/sendfile.cpp
+++ b/src/sys/sendfile/linux/sendfile.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/sendfile.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, sendfile,
                    (int out_fd, int in_fd, off_t *offset, size_t count)) {
@@ -37,4 +38,4 @@ LLVM_LIBC_FUNCTION(ssize_t, sendfile,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/sendfile/sendfile.h b/src/sys/sendfile/sendfile.h
index 14673bb..95c3fd4 100644
--- a/src/sys/sendfile/sendfile.h
+++ b/src/sys/sendfile/sendfile.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_SENDFILE_SENDFILE_H
 #define LLVM_LIBC_SRC_SYS_SENDFILE_SENDFILE_H
 
+#include "src/__support/macros/config.h"
 #include <sys/sendfile.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t sendfile(int, int, off_t *, size_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_SENDFILE_SENDFILE_H
diff --git a/src/sys/socket/bind.h b/src/sys/socket/bind.h
index 62e6221..619cd9f 100644
--- a/src/sys/socket/bind.h
+++ b/src/sys/socket/bind.h
@@ -9,12 +9,14 @@
 #ifndef LLVM_LIBC_SRC_SYS_SOCKET_BIND_H
 #define LLVM_LIBC_SRC_SYS_SOCKET_BIND_H
 
-#include <sys/socket.h>
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-int bind(int domain, const struct sockaddr *address, socklen_t address_len);
+int bind(int socket, const struct sockaddr *address, socklen_t address_len);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_SOCKET_BIND_H
diff --git a/src/sys/socket/linux/bind.cpp b/src/sys/socket/linux/bind.cpp
index 36afc64..72a3307 100644
--- a/src/sys/socket/linux/bind.cpp
+++ b/src/sys/socket/linux/bind.cpp
@@ -11,21 +11,22 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <linux/net.h>   // For SYS_SOCKET socketcall number.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, bind,
-                   (int domain, const struct sockaddr *address,
+                   (int socket, const struct sockaddr *address,
                     socklen_t address_len)) {
-#ifdef SYS_socket
+#ifdef SYS_bind
   int ret =
-      LIBC_NAMESPACE::syscall_impl<int>(SYS_bind, domain, address, address_len);
+      LIBC_NAMESPACE::syscall_impl<int>(SYS_bind, socket, address, address_len);
 #elif defined(SYS_socketcall)
-  unsigned long sockcall_args[3] = {static_cast<unsigned long>(domain),
+  unsigned long sockcall_args[3] = {static_cast<unsigned long>(socket),
                                     reinterpret_cast<unsigned long>(address),
                                     static_cast<unsigned long>(address_len)};
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_socketcall, SYS_BIND,
@@ -40,4 +41,4 @@ LLVM_LIBC_FUNCTION(int, bind,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/recv.cpp b/src/sys/socket/linux/recv.cpp
new file mode 100644
index 0000000..5e9f2d3
--- /dev/null
+++ b/src/sys/socket/linux/recv.cpp
@@ -0,0 +1,51 @@
+//===-- Linux implementation of recv --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recv.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/sanitizer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, recv,
+                   (int sockfd, void *buf, size_t len, int flags)) {
+#ifdef SYS_recv
+  ssize_t ret =
+      LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_recv, sockfd, buf, len, flags);
+#elif defined(SYS_recvfrom)
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_recvfrom, sockfd, buf, len, flags, nullptr, nullptr);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[4] = {
+      static_cast<unsigned long>(sockfd), reinterpret_cast<unsigned long>(buf),
+      static_cast<unsigned long>(len), static_cast<unsigned long>(flags)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_socketcall, SYS_RECV,
+                                                      sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+
+  MSAN_UNPOISON(buf, ret);
+
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/recvfrom.cpp b/src/sys/socket/linux/recvfrom.cpp
new file mode 100644
index 0000000..574e65f
--- /dev/null
+++ b/src/sys/socket/linux/recvfrom.cpp
@@ -0,0 +1,68 @@
+//===-- Linux implementation of recvfrom ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recvfrom.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/sanitizer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, recvfrom,
+                   (int sockfd, void *buf, size_t len, int flags,
+                    sockaddr *__restrict src_addr,
+                    socklen_t *__restrict addrlen)) {
+  // addrlen is a value-result argument. If it's not null, it passes the max
+  // size of the buffer src_addr to the syscall. After the syscall, it's updated
+  // to the actual size of the source address. This may be larger than the
+  // buffer, in which case the buffer contains a truncated result.
+  size_t srcaddr_sz;
+  if (src_addr)
+    srcaddr_sz = *addrlen;
+  (void)srcaddr_sz; // prevent "set but not used" warning
+
+#ifdef SYS_recvfrom
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_recvfrom, sockfd, buf, len, flags, src_addr, addrlen);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[6] = {static_cast<unsigned long>(sockfd),
+                                    reinterpret_cast<unsigned long>(buf),
+                                    static_cast<unsigned long>(len),
+                                    static_cast<unsigned long>(flags),
+                                    reinterpret_cast<unsigned long>(src_addr),
+                                    static_cast<unsigned long>(addrlen)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_socketcall, SYS_RECVFROM, sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+
+  MSAN_UNPOISON(buf, ret);
+
+  if (src_addr) {
+    size_t min_src_addr_size = (*addrlen < srcaddr_sz) ? *addrlen : srcaddr_sz;
+    (void)min_src_addr_size; // prevent "set but not used" warning
+
+    MSAN_UNPOISON(src_addr, min_src_addr_size);
+  }
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/recvmsg.cpp b/src/sys/socket/linux/recvmsg.cpp
new file mode 100644
index 0000000..e42b634
--- /dev/null
+++ b/src/sys/socket/linux/recvmsg.cpp
@@ -0,0 +1,53 @@
+//===-- Linux implementation of recvmsg -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recvmsg.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_msghdr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/sanitizer.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, recvmsg, (int sockfd, msghdr *msg, int flags)) {
+#ifdef SYS_recvmsg
+  ssize_t ret =
+      LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_recvmsg, sockfd, msg, flags);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[3] = {static_cast<unsigned long>(sockfd),
+                                    reinterpret_cast<unsigned long>(msg),
+                                    static_cast<unsigned long>(flags)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_socketcall, SYS_RECVMSG, sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+
+  // Unpoison the msghdr, as well as all its components.
+  MSAN_UNPOISON(msg, sizeof(msghdr));
+  MSAN_UNPOISON(msg->msg_name, msg->msg_namelen);
+
+  for (size_t i = 0; i < msg->msg_iovlen; ++i) {
+    MSAN_UNPOISON(msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+  }
+  MSAN_UNPOISON(msg->msg_control, msg->msg_controllen);
+
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/send.cpp b/src/sys/socket/linux/send.cpp
new file mode 100644
index 0000000..cb3b4d5
--- /dev/null
+++ b/src/sys/socket/linux/send.cpp
@@ -0,0 +1,47 @@
+//===-- Linux implementation of send --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/send.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, send,
+                   (int sockfd, const void *buf, size_t len, int flags)) {
+#ifdef SYS_send
+  ssize_t ret =
+      LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_send, sockfd, buf, len, flags);
+#elif defined(SYS_sendto)
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_sendto, sockfd, buf,
+                                                      len, flags, nullptr, 0);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[4] = {
+      static_cast<unsigned long>(sockfd), reinterpret_cast<unsigned long>(buf),
+      static_cast<unsigned long>(len), static_cast<unsigned long>(flags)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_socketcall, SYS_SEND,
+                                                      sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/sendmsg.cpp b/src/sys/socket/linux/sendmsg.cpp
new file mode 100644
index 0000000..b4d9c9d
--- /dev/null
+++ b/src/sys/socket/linux/sendmsg.cpp
@@ -0,0 +1,43 @@
+//===-- Linux implementation of sendmsg -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/sendmsg.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_msghdr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, sendmsg,
+                   (int sockfd, const struct msghdr *msg, int flags)) {
+#ifdef SYS_sendmsg
+  ssize_t ret =
+      LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_sendmsg, sockfd, msg, flags);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[3] = {static_cast<unsigned long>(sockfd),
+                                    reinterpret_cast<unsigned long>(msg),
+                                    static_cast<unsigned long>(flags)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_socketcall, SYS_SENDMSG, sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/sendto.cpp b/src/sys/socket/linux/sendto.cpp
new file mode 100644
index 0000000..2fada19
--- /dev/null
+++ b/src/sys/socket/linux/sendto.cpp
@@ -0,0 +1,48 @@
+//===-- Linux implementation of sendto ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/sendto.h"
+
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, sendto,
+                   (int sockfd, const void *buf, size_t len, int flags,
+                    const struct sockaddr *dest_addr, socklen_t addrlen)) {
+#ifdef SYS_sendto
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_sendto, sockfd, buf, len, flags, dest_addr, addrlen);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[6] = {static_cast<unsigned long>(sockfd),
+                                    reinterpret_cast<unsigned long>(buf),
+                                    static_cast<unsigned long>(len),
+                                    static_cast<unsigned long>(flags),
+                                    reinterpret_cast<unsigned long>(dest_addr),
+                                    static_cast<unsigned long>(addrlen)};
+  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
+      SYS_socketcall, SYS_SENDTO, sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/socket.cpp b/src/sys/socket/linux/socket.cpp
index 90a7dc6..3e6df4d 100644
--- a/src/sys/socket/linux/socket.cpp
+++ b/src/sys/socket/linux/socket.cpp
@@ -11,12 +11,13 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <linux/net.h>   // For SYS_SOCKET socketcall number.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, socket, (int domain, int type, int protocol)) {
 #ifdef SYS_socket
@@ -38,4 +39,4 @@ LLVM_LIBC_FUNCTION(int, socket, (int domain, int type, int protocol)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/linux/socketpair.cpp b/src/sys/socket/linux/socketpair.cpp
new file mode 100644
index 0000000..60612ac
--- /dev/null
+++ b/src/sys/socket/linux/socketpair.cpp
@@ -0,0 +1,45 @@
+//===-- Linux implementation of socketpair --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/socketpair.h"
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/sanitizer.h"
+#include "src/errno/libc_errno.h"
+#include <linux/net.h>   // For SYS_SOCKET socketcall number.
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, socketpair,
+                   (int domain, int type, int protocol, int sv[2])) {
+#ifdef SYS_socketpair
+  int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_socketpair, domain, type,
+                                              protocol, sv);
+#elif defined(SYS_socketcall)
+  unsigned long sockcall_args[3] = {
+      static_cast<unsigned long>(domain), static_cast<unsigned long>(type),
+      static_cast<unsigned long>(protocol), static_cast<unsigned long>(sv)};
+  int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_socketcall, SYS_SOCKETPAIR,
+                                              sockcall_args);
+#else
+#error "socket and socketcall syscalls unavailable for this platform."
+#endif
+  if (ret < 0) {
+    libc_errno = -ret;
+    return -1;
+  }
+
+  MSAN_UNPOISON(sv, sizeof(int) * 2);
+
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/socket/recv.h b/src/sys/socket/recv.h
new file mode 100644
index 0000000..ea64daa
--- /dev/null
+++ b/src/sys/socket/recv.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for recv --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_RECV_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_RECV_H
+
+#include "src/__support/macros/config.h"
+#include <sys/socket.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t recv(int sockfd, void *buf, size_t len, int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_RECV_H
diff --git a/src/sys/socket/recvfrom.h b/src/sys/socket/recvfrom.h
new file mode 100644
index 0000000..5c12410
--- /dev/null
+++ b/src/sys/socket/recvfrom.h
@@ -0,0 +1,25 @@
+//===-- Implementation header for recvfrom ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_RECVFROM_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_RECVFROM_H
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h> // For size_t
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
+                 sockaddr *__restrict src_addr, socklen_t *__restrict addrlen);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_RECVFROM_H
diff --git a/src/sys/socket/recvmsg.h b/src/sys/socket/recvmsg.h
new file mode 100644
index 0000000..6230136
--- /dev/null
+++ b/src/sys/socket/recvmsg.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for recvmsg -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_RECVMSG_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_RECVMSG_H
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_msghdr.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_RECVMSG_H
diff --git a/src/sys/socket/send.h b/src/sys/socket/send.h
new file mode 100644
index 0000000..e170669
--- /dev/null
+++ b/src/sys/socket/send.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for send --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_SEND_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_SEND_H
+
+#include "src/__support/macros/config.h"
+#include <sys/socket.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t send(int sockfd, const void *buf, size_t len, int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_SEND_H
diff --git a/src/sys/socket/sendmsg.h b/src/sys/socket/sendmsg.h
new file mode 100644
index 0000000..c11f3bd
--- /dev/null
+++ b/src/sys/socket/sendmsg.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for sendmsg -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_SENDMSG_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_SENDMSG_H
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_msghdr.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_SENDMSG_H
diff --git a/src/sys/socket/sendto.h b/src/sys/socket/sendto.h
new file mode 100644
index 0000000..6e5e6d4
--- /dev/null
+++ b/src/sys/socket/sendto.h
@@ -0,0 +1,25 @@
+//===-- Implementation header for sendto ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_SENDTO_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_SENDTO_H
+
+#include "hdr/types/socklen_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_sockaddr.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h> // For size_t
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
+               const struct sockaddr *dest_addr, socklen_t addrlen);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_SENDTO_H
diff --git a/src/sys/socket/socket.h b/src/sys/socket/socket.h
index a657898..253be73 100644
--- a/src/sys/socket/socket.h
+++ b/src/sys/socket/socket.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_SYS_SOCKET_SOCKET_H
 #define LLVM_LIBC_SRC_SYS_SOCKET_SOCKET_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int socket(int domain, int type, int protocol);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_SOCKET_SOCKET_H
diff --git a/src/sys/socket/socketpair.h b/src/sys/socket/socketpair.h
new file mode 100644
index 0000000..1d847c3
--- /dev/null
+++ b/src/sys/socket/socketpair.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for socketpair --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_SOCKET_SOCKETPAIR_H
+#define LLVM_LIBC_SRC_SYS_SOCKET_SOCKETPAIR_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int socketpair(int domain, int type, int protocol, int sv[2]);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_SOCKET_SOCKETPAIR_H
diff --git a/src/sys/stat/chmod.h b/src/sys/stat/chmod.h
index decb442..a05407a 100644
--- a/src/sys/stat/chmod.h
+++ b/src/sys/stat/chmod.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_CHMOD_H
 #define LLVM_LIBC_SRC_SYS_STAT_CHMOD_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int chmod(const char *path, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_CHMOD_H
diff --git a/src/sys/stat/fchmod.h b/src/sys/stat/fchmod.h
index 611bba1..470ce3e 100644
--- a/src/sys/stat/fchmod.h
+++ b/src/sys/stat/fchmod.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_FCHMOD_H
 #define LLVM_LIBC_SRC_SYS_STAT_FCHMOD_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fchmod(int fd, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_FCHMOD_H
diff --git a/src/sys/stat/fchmodat.h b/src/sys/stat/fchmodat.h
index e7b1269..e4500f5 100644
--- a/src/sys/stat/fchmodat.h
+++ b/src/sys/stat/fchmodat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_FCHMODAT_H
 #define LLVM_LIBC_SRC_SYS_STAT_FCHMODAT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fchmodat(int dirfd, const char *path, mode_t mode, int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_FCHMODAT_H
diff --git a/src/sys/stat/fstat.h b/src/sys/stat/fstat.h
index 7633ee6..a3ec9e4 100644
--- a/src/sys/stat/fstat.h
+++ b/src/sys/stat/fstat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_FSTAT_H
 #define LLVM_LIBC_SRC_SYS_STAT_FSTAT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fstat(int fd, struct stat *statbuf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_FSTAT_H
diff --git a/src/sys/stat/linux/chmod.cpp b/src/sys/stat/linux/chmod.cpp
index 25e5e69..57d5bae 100644
--- a/src/sys/stat/linux/chmod.cpp
+++ b/src/sys/stat/linux/chmod.cpp
@@ -11,12 +11,14 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "hdr/types/mode_t.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, chmod, (const char *path, mode_t mode)) {
 #ifdef SYS_chmod
@@ -38,4 +40,4 @@ LLVM_LIBC_FUNCTION(int, chmod, (const char *path, mode_t mode)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/fchmod.cpp b/src/sys/stat/linux/fchmod.cpp
index cdc9cbf..0d6fd35 100644
--- a/src/sys/stat/linux/fchmod.cpp
+++ b/src/sys/stat/linux/fchmod.cpp
@@ -11,12 +11,13 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/types/mode_t.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fchmod, (int fd, mode_t mode)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_fchmod, fd, mode);
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, fchmod, (int fd, mode_t mode)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/fchmodat.cpp b/src/sys/stat/linux/fchmodat.cpp
index 43b4cf0..e76db4d 100644
--- a/src/sys/stat/linux/fchmodat.cpp
+++ b/src/sys/stat/linux/fchmodat.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/stat.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fchmodat,
                    (int dirfd, const char *path, mode_t mode, int flags)) {
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, fchmodat,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/fstat.cpp b/src/sys/stat/linux/fstat.cpp
index 5164178..35cf8f0 100644
--- a/src/sys/stat/linux/fstat.cpp
+++ b/src/sys/stat/linux/fstat.cpp
@@ -8,14 +8,15 @@
 
 #include "src/sys/stat/fstat.h"
 #include "kernel_statx.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include "src/__support/common.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fstat, (int fd, struct stat *statbuf)) {
   int err = statx(fd, "", AT_EMPTY_PATH, statbuf);
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, fstat, (int fd, struct stat *statbuf)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/kernel_statx.h b/src/sys/stat/linux/kernel_statx.h
index 6096916..d0e223a 100644
--- a/src/sys/stat/linux/kernel_statx.h
+++ b/src/sys/stat/linux/kernel_statx.h
@@ -11,6 +11,7 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 #include <sys/stat.h>
@@ -67,7 +68,7 @@ constexpr unsigned int STATX_BASIC_STATS_MASK = 0x7FF;
 
 } // Anonymous namespace
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE int statx(int dirfd, const char *__restrict path, int flags,
                       struct stat *__restrict statbuf) {
@@ -79,7 +80,7 @@ LIBC_INLINE int statx(int dirfd, const char *__restrict path, int flags,
     return -ret;
 
   statbuf->st_dev = MKDEV(xbuf.stx_dev_major, xbuf.stx_dev_minor);
-  statbuf->st_ino = xbuf.stx_ino;
+  statbuf->st_ino = static_cast<decltype(statbuf->st_ino)>(xbuf.stx_ino);
   statbuf->st_mode = xbuf.stx_mode;
   statbuf->st_nlink = xbuf.stx_nlink;
   statbuf->st_uid = xbuf.stx_uid;
@@ -93,11 +94,12 @@ LIBC_INLINE int statx(int dirfd, const char *__restrict path, int flags,
   statbuf->st_ctim.tv_sec = xbuf.stx_ctime.tv_sec;
   statbuf->st_ctim.tv_nsec = xbuf.stx_ctime.tv_nsec;
   statbuf->st_blksize = xbuf.stx_blksize;
-  statbuf->st_blocks = xbuf.stx_blocks;
+  statbuf->st_blocks =
+      static_cast<decltype(statbuf->st_blocks)>(xbuf.stx_blocks);
 
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_LINUX_KERNEL_STATX_H
diff --git a/src/sys/stat/linux/lstat.cpp b/src/sys/stat/linux/lstat.cpp
index b269814..354c5b6 100644
--- a/src/sys/stat/linux/lstat.cpp
+++ b/src/sys/stat/linux/lstat.cpp
@@ -8,15 +8,16 @@
 
 #include "src/sys/stat/lstat.h"
 #include "kernel_statx.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, lstat,
                    (const char *__restrict path,
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, lstat,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/mkdir.cpp b/src/sys/stat/linux/mkdir.cpp
index 63b64ac..b319b5c 100644
--- a/src/sys/stat/linux/mkdir.cpp
+++ b/src/sys/stat/linux/mkdir.cpp
@@ -11,12 +11,14 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "hdr/types/mode_t.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, mkdir, (const char *path, mode_t mode)) {
 #ifdef SYS_mkdir
@@ -35,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, mkdir, (const char *path, mode_t mode)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/mkdirat.cpp b/src/sys/stat/linux/mkdirat.cpp
index 0128d7c..097fc15 100644
--- a/src/sys/stat/linux/mkdirat.cpp
+++ b/src/sys/stat/linux/mkdirat.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/stat.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, mkdirat, (int dfd, const char *path, mode_t mode)) {
 #ifdef SYS_mkdirat
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, mkdirat, (int dfd, const char *path, mode_t mode)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/linux/stat.cpp b/src/sys/stat/linux/stat.cpp
index c30c8b6..de9cdb1 100644
--- a/src/sys/stat/linux/stat.cpp
+++ b/src/sys/stat/linux/stat.cpp
@@ -8,14 +8,15 @@
 
 #include "src/sys/stat/stat.h"
 #include "kernel_statx.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include "src/__support/common.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, stat,
                    (const char *__restrict path,
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, stat,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/stat/lstat.h b/src/sys/stat/lstat.h
index 42bd8e9..a94fc69 100644
--- a/src/sys/stat/lstat.h
+++ b/src/sys/stat/lstat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_LSTAT_H
 #define LLVM_LIBC_SRC_SYS_STAT_LSTAT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int lstat(const char *__restrict path, struct stat *__restrict statbuf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_LSTAT_H
diff --git a/src/sys/stat/mkdir.h b/src/sys/stat/mkdir.h
index 9f2991d..2d990ba 100644
--- a/src/sys/stat/mkdir.h
+++ b/src/sys/stat/mkdir.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_MKDIR_H
 #define LLVM_LIBC_SRC_SYS_STAT_MKDIR_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mkdir(const char *path, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_MKDIR_H
diff --git a/src/sys/stat/mkdirat.h b/src/sys/stat/mkdirat.h
index 3222097..e26cf5b 100644
--- a/src/sys/stat/mkdirat.h
+++ b/src/sys/stat/mkdirat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_MKDIRAT_H
 #define LLVM_LIBC_SRC_SYS_STAT_MKDIRAT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mkdirat(int dfd, const char *path, mode_t mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_MKDIRAT_H
diff --git a/src/sys/stat/stat.h b/src/sys/stat/stat.h
index 5d2eba5..8ec3e9b 100644
--- a/src/sys/stat/stat.h
+++ b/src/sys/stat/stat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STAT_STAT_H
 #define LLVM_LIBC_SRC_SYS_STAT_STAT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/stat.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int stat(const char *__restrict path, struct stat *__restrict statbuf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STAT_STAT_H
diff --git a/src/sys/statvfs/fstatvfs.h b/src/sys/statvfs/fstatvfs.h
index 6ca76a4..dfff757 100644
--- a/src/sys/statvfs/fstatvfs.h
+++ b/src/sys/statvfs/fstatvfs.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STATVFS_FSTATVFS_H
 #define LLVM_LIBC_SRC_SYS_STATVFS_FSTATVFS_H
 
-#include "llvm-libc-types/struct_statvfs.h"
+#include "include/llvm-libc-types/struct_statvfs.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int fstatvfs(int fd, struct statvfs *buf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STATVFS_FSTATVFS_H
diff --git a/src/sys/statvfs/linux/fstatvfs.cpp b/src/sys/statvfs/linux/fstatvfs.cpp
index 488989a..1a2fc04 100644
--- a/src/sys/statvfs/linux/fstatvfs.cpp
+++ b/src/sys/statvfs/linux/fstatvfs.cpp
@@ -9,9 +9,10 @@
 #include "src/sys/statvfs/fstatvfs.h"
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/sys/statvfs/linux/statfs_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fstatvfs, (int fd, struct statvfs *buf)) {
   using namespace statfs_utils;
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, fstatvfs, (int fd, struct statvfs *buf)) {
   return result ? 0 : -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/statvfs/linux/statfs_utils.h b/src/sys/statvfs/linux/statfs_utils.h
index 606786a..1e5be51 100644
--- a/src/sys/statvfs/linux/statfs_utils.h
+++ b/src/sys/statvfs/linux/statfs_utils.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_SYS_STATVFS_LINUX_STATFS_TO_STATVFS_H
 #define LLVM_LIBC_SRC_SYS_STATVFS_LINUX_STATFS_TO_STATVFS_H
 
-#include "llvm-libc-types/struct_statvfs.h"
+#include "include/llvm-libc-types/struct_statvfs.h"
 #include "src/__support/CPP/optional.h"
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/macros/attributes.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <asm/statfs.h>
 #include <sys/syscall.h>
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace statfs_utils {
 #ifdef SYS_statfs64
@@ -77,19 +78,20 @@ LIBC_INLINE struct statvfs statfs_to_statvfs(const LinuxStatFs &in) {
   struct statvfs out;
   out.f_bsize = in.f_bsize;
   out.f_frsize = in.f_frsize;
-  out.f_blocks = in.f_blocks;
-  out.f_bfree = in.f_bfree;
-  out.f_bavail = in.f_bavail;
-  out.f_files = in.f_files;
-  out.f_ffree = in.f_ffree;
-  out.f_favail = in.f_ffree;
-  out.f_fsid = in.f_fsid.val[0] |
-               static_cast<decltype(out.f_fsid)>(in.f_fsid.val[1]) << 32;
+  out.f_blocks = static_cast<decltype(out.f_blocks)>(in.f_blocks);
+  out.f_bfree = static_cast<decltype(out.f_bfree)>(in.f_bfree);
+  out.f_bavail = static_cast<decltype(out.f_bavail)>(in.f_bavail);
+  out.f_files = static_cast<decltype(out.f_files)>(in.f_files);
+  out.f_ffree = static_cast<decltype(out.f_ffree)>(in.f_ffree);
+  out.f_favail = static_cast<decltype(out.f_favail)>(in.f_ffree);
+  out.f_fsid = in.f_fsid.val[0];
+  if constexpr (sizeof(decltype(out.f_fsid)) == sizeof(uint64_t))
+    out.f_fsid |= static_cast<decltype(out.f_fsid)>(in.f_fsid.val[1]) << 32;
   out.f_flag = in.f_flags;
   out.f_namemax = in.f_namelen;
   return out;
 }
 } // namespace statfs_utils
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STATVFS_LINUX_STATFS_TO_STATVFS_H
diff --git a/src/sys/statvfs/linux/statvfs.cpp b/src/sys/statvfs/linux/statvfs.cpp
index a438ef1..fc3c75a 100644
--- a/src/sys/statvfs/linux/statvfs.cpp
+++ b/src/sys/statvfs/linux/statvfs.cpp
@@ -9,9 +9,10 @@
 #include "src/sys/statvfs/statvfs.h"
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
 #include "src/sys/statvfs/linux/statfs_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, statvfs,
                    (const char *__restrict path,
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, statvfs,
   return result ? 0 : -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/statvfs/statvfs.h b/src/sys/statvfs/statvfs.h
index 792c7dd..1350880 100644
--- a/src/sys/statvfs/statvfs.h
+++ b/src/sys/statvfs/statvfs.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_STATVFS_STATVFS_H
 #define LLVM_LIBC_SRC_SYS_STATVFS_STATVFS_H
 
-#include "llvm-libc-types/struct_statvfs.h"
+#include "include/llvm-libc-types/struct_statvfs.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int statvfs(const char *__restrict path, struct statvfs *__restrict buf);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_STATVFS_STATVFS_H
diff --git a/src/sys/utsname/linux/uname.cpp b/src/sys/utsname/linux/uname.cpp
index f0796b6..7bb227e 100644
--- a/src/sys/utsname/linux/uname.cpp
+++ b/src/sys/utsname/linux/uname.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 #include <sys/utsname.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, uname, (struct utsname * name)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_uname, name);
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(int, uname, (struct utsname * name)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/utsname/uname.h b/src/sys/utsname/uname.h
index b347cf0..973df77 100644
--- a/src/sys/utsname/uname.h
+++ b/src/sys/utsname/uname.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_UTSNAME_UNAME_H
 #define LLVM_LIBC_SRC_SYS_UTSNAME_UNAME_H
 
+#include "src/__support/macros/config.h"
 #include <sys/utsname.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int uname(struct utsname *name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_UTSNAME_UNAME_H
diff --git a/src/sys/wait/linux/wait.cpp b/src/sys/wait/linux/wait.cpp
index 02e6a34..dc97d0a 100644
--- a/src/sys/wait/linux/wait.cpp
+++ b/src/sys/wait/linux/wait.cpp
@@ -9,10 +9,11 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 
+#include "src/__support/macros/config.h"
 #include "src/sys/wait/wait.h"
 #include "src/sys/wait/wait4Impl.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, wait, (int *wait_status)) {
   auto result = internal::wait4impl(-1, wait_status, 0, 0);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(pid_t, wait, (int *wait_status)) {
   return result.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/wait/linux/wait4.cpp b/src/sys/wait/linux/wait4.cpp
index 84036ca..ac6d169 100644
--- a/src/sys/wait/linux/wait4.cpp
+++ b/src/sys/wait/linux/wait4.cpp
@@ -9,10 +9,11 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 
+#include "src/__support/macros/config.h"
 #include "src/sys/wait/wait4.h"
 #include "src/sys/wait/wait4Impl.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, wait4,
                    (pid_t pid, int *wait_status, int options,
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(pid_t, wait4,
   return result.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/wait/linux/waitpid.cpp b/src/sys/wait/linux/waitpid.cpp
index b2e8229..cb763a6 100644
--- a/src/sys/wait/linux/waitpid.cpp
+++ b/src/sys/wait/linux/waitpid.cpp
@@ -9,10 +9,11 @@
 #include "src/__support/common.h"
 #include "src/__support/libc_assert.h"
 
+#include "src/__support/macros/config.h"
 #include "src/sys/wait/wait4Impl.h"
 #include "src/sys/wait/waitpid.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, waitpid, (pid_t pid, int *wait_status, int options)) {
   auto result = internal::wait4impl(pid, wait_status, options, 0);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(pid_t, waitpid, (pid_t pid, int *wait_status, int options)) {
   return result.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/wait/wait.h b/src/sys/wait/wait.h
index abe5249..03b53a5 100644
--- a/src/sys/wait/wait.h
+++ b/src/sys/wait/wait.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_WAIT_WAIT_H
 #define LLVM_LIBC_SRC_SYS_WAIT_WAIT_H
 
+#include "src/__support/macros/config.h"
 #include <sys/wait.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t wait(int *waitstatus);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_WAIT_WAIT_H
diff --git a/src/sys/wait/wait4.h b/src/sys/wait/wait4.h
index 3205b28..f425fee 100644
--- a/src/sys/wait/wait4.h
+++ b/src/sys/wait/wait4.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_WAIT_WAIT4_H
 #define LLVM_LIBC_SRC_SYS_WAIT_WAIT4_H
 
+#include "src/__support/macros/config.h"
 #include <sys/wait.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t wait4(pid_t pid, int *waitstatus, int options, struct rusage *usage);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_WAIT_WAIT4_H
diff --git a/src/sys/wait/wait4Impl.h b/src/sys/wait/wait4Impl.h
index 956ad0f..5c2cb3e 100644
--- a/src/sys/wait/wait4Impl.h
+++ b/src/sys/wait/wait4Impl.h
@@ -12,13 +12,14 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 #include "src/__support/error_or.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <signal.h>
 #include <sys/syscall.h> // For syscall numbers.
 #include <sys/wait.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 // The implementation of wait here is very minimal. We will add more
@@ -80,6 +81,6 @@ LIBC_INLINE ErrorOr<pid_t> wait4impl(pid_t pid, int *wait_status, int options,
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_WAIT_WAIT4IMPL_H
diff --git a/src/sys/wait/waitpid.h b/src/sys/wait/waitpid.h
index 37ebf28..883b537 100644
--- a/src/sys/wait/waitpid.h
+++ b/src/sys/wait/waitpid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_SYS_WAIT_WAITPID_H
 #define LLVM_LIBC_SRC_SYS_WAIT_WAITPID_H
 
+#include "src/__support/macros/config.h"
 #include <sys/wait.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t waitpid(pid_t pid, int *waitstatus, int options);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_SYS_WAIT_WAITPID_H
diff --git a/src/termios/cfgetispeed.h b/src/termios/cfgetispeed.h
index 7ea280f..56b0ab8 100644
--- a/src/termios/cfgetispeed.h
+++ b/src/termios/cfgetispeed.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_CFGETISPEED_H
 #define LLVM_LIBC_SRC_TERMIOS_CFGETISPEED_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 speed_t cfgetispeed(const struct termios *t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_CFGETISPEED_H
diff --git a/src/termios/cfgetospeed.h b/src/termios/cfgetospeed.h
index 95e3edb..9d8e665 100644
--- a/src/termios/cfgetospeed.h
+++ b/src/termios/cfgetospeed.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_CFGETOSPEED_H
 #define LLVM_LIBC_SRC_TERMIOS_CFGETOSPEED_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 speed_t cfgetospeed(const struct termios *t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_CFGETOSPEED_H
diff --git a/src/termios/cfsetispeed.h b/src/termios/cfsetispeed.h
index e03a2d1..89b683e 100644
--- a/src/termios/cfsetispeed.h
+++ b/src/termios/cfsetispeed.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_CFSETISPEED_H
 #define LLVM_LIBC_SRC_TERMIOS_CFSETISPEED_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cfsetispeed(struct termios *t, speed_t speed);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_CFSETISPEED_H
diff --git a/src/termios/cfsetospeed.h b/src/termios/cfsetospeed.h
index 74d41ab..2f2c531 100644
--- a/src/termios/cfsetospeed.h
+++ b/src/termios/cfsetospeed.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_CFSETOSPEED_H
 #define LLVM_LIBC_SRC_TERMIOS_CFSETOSPEED_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cfsetospeed(struct termios *t, speed_t speed);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_CFSETOSPEED_H
diff --git a/src/termios/linux/cfgetispeed.cpp b/src/termios/linux/cfgetispeed.cpp
index 18e34b2..19e9b91 100644
--- a/src/termios/linux/cfgetispeed.cpp
+++ b/src/termios/linux/cfgetispeed.cpp
@@ -9,13 +9,14 @@
 #include "src/termios/cfgetispeed.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(speed_t, cfgetispeed, (const struct termios *t)) {
   return t->c_cflag & CBAUD;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/cfgetospeed.cpp b/src/termios/linux/cfgetospeed.cpp
index 1989b3f..d633beb 100644
--- a/src/termios/linux/cfgetospeed.cpp
+++ b/src/termios/linux/cfgetospeed.cpp
@@ -9,13 +9,14 @@
 #include "src/termios/cfgetospeed.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(speed_t, cfgetospeed, (const struct termios *t)) {
   return t->c_cflag & CBAUD;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/cfsetispeed.cpp b/src/termios/linux/cfsetispeed.cpp
index 0e8ac55..9656b71 100644
--- a/src/termios/linux/cfsetispeed.cpp
+++ b/src/termios/linux/cfsetispeed.cpp
@@ -9,11 +9,12 @@
 #include "src/termios/cfsetispeed.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, cfsetispeed, (struct termios * t, speed_t speed)) {
   constexpr speed_t NOT_SPEED_MASK = ~speed_t(CBAUD);
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, cfsetispeed, (struct termios * t, speed_t speed)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/cfsetospeed.cpp b/src/termios/linux/cfsetospeed.cpp
index d21f629..6130d26 100644
--- a/src/termios/linux/cfsetospeed.cpp
+++ b/src/termios/linux/cfsetospeed.cpp
@@ -7,13 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/termios/cfsetospeed.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include "src/__support/common.h"
 
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, cfsetospeed, (struct termios * t, speed_t speed)) {
   constexpr speed_t NOT_SPEED_MASK = ~speed_t(CBAUD);
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, cfsetospeed, (struct termios * t, speed_t speed)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/kernel_termios.h b/src/termios/linux/kernel_termios.h
index d96de72..5a3a972 100644
--- a/src/termios/linux/kernel_termios.h
+++ b/src/termios/linux/kernel_termios.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_LINUX_KERNEL_TERMIOS_H
 #define LLVM_LIBC_SRC_TERMIOS_LINUX_KERNEL_TERMIOS_H
 
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The kernel's struct termios is different from the libc's struct termios. The
 // kernel's syscalls expect the size and layout of its definition of struct
@@ -36,6 +37,6 @@ struct kernel_termios {
   cc_t c_cc[KERNEL_NCCS];
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_LINUX_KERNEL_TERMIOS_H
diff --git a/src/termios/linux/tcdrain.cpp b/src/termios/linux/tcdrain.cpp
index c3826ff..116e3f0 100644
--- a/src/termios/linux/tcdrain.cpp
+++ b/src/termios/linux/tcdrain.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tcdrain, (int fd)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_ioctl, fd, TCSBRK, 1);
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, tcdrain, (int fd)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcflow.cpp b/src/termios/linux/tcflow.cpp
index 9753ef7..d229230 100644
--- a/src/termios/linux/tcflow.cpp
+++ b/src/termios/linux/tcflow.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tcflow, (int fd, int action)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_ioctl, fd, TCXONC, action);
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, tcflow, (int fd, int action)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcflush.cpp b/src/termios/linux/tcflush.cpp
index 9c7e8f0..028a541 100644
--- a/src/termios/linux/tcflush.cpp
+++ b/src/termios/linux/tcflush.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tcflush, (int fd, int queue_selector)) {
   int ret =
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(int, tcflush, (int fd, int queue_selector)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcgetattr.cpp b/src/termios/linux/tcgetattr.cpp
index 254c485..63c096f 100644
--- a/src/termios/linux/tcgetattr.cpp
+++ b/src/termios/linux/tcgetattr.cpp
@@ -11,13 +11,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tcgetattr, (int fd, struct termios *t)) {
   LIBC_NAMESPACE::kernel_termios kt;
@@ -43,4 +44,4 @@ LLVM_LIBC_FUNCTION(int, tcgetattr, (int fd, struct termios *t)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcgetsid.cpp b/src/termios/linux/tcgetsid.cpp
index 7b2abf8..c283d0e 100644
--- a/src/termios/linux/tcgetsid.cpp
+++ b/src/termios/linux/tcgetsid.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, tcgetsid, (int fd)) {
   pid_t sid;
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(pid_t, tcgetsid, (int fd)) {
   return sid;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcsendbreak.cpp b/src/termios/linux/tcsendbreak.cpp
index fdd3f8a..30bc91c 100644
--- a/src/termios/linux/tcsendbreak.cpp
+++ b/src/termios/linux/tcsendbreak.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, tcsendbreak, (int fd, int /* unused duration */)) {
   // POSIX leaves the behavior for non-zero duration implementation dependent.
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(pid_t, tcsendbreak, (int fd, int /* unused duration */)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/linux/tcsetattr.cpp b/src/termios/linux/tcsetattr.cpp
index ba500a0..8aa1e5c 100644
--- a/src/termios/linux/tcsetattr.cpp
+++ b/src/termios/linux/tcsetattr.cpp
@@ -11,13 +11,14 @@
 
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <asm/ioctls.h> // Safe to include without the risk of name pollution.
 #include <sys/syscall.h> // For syscall numbers
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tcsetattr,
                    (int fd, int actions, const struct termios *t)) {
@@ -59,4 +60,4 @@ LLVM_LIBC_FUNCTION(int, tcsetattr,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/termios/tcdrain.h b/src/termios/tcdrain.h
index 5204206..f7fcd8c 100644
--- a/src/termios/tcdrain.h
+++ b/src/termios/tcdrain.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCDRAIN_H
 #define LLVM_LIBC_SRC_TERMIOS_TCDRAIN_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcdrain(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCDRAIN_H
diff --git a/src/termios/tcflow.h b/src/termios/tcflow.h
index 267d3f6..dbe63ad 100644
--- a/src/termios/tcflow.h
+++ b/src/termios/tcflow.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCFLOW_H
 #define LLVM_LIBC_SRC_TERMIOS_TCFLOW_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcflow(int fd, int action);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCFLOW_H
diff --git a/src/termios/tcflush.h b/src/termios/tcflush.h
index d631ca2..5c283a0 100644
--- a/src/termios/tcflush.h
+++ b/src/termios/tcflush.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCFLUSH_H
 #define LLVM_LIBC_SRC_TERMIOS_TCFLUSH_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcflush(int fd, int queue_selector);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCFLUSH_H
diff --git a/src/termios/tcgetattr.h b/src/termios/tcgetattr.h
index c39aa41..54b169a 100644
--- a/src/termios/tcgetattr.h
+++ b/src/termios/tcgetattr.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCGETATTR_H
 #define LLVM_LIBC_SRC_TERMIOS_TCGETATTR_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcgetattr(int fd, struct termios *t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCGETATTR_H
diff --git a/src/termios/tcgetsid.h b/src/termios/tcgetsid.h
index 07dbb22..a69db00 100644
--- a/src/termios/tcgetsid.h
+++ b/src/termios/tcgetsid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCGETSID_H
 #define LLVM_LIBC_SRC_TERMIOS_TCGETSID_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t tcgetsid(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCGETSID_H
diff --git a/src/termios/tcsendbreak.h b/src/termios/tcsendbreak.h
index 487fdad..9edc602 100644
--- a/src/termios/tcsendbreak.h
+++ b/src/termios/tcsendbreak.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCSENDBREAK_H
 #define LLVM_LIBC_SRC_TERMIOS_TCSENDBREAK_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcsendbreak(int fd, int duration);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCSENDBREAK_H
diff --git a/src/termios/tcsetattr.h b/src/termios/tcsetattr.h
index d514ac7..05c88f1 100644
--- a/src/termios/tcsetattr.h
+++ b/src/termios/tcsetattr.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TERMIOS_TCSETATTR_H
 #define LLVM_LIBC_SRC_TERMIOS_TCSETATTR_H
 
+#include "src/__support/macros/config.h"
 #include <termios.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tcsetattr(int fd, int actions, const struct termios *t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TERMIOS_TCSETATTR_H
diff --git a/src/threads/call_once.cpp b/src/threads/call_once.cpp
index 2d91094..8466cd6 100644
--- a/src/threads/call_once.cpp
+++ b/src/threads/call_once.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/call_once.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/callonce.h"
 
 #include <threads.h> // For once_flag and __call_once_func_t definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, call_once,
                    (once_flag * flag, __call_once_func_t func)) {
@@ -20,4 +21,4 @@ LLVM_LIBC_FUNCTION(void, call_once,
            reinterpret_cast<CallOnceCallback *>(func));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/call_once.h b/src/threads/call_once.h
index 186d63c..b6208af 100644
--- a/src/threads/call_once.h
+++ b/src/threads/call_once.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CALL_ONCE_H
 #define LLVM_LIBC_SRC_THREADS_CALL_ONCE_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void call_once(once_flag *flag, __call_once_func_t func);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CALL_ONCE_H
diff --git a/src/threads/cnd_broadcast.h b/src/threads/cnd_broadcast.h
index 4e996f2..ab911a7 100644
--- a/src/threads/cnd_broadcast.h
+++ b/src/threads/cnd_broadcast.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CND_BROADCAST_H
 #define LLVM_LIBC_SRC_THREADS_CND_BROADCAST_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cnd_broadcast(cnd_t *cond);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CND_BROADCAST_H
diff --git a/src/threads/cnd_destroy.h b/src/threads/cnd_destroy.h
index d102e7b..224a9a4 100644
--- a/src/threads/cnd_destroy.h
+++ b/src/threads/cnd_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CND_DESTROY_H
 #define LLVM_LIBC_SRC_THREADS_CND_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void cnd_destroy(cnd_t *cond);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CND_DESTROY_H
diff --git a/src/threads/cnd_init.h b/src/threads/cnd_init.h
index c4fc02f..dcd4f7b 100644
--- a/src/threads/cnd_init.h
+++ b/src/threads/cnd_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CND_INIT_H
 #define LLVM_LIBC_SRC_THREADS_CND_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cnd_init(cnd_t *cond);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CND_INIT_H
diff --git a/src/threads/cnd_signal.h b/src/threads/cnd_signal.h
index 4c60a92..95d4426 100644
--- a/src/threads/cnd_signal.h
+++ b/src/threads/cnd_signal.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CND_SIGNAL_H
 #define LLVM_LIBC_SRC_THREADS_CND_SIGNAL_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cnd_signal(cnd_t *cond);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CND_SIGNAL_H
diff --git a/src/threads/cnd_wait.h b/src/threads/cnd_wait.h
index 5d2cdbb..8f9f0f3 100644
--- a/src/threads/cnd_wait.h
+++ b/src/threads/cnd_wait.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_CND_WAIT_H
 #define LLVM_LIBC_SRC_THREADS_CND_WAIT_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int cnd_wait(cnd_t *cond, mtx_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_CND_WAIT_H
diff --git a/src/threads/linux/Futex.h b/src/threads/linux/Futex.h
index 4b426ac..e7fde14 100644
--- a/src/threads/linux/Futex.h
+++ b/src/threads/linux/Futex.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_SRC_THREADS_LINUX_FUTEX_H
 #define LLVM_LIBC_SRC_THREADS_LINUX_FUTEX_H
 
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h" // Architecture macros
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #if (defined(LIBC_TARGET_ARCH_IS_AARCH64) ||                                   \
      defined(LIBC_TARGET_ARCH_IS_X86_64))
@@ -27,6 +28,6 @@ static_assert(sizeof(FutexWordType) == 4,
 #error "Futex word base type not defined for the target architecture."
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_LINUX_FUTEX_H
diff --git a/src/threads/linux/cnd_broadcast.cpp b/src/threads/linux/cnd_broadcast.cpp
index a56aaa2..5c51874 100644
--- a/src/threads/linux/cnd_broadcast.cpp
+++ b/src/threads/linux/cnd_broadcast.cpp
@@ -8,12 +8,13 @@
 
 #include "src/threads/cnd_broadcast.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/CndVar.h"
 
 // TODO: https://github.com/llvm/llvm-project/issues/92968
 #include <threads.h> // cnd_t, thrd_error, thrd_success
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(CndVar) == sizeof(cnd_t));
 
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, cnd_broadcast, (cnd_t * cond)) {
   return thrd_success;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/linux/cnd_destroy.cpp b/src/threads/linux/cnd_destroy.cpp
index 2b03b18..963991b 100644
--- a/src/threads/linux/cnd_destroy.cpp
+++ b/src/threads/linux/cnd_destroy.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/cnd_destroy.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/CndVar.h"
 
 #include <threads.h> // cnd_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(CndVar) == sizeof(cnd_t));
 
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(void, cnd_destroy, (cnd_t * cond)) {
   CndVar::destroy(cndvar);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/linux/cnd_init.cpp b/src/threads/linux/cnd_init.cpp
index d3d2c8a..478011a 100644
--- a/src/threads/linux/cnd_init.cpp
+++ b/src/threads/linux/cnd_init.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/cnd_init.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/CndVar.h"
 
 #include <threads.h> // cnd_t, thrd_error, thrd_success
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(CndVar) == sizeof(cnd_t));
 
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, cnd_init, (cnd_t * cond)) {
   return CndVar::init(cndvar) ? thrd_error : thrd_success;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/linux/cnd_signal.cpp b/src/threads/linux/cnd_signal.cpp
index f144013..0d21840 100644
--- a/src/threads/linux/cnd_signal.cpp
+++ b/src/threads/linux/cnd_signal.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/cnd_signal.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/CndVar.h"
 
 #include <threads.h> // cnd_t, thrd_error, thrd_success
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(CndVar) == sizeof(cnd_t));
 
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, cnd_signal, (cnd_t * cond)) {
   return thrd_success;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/linux/cnd_wait.cpp b/src/threads/linux/cnd_wait.cpp
index 97cade3..3633cc8 100644
--- a/src/threads/linux/cnd_wait.cpp
+++ b/src/threads/linux/cnd_wait.cpp
@@ -8,12 +8,13 @@
 
 #include "src/threads/cnd_wait.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/CndVar.h"
 #include "src/__support/threads/mutex.h"
 
 #include <threads.h> // cnd_t, mtx_t, thrd_error, thrd_success
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(CndVar) == sizeof(cnd_t));
 
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, cnd_wait, (cnd_t * cond, mtx_t *mtx)) {
   return cndvar->wait(mutex) ? thrd_error : thrd_success;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/mtx_destroy.cpp b/src/threads/mtx_destroy.cpp
index 5ee4777..f5e3f82 100644
--- a/src/threads/mtx_destroy.cpp
+++ b/src/threads/mtx_destroy.cpp
@@ -8,12 +8,13 @@
 
 #include "src/threads/mtx_destroy.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <threads.h> // For mtx_t definition.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, mtx_destroy, (mtx_t *)) {}
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/mtx_destroy.h b/src/threads/mtx_destroy.h
index 1abf5d5..8919008 100644
--- a/src/threads/mtx_destroy.h
+++ b/src/threads/mtx_destroy.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_MTX_DESTROY_H
 #define LLVM_LIBC_SRC_THREADS_MTX_DESTROY_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void mtx_destroy(mtx_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_MTX_DESTROY_H
diff --git a/src/threads/mtx_init.cpp b/src/threads/mtx_init.cpp
index 7cd848d..eb0ba50 100644
--- a/src/threads/mtx_init.cpp
+++ b/src/threads/mtx_init.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/mtx_init.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <threads.h> // For mtx_t definition.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(Mutex) <= sizeof(mtx_t),
               "The public mtx_t type cannot accommodate the internal mutex "
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, mtx_init, (mtx_t * m, int type)) {
   return err == MutexError::NONE ? thrd_success : thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/mtx_init.h b/src/threads/mtx_init.h
index 69294d7..41dc807 100644
--- a/src/threads/mtx_init.h
+++ b/src/threads/mtx_init.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_MTX_INIT_H
 #define LLVM_LIBC_SRC_THREADS_MTX_INIT_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mtx_init(mtx_t *mutex, int type);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_MTX_INIT_H
diff --git a/src/threads/mtx_lock.cpp b/src/threads/mtx_lock.cpp
index 013a88a..5595ebd 100644
--- a/src/threads/mtx_lock.cpp
+++ b/src/threads/mtx_lock.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/mtx_lock.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <threads.h> // For mtx_t definition.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The implementation currently handles only plain mutexes.
 LLVM_LIBC_FUNCTION(int, mtx_lock, (mtx_t * mutex)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, mtx_lock, (mtx_t * mutex)) {
   return err == MutexError::NONE ? thrd_success : thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/mtx_lock.h b/src/threads/mtx_lock.h
index 15c9e1a..110ac27 100644
--- a/src/threads/mtx_lock.h
+++ b/src/threads/mtx_lock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_MTX_LOCK_H
 #define LLVM_LIBC_SRC_THREADS_MTX_LOCK_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mtx_lock(mtx_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_MTX_LOCK_H
diff --git a/src/threads/mtx_unlock.cpp b/src/threads/mtx_unlock.cpp
index a72ee44..dcb2206 100644
--- a/src/threads/mtx_unlock.cpp
+++ b/src/threads/mtx_unlock.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/mtx_unlock.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/mutex.h"
 
 #include <threads.h> // For mtx_t definition.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The implementation currently handles only plain mutexes.
 LLVM_LIBC_FUNCTION(int, mtx_unlock, (mtx_t * mutex)) {
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(int, mtx_unlock, (mtx_t * mutex)) {
   return err == MutexError::NONE ? thrd_success : thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/mtx_unlock.h b/src/threads/mtx_unlock.h
index 54fb034..54f6f79 100644
--- a/src/threads/mtx_unlock.h
+++ b/src/threads/mtx_unlock.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_MTX_UNLOCK_H
 #define LLVM_LIBC_SRC_THREADS_MTX_UNLOCK_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int mtx_unlock(mtx_t *mutex);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_MTX_UNLOCK_H
diff --git a/src/threads/thrd_create.cpp b/src/threads/thrd_create.cpp
index 06cba84..4680944 100644
--- a/src/threads/thrd_create.cpp
+++ b/src/threads/thrd_create.cpp
@@ -8,12 +8,13 @@
 
 #include "src/threads/thrd_create.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
+#include "src/errno/libc_errno.h"
 
-#include <errno.h>
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, thrd_create,
     return thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_create.h b/src/threads/thrd_create.h
index 0efa6f5..c7b527b 100644
--- a/src/threads/thrd_create.h
+++ b/src/threads/thrd_create.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_CREATE_H
 #define LLVM_LIBC_SRC_THREADS_THRD_CREATE_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int thrd_create(thrd_t *thread, thrd_start_t func, void *arg);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_CREATE_H
diff --git a/src/threads/thrd_current.cpp b/src/threads/thrd_current.cpp
index b5ea043..6341597 100644
--- a/src/threads/thrd_current.cpp
+++ b/src/threads/thrd_current.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/thrd_current.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(thrd_t, thrd_current, ()) {
   return th;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_current.h b/src/threads/thrd_current.h
index 2125729..aec9cd8 100644
--- a/src/threads/thrd_current.h
+++ b/src/threads/thrd_current.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_CURRENT_H
 #define LLVM_LIBC_SRC_THREADS_THRD_CURRENT_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 thrd_t thrd_current();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_CURRENT_H
diff --git a/src/threads/thrd_detach.cpp b/src/threads/thrd_detach.cpp
index 17731c6..a3fe257 100644
--- a/src/threads/thrd_detach.cpp
+++ b/src/threads/thrd_detach.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/thrd_detach.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, thrd_detach, (thrd_t th)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_detach.h b/src/threads/thrd_detach.h
index 64f2094..d139aad 100644
--- a/src/threads/thrd_detach.h
+++ b/src/threads/thrd_detach.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_DETACH_H
 #define LLVM_LIBC_SRC_THREADS_THRD_DETACH_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int thrd_detach(thrd_t thread);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_DETACH_H
diff --git a/src/threads/thrd_equal.cpp b/src/threads/thrd_equal.cpp
index b9717cf..1d901cb 100644
--- a/src/threads/thrd_equal.cpp
+++ b/src/threads/thrd_equal.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/thrd_equal.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, thrd_equal, (thrd_t lhs, thrd_t rhs)) {
   return *lhs_internal == *rhs_internal;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_equal.h b/src/threads/thrd_equal.h
index 5878ea4..5309dbc 100644
--- a/src/threads/thrd_equal.h
+++ b/src/threads/thrd_equal.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_EQUAL_H
 #define LLVM_LIBC_SRC_THREADS_THRD_EQUAL_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int thrd_equal(thrd_t lhs, thrd_t rhs);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_EQUAL_H
diff --git a/src/threads/thrd_exit.cpp b/src/threads/thrd_exit.cpp
index 67a7a41..72fd950 100644
--- a/src/threads/thrd_exit.cpp
+++ b/src/threads/thrd_exit.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/thrd_exit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -21,4 +22,4 @@ LLVM_LIBC_FUNCTION(void, thrd_exit, (int retval)) {
   thread_exit(ThreadReturnValue(retval), ThreadStyle::STDC);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_exit.h b/src/threads/thrd_exit.h
index 19eb027..0569967 100644
--- a/src/threads/thrd_exit.h
+++ b/src/threads/thrd_exit.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_EXIT_H
 #define LLVM_LIBC_SRC_THREADS_THRD_EXIT_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void thrd_exit(int retval);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_EXIT_H
diff --git a/src/threads/thrd_join.cpp b/src/threads/thrd_join.cpp
index cc8ba4b..74211ca 100644
--- a/src/threads/thrd_join.cpp
+++ b/src/threads/thrd_join.cpp
@@ -8,11 +8,12 @@
 
 #include "src/threads/thrd_join.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h> // For thrd_* type definitions.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 static_assert(sizeof(thrd_t) == sizeof(LIBC_NAMESPACE::Thread),
               "Mismatch between thrd_t and internal Thread.");
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, thrd_join, (thrd_t th, int *retval)) {
   return result == 0 ? thrd_success : thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/thrd_join.h b/src/threads/thrd_join.h
index 21a398c..0889d58 100644
--- a/src/threads/thrd_join.h
+++ b/src/threads/thrd_join.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_THRD_JOIN_H
 #define LLVM_LIBC_SRC_THREADS_THRD_JOIN_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int thrd_join(thrd_t thread, int *retval);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_THRD_JOIN_H
diff --git a/src/threads/tss_create.cpp b/src/threads/tss_create.cpp
index ddea44d..05403a3 100644
--- a/src/threads/tss_create.cpp
+++ b/src/threads/tss_create.cpp
@@ -9,11 +9,12 @@
 #include "tss_create.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tss_create, (tss_t * key, tss_dtor_t dtor)) {
   auto k = LIBC_NAMESPACE::new_tss_key(dtor);
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(int, tss_create, (tss_t * key, tss_dtor_t dtor)) {
   return thrd_success;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/tss_create.h b/src/threads/tss_create.h
index def903e..6f055a0 100644
--- a/src/threads/tss_create.h
+++ b/src/threads/tss_create.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_TSS_CREATE_H
 #define LLVM_LIBC_SRC_THREADS_TSS_CREATE_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tss_create(tss_t *key, tss_dtor_t dtor);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_TSS_CREATE_H
diff --git a/src/threads/tss_delete.cpp b/src/threads/tss_delete.cpp
index a2a4e9a..c0a07d6 100644
--- a/src/threads/tss_delete.cpp
+++ b/src/threads/tss_delete.cpp
@@ -9,14 +9,15 @@
 #include "tss_delete.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, tss_delete, (tss_t key)) {
   LIBC_NAMESPACE::tss_key_delete(key);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/tss_delete.h b/src/threads/tss_delete.h
index 3efc0d7..72e7111 100644
--- a/src/threads/tss_delete.h
+++ b/src/threads/tss_delete.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_TSS_DELETE_H
 #define LLVM_LIBC_SRC_THREADS_TSS_DELETE_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void tss_delete(tss_t key);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_TSS_DELETE_H
diff --git a/src/threads/tss_get.cpp b/src/threads/tss_get.cpp
index 9b8c94f..d6a0b96 100644
--- a/src/threads/tss_get.cpp
+++ b/src/threads/tss_get.cpp
@@ -9,12 +9,13 @@
 #include "tss_get.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void *, tss_get, (tss_t key)) { return get_tss_value(key); }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/tss_get.h b/src/threads/tss_get.h
index dfdb79c..c5dd9cb 100644
--- a/src/threads/tss_get.h
+++ b/src/threads/tss_get.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_TSS_GET_H
 #define LLVM_LIBC_SRC_THREADS_TSS_GET_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void *tss_get(tss_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_TSS_GET_H
diff --git a/src/threads/tss_set.cpp b/src/threads/tss_set.cpp
index 640896d..a159c9d 100644
--- a/src/threads/tss_set.cpp
+++ b/src/threads/tss_set.cpp
@@ -9,11 +9,12 @@
 #include "tss_set.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/thread.h"
 
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, tss_set, (tss_t key, void *data)) {
   if (set_tss_value(key, data))
@@ -22,4 +23,4 @@ LLVM_LIBC_FUNCTION(int, tss_set, (tss_t key, void *data)) {
     return thrd_error;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/threads/tss_set.h b/src/threads/tss_set.h
index 249607f..68f50f9 100644
--- a/src/threads/tss_set.h
+++ b/src/threads/tss_set.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_THREADS_TSS_SET_H
 #define LLVM_LIBC_SRC_THREADS_TSS_SET_H
 
+#include "src/__support/macros/config.h"
 #include <threads.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int tss_set(tss_t, void *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_THREADS_TSS_SET_H
diff --git a/src/time/asctime.cpp b/src/time/asctime.cpp
index 9958903..d6fbe73 100644
--- a/src/time/asctime.cpp
+++ b/src/time/asctime.cpp
@@ -8,9 +8,10 @@
 
 #include "src/time/asctime.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using LIBC_NAMESPACE::time_utils::TimeConstants;
 
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(char *, asctime, (const struct tm *timeptr)) {
   return time_utils::asctime(timeptr, buffer, TimeConstants::ASCTIME_MAX_BYTES);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/asctime.h b/src/time/asctime.h
index 941cd70..623e6df 100644
--- a/src/time/asctime.h
+++ b/src/time/asctime.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_ASCTIME_H
 #define LLVM_LIBC_SRC_TIME_ASCTIME_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *asctime(const struct tm *timeptr);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_ASCTIME_H
diff --git a/src/time/asctime_r.cpp b/src/time/asctime_r.cpp
index 19a2124..caa22f1 100644
--- a/src/time/asctime_r.cpp
+++ b/src/time/asctime_r.cpp
@@ -8,9 +8,10 @@
 
 #include "src/time/asctime_r.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using LIBC_NAMESPACE::time_utils::TimeConstants;
 
@@ -19,4 +20,4 @@ LLVM_LIBC_FUNCTION(char *, asctime_r,
   return time_utils::asctime(timeptr, buffer, TimeConstants::ASCTIME_MAX_BYTES);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/asctime_r.h b/src/time/asctime_r.h
index 04d3c01..328b7df 100644
--- a/src/time/asctime_r.h
+++ b/src/time/asctime_r.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_ASCTIME_R_H
 #define LLVM_LIBC_SRC_TIME_ASCTIME_R_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *asctime_r(const struct tm *timeptr, char *buffer);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_ASCTIME_R_H
diff --git a/src/time/clock.h b/src/time/clock.h
index f5d14d0..1a794fa 100644
--- a/src/time/clock.h
+++ b/src/time/clock.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_TIME_CLOCK_H
 
 #include "hdr/types/clock_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 clock_t clock();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_CLOCK_H
diff --git a/src/time/clock_gettime.h b/src/time/clock_gettime.h
index 48e81a3..9f061d2 100644
--- a/src/time/clock_gettime.h
+++ b/src/time/clock_gettime.h
@@ -11,11 +11,12 @@
 
 #include "hdr/types/clockid_t.h"
 #include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int clock_gettime(clockid_t clockid, timespec *tp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_CLOCK_GETTIME_H
diff --git a/src/time/ctime.cpp b/src/time/ctime.cpp
new file mode 100644
index 0000000..8adae9b
--- /dev/null
+++ b/src/time/ctime.cpp
@@ -0,0 +1,28 @@
+//===-- Implementation of ctime function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ctime.h"
+#include "src/__support/CPP/limits.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+using LIBC_NAMESPACE::time_utils::TimeConstants;
+
+LLVM_LIBC_FUNCTION(char *, ctime, (const time_t *t_ptr)) {
+  if (t_ptr == nullptr || *t_ptr > cpp::numeric_limits<int32_t>::max()) {
+    return nullptr;
+  }
+  static char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  return time_utils::asctime(time_utils::localtime(t_ptr), buffer,
+                             TimeConstants::ASCTIME_MAX_BYTES);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/ctime.h b/src/time/ctime.h
new file mode 100644
index 0000000..7760710
--- /dev/null
+++ b/src/time/ctime.h
@@ -0,0 +1,21 @@
+//===-- Implementation header of ctime --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_CTIME_H
+#define LLVM_LIBC_SRC_TIME_CTIME_H
+
+#include "hdr/types/time_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+char *ctime(const time_t *t_ptr);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_CTIME_H
diff --git a/src/time/ctime_r.cpp b/src/time/ctime_r.cpp
new file mode 100644
index 0000000..63d93c4
--- /dev/null
+++ b/src/time/ctime_r.cpp
@@ -0,0 +1,29 @@
+//===-- Implementation of ctime_r function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ctime_r.h"
+#include "src/__support/CPP/limits.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+using LIBC_NAMESPACE::time_utils::TimeConstants;
+
+LLVM_LIBC_FUNCTION(char *, ctime_r, (const time_t *t_ptr, char *buffer)) {
+  if (t_ptr == nullptr || buffer == nullptr ||
+      *t_ptr > cpp::numeric_limits<int32_t>::max()) {
+    return nullptr;
+  }
+
+  return time_utils::asctime(time_utils::localtime(t_ptr), buffer,
+                             TimeConstants::ASCTIME_MAX_BYTES);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/ctime_r.h b/src/time/ctime_r.h
new file mode 100644
index 0000000..d45bf7b
--- /dev/null
+++ b/src/time/ctime_r.h
@@ -0,0 +1,21 @@
+//===-- Implementation header of ctime_r ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_CTIME_R_H
+#define LLVM_LIBC_SRC_TIME_CTIME_R_H
+
+#include "hdr/types/time_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+char *ctime_r(const time_t *t_ptr, char *buffer);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_CTIME_R_H
diff --git a/src/time/difftime.cpp b/src/time/difftime.cpp
index 95aa1be..f295b83 100644
--- a/src/time/difftime.cpp
+++ b/src/time/difftime.cpp
@@ -8,11 +8,12 @@
 
 #include "src/time/difftime.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(double, difftime, (time_t end, time_t beginning)) {
   return static_cast<double>(end - beginning);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/difftime.h b/src/time/difftime.h
index 6498b8b..d5cd593 100644
--- a/src/time/difftime.h
+++ b/src/time/difftime.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_DIFFTIME_H
 #define LLVM_LIBC_SRC_TIME_DIFFTIME_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 double difftime(time_t end, time_t beginning);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_DIFFTIME_H
diff --git a/src/time/gettimeofday.h b/src/time/gettimeofday.h
index 62ee31e..536d871 100644
--- a/src/time/gettimeofday.h
+++ b/src/time/gettimeofday.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_TIME_GETTIMEOFDAY_H
 
 #include "hdr/types/struct_timeval.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int gettimeofday(struct timeval *tv, void *tz);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_GETTIMEOFDAY_H
diff --git a/src/time/gmtime.cpp b/src/time/gmtime.cpp
index 8597f22..6785d18 100644
--- a/src/time/gmtime.cpp
+++ b/src/time/gmtime.cpp
@@ -8,13 +8,14 @@
 
 #include "src/time/gmtime.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(struct tm *, gmtime, (const time_t *timer)) {
   static struct tm tm_out;
   return time_utils::gmtime_internal(timer, &tm_out);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gmtime.h b/src/time/gmtime.h
index d361eb2..3de3ceb 100644
--- a/src/time/gmtime.h
+++ b/src/time/gmtime.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_GMTIME_H
 #define LLVM_LIBC_SRC_TIME_GMTIME_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct tm *gmtime(const time_t *timer);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_GMTIME_H
diff --git a/src/time/gmtime_r.cpp b/src/time/gmtime_r.cpp
index 15a0c06..d506b52 100644
--- a/src/time/gmtime_r.cpp
+++ b/src/time/gmtime_r.cpp
@@ -8,13 +8,14 @@
 
 #include "src/time/gmtime_r.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(struct tm *, gmtime_r,
                    (const time_t *timer, struct tm *result)) {
   return time_utils::gmtime_internal(timer, result);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gmtime_r.h b/src/time/gmtime_r.h
index f7aac28..b4f387e 100644
--- a/src/time/gmtime_r.h
+++ b/src/time/gmtime_r.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_GMTIME_R_H
 #define LLVM_LIBC_SRC_TIME_GMTIME_R_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct tm *gmtime_r(const time_t *timer, struct tm *result);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_GMTIME_R_H
diff --git a/src/time/gpu/clock.cpp b/src/time/gpu/clock.cpp
index 8ddfc27..4cdb1d5 100644
--- a/src/time/gpu/clock.cpp
+++ b/src/time/gpu/clock.cpp
@@ -7,9 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/time/clock.h"
+#include "src/__support/macros/config.h"
 #include "src/time/gpu/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(clock_t, clock, ()) {
   if (!GPU_CLOCKS_PER_SEC)
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(clock_t, clock, ()) {
   return clock_t(ticks * (CLOCKS_PER_SEC / GPU_CLOCKS_PER_SEC));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/clock_gettime.cpp b/src/time/gpu/clock_gettime.cpp
new file mode 100644
index 0000000..de7899a
--- /dev/null
+++ b/src/time/gpu/clock_gettime.cpp
@@ -0,0 +1,32 @@
+//===---------- GPU implementation of the POSIX clock_gettime function ----===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/clock_gettime.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
+
+LLVM_LIBC_FUNCTION(int, clock_gettime, (clockid_t clockid, timespec *ts)) {
+  if (clockid != CLOCK_MONOTONIC || !ts)
+    return -1;
+
+  uint64_t ns_per_tick = TICKS_PER_SEC / GPU_CLOCKS_PER_SEC;
+  uint64_t ticks = gpu::fixed_frequency_clock();
+
+  ts->tv_nsec = (ticks * ns_per_tick) % TICKS_PER_SEC;
+  ts->tv_sec = (ticks * ns_per_tick) / TICKS_PER_SEC;
+
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/nanosleep.cpp b/src/time/gpu/nanosleep.cpp
index dd669ff..3f4a609 100644
--- a/src/time/gpu/nanosleep.cpp
+++ b/src/time/gpu/nanosleep.cpp
@@ -8,9 +8,10 @@
 
 #include "src/time/nanosleep.h"
 
+#include "src/__support/macros/config.h"
 #include "time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
 
@@ -70,4 +71,4 @@ LLVM_LIBC_FUNCTION(int, nanosleep,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/time_utils.cpp b/src/time/gpu/time_utils.cpp
index 1a674b2..38e09f6 100644
--- a/src/time/gpu/time_utils.cpp
+++ b/src/time/gpu/time_utils.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "time_utils.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 #if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
 // This is expected to be initialized by the runtime if the default value is
@@ -18,4 +19,4 @@ namespace LIBC_NAMESPACE {
 gpu::Constant<uint64_t> __llvm_libc_clock_freq = clock_freq;
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/time_utils.h b/src/time/gpu/time_utils.h
index 77eeb89..c631a38 100644
--- a/src/time/gpu/time_utils.h
+++ b/src/time/gpu/time_utils.h
@@ -12,7 +12,9 @@
 #include "hdr/time_macros.h"
 #include "hdr/types/clock_t.h"
 #include "src/__support/GPU/utils.h"
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 #if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
 // AMDGPU does not have a single set frequency. Different architectures and
@@ -36,6 +38,6 @@ extern gpu::Constant<uint64_t> __llvm_libc_clock_freq;
 #error "Unsupported target"
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_GPU_TIME_UTILS_H
diff --git a/src/time/linux/clock.cpp b/src/time/linux/clock.cpp
index 2c1eee8..f43e1bc 100644
--- a/src/time/linux/clock.cpp
+++ b/src/time/linux/clock.cpp
@@ -10,11 +10,12 @@
 #include "hdr/time_macros.h"
 #include "src/__support/CPP/limits.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/clock_gettime.h"
 #include "src/__support/time/units.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(clock_t, clock, ()) {
   using namespace time_units;
@@ -43,4 +44,4 @@ LLVM_LIBC_FUNCTION(clock_t, clock, ()) {
                  ts.tv_nsec / (1_s_ns / CLOCKS_PER_SEC));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/linux/clock_gettime.cpp b/src/time/linux/clock_gettime.cpp
index d7b8cfd..a2b20a6 100644
--- a/src/time/linux/clock_gettime.cpp
+++ b/src/time/linux/clock_gettime.cpp
@@ -8,10 +8,11 @@
 
 #include "src/time/clock_gettime.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/clock_gettime.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO(michaelrj): Move this into time/linux with the other syscalls.
 LLVM_LIBC_FUNCTION(int, clock_gettime,
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, clock_gettime,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/linux/gettimeofday.cpp b/src/time/linux/gettimeofday.cpp
index f868f5f..19d9988 100644
--- a/src/time/linux/gettimeofday.cpp
+++ b/src/time/linux/gettimeofday.cpp
@@ -10,11 +10,12 @@
 #include "hdr/time_macros.h"
 #include "hdr/types/suseconds_t.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/clock_gettime.h"
 #include "src/__support/time/units.h"
 #include "src/errno/libc_errno.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO(michaelrj): Move this into time/linux with the other syscalls.
 LLVM_LIBC_FUNCTION(int, gettimeofday,
@@ -38,4 +39,4 @@ LLVM_LIBC_FUNCTION(int, gettimeofday,
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/linux/nanosleep.cpp b/src/time/linux/nanosleep.cpp
index bcfe567..7a85637 100644
--- a/src/time/linux/nanosleep.cpp
+++ b/src/time/linux/nanosleep.cpp
@@ -7,15 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/time/nanosleep.h"
-
+#include "hdr/time_macros.h"
 #include "src/__support/OSUtil/syscall.h" // For syscall functions.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <stdint.h>      // For int64_t.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, nanosleep,
                    (const struct timespec *req, struct timespec *rem)) {
@@ -38,4 +39,4 @@ LLVM_LIBC_FUNCTION(int, nanosleep,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/linux/time.cpp b/src/time/linux/time.cpp
index 32f531e..20fb86e 100644
--- a/src/time/linux/time.cpp
+++ b/src/time/linux/time.cpp
@@ -8,11 +8,12 @@
 
 #include "hdr/time_macros.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/time/linux/clock_gettime.h"
 #include "src/errno/libc_errno.h"
 #include "src/time/time_func.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(time_t, time, (time_t * tp)) {
   // TODO: Use the Linux VDSO to fetch the time and avoid the syscall.
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(time_t, time, (time_t * tp)) {
   return time_t(ts.tv_sec);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/mktime.cpp b/src/time/mktime.cpp
index 8a4397e..72cd229 100644
--- a/src/time/mktime.cpp
+++ b/src/time/mktime.cpp
@@ -8,9 +8,10 @@
 
 #include "src/time/mktime.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using LIBC_NAMESPACE::time_utils::TimeConstants;
 
@@ -41,12 +42,18 @@ LLVM_LIBC_FUNCTION(time_t, mktime, (struct tm * tm_out)) {
       return time_utils::out_of_range();
     if (tm_out->tm_mday > 19)
       return time_utils::out_of_range();
-    if (tm_out->tm_hour > 3)
-      return time_utils::out_of_range();
-    if (tm_out->tm_min > 14)
-      return time_utils::out_of_range();
-    if (tm_out->tm_sec > 7)
-      return time_utils::out_of_range();
+    else if (tm_out->tm_mday == 19) {
+      if (tm_out->tm_hour > 3)
+        return time_utils::out_of_range();
+      else if (tm_out->tm_hour == 3) {
+        if (tm_out->tm_min > 14)
+          return time_utils::out_of_range();
+        else if (tm_out->tm_min == 14) {
+          if (tm_out->tm_sec > 7)
+            return time_utils::out_of_range();
+        }
+      }
+    }
   }
 
   // Years are ints.  A 32-bit year will fit into a 64-bit time_t.
@@ -112,4 +119,4 @@ LLVM_LIBC_FUNCTION(time_t, mktime, (struct tm * tm_out)) {
   return static_cast<time_t>(seconds);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/mktime.h b/src/time/mktime.h
index a50e97c..2b4c679 100644
--- a/src/time/mktime.h
+++ b/src/time/mktime.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_TIME_MKTIME_H
 #define LLVM_LIBC_SRC_TIME_MKTIME_H
 
+#include "src/__support/macros/config.h"
 #include <time.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 time_t mktime(struct tm *t1);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_MKTIME_H
diff --git a/src/time/nanosleep.h b/src/time/nanosleep.h
index 2309666..11b7ac0 100644
--- a/src/time/nanosleep.h
+++ b/src/time/nanosleep.h
@@ -10,11 +10,12 @@
 #define LLVM_LIBC_SRC_TIME_NANOSLEEP_H
 
 #include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int nanosleep(const timespec *req, timespec *rem);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_NANOSLEEP_H
diff --git a/src/time/time_func.h b/src/time/time_func.h
index 2a52392..9cfd6cd 100644
--- a/src/time/time_func.h
+++ b/src/time/time_func.h
@@ -10,13 +10,14 @@
 #define LLVM_LIBC_SRC_TIME_TIME_FUNC_H
 
 #include "hdr/types/time_t.h"
+#include "src/__support/macros/config.h"
 
 // Note this header file is named time_func.h to avoid conflicts with the
 // public header file time.h.
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 time_t time(time_t *tp);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_TIME_FUNC_H
diff --git a/src/time/time_utils.cpp b/src/time/time_utils.cpp
index 713ed21..509cad8 100644
--- a/src/time/time_utils.cpp
+++ b/src/time/time_utils.cpp
@@ -9,8 +9,9 @@
 #include "src/time/time_utils.h"
 #include "src/__support/CPP/limits.h" // INT_MIN, INT_MAX
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace time_utils {
 
 using LIBC_NAMESPACE::time_utils::TimeConstants;
@@ -150,4 +151,4 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
 }
 
 } // namespace time_utils
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/time_utils.h b/src/time/time_utils.h
index a5da3ad..552ea92 100644
--- a/src/time/time_utils.h
+++ b/src/time/time_utils.h
@@ -12,12 +12,13 @@
 #include <stddef.h> // For size_t.
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/time/mktime.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace time_utils {
 
 enum Month : int {
@@ -91,7 +92,12 @@ extern int64_t update_from_seconds(int64_t total_seconds, struct tm *tm);
 
 // POSIX.1-2017 requires this.
 LIBC_INLINE time_t out_of_range() {
+#ifdef EOVERFLOW
+  // For non-POSIX uses of the standard C time functions, where EOVERFLOW is
+  // not defined, it's OK not to set errno at all. The plain C standard doesn't
+  // require it.
   libc_errno = EOVERFLOW;
+#endif
   return TimeConstants::OUT_OF_RANGE_RETURN_VALUE;
 }
 
@@ -150,7 +156,14 @@ LIBC_INLINE struct tm *gmtime_internal(const time_t *timer, struct tm *result) {
   return result;
 }
 
+// TODO: localtime is not yet implemented and a temporary solution is to
+//       use gmtime, https://github.com/llvm/llvm-project/issues/107597
+LIBC_INLINE struct tm *localtime(const time_t *t_ptr) {
+  static struct tm result;
+  return time_utils::gmtime_internal(t_ptr, &result);
+}
+
 } // namespace time_utils
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_TIME_UTILS_H
diff --git a/src/unistd/_exit.cpp b/src/unistd/_exit.cpp
index 4b652a2..854bf8b 100644
--- a/src/unistd/_exit.cpp
+++ b/src/unistd/_exit.cpp
@@ -9,11 +9,12 @@
 #include "src/unistd/_exit.h"
 #include "src/__support/OSUtil/exit.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] LLVM_LIBC_FUNCTION(void, _exit, (int status)) {
   internal::exit(status);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/_exit.h b/src/unistd/_exit.h
index 141b875..e00e27c 100644
--- a/src/unistd/_exit.h
+++ b/src/unistd/_exit.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD__EXIT_H
 #define LLVM_LIBC_SRC_UNISTD__EXIT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 [[noreturn]] void _exit(int status);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD__EXIT_H
diff --git a/src/unistd/access.h b/src/unistd/access.h
index 7623c85..1471224 100644
--- a/src/unistd/access.h
+++ b/src/unistd/access.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_ACCESS_H
 #define LLVM_LIBC_SRC_UNISTD_ACCESS_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int access(const char *path, int mode);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_ACCESS_H
diff --git a/src/unistd/chdir.h b/src/unistd/chdir.h
index ca1dd35..db2b4da 100644
--- a/src/unistd/chdir.h
+++ b/src/unistd/chdir.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_CHDIR_H
 #define LLVM_LIBC_SRC_UNISTD_CHDIR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int chdir(const char *path);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_CHDIR_H
diff --git a/src/unistd/close.h b/src/unistd/close.h
index 02e01c2..599be83 100644
--- a/src/unistd/close.h
+++ b/src/unistd/close.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_CLOSE_H
 #define LLVM_LIBC_SRC_UNISTD_CLOSE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int close(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_CLOSE_H
diff --git a/src/unistd/dup.h b/src/unistd/dup.h
index d6daa5a..63f093c 100644
--- a/src/unistd/dup.h
+++ b/src/unistd/dup.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP_H
 #define LLVM_LIBC_SRC_UNISTD_DUP_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int dup(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_DUP_H
diff --git a/src/unistd/dup2.h b/src/unistd/dup2.h
index ba8c5f4..060c112 100644
--- a/src/unistd/dup2.h
+++ b/src/unistd/dup2.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP2_H
 #define LLVM_LIBC_SRC_UNISTD_DUP2_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int dup2(int oldfd, int newfd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_DUP2_H
diff --git a/src/unistd/dup3.h b/src/unistd/dup3.h
index 2b10824..f386886 100644
--- a/src/unistd/dup3.h
+++ b/src/unistd/dup3.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP3_H
 #define LLVM_LIBC_SRC_UNISTD_DUP3_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int dup3(int oldfd, int newfd, int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_DUP3_H
diff --git a/src/unistd/environ.cpp b/src/unistd/environ.cpp
index 2266c72..db7faef 100644
--- a/src/unistd/environ.cpp
+++ b/src/unistd/environ.cpp
@@ -6,11 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 // This is initialized to the correct value by the statup code.
 extern "C" {
 char **environ = nullptr;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/environ.h b/src/unistd/environ.h
index c09a04f..af98967 100644
--- a/src/unistd/environ.h
+++ b/src/unistd/environ.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_ENVIRON_H
 #define LLVM_LIBC_SRC_UNISTD_ENVIRON_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 extern "C" char **environ;
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_ENVIRON_H
diff --git a/src/unistd/execv.h b/src/unistd/execv.h
index 7ff3664..86bf999 100644
--- a/src/unistd/execv.h
+++ b/src/unistd/execv.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_EXECV_H
 #define LLVM_LIBC_SRC_UNISTD_EXECV_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int execv(const char *path, char *const argv[]);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_EXECV_H
diff --git a/src/unistd/execve.h b/src/unistd/execve.h
index 0054a47..fe3b930 100644
--- a/src/unistd/execve.h
+++ b/src/unistd/execve.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_EXECVE_H
 #define LLVM_LIBC_SRC_UNISTD_EXECVE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int execve(const char *path, char *const argv[], char *const envp[]);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_EXECVE_H
diff --git a/src/unistd/fchdir.h b/src/unistd/fchdir.h
index 267785c..8d1a53b 100644
--- a/src/unistd/fchdir.h
+++ b/src/unistd/fchdir.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FCHDIR_H
 #define LLVM_LIBC_SRC_UNISTD_FCHDIR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fchdir(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_FCHDIR_H
diff --git a/src/unistd/fork.h b/src/unistd/fork.h
index 6b1b72a..b6fd576 100644
--- a/src/unistd/fork.h
+++ b/src/unistd/fork.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FORK_H
 #define LLVM_LIBC_SRC_UNISTD_FORK_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t fork();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_FORK_H
diff --git a/src/unistd/fpathconf.h b/src/unistd/fpathconf.h
new file mode 100644
index 0000000..610e242
--- /dev/null
+++ b/src/unistd/fpathconf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for fpathconf ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_FPATHCONF_H
+#define LLVM_LIBC_SRC_UNISTD_FPATHCONF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long fpathconf(int fd, int name);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_FSYNC_H
diff --git a/src/unistd/fsync.h b/src/unistd/fsync.h
index b5742de..5bbf179 100644
--- a/src/unistd/fsync.h
+++ b/src/unistd/fsync.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FSYNC_H
 #define LLVM_LIBC_SRC_UNISTD_FSYNC_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int fsync(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_FSYNC_H
diff --git a/src/unistd/ftruncate.h b/src/unistd/ftruncate.h
index 5508ef0..cd8d363 100644
--- a/src/unistd/ftruncate.h
+++ b/src/unistd/ftruncate.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FTRUNCATE_H
 #define LLVM_LIBC_SRC_UNISTD_FTRUNCATE_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int ftruncate(int, off_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_FTRUNCATE_H
diff --git a/src/unistd/getcwd.h b/src/unistd/getcwd.h
index ab7038e..8b63a91 100644
--- a/src/unistd/getcwd.h
+++ b/src/unistd/getcwd.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETCWD_H
 #define LLVM_LIBC_SRC_UNISTD_GETCWD_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 char *getcwd(char *buf, size_t size);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETCWD_H
diff --git a/src/unistd/geteuid.h b/src/unistd/geteuid.h
index f19cbae..9469797 100644
--- a/src/unistd/geteuid.h
+++ b/src/unistd/geteuid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETEUID_H
 #define LLVM_LIBC_SRC_UNISTD_GETEUID_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uid_t geteuid();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETEUID_H
diff --git a/src/unistd/getopt.cpp b/src/unistd/getopt.cpp
index ccdfdc6..0dba01f 100644
--- a/src/unistd/getopt.cpp
+++ b/src/unistd/getopt.cpp
@@ -11,15 +11,16 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/File/file.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/fprintf.h"
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
 
 // This is POSIX compliant and does not support GNU extensions, mainly this is
 // just the re-ordering of argv elements such that unknown arguments can be
 // easily iterated over.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename T> struct RefWrapper {
   RefWrapper() = delete;
@@ -202,4 +203,4 @@ LLVM_LIBC_FUNCTION(int, getopt,
   return getopt_r(argc, argv, optstring, impl::ctx);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/getopt.h b/src/unistd/getopt.h
index ae27958..1be3331 100644
--- a/src/unistd/getopt.h
+++ b/src/unistd/getopt.h
@@ -9,10 +9,11 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETOPT_H
 #define LLVM_LIBC_SRC_UNISTD_GETOPT_H
 
-#include <stdio.h>
+#include "hdr/types/FILE.h"
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace impl {
 void set_getopt_state(char **, int *, int *, unsigned *, int *, FILE *);
@@ -20,6 +21,6 @@ void set_getopt_state(char **, int *, int *, unsigned *, int *, FILE *);
 
 int getopt(int argc, char *const argv[], const char *optstring);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETOPT_H
diff --git a/src/unistd/getpid.h b/src/unistd/getpid.h
index 5890dbf..c3c55b0 100644
--- a/src/unistd/getpid.h
+++ b/src/unistd/getpid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETPID_H
 #define LLVM_LIBC_SRC_UNISTD_GETPID_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t getpid();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETPID_H
diff --git a/src/unistd/getppid.h b/src/unistd/getppid.h
index a09c7ca..d820791 100644
--- a/src/unistd/getppid.h
+++ b/src/unistd/getppid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETPPID_H
 #define LLVM_LIBC_SRC_UNISTD_GETPPID_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 pid_t getppid();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETPPID_H
diff --git a/src/unistd/gettid.cpp b/src/unistd/gettid.cpp
new file mode 100644
index 0000000..f3d87ef
--- /dev/null
+++ b/src/unistd/gettid.cpp
@@ -0,0 +1,17 @@
+//===-- Implementation file for gettid --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/gettid.h"
+#include "src/__support/common.h"
+#include "src/__support/threads/identifier.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(pid_t, gettid, ()) { return internal::gettid(); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/gettid.h b/src/unistd/gettid.h
new file mode 100644
index 0000000..48f5d22
--- /dev/null
+++ b/src/unistd/gettid.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for gettid ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_GETTID_H
+#define LLVM_LIBC_SRC_UNISTD_GETTID_H
+
+#include "hdr/types/pid_t.h"
+#include "src/__support/common.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+pid_t gettid();
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_GETTID_H
diff --git a/src/unistd/getuid.h b/src/unistd/getuid.h
index 3516378..dd82c71 100644
--- a/src/unistd/getuid.h
+++ b/src/unistd/getuid.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETUID_H
 #define LLVM_LIBC_SRC_UNISTD_GETUID_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 uid_t getuid();
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_GETUID_H
diff --git a/src/unistd/isatty.h b/src/unistd/isatty.h
index 90a1697..6dd1b7b 100644
--- a/src/unistd/isatty.h
+++ b/src/unistd/isatty.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_ISATTY_H
 #define LLVM_LIBC_SRC_UNISTD_ISATTY_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int isatty(int fd);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_ISATTY_H
diff --git a/src/unistd/link.h b/src/unistd/link.h
index a95111f..9b27aa1 100644
--- a/src/unistd/link.h
+++ b/src/unistd/link.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_LINK_H
 #define LLVM_LIBC_SRC_UNISTD_LINK_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int link(const char *, const char *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_LINK_H
diff --git a/src/unistd/linkat.h b/src/unistd/linkat.h
index c53b87e..bb03e31 100644
--- a/src/unistd/linkat.h
+++ b/src/unistd/linkat.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_LINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_LINKAT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int linkat(int, const char *, int, const char *, int);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_LINKAT_H
diff --git a/src/unistd/linux/access.cpp b/src/unistd/linux/access.cpp
index f062ad4..2f7ebbc 100644
--- a/src/unistd/linux/access.cpp
+++ b/src/unistd/linux/access.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, access, (const char *path, int mode)) {
 #ifdef SYS_access
@@ -34,4 +35,4 @@ LLVM_LIBC_FUNCTION(int, access, (const char *path, int mode)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/chdir.cpp b/src/unistd/linux/chdir.cpp
index 61d44ff..a30d1dc 100644
--- a/src/unistd/linux/chdir.cpp
+++ b/src/unistd/linux/chdir.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, chdir, (const char *path)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_chdir, path);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, chdir, (const char *path)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/close.cpp b/src/unistd/linux/close.cpp
index 0843348..58d42a9 100644
--- a/src/unistd/linux/close.cpp
+++ b/src/unistd/linux/close.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, close, (int fd)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_close, fd);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, close, (int fd)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/dup.cpp b/src/unistd/linux/dup.cpp
index a2e7d3f..c1710a3 100644
--- a/src/unistd/linux/dup.cpp
+++ b/src/unistd/linux/dup.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, dup, (int fd)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_dup, fd);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, dup, (int fd)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/dup2.cpp b/src/unistd/linux/dup2.cpp
index f6804e2..c7c7c1a 100644
--- a/src/unistd/linux/dup2.cpp
+++ b/src/unistd/linux/dup2.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, dup2, (int oldfd, int newfd)) {
 #ifdef SYS_dup2
@@ -52,4 +53,4 @@ LLVM_LIBC_FUNCTION(int, dup2, (int oldfd, int newfd)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/dup3.cpp b/src/unistd/linux/dup3.cpp
index bf2c257..c096ba7 100644
--- a/src/unistd/linux/dup3.cpp
+++ b/src/unistd/linux/dup3.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, dup3, (int oldfd, int newfd, int flags)) {
   // If dup2 syscall is available, we make use of directly.
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, dup3, (int oldfd, int newfd, int flags)) {
   return -1;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/execv.cpp b/src/unistd/linux/execv.cpp
index bd134ca..a3f2525 100644
--- a/src/unistd/linux/execv.cpp
+++ b/src/unistd/linux/execv.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/unistd/execv.h"
+#include "src/__support/macros/config.h"
 #include "src/unistd/environ.h"
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
@@ -15,7 +16,7 @@
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, execv, (const char *path, char *const argv[])) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_execve, path, argv,
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, execv, (const char *path, char *const argv[])) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/execve.cpp b/src/unistd/linux/execve.cpp
index b6de0a4..37162c4 100644
--- a/src/unistd/linux/execve.cpp
+++ b/src/unistd/linux/execve.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/unistd/execve.h"
+#include "src/__support/macros/config.h"
 #include "src/unistd/environ.h"
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
@@ -15,7 +16,7 @@
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, execve,
                    (const char *path, char *const argv[], char *const envp[])) {
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(int, execve,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/fchdir.cpp b/src/unistd/linux/fchdir.cpp
index d24b9ba..8196dc6 100644
--- a/src/unistd/linux/fchdir.cpp
+++ b/src/unistd/linux/fchdir.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fchdir, (int fd)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_fchdir, fd);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, fchdir, (int fd)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/fork.cpp b/src/unistd/linux/fork.cpp
index 6fa2b99..8aa0477 100644
--- a/src/unistd/linux/fork.cpp
+++ b/src/unistd/linux/fork.cpp
@@ -10,33 +10,41 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/fork_callbacks.h"
+#include "src/__support/threads/identifier.h"
 #include "src/__support/threads/thread.h" // For thread self object
 
 #include "src/errno/libc_errno.h"
 #include <signal.h>      // For SIGCHLD
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // The implementation of fork here is very minimal. We will add more
 // functionality and standard compliance in future.
 
 LLVM_LIBC_FUNCTION(pid_t, fork, (void)) {
   invoke_prepare_callbacks();
+  pid_t parent_tid = internal::gettid();
+  // Invalidate parent's tid cache before forking. We cannot do this in child
+  // process because in the post-fork instruction windows, there may be a signal
+  // handler triggered which may get the wrong tid.
+  internal::force_set_tid(0);
 #ifdef SYS_fork
-  pid_t ret = LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_fork);
+  pid_t ret = syscall_impl<pid_t>(SYS_fork);
 #elif defined(SYS_clone)
-  pid_t ret = LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_clone, SIGCHLD, 0);
+  pid_t ret = syscall_impl<pid_t>(SYS_clone, SIGCHLD, 0);
 #else
 #error "fork and clone syscalls not available."
 #endif
+
   if (ret == 0) {
     // Return value is 0 in the child process.
     // The child is created with a single thread whose self object will be a
     // copy of parent process' thread which called fork. So, we have to fix up
     // the child process' self object with the new process' tid.
-    self.attrib->tid = LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_gettid);
+    internal::force_set_tid(syscall_impl<pid_t>(SYS_gettid));
     invoke_child_callbacks();
     return 0;
   }
@@ -46,9 +54,10 @@ LLVM_LIBC_FUNCTION(pid_t, fork, (void)) {
     libc_errno = static_cast<int>(-ret);
     return -1;
   }
-
+  // recover parent's tid.
+  internal::force_set_tid(parent_tid);
   invoke_parent_callbacks();
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/fpathconf.cpp b/src/unistd/linux/fpathconf.cpp
new file mode 100644
index 0000000..8e0c8bc
--- /dev/null
+++ b/src/unistd/linux/fpathconf.cpp
@@ -0,0 +1,25 @@
+//===-- Linux implementation of fpathconf ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/fpathconf.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/sys/statvfs/linux/statfs_utils.h"
+#include "src/unistd/linux/pathconf_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long, fpathconf, (int fd, int name)) {
+  if (cpp::optional<statfs_utils::LinuxStatFs> result =
+          statfs_utils::linux_fstatfs(fd))
+    return pathconfig(result.value(), name);
+  return -1;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/fsync.cpp b/src/unistd/linux/fsync.cpp
index 44d504e..ae3895b 100644
--- a/src/unistd/linux/fsync.cpp
+++ b/src/unistd/linux/fsync.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fsync, (int fd)) {
   int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_fsync, fd);
@@ -25,4 +26,4 @@ LLVM_LIBC_FUNCTION(int, fsync, (int fd)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/ftruncate.cpp b/src/unistd/linux/ftruncate.cpp
index 795bb98..39cb3b5 100644
--- a/src/unistd/linux/ftruncate.cpp
+++ b/src/unistd/linux/ftruncate.cpp
@@ -11,12 +11,13 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ftruncate, (int fd, off_t len)) {
 #ifdef SYS_ftruncate
@@ -37,4 +38,4 @@ LLVM_LIBC_FUNCTION(int, ftruncate, (int fd, off_t len)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/getcwd.cpp b/src/unistd/linux/getcwd.cpp
index 11c58f1..1bb11a7 100644
--- a/src/unistd/linux/getcwd.cpp
+++ b/src/unistd/linux/getcwd.cpp
@@ -10,14 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/string/allocating_string_utils.h" // For strdup.
 
 #include "src/errno/libc_errno.h"
 #include <linux/limits.h> // This is safe to include without any name pollution.
-#include <stdlib.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
@@ -63,4 +63,4 @@ LLVM_LIBC_FUNCTION(char *, getcwd, (char *buf, size_t size)) {
   return buf;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/geteuid.cpp b/src/unistd/linux/geteuid.cpp
index 2a7f163..a4bbcc0 100644
--- a/src/unistd/linux/geteuid.cpp
+++ b/src/unistd/linux/geteuid.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uid_t, geteuid, ()) {
   return LIBC_NAMESPACE::syscall_impl<uid_t>(SYS_geteuid);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/getpid.cpp b/src/unistd/linux/getpid.cpp
index 8573073..b24c86a 100644
--- a/src/unistd/linux/getpid.cpp
+++ b/src/unistd/linux/getpid.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, getpid, ()) {
   return LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_getpid);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/getppid.cpp b/src/unistd/linux/getppid.cpp
index 7ee11f3..c55329d 100644
--- a/src/unistd/linux/getppid.cpp
+++ b/src/unistd/linux/getppid.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(pid_t, getppid, ()) {
   return LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_getppid);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/getuid.cpp b/src/unistd/linux/getuid.cpp
index c813180..ce818ec 100644
--- a/src/unistd/linux/getuid.cpp
+++ b/src/unistd/linux/getuid.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(uid_t, getuid, ()) {
   return LIBC_NAMESPACE::syscall_impl<uid_t>(SYS_getuid);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/isatty.cpp b/src/unistd/linux/isatty.cpp
index 2050138..e6ea22a 100644
--- a/src/unistd/linux/isatty.cpp
+++ b/src/unistd/linux/isatty.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <sys/ioctl.h>   // For ioctl numbers.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, isatty, (int fd)) {
   constexpr int INIT_VAL = 0x1234abcd;
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, isatty, (int fd)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/link.cpp b/src/unistd/linux/link.cpp
index b5024ad..477806a 100644
--- a/src/unistd/linux/link.cpp
+++ b/src/unistd/linux/link.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, link, (const char *path1, const char *path2)) {
 #ifdef SYS_link
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, link, (const char *path1, const char *path2)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/linkat.cpp b/src/unistd/linux/linkat.cpp
index c5d071e..40f68cc 100644
--- a/src/unistd/linux/linkat.cpp
+++ b/src/unistd/linux/linkat.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, linkat,
                    (int fd1, const char *path1, int fd2, const char *path2,
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(int, linkat,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/lseek.cpp b/src/unistd/linux/lseek.cpp
index 6f3d993..9486cec 100644
--- a/src/unistd/linux/lseek.cpp
+++ b/src/unistd/linux/lseek.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/unistd/lseek.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include "src/__support/File/linux/lseekImpl.h"
@@ -16,7 +17,7 @@
 #include <sys/syscall.h> // For syscall numbers.
 #include <unistd.h>      // For off_t.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(off_t, lseek, (int fd, off_t offset, int whence)) {
   auto result = internal::lseekimpl(fd, offset, whence);
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(off_t, lseek, (int fd, off_t offset, int whence)) {
   return result.value();
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pathconf.cpp b/src/unistd/linux/pathconf.cpp
new file mode 100644
index 0000000..ca1c10b
--- /dev/null
+++ b/src/unistd/linux/pathconf.cpp
@@ -0,0 +1,24 @@
+//===-- Linux implementation of pathconf ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/pathconf.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include "src/sys/statvfs/linux/statfs_utils.h"
+#include "src/unistd/linux/pathconf_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(long, pathconf, (const char *path, int name)) {
+  if (cpp::optional<statfs_utils::LinuxStatFs> result =
+          statfs_utils::linux_statfs(path))
+    return pathconfig(result.value(), name);
+  return -1;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pathconf_utils.cpp b/src/unistd/linux/pathconf_utils.cpp
new file mode 100644
index 0000000..035e628
--- /dev/null
+++ b/src/unistd/linux/pathconf_utils.cpp
@@ -0,0 +1,128 @@
+//===-- Linux implementation of pathconf_utils ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// This header must go before limits_macros.h otherwise libc header may choose
+// to undefine LINK_MAX.
+#include <linux/limits.h> // For LINK_MAX and other limits
+
+#include "hdr/limits_macros.h"
+#include "hdr/unistd_macros.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include "src/sys/statvfs/linux/statfs_utils.h"
+
+// other linux specific includes
+#include <linux/bfs_fs.h>
+#if __has_include(<linux/ufs_fs.h>)
+#include <linux/ufs_fs.h>
+#else
+// from https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/
+#define UFS_MAGIC 0x00011954
+#endif
+#include <linux/magic.h> // For common FS magics
+
+namespace LIBC_NAMESPACE_DECL {
+
+long filesizebits(const statfs_utils::LinuxStatFs &s) {
+  switch (s.f_type) {
+  case JFFS2_SUPER_MAGIC:
+  case MSDOS_SUPER_MAGIC:
+  case NCP_SUPER_MAGIC:
+    return 32;
+  }
+  return 64;
+}
+
+long link_max(const statfs_utils::LinuxStatFs &s) {
+  switch (s.f_type) {
+  case EXT2_SUPER_MAGIC:
+    return 32000;
+  case MINIX_SUPER_MAGIC:
+    return 250;
+  case MINIX2_SUPER_MAGIC:
+    return 65530;
+  case REISERFS_SUPER_MAGIC:
+    return 0xffff - 1000;
+  case UFS_MAGIC:
+    return 32000;
+  }
+  return LINK_MAX;
+}
+
+long symlinks(const statfs_utils::LinuxStatFs &s) {
+  switch (s.f_type) {
+  case ADFS_SUPER_MAGIC:
+  case BFS_MAGIC:
+  case CRAMFS_MAGIC:
+  case EFS_SUPER_MAGIC:
+  case MSDOS_SUPER_MAGIC:
+  case QNX4_SUPER_MAGIC:
+    return 0;
+  }
+  return 1;
+}
+
+long pathconfig(const statfs_utils::LinuxStatFs &s, int name) {
+  switch (name) {
+  case _PC_LINK_MAX:
+    return link_max(s);
+
+  case _PC_FILESIZEBITS:
+    return filesizebits(s);
+
+  case _PC_2_SYMLINKS:
+    return symlinks(s);
+
+  case _PC_REC_MIN_XFER_SIZE:
+    return s.f_bsize;
+
+  case _PC_ALLOC_SIZE_MIN:
+  case _PC_REC_XFER_ALIGN:
+    return s.f_frsize;
+
+  case _PC_MAX_CANON:
+    return _POSIX_MAX_CANON;
+
+  case _PC_MAX_INPUT:
+    return _POSIX_MAX_INPUT;
+
+  case _PC_NAME_MAX:
+    return s.f_namelen;
+
+  case _PC_PATH_MAX:
+    return _POSIX_PATH_MAX;
+
+  case _PC_PIPE_BUF:
+    return _POSIX_PIPE_BUF;
+
+  case _PC_CHOWN_RESTRICTED:
+    return _POSIX_CHOWN_RESTRICTED;
+
+  case _PC_NO_TRUNC:
+    return _POSIX_NO_TRUNC;
+
+  case _PC_VDISABLE:
+    return _POSIX_VDISABLE;
+
+  case _PC_ASYNC_IO:
+  case _PC_PRIO_IO:
+  case _PC_REC_INCR_XFER_SIZE:
+  case _PC_REC_MAX_XFER_SIZE:
+  case _PC_SYMLINK_MAX:
+  case _PC_SYNC_IO:
+    return -1;
+
+  default:
+    libc_errno = EINVAL;
+    return -1;
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pathconf_utils.h b/src/unistd/linux/pathconf_utils.h
new file mode 100644
index 0000000..bd34de2
--- /dev/null
+++ b/src/unistd/linux/pathconf_utils.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for pathconf_utils ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_PATHCONF_UTILS_H
+#define LLVM_LIBC_SRC_UNISTD_PATHCONF_UTILS_H
+
+#include "src/__support/macros/config.h"
+#include "src/sys/statvfs/linux/statfs_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long pathconfig(const statfs_utils::LinuxStatFs &s, int name);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_PREAD_H
diff --git a/src/unistd/linux/pipe.cpp b/src/unistd/linux/pipe.cpp
index 8cfb8d1..dfcd5bf 100644
--- a/src/unistd/linux/pipe.cpp
+++ b/src/unistd/linux/pipe.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h" // for MSAN_UNPOISON
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, pipe, (int pipefd[2])) {
 #ifdef SYS_pipe
@@ -32,4 +33,4 @@ LLVM_LIBC_FUNCTION(int, pipe, (int pipefd[2])) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pipe2.cpp b/src/unistd/linux/pipe2.cpp
new file mode 100644
index 0000000..ebe7e01
--- /dev/null
+++ b/src/unistd/linux/pipe2.cpp
@@ -0,0 +1,30 @@
+//===-- Linux implementation of pipe --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/pipe2.h"
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, pipe2, (int pipefd[2], int flags)) {
+  int ret = LIBC_NAMESPACE::syscall_impl<int>(
+      SYS_pipe2, reinterpret_cast<long>(pipefd), flags);
+  if (ret < 0) {
+    libc_errno = -ret;
+    return -1;
+  }
+  MSAN_UNPOISON(pipefd, sizeof(int) * 2);
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pread.cpp b/src/unistd/linux/pread.cpp
index 11cefc5..3e27857 100644
--- a/src/unistd/linux/pread.cpp
+++ b/src/unistd/linux/pread.cpp
@@ -10,24 +10,31 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h" // for MSAN_UNPOISON
 #include "src/errno/libc_errno.h"
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, pread,
                    (int fd, void *buf, size_t count, off_t offset)) {
-#ifdef LIBC_TARGET_ARCH_IS_RISCV32
-  static_assert(sizeof(off_t) == 8);
-  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
-      SYS_pread64, fd, buf, count, (long)offset,
-      (long)(((uint64_t)(offset)) >> 32));
-#else
-  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pread64, fd, buf,
-                                                      count, offset);
-#endif
+  ssize_t ret;
+  if constexpr (sizeof(long) == sizeof(uint32_t) &&
+                sizeof(off_t) == sizeof(uint64_t)) {
+    // This is a 32-bit system with a 64-bit offset, offset must be split.
+    const uint64_t bits = cpp::bit_cast<uint64_t>(offset);
+    const uint32_t lo = bits & UINT32_MAX;
+    const uint32_t hi = bits >> 32;
+    const long offset_low = cpp::bit_cast<long>(static_cast<long>(lo));
+    const long offset_high = cpp::bit_cast<long>(static_cast<long>(hi));
+    ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pread64, fd, buf, count,
+                                                offset_low, offset_high);
+  } else {
+    ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pread64, fd, buf, count,
+                                                offset);
+  }
   // The cast is important since there is a check that dereferences the pointer
   // which fails on void*.
   MSAN_UNPOISON(reinterpret_cast<char *>(buf), count);
@@ -38,4 +45,4 @@ LLVM_LIBC_FUNCTION(ssize_t, pread,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/pwrite.cpp b/src/unistd/linux/pwrite.cpp
index 6c6a0b5..1b81b2a 100644
--- a/src/unistd/linux/pwrite.cpp
+++ b/src/unistd/linux/pwrite.cpp
@@ -11,23 +11,32 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, pwrite,
                    (int fd, const void *buf, size_t count, off_t offset)) {
-#ifdef LIBC_TARGET_ARCH_IS_RISCV32
-  static_assert(sizeof(off_t) == 8);
-  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(
-      SYS_pwrite64, fd, buf, count, (long)offset,
-      (long)(((uint64_t)(offset)) >> 32));
-#else
-  ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pwrite64, fd, buf,
-                                                      count, offset);
-#endif
+
+  ssize_t ret;
+  if constexpr (sizeof(long) == sizeof(uint32_t) &&
+                sizeof(off_t) == sizeof(uint64_t)) {
+    // This is a 32-bit system with a 64-bit offset, offset must be split.
+    const uint64_t bits = cpp::bit_cast<uint64_t>(offset);
+    const uint32_t lo = bits & UINT32_MAX;
+    const uint32_t hi = bits >> 32;
+    const long offset_low = cpp::bit_cast<long>(static_cast<long>(lo));
+    const long offset_high = cpp::bit_cast<long>(static_cast<long>(hi));
+    ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pwrite64, fd, buf, count,
+                                                offset_low, offset_high);
+  } else {
+    ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_pwrite64, fd, buf, count,
+                                                offset);
+  }
+
   if (ret < 0) {
     libc_errno = static_cast<int>(-ret);
     return -1;
@@ -35,4 +44,4 @@ LLVM_LIBC_FUNCTION(ssize_t, pwrite,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/read.cpp b/src/unistd/linux/read.cpp
index 41be1eb..4419900 100644
--- a/src/unistd/linux/read.cpp
+++ b/src/unistd/linux/read.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h" // for MSAN_UNPOISON
 #include "src/errno/libc_errno.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, read, (int fd, void *buf, size_t count)) {
   ssize_t ret = LIBC_NAMESPACE::syscall_impl<ssize_t>(SYS_read, fd, buf, count);
@@ -28,4 +29,4 @@ LLVM_LIBC_FUNCTION(ssize_t, read, (int fd, void *buf, size_t count)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/readlink.cpp b/src/unistd/linux/readlink.cpp
index 8dee58c..2055e6b 100644
--- a/src/unistd/linux/readlink.cpp
+++ b/src/unistd/linux/readlink.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, readlink,
                    (const char *__restrict path, char *__restrict buf,
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(ssize_t, readlink,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/readlinkat.cpp b/src/unistd/linux/readlinkat.cpp
index 479735d..e5e4d0d 100644
--- a/src/unistd/linux/readlinkat.cpp
+++ b/src/unistd/linux/readlinkat.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, readlinkat,
                    (int fd, const char *__restrict path, char *__restrict buf,
@@ -29,4 +30,4 @@ LLVM_LIBC_FUNCTION(ssize_t, readlinkat,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/rmdir.cpp b/src/unistd/linux/rmdir.cpp
index 234b0c3..075af12 100644
--- a/src/unistd/linux/rmdir.cpp
+++ b/src/unistd/linux/rmdir.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, rmdir, (const char *path)) {
 #ifdef SYS_rmdir
@@ -34,4 +35,4 @@ LLVM_LIBC_FUNCTION(int, rmdir, (const char *path)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/symlink.cpp b/src/unistd/linux/symlink.cpp
index e8983e2..9e1b288 100644
--- a/src/unistd/linux/symlink.cpp
+++ b/src/unistd/linux/symlink.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, symlink, (const char *path1, const char *path2)) {
 #ifdef SYS_symlink
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, symlink, (const char *path1, const char *path2)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/symlinkat.cpp b/src/unistd/linux/symlinkat.cpp
index 64f02d1..bcf2d0f 100644
--- a/src/unistd/linux/symlinkat.cpp
+++ b/src/unistd/linux/symlinkat.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, symlinkat,
                    (const char *path1, int fd, const char *path2)) {
@@ -27,4 +28,4 @@ LLVM_LIBC_FUNCTION(int, symlinkat,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/syscall.cpp b/src/unistd/linux/syscall.cpp
index e0070fe..5394bff 100644
--- a/src/unistd/linux/syscall.cpp
+++ b/src/unistd/linux/syscall.cpp
@@ -11,10 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <stdarg.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, __llvm_libc_syscall,
                    (long number, long arg1, long arg2, long arg3, long arg4,
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(long, __llvm_libc_syscall,
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/sysconf.cpp b/src/unistd/linux/sysconf.cpp
index d4577c8..1540eb4 100644
--- a/src/unistd/linux/sysconf.cpp
+++ b/src/unistd/linux/sysconf.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/common.h"
 
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/sys/auxv/getauxval.h"
 #include <sys/auxv.h>
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, sysconf, (int name)) {
   long ret = 0;
@@ -30,4 +31,4 @@ LLVM_LIBC_FUNCTION(long, sysconf, (int name)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/truncate.cpp b/src/unistd/linux/truncate.cpp
index 0120cc7..283cf40 100644
--- a/src/unistd/linux/truncate.cpp
+++ b/src/unistd/linux/truncate.cpp
@@ -10,13 +10,14 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, truncate, (const char *path, off_t len)) {
 #ifdef SYS_truncate
@@ -36,4 +37,4 @@ LLVM_LIBC_FUNCTION(int, truncate, (const char *path, off_t len)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/unlink.cpp b/src/unistd/linux/unlink.cpp
index e62fb8f..72d8e23 100644
--- a/src/unistd/linux/unlink.cpp
+++ b/src/unistd/linux/unlink.cpp
@@ -11,11 +11,12 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <fcntl.h>
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, unlink, (const char *path)) {
 #ifdef SYS_unlink
@@ -33,4 +34,4 @@ LLVM_LIBC_FUNCTION(int, unlink, (const char *path)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/unlinkat.cpp b/src/unistd/linux/unlinkat.cpp
index 4ec5e38..4ed20f5 100644
--- a/src/unistd/linux/unlinkat.cpp
+++ b/src/unistd/linux/unlinkat.cpp
@@ -10,12 +10,13 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, unlinkat, (int dfd, const char *path, int flags)) {
 #ifdef SYS_unlinkat
@@ -31,4 +32,4 @@ LLVM_LIBC_FUNCTION(int, unlinkat, (int dfd, const char *path, int flags)) {
   return 0;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/write.cpp b/src/unistd/linux/write.cpp
index bd6c911..99d5ab7 100644
--- a/src/unistd/linux/write.cpp
+++ b/src/unistd/linux/write.cpp
@@ -10,11 +10,12 @@
 
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
 #include <sys/syscall.h> // For syscall numbers.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(ssize_t, write, (int fd, const void *buf, size_t count)) {
   ssize_t ret =
@@ -26,4 +27,4 @@ LLVM_LIBC_FUNCTION(ssize_t, write, (int fd, const void *buf, size_t count)) {
   return ret;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/lseek.h b/src/unistd/lseek.h
index 75e33d8..a8704ec 100644
--- a/src/unistd/lseek.h
+++ b/src/unistd/lseek.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_LSEEK_H
 #define LLVM_LIBC_SRC_UNISTD_LSEEK_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 off_t lseek(int fd, off_t offset, int whence);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_LSEEK_H
diff --git a/src/unistd/pathconf.h b/src/unistd/pathconf.h
new file mode 100644
index 0000000..d6b891e
--- /dev/null
+++ b/src/unistd/pathconf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for pathconf ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_PATHCONF_H
+#define LLVM_LIBC_SRC_UNISTD_PATHCONF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long pathconf(const char *path, int name);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_PREAD_H
diff --git a/src/unistd/pipe.h b/src/unistd/pipe.h
index 0e20bb4..d5cccf3 100644
--- a/src/unistd/pipe.h
+++ b/src/unistd/pipe.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_PIPE_H
 #define LLVM_LIBC_SRC_UNISTD_PIPE_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int pipe(int pipefd[2]);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_PIPE_H
diff --git a/src/unistd/pipe2.h b/src/unistd/pipe2.h
new file mode 100644
index 0000000..7118f4a
--- /dev/null
+++ b/src/unistd/pipe2.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for pipe2 -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_PIPE2_H
+#define LLVM_LIBC_SRC_UNISTD_PIPE2_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int pipe2(int pipefd[2], int flags);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_PIPE2_H
diff --git a/src/unistd/pread.h b/src/unistd/pread.h
index 6ecfef4..4723675 100644
--- a/src/unistd/pread.h
+++ b/src/unistd/pread.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_PREAD_H
 #define LLVM_LIBC_SRC_UNISTD_PREAD_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t pread(int fd, void *buf, size_t count, off_t offset);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_PREAD_H
diff --git a/src/unistd/pwrite.h b/src/unistd/pwrite.h
index 535c921..baffbe4 100644
--- a/src/unistd/pwrite.h
+++ b/src/unistd/pwrite.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_PWRITE_H
 #define LLVM_LIBC_SRC_UNISTD_PWRITE_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_PWRITE_H
diff --git a/src/unistd/read.h b/src/unistd/read.h
index 05a56a2..01231cb 100644
--- a/src/unistd/read.h
+++ b/src/unistd/read.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READ_H
 #define LLVM_LIBC_SRC_UNISTD_READ_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t read(int fd, void *buf, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_READ_H
diff --git a/src/unistd/readlink.h b/src/unistd/readlink.h
index c93c430..a73e974 100644
--- a/src/unistd/readlink.h
+++ b/src/unistd/readlink.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READLINK_H
 #define LLVM_LIBC_SRC_UNISTD_READLINK_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t readlink(const char *__restrict, char *__restrict, size_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_READLINK_H
diff --git a/src/unistd/readlinkat.h b/src/unistd/readlinkat.h
index a4357ef..6bdd48b 100644
--- a/src/unistd/readlinkat.h
+++ b/src/unistd/readlinkat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READLINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_READLINKAT_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t readlinkat(int, const char *__restrict, char *__restrict, size_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_READLINKAT_H
diff --git a/src/unistd/rmdir.h b/src/unistd/rmdir.h
index 55dcbaf..abf5bf7 100644
--- a/src/unistd/rmdir.h
+++ b/src/unistd/rmdir.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_RMDIR_H
 #define LLVM_LIBC_SRC_UNISTD_RMDIR_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int rmdir(const char *path);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_RMDIR_H
diff --git a/src/unistd/swab.cpp b/src/unistd/swab.cpp
index 5c2f507..643079a 100644
--- a/src/unistd/swab.cpp
+++ b/src/unistd/swab.cpp
@@ -9,8 +9,9 @@
 #include "src/unistd/swab.h"
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, swab,
                    (const void *__restrict from, void *__restrict to,
@@ -23,4 +24,4 @@ LLVM_LIBC_FUNCTION(void, swab,
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/swab.h b/src/unistd/swab.h
index 0a6aa49..caa9c71 100644
--- a/src/unistd/swab.h
+++ b/src/unistd/swab.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SWAB_H
 #define LLVM_LIBC_SRC_UNISTD_SWAB_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h> // For ssize_t
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 void swab(const void *__restrict from, void *__restrict to, ssize_t n);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_SWAB_H
diff --git a/src/unistd/symlink.h b/src/unistd/symlink.h
index 0a0124c..47f04f8 100644
--- a/src/unistd/symlink.h
+++ b/src/unistd/symlink.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYMLINK_H
 #define LLVM_LIBC_SRC_UNISTD_SYMLINK_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int symlink(const char *, const char *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_SYMLINK_H
diff --git a/src/unistd/symlinkat.h b/src/unistd/symlinkat.h
index ecca438..9f8ad51 100644
--- a/src/unistd/symlinkat.h
+++ b/src/unistd/symlinkat.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYMLINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_SYMLINKAT_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int symlinkat(const char *, int, const char *);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_SYMLINKAT_H
diff --git a/src/unistd/syscall.h b/src/unistd/syscall.h
index a41d977..db70745 100644
--- a/src/unistd/syscall.h
+++ b/src/unistd/syscall.h
@@ -9,14 +9,15 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYSCALL_H
 #define LLVM_LIBC_SRC_UNISTD_SYSCALL_H
 
+#include "src/__support/macros/config.h"
 #include <stdarg.h>
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long __llvm_libc_syscall(long number, long arg1, long arg2, long arg3,
                          long arg4, long arg5, long arg6);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_SYSCALL_H
diff --git a/src/unistd/sysconf.h b/src/unistd/sysconf.h
index 89c5efa..1b3f39e 100644
--- a/src/unistd/sysconf.h
+++ b/src/unistd/sysconf.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYSCONF_H
 #define LLVM_LIBC_SRC_UNISTD_SYSCONF_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 long sysconf(int name);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_SYSCONF_H
diff --git a/src/unistd/truncate.h b/src/unistd/truncate.h
index 5245b6b..9ba5cf8 100644
--- a/src/unistd/truncate.h
+++ b/src/unistd/truncate.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_TRUNCATE_H
 #define LLVM_LIBC_SRC_UNISTD_TRUNCATE_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int truncate(const char *, off_t);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_TRUNCATE_H
diff --git a/src/unistd/unlink.h b/src/unistd/unlink.h
index d1d34fa..71ef19f 100644
--- a/src/unistd/unlink.h
+++ b/src/unistd/unlink.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_UNLINK_H
 #define LLVM_LIBC_SRC_UNISTD_UNLINK_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int unlink(const char *path);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_UNLINK_H
diff --git a/src/unistd/unlinkat.h b/src/unistd/unlinkat.h
index 81d23bd..2ce46b8 100644
--- a/src/unistd/unlinkat.h
+++ b/src/unistd/unlinkat.h
@@ -9,10 +9,12 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_UNLINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_UNLINKAT_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 
 int unlinkat(int dfd, const char *path, int flags);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_UNLINKAT_H
diff --git a/src/unistd/write.h b/src/unistd/write.h
index 52cdff3..e40ce19 100644
--- a/src/unistd/write.h
+++ b/src/unistd/write.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_WRITE_H
 #define LLVM_LIBC_SRC_UNISTD_WRITE_H
 
+#include "src/__support/macros/config.h"
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 ssize_t write(int fd, const void *buf, size_t count);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_UNISTD_WRITE_H
diff --git a/src/wchar/btowc.cpp b/src/wchar/btowc.cpp
index 040c60e..c69f77d 100644
--- a/src/wchar/btowc.cpp
+++ b/src/wchar/btowc.cpp
@@ -8,13 +8,15 @@
 
 #include "src/wchar/btowc.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/wctype_utils.h"
 
-#include <stdio.h> // for EOF.
+#include "hdr/types/wint_t.h"
+#include "hdr/wchar_macros.h" // for WEOF.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(int, btowc, (wint_t c)) {
+LLVM_LIBC_FUNCTION(wint_t, btowc, (int c)) {
   auto result = internal::btowc(c);
   if (result.has_value()) {
     return result.value();
@@ -23,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, btowc, (wint_t c)) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/wchar/btowc.h b/src/wchar/btowc.h
index de67f15..ef70ee2 100644
--- a/src/wchar/btowc.h
+++ b/src/wchar/btowc.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_WCHAR_BTOWC_H
 #define LLVM_LIBC_SRC_WCHAR_BTOWC_H
 
-#include <wchar.h>
+#include "hdr/types/wint_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 wint_t btowc(int c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_WCHAR_BTOWC_H
diff --git a/src/wchar/wctob.cpp b/src/wchar/wctob.cpp
index 538d538..45240d6 100644
--- a/src/wchar/wctob.cpp
+++ b/src/wchar/wctob.cpp
@@ -8,11 +8,13 @@
 
 #include "src/wchar/wctob.h"
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/wctype_utils.h"
 
-#include <stdio.h> // for EOF.
+#include "hdr/stdio_macros.h" // for EOF.
+#include "hdr/types/wint_t.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, wctob, (wint_t c)) {
   auto result = internal::wctob(c);
@@ -23,4 +25,4 @@ LLVM_LIBC_FUNCTION(int, wctob, (wint_t c)) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/wchar/wctob.h b/src/wchar/wctob.h
index 1cc0c21..8ae89fa 100644
--- a/src/wchar/wctob.h
+++ b/src/wchar/wctob.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_SRC_WCHAR_WCTOB_H
 #define LLVM_LIBC_SRC_WCHAR_WCTOB_H
 
-#include <wchar.h>
+#include "hdr/types/wint_t.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int wctob(wint_t c);
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_WCHAR_WCTOB_H
diff --git a/test/IntegrationTest/test.cpp b/test/IntegrationTest/test.cpp
index 2751f31..871bdf0 100644
--- a/test/IntegrationTest/test.cpp
+++ b/test/IntegrationTest/test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 #include <stdint.h>
 
@@ -19,7 +20,7 @@
 // entrypoint to the internal implementation of the function used for testing.
 // This is done manually as not all targets support aliases.
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int bcmp(const void *lhs, const void *rhs, size_t count);
 void bzero(void *ptr, size_t count);
@@ -29,7 +30,7 @@ void *memmove(void *dst, const void *src, size_t count);
 void *memset(void *ptr, int value, size_t count);
 int atexit(void (*func)(void));
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 extern "C" {
 
diff --git a/test/UnitTest/BazelFilePath.cpp b/test/UnitTest/BazelFilePath.cpp
index 7973086..ee5fcaa 100644
--- a/test/UnitTest/BazelFilePath.cpp
+++ b/test/UnitTest/BazelFilePath.cpp
@@ -12,8 +12,10 @@
 
 #include "src/__support/CPP/string.h"
 #include "src/__support/c_string.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 CString libc_make_test_file_path_func(const char *file_name) {
   // This is the path to the folder bazel wants the test outputs written to.
@@ -22,4 +24,5 @@ CString libc_make_test_file_path_func(const char *file_name) {
   return cpp::string(UNDECLARED_OUTPUTS_PATH) + file_name;
 }
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/CmakeFilePath.cpp b/test/UnitTest/CmakeFilePath.cpp
index 2a7d1c3..b7bc5a8 100644
--- a/test/UnitTest/CmakeFilePath.cpp
+++ b/test/UnitTest/CmakeFilePath.cpp
@@ -10,11 +10,14 @@
 
 #include "src/__support/CPP/string.h"
 #include "src/__support/c_string.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 CString libc_make_test_file_path_func(const char *file_name) {
   return cpp::string(file_name);
 }
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/ErrnoSetterMatcher.h b/test/UnitTest/ErrnoSetterMatcher.h
index 745ba41..a895c50 100644
--- a/test/UnitTest/ErrnoSetterMatcher.h
+++ b/test/UnitTest/ErrnoSetterMatcher.h
@@ -12,11 +12,12 @@
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/fpbits_str.h"
 #include "src/__support/StringUtil/error_to_string.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/errno/libc_errno.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 namespace internal {
@@ -182,6 +183,6 @@ static ErrnoSetterMatcherBuilder<RetT> returns(internal::Comparator<RetT> cmp) {
 } // namespace ErrnoSetterMatcher
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_ERRNOSETTERMATCHER_H
diff --git a/test/UnitTest/ExecuteFunction.h b/test/UnitTest/ExecuteFunction.h
index 9595056..511249b 100644
--- a/test/UnitTest/ExecuteFunction.h
+++ b/test/UnitTest/ExecuteFunction.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_TEST_UNITTEST_EXECUTEFUNCTION_H
 #define LLVM_LIBC_TEST_UNITTEST_EXECUTEFUNCTION_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testutils {
 
 class FunctionCaller {
@@ -47,6 +48,6 @@ invoke_in_subprocess(FunctionCaller *func,
 const char *signal_as_string(int signum);
 
 } // namespace testutils
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_UNITTEST_EXECUTEFUNCTION_H
diff --git a/test/UnitTest/ExecuteFunctionUnix.cpp b/test/UnitTest/ExecuteFunctionUnix.cpp
index b244337..3a657c0 100644
--- a/test/UnitTest/ExecuteFunctionUnix.cpp
+++ b/test/UnitTest/ExecuteFunctionUnix.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "ExecuteFunction.h"
+#include "src/__support/macros/config.h"
 #include <cassert>
 #include <cstdlib>
 #include <cstring>
@@ -17,7 +18,7 @@
 #include <sys/wait.h>
 #include <unistd.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testutils {
 
 bool ProcessStatus::exited_normally() { return WIFEXITED(platform_defined); }
@@ -78,4 +79,4 @@ ProcessStatus invoke_in_subprocess(FunctionCaller *func, unsigned timeout_ms) {
 const char *signal_as_string(int signum) { return ::strsignal(signum); }
 
 } // namespace testutils
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/FEnvSafeTest.cpp b/test/UnitTest/FEnvSafeTest.cpp
index 905aa92..168b1d4 100644
--- a/test/UnitTest/FEnvSafeTest.cpp
+++ b/test/UnitTest/FEnvSafeTest.cpp
@@ -9,9 +9,11 @@
 #include "FEnvSafeTest.h"
 
 #include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 void FEnvSafeTest::PreserveFEnv::check() {
   fenv_t after;
@@ -81,4 +83,5 @@ void FEnvSafeTest::expect_fenv_eq(const fenv_t &before_fenv,
 #endif
 }
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/FEnvSafeTest.h b/test/UnitTest/FEnvSafeTest.h
index d5a8bb7..a3c5e62 100644
--- a/test/UnitTest/FEnvSafeTest.h
+++ b/test/UnitTest/FEnvSafeTest.h
@@ -11,9 +11,11 @@
 
 #include "hdr/types/fenv_t.h"
 #include "src/__support/CPP/utility.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 // This provides a test fixture (or base class for other test fixtures) that
 // asserts that each test does not leave the FPU state represented by `fenv_t`
@@ -96,6 +98,7 @@ private:
   bool should_be_unchanged = false;
 };
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_UNITTEST_FPENVSAFE_H
diff --git a/test/UnitTest/FPExceptMatcher.cpp b/test/UnitTest/FPExceptMatcher.cpp
index c1dfc53..37ba0a0 100644
--- a/test/UnitTest/FPExceptMatcher.cpp
+++ b/test/UnitTest/FPExceptMatcher.cpp
@@ -8,6 +8,7 @@
 
 #include "FPExceptMatcher.h"
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/types/fenv_t.h"
@@ -18,7 +19,7 @@
 
 #if LIBC_TEST_HAS_MATCHERS()
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 #if defined(_WIN32)
@@ -52,6 +53,6 @@ FPExceptMatcher::FPExceptMatcher(FunctionCaller *func) {
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TEST_HAS_MATCHERS()
diff --git a/test/UnitTest/FPExceptMatcher.h b/test/UnitTest/FPExceptMatcher.h
index 5136e38..978501d 100644
--- a/test/UnitTest/FPExceptMatcher.h
+++ b/test/UnitTest/FPExceptMatcher.h
@@ -9,12 +9,13 @@
 #ifndef LLVM_LIBC_TEST_UNITTEST_FPEXCEPTMATCHER_H
 #define LLVM_LIBC_TEST_UNITTEST_FPEXCEPTMATCHER_H
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 #include "test/UnitTest/TestLogger.h"
 
 #if LIBC_TEST_HAS_MATCHERS()
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 // TODO: Make the matcher match specific exceptions instead of just identifying
@@ -51,7 +52,7 @@ public:
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define ASSERT_RAISES_FP_EXCEPT(func)                                          \
   ASSERT_THAT(                                                                 \
diff --git a/test/UnitTest/FPMatcher.h b/test/UnitTest/FPMatcher.h
index 86b8232..9f2bae3 100644
--- a/test/UnitTest/FPMatcher.h
+++ b/test/UnitTest/FPMatcher.h
@@ -11,16 +11,21 @@
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/CPP/type_traits/is_complex.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/fpbits_str.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/architectures.h"
 #include "test/UnitTest/RoundingModeUtils.h"
 #include "test/UnitTest/StringUtils.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/math_macros.h"
 
-namespace LIBC_NAMESPACE {
+using LIBC_NAMESPACE::Sign;
+
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 template <typename T, TestCond Condition> class FPMatcher : public Matcher<T> {
@@ -57,10 +62,111 @@ public:
   }
 };
 
+template <typename T, TestCond Condition> class CFPMatcher : public Matcher<T> {
+  static_assert(
+      cpp::is_complex_v<T>,
+      "CFPMatcher can only be used with complex floating point values.");
+  static_assert(Condition == TestCond::EQ || Condition == TestCond::NE,
+                "Unsupported CFPMatcher test condition.");
+
+  T expected;
+  T actual;
+
+public:
+  CFPMatcher(T expectedValue) : expected(expectedValue) {}
+
+  template <typename CFT> bool matchComplex() {
+    CFT *actualCmplxPtr = reinterpret_cast<CFT *>(&actual);
+    CFT *expectedCmplxPtr = reinterpret_cast<CFT *>(&expected);
+    CFT actualReal = actualCmplxPtr[0];
+    CFT actualImag = actualCmplxPtr[1];
+    CFT expectedReal = expectedCmplxPtr[0];
+    CFT expectedImag = expectedCmplxPtr[1];
+    fputil::FPBits<CFT> actualRealBits(actualReal),
+        expectedRealBits(expectedReal);
+    fputil::FPBits<CFT> actualImagBits(actualImag),
+        expectedImagBits(expectedImag);
+    if (Condition == TestCond::EQ)
+      return ((actualRealBits.is_nan() && expectedRealBits.is_nan()) ||
+              (actualRealBits.uintval() == expectedRealBits.uintval())) &&
+             ((actualImagBits.is_nan() && expectedImagBits.is_nan()) ||
+              (actualImagBits.uintval() == expectedImagBits.uintval()));
+
+    // If condition == TestCond::NE.
+    if (actualRealBits.is_nan() && expectedRealBits.is_nan())
+      return !expectedRealBits.is_nan() && !expectedImagBits.is_nan();
+    if (actualRealBits.is_nan())
+      return !expectedRealBits.is_nan();
+    if (actualImagBits.is_nan())
+      return !expectedImagBits.is_nan();
+    return (expectedRealBits.is_nan() ||
+            actualRealBits.uintval() != expectedRealBits.uintval()) &&
+           (expectedImagBits.is_nan() ||
+            actualImagBits.uintval() != expectedImagBits.uintval());
+  }
+
+  template <typename CFT> void explainErrorComplex() {
+    CFT *actualCmplxPtr = reinterpret_cast<CFT *>(&actual);
+    CFT *expectedCmplxPtr = reinterpret_cast<CFT *>(&expected);
+    CFT actualReal = actualCmplxPtr[0];
+    CFT actualImag = actualCmplxPtr[1];
+    CFT expectedReal = expectedCmplxPtr[0];
+    CFT expectedImag = expectedCmplxPtr[1];
+    tlog << "Expected complex floating point value: "
+         << str(fputil::FPBits<CFT>(expectedReal)) + " + " +
+                str(fputil::FPBits<CFT>(expectedImag)) + "i"
+         << '\n';
+    tlog << "Actual complex floating point value: "
+         << str(fputil::FPBits<CFT>(actualReal)) + " + " +
+                str(fputil::FPBits<CFT>(actualImag)) + "i"
+         << '\n';
+  }
+
+  bool match(T actualValue) {
+    actual = actualValue;
+    if constexpr (cpp::is_complex_type_same<T, _Complex float>())
+      return matchComplex<float>();
+    else if constexpr (cpp::is_complex_type_same<T, _Complex double>())
+      return matchComplex<double>();
+    else if constexpr (cpp::is_complex_type_same<T, _Complex long double>())
+      return matchComplex<long double>();
+#ifdef LIBC_TYPES_HAS_CFLOAT16
+    else if constexpr (cpp::is_complex_type_same<T, cfloat16>)
+      return matchComplex<float16>();
+#endif
+#ifdef LIBC_TYPES_HAS_CFLOAT128
+    else if constexpr (cpp::is_complex_type_same<T, cfloat128>)
+      return matchComplex<float128>();
+#endif
+  }
+
+  void explainError() override {
+    if constexpr (cpp::is_complex_type_same<T, _Complex float>())
+      return explainErrorComplex<float>();
+    else if constexpr (cpp::is_complex_type_same<T, _Complex double>())
+      return explainErrorComplex<double>();
+    else if constexpr (cpp::is_complex_type_same<T, _Complex long double>())
+      return explainErrorComplex<long double>();
+#ifdef LIBC_TYPES_HAS_CFLOAT16
+    else if constexpr (cpp::is_complex_type_same<T, cfloat16>)
+      return explainErrorComplex<float16>();
+#endif
+#ifdef LIBC_TYPES_HAS_CFLOAT128
+    else if constexpr (cpp::is_complex_type_same<T, cfloat128>)
+      return explainErrorComplex<float128>();
+#endif
+  }
+};
+
 template <TestCond C, typename T> FPMatcher<T, C> getMatcher(T expectedValue) {
   return FPMatcher<T, C>(expectedValue);
 }
 
+template <TestCond C, typename T>
+CFPMatcher<T, C> getMatcherComplex(T expectedValue) {
+  return CFPMatcher<T, C>(expectedValue);
+}
+
 template <typename T> struct FPTest : public Test {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
   using StorageType = typename FPBits::StorageType;
@@ -68,12 +174,14 @@ template <typename T> struct FPTest : public Test {
       LIBC_NAMESPACE::cpp::numeric_limits<StorageType>::max();
   static constexpr T zero = FPBits::zero(Sign::POS).get_val();
   static constexpr T neg_zero = FPBits::zero(Sign::NEG).get_val();
-  static constexpr T aNaN = FPBits::quiet_nan().get_val();
+  static constexpr T aNaN = FPBits::quiet_nan(Sign::POS).get_val();
+  static constexpr T neg_aNaN = FPBits::quiet_nan(Sign::NEG).get_val();
   static constexpr T sNaN = FPBits::signaling_nan().get_val();
   static constexpr T inf = FPBits::inf(Sign::POS).get_val();
   static constexpr T neg_inf = FPBits::inf(Sign::NEG).get_val();
   static constexpr T min_normal = FPBits::min_normal().get_val();
-  static constexpr T max_normal = FPBits::max_normal().get_val();
+  static constexpr T max_normal = FPBits::max_normal(Sign::POS).get_val();
+  static constexpr T neg_max_normal = FPBits::max_normal(Sign::NEG).get_val();
   static constexpr T min_denormal = FPBits::min_subnormal().get_val();
   static constexpr T max_denormal = FPBits::max_subnormal().get_val();
 
@@ -86,8 +194,33 @@ template <typename T> struct FPTest : public Test {
   };
 };
 
+// Add facility to test Flush-Denormal-To-Zero (FTZ) and Denormal-As-Zero (DAZ)
+// modes.
+// These tests to ensure that our implementations will not crash under these
+// modes.
+#if defined(LIBC_TARGET_ARCH_IS_X86_64) && __has_builtin(__builtin_ia32_stmxcsr)
+
+#define LIBC_TEST_FTZ_DAZ
+
+static constexpr unsigned FTZ = 0x8000; // Flush denormal to zero
+static constexpr unsigned DAZ = 0x0040; // Denormal as zero
+
+struct ModifyMXCSR {
+  ModifyMXCSR(unsigned flags) {
+    old_mxcsr = __builtin_ia32_stmxcsr();
+    __builtin_ia32_ldmxcsr(old_mxcsr | flags);
+  }
+
+  ~ModifyMXCSR() { __builtin_ia32_ldmxcsr(old_mxcsr); }
+
+private:
+  unsigned old_mxcsr;
+};
+
+#endif
+
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define DECLARE_SPECIAL_CONSTANTS(T)                                           \
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;                            \
@@ -121,6 +254,10 @@ template <typename T> struct FPTest : public Test {
   EXPECT_THAT(actual, LIBC_NAMESPACE::testing::getMatcher<                     \
                           LIBC_NAMESPACE::testing::TestCond::EQ>(expected))
 
+#define EXPECT_CFP_EQ(expected, actual)                                        \
+  EXPECT_THAT(actual, LIBC_NAMESPACE::testing::getMatcherComplex<              \
+                          LIBC_NAMESPACE::testing::TestCond::EQ>(expected))
+
 #define TEST_FP_EQ(expected, actual)                                           \
   LIBC_NAMESPACE::testing::getMatcher<LIBC_NAMESPACE::testing::TestCond::EQ>(  \
       expected)                                                                \
@@ -161,31 +298,35 @@ template <typename T> struct FPTest : public Test {
 #define EXPECT_FP_EXCEPTION(expected)                                          \
   do {                                                                         \
     if (math_errhandling & MATH_ERREXCEPT) {                                   \
-      EXPECT_EQ(LIBC_NAMESPACE::fputil::test_except(FE_ALL_EXCEPT) &           \
-                    ((expected) ? (expected) : FE_ALL_EXCEPT),                 \
-                (expected));                                                   \
+      EXPECT_EQ(                                                               \
+          LIBC_NAMESPACE::fputil::test_except(                                 \
+              static_cast<int>(FE_ALL_EXCEPT)) &                               \
+              ((expected) ? (expected) : static_cast<int>(FE_ALL_EXCEPT)),     \
+          (expected));                                                         \
     }                                                                          \
   } while (0)
 
 #define ASSERT_FP_EXCEPTION(expected)                                          \
   do {                                                                         \
     if (math_errhandling & MATH_ERREXCEPT) {                                   \
-      ASSERT_EQ(LIBC_NAMESPACE::fputil::test_except(FE_ALL_EXCEPT) &           \
-                    ((expected) ? (expected) : FE_ALL_EXCEPT),                 \
-                (expected));                                                   \
+      ASSERT_EQ(                                                               \
+          LIBC_NAMESPACE::fputil::test_except(                                 \
+              static_cast<int>(FE_ALL_EXCEPT)) &                               \
+              ((expected) ? (expected) : static_cast<int>(FE_ALL_EXCEPT)),     \
+          (expected));                                                         \
     }                                                                          \
   } while (0)
 
 #define EXPECT_FP_EQ_WITH_EXCEPTION(expected_val, actual_val, expected_except) \
   do {                                                                         \
-    LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT);                       \
+    LIBC_NAMESPACE::fputil::clear_except(static_cast<int>(FE_ALL_EXCEPT));     \
     EXPECT_FP_EQ(expected_val, actual_val);                                    \
     EXPECT_FP_EXCEPTION(expected_except);                                      \
   } while (0)
 
 #define EXPECT_FP_IS_NAN_WITH_EXCEPTION(actual_val, expected_except)           \
   do {                                                                         \
-    LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT);                       \
+    LIBC_NAMESPACE::fputil::clear_except(static_cast<int>(FE_ALL_EXCEPT));     \
     EXPECT_FP_IS_NAN(actual_val);                                              \
     EXPECT_FP_EXCEPTION(expected_except);                                      \
   } while (0)
@@ -232,4 +373,49 @@ template <typename T> struct FPTest : public Test {
 #define EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO(expected, actual)                    \
   EXPECT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::TowardZero)
 
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                             \
+    expected, actual, expected_except, rounding_mode)                          \
+  do {                                                                         \
+    using namespace LIBC_NAMESPACE::fputil::testing;                           \
+    ForceRoundingMode __r((rounding_mode));                                    \
+    if (__r.success) {                                                         \
+      LIBC_NAMESPACE::fputil::clear_except(static_cast<int>(FE_ALL_EXCEPT));   \
+      EXPECT_FP_EQ((expected), (actual));                                      \
+      EXPECT_FP_EXCEPTION(expected_except);                                    \
+    }                                                                          \
+  } while (0)
+
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(expected, actual,         \
+                                                     expected_except)          \
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                                   \
+      (expected), (actual), (expected_except), RoundingMode::Nearest)
+
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(expected, actual,          \
+                                                    expected_except)           \
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                                   \
+      (expected), (actual), (expected_except), RoundingMode::Upward)
+
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(expected, actual,        \
+                                                      expected_except)         \
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                                   \
+      (expected), (actual), (expected_except), RoundingMode::Downward)
+
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(expected, actual,     \
+                                                         expected_except)      \
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                                   \
+      (expected), (actual), (expected_except), RoundingMode::TowardZero)
+
+#define EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(expected, actual,             \
+                                                 expected_except)              \
+  do {                                                                         \
+    EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST((expected), (actual),         \
+                                                 (expected_except));           \
+    EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD((expected), (actual),          \
+                                                (expected_except));            \
+    EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD((expected), (actual),        \
+                                                  (expected_except));          \
+    EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO((expected), (actual),     \
+                                                     (expected_except));       \
+  } while (0)
+
 #endif // LLVM_LIBC_TEST_UNITTEST_FPMATCHER_H
diff --git a/test/UnitTest/GTest.h b/test/UnitTest/GTest.h
index d1637d3..fd6be9c 100644
--- a/test/UnitTest/GTest.h
+++ b/test/UnitTest/GTest.h
@@ -9,14 +9,17 @@
 #ifndef LLVM_LIBC_UTILS_UNITTEST_GTEST_H
 #define LLVM_LIBC_UTILS_UNITTEST_GTEST_H
 
+#include "src/__support/macros/config.h"
 #include <gtest/gtest.h>
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 using ::testing::Matcher;
 using ::testing::Test;
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
 
 #define LIBC_TEST_HAS_MATCHERS() (1)
 
diff --git a/test/UnitTest/HermeticTestUtils.cpp b/test/UnitTest/HermeticTestUtils.cpp
index ca854ad..47f813b 100644
--- a/test/UnitTest/HermeticTestUtils.cpp
+++ b/test/UnitTest/HermeticTestUtils.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/common.h"
+#include "src/__support/macros/config.h"
 #include <stddef.h>
 #include <stdint.h>
 
@@ -14,7 +15,7 @@
 #include "src/sys/auxv/getauxval.h"
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int bcmp(const void *lhs, const void *rhs, size_t count);
 void bzero(void *ptr, size_t count);
@@ -30,7 +31,7 @@ int atexit(void (*func)(void));
 // always returns 0 to indicate a failure.
 [[gnu::weak]] unsigned long getauxval(unsigned long id) { return 0; }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 namespace {
 
@@ -123,7 +124,7 @@ unsigned long __getauxval(unsigned long id) {
 
 } // extern "C"
 
-void *operator new(unsigned long size, void *ptr) { return ptr; }
+void *operator new(size_t size, void *ptr) { return ptr; }
 
 void *operator new(size_t size) { return malloc(size); }
 
@@ -136,3 +137,16 @@ void operator delete(void *) {
 }
 
 void operator delete(void *ptr, size_t size) { __builtin_trap(); }
+
+// Defining members in the std namespace is not preferred. But, we do it here
+// so that we can use it to define the operator new which takes std::align_val_t
+// argument.
+namespace std {
+enum class align_val_t : size_t {};
+} // namespace std
+
+void operator delete(void *mem, std::align_val_t) noexcept { __builtin_trap(); }
+
+void operator delete(void *mem, unsigned int, std::align_val_t) noexcept {
+  __builtin_trap();
+}
diff --git a/test/UnitTest/LibcDeathTestExecutors.cpp b/test/UnitTest/LibcDeathTestExecutors.cpp
index fa6d164..77b0559 100644
--- a/test/UnitTest/LibcDeathTestExecutors.cpp
+++ b/test/UnitTest/LibcDeathTestExecutors.cpp
@@ -8,18 +8,24 @@
 
 #include "LibcTest.h"
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/ExecuteFunction.h"
 #include "test/UnitTest/TestLogger.h"
 
 #include <cassert>
 
-namespace LIBC_NAMESPACE {
+namespace {
+constexpr unsigned TIMEOUT_MS = 10000;
+} // Anonymous namespace
+
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 bool Test::testProcessKilled(testutils::FunctionCaller *Func, int Signal,
                              const char *LHSStr, const char *RHSStr,
                              internal::Location Loc) {
-  testutils::ProcessStatus Result = testutils::invoke_in_subprocess(Func, 1000);
+  testutils::ProcessStatus Result =
+      testutils::invoke_in_subprocess(Func, TIMEOUT_MS);
 
   if (const char *error = Result.get_error()) {
     Ctx->markFail();
@@ -31,7 +37,7 @@ bool Test::testProcessKilled(testutils::FunctionCaller *Func, int Signal,
   if (Result.timed_out()) {
     Ctx->markFail();
     tlog << Loc;
-    tlog << "Process timed out after " << 1000 << " milliseconds.\n";
+    tlog << "Process timed out after " << TIMEOUT_MS << " milliseconds.\n";
     return false;
   }
 
@@ -62,7 +68,8 @@ bool Test::testProcessKilled(testutils::FunctionCaller *Func, int Signal,
 bool Test::testProcessExits(testutils::FunctionCaller *Func, int ExitCode,
                             const char *LHSStr, const char *RHSStr,
                             internal::Location Loc) {
-  testutils::ProcessStatus Result = testutils::invoke_in_subprocess(Func, 1000);
+  testutils::ProcessStatus Result =
+      testutils::invoke_in_subprocess(Func, TIMEOUT_MS);
 
   if (const char *error = Result.get_error()) {
     Ctx->markFail();
@@ -74,7 +81,7 @@ bool Test::testProcessExits(testutils::FunctionCaller *Func, int ExitCode,
   if (Result.timed_out()) {
     Ctx->markFail();
     tlog << Loc;
-    tlog << "Process timed out after " << 1000 << " milliseconds.\n";
+    tlog << "Process timed out after " << TIMEOUT_MS << " milliseconds.\n";
     return false;
   }
 
@@ -101,4 +108,4 @@ bool Test::testProcessExits(testutils::FunctionCaller *Func, int ExitCode,
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/LibcTest.cpp b/test/UnitTest/LibcTest.cpp
index 539a2e4..afb1368 100644
--- a/test/UnitTest/LibcTest.cpp
+++ b/test/UnitTest/LibcTest.cpp
@@ -12,6 +12,7 @@
 #include "src/__support/CPP/string.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/fixed_point/fx_rep.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 #include "src/__support/uint128.h"
 #include "test/UnitTest/TestLogger.h"
@@ -27,7 +28,7 @@ extern "C" clock_t clock() noexcept { return LIBC_NAMESPACE::clock(); }
 #define LIBC_TEST_USE_CLOCK
 #endif
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 namespace internal {
@@ -43,7 +44,6 @@ cpp::enable_if_t<(cpp::is_integral_v<T> && (sizeof(T) > sizeof(uint64_t))) ||
                      is_big_int_v<T>,
                  cpp::string>
 describeValue(T Value) {
-  static_assert(sizeof(T) % 8 == 0, "Unsupported size of UInt");
   const IntegerToString<T, radix::Hex::WithPrefix> buffer(Value);
   return buffer.view();
 }
@@ -158,13 +158,13 @@ int Test::runTests(const TestOptions &Options) {
     }
 
     tlog << green << "[ RUN      ] " << reset << TestName << '\n';
-    [[maybe_unused]] const auto start_time = clock();
+    [[maybe_unused]] const uint64_t start_time = clock();
     RunContext Ctx;
     T->SetUp();
     T->setContext(&Ctx);
     T->Run();
     T->TearDown();
-    [[maybe_unused]] const auto end_time = clock();
+    [[maybe_unused]] const uint64_t end_time = clock();
     switch (Ctx.status()) {
     case RunContext::RunResult::Fail:
       tlog << red << "[  FAILED  ] " << reset << TestName << '\n';
@@ -241,6 +241,7 @@ TEST_SPECIALIZATION(__uint128_t);
 
 TEST_SPECIALIZATION(LIBC_NAMESPACE::Int<128>);
 
+TEST_SPECIALIZATION(LIBC_NAMESPACE::UInt<96>);
 TEST_SPECIALIZATION(LIBC_NAMESPACE::UInt<128>);
 TEST_SPECIALIZATION(LIBC_NAMESPACE::UInt<192>);
 TEST_SPECIALIZATION(LIBC_NAMESPACE::UInt<256>);
@@ -296,4 +297,4 @@ bool Test::testMatch(bool MatchResult, MatcherBase &Matcher, const char *LHSStr,
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/LibcTest.h b/test/UnitTest/LibcTest.h
index 42ba37a..b4e3819 100644
--- a/test/UnitTest/LibcTest.h
+++ b/test/UnitTest/LibcTest.h
@@ -12,6 +12,7 @@
 // This is defined as a simple macro in test.h so that it exists for platforms
 // that don't use our test infrastructure. It's defined as a proper function
 // below.
+#include "src/__support/macros/config.h"
 #ifdef libc_make_test_file_path
 #undef libc_make_test_file_path
 #endif // libc_make_test_file_path
@@ -32,7 +33,7 @@
 #include "test/UnitTest/ExecuteFunction.h"
 #include "test/UnitTest/TestLogger.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 // Only the following conditions are supported. Notice that we do not have
@@ -161,6 +162,14 @@ protected:
                           (unsigned long long)RHS, LHSStr, RHSStr, Loc);
   }
 
+  // Helper to allow macro invocations like `ASSERT_EQ(foo, nullptr)`.
+  template <typename ValType,
+            cpp::enable_if_t<cpp::is_pointer_v<ValType>, ValType> = nullptr>
+  bool test(TestCond Cond, ValType LHS, cpp::nullptr_t, const char *LHSStr,
+            const char *RHSStr, internal::Location Loc) {
+    return test(Cond, LHS, static_cast<ValType>(nullptr), LHSStr, RHSStr, Loc);
+  }
+
   template <
       typename ValType,
       cpp::enable_if_t<
@@ -312,7 +321,7 @@ template <typename... Types> using TypeList = internal::TypeList<Types...>;
 CString libc_make_test_file_path_func(const char *file_name);
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 // For TYPED_TEST and TYPED_TEST_F below we need to display which type was used
 // to run the test. The default will return the fully qualified canonical type
diff --git a/test/UnitTest/LibcTestMain.cpp b/test/UnitTest/LibcTestMain.cpp
index 94536e9..c348d5e 100644
--- a/test/UnitTest/LibcTestMain.cpp
+++ b/test/UnitTest/LibcTestMain.cpp
@@ -43,7 +43,15 @@ TestOptions parseOptions(int argc, char **argv) {
 
 } // anonymous namespace
 
-extern "C" int main(int argc, char **argv, char **envp) {
+// The C++ standard forbids declaring the main function with a linkage specifier
+// outisde of 'freestanding' mode, only define the linkage for hermetic tests.
+#if __STDC_HOSTED__
+#define TEST_MAIN int main
+#else
+#define TEST_MAIN extern "C" int main
+#endif
+
+TEST_MAIN(int argc, char **argv, char **envp) {
   LIBC_NAMESPACE::testing::argc = argc;
   LIBC_NAMESPACE::testing::argv = argv;
   LIBC_NAMESPACE::testing::envp = envp;
diff --git a/test/UnitTest/MemoryMatcher.cpp b/test/UnitTest/MemoryMatcher.cpp
index c18bc4a..244f255 100644
--- a/test/UnitTest/MemoryMatcher.cpp
+++ b/test/UnitTest/MemoryMatcher.cpp
@@ -8,13 +8,14 @@
 
 #include "MemoryMatcher.h"
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
 #if LIBC_TEST_HAS_MATCHERS()
 
 using LIBC_NAMESPACE::testing::tlog;
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 template <typename T>
@@ -77,6 +78,6 @@ void MemoryMatcher::explainError() {
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TEST_HAS_MATCHERS()
diff --git a/test/UnitTest/MemoryMatcher.h b/test/UnitTest/MemoryMatcher.h
index ab77eff..6172315 100644
--- a/test/UnitTest/MemoryMatcher.h
+++ b/test/UnitTest/MemoryMatcher.h
@@ -11,15 +11,16 @@
 
 #include "src/__support/CPP/span.h"
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 using MemoryView = LIBC_NAMESPACE::cpp::span<const char>;
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #if !LIBC_TEST_HAS_MATCHERS()
 
@@ -41,7 +42,8 @@ using MemoryView = LIBC_NAMESPACE::cpp::span<const char>;
 
 #else // LIBC_TEST_HAS_MATCHERS()
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 class MemoryMatcher : public Matcher<MemoryView> {
   MemoryView expected;
@@ -57,7 +59,8 @@ public:
   void explainError() override;
 };
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
 
 #define EXPECT_MEM_EQ(expected, actual)                                        \
   EXPECT_THAT(actual, LIBC_NAMESPACE::testing::MemoryMatcher(expected))
diff --git a/test/UnitTest/PrintfMatcher.cpp b/test/UnitTest/PrintfMatcher.cpp
index c830381..4fdcbf1 100644
--- a/test/UnitTest/PrintfMatcher.cpp
+++ b/test/UnitTest/PrintfMatcher.cpp
@@ -9,6 +9,7 @@
 #include "PrintfMatcher.h"
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 
 #include "test/UnitTest/StringUtils.h"
@@ -16,7 +17,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 using printf_core::FormatFlags;
@@ -100,4 +101,4 @@ void FormatSectionMatcher::explainError() {
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/PrintfMatcher.h b/test/UnitTest/PrintfMatcher.h
index a4fbeda..4f79832 100644
--- a/test/UnitTest/PrintfMatcher.h
+++ b/test/UnitTest/PrintfMatcher.h
@@ -9,12 +9,11 @@
 #ifndef LLVM_LIBC_UTILS_UNITTEST_PRINTF_MATCHER_H
 #define LLVM_LIBC_UTILS_UNITTEST_PRINTF_MATCHER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 class FormatSectionMatcher : public Matcher<printf_core::FormatSection> {
@@ -31,7 +30,7 @@ public:
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define EXPECT_PFORMAT_EQ(expected, actual)                                    \
   EXPECT_THAT(actual, LIBC_NAMESPACE::testing::FormatSectionMatcher(expected))
diff --git a/test/UnitTest/RoundingModeUtils.cpp b/test/UnitTest/RoundingModeUtils.cpp
index cb34c5e..46ac204 100644
--- a/test/UnitTest/RoundingModeUtils.cpp
+++ b/test/UnitTest/RoundingModeUtils.cpp
@@ -11,8 +11,9 @@
 #include "src/__support/FPUtil/rounding_mode.h"
 
 #include "hdr/fenv_macros.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 namespace testing {
 
@@ -48,4 +49,4 @@ ForceRoundingMode::~ForceRoundingMode() {
 
 } // namespace testing
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/RoundingModeUtils.h b/test/UnitTest/RoundingModeUtils.h
index b986c98..cdc3699 100644
--- a/test/UnitTest/RoundingModeUtils.h
+++ b/test/UnitTest/RoundingModeUtils.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_TEST_UNITTEST_ROUNDINGMODEUTILS_H
 #define LLVM_LIBC_TEST_UNITTEST_ROUNDINGMODEUTILS_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 namespace testing {
 
@@ -32,6 +33,6 @@ template <RoundingMode R> struct ForceRoundingModeTest : ForceRoundingMode {
 
 } // namespace testing
 } // namespace fputil
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_UNITTEST_ROUNDINGMODEUTILS_H
diff --git a/test/UnitTest/ScanfMatcher.cpp b/test/UnitTest/ScanfMatcher.cpp
index 91cb73f..3e9f2a5 100644
--- a/test/UnitTest/ScanfMatcher.cpp
+++ b/test/UnitTest/ScanfMatcher.cpp
@@ -9,6 +9,7 @@
 #include "ScanfMatcher.h"
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 
 #include "test/UnitTest/StringUtils.h"
@@ -16,7 +17,7 @@
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 using scanf_core::FormatFlags;
@@ -99,4 +100,4 @@ void FormatSectionMatcher::explainError() {
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/ScanfMatcher.h b/test/UnitTest/ScanfMatcher.h
index 0b9a886..cb9d13f 100644
--- a/test/UnitTest/ScanfMatcher.h
+++ b/test/UnitTest/ScanfMatcher.h
@@ -9,12 +9,11 @@
 #ifndef LLVM_LIBC_UTILS_UNITTEST_SCANF_MATCHER_H
 #define LLVM_LIBC_UTILS_UNITTEST_SCANF_MATCHER_H
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
-
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 class FormatSectionMatcher : public Matcher<scanf_core::FormatSection> {
@@ -31,7 +30,7 @@ public:
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define EXPECT_SFORMAT_EQ(expected, actual)                                    \
   EXPECT_THAT(actual, LIBC_NAMESPACE::testing::FormatSectionMatcher(expected))
diff --git a/test/UnitTest/StringUtils.h b/test/UnitTest/StringUtils.h
index 61d74b4..9225881 100644
--- a/test/UnitTest/StringUtils.h
+++ b/test/UnitTest/StringUtils.h
@@ -12,8 +12,9 @@
 #include "src/__support/CPP/string.h"
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/big_int.h"
+#include "src/__support/macros/config.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Return the first N hex digits of an integer as a string in upper case.
 template <typename T>
@@ -32,6 +33,6 @@ int_to_hex(T value, size_t length = sizeof(T) * 2) {
   return "0x" + s;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_UNITTEST_STRINGUTILS_H
diff --git a/test/UnitTest/TestLogger.cpp b/test/UnitTest/TestLogger.cpp
index feba4b5..e1df798 100644
--- a/test/UnitTest/TestLogger.cpp
+++ b/test/UnitTest/TestLogger.cpp
@@ -3,12 +3,13 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/OSUtil/io.h"               // write_to_stderr
 #include "src/__support/big_int.h"                 // is_big_int
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 #include "src/__support/uint128.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 // cpp::string_view specialization
@@ -86,4 +87,4 @@ template TestLogger &TestLogger::operator<< <UInt<320>>(UInt<320>);
 TestLogger tlog;
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/UnitTest/TestLogger.h b/test/UnitTest/TestLogger.h
index 6188bcf..c4dbd3a 100644
--- a/test/UnitTest/TestLogger.h
+++ b/test/UnitTest/TestLogger.h
@@ -9,7 +9,9 @@
 #ifndef LLVM_LIBC_TEST_UNITTEST_TESTLOGGER_H
 #define LLVM_LIBC_TEST_UNITTEST_TESTLOGGER_H
 
-namespace LIBC_NAMESPACE {
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 // A class to log to standard output in the context of hermetic tests.
@@ -22,6 +24,6 @@ struct TestLogger {
 extern TestLogger tlog;
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif /* LLVM_LIBC_TEST_UNITTEST_TESTLOGGER_H */
diff --git a/test/UnitTest/ZxTest.h b/test/UnitTest/ZxTest.h
index e6bd1e8..0881902 100644
--- a/test/UnitTest/ZxTest.h
+++ b/test/UnitTest/ZxTest.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_UTILS_UNITTEST_ZXTEST_H
 #define LLVM_LIBC_UTILS_UNITTEST_ZXTEST_H
 
+#include "src/__support/macros/config.h"
 #include <zxtest/zxtest.h>
 
 #define WITH_SIGNAL(X) #X
@@ -28,11 +29,13 @@
 #define EXPECT_DEATH(FUNC, SIG) ([&] { ASSERT_DEATH(FUNC, SIG); }())
 #endif
 
-namespace LIBC_NAMESPACE::testing {
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
 
 using Test = ::zxtest::Test;
 
-} // namespace LIBC_NAMESPACE::testing
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
 
 // zxtest does not have gmock-style matchers.
 #define LIBC_TEST_HAS_MATCHERS() (0)
diff --git a/test/include/FpClassifyTest.h b/test/include/FpClassifyTest.h
new file mode 100644
index 0000000..067ce4d
--- /dev/null
+++ b/test/include/FpClassifyTest.h
@@ -0,0 +1,49 @@
+//===-- Utility class to test the fpclassify macro  -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_FPCLASSIFY_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_FPCLASSIFY_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T>
+class FpClassifyTest : public LIBC_NAMESPACE::testing::Test {
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*FpClassifyFunc)(T);
+
+  void testSpecialNumbers(FpClassifyFunc func) {
+    EXPECT_EQ(func(aNaN), FP_NAN);
+    EXPECT_EQ(func(neg_aNaN), FP_NAN);
+    EXPECT_EQ(func(sNaN), FP_NAN);
+    EXPECT_EQ(func(neg_sNaN), FP_NAN);
+    EXPECT_EQ(func(inf), FP_INFINITE);
+    EXPECT_EQ(func(neg_inf), FP_INFINITE);
+    EXPECT_EQ(func(min_normal), FP_NORMAL);
+    EXPECT_EQ(func(max_normal), FP_NORMAL);
+    EXPECT_EQ(func(neg_max_normal), FP_NORMAL);
+    EXPECT_EQ(func(min_denormal), FP_SUBNORMAL);
+    EXPECT_EQ(func(neg_min_denormal), FP_SUBNORMAL);
+    EXPECT_EQ(func(max_denormal), FP_SUBNORMAL);
+    EXPECT_EQ(func(zero), FP_ZERO);
+    EXPECT_EQ(func(neg_zero), FP_ZERO);
+  }
+};
+
+#define LIST_FPCLASSIFY_TESTS(T, func)                                         \
+  using LlvmLibcFpClassifyTest = FpClassifyTest<T>;                            \
+  TEST_F(LlvmLibcFpClassifyTest, SpecialNumbers) {                             \
+    auto fpclassify_func = [](T x) { return func(x); };                        \
+    testSpecialNumbers(fpclassify_func);                                       \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_FPCLASSIFY_H
diff --git a/test/include/IsFiniteTest.h b/test/include/IsFiniteTest.h
new file mode 100644
index 0000000..3d2fc0d
--- /dev/null
+++ b/test/include/IsFiniteTest.h
@@ -0,0 +1,39 @@
+//===-- Utility class to test the isfinite macro [f|l] ----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISFINITE_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISFINITE_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T>
+class IsFiniteTest : public LIBC_NAMESPACE::testing::Test {
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsFiniteFunc)(T);
+
+  void testSpecialNumbers(IsFiniteFunc func) {
+    EXPECT_EQ(func(inf), 0);
+    EXPECT_EQ(func(neg_inf), 0);
+    EXPECT_EQ(func(zero), 1);
+    EXPECT_EQ(func(neg_zero), 1);
+  }
+};
+
+#define LIST_ISFINITE_TESTS(T, func)                                           \
+  using LlvmLibcIsFiniteTest = IsFiniteTest<T>;                                \
+  TEST_F(LlvmLibcIsFiniteTest, SpecialNumbers) {                               \
+    auto isfinite_func = [](T x) { return func(x); };                          \
+    testSpecialNumbers(isfinite_func);                                         \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISFINITE_H
diff --git a/test/include/IsInfTest.h b/test/include/IsInfTest.h
new file mode 100644
index 0000000..7993a49
--- /dev/null
+++ b/test/include/IsInfTest.h
@@ -0,0 +1,39 @@
+//===-- Utility class to test the isinf macro [f|l] -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISINF_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISINF_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T> class IsInfTest : public LIBC_NAMESPACE::testing::Test {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsInfFunc)(T);
+
+  void testSpecialNumbers(IsInfFunc func) {
+    EXPECT_EQ(func(zero), 0);
+    EXPECT_EQ(func(neg_zero), 0);
+    EXPECT_EQ(func(inf), 1);
+    EXPECT_EQ(func(neg_inf), 1);
+  }
+};
+
+#define LIST_ISINF_TESTS(T, func)                                              \
+  using LlvmLibcIsInfTest = IsInfTest<T>;                                      \
+  TEST_F(LlvmLibcIsInfTest, SpecialNumbers) {                                  \
+    auto isinf_func = [](T x) { return func(x); };                             \
+    testSpecialNumbers(isinf_func);                                            \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISINF_H
diff --git a/test/include/IsNanTest.h b/test/include/IsNanTest.h
new file mode 100644
index 0000000..362699a
--- /dev/null
+++ b/test/include/IsNanTest.h
@@ -0,0 +1,39 @@
+//===-- Utility class to test the isnan macro [f|l] -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license nanormation.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISNAN_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISNAN_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T> class IsNanTest : public LIBC_NAMESPACE::testing::Test {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsNanFunc)(T);
+
+  void testSpecialNumbers(IsNanFunc func) {
+    EXPECT_EQ(func(zero), 0);
+    EXPECT_EQ(func(neg_zero), 0);
+    EXPECT_EQ(func(aNaN), 1);
+    EXPECT_EQ(func(sNaN), 1);
+  }
+};
+
+#define LIST_ISNAN_TESTS(T, func)                                              \
+  using LlvmLibcIsNanTest = IsNanTest<T>;                                      \
+  TEST_F(LlvmLibcIsNanTest, SpecialNumbers) {                                  \
+    auto isnan_func = [](T x) { return func(x); };                             \
+    testSpecialNumbers(isnan_func);                                            \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISNAN_H
diff --git a/test/include/IsNormalTest.h b/test/include/IsNormalTest.h
new file mode 100644
index 0000000..5e74efa
--- /dev/null
+++ b/test/include/IsNormalTest.h
@@ -0,0 +1,49 @@
+//===-- Utility class to test the isnormal macro  ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISNORMAL_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISNORMAL_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T>
+class IsNormalTest : public LIBC_NAMESPACE::testing::Test {
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsNormalFunc)(T);
+
+  void testSpecialNumbers(IsNormalFunc func) {
+    EXPECT_EQ(func(aNaN), 0);
+    EXPECT_EQ(func(neg_aNaN), 0);
+    EXPECT_EQ(func(sNaN), 0);
+    EXPECT_EQ(func(neg_sNaN), 0);
+    EXPECT_EQ(func(inf), 0);
+    EXPECT_EQ(func(neg_inf), 0);
+    EXPECT_EQ(func(min_normal), 1);
+    EXPECT_EQ(func(max_normal), 1);
+    EXPECT_EQ(func(neg_max_normal), 1);
+    EXPECT_EQ(func(min_denormal), 0);
+    EXPECT_EQ(func(neg_min_denormal), 0);
+    EXPECT_EQ(func(max_denormal), 0);
+    EXPECT_EQ(func(zero), 0);
+    EXPECT_EQ(func(neg_zero), 0);
+  }
+};
+
+#define LIST_ISNORMAL_TESTS(T, func)                                           \
+  using LlvmLibcIsNormalTest = IsNormalTest<T>;                                \
+  TEST_F(LlvmLibcIsNormalTest, SpecialNumbers) {                               \
+    auto isnormal_func = [](T x) { return func(x); };                          \
+    testSpecialNumbers(isnormal_func);                                         \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISNORMAL_H
diff --git a/test/include/IsSubnormalTest.h b/test/include/IsSubnormalTest.h
new file mode 100644
index 0000000..f26d6d2
--- /dev/null
+++ b/test/include/IsSubnormalTest.h
@@ -0,0 +1,49 @@
+//===-- Utility class to test the issubnormal macro  ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISSUBNORMAL_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISSUBNORMAL_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T>
+class IsSubnormalTest : public LIBC_NAMESPACE::testing::Test {
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef bool (*IsSubnormalFunc)(T);
+
+  void testSpecialNumbers(IsSubnormalFunc func) {
+    EXPECT_FALSE(func(aNaN));
+    EXPECT_FALSE(func(neg_aNaN));
+    EXPECT_FALSE(func(sNaN));
+    EXPECT_FALSE(func(neg_sNaN));
+    EXPECT_FALSE(func(inf));
+    EXPECT_FALSE(func(neg_inf));
+    EXPECT_FALSE(func(min_normal));
+    EXPECT_FALSE(func(max_normal));
+    EXPECT_FALSE(func(neg_max_normal));
+    EXPECT_TRUE(func(min_denormal));
+    EXPECT_TRUE(func(neg_min_denormal));
+    EXPECT_TRUE(func(max_denormal));
+    EXPECT_FALSE(func(zero));
+    EXPECT_FALSE(func(neg_zero));
+  }
+};
+
+#define LIST_ISSUBNORMAL_TESTS(T, func)                                        \
+  using LlvmLibcIsSubnormalTest = IsSubnormalTest<T>;                          \
+  TEST_F(LlvmLibcIsSubnormalTest, SpecialNumbers) {                            \
+    auto issubnormal_func = [](T x) { return func(x); };                       \
+    testSpecialNumbers(issubnormal_func);                                      \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISSUBNORMAL_H
diff --git a/test/include/IsZeroTest.h b/test/include/IsZeroTest.h
new file mode 100644
index 0000000..8387196
--- /dev/null
+++ b/test/include/IsZeroTest.h
@@ -0,0 +1,38 @@
+//===-- Utility class to test the iszero macro  -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_ISZERO_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_ISZERO_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T> class IsZeroTest : public LIBC_NAMESPACE::testing::Test {
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef bool (*IsZeroFunc)(T);
+
+  void testSpecialNumbers(IsZeroFunc func) {
+    EXPECT_FALSE(func(inf));
+    EXPECT_FALSE(func(neg_inf));
+    EXPECT_TRUE(func(zero));
+    EXPECT_TRUE(func(neg_zero));
+  }
+};
+
+#define LIST_ISZERO_TESTS(T, func)                                             \
+  using LlvmLibcIsZeroTest = IsZeroTest<T>;                                    \
+  TEST_F(LlvmLibcIsZeroTest, SpecialNumbers) {                                 \
+    auto iszero_func = [](T x) { return func(x); };                            \
+    testSpecialNumbers(iszero_func);                                           \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_ISZERO_H
diff --git a/test/include/SignbitTest.h b/test/include/SignbitTest.h
new file mode 100644
index 0000000..d0686d4
--- /dev/null
+++ b/test/include/SignbitTest.h
@@ -0,0 +1,37 @@
+//===-- Utility class to test the signbit macro [f|l] -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_INCLUDE_MATH_SIGNBIT_H
+#define LLVM_LIBC_TEST_INCLUDE_MATH_SIGNBIT_H
+
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+template <typename T> class SignbitTest : public LIBC_NAMESPACE::testing::Test {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*SignbitFunc)(T);
+
+  void testSpecialNumbers(SignbitFunc func) {
+    EXPECT_EQ(func(1), 0);
+    EXPECT_NE(func(-1), 0);
+  }
+};
+
+#define LIST_SIGNBIT_TESTS(T, func)                                            \
+  using LlvmLibcSignbitTest = SignbitTest<T>;                                  \
+  TEST_F(LlvmLibcSignbitTest, SpecialNumbers) {                                \
+    auto signbit_func = [](T x) { return func(x); };                           \
+    testSpecialNumbers(signbit_func);                                          \
+  }
+
+#endif // LLVM_LIBC_TEST_INCLUDE_MATH_SIGNBIT_H
diff --git a/test/include/complex_test.cpp b/test/include/complex_test.cpp
new file mode 100644
index 0000000..f6bfe99
--- /dev/null
+++ b/test/include/complex_test.cpp
@@ -0,0 +1,19 @@
+//===-- Unittests for complex ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "include/llvm-libc-macros/complex-macros.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcComplexTest, VersionMacro) {
+  EXPECT_EQ(__STDC_VERSION_COMPLEX_H__, 202311L);
+}
+
+TEST(LlvmLibcComplexTest, IMacro) { EXPECT_CFP_EQ(1.0fi, I); }
+
+TEST(LlvmLibcComplexTest, _Complex_IMacro) { EXPECT_CFP_EQ(1.0fi, _Complex_I); }
diff --git a/test/include/fpclassify_test.c b/test/include/fpclassify_test.c
new file mode 100644
index 0000000..9a9b62c
--- /dev/null
+++ b/test/include/fpclassify_test.c
@@ -0,0 +1,25 @@
+//===-- Unittests for fpclassify macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef fpclassify
+#error "fpclassify macro is not defined"
+#else
+int main(void) {
+  assert(fpclassify(1.819f) == FP_NORMAL);
+  assert(fpclassify(-1.726) == FP_NORMAL);
+  assert(fpclassify(1.426L) == FP_NORMAL);
+  assert(fpclassify(-0.0f) == FP_ZERO);
+  assert(fpclassify(0.0) == FP_ZERO);
+  assert(fpclassify(-0.0L) == FP_ZERO);
+  return 0;
+}
+#endif
diff --git a/test/include/fpclassify_test.cpp b/test/include/fpclassify_test.cpp
new file mode 100644
index 0000000..93c8e3c
--- /dev/null
+++ b/test/include/fpclassify_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for fpclassify[d] macro ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FpClassifyTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_FPCLASSIFY_TESTS(double, fpclassify)
diff --git a/test/include/fpclassifyf_test.cpp b/test/include/fpclassifyf_test.cpp
new file mode 100644
index 0000000..875482a
--- /dev/null
+++ b/test/include/fpclassifyf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for fpclassify[f] macro ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FpClassifyTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_FPCLASSIFY_TESTS(float, fpclassify)
diff --git a/test/include/fpclassifyl_test.cpp b/test/include/fpclassifyl_test.cpp
new file mode 100644
index 0000000..6627956
--- /dev/null
+++ b/test/include/fpclassifyl_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for fpclassify[l] macro ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FpClassifyTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_FPCLASSIFY_TESTS(long double, fpclassify)
diff --git a/test/include/iscanonical_test.c b/test/include/iscanonical_test.c
new file mode 100644
index 0000000..c0ad23b
--- /dev/null
+++ b/test/include/iscanonical_test.c
@@ -0,0 +1,29 @@
+//===-- Unittests for iscanonical macro -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+int iscanonical(double);
+int iscanonicalf(float);
+int iscanonicall(long double);
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef iscanonical
+#error "iscanonical macro is not defined"
+#else
+int main(void) {
+  assert(iscanonical(__builtin_nans("")) == 0);
+  assert(iscanonical(__builtin_nansf("")) == 0);
+  assert(iscanonical(__builtin_nansl("")) == 0);
+  assert(iscanonical(1.819f) == 1);
+  assert(iscanonical(-1.726) == 1);
+  assert(iscanonical(1.426L) == 1);
+  return 0;
+}
+#endif
diff --git a/test/include/isfinite_test.c b/test/include/isfinite_test.c
new file mode 100644
index 0000000..5fbf4b4
--- /dev/null
+++ b/test/include/isfinite_test.c
@@ -0,0 +1,22 @@
+//===-- Unittests for isfinite macro --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef isfinite
+#error "isfinite macro is not defined"
+#else
+int main(void) {
+  assert(isfinite(1.0f));
+  assert(isfinite(1.0));
+  assert(isfinite(1.0L));
+  return 0;
+}
+#endif
diff --git a/test/include/isfinite_test.cpp b/test/include/isfinite_test.cpp
new file mode 100644
index 0000000..79ac442
--- /dev/null
+++ b/test/include/isfinite_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isfinite[d] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsFiniteTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISFINITE_TESTS(double, isfinite)
diff --git a/test/include/isfinitef_test.cpp b/test/include/isfinitef_test.cpp
new file mode 100644
index 0000000..b1f66cd
--- /dev/null
+++ b/test/include/isfinitef_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isfinite[f] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsFiniteTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISFINITE_TESTS(float, isfinite)
diff --git a/test/include/isfinitel_test.cpp b/test/include/isfinitel_test.cpp
new file mode 100644
index 0000000..9087cd6
--- /dev/null
+++ b/test/include/isfinitel_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isfinite[l] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsFiniteTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISFINITE_TESTS(long double, isfinite)
diff --git a/test/include/isinf_test.c b/test/include/isinf_test.c
new file mode 100644
index 0000000..cc099cb
--- /dev/null
+++ b/test/include/isinf_test.c
@@ -0,0 +1,22 @@
+//===-- Unittests for isinf macro -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef isinf
+#error "isinf macro is not defined"
+#else
+int main(void) {
+  assert(!isinf(1.0f));
+  assert(!isinf(1.0));
+  assert(!isinf(1.0L));
+  return 0;
+}
+#endif
diff --git a/test/include/isinf_test.cpp b/test/include/isinf_test.cpp
new file mode 100644
index 0000000..ecf19d0
--- /dev/null
+++ b/test/include/isinf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isinf[d] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsInfTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISINF_TESTS(double, isinf)
diff --git a/test/include/isinff_test.cpp b/test/include/isinff_test.cpp
new file mode 100644
index 0000000..a2170c7
--- /dev/null
+++ b/test/include/isinff_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isinf[f] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsInfTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISINF_TESTS(float, isinf)
diff --git a/test/include/isinfl_test.cpp b/test/include/isinfl_test.cpp
new file mode 100644
index 0000000..e4fb91d
--- /dev/null
+++ b/test/include/isinfl_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isinf[l] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsInfTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISINF_TESTS(long double, isinf)
diff --git a/test/include/isnan_test.c b/test/include/isnan_test.c
new file mode 100644
index 0000000..ec0f803
--- /dev/null
+++ b/test/include/isnan_test.c
@@ -0,0 +1,22 @@
+//===-- Unittests for isnan macro -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef isnan
+#error "isnan macro is not defined"
+#else
+int main(void) {
+  assert(!isnan(1.0f));
+  assert(!isnan(1.0));
+  assert(!isnan(1.0L));
+  return 0;
+}
+#endif
diff --git a/test/include/isnan_test.cpp b/test/include/isnan_test.cpp
new file mode 100644
index 0000000..07dfab7
--- /dev/null
+++ b/test/include/isnan_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnan[l] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNanTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNAN_TESTS(double, isnan)
diff --git a/test/include/isnanf_test.cpp b/test/include/isnanf_test.cpp
new file mode 100644
index 0000000..e78a8e4
--- /dev/null
+++ b/test/include/isnanf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnan[f] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNanTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNAN_TESTS(float, isnan)
diff --git a/test/include/isnanl_test.cpp b/test/include/isnanl_test.cpp
new file mode 100644
index 0000000..84759a3
--- /dev/null
+++ b/test/include/isnanl_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnan[l] macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNanTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNAN_TESTS(long double, isnan)
diff --git a/test/include/isnormal_test.c b/test/include/isnormal_test.c
new file mode 100644
index 0000000..c076c5b
--- /dev/null
+++ b/test/include/isnormal_test.c
@@ -0,0 +1,25 @@
+//===-- Unittests for isnormal macro --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef isnormal
+#error "isnormal macro is not defined"
+#else
+int main(void) {
+  assert(isnormal(1.819f) == 1);
+  assert(isnormal(-1.726) == 1);
+  assert(isnormal(1.426L) == 1);
+  assert(isnormal(-0.0f) == 0);
+  assert(isnormal(0.0) == 0);
+  assert(isnormal(-0.0L) == 0);
+  return 0;
+}
+#endif
diff --git a/test/include/isnormal_test.cpp b/test/include/isnormal_test.cpp
new file mode 100644
index 0000000..da10850
--- /dev/null
+++ b/test/include/isnormal_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnormal[d] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNORMAL_TESTS(double, isnormal)
diff --git a/test/include/isnormalf_test.cpp b/test/include/isnormalf_test.cpp
new file mode 100644
index 0000000..59c0909
--- /dev/null
+++ b/test/include/isnormalf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnormal[f] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNORMAL_TESTS(float, isnormal)
diff --git a/test/include/isnormall_test.cpp b/test/include/isnormall_test.cpp
new file mode 100644
index 0000000..a21f841
--- /dev/null
+++ b/test/include/isnormall_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for isnormal[l] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsNormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISNORMAL_TESTS(long double, isnormal)
diff --git a/test/include/issignaling_test.c b/test/include/issignaling_test.c
new file mode 100644
index 0000000..c89970c
--- /dev/null
+++ b/test/include/issignaling_test.c
@@ -0,0 +1,29 @@
+//===-- Unittests for issignaling macro -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+int issignaling(double);
+int issignalingf(float);
+int issignalingl(long double);
+
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef issignaling
+#error "issignaling macro is not defined"
+#else
+int main(void) {
+  assert(issignaling(__builtin_nans("")) == 1);
+  assert(issignaling(__builtin_nansf("")) == 1);
+  assert(issignaling(__builtin_nansl("")) == 1);
+  assert(issignaling(1.819f) == 0);
+  assert(issignaling(-1.726) == 0);
+  assert(issignaling(1.426L) == 0);
+  return 0;
+}
+#endif
diff --git a/test/include/issubnormal_test.c b/test/include/issubnormal_test.c
new file mode 100644
index 0000000..8a45443
--- /dev/null
+++ b/test/include/issubnormal_test.c
@@ -0,0 +1,24 @@
+//===-- Unittests for issubnormal macro -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef issubnormal
+#error "issubnormal macro is not defined"
+#else
+int main(void) {
+  assert(issubnormal(1.819f) == 0);
+  assert(issubnormal(-1.726) == 0);
+  assert(issubnormal(1.426L) == 0);
+  assert(issubnormal(1e-308) == 1);
+  assert(issubnormal(-1e-308) == 1);
+  return 0;
+}
+#endif
diff --git a/test/include/issubnormal_test.cpp b/test/include/issubnormal_test.cpp
new file mode 100644
index 0000000..ff57a1f
--- /dev/null
+++ b/test/include/issubnormal_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for issubnormal[d] macro ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSubnormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISSUBNORMAL_TESTS(double, issubnormal)
diff --git a/test/include/issubnormalf_test.cpp b/test/include/issubnormalf_test.cpp
new file mode 100644
index 0000000..7ffa07e
--- /dev/null
+++ b/test/include/issubnormalf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for issubnormal[f] macro ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSubnormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISSUBNORMAL_TESTS(float, issubnormal)
diff --git a/test/include/issubnormall_test.cpp b/test/include/issubnormall_test.cpp
new file mode 100644
index 0000000..4546e2d
--- /dev/null
+++ b/test/include/issubnormall_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for issubnormal[l] macro ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSubnormalTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISSUBNORMAL_TESTS(long double, issubnormal)
diff --git a/test/include/iszero_test.c b/test/include/iszero_test.c
new file mode 100644
index 0000000..be2d34a
--- /dev/null
+++ b/test/include/iszero_test.c
@@ -0,0 +1,25 @@
+//===-- Unittests for iszero macro ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef iszero
+#error "iszero macro is not defined"
+#else
+int main(void) {
+  assert(iszero(1.0f) == 0);
+  assert(iszero(1.0) == 0);
+  assert(iszero(1.0L) == 0);
+  assert(iszero(0.0f) == 1);
+  assert(iszero(0.0) == 1);
+  assert(iszero(0.0L) == 1);
+  return 0;
+}
+#endif
diff --git a/test/include/iszero_test.cpp b/test/include/iszero_test.cpp
new file mode 100644
index 0000000..c478097
--- /dev/null
+++ b/test/include/iszero_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for iszero[d] macro --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsZeroTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISZERO_TESTS(double, iszero)
diff --git a/test/include/iszerof_test.cpp b/test/include/iszerof_test.cpp
new file mode 100644
index 0000000..8bf5319
--- /dev/null
+++ b/test/include/iszerof_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for iszero[f] macro --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsZeroTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISZERO_TESTS(float, iszero)
diff --git a/test/include/iszerol_test.cpp b/test/include/iszerol_test.cpp
new file mode 100644
index 0000000..1b1249f
--- /dev/null
+++ b/test/include/iszerol_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for iszero[l] macro --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsZeroTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_ISZERO_TESTS(long double, iszero)
diff --git a/test/include/signbit_test.c b/test/include/signbit_test.c
new file mode 100644
index 0000000..7e2460f
--- /dev/null
+++ b/test/include/signbit_test.c
@@ -0,0 +1,25 @@
+//===-- Unittests for signbit macro ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+#include <assert.h>
+
+// check if macro is defined
+#ifndef signbit
+#error "signbit macro is not defined"
+#else
+int main(void) {
+  assert(!signbit(1.0f));
+  assert(!signbit(1.0));
+  assert(!signbit(1.0L));
+  assert(signbit(-1.0f));
+  assert(signbit(-1.0));
+  assert(signbit(-1.0L));
+  return 0;
+}
+#endif
diff --git a/test/include/signbit_test.cpp b/test/include/signbit_test.cpp
new file mode 100644
index 0000000..d97ab0b
--- /dev/null
+++ b/test/include/signbit_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittest for signbit [d] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SignbitTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_SIGNBIT_TESTS(double, signbit)
diff --git a/test/include/signbitf_test.cpp b/test/include/signbitf_test.cpp
new file mode 100644
index 0000000..3a4bf93
--- /dev/null
+++ b/test/include/signbitf_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for signbit [f] macro -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SignbitTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_SIGNBIT_TESTS(float, signbit)
diff --git a/test/include/signbitl_test.cpp b/test/include/signbitl_test.cpp
new file mode 100644
index 0000000..5859840
--- /dev/null
+++ b/test/include/signbitl_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for signbit[l] macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SignbitTest.h"
+#include "include/llvm-libc-macros/math-function-macros.h"
+
+LIST_SIGNBIT_TESTS(long double, signbit)
diff --git a/test/include/sys/queue_test.cpp b/test/include/sys/queue_test.cpp
index c10e48d..a1fda90 100644
--- a/test/include/sys/queue_test.cpp
+++ b/test/include/sys/queue_test.cpp
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/string.h"
 #include "src/__support/char_vector.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
 #include "include/llvm-libc-macros/sys-queue-macros.h"
@@ -15,7 +16,7 @@
 using LIBC_NAMESPACE::CharVector;
 using LIBC_NAMESPACE::cpp::string;
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcQueueTest, SList) {
   struct Entry {
@@ -165,4 +166,4 @@ TEST(LlvmLibcQueueTest, STailQ) {
   ASSERT_TRUE(STAILQ_EMPTY(&head));
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/integration/src/pthread/pthread_name_test.cpp b/test/integration/src/pthread/pthread_name_test.cpp
index d341792..37cecee 100644
--- a/test/integration/src/pthread/pthread_name_test.cpp
+++ b/test/integration/src/pthread/pthread_name_test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
+#include "src/errno/libc_errno.h"
 #include "src/pthread/pthread_create.h"
 #include "src/pthread/pthread_getname_np.h"
 #include "src/pthread/pthread_join.h"
@@ -19,7 +20,6 @@
 
 #include "test/IntegrationTest/test.h"
 
-#include <errno.h>
 #include <pthread.h>
 #include <stdint.h> // uintptr_t
 
diff --git a/test/integration/src/pthread/pthread_rwlock_test.cpp b/test/integration/src/pthread/pthread_rwlock_test.cpp
index 9175efe..4cd4255 100644
--- a/test/integration/src/pthread/pthread_rwlock_test.cpp
+++ b/test/integration/src/pthread/pthread_rwlock_test.cpp
@@ -6,14 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/errno_macros.h"
+#include "hdr/time_macros.h"
 #include "src/__support/CPP/atomic.h"
 #include "src/__support/CPP/new.h"
 #include "src/__support/OSUtil/syscall.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/threads/linux/raw_mutex.h"
 #include "src/__support/threads/linux/rwlock.h"
 #include "src/__support/threads/sleep.h"
 #include "src/pthread/pthread_create.h"
 #include "src/pthread/pthread_join.h"
+#include "src/pthread/pthread_rwlock_clockrdlock.h"
+#include "src/pthread/pthread_rwlock_clockwrlock.h"
 #include "src/pthread/pthread_rwlock_destroy.h"
 #include "src/pthread/pthread_rwlock_init.h"
 #include "src/pthread/pthread_rwlock_rdlock.h"
@@ -37,18 +42,18 @@
 #include "src/time/clock_gettime.h"
 #include "src/unistd/fork.h"
 #include "test/IntegrationTest/test.h"
-#include <errno.h>
 #include <pthread.h>
-#include <time.h>
 
-namespace LIBC_NAMESPACE::rwlock {
+namespace LIBC_NAMESPACE_DECL {
+namespace rwlock {
 class RwLockTester {
 public:
   static constexpr int full_reader_state() {
     return (~0) & (~RwState::PENDING_MASK) & (~RwState::ACTIVE_WRITER_BIT);
   }
 };
-} // namespace LIBC_NAMESPACE::rwlock
+} // namespace rwlock
+} // namespace LIBC_NAMESPACE_DECL
 
 static void smoke_test() {
   pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
@@ -109,6 +114,12 @@ static void nullptr_test() {
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_wrlock(nullptr), EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedrdlock(nullptr, &ts), EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedwrlock(nullptr, &ts), EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(nullptr, CLOCK_MONOTONIC, &ts),
+      EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(nullptr, CLOCK_MONOTONIC, &ts),
+      EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_tryrdlock(nullptr), EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_trywrlock(nullptr), EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_unlock(nullptr), EINVAL);
@@ -156,16 +167,40 @@ static void unusual_timespec_test() {
   timespec ts = {0, -1};
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedrdlock(&rwlock, &ts), EINVAL);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedwrlock(&rwlock, &ts), EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
   ts.tv_nsec = 1'000'000'000;
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedrdlock(&rwlock, &ts), EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
   ts.tv_nsec += 1;
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedwrlock(&rwlock, &ts), EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      EINVAL);
   ts.tv_nsec = 0;
   ts.tv_sec = -1;
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedrdlock(&rwlock, &ts),
             ETIMEDOUT);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedwrlock(&rwlock, &ts),
             ETIMEDOUT);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      ETIMEDOUT);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&rwlock, CLOCK_MONOTONIC, &ts),
+      ETIMEDOUT);
 }
 
 static void timedlock_with_deadlock_test() {
@@ -181,6 +216,13 @@ static void timedlock_with_deadlock_test() {
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedwrlock(&rwlock, &ts),
             ETIMEDOUT);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_timedrdlock(&rwlock, &ts), 0);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&rwlock, CLOCK_REALTIME, &ts),
+      ETIMEDOUT);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&rwlock, CLOCK_REALTIME, &ts),
+      0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_unlock(&rwlock), 0);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_unlock(&rwlock), 0);
   ASSERT_EQ(LIBC_NAMESPACE::pthread_rwlock_unlock(&rwlock), 0);
   // notice that ts is already expired, but the following should still succeed.
@@ -267,9 +309,11 @@ enum class Operation : int {
   WRITE = 1,
   TIMED_READ = 2,
   TIMED_WRITE = 3,
-  TRY_READ = 4,
-  TRY_WRITE = 5,
-  COUNT = 6
+  CLOCK_READ = 4,
+  CLOCK_WRITE = 5,
+  TRY_READ = 6,
+  TRY_WRITE = 7,
+  COUNT = 8
 };
 
 LIBC_NAMESPACE::RawMutex *io_mutex;
@@ -355,6 +399,24 @@ static void randomized_thread_operation(SharedData *data, ThreadGuard &guard) {
     }
     break;
   }
+  case Operation::CLOCK_READ: {
+    timespec ts = get_ts();
+    if (LIBC_NAMESPACE::pthread_rwlock_clockrdlock(&data->lock, CLOCK_MONOTONIC,
+                                                   &ts) == 0) {
+      read_ops();
+      LIBC_NAMESPACE::pthread_rwlock_unlock(&data->lock);
+    }
+    break;
+  }
+  case Operation::CLOCK_WRITE: {
+    timespec ts = get_ts();
+    if (LIBC_NAMESPACE::pthread_rwlock_clockwrlock(&data->lock, CLOCK_MONOTONIC,
+                                                   &ts) == 0) {
+      write_ops();
+      LIBC_NAMESPACE::pthread_rwlock_unlock(&data->lock);
+    }
+    break;
+  }
   case Operation::TRY_READ: {
     if (LIBC_NAMESPACE::pthread_rwlock_tryrdlock(&data->lock) == 0) {
       read_ops();
diff --git a/test/integration/src/pthread/pthread_spinlock_test.cpp b/test/integration/src/pthread/pthread_spinlock_test.cpp
new file mode 100644
index 0000000..233daf8
--- /dev/null
+++ b/test/integration/src/pthread/pthread_spinlock_test.cpp
@@ -0,0 +1,145 @@
+//===-- Tests for pthread_spinlock ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/errno_macros.h"
+#include "src/pthread/pthread_create.h"
+#include "src/pthread/pthread_join.h"
+#include "src/pthread/pthread_spin_destroy.h"
+#include "src/pthread/pthread_spin_init.h"
+#include "src/pthread/pthread_spin_lock.h"
+#include "src/pthread/pthread_spin_trylock.h"
+#include "src/pthread/pthread_spin_unlock.h"
+#include "test/IntegrationTest/test.h"
+#include <pthread.h>
+
+namespace {
+void smoke_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+}
+
+void trylock_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_trylock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_trylock(&lock), EBUSY);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_trylock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+}
+
+void destroy_held_lock_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), EBUSY);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+}
+
+void use_after_destroy_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&lock), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_trylock(&lock), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), EINVAL);
+}
+
+void unlock_without_holding_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), EPERM);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+}
+
+void deadlock_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&lock), EDEADLK);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&lock), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+}
+
+void null_lock_test() {
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(nullptr, 0), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(nullptr), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_trylock(nullptr), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(nullptr), EINVAL);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(nullptr), EINVAL);
+}
+
+void pshared_attribute_test() {
+  pthread_spinlock_t lock;
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_SHARED),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE),
+            0);
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&lock), 0);
+
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&lock, -1), EINVAL);
+}
+
+void multi_thread_test() {
+  struct shared_data {
+    pthread_spinlock_t lock;
+    int count = 0;
+  } shared;
+  pthread_t thread[10];
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_init(&shared.lock, 0), 0);
+  for (int i = 0; i < 10; ++i) {
+    ASSERT_EQ(
+        LIBC_NAMESPACE::pthread_create(
+            &thread[i], nullptr,
+            [](void *arg) -> void * {
+              auto *data = static_cast<shared_data *>(arg);
+              for (int j = 0; j < 1000; ++j) {
+                ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_lock(&data->lock), 0);
+                data->count += j;
+                ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_unlock(&data->lock), 0);
+              }
+              return nullptr;
+            },
+            &shared),
+        0);
+  }
+  for (int i = 0; i < 10; ++i) {
+    ASSERT_EQ(LIBC_NAMESPACE::pthread_join(thread[i], nullptr), 0);
+  }
+  ASSERT_EQ(LIBC_NAMESPACE::pthread_spin_destroy(&shared.lock), 0);
+  ASSERT_EQ(shared.count, 1000 * 999 * 5);
+}
+
+} // namespace
+
+TEST_MAIN() {
+  smoke_test();
+  trylock_test();
+  destroy_held_lock_test();
+  use_after_destroy_test();
+  unlock_without_holding_test();
+  deadlock_test();
+  multi_thread_test();
+  null_lock_test();
+  pshared_attribute_test();
+  return 0;
+}
diff --git a/test/integration/src/spawn/posix_spawn_test_binary.cpp b/test/integration/src/spawn/posix_spawn_test_binary.cpp
index 7aec39c..c1b0cd6 100644
--- a/test/integration/src/spawn/posix_spawn_test_binary.cpp
+++ b/test/integration/src/spawn/posix_spawn_test_binary.cpp
@@ -1,5 +1,4 @@
 #include "test_binary_properties.h"
-#include <errno.h>
 #include <string.h>
 #include <unistd.h>
 
diff --git a/test/integration/src/stdio/gpu/printf.cpp b/test/integration/src/stdio/gpu/printf_test.cpp
similarity index 54%
rename from test/integration/src/stdio/gpu/printf.cpp
rename to test/integration/src/stdio/gpu/printf_test.cpp
index 97ad4ac..5f78737 100644
--- a/test/integration/src/stdio/gpu/printf.cpp
+++ b/test/integration/src/stdio/gpu/printf_test.cpp
@@ -9,8 +9,8 @@
 #include "test/IntegrationTest/test.h"
 
 #include "src/__support/GPU/utils.h"
-#include "src/gpu/rpc_fprintf.h"
 #include "src/stdio/fopen.h"
+#include "src/stdio/fprintf.h"
 
 using namespace LIBC_NAMESPACE;
 
@@ -20,68 +20,48 @@ TEST_MAIN(int argc, char **argv, char **envp) {
   ASSERT_TRUE(file && "failed to open file");
   // Check basic printing.
   int written = 0;
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "A simple string\n", nullptr, 0);
+  written = LIBC_NAMESPACE::fprintf(file, "A simple string\n");
   ASSERT_EQ(written, 16);
 
   const char *str = "A simple string\n";
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%s", &str, sizeof(void *));
+  written = LIBC_NAMESPACE::fprintf(file, "%s", str);
   ASSERT_EQ(written, 16);
 
   // Check printing a different value with each thread.
   uint64_t thread_id = gpu::get_thread_id();
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%8ld\n", &thread_id,
-                                        sizeof(thread_id));
+  written = LIBC_NAMESPACE::fprintf(file, "%8ld\n", thread_id);
   ASSERT_EQ(written, 9);
 
-  struct {
-    uint32_t x = 1;
-    char c = 'c';
-    double f = 1.0;
-  } args1;
-  written =
-      LIBC_NAMESPACE::rpc_fprintf(file, "%d%c%.1f\n", &args1, sizeof(args1));
+  written = LIBC_NAMESPACE::fprintf(file, "%d%c%.1f\n", 1, 'c', 1.0);
   ASSERT_EQ(written, 6);
 
-  struct {
-    uint32_t x = 1;
-    const char *str = "A simple string\n";
-  } args2;
-  written =
-      LIBC_NAMESPACE::rpc_fprintf(file, "%032b%s\n", &args2, sizeof(args2));
+  written = LIBC_NAMESPACE::fprintf(file, "%032b%s\n", 1, "A simple string\n");
   ASSERT_EQ(written, 49);
 
   // Check that the server correctly handles divergent numbers of arguments.
   const char *format = gpu::get_thread_id() % 2 ? "%s" : "%20ld\n";
-  written = LIBC_NAMESPACE::rpc_fprintf(file, format, &str, sizeof(void *));
+  written = LIBC_NAMESPACE::fprintf(file, format, str);
   ASSERT_EQ(written, gpu::get_thread_id() % 2 ? 16 : 21);
 
   format = gpu::get_thread_id() % 2 ? "%s" : str;
-  written = LIBC_NAMESPACE::rpc_fprintf(file, format, &str, sizeof(void *));
+  written = LIBC_NAMESPACE::fprintf(file, format, str);
   ASSERT_EQ(written, 16);
 
   // Check that we handle null arguments correctly.
-  struct {
-    void *null = nullptr;
-  } args3;
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%p", &args3, sizeof(args3));
+  written = LIBC_NAMESPACE::fprintf(file, "%p", nullptr);
   ASSERT_EQ(written, 9);
 
 #ifndef LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%s", &args3, sizeof(args3));
+  written = LIBC_NAMESPACE::fprintf(file, "%s", nullptr);
   ASSERT_EQ(written, 6);
 #endif // LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
 
   // Check for extremely abused variable width arguments
-  struct {
-    uint32_t x = 1;
-    uint32_t y = 2;
-    double f = 1.0;
-  } args4;
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%**d", &args4, sizeof(args4));
+  written = LIBC_NAMESPACE::fprintf(file, "%**d", 1, 2, 1.0);
   ASSERT_EQ(written, 4);
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%**d%6d", &args4, sizeof(args4));
+  written = LIBC_NAMESPACE::fprintf(file, "%**d%6d", 1, 2, 1.0);
   ASSERT_EQ(written, 10);
-  written = LIBC_NAMESPACE::rpc_fprintf(file, "%**.**f", &args4, sizeof(args4));
+  written = LIBC_NAMESPACE::fprintf(file, "%**.**f", 1, 2, 1.0);
   ASSERT_EQ(written, 7);
 
   return 0;
diff --git a/test/integration/src/unistd/fork_test.cpp b/test/integration/src/unistd/fork_test.cpp
index 9c9213e..010f57a 100644
--- a/test/integration/src/unistd/fork_test.cpp
+++ b/test/integration/src/unistd/fork_test.cpp
@@ -6,17 +6,20 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/OSUtil/syscall.h"
 #include "src/pthread/pthread_atfork.h"
 #include "src/signal/raise.h"
+#include "src/stdlib/exit.h"
 #include "src/sys/wait/wait.h"
 #include "src/sys/wait/wait4.h"
 #include "src/sys/wait/waitpid.h"
 #include "src/unistd/fork.h"
+#include "src/unistd/gettid.h"
 
 #include "test/IntegrationTest/test.h"
 
-#include <errno.h>
 #include <signal.h>
+#include <sys/syscall.h>
 #include <sys/wait.h>
 #include <unistd.h>
 
@@ -140,7 +143,24 @@ void fork_with_atfork_callbacks() {
   ASSERT_NE(child, DONE);
 }
 
+void gettid_test() {
+  // fork and verify tid is consistent with the syscall result.
+  int pid = LIBC_NAMESPACE::fork();
+  ASSERT_EQ(LIBC_NAMESPACE::gettid(),
+            LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_gettid));
+  if (pid == 0)
+    LIBC_NAMESPACE::exit(0);
+  // make sure child process exits normally
+  int status;
+  pid_t cpid = LIBC_NAMESPACE::waitpid(pid, &status, 0);
+  ASSERT_TRUE(cpid > 0);
+  ASSERT_EQ(cpid, pid);
+  ASSERT_TRUE(WIFEXITED(status));
+  ASSERT_EQ(WEXITSTATUS(status), 0);
+}
+
 TEST_MAIN(int argc, char **argv, char **envp) {
+  gettid_test();
   fork_and_wait_normal_exit();
   fork_and_wait4_normal_exit();
   fork_and_waitpid_normal_exit();
diff --git a/test/integration/src/unistd/stack_smashing_test.cpp b/test/integration/src/unistd/stack_smashing_test.cpp
index 89fc53d..3508b16 100644
--- a/test/integration/src/unistd/stack_smashing_test.cpp
+++ b/test/integration/src/unistd/stack_smashing_test.cpp
@@ -17,7 +17,6 @@
 
 #include "test/IntegrationTest/test.h"
 
-#include <errno.h>
 #include <signal.h>
 #include <sys/wait.h>
 #include <unistd.h>
diff --git a/test/integration/startup/gpu/rpc_interface_test.cpp b/test/integration/startup/gpu/rpc_interface_test.cpp
index 674e2cc..b05ffb9 100644
--- a/test/integration/startup/gpu/rpc_interface_test.cpp
+++ b/test/integration/startup/gpu/rpc_interface_test.cpp
@@ -17,20 +17,43 @@ using namespace LIBC_NAMESPACE;
 // as long as they are mirrored.
 static void test_interface(bool end_with_send) {
   uint64_t cnt = 0;
-  rpc::Client::Port port = rpc::client.open<RPC_TEST_INTERFACE>();
-  port.send([&](rpc::Buffer *buffer) { buffer->data[0] = end_with_send; });
-  port.send([&](rpc::Buffer *buffer) { buffer->data[0] = cnt = cnt + 1; });
-  port.recv([&](rpc::Buffer *buffer) { cnt = buffer->data[0]; });
-  port.send([&](rpc::Buffer *buffer) { buffer->data[0] = cnt = cnt + 1; });
-  port.recv([&](rpc::Buffer *buffer) { cnt = buffer->data[0]; });
-  port.send([&](rpc::Buffer *buffer) { buffer->data[0] = cnt = cnt + 1; });
-  port.send([&](rpc::Buffer *buffer) { buffer->data[0] = cnt = cnt + 1; });
-  port.recv([&](rpc::Buffer *buffer) { cnt = buffer->data[0]; });
-  port.recv([&](rpc::Buffer *buffer) { cnt = buffer->data[0]; });
+  LIBC_NAMESPACE::rpc::Client::Port port =
+      LIBC_NAMESPACE::rpc::client.open<RPC_TEST_INTERFACE>();
+  port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = end_with_send;
+  });
+  port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = cnt = cnt + 1;
+  });
+  port.recv([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    cnt = buffer->data[0];
+  });
+  port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = cnt = cnt + 1;
+  });
+  port.recv([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    cnt = buffer->data[0];
+  });
+  port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = cnt = cnt + 1;
+  });
+  port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = cnt = cnt + 1;
+  });
+  port.recv([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    cnt = buffer->data[0];
+  });
+  port.recv([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    cnt = buffer->data[0];
+  });
   if (end_with_send)
-    port.send([&](rpc::Buffer *buffer) { buffer->data[0] = cnt = cnt + 1; });
+    port.send([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = cnt = cnt + 1;
+    });
   else
-    port.recv([&](rpc::Buffer *buffer) { cnt = buffer->data[0]; });
+    port.recv([&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+      cnt = buffer->data[0];
+    });
   port.close();
 
   ASSERT_TRUE(cnt == 9 && "Invalid number of increments");
diff --git a/test/integration/startup/gpu/rpc_lane_test.cpp b/test/integration/startup/gpu/rpc_lane_test.cpp
new file mode 100644
index 0000000..72c7109
--- /dev/null
+++ b/test/integration/startup/gpu/rpc_lane_test.cpp
@@ -0,0 +1,36 @@
+//===-- Loader test to check the RPC interface with the loader ------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "include/llvm-libc-types/test_rpc_opcodes_t.h"
+#include "src/__support/GPU/utils.h"
+#include "src/__support/RPC/rpc_client.h"
+#include "test/IntegrationTest/test.h"
+
+using namespace LIBC_NAMESPACE;
+
+static void test_add() {
+  uint64_t cnt = gpu::get_lane_id();
+  LIBC_NAMESPACE::rpc::Client::Port port =
+      LIBC_NAMESPACE::rpc::client.open<RPC_TEST_INCREMENT>();
+  port.send_and_recv(
+      [=](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+        reinterpret_cast<uint64_t *>(buffer->data)[0] = cnt;
+      },
+      [&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+        cnt = reinterpret_cast<uint64_t *>(buffer->data)[0];
+      });
+  port.close();
+  EXPECT_EQ(cnt, gpu::get_lane_id() + 1);
+  EXPECT_EQ(gpu::get_thread_id(), gpu::get_lane_id());
+}
+
+TEST_MAIN(int argc, char **argv, char **envp) {
+  test_add();
+
+  return 0;
+}
diff --git a/test/integration/startup/gpu/rpc_stream_test.cpp b/test/integration/startup/gpu/rpc_stream_test.cpp
index 09a4ae6..208130b 100644
--- a/test/integration/startup/gpu/rpc_stream_test.cpp
+++ b/test/integration/startup/gpu/rpc_stream_test.cpp
@@ -34,7 +34,8 @@ static void test_stream() {
 
   inline_memcpy(send_ptr, str, send_size);
   ASSERT_TRUE(inline_memcmp(send_ptr, str, send_size) == 0 && "Data mismatch");
-  rpc::Client::Port port = rpc::client.open<RPC_TEST_STREAM>();
+  LIBC_NAMESPACE::rpc::Client::Port port =
+      LIBC_NAMESPACE::rpc::client.open<RPC_TEST_STREAM>();
   port.send_n(send_ptr, send_size);
   port.recv_n(&recv_ptr, &recv_size,
               [](uint64_t size) { return malloc(size); });
@@ -77,7 +78,8 @@ static void test_divergent() {
   inline_memcpy(buffer, &data[offset], offset);
   ASSERT_TRUE(inline_memcmp(buffer, &data[offset], offset) == 0 &&
               "Data mismatch");
-  rpc::Client::Port port = rpc::client.open<RPC_TEST_STREAM>();
+  LIBC_NAMESPACE::rpc::Client::Port port =
+      LIBC_NAMESPACE::rpc::client.open<RPC_TEST_STREAM>();
   port.send_n(buffer, offset);
   inline_memset(buffer, offset, 0);
   port.recv_n(&recv_ptr, &recv_size, [&](uint64_t) { return buffer; });
diff --git a/test/integration/startup/gpu/rpc_test.cpp b/test/integration/startup/gpu/rpc_test.cpp
index 4032d89..3deb72b 100644
--- a/test/integration/startup/gpu/rpc_test.cpp
+++ b/test/integration/startup/gpu/rpc_test.cpp
@@ -18,12 +18,13 @@ static void test_add_simple() {
       10 + 10 * gpu::get_thread_id() + 10 * gpu::get_block_id();
   uint64_t cnt = 0;
   for (uint32_t i = 0; i < num_additions; ++i) {
-    rpc::Client::Port port = rpc::client.open<RPC_TEST_INCREMENT>();
+    LIBC_NAMESPACE::rpc::Client::Port port =
+        LIBC_NAMESPACE::rpc::client.open<RPC_TEST_INCREMENT>();
     port.send_and_recv(
-        [=](rpc::Buffer *buffer) {
+        [=](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
           reinterpret_cast<uint64_t *>(buffer->data)[0] = cnt;
         },
-        [&](rpc::Buffer *buffer) {
+        [&](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
           cnt = reinterpret_cast<uint64_t *>(buffer->data)[0];
         });
     port.close();
@@ -33,8 +34,11 @@ static void test_add_simple() {
 
 // Test to ensure that the RPC mechanism doesn't hang on divergence.
 static void test_noop(uint8_t data) {
-  rpc::Client::Port port = rpc::client.open<RPC_NOOP>();
-  port.send([=](rpc::Buffer *buffer) { buffer->data[0] = data; });
+  LIBC_NAMESPACE::rpc::Client::Port port =
+      LIBC_NAMESPACE::rpc::client.open<RPC_NOOP>();
+  port.send([=](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
+    buffer->data[0] = data;
+  });
   port.close();
 }
 
diff --git a/test/integration/startup/linux/tls_test.cpp b/test/integration/startup/linux/tls_test.cpp
index 2a6385e..ef9fd9f 100644
--- a/test/integration/startup/linux/tls_test.cpp
+++ b/test/integration/startup/linux/tls_test.cpp
@@ -10,7 +10,6 @@
 #include "src/sys/mman/mmap.h"
 #include "test/IntegrationTest/test.h"
 
-#include <errno.h>
 #include <sys/mman.h>
 
 constexpr int threadLocalDataSize = 101;
diff --git a/test/src/__support/CPP/algorithm_test.cpp b/test/src/__support/CPP/algorithm_test.cpp
index e52e562..00d07bf 100644
--- a/test/src/__support/CPP/algorithm_test.cpp
+++ b/test/src/__support/CPP/algorithm_test.cpp
@@ -8,11 +8,13 @@
 
 #include "src/__support/CPP/algorithm.h"
 #include "src/__support/CPP/array.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
 // TODO(https://github.com/llvm/llvm-project/issues/94066): Add unittests for
 // the remaining algorithm functions.
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 TEST(LlvmLibcAlgorithmTest, FindIfNot) {
   array<int, 4> nums{1, 2, 3, 4};
@@ -44,4 +46,5 @@ TEST(LlvmLibcAlgorithmTest, AllOf) {
   EXPECT_TRUE(all_of(nums.begin(), nums.begin(), [](int i) { return i < 0; }));
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/CPP/bit_test.cpp b/test/src/__support/CPP/bit_test.cpp
index 299623d..9429b66 100644
--- a/test/src/__support/CPP/bit_test.cpp
+++ b/test/src/__support/CPP/bit_test.cpp
@@ -8,12 +8,14 @@
 
 #include "src/__support/CPP/bit.h"
 #include "src/__support/big_int.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 #include "test/UnitTest/Test.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 using UnsignedTypes = testing::TypeList<
 #if defined(LIBC_TYPES_HAS_INT128)
@@ -228,4 +230,5 @@ TYPED_TEST(LlvmLibcBitTest, CountOnes, UnsignedTypes) {
               cpp::numeric_limits<T>::digits - i);
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/CPP/cstddef_test.cpp b/test/src/__support/CPP/cstddef_test.cpp
index 8337081..eceabaa 100644
--- a/test/src/__support/CPP/cstddef_test.cpp
+++ b/test/src/__support/CPP/cstddef_test.cpp
@@ -7,9 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/cstddef.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 TEST(LlvmLibcByteTest, to_integer) {
   const char str[] = "abc";
@@ -41,4 +43,5 @@ TEST(LlvmLibcByteTest, bitwise) {
   ASSERT_EQ(b, byte{0b00001111});
 }
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/CPP/limits_test.cpp b/test/src/__support/CPP/limits_test.cpp
index bcf7d5e..6c94b09 100644
--- a/test/src/__support/CPP/limits_test.cpp
+++ b/test/src/__support/CPP/limits_test.cpp
@@ -8,10 +8,11 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/big_int.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // This just checks against the C spec, almost all implementations will surpass
 // this.
@@ -42,4 +43,4 @@ TEST(LlvmLibcLimitsTest, UInt128Limits) {
 #endif // LIBC_TYPES_HAS_INT128
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/CPP/type_traits_test.cpp b/test/src/__support/CPP/type_traits_test.cpp
index 1c428e9..fa5298a 100644
--- a/test/src/__support/CPP/type_traits_test.cpp
+++ b/test/src/__support/CPP/type_traits_test.cpp
@@ -7,11 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
 // TODO: Split this file if it becomes too big.
 
-namespace LIBC_NAMESPACE::cpp {
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
 
 class Class {};
 union Union {};
@@ -117,7 +119,7 @@ TEST(LlvmLibcTypeTraitsTest, aligned_storage) {
     int a, b;
   };
   aligned_storage_t<sizeof(S), alignof(S)> buf;
-  EXPECT_EQ(alignof(buf), alignof(S));
+  EXPECT_EQ(alignof(decltype(buf)), alignof(S));
   EXPECT_EQ(sizeof(buf), sizeof(S));
 }
 
@@ -441,4 +443,5 @@ TEST(LlvmLibcTypeTraitsTest, true_type) { EXPECT_TRUE((true_type::value)); }
 
 // TODO void_t
 
-} // namespace LIBC_NAMESPACE::cpp
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/FPUtil/dyadic_float_test.cpp b/test/src/__support/FPUtil/dyadic_float_test.cpp
index 3b1f9de..709e1df 100644
--- a/test/src/__support/FPUtil/dyadic_float_test.cpp
+++ b/test/src/__support/FPUtil/dyadic_float_test.cpp
@@ -16,6 +16,7 @@
 using Float128 = LIBC_NAMESPACE::fputil::DyadicFloat<128>;
 using Float192 = LIBC_NAMESPACE::fputil::DyadicFloat<192>;
 using Float256 = LIBC_NAMESPACE::fputil::DyadicFloat<256>;
+using LIBC_NAMESPACE::Sign;
 
 TEST(LlvmLibcDyadicFloatTest, BasicConversions) {
   Float128 x(Sign::POS, /*exponent*/ 0,
diff --git a/test/src/__support/FPUtil/fpbits_test.cpp b/test/src/__support/FPUtil/fpbits_test.cpp
index af20b1a..6953d3a 100644
--- a/test/src/__support/FPUtil/fpbits_test.cpp
+++ b/test/src/__support/FPUtil/fpbits_test.cpp
@@ -8,10 +8,14 @@
 
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/fpbits_str.h"
+#include "src/__support/big_int.h"
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/properties/types.h"
 #include "src/__support/sign.h" // Sign
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+using LIBC_NAMESPACE::UInt;
 using LIBC_NAMESPACE::fputil::FPBits;
 using LIBC_NAMESPACE::fputil::FPType;
 using LIBC_NAMESPACE::fputil::internal::FPRep;
@@ -19,6 +23,7 @@ using LIBC_NAMESPACE::fputil::internal::FPRep;
 using LIBC_NAMESPACE::operator""_u16;
 using LIBC_NAMESPACE::operator""_u32;
 using LIBC_NAMESPACE::operator""_u64;
+using LIBC_NAMESPACE::operator""_u96;
 using LIBC_NAMESPACE::operator""_u128;
 
 TEST(LlvmLibcFPBitsTest, FPType_IEEE754_Binary16) {
@@ -119,9 +124,11 @@ TEST(LlvmLibcFPBitsTest, FPType_IEEE754_Binary128) {
       UInt128(Rep::quiet_nan()));
 }
 
+#ifdef LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 TEST(LlvmLibcFPBitsTest, FPType_X86_Binary80) {
   using Rep = FPRep<FPType::X86_Binary80>;
 
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(
       0b0'0000000000000000000000000000000000000000000000000000000000000000000000000000000_u128,
       UInt128(Rep::zero()));
@@ -149,11 +156,43 @@ TEST(LlvmLibcFPBitsTest, FPType_X86_Binary80) {
   EXPECT_EQ(
       0b0'1111111111111111100000000000000000000000000000000000000000000000000000000000000_u128,
       UInt128(Rep::quiet_nan()));
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(
+      0b0'0000000000000000000000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::zero()));
+  EXPECT_EQ(
+      0b0'0111111111111111000000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::one()));
+  EXPECT_EQ(
+      0b0'0000000000000000000000000000000000000000000000000000000000000000000000000000001_u96,
+      UInt<96>(Rep::min_subnormal()));
+  EXPECT_EQ(
+      0b0'0000000000000000111111111111111111111111111111111111111111111111111111111111111_u96,
+      UInt<96>(Rep::max_subnormal()));
+  EXPECT_EQ(
+      0b0'0000000000000011000000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::min_normal()));
+  EXPECT_EQ(
+      0b0'1111111111111101111111111111111111111111111111111111111111111111111111111111111_u96,
+      UInt<96>(Rep::max_normal()));
+  EXPECT_EQ(
+      0b0'1111111111111111000000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::inf()));
+  EXPECT_EQ(
+      0b0'1111111111111111010000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::signaling_nan()));
+  EXPECT_EQ(
+      0b0'1111111111111111100000000000000000000000000000000000000000000000000000000000000_u96,
+      UInt<96>(Rep::quiet_nan()));
+#else
+#error "unhandled long double type"
+#endif
 }
 
 TEST(LlvmLibcFPBitsTest, FPType_X86_Binary80_IsNan) {
   using Rep = FPRep<FPType::X86_Binary80>;
 
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_TRUE( // NAN : Pseudo-Infinity
       Rep(0b0'111111111111111'0000000000000000000000000000000000000000000000000000000000000000_u128)
           .is_nan());
@@ -190,7 +229,48 @@ TEST(LlvmLibcFPBitsTest, FPType_X86_Binary80_IsNan) {
   EXPECT_FALSE( // Normalized
       Rep(0b0'111111111111110'1000000000000000000000000000000000000000000000000000000000000000_u128)
           .is_nan());
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_TRUE( // NAN : Pseudo-Infinity
+      Rep(0b0'111111111111111'0000000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Pseudo Not a Number
+      Rep(0b0'111111111111111'0000000000000000000000000000000000000000000000000000000000000001_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Pseudo Not a Number
+      Rep(0b0'111111111111111'0100000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Signalling Not a Number
+      Rep(0b0'111111111111111'1000000000000000000000000000000000000000000000000000000000000001_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Floating-point Indefinite
+      Rep(0b0'111111111111111'1100000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Quiet Not a Number
+      Rep(0b0'111111111111111'1100000000000000000000000000000000000000000000000000000000000001_u96)
+          .is_nan());
+  EXPECT_TRUE( // NAN : Unnormal
+      Rep(0b0'111111111111110'0000000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_FALSE( // Zero
+      Rep(0b0'000000000000000'0000000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_FALSE( // Subnormal
+      Rep(0b0'000000000000000'0000000000000000000000000000000000000000000000000000000000000001_u96)
+          .is_nan());
+  EXPECT_FALSE( // Pseudo Denormal
+      Rep(0b0'000000000000000'1000000000000000000000000000000000000000000000000000000000000001_u96)
+          .is_nan());
+  EXPECT_FALSE( // Infinity
+      Rep(0b0'111111111111111'1000000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+  EXPECT_FALSE( // Normalized
+      Rep(0b0'111111111111110'1000000000000000000000000000000000000000000000000000000000000000_u96)
+          .is_nan());
+#else
+#error "unhandled long double type"
+#endif
 }
+#endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 
 enum class FP {
   ZERO,
@@ -238,6 +318,7 @@ template <typename T> constexpr auto make(Sign sign, FP fp) {
   case FP::QUIET_NAN:
     return T::quiet_nan(sign);
   }
+  __builtin_unreachable();
 }
 
 // Tests all properties for all types of float.
@@ -424,12 +505,10 @@ TEST(LlvmLibcFPBitsTest, DoubleType) {
   EXPECT_EQ(quiet_nan.is_quiet_nan(), true);
 }
 
-#ifdef LIBC_TARGET_ARCH_IS_X86
+#ifdef LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 TEST(LlvmLibcFPBitsTest, X86LongDoubleType) {
   using LongDoubleBits = FPBits<long double>;
-
-  if constexpr (sizeof(long double) == sizeof(double))
-    return; // The tests for the "double" type cover for this case.
+  using Rep = FPRep<FPType::X86_Binary80>;
 
   EXPECT_STREQ(LIBC_NAMESPACE::str(LongDoubleBits::inf(Sign::POS)).c_str(),
                "(+Infinity)");
@@ -441,62 +520,117 @@ TEST(LlvmLibcFPBitsTest, X86LongDoubleType) {
   LongDoubleBits zero(0.0l);
   EXPECT_TRUE(zero.is_pos());
   EXPECT_EQ(zero.get_biased_exponent(), 0_u16);
-  EXPECT_EQ(zero.get_mantissa(), 0_u128);
-  EXPECT_EQ(zero.uintval(), 0_u128);
+  EXPECT_EQ(zero.get_mantissa(), LongDoubleBits::StorageType(Rep::zero()));
+  EXPECT_EQ(zero.uintval(), LongDoubleBits::StorageType(Rep::zero()));
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(zero).c_str(),
       "0x00000000000000000000000000000000 = "
       "(S: 0, E: 0x0000, I: 0, M: 0x00000000000000000000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_STREQ(LIBC_NAMESPACE::str(zero).c_str(),
+               "0x000000000000000000000000 = "
+               "(S: 0, E: 0x0000, I: 0, M: 0x000000000000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits negzero(-0.0l);
   EXPECT_TRUE(negzero.is_neg());
   EXPECT_EQ(negzero.get_biased_exponent(), 0_u16);
-  EXPECT_EQ(negzero.get_mantissa(), 0_u128);
+  EXPECT_EQ(negzero.get_mantissa(), LongDoubleBits::StorageType(Rep::zero()));
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(negzero.uintval(), 0x8000'00000000'00000000_u128);
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(negzero).c_str(),
       "0x00000000000080000000000000000000 = "
       "(S: 1, E: 0x0000, I: 0, M: 0x00000000000000000000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(negzero.uintval(), 0x8000'00000000'00000000_u96);
+  EXPECT_STREQ(LIBC_NAMESPACE::str(negzero).c_str(),
+               "0x000080000000000000000000 = "
+               "(S: 1, E: 0x0000, I: 0, M: 0x000000000000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits one(1.0l);
   EXPECT_TRUE(one.is_pos());
   EXPECT_EQ(one.get_biased_exponent(), 0x3FFF_u16);
-  EXPECT_EQ(one.get_mantissa(), 0_u128);
+  EXPECT_EQ(one.get_mantissa(), LongDoubleBits::StorageType(Rep::zero()));
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(one.uintval(), 0x3FFF'80000000'00000000_u128);
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(one).c_str(),
       "0x0000000000003FFF8000000000000000 = "
       "(S: 0, E: 0x3FFF, I: 1, M: 0x00000000000000000000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(one.uintval(), 0x3FFF'80000000'00000000_u96);
+  EXPECT_STREQ(LIBC_NAMESPACE::str(one).c_str(),
+               "0x00003FFF8000000000000000 = "
+               "(S: 0, E: 0x3FFF, I: 1, M: 0x000000000000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits negone(-1.0l);
   EXPECT_TRUE(negone.is_neg());
   EXPECT_EQ(negone.get_biased_exponent(), 0x3FFF_u16);
-  EXPECT_EQ(negone.get_mantissa(), 0_u128);
+  EXPECT_EQ(negone.get_mantissa(), LongDoubleBits::StorageType(Rep::zero()));
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(negone.uintval(), 0xBFFF'80000000'00000000_u128);
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(negone).c_str(),
       "0x000000000000BFFF8000000000000000 = "
       "(S: 1, E: 0x3FFF, I: 1, M: 0x00000000000000000000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(negone.uintval(), 0xBFFF'80000000'00000000_u96);
+  EXPECT_STREQ(LIBC_NAMESPACE::str(negone).c_str(),
+               "0x0000BFFF8000000000000000 = "
+               "(S: 1, E: 0x3FFF, I: 1, M: 0x000000000000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits num(1.125l);
   EXPECT_TRUE(num.is_pos());
   EXPECT_EQ(num.get_biased_exponent(), 0x3FFF_u16);
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(num.get_mantissa(), 0x10000000'00000000_u128);
   EXPECT_EQ(num.uintval(), 0x3FFF'90000000'00000000_u128);
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(num).c_str(),
       "0x0000000000003FFF9000000000000000 = "
       "(S: 0, E: 0x3FFF, I: 1, M: 0x00000000000000001000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(num.get_mantissa(), 0x10000000'00000000_u96);
+  EXPECT_EQ(num.uintval(), 0x3FFF'90000000'00000000_u96);
+  EXPECT_STREQ(LIBC_NAMESPACE::str(num).c_str(),
+               "0x00003FFF9000000000000000 = "
+               "(S: 0, E: 0x3FFF, I: 1, M: 0x000000001000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits negnum(-1.125l);
   EXPECT_TRUE(negnum.is_neg());
   EXPECT_EQ(negnum.get_biased_exponent(), 0x3FFF_u16);
+#if __SIZEOF_LONG_DOUBLE__ == 16
   EXPECT_EQ(negnum.get_mantissa(), 0x10000000'00000000_u128);
   EXPECT_EQ(negnum.uintval(), 0xBFFF'90000000'00000000_u128);
   EXPECT_STREQ(
       LIBC_NAMESPACE::str(negnum).c_str(),
       "0x000000000000BFFF9000000000000000 = "
       "(S: 1, E: 0x3FFF, I: 1, M: 0x00000000000000001000000000000000)");
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  EXPECT_EQ(negnum.get_mantissa(), 0x10000000'00000000_u96);
+  EXPECT_EQ(negnum.uintval(), 0xBFFF'90000000'00000000_u96);
+  EXPECT_STREQ(LIBC_NAMESPACE::str(negnum).c_str(),
+               "0x0000BFFF9000000000000000 = "
+               "(S: 1, E: 0x3FFF, I: 1, M: 0x000000001000000000000000)");
+#else
+#error "unhandled long double type"
+#endif
 
   LongDoubleBits quiet_nan = LongDoubleBits::quiet_nan();
   EXPECT_EQ(quiet_nan.is_quiet_nan(), true);
diff --git a/test/src/__support/File/file_test.cpp b/test/src/__support/File/file_test.cpp
index fbcedc1..b3c9f2b 100644
--- a/test/src/__support/File/file_test.cpp
+++ b/test/src/__support/File/file_test.cpp
@@ -12,8 +12,7 @@
 #include "test/UnitTest/MemoryMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
 
 using ModeFlags = LIBC_NAMESPACE::File::ModeFlags;
 using MemoryView = LIBC_NAMESPACE::testing::MemoryView;
@@ -31,8 +30,8 @@ class StringFile : public File {
   static FileIOResult str_read(LIBC_NAMESPACE::File *f, void *data, size_t len);
   static FileIOResult str_write(LIBC_NAMESPACE::File *f, const void *data,
                                 size_t len);
-  static ErrorOr<long> str_seek(LIBC_NAMESPACE::File *f, long offset,
-                                int whence);
+  static ErrorOr<off_t> str_seek(LIBC_NAMESPACE::File *f, off_t offset,
+                                 int whence);
   static int str_close(LIBC_NAMESPACE::File *f) {
     delete reinterpret_cast<StringFile *>(f);
     return 0;
@@ -93,8 +92,8 @@ FileIOResult StringFile::str_write(LIBC_NAMESPACE::File *f, const void *data,
   return i;
 }
 
-ErrorOr<long> StringFile::str_seek(LIBC_NAMESPACE::File *f, long offset,
-                                   int whence) {
+ErrorOr<off_t> StringFile::str_seek(LIBC_NAMESPACE::File *f, off_t offset,
+                                    int whence) {
   StringFile *sf = static_cast<StringFile *>(f);
   if (whence == SEEK_SET)
     sf->pos = offset;
diff --git a/test/src/__support/File/platform_file_test.cpp b/test/src/__support/File/platform_file_test.cpp
index 469d750..6b2be2a 100644
--- a/test/src/__support/File/platform_file_test.cpp
+++ b/test/src/__support/File/platform_file_test.cpp
@@ -9,7 +9,7 @@
 #include "src/__support/File/file.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h> // For SEEK_* macros
+#include "hdr/stdio_macros.h" // For SEEK_* macros
 
 using File = LIBC_NAMESPACE::File;
 constexpr char TEXT[] = "Hello, File";
@@ -103,7 +103,8 @@ TEST(LlvmLibcPlatformFileTest, CreateAppendSeekAndReadBack) {
   constexpr size_t APPEND_TEXT_SIZE = sizeof(APPEND_TEXT) - 1;
   ASSERT_EQ(file->write(APPEND_TEXT, APPEND_TEXT_SIZE).value, APPEND_TEXT_SIZE);
 
-  ASSERT_EQ(file->seek(-APPEND_TEXT_SIZE, SEEK_END).value(), 0);
+  ASSERT_EQ(file->seek(-static_cast<off_t>(APPEND_TEXT_SIZE), SEEK_END).value(),
+            0);
   char data[APPEND_TEXT_SIZE + 1];
   ASSERT_EQ(file->read(data, APPEND_TEXT_SIZE).value, APPEND_TEXT_SIZE);
   data[APPEND_TEXT_SIZE] = '\0';
diff --git a/test/src/__support/HashTable/bitmask_test.cpp b/test/src/__support/HashTable/bitmask_test.cpp
index 5203220..ce56b20 100644
--- a/test/src/__support/HashTable/bitmask_test.cpp
+++ b/test/src/__support/HashTable/bitmask_test.cpp
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/HashTable/bitmask.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 using ShortBitMask = BitMaskAdaptor<uint16_t, 1>;
@@ -66,4 +67,4 @@ TEST(LlvmLibcHashTableBitMaskTest, MultiBitStrideIteration) {
   }
 }
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/HashTable/group_test.cpp b/test/src/__support/HashTable/group_test.cpp
index 9079083..acdc58e 100644
--- a/test/src/__support/HashTable/group_test.cpp
+++ b/test/src/__support/HashTable/group_test.cpp
@@ -8,11 +8,13 @@
 
 #include "src/__support/HashTable/bitmask.h"
 
+#include "src/__support/CPP/bit.h"
+#include "src/__support/macros/config.h"
 #include "src/stdlib/rand.h"
 #include "test/UnitTest/Test.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
 struct ByteArray {
@@ -27,14 +29,13 @@ TEST(LlvmLibcHashTableBitMaskTest, Match) {
   size_t appearance[4][sizeof(Group)];
   ByteArray array{};
 
-  union {
-    uintptr_t random;
-    int data[sizeof(uintptr_t) / sizeof(int)];
-  };
+  int data[sizeof(uintptr_t) / sizeof(int)];
 
   for (int &i : data)
     i = rand();
 
+  uintptr_t random = cpp::bit_cast<uintptr_t>(data);
+
   for (size_t i = 0; i < sizeof(Group); ++i) {
     size_t choice = random % 4;
     random /= 4;
@@ -61,14 +62,13 @@ TEST(LlvmLibcHashTableBitMaskTest, MaskAvailable) {
   for (size_t i = 0; i < sizeof(Group); ++i) {
     ByteArray array{};
 
-    union {
-      uintptr_t random;
-      int data[sizeof(uintptr_t) / sizeof(int)];
-    };
+    int data[sizeof(uintptr_t) / sizeof(int)];
 
     for (int &j : data)
       j = rand();
 
+    uintptr_t random = cpp::bit_cast<uintptr_t>(data);
+
     ASSERT_FALSE(Group::load(array.data).mask_available().any_bit_set());
 
     array.data[i] = 0x80;
@@ -87,4 +87,4 @@ TEST(LlvmLibcHashTableBitMaskTest, MaskAvailable) {
   }
 }
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/HashTable/table_test.cpp b/test/src/__support/HashTable/table_test.cpp
index dcae6f4..c3b8697 100644
--- a/test/src/__support/HashTable/table_test.cpp
+++ b/test/src/__support/HashTable/table_test.cpp
@@ -9,9 +9,10 @@
 #include "src/__support/CPP/bit.h" // bit_ceil
 #include "src/__support/HashTable/randomness.h"
 #include "src/__support/HashTable/table.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 TEST(LlvmLibcTableTest, AllocationAndDeallocation) {
   size_t caps[] = {0, 1, 2, 3, 4, 7, 11, 37, 1024, 5261, 19999};
@@ -81,7 +82,7 @@ TEST(LlvmLibcTableTest, GrowthSequence) {
 }
 
 TEST(LlvmLibcTableTest, Insertion) {
-  union key {
+  struct key {
     char bytes[2];
   } keys[256];
   for (size_t k = 0; k < 256; ++k) {
@@ -128,4 +129,4 @@ TEST(LlvmLibcTableTest, Insertion) {
 }
 
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/OSUtil/linux/vdso_test.cpp b/test/src/__support/OSUtil/linux/vdso_test.cpp
new file mode 100644
index 0000000..2f68470
--- /dev/null
+++ b/test/src/__support/OSUtil/linux/vdso_test.cpp
@@ -0,0 +1,161 @@
+//===-- Unittests for VDSO ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/signal_macros.h"
+#include "hdr/time_macros.h"
+#include "hdr/types/clockid_t.h"
+#include "hdr/types/struct_sigaction.h"
+#include "hdr/types/struct_timespec.h"
+#include "hdr/types/struct_timeval.h"
+#include "hdr/types/time_t.h"
+#include "src/__support/OSUtil/linux/vdso.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/macros/properties/architectures.h"
+#include "src/signal/raise.h"
+#include "src/signal/sigaction.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+#include <linux/time_types.h>
+#include <sys/syscall.h>
+
+struct riscv_hwprobe {
+  int64_t key;
+  uint64_t value;
+};
+
+namespace LIBC_NAMESPACE_DECL {
+// For x86_64, we explicitly test some traditional vdso symbols are indeed
+// available.
+
+TEST(LlvmLibcOSUtilVDSOTest, GetTimeOfDay) {
+  vdso::TypedSymbol<vdso::VDSOSym::GetTimeOfDay> symbol;
+  if (!symbol)
+    return;
+  timeval tv;
+  EXPECT_EQ(symbol(&tv, nullptr), 0);
+  // hopefully people are not building time machines using our libc.
+  EXPECT_GT(tv.tv_sec, static_cast<decltype(tv.tv_sec)>(0));
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, Time) {
+  vdso::TypedSymbol<vdso::VDSOSym::Time> symbol;
+  if (!symbol)
+    return;
+  time_t a, b;
+  EXPECT_GT(symbol(&a), static_cast<time_t>(0));
+  EXPECT_GT(symbol(&b), static_cast<time_t>(0));
+  EXPECT_GE(b, a);
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, ClockGetTime) {
+  vdso::TypedSymbol<vdso::VDSOSym::ClockGetTime> symbol;
+  if (!symbol)
+    return;
+  timespec a, b;
+  EXPECT_EQ(symbol(CLOCK_MONOTONIC, &a), 0);
+  EXPECT_EQ(symbol(CLOCK_MONOTONIC, &b), 0);
+  if (a.tv_sec == b.tv_sec) {
+    EXPECT_LT(a.tv_nsec, b.tv_nsec);
+  } else {
+    EXPECT_LT(a.tv_sec, b.tv_sec);
+  }
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, ClockGetTime64) {
+  vdso::TypedSymbol<vdso::VDSOSym::ClockGetTime64> symbol;
+  if (!symbol)
+    return;
+  // See kernel API at
+  // https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vDSO/vdso_test_correctness.c#L155
+  __kernel_timespec a, b;
+  EXPECT_EQ(symbol(CLOCK_MONOTONIC, &a), 0);
+  EXPECT_EQ(symbol(CLOCK_MONOTONIC, &b), 0);
+  if (a.tv_sec == b.tv_sec) {
+    EXPECT_LT(a.tv_nsec, b.tv_nsec);
+  } else {
+    EXPECT_LT(a.tv_sec, b.tv_sec);
+  }
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, ClockGetRes) {
+  vdso::TypedSymbol<vdso::VDSOSym::ClockGetRes> symbol;
+  if (!symbol)
+    return;
+  timespec res{};
+  EXPECT_EQ(symbol(CLOCK_MONOTONIC, &res), 0);
+  EXPECT_TRUE(res.tv_sec > 0 || res.tv_nsec > 0);
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, GetCpu) {
+  // The kernel system call has a third argument, which should be passed as
+  // nullptr.
+  vdso::TypedSymbol<vdso::VDSOSym::GetCpu> symbol;
+  if (!symbol)
+    return;
+  unsigned cpu = static_cast<unsigned>(-1), node = static_cast<unsigned>(-1);
+  EXPECT_EQ(symbol(&cpu, &node, nullptr), 0);
+  EXPECT_GE(cpu, 0u);
+  EXPECT_GE(node, 0u);
+}
+
+static bool flag = false;
+static void sigprof_handler [[gnu::used]] (int) { flag = true; }
+
+TEST(LlvmLibcOSUtilVDSOTest, RtSigReturn) {
+  using namespace testing::ErrnoSetterMatcher;
+  // must use struct since there is a function of the same name in the same
+  // scope.
+  struct sigaction sa {};
+  struct sigaction old_sa {};
+  sa.sa_handler = sigprof_handler;
+  sa.sa_flags = SA_RESTORER;
+  vdso::TypedSymbol<vdso::VDSOSym::RTSigReturn> symbol;
+  if (!symbol)
+    return;
+  sa.sa_restorer = symbol;
+  ASSERT_THAT(LIBC_NAMESPACE::sigaction(SIGPROF, &sa, &old_sa), Succeeds());
+  raise(SIGPROF);
+  ASSERT_TRUE(flag);
+  flag = false;
+  ASSERT_THAT(LIBC_NAMESPACE::sigaction(SIGPROF, &old_sa, nullptr), Succeeds());
+}
+
+TEST(LlvmLibcOSUtilVDSOTest, FlushICache) {
+  vdso::TypedSymbol<vdso::VDSOSym::FlushICache> symbol;
+  if (!symbol)
+    return;
+  char buf[512];
+  // we just check that the flush will not panic the program.
+  // the flags part only take 0/1 as up to kernel 6.10, which is used to
+  // indicate whether the flush is local to the core or global.
+  symbol(buf, buf + sizeof(buf), 0);
+  symbol(buf, buf + sizeof(buf), 1);
+}
+
+// https://docs.kernel.org/6.5/riscv/hwprobe.html
+TEST(LlvmLibcOSUtilVDSOTest, RiscvHwProbe) {
+  using namespace testing::ErrnoSetterMatcher;
+  vdso::TypedSymbol<vdso::VDSOSym::RiscvHwProbe> symbol;
+  if (!symbol)
+    return;
+  // If a key is unknown to the kernel, its key field will be cleared to -1, and
+  // its value set to 0. We expect probes.value are all 0.
+  // Usermode can supply NULL for cpus and 0 for cpu_count as a shortcut for all
+  // online CPUs
+  riscv_hwprobe probes[2] = {{-1, 1}, {-1, 1}};
+  ASSERT_THAT(symbol(/*pairs=*/probes, /*count=*/2, /*cpusetsize=*/0,
+                     /*cpuset=*/nullptr,
+                     /*flags=*/0),
+              Succeeds());
+  for (auto &probe : probes) {
+    EXPECT_EQ(probe.key, static_cast<decltype(probe.key)>(-1));
+    EXPECT_EQ(probe.value, static_cast<decltype(probe.value)>(0));
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/arg_list_test.cpp b/test/src/__support/arg_list_test.cpp
index 4f229e2..79a715e 100644
--- a/test/src/__support/arg_list_test.cpp
+++ b/test/src/__support/arg_list_test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/arg_list.h"
+#include "src/__support/macros/properties/os.h"
 
 #include "test/UnitTest/Test.h"
 
@@ -120,7 +121,7 @@ TEST(LlvmLibcArgListTest, TestStructTypes) {
 }
 
 // Test vector extensions from clang.
-#if __has_attribute(ext_vector_type)
+#if !defined(LIBC_TARGET_OS_IS_WINDOWS) && __has_attribute(ext_vector_type)
 
 using int1 = int __attribute__((ext_vector_type(1)));
 using int2 = int __attribute__((ext_vector_type(2)));
diff --git a/test/src/__support/big_int_test.cpp b/test/src/__support/big_int_test.cpp
index 84cd206..2666ed9 100644
--- a/test/src/__support/big_int_test.cpp
+++ b/test/src/__support/big_int_test.cpp
@@ -8,13 +8,14 @@
 
 #include "src/__support/CPP/optional.h"
 #include "src/__support/big_int.h"
-#include "src/__support/integer_literals.h"        // parse_unsigned_bigint
+#include "src/__support/integer_literals.h" // parse_unsigned_bigint
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT128
 
 #include "hdr/math_macros.h" // HUGE_VALF, HUGE_VALF
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 enum Value { ZERO, ONE, TWO, MIN, MAX };
 
@@ -31,6 +32,7 @@ template <typename T> auto create(Value value) {
   case MAX:
     return T::max();
   }
+  __builtin_unreachable();
 }
 
 using Types = testing::TypeList< //
@@ -206,6 +208,7 @@ TYPED_TEST(LlvmLibcUIntClassTest, CountBits, Types) {
 }
 
 using LL_UInt16 = UInt<16>;
+using LL_UInt32 = UInt<32>;
 using LL_UInt64 = UInt<64>;
 // We want to test UInt<128> explicitly. So, for
 // convenience, we use a sugar which does not conflict with the UInt128 type
@@ -263,7 +266,11 @@ TEST(LlvmLibcUIntClassTest, BitCastToFromNativeFloat128) {
 TEST(LlvmLibcUIntClassTest, BitCastToFromNativeFloat16) {
   static_assert(cpp::is_trivially_copyable<LL_UInt16>::value);
   static_assert(sizeof(LL_UInt16) == sizeof(float16));
-  const float16 array[] = {0, 0.1, 1};
+  const float16 array[] = {
+      static_cast<float16>(0.0),
+      static_cast<float16>(0.1),
+      static_cast<float16>(1.0),
+  };
   for (float16 value : array) {
     LL_UInt16 back = cpp::bit_cast<LL_UInt16>(value);
     float16 forth = cpp::bit_cast<float16>(back);
@@ -921,4 +928,151 @@ TEST(LlvmLibcUIntClassTest, OtherWordTypeTests) {
   ASSERT_EQ(static_cast<int>(a >> 64), 1);
 }
 
-} // namespace LIBC_NAMESPACE
+TEST(LlvmLibcUIntClassTest, OtherWordTypeCastTests) {
+  using LL_UInt96 = BigInt<96, false, uint32_t>;
+
+  LL_UInt96 a({123, 456, 789});
+
+  ASSERT_EQ(static_cast<int>(a), 123);
+  ASSERT_EQ(static_cast<int>(a >> 32), 456);
+  ASSERT_EQ(static_cast<int>(a >> 64), 789);
+
+  // Bigger word with more bits to smaller word with less bits.
+  LL_UInt128 b(a);
+
+  ASSERT_EQ(static_cast<int>(b), 123);
+  ASSERT_EQ(static_cast<int>(b >> 32), 456);
+  ASSERT_EQ(static_cast<int>(b >> 64), 789);
+  ASSERT_EQ(static_cast<int>(b >> 96), 0);
+
+  b = (b << 32) + 987;
+
+  ASSERT_EQ(static_cast<int>(b), 987);
+  ASSERT_EQ(static_cast<int>(b >> 32), 123);
+  ASSERT_EQ(static_cast<int>(b >> 64), 456);
+  ASSERT_EQ(static_cast<int>(b >> 96), 789);
+
+  // Smaller word with less bits to bigger word with more bits.
+  LL_UInt96 c(b);
+
+  ASSERT_EQ(static_cast<int>(c), 987);
+  ASSERT_EQ(static_cast<int>(c >> 32), 123);
+  ASSERT_EQ(static_cast<int>(c >> 64), 456);
+
+  // Smaller word with more bits to bigger word with less bits
+  LL_UInt64 d(c);
+
+  ASSERT_EQ(static_cast<int>(d), 987);
+  ASSERT_EQ(static_cast<int>(d >> 32), 123);
+
+  // Bigger word with less bits to smaller word with more bits
+
+  LL_UInt96 e(d);
+
+  ASSERT_EQ(static_cast<int>(e), 987);
+  ASSERT_EQ(static_cast<int>(e >> 32), 123);
+
+  e = (e << 32) + 654;
+
+  ASSERT_EQ(static_cast<int>(e), 654);
+  ASSERT_EQ(static_cast<int>(e >> 32), 987);
+  ASSERT_EQ(static_cast<int>(e >> 64), 123);
+}
+
+TEST(LlvmLibcUIntClassTest, SignedOtherWordTypeCastTests) {
+  using LL_Int64 = BigInt<64, true, uint64_t>;
+  using LL_Int96 = BigInt<96, true, uint32_t>;
+
+  LL_Int64 zero_64(0);
+  LL_Int96 zero_96(0);
+  LL_Int192 zero_192(0);
+
+  LL_Int96 plus_a({0x1234, 0x5678, 0x9ABC});
+
+  ASSERT_EQ(static_cast<int>(plus_a), 0x1234);
+  ASSERT_EQ(static_cast<int>(plus_a >> 32), 0x5678);
+  ASSERT_EQ(static_cast<int>(plus_a >> 64), 0x9ABC);
+
+  LL_Int96 minus_a(-plus_a);
+
+  // The reason that the numbers are inverted and not negated is that we're
+  // using two's complement. To negate a two's complement number you flip the
+  // bits and add 1, so minus_a is {~0x1234, ~0x5678, ~0x9ABC} + {1,0,0}.
+  ASSERT_EQ(static_cast<int>(minus_a), (~0x1234) + 1);
+  ASSERT_EQ(static_cast<int>(minus_a >> 32), ~0x5678);
+  ASSERT_EQ(static_cast<int>(minus_a >> 64), ~0x9ABC);
+
+  ASSERT_TRUE(plus_a + minus_a == zero_96);
+
+  // 192 so there's an extra block to get sign extended to
+  LL_Int192 bigger_plus_a(plus_a);
+
+  ASSERT_EQ(static_cast<int>(bigger_plus_a), 0x1234);
+  ASSERT_EQ(static_cast<int>(bigger_plus_a >> 32), 0x5678);
+  ASSERT_EQ(static_cast<int>(bigger_plus_a >> 64), 0x9ABC);
+  ASSERT_EQ(static_cast<int>(bigger_plus_a >> 96), 0);
+  ASSERT_EQ(static_cast<int>(bigger_plus_a >> 128), 0);
+  ASSERT_EQ(static_cast<int>(bigger_plus_a >> 160), 0);
+
+  LL_Int192 bigger_minus_a(minus_a);
+
+  ASSERT_EQ(static_cast<int>(bigger_minus_a), (~0x1234) + 1);
+  ASSERT_EQ(static_cast<int>(bigger_minus_a >> 32), ~0x5678);
+  ASSERT_EQ(static_cast<int>(bigger_minus_a >> 64), ~0x9ABC);
+  ASSERT_EQ(static_cast<int>(bigger_minus_a >> 96), ~0);
+  ASSERT_EQ(static_cast<int>(bigger_minus_a >> 128), ~0);
+  ASSERT_EQ(static_cast<int>(bigger_minus_a >> 160), ~0);
+
+  ASSERT_TRUE(bigger_plus_a + bigger_minus_a == zero_192);
+
+  LL_Int64 smaller_plus_a(plus_a);
+
+  ASSERT_EQ(static_cast<int>(smaller_plus_a), 0x1234);
+  ASSERT_EQ(static_cast<int>(smaller_plus_a >> 32), 0x5678);
+
+  LL_Int64 smaller_minus_a(minus_a);
+
+  ASSERT_EQ(static_cast<int>(smaller_minus_a), (~0x1234) + 1);
+  ASSERT_EQ(static_cast<int>(smaller_minus_a >> 32), ~0x5678);
+
+  ASSERT_TRUE(smaller_plus_a + smaller_minus_a == zero_64);
+
+  // Also try going from bigger word size to smaller word size
+  LL_Int96 smaller_back_plus_a(smaller_plus_a);
+
+  ASSERT_EQ(static_cast<int>(smaller_back_plus_a), 0x1234);
+  ASSERT_EQ(static_cast<int>(smaller_back_plus_a >> 32), 0x5678);
+  ASSERT_EQ(static_cast<int>(smaller_back_plus_a >> 64), 0);
+
+  LL_Int96 smaller_back_minus_a(smaller_minus_a);
+
+  ASSERT_EQ(static_cast<int>(smaller_back_minus_a), (~0x1234) + 1);
+  ASSERT_EQ(static_cast<int>(smaller_back_minus_a >> 32), ~0x5678);
+  ASSERT_EQ(static_cast<int>(smaller_back_minus_a >> 64), ~0);
+
+  ASSERT_TRUE(smaller_back_plus_a + smaller_back_minus_a == zero_96);
+
+  LL_Int96 bigger_back_plus_a(bigger_plus_a);
+
+  ASSERT_EQ(static_cast<int>(bigger_back_plus_a), 0x1234);
+  ASSERT_EQ(static_cast<int>(bigger_back_plus_a >> 32), 0x5678);
+  ASSERT_EQ(static_cast<int>(bigger_back_plus_a >> 64), 0x9ABC);
+
+  LL_Int96 bigger_back_minus_a(bigger_minus_a);
+
+  ASSERT_EQ(static_cast<int>(bigger_back_minus_a), (~0x1234) + 1);
+  ASSERT_EQ(static_cast<int>(bigger_back_minus_a >> 32), ~0x5678);
+  ASSERT_EQ(static_cast<int>(bigger_back_minus_a >> 64), ~0x9ABC);
+
+  ASSERT_TRUE(bigger_back_plus_a + bigger_back_minus_a == zero_96);
+}
+
+TEST(LlvmLibcUIntClassTest, MixedSignednessOtherWordTypeCastTests) {
+  using LL_UInt96 = BigInt<96, false, uint32_t>;
+  LL_UInt96 x = -123;
+  // ensure that -123 gets extended, even though the input type is signed while
+  // the BigInt is unsigned.
+  ASSERT_EQ(int64_t(x), int64_t(-123));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/block_test.cpp b/test/src/__support/block_test.cpp
index 6614e4b..5e437db 100644
--- a/test/src/__support/block_test.cpp
+++ b/test/src/__support/block_test.cpp
@@ -8,139 +8,116 @@
 #include <stddef.h>
 
 #include "src/__support/CPP/array.h"
+#include "src/__support/CPP/bit.h"
 #include "src/__support/CPP/span.h"
 #include "src/__support/block.h"
 #include "src/string/memcpy.h"
 #include "test/UnitTest/Test.h"
 
-// Block types.
-using LargeOffsetBlock = LIBC_NAMESPACE::Block<uint64_t>;
-using SmallOffsetBlock = LIBC_NAMESPACE::Block<uint16_t>;
-
-// For each of the block types above, we'd like to run the same tests since
-// they should work independently of the parameter sizes. Rather than re-writing
-// the same test for each case, let's instead create a custom test framework for
-// each test case that invokes the actual testing function for each block type.
-//
-// It's organized this way because the ASSERT/EXPECT macros only work within a
-// `Test` class due to those macros expanding to `test` methods.
-#define TEST_FOR_EACH_BLOCK_TYPE(TestCase)                                     \
-  class LlvmLibcBlockTest##TestCase : public LIBC_NAMESPACE::testing::Test {   \
-  public:                                                                      \
-    template <typename BlockType> void RunTest();                              \
-  };                                                                           \
-  TEST_F(LlvmLibcBlockTest##TestCase, TestCase) {                              \
-    RunTest<LargeOffsetBlock>();                                               \
-    RunTest<SmallOffsetBlock>();                                               \
-  }                                                                            \
-  template <typename BlockType> void LlvmLibcBlockTest##TestCase::RunTest()
-
+using LIBC_NAMESPACE::Block;
 using LIBC_NAMESPACE::cpp::array;
+using LIBC_NAMESPACE::cpp::bit_ceil;
 using LIBC_NAMESPACE::cpp::byte;
 using LIBC_NAMESPACE::cpp::span;
 
-TEST_FOR_EACH_BLOCK_TYPE(CanCreateSingleAlignedBlock) {
+TEST(LlvmLibcBlockTest, CanCreateSingleAlignedBlock) {
   constexpr size_t kN = 1024;
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
 
-  auto result = BlockType::init(bytes);
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  EXPECT_EQ(block->outer_size(), kN);
-  EXPECT_EQ(block->inner_size(), kN - BlockType::BLOCK_OVERHEAD);
-  EXPECT_EQ(block->prev(), static_cast<BlockType *>(nullptr));
-  EXPECT_EQ(block->next(), static_cast<BlockType *>(nullptr));
+  Block *last = block->next();
+  ASSERT_NE(last, static_cast<Block *>(nullptr));
+  constexpr size_t last_outer_size = Block::BLOCK_OVERHEAD;
+  EXPECT_EQ(last->outer_size(), last_outer_size);
+  EXPECT_EQ(last->prev_free(), block);
+  EXPECT_TRUE(last->used());
+
+  EXPECT_EQ(block->outer_size(), kN - last_outer_size);
+  constexpr size_t last_prev_field_size = sizeof(size_t);
+  EXPECT_EQ(block->inner_size(), kN - last_outer_size - Block::BLOCK_OVERHEAD +
+                                     last_prev_field_size);
+  EXPECT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
   EXPECT_FALSE(block->used());
-  EXPECT_TRUE(block->last());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanCreateUnalignedSingleBlock) {
+TEST(LlvmLibcBlockTest, CanCreateUnalignedSingleBlock) {
   constexpr size_t kN = 1024;
 
   // Force alignment, so we can un-force it below
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
   span<byte> aligned(bytes);
 
-  auto result = BlockType::init(aligned.subspan(1));
+  auto result = Block::init(aligned.subspan(1));
   EXPECT_TRUE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotCreateTooSmallBlock) {
+TEST(LlvmLibcBlockTest, CannotCreateTooSmallBlock) {
   array<byte, 2> bytes;
-  auto result = BlockType::init(bytes);
+  auto result = Block::init(bytes);
   EXPECT_FALSE(result.has_value());
 }
 
-// This test specifically checks that we cannot allocate a block with a size
-// larger than what can be held by the offset type, we don't need to test with
-// multiple block types for this particular check, so we use the normal TEST
-// macro and not the custom framework.
-TEST(LlvmLibcBlockTest, CannotCreateTooLargeBlock) {
-  using BlockType = LIBC_NAMESPACE::Block<uint8_t>;
+TEST(LlvmLibcBlockTest, CanSplitBlock) {
   constexpr size_t kN = 1024;
+  constexpr size_t prev_field_size = sizeof(size_t);
+  // Give the split position a large alignment.
+  constexpr size_t kSplitN = 512 + prev_field_size;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
-  EXPECT_FALSE(result.has_value());
-}
-
-TEST_FOR_EACH_BLOCK_TYPE(CanSplitBlock) {
-  constexpr size_t kN = 1024;
-  constexpr size_t kSplitN = 512;
-
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   auto *block1 = *result;
+  size_t orig_size = block1->outer_size();
 
-  result = BlockType::split(block1, kSplitN);
+  result = block1->split(kSplitN);
   ASSERT_TRUE(result.has_value());
-
   auto *block2 = *result;
 
   EXPECT_EQ(block1->inner_size(), kSplitN);
-  EXPECT_EQ(block1->outer_size(), kSplitN + BlockType::BLOCK_OVERHEAD);
-  EXPECT_FALSE(block1->last());
+  EXPECT_EQ(block1->outer_size(),
+            kSplitN - prev_field_size + Block::BLOCK_OVERHEAD);
 
-  EXPECT_EQ(block2->outer_size(), kN - kSplitN - BlockType::BLOCK_OVERHEAD);
+  EXPECT_EQ(block2->outer_size(), orig_size - block1->outer_size());
   EXPECT_FALSE(block2->used());
-  EXPECT_TRUE(block2->last());
 
   EXPECT_EQ(block1->next(), block2);
-  EXPECT_EQ(block2->prev(), block1);
+  EXPECT_EQ(block2->prev_free(), block1);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanSplitBlockUnaligned) {
+TEST(LlvmLibcBlockTest, CanSplitBlockUnaligned) {
   constexpr size_t kN = 1024;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block1 = *result;
+  size_t orig_size = block1->outer_size();
 
-  // We should split at sizeof(BlockType) + kSplitN bytes. Then
-  // we need to round that up to an alignof(BlockType) boundary.
   constexpr size_t kSplitN = 513;
-  uintptr_t split_addr = reinterpret_cast<uintptr_t>(block1) + kSplitN;
-  split_addr += alignof(BlockType) - (split_addr % alignof(BlockType));
-  uintptr_t split_len = split_addr - (uintptr_t)&bytes;
+  constexpr size_t prev_field_size = sizeof(size_t);
+  uintptr_t split_addr =
+      reinterpret_cast<uintptr_t>(block1) + (kSplitN - prev_field_size);
+  // Round split_addr up to a multiple of the alignment.
+  split_addr += alignof(Block) - (split_addr % alignof(Block));
+  uintptr_t split_len = split_addr - (uintptr_t)&bytes + prev_field_size;
 
-  result = BlockType::split(block1, kSplitN);
+  result = block1->split(kSplitN);
   ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
+  Block *block2 = *result;
 
   EXPECT_EQ(block1->inner_size(), split_len);
-  EXPECT_EQ(block1->outer_size(), split_len + BlockType::BLOCK_OVERHEAD);
 
-  EXPECT_EQ(block2->outer_size(), kN - block1->outer_size());
+  EXPECT_EQ(block2->outer_size(), orig_size - block1->outer_size());
   EXPECT_FALSE(block2->used());
 
   EXPECT_EQ(block1->next(), block2);
-  EXPECT_EQ(block2->prev(), block1);
+  EXPECT_EQ(block2->prev_free(), block1);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanSplitMidBlock) {
+TEST(LlvmLibcBlockTest, CanSplitMidBlock) {
   // split once, then split the original block again to ensure that the
   // pointers get rewired properly.
   // I.e.
@@ -154,416 +131,417 @@ TEST_FOR_EACH_BLOCK_TYPE(CanSplitMidBlock) {
   constexpr size_t kSplit1 = 512;
   constexpr size_t kSplit2 = 256;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block1 = *result;
 
-  result = BlockType::split(block1, kSplit1);
+  result = block1->split(kSplit1);
   ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
+  Block *block2 = *result;
 
-  result = BlockType::split(block1, kSplit2);
+  result = block1->split(kSplit2);
   ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
+  Block *block3 = *result;
 
   EXPECT_EQ(block1->next(), block3);
-  EXPECT_EQ(block3->prev(), block1);
+  EXPECT_EQ(block3->prev_free(), block1);
   EXPECT_EQ(block3->next(), block2);
-  EXPECT_EQ(block2->prev(), block3);
+  EXPECT_EQ(block2->prev_free(), block3);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotSplitTooSmallBlock) {
+TEST(LlvmLibcBlockTest, CannotSplitTooSmallBlock) {
   constexpr size_t kN = 64;
   constexpr size_t kSplitN = kN + 1;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block, kSplitN);
+  result = block->split(kSplitN);
   ASSERT_FALSE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotSplitBlockWithoutHeaderSpace) {
+TEST(LlvmLibcBlockTest, CannotSplitBlockWithoutHeaderSpace) {
   constexpr size_t kN = 1024;
-  constexpr size_t kSplitN = kN - BlockType::BLOCK_OVERHEAD - 1;
+  constexpr size_t kSplitN = kN - 2 * Block::BLOCK_OVERHEAD - 1;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block, kSplitN);
+  result = block->split(kSplitN);
   ASSERT_FALSE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotSplitNull) {
-  BlockType *block = nullptr;
-  auto result = BlockType::split(block, 1);
-  ASSERT_FALSE(result.has_value());
-}
-
-TEST_FOR_EACH_BLOCK_TYPE(CannotMakeBlockLargerInSplit) {
+TEST(LlvmLibcBlockTest, CannotMakeBlockLargerInSplit) {
   // Ensure that we can't ask for more space than the block actually has...
   constexpr size_t kN = 1024;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block, block->inner_size() + 1);
+  result = block->split(block->inner_size() + 1);
   ASSERT_FALSE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotMakeSecondBlockLargerInSplit) {
+TEST(LlvmLibcBlockTest, CannotMakeSecondBlockLargerInSplit) {
   // Ensure that the second block in split is at least of the size of header.
   constexpr size_t kN = 1024;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block, block->inner_size() -
-                                       BlockType::BLOCK_OVERHEAD + 1);
+  result = block->split(block->inner_size() - Block::BLOCK_OVERHEAD + 1);
   ASSERT_FALSE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanMakeZeroSizeFirstBlock) {
-  // This block does support splitting with zero payload size.
+TEST(LlvmLibcBlockTest, CanMakeMinimalSizeFirstBlock) {
+  // This block does support splitting with minimal payload size.
   constexpr size_t kN = 1024;
+  constexpr size_t minimal_size = sizeof(size_t);
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block, 0);
+  result = block->split(minimal_size);
   ASSERT_TRUE(result.has_value());
-  EXPECT_EQ(block->inner_size(), static_cast<size_t>(0));
+  EXPECT_EQ(block->inner_size(), minimal_size);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanMakeZeroSizeSecondBlock) {
-  // Likewise, the split block can be zero-width.
+TEST(LlvmLibcBlockTest, CanMakeMinimalSizeSecondBlock) {
+  // Likewise, the split block can be minimal-width.
   constexpr size_t kN = 1024;
+  constexpr size_t minimal_size = sizeof(size_t);
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block1 = *result;
 
-  result = BlockType::split(block1,
-                            block1->inner_size() - BlockType::BLOCK_OVERHEAD);
+  result = block1->split(block1->inner_size() - Block::BLOCK_OVERHEAD);
   ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
+  Block *block2 = *result;
 
-  EXPECT_EQ(block2->inner_size(), static_cast<size_t>(0));
+  EXPECT_EQ(block2->inner_size(), minimal_size);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanMarkBlockUsed) {
+TEST(LlvmLibcBlockTest, CanMarkBlockUsed) {
   constexpr size_t kN = 1024;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
+  size_t orig_size = block->outer_size();
 
   block->mark_used();
   EXPECT_TRUE(block->used());
-
-  // Size should be unaffected.
-  EXPECT_EQ(block->outer_size(), kN);
+  EXPECT_EQ(block->outer_size(), orig_size);
 
   block->mark_free();
   EXPECT_FALSE(block->used());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotSplitUsedBlock) {
+TEST(LlvmLibcBlockTest, CannotSplitUsedBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
   block->mark_used();
-  result = BlockType::split(block, kSplitN);
+  result = block->split(kSplitN);
   ASSERT_FALSE(result.has_value());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanMergeWithNextBlock) {
+TEST(LlvmLibcBlockTest, CanMergeWithNextBlock) {
   // Do the three way merge from "CanSplitMidBlock", and let's
   // merge block 3 and 2
   constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
+  // Give the split positions large alignments.
+  constexpr size_t prev_field_size = sizeof(size_t);
+  constexpr size_t kSplit1 = 512 + prev_field_size;
+  constexpr size_t kSplit2 = 256 + prev_field_size;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block1 = *result;
+  size_t orig_size = block1->outer_size();
 
-  result = BlockType::split(block1, kSplit1);
+  result = block1->split(kSplit1);
   ASSERT_TRUE(result.has_value());
 
-  result = BlockType::split(block1, kSplit2);
+  result = block1->split(kSplit2);
   ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
+  Block *block3 = *result;
 
-  EXPECT_TRUE(BlockType::merge_next(block3));
+  EXPECT_TRUE(block3->merge_next());
 
   EXPECT_EQ(block1->next(), block3);
-  EXPECT_EQ(block3->prev(), block1);
+  EXPECT_EQ(block3->prev_free(), block1);
   EXPECT_EQ(block1->inner_size(), kSplit2);
-  EXPECT_EQ(block3->outer_size(), kN - block1->outer_size());
+  EXPECT_EQ(block3->outer_size(), orig_size - block1->outer_size());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotMergeWithFirstOrLastBlock) {
+TEST(LlvmLibcBlockTest, CannotMergeWithFirstOrLastBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block1 = *result;
 
   // Do a split, just to check that the checks on next/prev are different...
-  result = BlockType::split(block1, kSplitN);
+  result = block1->split(kSplitN);
   ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
+  Block *block2 = *result;
 
-  EXPECT_FALSE(BlockType::merge_next(block2));
+  EXPECT_FALSE(block2->merge_next());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CannotMergeNull) {
-  BlockType *block = nullptr;
-  EXPECT_FALSE(BlockType::merge_next(block));
-}
-
-TEST_FOR_EACH_BLOCK_TYPE(CannotMergeUsedBlock) {
+TEST(LlvmLibcBlockTest, CannotMergeUsedBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block = *result;
 
   // Do a split, just to check that the checks on next/prev are different...
-  result = BlockType::split(block, kSplitN);
+  result = block->split(kSplitN);
   ASSERT_TRUE(result.has_value());
 
   block->mark_used();
-  EXPECT_FALSE(BlockType::merge_next(block));
+  EXPECT_FALSE(block->merge_next());
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanFreeSingleBlock) {
+TEST(LlvmLibcBlockTest, CanGetBlockFromUsableSpace) {
   constexpr size_t kN = 1024;
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
 
-  auto result = BlockType::init(bytes);
+  array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block = *result;
+  Block *block1 = *result;
 
-  block->mark_used();
-  BlockType::free(block);
-  EXPECT_FALSE(block->used());
-  EXPECT_EQ(block->outer_size(), kN);
+  void *ptr = block1->usable_space();
+  Block *block2 = Block::from_usable_space(ptr);
+  EXPECT_EQ(block1, block2);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanFreeBlockWithoutMerging) {
+TEST(LlvmLibcBlockTest, CanGetConstBlockFromUsableSpace) {
   constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
-
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
 
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
-
-  result = BlockType::split(block2, kSplit2);
+  array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
+  const Block *block1 = *result;
 
-  block1->mark_used();
-  block2->mark_used();
-  block3->mark_used();
-
-  BlockType::free(block2);
-  EXPECT_FALSE(block2->used());
-  EXPECT_NE(block2->prev(), static_cast<BlockType *>(nullptr));
-  EXPECT_FALSE(block2->last());
+  const void *ptr = block1->usable_space();
+  const Block *block2 = Block::from_usable_space(ptr);
+  EXPECT_EQ(block1, block2);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanFreeBlockAndMergeWithPrev) {
-  constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
-
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
-
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
-
-  result = BlockType::split(block2, kSplit2);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
-
-  block2->mark_used();
-  block3->mark_used();
-
-  BlockType::free(block2);
-  EXPECT_FALSE(block2->used());
-  EXPECT_EQ(block2->prev(), static_cast<BlockType *>(nullptr));
-  EXPECT_FALSE(block2->last());
+TEST(LlvmLibcBlockTest, CanAllocate) {
+  constexpr size_t kN = 1024 + Block::BLOCK_OVERHEAD;
+
+  // Ensure we can allocate everything up to the block size within this block.
+  for (size_t i = 0; i < kN - 2 * Block::BLOCK_OVERHEAD; ++i) {
+    alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
+    auto result = Block::init(bytes);
+    ASSERT_TRUE(result.has_value());
+    Block *block = *result;
+
+    constexpr size_t ALIGN = 1; // Effectively ignores alignment.
+    EXPECT_TRUE(block->can_allocate(ALIGN, i));
+
+    // For each can_allocate, we should be able to do a successful call to
+    // allocate.
+    auto info = Block::allocate(block, ALIGN, i);
+    EXPECT_NE(info.block, static_cast<Block *>(nullptr));
+  }
+
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
+  ASSERT_TRUE(result.has_value());
+  Block *block = *result;
+
+  // Given a block of size N (assuming it's also a power of two), we should be
+  // able to allocate a block within it that's aligned to N/2. This is
+  // because regardless of where the buffer is located, we can always find a
+  // starting location within it that meets this alignment.
+  EXPECT_TRUE(block->can_allocate(block->outer_size() / 2, 1));
+  auto info = Block::allocate(block, block->outer_size() / 2, 1);
+  EXPECT_NE(info.block, static_cast<Block *>(nullptr));
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanFreeBlockAndMergeWithNext) {
+TEST(LlvmLibcBlockTest, AllocateAlreadyAligned) {
   constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
-
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
-
-  result = BlockType::split(block2, kSplit2);
-  ASSERT_TRUE(result.has_value());
-
-  block1->mark_used();
-  block2->mark_used();
-
-  BlockType::free(block2);
-  EXPECT_FALSE(block2->used());
-  EXPECT_NE(block2->prev(), static_cast<BlockType *>(nullptr));
-  EXPECT_TRUE(block2->last());
-}
+  Block *block = *result;
 
-TEST_FOR_EACH_BLOCK_TYPE(CanFreeUsedBlockAndMergeWithBoth) {
-  constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
+  // This should result in no new blocks.
+  constexpr size_t kAlignment = Block::ALIGNMENT;
+  constexpr size_t prev_field_size = sizeof(size_t);
+  constexpr size_t kExpectedSize = Block::ALIGNMENT + prev_field_size;
+  EXPECT_TRUE(block->can_allocate(kAlignment, kExpectedSize));
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  auto [aligned_block, prev, next] =
+      Block::allocate(block, Block::ALIGNMENT, kExpectedSize);
 
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
-
-  result = BlockType::split(block2, kSplit2);
-  ASSERT_TRUE(result.has_value());
+  // Since this is already aligned, there should be no previous block.
+  EXPECT_EQ(prev, static_cast<Block *>(nullptr));
 
-  block2->mark_used();
+  // Ensure we the block is aligned and the size we expect.
+  EXPECT_NE(aligned_block, static_cast<Block *>(nullptr));
+  EXPECT_TRUE(aligned_block->is_usable_space_aligned(Block::ALIGNMENT));
+  EXPECT_EQ(aligned_block->inner_size(), kExpectedSize);
 
-  BlockType::free(block2);
-  EXPECT_FALSE(block2->used());
-  EXPECT_EQ(block2->prev(), static_cast<BlockType *>(nullptr));
-  EXPECT_TRUE(block2->last());
+  // Check the next block.
+  EXPECT_NE(next, static_cast<Block *>(nullptr));
+  EXPECT_EQ(aligned_block->next(), next);
+  EXPECT_EQ(reinterpret_cast<byte *>(next) + next->outer_size(),
+            bytes.data() + bytes.size() - Block::BLOCK_OVERHEAD);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanCheckValidBlock) {
+TEST(LlvmLibcBlockTest, AllocateNeedsAlignment) {
   constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 512;
-  constexpr size_t kSplit2 = 256;
 
-  alignas(BlockType::ALIGNMENT) array<byte, kN> bytes;
-  auto result = BlockType::init(bytes);
+  alignas(kN) array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
+  Block *block = *result;
 
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
+  // Ensure first the usable_data is only aligned to the block alignment.
+  ASSERT_EQ(block->usable_space(), bytes.data() + Block::BLOCK_OVERHEAD);
+  ASSERT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
 
-  result = BlockType::split(block2, kSplit2);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
+  // Now pick an alignment such that the usable space is not already aligned to
+  // it. We want to explicitly test that the block will split into one before
+  // it.
+  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
+  ASSERT_FALSE(block->is_usable_space_aligned(kAlignment));
 
-  EXPECT_TRUE(block1->is_valid());
-  EXPECT_TRUE(block2->is_valid());
-  EXPECT_TRUE(block3->is_valid());
-}
+  constexpr size_t kSize = 10;
+  EXPECT_TRUE(block->can_allocate(kAlignment, kSize));
 
-TEST_FOR_EACH_BLOCK_TYPE(CanCheckInvalidBlock) {
-  constexpr size_t kN = 1024;
-  constexpr size_t kSplit1 = 128;
-  constexpr size_t kSplit2 = 384;
-  constexpr size_t kSplit3 = 256;
+  auto [aligned_block, prev, next] = Block::allocate(block, kAlignment, kSize);
 
-  array<byte, kN> bytes{};
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
-
-  result = BlockType::split(block1, kSplit1);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block2 = *result;
-
-  result = BlockType::split(block2, kSplit2);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block3 = *result;
+  // Check the previous block was created appropriately. Since this block is the
+  // first block, a new one should be made before this.
+  EXPECT_NE(prev, static_cast<Block *>(nullptr));
+  EXPECT_EQ(aligned_block->prev_free(), prev);
+  EXPECT_EQ(prev->next(), aligned_block);
+  EXPECT_EQ(prev->outer_size(), reinterpret_cast<uintptr_t>(aligned_block) -
+                                    reinterpret_cast<uintptr_t>(prev));
 
-  result = BlockType::split(block3, kSplit3);
-  ASSERT_TRUE(result.has_value());
+  // Ensure we the block is aligned and the size we expect.
+  EXPECT_NE(next, static_cast<Block *>(nullptr));
+  EXPECT_TRUE(aligned_block->is_usable_space_aligned(kAlignment));
 
-  // Corrupt a Block header.
-  // This must not touch memory outside the original region, or the test may
-  // (correctly) abort when run with address sanitizer.
-  // To remain as agostic to the internals of `Block` as possible, the test
-  // copies a smaller block's header to a larger block.
-  EXPECT_TRUE(block1->is_valid());
-  EXPECT_TRUE(block2->is_valid());
-  EXPECT_TRUE(block3->is_valid());
-  auto *src = reinterpret_cast<byte *>(block1);
-  auto *dst = reinterpret_cast<byte *>(block2);
-  LIBC_NAMESPACE::memcpy(dst, src, sizeof(BlockType));
-  EXPECT_FALSE(block1->is_valid());
-  EXPECT_FALSE(block2->is_valid());
-  EXPECT_FALSE(block3->is_valid());
+  // Check the next block.
+  EXPECT_NE(next, static_cast<Block *>(nullptr));
+  EXPECT_EQ(aligned_block->next(), next);
+  EXPECT_EQ(reinterpret_cast<byte *>(next) + next->outer_size(),
+            bytes.data() + bytes.size() - Block::BLOCK_OVERHEAD);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanGetBlockFromUsableSpace) {
+TEST(LlvmLibcBlockTest, PreviousBlockMergedIfNotFirst) {
   constexpr size_t kN = 1024;
 
-  array<byte, kN> bytes{};
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  BlockType *block1 = *result;
-
-  void *ptr = block1->usable_space();
-  BlockType *block2 = BlockType::from_usable_space(ptr);
-  EXPECT_EQ(block1, block2);
+  alignas(kN) array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
+  ASSERT_TRUE(result.has_value());
+  Block *block = *result;
+
+  // Split the block roughly halfway and work on the second half.
+  auto result2 = block->split(kN / 2);
+  ASSERT_TRUE(result2.has_value());
+  Block *newblock = *result2;
+  ASSERT_EQ(newblock->prev_free(), block);
+  size_t old_prev_size = block->outer_size();
+
+  // Now pick an alignment such that the usable space is not already aligned to
+  // it. We want to explicitly test that the block will split into one before
+  // it.
+  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
+  ASSERT_FALSE(newblock->is_usable_space_aligned(kAlignment));
+
+  // Ensure we can allocate in the new block.
+  constexpr size_t kSize = Block::ALIGNMENT;
+  EXPECT_TRUE(newblock->can_allocate(kAlignment, kSize));
+
+  auto [aligned_block, prev, next] =
+      Block::allocate(newblock, kAlignment, kSize);
+
+  // Now there should be no new previous block. Instead, the padding we did
+  // create should be merged into the original previous block.
+  EXPECT_EQ(prev, static_cast<Block *>(nullptr));
+  EXPECT_EQ(aligned_block->prev_free(), block);
+  EXPECT_EQ(block->next(), aligned_block);
+  EXPECT_GT(block->outer_size(), old_prev_size);
 }
 
-TEST_FOR_EACH_BLOCK_TYPE(CanGetConstBlockFromUsableSpace) {
+TEST(LlvmLibcBlockTest, CanRemergeBlockAllocations) {
+  // Finally to ensure we made the split blocks correctly via allocate. We
+  // should be able to reconstruct the original block from the blocklets.
+  //
+  // This is the same setup as with the `AllocateNeedsAlignment` test case.
   constexpr size_t kN = 1024;
 
-  array<byte, kN> bytes{};
-  auto result = BlockType::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  const BlockType *block1 = *result;
-
-  const void *ptr = block1->usable_space();
-  const BlockType *block2 = BlockType::from_usable_space(ptr);
-  EXPECT_EQ(block1, block2);
+  alignas(kN) array<byte, kN> bytes{};
+  auto result = Block::init(bytes);
+  ASSERT_TRUE(result.has_value());
+  Block *block = *result;
+  Block *last = block->next();
+
+  // Ensure first the usable_data is only aligned to the block alignment.
+  ASSERT_EQ(block->usable_space(), bytes.data() + Block::BLOCK_OVERHEAD);
+  ASSERT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
+
+  // Now pick an alignment such that the usable space is not already aligned to
+  // it. We want to explicitly test that the block will split into one before
+  // it.
+  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
+  ASSERT_FALSE(block->is_usable_space_aligned(kAlignment));
+
+  constexpr size_t kSize = Block::ALIGNMENT;
+  EXPECT_TRUE(block->can_allocate(kAlignment, kSize));
+
+  auto [aligned_block, prev, next] = Block::allocate(block, kAlignment, kSize);
+
+  // Check we have the appropriate blocks.
+  ASSERT_NE(prev, static_cast<Block *>(nullptr));
+  ASSERT_EQ(aligned_block->prev_free(), prev);
+  EXPECT_NE(next, static_cast<Block *>(nullptr));
+  EXPECT_EQ(aligned_block->next(), next);
+  EXPECT_EQ(next->next(), last);
+
+  // Now check for successful merges.
+  EXPECT_TRUE(prev->merge_next());
+  EXPECT_EQ(prev->next(), next);
+  EXPECT_TRUE(prev->merge_next());
+  EXPECT_EQ(prev->next(), last);
+
+  // We should have the original buffer.
+  EXPECT_EQ(reinterpret_cast<byte *>(prev), &*bytes.begin());
+  EXPECT_EQ(prev->outer_size(), bytes.size() - Block::BLOCK_OVERHEAD);
+  EXPECT_EQ(reinterpret_cast<byte *>(prev) + prev->outer_size(),
+            &*bytes.end() - Block::BLOCK_OVERHEAD);
 }
diff --git a/test/src/__support/blockstore_test.cpp b/test/src/__support/blockstore_test.cpp
index 5fe8fef..de7bd72 100644
--- a/test/src/__support/blockstore_test.cpp
+++ b/test/src/__support/blockstore_test.cpp
@@ -64,6 +64,99 @@ public:
     }
     block_store.destroy(&block_store);
   }
+
+  template <bool REVERSE> void erase_test() {
+    using LIBC_NAMESPACE::BlockStore;
+    BlockStore<int, 2, REVERSE> block_store;
+    int i;
+
+    constexpr int ARR_SIZE = 6;
+
+    ASSERT_TRUE(block_store.empty());
+    for (int i = 0; i < ARR_SIZE; i++) {
+      ASSERT_TRUE(block_store.push_back(i + 1));
+    }
+
+    // block_store state should be {1,2,3,4,5,6}
+
+    block_store.erase(block_store.begin());
+
+    // FORWARD: block_store state should be {2,3,4,5,6}
+    // REVERSE: block_store state should be {1,2,3,4,5}
+
+    auto iter = block_store.begin();
+    for (i = 0; iter != block_store.end(); ++i, ++iter) {
+      if (!REVERSE) {
+        ASSERT_EQ(*iter, i + 2);
+      } else {
+        ASSERT_EQ(*iter, (ARR_SIZE - 1) - i);
+      }
+    }
+
+    // Assert that there were the correct number of elements
+    ASSERT_EQ(i, ARR_SIZE - 1);
+
+    block_store.erase(block_store.end());
+
+    // BOTH: block_store state should be {2,3,4,5}
+
+    iter = block_store.begin();
+    for (i = 0; iter != block_store.end(); ++i, ++iter) {
+      if (!REVERSE) {
+        ASSERT_EQ(*iter, i + 2);
+      } else {
+        ASSERT_EQ(*iter, (ARR_SIZE - 1) - i);
+      }
+    }
+
+    ASSERT_EQ(i, ARR_SIZE - 2);
+
+    block_store.erase(block_store.begin() + 1);
+
+    // FORWARD: block_store state should be {2,4,5}
+    // REVERSE: block_store state should be {2,3,5}
+
+    const int FORWARD_RESULTS[] = {2, 4, 5};
+    const int REVERSE_RESULTS[] = {2, 3, 5};
+
+    iter = block_store.begin();
+    for (i = 0; iter != block_store.end(); ++i, ++iter) {
+      if (!REVERSE) {
+        ASSERT_EQ(*iter, FORWARD_RESULTS[i]);
+      } else {
+        ASSERT_EQ(*iter, REVERSE_RESULTS[ARR_SIZE - 4 - i]); // reversed
+      }
+    }
+
+    ASSERT_EQ(i, ARR_SIZE - 3);
+
+    block_store.erase(block_store.begin() + 1);
+    // BOTH: block_store state should be {2,5}
+
+    iter = block_store.begin();
+    if (!REVERSE) {
+      ASSERT_EQ(*iter, 2);
+      ASSERT_EQ(*(iter + 1), 5);
+    } else {
+      ASSERT_EQ(*iter, 5);
+      ASSERT_EQ(*(iter + 1), 2);
+    }
+
+    block_store.erase(block_store.begin());
+    // FORWARD: block_store state should be {5}
+    // REVERSE: block_store state should be {2}
+    iter = block_store.begin();
+    if (!REVERSE) {
+      ASSERT_EQ(*iter, 5);
+    } else {
+      ASSERT_EQ(*iter, 2);
+    }
+
+    block_store.erase(block_store.begin());
+    // BOTH: block_store state should be {}
+
+    block_store.destroy(&block_store);
+  }
 };
 
 TEST_F(LlvmLibcBlockStoreTest, PopulateAndIterate4) {
@@ -90,13 +183,17 @@ TEST_F(LlvmLibcBlockStoreTest, PopulateAndIterateReverse10) {
   populate_and_iterate<4, 10, true>();
 }
 
-TEST_F(LlvmLibcBlockStoreTest, Back) { back_test<false>(); }
-
-// FIXME: Combing this test with the above test makes the AMDGPU backend
-// generate code which hangs. This should be fixed in the clang compiler.
-TEST_F(LlvmLibcBlockStoreTest, BackReverse) { back_test<true>(); }
+TEST_F(LlvmLibcBlockStoreTest, Back) {
+  back_test<false>();
+  back_test<true>();
+}
 
 TEST_F(LlvmLibcBlockStoreTest, Empty) {
   empty_test<false>();
   empty_test<true>();
 }
+
+TEST_F(LlvmLibcBlockStoreTest, Erase) {
+  erase_test<false>();
+  erase_test<true>();
+}
diff --git a/test/src/__support/endian_test.cpp b/test/src/__support/endian_internal_test.cpp
similarity index 91%
rename from test/src/__support/endian_test.cpp
rename to test/src/__support/endian_internal_test.cpp
index 4d95c03..eab0f37 100644
--- a/test/src/__support/endian_test.cpp
+++ b/test/src/__support/endian_internal_test.cpp
@@ -6,10 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 struct LlvmLibcEndian : testing::Test {
   template <typename T> void check(const T original, const T swapped) {
@@ -52,4 +53,4 @@ TEST_F(LlvmLibcEndian, uint64_t) {
   check(original, swapped);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/fixedvector_test.cpp b/test/src/__support/fixedvector_test.cpp
index 212e1ae..b73df04 100644
--- a/test/src/__support/fixedvector_test.cpp
+++ b/test/src/__support/fixedvector_test.cpp
@@ -96,3 +96,13 @@ TEST(LlvmLibcFixedVectorTest, ForwardIteration) {
     ASSERT_EQ(*it, arr[idx]);
   }
 }
+
+TEST(LlvmLibcFixedVectorTest, ConstForwardIteration) {
+  const LIBC_NAMESPACE::cpp::array<int, 4> arr{1, 2, 3, 4};
+  const LIBC_NAMESPACE::FixedVector<int, 5> vec(arr.begin(), arr.end());
+  ASSERT_EQ(vec.size(), arr.size());
+  for (auto it = vec.begin(); it != vec.end(); ++it) {
+    auto idx = it - vec.begin();
+    ASSERT_EQ(*it, arr[idx]);
+  }
+}
diff --git a/test/src/__support/freelist_heap_test.cpp b/test/src/__support/freelist_heap_test.cpp
index a35cb55..991c158 100644
--- a/test/src/__support/freelist_heap_test.cpp
+++ b/test/src/__support/freelist_heap_test.cpp
@@ -8,13 +8,17 @@
 
 #include "src/__support/CPP/span.h"
 #include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memcmp.h"
 #include "src/string/memcpy.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
-
+using LIBC_NAMESPACE::Block;
 using LIBC_NAMESPACE::freelist_heap;
+using LIBC_NAMESPACE::FreeListHeap;
+using LIBC_NAMESPACE::FreeListHeapBuffer;
+using LIBC_NAMESPACE::cpp::byte;
+using LIBC_NAMESPACE::cpp::span;
 
 // Similar to `LlvmLibcBlockTest` in block_test.cpp, we'd like to run the same
 // tests independently for different parameters. In this case, we'd like to test
@@ -27,18 +31,23 @@ using LIBC_NAMESPACE::freelist_heap;
 // made in tests leak and aren't free'd. This is fine for the purposes of this
 // test file.
 #define TEST_FOR_EACH_ALLOCATOR(TestCase, BufferSize)                          \
-  class LlvmLibcFreeListHeapTest##TestCase : public testing::Test {            \
+  class LlvmLibcFreeListHeapTest##TestCase                                     \
+      : public LIBC_NAMESPACE::testing::Test {                                 \
   public:                                                                      \
-    void RunTest(FreeListHeap<> &allocator, [[maybe_unused]] size_t N);        \
+    FreeListHeapBuffer<BufferSize> fake_global_buffer;                         \
+    void SetUp() override {                                                    \
+      freelist_heap =                                                          \
+          new (&fake_global_buffer) FreeListHeapBuffer<BufferSize>;            \
+    }                                                                          \
+    void RunTest(FreeListHeap &allocator, [[maybe_unused]] size_t N);          \
   };                                                                           \
   TEST_F(LlvmLibcFreeListHeapTest##TestCase, TestCase) {                       \
-    alignas(FreeListHeap<>::BlockType)                                         \
-        cpp::byte buf[BufferSize] = {cpp::byte(0)};                            \
-    FreeListHeap<> allocator(buf);                                             \
+    alignas(Block) byte buf[BufferSize] = {byte(0)};                           \
+    FreeListHeap allocator(buf);                                               \
     RunTest(allocator, BufferSize);                                            \
-    RunTest(*freelist_heap, freelist_heap->region_size());                     \
+    RunTest(*freelist_heap, freelist_heap->region().size());                   \
   }                                                                            \
-  void LlvmLibcFreeListHeapTest##TestCase::RunTest(FreeListHeap<> &allocator,  \
+  void LlvmLibcFreeListHeapTest##TestCase::RunTest(FreeListHeap &allocator,    \
                                                    size_t N)
 
 TEST_FOR_EACH_ALLOCATOR(CanAllocate, 2048) {
@@ -47,10 +56,6 @@ TEST_FOR_EACH_ALLOCATOR(CanAllocate, 2048) {
   void *ptr = allocator.allocate(ALLOC_SIZE);
 
   ASSERT_NE(ptr, static_cast<void *>(nullptr));
-  // In this case, the allocator should be returning us the start of the chunk.
-  EXPECT_EQ(ptr, static_cast<void *>(
-                     reinterpret_cast<cpp::byte *>(allocator.region_start()) +
-                     FreeListHeap<>::BlockType::BLOCK_OVERHEAD));
 }
 
 TEST_FOR_EACH_ALLOCATOR(AllocationsDontOverlap, 2048) {
@@ -90,11 +95,13 @@ TEST_FOR_EACH_ALLOCATOR(ReturnsNullWhenAllocationTooLarge, 2048) {
 // is used for other test cases and we don't explicitly free them.
 TEST(LlvmLibcFreeListHeap, ReturnsNullWhenFull) {
   constexpr size_t N = 2048;
-  alignas(FreeListHeap<>::BlockType) cpp::byte buf[N] = {cpp::byte(0)};
+  alignas(Block) byte buf[N] = {byte(0)};
 
-  FreeListHeap<> allocator(buf);
+  FreeListHeap allocator(buf);
 
-  EXPECT_NE(allocator.allocate(N - FreeListHeap<>::BlockType::BLOCK_OVERHEAD),
+  // Use aligned_allocate so we don't need to worry about ensuring the `buf`
+  // being aligned to max_align_t.
+  EXPECT_NE(allocator.aligned_allocate(1, N - 2 * Block::BLOCK_OVERHEAD),
             static_cast<void *>(nullptr));
   EXPECT_EQ(allocator.allocate(1), static_cast<void *>(nullptr));
 }
@@ -129,9 +136,9 @@ TEST_FOR_EACH_ALLOCATOR(ReallocHasSameContent, 2048) {
   constexpr size_t ALLOC_SIZE = sizeof(int);
   constexpr size_t kNewAllocSize = sizeof(int) * 2;
   // Data inside the allocated block.
-  cpp::byte data1[ALLOC_SIZE];
+  byte data1[ALLOC_SIZE];
   // Data inside the reallocated block.
-  cpp::byte data2[ALLOC_SIZE];
+  byte data2[ALLOC_SIZE];
 
   int *ptr1 = reinterpret_cast<int *>(allocator.allocate(ALLOC_SIZE));
   *ptr1 = 42;
@@ -183,10 +190,9 @@ TEST_FOR_EACH_ALLOCATOR(CanCalloc, 2048) {
   constexpr size_t ALLOC_SIZE = 128;
   constexpr size_t NUM = 4;
   constexpr int size = NUM * ALLOC_SIZE;
-  constexpr cpp::byte zero{0};
+  constexpr byte zero{0};
 
-  cpp::byte *ptr1 =
-      reinterpret_cast<cpp::byte *>(allocator.calloc(NUM, ALLOC_SIZE));
+  byte *ptr1 = reinterpret_cast<byte *>(allocator.calloc(NUM, ALLOC_SIZE));
 
   // calloc'd content is zero.
   for (int i = 0; i < size; i++) {
@@ -198,10 +204,9 @@ TEST_FOR_EACH_ALLOCATOR(CanCallocWeirdSize, 2048) {
   constexpr size_t ALLOC_SIZE = 143;
   constexpr size_t NUM = 3;
   constexpr int size = NUM * ALLOC_SIZE;
-  constexpr cpp::byte zero{0};
+  constexpr byte zero{0};
 
-  cpp::byte *ptr1 =
-      reinterpret_cast<cpp::byte *>(allocator.calloc(NUM, ALLOC_SIZE));
+  byte *ptr1 = reinterpret_cast<byte *>(allocator.calloc(NUM, ALLOC_SIZE));
 
   // calloc'd content is zero.
   for (int i = 0; i < size; i++) {
@@ -214,4 +219,72 @@ TEST_FOR_EACH_ALLOCATOR(CallocTooLarge, 2048) {
   EXPECT_EQ(allocator.calloc(1, ALLOC_SIZE), static_cast<void *>(nullptr));
 }
 
-} // namespace LIBC_NAMESPACE
+TEST_FOR_EACH_ALLOCATOR(AllocateZero, 2048) {
+  void *ptr = allocator.allocate(0);
+  ASSERT_EQ(ptr, static_cast<void *>(nullptr));
+}
+
+TEST_FOR_EACH_ALLOCATOR(AlignedAlloc, 2048) {
+  constexpr size_t ALIGNMENTS[] = {1, 2, 4, 8, 16, 32, 64, 128, 256};
+  constexpr size_t SIZE_SCALES[] = {1, 2, 3, 4, 5};
+
+  for (size_t alignment : ALIGNMENTS) {
+    for (size_t scale : SIZE_SCALES) {
+      size_t size = alignment * scale;
+      void *ptr = allocator.aligned_allocate(alignment, size);
+      EXPECT_NE(ptr, static_cast<void *>(nullptr));
+      EXPECT_EQ(reinterpret_cast<uintptr_t>(ptr) % alignment, size_t(0));
+      allocator.free(ptr);
+    }
+  }
+}
+
+// This test is not part of the TEST_FOR_EACH_ALLOCATOR since we want to
+// explicitly ensure that the buffer can still return aligned allocations even
+// if the underlying buffer is at most aligned to the Block alignment. This
+// is so we can check that we can still get aligned allocations even if the
+// underlying buffer is not aligned to the alignments we request.
+TEST(LlvmLibcFreeListHeap, AlignedAllocOnlyBlockAligned) {
+  constexpr size_t BUFFER_SIZE = 4096;
+  constexpr size_t BUFFER_ALIGNMENT = alignof(Block) * 2;
+  alignas(BUFFER_ALIGNMENT) byte buf[BUFFER_SIZE] = {byte(0)};
+
+  // Ensure the underlying buffer is at most aligned to the block type.
+  FreeListHeap allocator(span<byte>(buf).subspan(alignof(Block)));
+
+  constexpr size_t ALIGNMENTS[] = {1, 2, 4, 8, 16, 32, 64, 128, 256};
+  constexpr size_t SIZE_SCALES[] = {1, 2, 3, 4, 5};
+
+  for (size_t alignment : ALIGNMENTS) {
+    for (size_t scale : SIZE_SCALES) {
+      size_t size = alignment * scale;
+      void *ptr = allocator.aligned_allocate(alignment, size);
+      EXPECT_NE(ptr, static_cast<void *>(nullptr));
+      EXPECT_EQ(reinterpret_cast<uintptr_t>(ptr) % alignment, size_t(0));
+      allocator.free(ptr);
+    }
+  }
+}
+
+TEST_FOR_EACH_ALLOCATOR(InvalidAlignedAllocAlignment, 2048) {
+  // Must be a power of 2.
+  constexpr size_t ALIGNMENTS[] = {4, 8, 16, 32, 64, 128, 256};
+  for (size_t alignment : ALIGNMENTS) {
+    void *ptr = allocator.aligned_allocate(alignment - 1, alignment - 1);
+    EXPECT_EQ(ptr, static_cast<void *>(nullptr));
+  }
+
+  // Size must be a multiple of alignment
+  for (size_t alignment : ALIGNMENTS) {
+    void *ptr = allocator.aligned_allocate(alignment, alignment + 1);
+    EXPECT_EQ(ptr, static_cast<void *>(nullptr));
+  }
+
+  // Don't accept zero size.
+  void *ptr = allocator.aligned_allocate(1, 0);
+  EXPECT_EQ(ptr, static_cast<void *>(nullptr));
+
+  // Don't accept zero alignment.
+  ptr = allocator.aligned_allocate(0, 8);
+  EXPECT_EQ(ptr, static_cast<void *>(nullptr));
+}
diff --git a/test/src/__support/freelist_malloc_test.cpp b/test/src/__support/freelist_malloc_test.cpp
index 989e954..793e249 100644
--- a/test/src/__support/freelist_malloc_test.cpp
+++ b/test/src/__support/freelist_malloc_test.cpp
@@ -7,50 +7,48 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/freelist_heap.h"
+#include "src/stdlib/aligned_alloc.h"
 #include "src/stdlib/calloc.h"
 #include "src/stdlib/free.h"
 #include "src/stdlib/malloc.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Block;
 using LIBC_NAMESPACE::freelist_heap;
+using LIBC_NAMESPACE::FreeListHeap;
+using LIBC_NAMESPACE::FreeListHeapBuffer;
 
-TEST(LlvmLibcFreeListMalloc, MallocStats) {
+TEST(LlvmLibcFreeListMalloc, Malloc) {
   constexpr size_t kAllocSize = 256;
   constexpr size_t kCallocNum = 4;
   constexpr size_t kCallocSize = 64;
 
-  freelist_heap->reset_heap_stats(); // Do this because other tests might've
-                                     // called the same global allocator.
-
   void *ptr1 = LIBC_NAMESPACE::malloc(kAllocSize);
-
-  const auto &freelist_heap_stats = freelist_heap->heap_stats();
-
-  ASSERT_NE(ptr1, static_cast<void *>(nullptr));
-  EXPECT_EQ(freelist_heap_stats.bytes_allocated, kAllocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_allocated, kAllocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_freed, size_t(0));
+  auto *block = Block::from_usable_space(ptr1);
+  EXPECT_GE(block->inner_size(), kAllocSize);
 
   LIBC_NAMESPACE::free(ptr1);
-  EXPECT_EQ(freelist_heap_stats.bytes_allocated, size_t(0));
-  EXPECT_EQ(freelist_heap_stats.cumulative_allocated, kAllocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_freed, kAllocSize);
+  ASSERT_NE(block->next(), static_cast<Block *>(nullptr));
+  ASSERT_EQ(block->next()->next(), static_cast<Block *>(nullptr));
+  size_t heap_size = block->inner_size();
 
   void *ptr2 = LIBC_NAMESPACE::calloc(kCallocNum, kCallocSize);
-  ASSERT_NE(ptr2, static_cast<void *>(nullptr));
-  EXPECT_EQ(freelist_heap_stats.bytes_allocated, kCallocNum * kCallocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_allocated,
-            kAllocSize + kCallocNum * kCallocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_freed, kAllocSize);
+  ASSERT_EQ(ptr2, ptr1);
+  EXPECT_GE(block->inner_size(), kCallocNum * kCallocSize);
 
-  for (size_t i = 0; i < kCallocNum * kCallocSize; ++i) {
+  for (size_t i = 0; i < kCallocNum * kCallocSize; ++i)
     EXPECT_EQ(reinterpret_cast<uint8_t *>(ptr2)[i], uint8_t(0));
-  }
 
   LIBC_NAMESPACE::free(ptr2);
-  EXPECT_EQ(freelist_heap_stats.bytes_allocated, size_t(0));
-  EXPECT_EQ(freelist_heap_stats.cumulative_allocated,
-            kAllocSize + kCallocNum * kCallocSize);
-  EXPECT_EQ(freelist_heap_stats.cumulative_freed,
-            kAllocSize + kCallocNum * kCallocSize);
+  EXPECT_EQ(block->inner_size(), heap_size);
+
+  constexpr size_t ALIGN = kAllocSize;
+  void *ptr3 = LIBC_NAMESPACE::aligned_alloc(ALIGN, kAllocSize);
+  EXPECT_NE(ptr3, static_cast<void *>(nullptr));
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(ptr3) % ALIGN, size_t(0));
+  auto *aligned_block = reinterpret_cast<Block *>(ptr3);
+  EXPECT_GE(aligned_block->inner_size(), kAllocSize);
+
+  LIBC_NAMESPACE::free(ptr3);
+  EXPECT_EQ(block->inner_size(), heap_size);
 }
diff --git a/test/src/__support/freelist_test.cpp b/test/src/__support/freelist_test.cpp
index cae0ed4..bd5ecec 100644
--- a/test/src/__support/freelist_test.cpp
+++ b/test/src/__support/freelist_test.cpp
@@ -8,159 +8,46 @@
 
 #include <stddef.h>
 
-#include "src/__support/CPP/array.h"
-#include "src/__support/CPP/span.h"
 #include "src/__support/freelist.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Block;
 using LIBC_NAMESPACE::FreeList;
-using LIBC_NAMESPACE::cpp::array;
 using LIBC_NAMESPACE::cpp::byte;
-using LIBC_NAMESPACE::cpp::span;
-
-static constexpr size_t SIZE = 8;
-static constexpr array<size_t, SIZE> example_sizes = {64,   128,  256,  512,
-                                                      1024, 2048, 4096, 8192};
-
-TEST(LlvmLibcFreeList, EmptyListHasNoMembers) {
-  FreeList<SIZE> list(example_sizes);
-
-  auto item = list.find_chunk(4);
-  EXPECT_EQ(item.size(), static_cast<size_t>(0));
-  item = list.find_chunk(128);
-  EXPECT_EQ(item.size(), static_cast<size_t>(0));
-}
-
-TEST(LlvmLibcFreeList, CanRetrieveAddedMember) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t N = 512;
-
-  byte data[N] = {byte(0)};
-
-  bool ok = list.add_chunk(span<byte>(data, N));
-  EXPECT_TRUE(ok);
-
-  auto item = list.find_chunk(N);
-  EXPECT_EQ(item.size(), N);
-  EXPECT_EQ(item.data(), data);
-}
-
-TEST(LlvmLibcFreeList, CanRetrieveAddedMemberForSmallerSize) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t N = 512;
-
-  byte data[N] = {byte(0)};
-
-  ASSERT_TRUE(list.add_chunk(span<byte>(data, N)));
-  auto item = list.find_chunk(N / 2);
-  EXPECT_EQ(item.size(), N);
-  EXPECT_EQ(item.data(), data);
-}
-
-TEST(LlvmLibcFreeList, CanRemoveItem) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t N = 512;
-
-  byte data[N] = {byte(0)};
-
-  ASSERT_TRUE(list.add_chunk(span<byte>(data, N)));
-  EXPECT_TRUE(list.remove_chunk(span<byte>(data, N)));
-
-  auto item = list.find_chunk(N);
-  EXPECT_EQ(item.size(), static_cast<size_t>(0));
-}
-
-TEST(LlvmLibcFreeList, FindReturnsSmallestChunk) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t kN1 = 512;
-  constexpr size_t kN2 = 1024;
-
-  byte data1[kN1] = {byte(0)};
-  byte data2[kN2] = {byte(0)};
-
-  ASSERT_TRUE(list.add_chunk(span<byte>(data1, kN1)));
-  ASSERT_TRUE(list.add_chunk(span<byte>(data2, kN2)));
-
-  auto chunk = list.find_chunk(kN1 / 2);
-  EXPECT_EQ(chunk.size(), kN1);
-  EXPECT_EQ(chunk.data(), data1);
-
-  chunk = list.find_chunk(kN1);
-  EXPECT_EQ(chunk.size(), kN1);
-  EXPECT_EQ(chunk.data(), data1);
-
-  chunk = list.find_chunk(kN1 + 1);
-  EXPECT_EQ(chunk.size(), kN2);
-  EXPECT_EQ(chunk.data(), data2);
-}
-
-TEST(LlvmLibcFreeList, FindReturnsCorrectChunkInSameBucket) {
-  // If we have two values in the same bucket, ensure that the allocation will
-  // pick an appropriately sized one.
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t kN1 = 512;
-  constexpr size_t kN2 = 257;
-
-  byte data1[kN1] = {byte(0)};
-  byte data2[kN2] = {byte(0)};
-
-  // List should now be 257 -> 512 -> NULL
-  ASSERT_TRUE(list.add_chunk(span<byte>(data1, kN1)));
-  ASSERT_TRUE(list.add_chunk(span<byte>(data2, kN2)));
-
-  auto chunk = list.find_chunk(kN2 + 1);
-  EXPECT_EQ(chunk.size(), kN1);
-}
-
-TEST(LlvmLibcFreeList, FindCanMoveUpThroughBuckets) {
-  // Ensure that finding a chunk will move up through buckets if no appropriate
-  // chunks were found in a given bucket
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t kN1 = 257;
-  constexpr size_t kN2 = 513;
-
-  byte data1[kN1] = {byte(0)};
-  byte data2[kN2] = {byte(0)};
-
-  // List should now be:
-  // bkt[3] (257 bytes up to 512 bytes) -> 257 -> NULL
-  // bkt[4] (513 bytes up to 1024 bytes) -> 513 -> NULL
-  ASSERT_TRUE(list.add_chunk(span<byte>(data1, kN1)));
-  ASSERT_TRUE(list.add_chunk(span<byte>(data2, kN2)));
-
-  // Request a 300 byte chunk. This should return the 513 byte one
-  auto chunk = list.find_chunk(kN1 + 1);
-  EXPECT_EQ(chunk.size(), kN2);
-}
-
-TEST(LlvmLibcFreeList, RemoveUnknownChunkReturnsNotFound) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t N = 512;
-
-  byte data[N] = {byte(0)};
-  byte data2[N] = {byte(0)};
-
-  ASSERT_TRUE(list.add_chunk(span<byte>(data, N)));
-  EXPECT_FALSE(list.remove_chunk(span<byte>(data2, N)));
-}
-
-TEST(LlvmLibcFreeList, CanStoreMultipleChunksPerBucket) {
-  FreeList<SIZE> list(example_sizes);
-  constexpr size_t N = 512;
-
-  byte data1[N] = {byte(0)};
-  byte data2[N] = {byte(0)};
-
-  ASSERT_TRUE(list.add_chunk(span<byte>(data1, N)));
-  ASSERT_TRUE(list.add_chunk(span<byte>(data2, N)));
-
-  auto chunk1 = list.find_chunk(N);
-  ASSERT_TRUE(list.remove_chunk(chunk1));
-  auto chunk2 = list.find_chunk(N);
-  ASSERT_TRUE(list.remove_chunk(chunk2));
-
-  // Ordering of the chunks doesn't matter
-  EXPECT_TRUE(chunk1.data() != chunk2.data());
-  EXPECT_TRUE(chunk1.data() == data1 || chunk1.data() == data2);
-  EXPECT_TRUE(chunk2.data() == data1 || chunk2.data() == data2);
+using LIBC_NAMESPACE::cpp::optional;
+
+TEST(LlvmLibcFreeList, FreeList) {
+  byte mem[1024];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *block1 = *maybeBlock;
+
+  maybeBlock = block1->split(128);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *block2 = *maybeBlock;
+
+  maybeBlock = block2->split(128);
+  ASSERT_TRUE(maybeBlock.has_value());
+
+  FreeList list;
+  list.push(block1);
+  ASSERT_FALSE(list.empty());
+  EXPECT_EQ(list.front(), block1);
+
+  list.push(block2);
+  EXPECT_EQ(list.front(), block1);
+
+  list.pop();
+  ASSERT_FALSE(list.empty());
+  EXPECT_EQ(list.front(), block2);
+
+  list.pop();
+  ASSERT_TRUE(list.empty());
+
+  list.push(block1);
+  list.push(block2);
+  list.remove(reinterpret_cast<FreeList::Node *>(block2->usable_space()));
+  EXPECT_EQ(list.front(), block1);
+  list.pop();
+  ASSERT_TRUE(list.empty());
 }
diff --git a/test/src/__support/freestore_test.cpp b/test/src/__support/freestore_test.cpp
new file mode 100644
index 0000000..7960d32
--- /dev/null
+++ b/test/src/__support/freestore_test.cpp
@@ -0,0 +1,105 @@
+//===-- Unittests for a freestore -------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include <stddef.h>
+
+#include "src/__support/freestore.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Block;
+using LIBC_NAMESPACE::FreeList;
+using LIBC_NAMESPACE::FreeStore;
+using LIBC_NAMESPACE::FreeTrie;
+using LIBC_NAMESPACE::cpp::byte;
+using LIBC_NAMESPACE::cpp::optional;
+
+// Inserting or removing blocks too small to be tracked does nothing.
+TEST(LlvmLibcFreeStore, TooSmall) {
+  byte mem[1024];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *too_small = *maybeBlock;
+  maybeBlock = too_small->split(sizeof(size_t));
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *remainder = *maybeBlock;
+
+  FreeStore store;
+  store.set_range({0, 4096});
+  store.insert(too_small);
+  store.insert(remainder);
+
+  EXPECT_EQ(store.remove_best_fit(too_small->inner_size()), remainder);
+  store.remove(too_small);
+}
+
+TEST(LlvmLibcFreeStore, RemoveBestFit) {
+  byte mem[1024];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+
+  Block *smallest = *maybeBlock;
+  maybeBlock = smallest->split(sizeof(FreeList::Node) + sizeof(size_t));
+  ASSERT_TRUE(maybeBlock.has_value());
+
+  Block *largest_small = *maybeBlock;
+  maybeBlock = largest_small->split(sizeof(FreeTrie::Node) + sizeof(size_t) -
+                                    alignof(max_align_t));
+  ASSERT_TRUE(maybeBlock.has_value());
+  if (largest_small->inner_size() == smallest->inner_size())
+    largest_small = smallest;
+  ASSERT_GE(largest_small->inner_size(), smallest->inner_size());
+
+  Block *remainder = *maybeBlock;
+
+  FreeStore store;
+  store.set_range({0, 4096});
+  store.insert(smallest);
+  if (largest_small != smallest)
+    store.insert(largest_small);
+  store.insert(remainder);
+
+  // Find exact match for smallest.
+  ASSERT_EQ(store.remove_best_fit(smallest->inner_size()), smallest);
+  store.insert(smallest);
+
+  // Find exact match for largest.
+  ASSERT_EQ(store.remove_best_fit(largest_small->inner_size()), largest_small);
+  store.insert(largest_small);
+
+  // Search small list for best fit.
+  Block *next_smallest = largest_small == smallest ? remainder : largest_small;
+  ASSERT_EQ(store.remove_best_fit(smallest->inner_size() + 1), next_smallest);
+  store.insert(next_smallest);
+
+  // Continue search for best fit to large blocks.
+  EXPECT_EQ(store.remove_best_fit(largest_small->inner_size() + 1), remainder);
+}
+
+TEST(LlvmLibcFreeStore, Remove) {
+  byte mem[1024];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+
+  Block *small = *maybeBlock;
+  maybeBlock = small->split(sizeof(FreeList::Node) + sizeof(size_t));
+  ASSERT_TRUE(maybeBlock.has_value());
+
+  Block *remainder = *maybeBlock;
+
+  FreeStore store;
+  store.set_range({0, 4096});
+  store.insert(small);
+  store.insert(remainder);
+
+  store.remove(remainder);
+  ASSERT_EQ(store.remove_best_fit(remainder->inner_size()),
+            static_cast<Block *>(nullptr));
+  store.remove(small);
+  ASSERT_EQ(store.remove_best_fit(small->inner_size()),
+            static_cast<Block *>(nullptr));
+}
diff --git a/test/src/__support/freetrie_test.cpp b/test/src/__support/freetrie_test.cpp
new file mode 100644
index 0000000..5663a01
--- /dev/null
+++ b/test/src/__support/freetrie_test.cpp
@@ -0,0 +1,125 @@
+//===-- Unittests for a freetrie --------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include <stddef.h>
+
+#include "src/__support/freetrie.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Block;
+using LIBC_NAMESPACE::FreeTrie;
+using LIBC_NAMESPACE::cpp::byte;
+using LIBC_NAMESPACE::cpp::optional;
+
+TEST(LlvmLibcFreeTrie, FindBestFitRoot) {
+  FreeTrie trie({0, 4096});
+  EXPECT_EQ(trie.find_best_fit(123), static_cast<FreeTrie::Node *>(nullptr));
+
+  byte mem[1024];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *block = *maybeBlock;
+  trie.push(block);
+
+  FreeTrie::Node *root = trie.find_best_fit(0);
+  ASSERT_EQ(root->block(), block);
+  EXPECT_EQ(trie.find_best_fit(block->inner_size() - 1), root);
+  EXPECT_EQ(trie.find_best_fit(block->inner_size()), root);
+  EXPECT_EQ(trie.find_best_fit(block->inner_size() + 1),
+            static_cast<FreeTrie::Node *>(nullptr));
+  EXPECT_EQ(trie.find_best_fit(4095), static_cast<FreeTrie::Node *>(nullptr));
+}
+
+TEST(LlvmLibcFreeTrie, FindBestFitLower) {
+  byte mem[4096];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *lower = *maybeBlock;
+  maybeBlock = lower->split(512);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *root = *maybeBlock;
+
+  FreeTrie trie({0, 4096});
+  trie.push(root);
+  trie.push(lower);
+
+  EXPECT_EQ(trie.find_best_fit(0)->block(), lower);
+}
+
+TEST(LlvmLibcFreeTrie, FindBestFitUpper) {
+  byte mem[4096];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *root = *maybeBlock;
+  maybeBlock = root->split(512);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *upper = *maybeBlock;
+
+  FreeTrie trie({0, 4096});
+  trie.push(root);
+  trie.push(upper);
+
+  EXPECT_EQ(trie.find_best_fit(root->inner_size() + 1)->block(), upper);
+  // The upper subtrie should be skipped if it could not contain a better fit.
+  EXPECT_EQ(trie.find_best_fit(root->inner_size() - 1)->block(), root);
+}
+
+TEST(LlvmLibcFreeTrie, FindBestFitLowerAndUpper) {
+  byte mem[4096];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *root = *maybeBlock;
+  maybeBlock = root->split(1024);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *lower = *maybeBlock;
+  maybeBlock = lower->split(128);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *upper = *maybeBlock;
+
+  FreeTrie trie({0, 4096});
+  trie.push(root);
+  trie.push(lower);
+  trie.push(upper);
+
+  // The lower subtrie is examined first.
+  EXPECT_EQ(trie.find_best_fit(0)->block(), lower);
+  // The upper subtrie is examined if there are no fits found in the upper
+  // subtrie.
+  EXPECT_EQ(trie.find_best_fit(2048)->block(), upper);
+}
+
+TEST(LlvmLibcFreeTrie, Remove) {
+  byte mem[4096];
+  optional<Block *> maybeBlock = Block::init(mem);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *small1 = *maybeBlock;
+  maybeBlock = small1->split(512);
+  ASSERT_TRUE(maybeBlock.has_value());
+  Block *small2 = *maybeBlock;
+  maybeBlock = small2->split(512);
+  ASSERT_TRUE(maybeBlock.has_value());
+  ASSERT_EQ(small1->inner_size(), small2->inner_size());
+  Block *large = *maybeBlock;
+
+  // Removing the root empties the trie.
+  FreeTrie trie({0, 4096});
+  trie.push(large);
+  FreeTrie::Node *large_node = trie.find_best_fit(0);
+  ASSERT_EQ(large_node->block(), large);
+  trie.remove(large_node);
+  ASSERT_TRUE(trie.empty());
+
+  // Removing the head of a trie list preserves the trie structure.
+  trie.push(small1);
+  trie.push(small2);
+  trie.push(large);
+  trie.remove(trie.find_best_fit(small1->inner_size()));
+  EXPECT_EQ(trie.find_best_fit(large->inner_size())->block(), large);
+  trie.remove(trie.find_best_fit(small1->inner_size()));
+  EXPECT_EQ(trie.find_best_fit(large->inner_size())->block(), large);
+}
diff --git a/test/src/__support/integer_literals_test.cpp b/test/src/__support/integer_literals_test.cpp
index cbc906a..5c626f4 100644
--- a/test/src/__support/integer_literals_test.cpp
+++ b/test/src/__support/integer_literals_test.cpp
@@ -1,4 +1,3 @@
-
 //===-- Unittests for user defined integer literals -----------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
diff --git a/test/src/__support/math_extras_test.cpp b/test/src/__support/math_extras_test.cpp
index 0047888..08c0900 100644
--- a/test/src/__support/math_extras_test.cpp
+++ b/test/src/__support/math_extras_test.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/integer_literals.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/math_extras.h"
 #include "src/__support/uint128.h" // UInt<128>
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // TODO: add UInt<128> support.
 using UnsignedTypesNoBigInt = testing::TypeList<
@@ -102,7 +103,7 @@ TYPED_TEST(LlvmLibcBitTest, CountZeros, UnsignedTypesNoBigInt) {
 }
 
 using UnsignedTypes = testing::TypeList<
-#if defined(__SIZEOF_INT128__)
+#if defined(LIBC_TYPES_HAS_INT128)
     __uint128_t,
 #endif
     unsigned char, unsigned short, unsigned int, unsigned long,
@@ -158,4 +159,4 @@ TYPED_TEST(LlvmLibcBlockMathExtrasTest, sub_overflow, UnsignedTypes) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/memory_size_test.cpp b/test/src/__support/memory_size_test.cpp
index 1c8f1ce..bda1571 100644
--- a/test/src/__support/memory_size_test.cpp
+++ b/test/src/__support/memory_size_test.cpp
@@ -6,10 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include "src/__support/memory_size.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 static inline constexpr size_t SAFE_MEM_SIZE_TEST_LIMIT =
     static_cast<size_t>(cpp::numeric_limits<cpp::make_signed_t<size_t>>::max());
@@ -100,4 +101,4 @@ TEST(LlvmLibcBlockBitTest, OffsetTo) {
   }
 }
 } // namespace internal
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/str_to_double_test.cpp b/test/src/__support/str_to_double_test.cpp
index 3c6d039..03d2185 100644
--- a/test/src/__support/str_to_double_test.cpp
+++ b/test/src/__support/str_to_double_test.cpp
@@ -1,24 +1,33 @@
+//===-- Unittests for str_to_float<double> --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
 #include "str_to_fp_test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 using LlvmLibcStrToDblTest = LlvmLibcStrToFloatTest<double>;
 
 TEST_F(LlvmLibcStrToDblTest, ClingerFastPathFloat64Simple) {
-  clinger_fast_path_test(123, 0, 0xEC00000000000, 1029);
-  clinger_fast_path_test(1234567890123456, 1, 0x5ee2a2eb5a5c0, 1076);
-  clinger_fast_path_test(1234567890, -10, 0xf9add3739635f, 1019);
+  clinger_fast_path_test(123, 0, 0x1EC00000000000, 1029);
+  clinger_fast_path_test(1234567890123456, 1, 0x15ee2a2eb5a5c0, 1076);
+  clinger_fast_path_test(1234567890, -10, 0x1f9add3739635f, 1019);
 }
 
 TEST_F(LlvmLibcStrToDblTest, ClingerFastPathFloat64ExtendedExp) {
-  clinger_fast_path_test(1, 30, 0x93e5939a08cea, 1122);
-  clinger_fast_path_test(1, 37, 0xe17b84357691b, 1145);
+  clinger_fast_path_test(1, 30, 0x193e5939a08cea, 1122);
+  clinger_fast_path_test(1, 37, 0x1e17b84357691b, 1145);
   clinger_fast_path_fails_test(10, 37);
   clinger_fast_path_fails_test(1, 100);
 }
 
 TEST_F(LlvmLibcStrToDblTest, ClingerFastPathFloat64NegativeExp) {
-  clinger_fast_path_test(1, -10, 0xb7cdfd9d7bdbb, 989);
-  clinger_fast_path_test(1, -20, 0x79ca10c924223, 956);
+  clinger_fast_path_test(1, -10, 0x1b7cdfd9d7bdbb, 989);
+  clinger_fast_path_test(1, -20, 0x179ca10c924223, 956);
   clinger_fast_path_fails_test(1, -25);
 }
 
@@ -102,4 +111,4 @@ TEST(LlvmLibcStrToDblTest, SimpleDecimalConversionExtraTypes) {
   EXPECT_EQ(double_result.error, 0);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/str_to_float_comparison_test.cpp b/test/src/__support/str_to_float_comparison_test.cpp
index 7641c59..61bfc3c 100644
--- a/test/src/__support/str_to_float_comparison_test.cpp
+++ b/test/src/__support/str_to_float_comparison_test.cpp
@@ -8,7 +8,7 @@
 
 // #include "src/__support/str_float_conv_utils.h"
 
-#include <stdlib.h>
+#include <stdlib.h> // For string to float functions
 
 // #include "src/__support/FPUtil/FPBits.h"
 
diff --git a/test/src/__support/str_to_float_test.cpp b/test/src/__support/str_to_float_test.cpp
index f23d870..fa4c642 100644
--- a/test/src/__support/str_to_float_test.cpp
+++ b/test/src/__support/str_to_float_test.cpp
@@ -1,25 +1,34 @@
+//===-- Unittests for str_to_float<float> ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
 #include "str_to_fp_test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using LlvmLibcStrToFltTest = LlvmLibcStrToFloatTest<float>;
 
 TEST_F(LlvmLibcStrToFltTest, ClingerFastPathFloat32Simple) {
-  clinger_fast_path_test(123, 0, 0x760000, 133);
-  clinger_fast_path_test(1234567, 1, 0x3c6146, 150);
-  clinger_fast_path_test(12345, -5, 0x7cd35b, 123);
+  clinger_fast_path_test(123, 0, 0xf60000, 133);
+  clinger_fast_path_test(1234567, 1, 0xbc6146, 150);
+  clinger_fast_path_test(12345, -5, 0xfcd35b, 123);
 }
 
 TEST_F(LlvmLibcStrToFltTest, ClingerFastPathFloat32ExtendedExp) {
-  clinger_fast_path_test(1, 15, 0x635fa9, 176);
-  clinger_fast_path_test(1, 17, 0x31a2bc, 183);
+  clinger_fast_path_test(1, 15, 0xe35fa9, 176);
+  clinger_fast_path_test(1, 17, 0xb1a2bc, 183);
   clinger_fast_path_fails_test(10, 17);
   clinger_fast_path_fails_test(1, 50);
 }
 
 TEST_F(LlvmLibcStrToFltTest, ClingerFastPathFloat32NegativeExp) {
-  clinger_fast_path_test(1, -5, 0x27c5ac, 110);
-  clinger_fast_path_test(1, -10, 0x5be6ff, 93);
+  clinger_fast_path_test(1, -5, 0xa7c5ac, 110);
+  clinger_fast_path_test(1, -10, 0xdbe6ff, 93);
   clinger_fast_path_fails_test(1, -15);
 }
 
@@ -56,4 +65,4 @@ TEST(LlvmLibcStrToFltTest, SimpleDecimalConversionExtraTypes) {
   EXPECT_EQ(float_result.error, 0);
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/str_to_fp_test.h b/test/src/__support/str_to_fp_test.h
index 8d6181c..db4e62a 100644
--- a/test/src/__support/str_to_fp_test.h
+++ b/test/src/__support/str_to_fp_test.h
@@ -7,13 +7,14 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_float.h"
 #include "src/__support/uint128.h"
 #include "src/errno/libc_errno.h"
 
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename T> struct LlvmLibcStrToFloatTest : public testing::Test {
   using StorageType = typename fputil::FPBits<T>::StorageType;
@@ -79,4 +80,4 @@ template <typename T> struct LlvmLibcStrToFloatTest : public testing::Test {
   }
 };
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/str_to_long_double_test.cpp b/test/src/__support/str_to_long_double_test.cpp
index c97fe27..fa7d600 100644
--- a/test/src/__support/str_to_long_double_test.cpp
+++ b/test/src/__support/str_to_long_double_test.cpp
@@ -1,8 +1,17 @@
+//===-- Unittests for str_to_float<long double> ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
 #include "str_to_fp_test.h"
 
 #include "src/__support/integer_literals.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using LlvmLibcStrToLongDblTest = LlvmLibcStrToFloatTest<long double>;
 using LIBC_NAMESPACE::operator""_u128;
@@ -21,12 +30,23 @@ TEST_F(LlvmLibcStrToLongDblTest, EiselLemireFloat80Simple) {
 }
 
 TEST_F(LlvmLibcStrToLongDblTest, EiselLemireFloat80LongerMantissa) {
+#if __SIZEOF_LONG_DOUBLE__ == 16
   eisel_lemire_test(0x12345678'12345678'12345678'12345678_u128, 0,
                     0x91a2b3c091a2b3c1, 16507);
   eisel_lemire_test(0x12345678'12345678'12345678'12345678_u128, 300,
                     0xd97757de56adb65c, 17503);
   eisel_lemire_test(0x12345678'12345678'12345678'12345678_u128, -300,
                     0xc30feb9a7618457d, 15510);
+#elif __SIZEOF_LONG_DOUBLE__ == 12
+  eisel_lemire_test(0x12345678'12345678'12345678_u96, 0, 0x91a2b3c091a2b3c1,
+                    16475);
+  eisel_lemire_test(0x12345678'12345678'12345678_u96, 300, 0xd97757de56adb65c,
+                    17471);
+  eisel_lemire_test(0x12345678'12345678'12345678_u96, -300, 0xc30feb9a7618457d,
+                    15478);
+#else
+#error "unhandled long double type"
+#endif
 }
 
 // These tests check numbers at the edge of the DETAILED_POWERS_OF_TEN table.
@@ -54,6 +74,12 @@ TEST_F(LlvmLibcStrToLongDblTest, EiselLemireFloat80Fallback) {
   ASSERT_FALSE(internal::eisel_lemire<long double>({1, -1000}).has_value());
 }
 
+TEST_F(LlvmLibcStrToLongDblTest, ClingerFastPathFloat80Simple) {
+  clinger_fast_path_test(123, 0, 0xf600000000000000, 16389);
+  clinger_fast_path_test(1234567, 1, 0xbc61460000000000, 16406);
+  clinger_fast_path_test(12345, -5, 0xfcd35a858793dd98, 16379);
+}
+
 #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
 
 TEST_F(LlvmLibcStrToLongDblTest, EiselLemireFloat128Simple) {
@@ -77,8 +103,17 @@ TEST_F(LlvmLibcStrToLongDblTest, EiselLemireFloat128Fallback) {
                    .has_value());
 }
 
+TEST_F(LlvmLibcStrToLongDblTest, ClingerFastPathFloat128Simple) {
+  clinger_fast_path_test(123, 0, 0x1ec00'00000000'00000000'00000000_u128,
+                         16389);
+  clinger_fast_path_test(1234567, 1, 0x178c2'8c000000'00000000'00000000_u128,
+                         16406);
+  clinger_fast_path_test(12345, -5, 0x1f9a6'b50b0f27'bb2fec56'd5cfaace_u128,
+                         16379);
+}
+
 #else
 #error "Unknown long double type"
 #endif
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/__support/time/linux/timeout_test.cpp b/test/src/__support/time/linux/timeout_test.cpp
index 886d438..37b3763 100644
--- a/test/src/__support/time/linux/timeout_test.cpp
+++ b/test/src/__support/time/linux/timeout_test.cpp
@@ -45,7 +45,7 @@ TEST(LlvmLibcSupportLinuxTimeoutTest, NoChangeIfClockIsMonotonic) {
   ensure_monotonicity(*result);
   ASSERT_FALSE(result->is_realtime());
   ASSERT_EQ(result->get_timespec().tv_sec, static_cast<time_t>(10000));
-  ASSERT_EQ(result->get_timespec().tv_nsec, static_cast<time_t>(0));
+  ASSERT_EQ(result->get_timespec().tv_nsec, static_cast<long int>(0));
 }
 TEST(LlvmLibcSupportLinuxTimeoutTest, ValidAfterConversion) {
   timespec ts;
diff --git a/test/src/compiler/stack_chk_guard_test.cpp b/test/src/compiler/stack_chk_guard_test.cpp
index 6b71e15..4ec8398 100644
--- a/test/src/compiler/stack_chk_guard_test.cpp
+++ b/test/src/compiler/stack_chk_guard_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "include/llvm-libc-macros/signal-macros.h"
+#include "hdr/signal_macros.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/compiler/__stack_chk_fail.h"
 #include "src/string/memset.h"
@@ -18,7 +18,7 @@ TEST(LlvmLibcStackChkFail, Death) {
 
 // Disable the test when asan is enabled so that it doesn't immediately fail
 // after the memset, but before the stack canary is re-checked.
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
+#ifndef LIBC_HAS_ADDRESS_SANITIZER
 TEST(LlvmLibcStackChkFail, Smash) {
   EXPECT_DEATH(
       [] {
@@ -27,4 +27,4 @@ TEST(LlvmLibcStackChkFail, Smash) {
       },
       WITH_SIGNAL(SIGABRT));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/complex/CImagTest.h b/test/src/complex/CImagTest.h
new file mode 100644
index 0000000..6d2f935
--- /dev/null
+++ b/test/src/complex/CImagTest.h
@@ -0,0 +1,74 @@
+//===-- Utility class to test different flavors of cimag --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_COMPLEX_CIMAGTEST_H
+#define LLVM_LIBC_TEST_SRC_COMPLEX_CIMAGTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "hdr/math_macros.h"
+
+template <typename CFPT, typename FPT>
+class CImagTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(FPT)
+
+public:
+  typedef FPT (*CImagFunc)(CFPT);
+
+  void testSpecialNumbers(CImagFunc func) {
+    EXPECT_FP_EQ(func(CFPT(67.123 + aNaN * 1.0i)), aNaN);
+    EXPECT_FP_EQ(func(CFPT(78.319 + neg_aNaN * 1.0i)), neg_aNaN);
+    EXPECT_FP_EQ(func(CFPT(7813.131 + sNaN * 1.0i)), sNaN);
+    EXPECT_FP_EQ(func(CFPT(7824.152 + neg_sNaN * 1.0i)), neg_sNaN);
+    EXPECT_FP_EQ(func(CFPT(9024.2442 + inf * 1.0i)), inf);
+    EXPECT_FP_EQ(func(CFPT(8923.124 + neg_inf * 1.0i)), neg_inf);
+    EXPECT_FP_EQ(func(CFPT(782.124 + min_normal * 1.0i)), min_normal);
+    EXPECT_FP_EQ(func(CFPT(2141.2352 + max_normal * 1.0i)), max_normal);
+    EXPECT_FP_EQ(func(CFPT(341.134 + neg_max_normal * 1.0i)), neg_max_normal);
+    EXPECT_FP_EQ(func(CFPT(781.142 + min_denormal * 1.0i)), min_denormal);
+    EXPECT_FP_EQ(func(CFPT(781.134 + neg_min_denormal * 1.0i)),
+                 neg_min_denormal);
+    EXPECT_FP_EQ(func(CFPT(1241.112 + max_denormal * 1.0i)), max_denormal);
+    EXPECT_FP_EQ(func(CFPT(121.121 + zero * 1.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(neg_zero + zero * 1.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(neg_zero + neg_zero * 1.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(zero + neg_zero * 1.0i)), neg_zero);
+  }
+
+  void testRoundedNumbers(CImagFunc func) {
+    EXPECT_FP_EQ(func((CFPT)(4523.1413 + 12413.1414i)), (FPT)(12413.1414));
+    EXPECT_FP_EQ(func((CFPT)(-4523.1413 + 12413.1414i)), (FPT)(12413.1414));
+    EXPECT_FP_EQ(func((CFPT)(4523.1413 - 12413.1414i)), (FPT)(-12413.1414));
+    EXPECT_FP_EQ(func((CFPT)(-4523.1413 - 12413.1414i)), (FPT)(-12413.1414));
+
+    EXPECT_FP_EQ(func((CFPT)(3210.5678 + 9876.5432i)), (FPT)(9876.5432));
+    EXPECT_FP_EQ(func((CFPT)(-3210.5678 + 9876.5432i)), (FPT)(9876.5432));
+    EXPECT_FP_EQ(func((CFPT)(3210.5678 - 9876.5432i)), (FPT)(-9876.5432));
+    EXPECT_FP_EQ(func((CFPT)(-3210.5678 - 9876.5432i)), (FPT)(-9876.5432));
+
+    EXPECT_FP_EQ(func((CFPT)(1234.4321 + 4321.1234i)), (FPT)(4321.1234));
+    EXPECT_FP_EQ(func((CFPT)(-1234.4321 + 4321.1234i)), (FPT)(4321.1234));
+    EXPECT_FP_EQ(func((CFPT)(1234.4321 - 4321.1234i)), (FPT)(-4321.1234));
+    EXPECT_FP_EQ(func((CFPT)(-1234.4321 - 4321.1234i)), (FPT)(-4321.1234));
+
+    EXPECT_FP_EQ(func((CFPT)(6789.1234 + 8765.6789i)), (FPT)(8765.6789));
+    EXPECT_FP_EQ(func((CFPT)(-6789.1234 + 8765.6789i)), (FPT)(8765.6789));
+    EXPECT_FP_EQ(func((CFPT)(6789.1234 - 8765.6789i)), (FPT)(-8765.6789));
+    EXPECT_FP_EQ(func((CFPT)(-6789.1234 - 8765.6789i)), (FPT)(-8765.6789));
+  }
+};
+
+#define LIST_CIMAG_TESTS(U, T, func)                                           \
+  using LlvmLibcCImagTest = CImagTest<U, T>;                                   \
+  TEST_F(LlvmLibcCImagTest, SpecialNumbers) { testSpecialNumbers(&func); }     \
+  TEST_F(LlvmLibcCImagTest, RoundedNumbers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_COMPLEX_CIMAGTEST_H
diff --git a/test/src/complex/CRealTest.h b/test/src/complex/CRealTest.h
new file mode 100644
index 0000000..a25555b
--- /dev/null
+++ b/test/src/complex/CRealTest.h
@@ -0,0 +1,72 @@
+//===-- Utility class to test different flavors of creal --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_COMPLEX_CREALTEST_H
+#define LLVM_LIBC_TEST_SRC_COMPLEX_CREALTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "hdr/math_macros.h"
+
+template <typename CFPT, typename FPT>
+class CRealTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(FPT)
+
+public:
+  typedef FPT (*CRealFunc)(CFPT);
+
+  void testSpecialNumbers(CRealFunc func) {
+    EXPECT_FP_EQ(func(CFPT(aNaN + 67.123i)), aNaN);
+    EXPECT_FP_EQ(func(CFPT(neg_aNaN + 78.319i)), neg_aNaN);
+    EXPECT_FP_EQ(func(CFPT(sNaN + 7813.131i)), sNaN);
+    EXPECT_FP_EQ(func(CFPT(neg_sNaN + 7824.152i)), neg_sNaN);
+    EXPECT_FP_EQ(func(CFPT(inf + 9024.2442i)), inf);
+    EXPECT_FP_EQ(func(CFPT(neg_inf + 8923.124i)), neg_inf);
+    EXPECT_FP_EQ(func(CFPT(min_normal + 782.124i)), min_normal);
+    EXPECT_FP_EQ(func(CFPT(max_normal + 2141.2352i)), max_normal);
+    EXPECT_FP_EQ(func(CFPT(neg_max_normal + 341.134i)), neg_max_normal);
+    EXPECT_FP_EQ(func(CFPT(min_denormal + 781.142i)), min_denormal);
+    EXPECT_FP_EQ(func(CFPT(neg_min_denormal + 781.134i)), neg_min_denormal);
+    EXPECT_FP_EQ(func(CFPT(max_denormal + 1241.112i)), max_denormal);
+    EXPECT_FP_EQ(func(CFPT(zero + 121.121i)), zero);
+    EXPECT_FP_EQ(func(CFPT(neg_zero + neg_zero * 1.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(neg_zero + zero * 1.0i)), zero);
+  }
+
+  void testRoundedNumbers(CRealFunc func) {
+    EXPECT_FP_EQ(func((CFPT)(4523.1413 + 12413.1414i)), (FPT)(4523.1413));
+    EXPECT_FP_EQ(func((CFPT)(-4523.1413 + 12413.1414i)), (FPT)(-4523.1413));
+    EXPECT_FP_EQ(func((CFPT)(4523.1413 - 12413.1414i)), (FPT)(4523.1413));
+    EXPECT_FP_EQ(func((CFPT)(-4523.1413 - 12413.1414i)), (FPT)(-4523.1413));
+
+    EXPECT_FP_EQ(func((CFPT)(3210.5678 + 9876.5432i)), (FPT)(3210.5678));
+    EXPECT_FP_EQ(func((CFPT)(-3210.5678 + 9876.5432i)), (FPT)(-3210.5678));
+    EXPECT_FP_EQ(func((CFPT)(3210.5678 - 9876.5432i)), (FPT)(3210.5678));
+    EXPECT_FP_EQ(func((CFPT)(-3210.5678 - 9876.5432i)), (FPT)(-3210.5678));
+
+    EXPECT_FP_EQ(func((CFPT)(1234.4321 + 4321.1234i)), (FPT)(1234.4321));
+    EXPECT_FP_EQ(func((CFPT)(-1234.4321 + 4321.1234i)), (FPT)(-1234.4321));
+    EXPECT_FP_EQ(func((CFPT)(1234.4321 - 4321.1234i)), (FPT)(1234.4321));
+    EXPECT_FP_EQ(func((CFPT)(-1234.4321 - 4321.1234i)), (FPT)(-1234.4321));
+
+    EXPECT_FP_EQ(func((CFPT)(6789.1234 + 8765.6789i)), (FPT)(6789.1234));
+    EXPECT_FP_EQ(func((CFPT)(-6789.1234 + 8765.6789i)), (FPT)(-6789.1234));
+    EXPECT_FP_EQ(func((CFPT)(6789.1234 - 8765.6789i)), (FPT)(6789.1234));
+    EXPECT_FP_EQ(func((CFPT)(-6789.1234 - 8765.6789i)), (FPT)(-6789.1234));
+  }
+};
+
+#define LIST_CREAL_TESTS(U, T, func)                                           \
+  using LlvmLibcCRealTest = CRealTest<U, T>;                                   \
+  TEST_F(LlvmLibcCRealTest, SpecialNumbers) { testSpecialNumbers(&func); }     \
+  TEST_F(LlvmLibcCRealTest, RoundedNumbers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_COMPLEX_CREALTEST_H
diff --git a/test/src/complex/cimag_test.cpp b/test/src/complex/cimag_test.cpp
new file mode 100644
index 0000000..706f544
--- /dev/null
+++ b/test/src/complex/cimag_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cimag -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CImagTest.h"
+
+#include "src/complex/cimag.h"
+
+LIST_CIMAG_TESTS(_Complex double, double, LIBC_NAMESPACE::cimag)
diff --git a/test/src/complex/cimagf128_test.cpp b/test/src/complex/cimagf128_test.cpp
new file mode 100644
index 0000000..50ddc0a
--- /dev/null
+++ b/test/src/complex/cimagf128_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for cimagf128 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CImagTest.h"
+
+#include "src/complex/cimagf128.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+LIST_CIMAG_TESTS(cfloat128, float128, LIBC_NAMESPACE::cimagf128)
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/test/src/complex/cimagf16_test.cpp b/test/src/complex/cimagf16_test.cpp
new file mode 100644
index 0000000..65a6978
--- /dev/null
+++ b/test/src/complex/cimagf16_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for cimagf16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CImagTest.h"
+
+#include "src/complex/cimagf16.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+LIST_CIMAG_TESTS(cfloat16, float16, LIBC_NAMESPACE::cimagf16)
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/test/src/complex/cimagf_test.cpp b/test/src/complex/cimagf_test.cpp
new file mode 100644
index 0000000..abc9225
--- /dev/null
+++ b/test/src/complex/cimagf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cimagf ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CImagTest.h"
+
+#include "src/complex/cimagf.h"
+
+LIST_CIMAG_TESTS(_Complex float, float, LIBC_NAMESPACE::cimagf)
diff --git a/test/src/complex/cimagl_test.cpp b/test/src/complex/cimagl_test.cpp
new file mode 100644
index 0000000..156e4c6
--- /dev/null
+++ b/test/src/complex/cimagl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cimagl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CImagTest.h"
+
+#include "src/complex/cimagl.h"
+
+LIST_CIMAG_TESTS(_Complex long double, long double, LIBC_NAMESPACE::cimagl)
diff --git a/test/src/complex/creal_test.cpp b/test/src/complex/creal_test.cpp
new file mode 100644
index 0000000..14dc550
--- /dev/null
+++ b/test/src/complex/creal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for creal -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CRealTest.h"
+
+#include "src/complex/creal.h"
+
+LIST_CREAL_TESTS(_Complex double, double, LIBC_NAMESPACE::creal)
diff --git a/test/src/complex/crealf128_test.cpp b/test/src/complex/crealf128_test.cpp
new file mode 100644
index 0000000..7626eee
--- /dev/null
+++ b/test/src/complex/crealf128_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for crealf128 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CRealTest.h"
+
+#include "src/complex/crealf128.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT128)
+
+LIST_CREAL_TESTS(cfloat128, float128, LIBC_NAMESPACE::crealf128)
+
+#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/test/src/complex/crealf16_test.cpp b/test/src/complex/crealf16_test.cpp
new file mode 100644
index 0000000..97346aa
--- /dev/null
+++ b/test/src/complex/crealf16_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for crealf16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CRealTest.h"
+
+#include "src/complex/crealf16.h"
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+
+LIST_CREAL_TESTS(cfloat16, float16, LIBC_NAMESPACE::crealf16)
+
+#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/test/src/complex/crealf_test.cpp b/test/src/complex/crealf_test.cpp
new file mode 100644
index 0000000..aa54f54
--- /dev/null
+++ b/test/src/complex/crealf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for crealf ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CRealTest.h"
+
+#include "src/complex/crealf.h"
+
+LIST_CREAL_TESTS(_Complex float, float, LIBC_NAMESPACE::crealf)
diff --git a/test/src/complex/creall_test.cpp b/test/src/complex/creall_test.cpp
new file mode 100644
index 0000000..6985dbc
--- /dev/null
+++ b/test/src/complex/creall_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for creall ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CRealTest.h"
+
+#include "src/complex/creall.h"
+
+LIST_CREAL_TESTS(_Complex long double, long double, LIBC_NAMESPACE::creall)
diff --git a/test/src/fcntl/fcntl_test.cpp b/test/src/fcntl/fcntl_test.cpp
index fc909ac..1a21afe 100644
--- a/test/src/fcntl/fcntl_test.cpp
+++ b/test/src/fcntl/fcntl_test.cpp
@@ -7,15 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "hdr/fcntl_macros.h"
+#include "hdr/stdio_macros.h"
 #include "hdr/types/struct_flock.h"
 #include "src/errno/libc_errno.h"
 #include "src/fcntl/fcntl.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
+#include "src/unistd/getpid.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
 #include <sys/stat.h> // For S_IRWXU
 
 TEST(LlvmLibcFcntlTest, FcntlDupfd) {
@@ -163,3 +164,22 @@ TEST(LlvmLibcFcntlTest, UseAfterClose) {
   ASSERT_EQ(-1, LIBC_NAMESPACE::fcntl(fd, F_GETFL));
   ASSERT_ERRNO_EQ(EBADF);
 }
+
+TEST(LlvmLibcFcntlTest, SetGetOwnerTest) {
+  LIBC_NAMESPACE::libc_errno = 0;
+  using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+  pid_t pid = LIBC_NAMESPACE::getpid();
+  ASSERT_GT(pid, -1);
+  constexpr const char *TEST_FILE_NAME = "testdata/fcntl_set_get_owner.test";
+  auto TEST_FILE = libc_make_test_file_path(TEST_FILE_NAME);
+  int fd = LIBC_NAMESPACE::open(TEST_FILE, O_CREAT | O_TRUNC | O_RDWR, S_IRWXU);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(fd, 0);
+  int ret = LIBC_NAMESPACE::fcntl(fd, F_SETOWN, pid);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(ret, -1);
+  int ret2 = LIBC_NAMESPACE::fcntl(fd, F_GETOWN);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_EQ(ret2, pid);
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
+}
diff --git a/test/src/fcntl/openat_test.cpp b/test/src/fcntl/openat_test.cpp
index 9dafd12..547359e 100644
--- a/test/src/fcntl/openat_test.cpp
+++ b/test/src/fcntl/openat_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 TEST(LlvmLibcUniStd, OpenAndReadTest) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
diff --git a/test/src/fenv/getenv_and_setenv_test.cpp b/test/src/fenv/getenv_and_setenv_test.cpp
index 8fc2787..fa4ef66 100644
--- a/test/src/fenv/getenv_and_setenv_test.cpp
+++ b/test/src/fenv/getenv_and_setenv_test.cpp
@@ -13,6 +13,7 @@
 #include "src/fenv/fesetround.h"
 
 #include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/macros/properties/os.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/Test.h"
 
@@ -20,6 +21,7 @@
 
 using LlvmLibcFEnvTest = LIBC_NAMESPACE::testing::FEnvSafeTest;
 
+#ifndef LIBC_TARGET_OS_IS_WINDOWS
 TEST_F(LlvmLibcFEnvTest, GetEnvAndSetEnv) {
   // We will disable all exceptions to prevent invocation of the exception
   // handler.
@@ -71,8 +73,9 @@ TEST_F(LlvmLibcFEnvTest, Set_FE_DFL_ENV) {
   int rm = LIBC_NAMESPACE::fegetround();
   EXPECT_EQ(rm, FE_TONEAREST);
 }
+#endif
 
-#ifdef _WIN32
+#ifdef LIBC_TARGET_OS_IS_WINDOWS
 TEST_F(LlvmLibcFEnvTest, Windows_Set_Get_Test) {
   // If a valid fenv_t is written, then reading it back out should be identical.
   fenv_t setEnv = {0x7e00053e, 0x0f00000f};
diff --git a/test/src/locale/locale_test.cpp b/test/src/locale/locale_test.cpp
new file mode 100644
index 0000000..bc48bb8
--- /dev/null
+++ b/test/src/locale/locale_test.cpp
@@ -0,0 +1,27 @@
+//===-- Unittests for locale ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/locale/freelocale.h"
+#include "src/locale/newlocale.h"
+#include "src/locale/uselocale.h"
+
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-macros/locale-macros.h"
+
+TEST(LlvmLibcLocale, DefaultLocale) {
+  locale_t new_locale = LIBC_NAMESPACE::newlocale(LC_ALL, "C", nullptr);
+  EXPECT_NE(new_locale, static_cast<locale_t>(nullptr));
+
+  locale_t old_locale = LIBC_NAMESPACE::uselocale(new_locale);
+  EXPECT_NE(old_locale, static_cast<locale_t>(nullptr));
+
+  LIBC_NAMESPACE::freelocale(new_locale);
+
+  LIBC_NAMESPACE::uselocale(old_locale);
+}
diff --git a/test/src/locale/localeconv_test.cpp b/test/src/locale/localeconv_test.cpp
new file mode 100644
index 0000000..7926427
--- /dev/null
+++ b/test/src/locale/localeconv_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for localeconv ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "include/llvm-libc-macros/locale-macros.h"
+#include "src/locale/localeconv.h"
+
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcLocale, DefaultLocale) {
+  struct lconv *conv = LIBC_NAMESPACE::localeconv();
+  EXPECT_STREQ(conv->decimal_point, ".");
+}
diff --git a/test/src/math/AddTest.h b/test/src/math/AddTest.h
new file mode 100644
index 0000000..df0ef66
--- /dev/null
+++ b/test/src/math/AddTest.h
@@ -0,0 +1,74 @@
+//===-- Utility class to test different flavors of float add ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+template <typename OutType, typename InType>
+class AddTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  static constexpr InStorageType IN_MAX_NORMAL_U =
+      InFPBits::max_normal().uintval();
+  static constexpr InStorageType IN_MIN_NORMAL_U =
+      InFPBits::min_normal().uintval();
+  static constexpr InStorageType IN_MAX_SUBNORMAL_U =
+      InFPBits::max_subnormal().uintval();
+  static constexpr InStorageType IN_MIN_SUBNORMAL_U =
+      InFPBits::min_subnormal().uintval();
+
+public:
+  typedef OutType (*AddFunc)(InType, InType);
+
+  void test_subnormal_range(AddFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP =
+        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_SUBNORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Add, input, func(x, y),
+                                     0.5);
+    }
+  }
+
+  void test_normal_range(AddFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_NORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Add, input, func(x, y),
+                                     0.5);
+    }
+  }
+};
+
+#define LIST_ADD_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcAddTest = AddTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcAddTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcAddTest, NormalRange) { test_normal_range(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
diff --git a/test/src/math/CopySignTest.h b/test/src/math/CopySignTest.h
index c66f914..8db4f69 100644
--- a/test/src/math/CopySignTest.h
+++ b/test/src/math/CopySignTest.h
@@ -39,7 +39,7 @@ public:
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
 
       double res1 = func(x, -x);
diff --git a/test/src/math/DivTest.h b/test/src/math/DivTest.h
new file mode 100644
index 0000000..c14d16f
--- /dev/null
+++ b/test/src/math/DivTest.h
@@ -0,0 +1,74 @@
+//===-- Utility class to test different flavors of float div ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_DIVTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_DIVTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+template <typename OutType, typename InType>
+class DivTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  static constexpr InStorageType IN_MAX_NORMAL_U =
+      InFPBits::max_normal().uintval();
+  static constexpr InStorageType IN_MIN_NORMAL_U =
+      InFPBits::min_normal().uintval();
+  static constexpr InStorageType IN_MAX_SUBNORMAL_U =
+      InFPBits::max_subnormal().uintval();
+  static constexpr InStorageType IN_MIN_SUBNORMAL_U =
+      InFPBits::min_subnormal().uintval();
+
+public:
+  using DivFunc = OutType (*)(InType, InType);
+
+  void test_subnormal_range(DivFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP =
+        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_SUBNORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Div, input, func(x, y),
+                                     0.5);
+    }
+  }
+
+  void test_normal_range(DivFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_NORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Div, input, func(x, y),
+                                     0.5);
+    }
+  }
+};
+
+#define LIST_DIV_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcDivTest = DivTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcDivTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcDivTest, NormalRange) { test_normal_range(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_DIVTEST_H
diff --git a/test/src/math/FAbsTest.h b/test/src/math/FAbsTest.h
index 92b589b..7b4ea93 100644
--- a/test/src/math/FAbsTest.h
+++ b/test/src/math/FAbsTest.h
@@ -41,7 +41,7 @@ public:
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
       ASSERT_MPFR_MATCH(mpfr::Operation::Abs, x, func(x), 0.0);
     }
diff --git a/test/src/math/FDimTest.h b/test/src/math/FDimTest.h
index fefcefe..03ff26a 100644
--- a/test/src/math/FDimTest.h
+++ b/test/src/math/FDimTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class FDimTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
@@ -67,9 +69,9 @@ public:
     for (StorageType i = 0, v = 0, w = STORAGE_MAX; i <= COUNT;
          ++i, v += STEP, w -= STEP) {
       T x = FPBits(v).get_val(), y = FPBits(w).get_val();
-      if (isnan(x) || isinf(x))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
-      if (isnan(y) || isinf(y))
+      if (FPBits(w).is_nan() || FPBits(w).is_inf())
         continue;
 
       if (x > y) {
diff --git a/test/src/math/FMaxTest.h b/test/src/math/FMaxTest.h
index 405642c..43904a4 100644
--- a/test/src/math/FMaxTest.h
+++ b/test/src/math/FMaxTest.h
@@ -65,9 +65,9 @@ public:
     for (StorageType i = 0, v = 0, w = STORAGE_MAX; i <= COUNT;
          ++i, v += STEP, w -= STEP) {
       T x = FPBits(v).get_val(), y = FPBits(w).get_val();
-      if (isnan(x) || isinf(x))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
-      if (isnan(y) || isinf(y))
+      if (FPBits(w).is_nan() || FPBits(w).is_inf())
         continue;
       if ((x == 0) && (y == 0))
         continue;
diff --git a/test/src/math/FMinTest.h b/test/src/math/FMinTest.h
index eae0008..51c21ae 100644
--- a/test/src/math/FMinTest.h
+++ b/test/src/math/FMinTest.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_FMINTEST_H
 #define LLVM_LIBC_TEST_SRC_MATH_FMINTEST_H
 
+#include "src/__support/FPUtil/FPBits.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
@@ -65,9 +66,9 @@ public:
     for (StorageType i = 0, v = 0, w = STORAGE_MAX; i <= COUNT;
          ++i, v += STEP, w -= STEP) {
       T x = FPBits(v).get_val(), y = FPBits(w).get_val();
-      if (isnan(x) || isinf(x))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
-      if (isnan(y) || isinf(y))
+      if (FPBits(w).is_nan() || FPBits(w).is_inf())
         continue;
       if ((x == 0) && (y == 0))
         continue;
diff --git a/test/src/math/FmaTest.h b/test/src/math/FmaTest.h
index 53895e7..0114333 100644
--- a/test/src/math/FmaTest.h
+++ b/test/src/math/FmaTest.h
@@ -45,9 +45,6 @@ class FmaTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   static constexpr InStorageType IN_MIN_SUBNORMAL_U =
       InFPBits::min_subnormal().uintval();
 
-  OutConstants out;
-  InConstants in;
-
   InStorageType get_random_bit_pattern() {
     InStorageType bits{0};
     for (InStorageType i = 0; i < sizeof(InStorageType) / 2; ++i) {
@@ -92,4 +89,14 @@ public:
   }
 };
 
+#define LIST_FMA_TESTS(T, func)                                                \
+  using LlvmLibcFmaTest = FmaTestTemplate<T>;                                  \
+  TEST_F(LlvmLibcFmaTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcFmaTest, NormalRange) { test_normal_range(&func); }
+
+#define LIST_NARROWING_FMA_TESTS(OutType, InType, func)                        \
+  using LlvmLibcFmaTest = FmaTestTemplate<OutType, InType>;                    \
+  TEST_F(LlvmLibcFmaTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcFmaTest, NormalRange) { test_normal_range(&func); }
+
 #endif // LLVM_LIBC_TEST_SRC_MATH_FMATEST_H
diff --git a/test/src/math/FrexpTest.h b/test/src/math/FrexpTest.h
index 3ba64af..74a2d60 100644
--- a/test/src/math/FrexpTest.h
+++ b/test/src/math/FrexpTest.h
@@ -99,7 +99,7 @@ public:
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x == 0.0l)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x == 0.0l)
         continue;
 
       mpfr::BinaryOutput<T> result;
diff --git a/test/src/math/HypotTest.h b/test/src/math/HypotTest.h
index 58b5338..fd0c1b3 100644
--- a/test/src/math/HypotTest.h
+++ b/test/src/math/HypotTest.h
@@ -17,6 +17,8 @@
 
 #include "hdr/math_macros.h"
 
+using LIBC_NAMESPACE::Sign;
+
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
 template <typename T>
diff --git a/test/src/math/ILogbTest.h b/test/src/math/ILogbTest.h
index c2d5a13..5d805ef 100644
--- a/test/src/math/ILogbTest.h
+++ b/test/src/math/ILogbTest.h
@@ -16,6 +16,8 @@
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 class LlvmLibcILogbTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
   template <typename T> struct ILogbFunc {
@@ -82,7 +84,7 @@ public:
     constexpr StorageType STEP = (MAX_SUBNORMAL - MIN_SUBNORMAL) / COUNT;
     for (StorageType v = MIN_SUBNORMAL; v <= MAX_SUBNORMAL; v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x == 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x == 0.0)
         continue;
 
       int exponent;
@@ -101,7 +103,7 @@ public:
     constexpr StorageType STEP = (MAX_NORMAL - MIN_NORMAL) / COUNT;
     for (StorageType v = MIN_NORMAL; v <= MAX_NORMAL; v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x == 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x == 0.0)
         continue;
 
       int exponent;
diff --git a/test/src/math/LdExpTest.h b/test/src/math/LdExpTest.h
index 34466a5..08dce0d 100644
--- a/test/src/math/LdExpTest.h
+++ b/test/src/math/LdExpTest.h
@@ -19,6 +19,8 @@
 #include "hdr/math_macros.h"
 #include <stdint.h>
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class LdExpTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
diff --git a/test/src/math/LogbTest.h b/test/src/math/LogbTest.h
index d6042e3..5ef3b26 100644
--- a/test/src/math/LogbTest.h
+++ b/test/src/math/LogbTest.h
@@ -78,7 +78,7 @@ public:
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x == 0.0l)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x == 0.0l)
         continue;
 
       int exponent;
diff --git a/test/src/math/ModfTest.h b/test/src/math/ModfTest.h
index d6c6f27..3377290 100644
--- a/test/src/math/ModfTest.h
+++ b/test/src/math/ModfTest.h
@@ -90,7 +90,7 @@ public:
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       T x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x == T(0.0))
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x == T(0.0))
         continue;
 
       T integral;
diff --git a/test/src/math/MulTest.h b/test/src/math/MulTest.h
new file mode 100644
index 0000000..cb81a79
--- /dev/null
+++ b/test/src/math/MulTest.h
@@ -0,0 +1,95 @@
+//===-- Utility class to test different flavors of float mul ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_MULTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_MULTEST_H
+
+#include "src/stdlib/rand.h"
+#include "src/stdlib/srand.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+template <typename OutType, typename InType>
+class MulTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  static constexpr InStorageType IN_MAX_NORMAL_U =
+      InFPBits::max_normal().uintval();
+  static constexpr InStorageType IN_MIN_NORMAL_U =
+      InFPBits::min_normal().uintval();
+  static constexpr InStorageType IN_MAX_SUBNORMAL_U =
+      InFPBits::max_subnormal().uintval();
+  static constexpr InStorageType IN_MIN_SUBNORMAL_U =
+      InFPBits::min_subnormal().uintval();
+
+  InStorageType get_random_bit_pattern() {
+    InStorageType bits{0};
+    for (InStorageType i = 0; i < sizeof(InStorageType) / 2; ++i)
+      bits = (bits << 2) + static_cast<uint16_t>(LIBC_NAMESPACE::rand());
+    return bits;
+  }
+
+public:
+  using MulFunc = OutType (*)(InType, InType);
+
+  void test_subnormal_range(MulFunc func) {
+    constexpr InStorageType COUNT = 10'001;
+    constexpr InStorageType STEP =
+        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
+    LIBC_NAMESPACE::srand(1);
+    for (int signs = 0; signs < 4; signs++) {
+      for (InStorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
+        InType x = InFPBits(get_random_bit_pattern()).get_val();
+        InType y = InFPBits(v).get_val();
+        if ((signs & 1) != 0)
+          x = -x;
+        if ((signs & 2) != 0)
+          y = -y;
+        mpfr::BinaryInput<InType> input{x, y};
+        EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Mul, input, func(x, y),
+                                       0.5);
+      }
+    }
+  }
+
+  void test_normal_range(MulFunc func) {
+    constexpr InStorageType COUNT = 10'001;
+    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
+    LIBC_NAMESPACE::srand(1);
+    for (int signs = 0; signs < 4; signs++) {
+      for (InStorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
+        InType x = InFPBits(get_random_bit_pattern()).get_val();
+        InType y = InFPBits(v).get_val();
+        if ((signs & 1) != 0)
+          x = -x;
+        if ((signs & 2) != 0)
+          y = -y;
+        mpfr::BinaryInput<InType> input{x, y};
+        EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Mul, input, func(x, y),
+                                       0.5);
+      }
+    }
+  }
+};
+
+#define LIST_MUL_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcMulTest = MulTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcMulTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcMulTest, NormalRange) { test_normal_range(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_MULTEST_H
diff --git a/test/src/math/NearbyIntTest.h b/test/src/math/NearbyIntTest.h
new file mode 100644
index 0000000..88cdf45
--- /dev/null
+++ b/test/src/math/NearbyIntTest.h
@@ -0,0 +1,118 @@
+//===-- Utility class to test different flavors of nearbyint ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_NEARBYINTTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_NEARBYINTTEST_H
+
+#include "src/__support/CPP/algorithm.h"
+#include "src/__support/CPP/array.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using namespace LIBC_NAMESPACE::fputil::testing;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+template <typename T>
+class NearbyIntTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+  static constexpr LIBC_NAMESPACE::cpp::array<RoundingMode, 4> ROUNDING_MODES =
+      {
+          RoundingMode::Upward,
+          RoundingMode::Downward,
+          RoundingMode::TowardZero,
+          RoundingMode::Nearest,
+      };
+
+  static constexpr StorageType MIN_SUBNORMAL =
+      FPBits::min_subnormal().uintval();
+  static constexpr StorageType MAX_SUBNORMAL =
+      FPBits::max_subnormal().uintval();
+  static constexpr StorageType MIN_NORMAL = FPBits::min_normal().uintval();
+  static constexpr StorageType MAX_NORMAL = FPBits::max_normal().uintval();
+
+public:
+  using NearbyIntFunc = T (*)(T);
+
+  void test_round_numbers(NearbyIntFunc func) {
+    for (RoundingMode mode : ROUNDING_MODES) {
+      if (ForceRoundingMode r(mode); r.success) {
+        EXPECT_FP_EQ(func(T(1.0)), mpfr::round(T(1.0), mode));
+        EXPECT_FP_EQ(func(T(-1.0)), mpfr::round(T(-1.0), mode));
+        EXPECT_FP_EQ(func(T(10.0)), mpfr::round(T(10.0), mode));
+        EXPECT_FP_EQ(func(T(-10.0)), mpfr::round(T(-10.0), mode));
+        EXPECT_FP_EQ(func(T(1234.0)), mpfr::round(T(1234.0), mode));
+        EXPECT_FP_EQ(func(T(-1234.0)), mpfr::round(T(-1234.0), mode));
+      }
+    }
+  }
+
+  void test_fractions(NearbyIntFunc func) {
+    for (RoundingMode mode : ROUNDING_MODES) {
+      if (ForceRoundingMode r(mode); r.success) {
+        EXPECT_FP_EQ(func(T(0.5)), mpfr::round(T(0.5), mode));
+        EXPECT_FP_EQ(func(T(-0.5)), mpfr::round(T(-0.5), mode));
+        EXPECT_FP_EQ(func(T(0.115)), mpfr::round(T(0.115), mode));
+        EXPECT_FP_EQ(func(T(-0.115)), mpfr::round(T(-0.115), mode));
+        EXPECT_FP_EQ(func(T(0.715)), mpfr::round(T(0.715), mode));
+        EXPECT_FP_EQ(func(T(-0.715)), mpfr::round(T(-0.715), mode));
+      }
+    }
+  }
+
+  void test_subnormal_range(NearbyIntFunc func) {
+    constexpr int COUNT = 100'001;
+    const StorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<StorageType>((MAX_SUBNORMAL - MIN_SUBNORMAL) / COUNT),
+        StorageType(1));
+    for (StorageType i = MIN_SUBNORMAL; i <= MAX_SUBNORMAL; i += STEP) {
+      T x = FPBits(i).get_val();
+      for (RoundingMode mode : ROUNDING_MODES) {
+        if (ForceRoundingMode r(mode); r.success) {
+          EXPECT_FP_EQ(func(x), mpfr::round(x, mode));
+        }
+      }
+    }
+  }
+
+  void test_normal_range(NearbyIntFunc func) {
+    constexpr int COUNT = 100'001;
+    const StorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<StorageType>((MAX_NORMAL - MIN_NORMAL) / COUNT),
+        StorageType(1));
+    for (StorageType i = MIN_NORMAL; i <= MAX_NORMAL; i += STEP) {
+      FPBits xbits(i);
+      T x = xbits.get_val();
+      // In normal range on x86 platforms, the long double implicit 1 bit can be
+      // zero making the numbers NaN. We will skip them.
+      if (xbits.is_nan())
+        continue;
+
+      for (RoundingMode mode : ROUNDING_MODES) {
+        if (ForceRoundingMode r(mode); r.success) {
+          EXPECT_FP_EQ(func(x), mpfr::round(x, mode));
+        }
+      }
+    }
+  }
+};
+
+#define LIST_NEARBYINT_TESTS(F, func)                                          \
+  using LlvmLibcNearbyIntTest = NearbyIntTestTemplate<F>;                      \
+  TEST_F(LlvmLibcNearbyIntTest, RoundNumbers) { test_round_numbers(&func); }   \
+  TEST_F(LlvmLibcNearbyIntTest, Fractions) { test_fractions(&func); }          \
+  TEST_F(LlvmLibcNearbyIntTest, SubnormalRange) {                              \
+    test_subnormal_range(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcNearbyIntTest, NormalRange) { test_normal_range(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_NEARBYINTTEST_H
diff --git a/test/src/math/NextAfterTest.h b/test/src/math/NextAfterTest.h
index b3b03f7..d97c264 100644
--- a/test/src/math/NextAfterTest.h
+++ b/test/src/math/NextAfterTest.h
@@ -18,6 +18,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class NextAfterTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
diff --git a/test/src/math/RIntTest.h b/test/src/math/RIntTest.h
index d31bf74..c9d8ebc 100644
--- a/test/src/math/RIntTest.h
+++ b/test/src/math/RIntTest.h
@@ -21,6 +21,7 @@
 #include "hdr/math_macros.h"
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+using LIBC_NAMESPACE::Sign;
 
 static constexpr int ROUNDING_MODES[4] = {FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO,
                                           FE_TONEAREST};
diff --git a/test/src/math/RemQuoTest.h b/test/src/math/RemQuoTest.h
index c39f239..e664000 100644
--- a/test/src/math/RemQuoTest.h
+++ b/test/src/math/RemQuoTest.h
@@ -18,6 +18,7 @@
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+using LIBC_NAMESPACE::Sign;
 
 template <typename T>
 class RemQuoTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
@@ -127,7 +128,7 @@ public:
 
       // In normal range on x86 platforms, the long double implicit 1 bit can be
       // zero making the numbers NaN. Hence we test for them separately.
-      if (isnan(x) || isnan(y)) {
+      if (FPBits(v).is_nan() || FPBits(w).is_nan()) {
         ASSERT_FP_EQ(result.f, nan);
         continue;
       }
diff --git a/test/src/math/RoundToIntegerTest.h b/test/src/math/RoundToIntegerTest.h
index bb7e864..77b465a 100644
--- a/test/src/math/RoundToIntegerTest.h
+++ b/test/src/math/RoundToIntegerTest.h
@@ -12,34 +12,35 @@
 #include "src/__support/CPP/algorithm.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/properties/architectures.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
 #include "hdr/math_macros.h"
-#include <errno.h>
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+using LIBC_NAMESPACE::Sign;
 
 static constexpr int ROUNDING_MODES[4] = {FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO,
                                           FE_TONEAREST};
 
-template <typename F, typename I, bool TestModes = false>
+template <typename FloatType, typename IntType, bool TestModes = false>
 class RoundToIntegerTestTemplate
     : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
-  typedef I (*RoundToIntegerFunc)(F);
+  typedef IntType (*RoundToIntegerFunc)(FloatType);
 
 private:
-  using FPBits = LIBC_NAMESPACE::fputil::FPBits<F>;
+  using FPBits = LIBC_NAMESPACE::fputil::FPBits<FloatType>;
   using StorageType = typename FPBits::StorageType;
 
-  const F zero = FPBits::zero().get_val();
-  const F neg_zero = FPBits::zero(Sign::NEG).get_val();
-  const F inf = FPBits::inf().get_val();
-  const F neg_inf = FPBits::inf(Sign::NEG).get_val();
-  const F nan = FPBits::quiet_nan().get_val();
+  const FloatType zero = FPBits::zero().get_val();
+  const FloatType neg_zero = FPBits::zero(Sign::NEG).get_val();
+  const FloatType inf = FPBits::inf().get_val();
+  const FloatType neg_inf = FPBits::inf(Sign::NEG).get_val();
+  const FloatType nan = FPBits::quiet_nan().get_val();
 
   static constexpr StorageType MAX_NORMAL = FPBits::max_normal().uintval();
   static constexpr StorageType MIN_NORMAL = FPBits::min_normal().uintval();
@@ -48,11 +49,12 @@ private:
   static constexpr StorageType MIN_SUBNORMAL =
       FPBits::min_subnormal().uintval();
 
-  static constexpr I INTEGER_MIN = I(1) << (sizeof(I) * 8 - 1);
-  static constexpr I INTEGER_MAX = -(INTEGER_MIN + 1);
+  static constexpr IntType INTEGER_MIN = IntType(1)
+                                         << (sizeof(IntType) * 8 - 1);
+  static constexpr IntType INTEGER_MAX = -(INTEGER_MIN + 1);
 
-  void test_one_input(RoundToIntegerFunc func, F input, I expected,
-                      bool expectError) {
+  void test_one_input(RoundToIntegerFunc func, FloatType input,
+                      IntType expected, bool expectError) {
     LIBC_NAMESPACE::libc_errno = 0;
     LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT);
 
@@ -119,35 +121,35 @@ public:
   }
 
   void do_round_numbers_test(RoundToIntegerFunc func) {
-    test_one_input(func, zero, I(0), false);
-    test_one_input(func, neg_zero, I(0), false);
-    test_one_input(func, F(1.0), I(1), false);
-    test_one_input(func, F(-1.0), I(-1), false);
-    test_one_input(func, F(10.0), I(10), false);
-    test_one_input(func, F(-10.0), I(-10), false);
-    test_one_input(func, F(1234.0), I(1234), false);
-    test_one_input(func, F(-1234.0), I(-1234), false);
+    test_one_input(func, zero, IntType(0), false);
+    test_one_input(func, neg_zero, IntType(0), false);
+    test_one_input(func, FloatType(1.0), IntType(1), false);
+    test_one_input(func, FloatType(-1.0), IntType(-1), false);
+    test_one_input(func, FloatType(10.0), IntType(10), false);
+    test_one_input(func, FloatType(-10.0), IntType(-10), false);
+    test_one_input(func, FloatType(1234.0), IntType(1234), false);
+    test_one_input(func, FloatType(-1234.0), IntType(-1234), false);
 
     // The rest of this function compares with an equivalent MPFR function
     // which rounds floating point numbers to long values. There is no MPFR
     // function to round to long long or wider integer values. So, we will
-    // the remaining tests only if the width of I less than equal to that of
-    // long.
-    if (sizeof(I) > sizeof(long))
+    // the remaining tests only if the width of IntType less than equal to that
+    // of long.
+    if (sizeof(IntType) > sizeof(long))
       return;
 
-    constexpr int EXPONENT_LIMIT = sizeof(I) * 8 - 1;
+    constexpr int EXPONENT_LIMIT = sizeof(IntType) * 8 - 1;
     constexpr int BIASED_EXPONENT_LIMIT = EXPONENT_LIMIT + FPBits::EXP_BIAS;
     if (BIASED_EXPONENT_LIMIT > FPBits::MAX_BIASED_EXPONENT)
       return;
     // We start with 1.0 so that the implicit bit for x86 long doubles
     // is set.
-    FPBits bits(F(1.0));
+    FPBits bits(FloatType(1.0));
     bits.set_biased_exponent(BIASED_EXPONENT_LIMIT);
     bits.set_sign(Sign::NEG);
     bits.set_mantissa(0);
 
-    F x = bits.get_val();
+    FloatType x = bits.get_val();
     long mpfr_result;
     bool erangeflag = mpfr::round_to_long(x, mpfr_result);
     ASSERT_FALSE(erangeflag);
@@ -166,8 +168,11 @@ public:
   }
 
   void do_fractions_test(RoundToIntegerFunc func, int mode) {
-    constexpr F FRACTIONS[] = {0.5, -0.5, 0.115, -0.115, 0.715, -0.715};
-    for (F x : FRACTIONS) {
+    constexpr FloatType FRACTIONS[] = {
+        FloatType(0.5),    FloatType(-0.5),  FloatType(0.115),
+        FloatType(-0.115), FloatType(0.715), FloatType(-0.715),
+    };
+    for (FloatType x : FRACTIONS) {
       long mpfr_long_result;
       bool erangeflag;
       if (TestModes)
@@ -176,7 +181,7 @@ public:
       else
         erangeflag = mpfr::round_to_long(x, mpfr_long_result);
       ASSERT_FALSE(erangeflag);
-      I mpfr_result = mpfr_long_result;
+      IntType mpfr_result = mpfr_long_result;
       test_one_input(func, x, mpfr_result, false);
     }
   }
@@ -198,23 +203,23 @@ public:
     // This function compares with an equivalent MPFR function which rounds
     // floating point numbers to long values. There is no MPFR function to
     // round to long long or wider integer values. So, we will peform the
-    // comparisons in this function only if the width of I less than equal to
-    // that of long.
-    if (sizeof(I) > sizeof(long))
+    // comparisons in this function only if the width of IntType less than equal
+    // to that of long.
+    if (sizeof(IntType) > sizeof(long))
       return;
 
-    constexpr int EXPONENT_LIMIT = sizeof(I) * 8 - 1;
+    constexpr int EXPONENT_LIMIT = sizeof(IntType) * 8 - 1;
     constexpr int BIASED_EXPONENT_LIMIT = EXPONENT_LIMIT + FPBits::EXP_BIAS;
     if (BIASED_EXPONENT_LIMIT > FPBits::MAX_BIASED_EXPONENT)
       return;
     // We start with 1.0 so that the implicit bit for x86 long doubles
     // is set.
-    FPBits bits(F(1.0));
+    FPBits bits(FloatType(1.0));
     bits.set_biased_exponent(BIASED_EXPONENT_LIMIT);
     bits.set_sign(Sign::NEG);
     bits.set_mantissa(FPBits::FRACTION_MASK);
 
-    F x = bits.get_val();
+    FloatType x = bits.get_val();
     if (TestModes) {
       for (int m : ROUNDING_MODES) {
         LIBC_NAMESPACE::fputil::set_round(m);
@@ -238,29 +243,29 @@ public:
         static_cast<StorageType>((MAX_SUBNORMAL - MIN_SUBNORMAL) / COUNT),
         StorageType(1));
     for (StorageType i = MIN_SUBNORMAL; i <= MAX_SUBNORMAL; i += STEP) {
-      F x = FPBits(i).get_val();
-      if (x == F(0.0))
+      FloatType x = FPBits(i).get_val();
+      if (x == FloatType(0.0))
         continue;
       // All subnormal numbers should round to zero.
       if (TestModes) {
         if (x > 0) {
           LIBC_NAMESPACE::fputil::set_round(FE_UPWARD);
-          test_one_input(func, x, I(1), false);
+          test_one_input(func, x, IntType(1), false);
           LIBC_NAMESPACE::fputil::set_round(FE_DOWNWARD);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
           LIBC_NAMESPACE::fputil::set_round(FE_TOWARDZERO);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
           LIBC_NAMESPACE::fputil::set_round(FE_TONEAREST);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
         } else {
           LIBC_NAMESPACE::fputil::set_round(FE_UPWARD);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
           LIBC_NAMESPACE::fputil::set_round(FE_DOWNWARD);
-          test_one_input(func, x, I(-1), false);
+          test_one_input(func, x, IntType(-1), false);
           LIBC_NAMESPACE::fputil::set_round(FE_TOWARDZERO);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
           LIBC_NAMESPACE::fputil::set_round(FE_TONEAREST);
-          test_one_input(func, x, I(0), false);
+          test_one_input(func, x, IntType(0), false);
         }
       } else {
         test_one_input(func, x, 0L, false);
@@ -272,9 +277,9 @@ public:
     // This function compares with an equivalent MPFR function which rounds
     // floating point numbers to long values. There is no MPFR function to
     // round to long long or wider integer values. So, we will peform the
-    // comparisons in this function only if the width of I less than equal to
-    // that of long.
-    if (sizeof(I) > sizeof(long))
+    // comparisons in this function only if the width of IntType less than equal
+    // to that of long.
+    if (sizeof(IntType) > sizeof(long))
       return;
 
     constexpr int COUNT = 1'000'001;
@@ -283,7 +288,7 @@ public:
         StorageType(1));
     for (StorageType i = MIN_NORMAL; i <= MAX_NORMAL; i += STEP) {
       FPBits xbits(i);
-      F x = xbits.get_val();
+      FloatType x = xbits.get_val();
       // In normal range on x86 platforms, the long double implicit 1 bit can be
       // zero making the numbers NaN. We will skip them.
       if (xbits.is_nan())
@@ -294,7 +299,7 @@ public:
           long mpfr_long_result;
           bool erangeflag = mpfr::round_to_long(x, to_mpfr_rounding_mode(m),
                                                 mpfr_long_result);
-          I mpfr_result = mpfr_long_result;
+          IntType mpfr_result = mpfr_long_result;
           LIBC_NAMESPACE::fputil::set_round(m);
           if (erangeflag)
             test_one_input(func, x, x > 0 ? INTEGER_MAX : INTEGER_MIN, true);
@@ -304,7 +309,7 @@ public:
       } else {
         long mpfr_long_result;
         bool erangeflag = mpfr::round_to_long(x, mpfr_long_result);
-        I mpfr_result = mpfr_long_result;
+        IntType mpfr_result = mpfr_long_result;
         if (erangeflag)
           test_one_input(func, x, x > 0 ? INTEGER_MAX : INTEGER_MIN, true);
         else
@@ -314,9 +319,10 @@ public:
   }
 };
 
-#define LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, TestModes)              \
+#define LIST_ROUND_TO_INTEGER_TESTS_HELPER(FloatType, IntType, func,           \
+                                           TestModes)                          \
   using LlvmLibcRoundToIntegerTest =                                           \
-      RoundToIntegerTestTemplate<F, I, TestModes>;                             \
+      RoundToIntegerTestTemplate<FloatType, IntType, TestModes>;               \
   TEST_F(LlvmLibcRoundToIntegerTest, InfinityAndNaN) {                         \
     testInfinityAndNaN(&func);                                                 \
   }                                                                            \
@@ -332,10 +338,10 @@ public:
   }                                                                            \
   TEST_F(LlvmLibcRoundToIntegerTest, NormalRange) { testNormalRange(&func); }
 
-#define LIST_ROUND_TO_INTEGER_TESTS(F, I, func)                                \
-  LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, false)
+#define LIST_ROUND_TO_INTEGER_TESTS(FloatType, IntType, func)                  \
+  LIST_ROUND_TO_INTEGER_TESTS_HELPER(FloatType, IntType, func, false)
 
-#define LIST_ROUND_TO_INTEGER_TESTS_WITH_MODES(F, I, func)                     \
-  LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, true)
+#define LIST_ROUND_TO_INTEGER_TESTS_WITH_MODES(FloatType, IntType, func)       \
+  LIST_ROUND_TO_INTEGER_TESTS_HELPER(FloatType, IntType, func, true)
 
 #endif // LLVM_LIBC_TEST_SRC_MATH_ROUNDTOINTEGERTEST_H
diff --git a/test/src/math/SqrtTest.h b/test/src/math/SqrtTest.h
index 1c422e2..770cc94 100644
--- a/test/src/math/SqrtTest.h
+++ b/test/src/math/SqrtTest.h
@@ -6,51 +6,36 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/CPP/bit.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include "hdr/math_macros.h"
-
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
-template <typename T>
+template <typename OutType, typename InType>
 class SqrtTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
-  DECLARE_SPECIAL_CONSTANTS(T)
+  DECLARE_SPECIAL_CONSTANTS(InType)
 
   static constexpr StorageType HIDDEN_BIT =
-      StorageType(1) << LIBC_NAMESPACE::fputil::FPBits<T>::FRACTION_LEN;
+      StorageType(1) << LIBC_NAMESPACE::fputil::FPBits<InType>::FRACTION_LEN;
 
 public:
-  typedef T (*SqrtFunc)(T);
-
-  void test_special_numbers(SqrtFunc func) {
-    ASSERT_FP_EQ(aNaN, func(aNaN));
-    ASSERT_FP_EQ(inf, func(inf));
-    ASSERT_FP_EQ(aNaN, func(neg_inf));
-    ASSERT_FP_EQ(0.0, func(0.0));
-    ASSERT_FP_EQ(-0.0, func(-0.0));
-    ASSERT_FP_EQ(aNaN, func(T(-1.0)));
-    ASSERT_FP_EQ(T(1.0), func(T(1.0)));
-    ASSERT_FP_EQ(T(2.0), func(T(4.0)));
-    ASSERT_FP_EQ(T(3.0), func(T(9.0)));
-  }
+  using SqrtFunc = OutType (*)(InType);
 
   void test_denormal_values(SqrtFunc func) {
     for (StorageType mant = 1; mant < HIDDEN_BIT; mant <<= 1) {
-      FPBits denormal(T(0.0));
+      FPBits denormal(zero);
       denormal.set_mantissa(mant);
-      T x = denormal.get_val();
+      InType x = denormal.get_val();
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
 
     constexpr StorageType COUNT = 200'001;
     constexpr StorageType STEP = HIDDEN_BIT / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
-      T x = LIBC_NAMESPACE::cpp::bit_cast<T>(v);
+      InType x = FPBits(i).get_val();
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
   }
@@ -59,17 +44,21 @@ public:
     constexpr StorageType COUNT = 200'001;
     constexpr StorageType STEP = STORAGE_MAX / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
-      T x = LIBC_NAMESPACE::cpp::bit_cast<T>(v);
-      if (isnan(x) || (x < 0)) {
+      FPBits x_bits(v);
+      InType x = x_bits.get_val();
+      if (x_bits.is_nan() || (x < 0))
         continue;
-      }
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
   }
 };
 
 #define LIST_SQRT_TESTS(T, func)                                               \
-  using LlvmLibcSqrtTest = SqrtTest<T>;                                        \
-  TEST_F(LlvmLibcSqrtTest, SpecialNumbers) { test_special_numbers(&func); }    \
+  using LlvmLibcSqrtTest = SqrtTest<T, T>;                                     \
+  TEST_F(LlvmLibcSqrtTest, DenormalValues) { test_denormal_values(&func); }    \
+  TEST_F(LlvmLibcSqrtTest, NormalRange) { test_normal_range(&func); }
+
+#define LIST_NARROWING_SQRT_TESTS(OutType, InType, func)                       \
+  using LlvmLibcSqrtTest = SqrtTest<OutType, InType>;                          \
   TEST_F(LlvmLibcSqrtTest, DenormalValues) { test_denormal_values(&func); }    \
   TEST_F(LlvmLibcSqrtTest, NormalRange) { test_normal_range(&func); }
diff --git a/test/src/math/SubTest.h b/test/src/math/SubTest.h
new file mode 100644
index 0000000..9b40353
--- /dev/null
+++ b/test/src/math/SubTest.h
@@ -0,0 +1,74 @@
+//===-- Utility class to test different flavors of float sub ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+template <typename OutType, typename InType>
+class SubTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  static constexpr InStorageType IN_MAX_NORMAL_U =
+      InFPBits::max_normal().uintval();
+  static constexpr InStorageType IN_MIN_NORMAL_U =
+      InFPBits::min_normal().uintval();
+  static constexpr InStorageType IN_MAX_SUBNORMAL_U =
+      InFPBits::max_subnormal().uintval();
+  static constexpr InStorageType IN_MIN_SUBNORMAL_U =
+      InFPBits::min_subnormal().uintval();
+
+public:
+  using SubFunc = OutType (*)(InType, InType);
+
+  void test_subnormal_range(SubFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP =
+        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_SUBNORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sub, input, func(x, y),
+                                     0.5);
+    }
+  }
+
+  void test_normal_range(SubFunc func) {
+    constexpr InStorageType COUNT = 100'001;
+    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
+    for (InStorageType i = 0, v = 0, w = IN_MAX_NORMAL_U; i <= COUNT;
+         ++i, v += STEP, w -= STEP) {
+      InType x = InFPBits(v).get_val();
+      InType y = InFPBits(w).get_val();
+      mpfr::BinaryInput<InType> input{x, y};
+      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sub, input, func(x, y),
+                                     0.5);
+    }
+  }
+};
+
+#define LIST_SUB_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcSubTest = SubTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcSubTest, SubnormalRange) { test_subnormal_range(&func); }     \
+  TEST_F(LlvmLibcSubTest, NormalRange) { test_normal_range(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
diff --git a/test/src/math/acosf_test.cpp b/test/src/math/acosf_test.cpp
index 0d25a80..2e4c8eb 100644
--- a/test/src/math/acosf_test.cpp
+++ b/test/src/math/acosf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
@@ -48,7 +47,7 @@ TEST_F(LlvmLibcAcosfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Acos, x,
                                    LIBC_NAMESPACE::acosf(x), 0.5);
diff --git a/test/src/math/acoshf_test.cpp b/test/src/math/acoshf_test.cpp
index 32761e2..18ed5a1 100644
--- a/test/src/math/acoshf_test.cpp
+++ b/test/src/math/acoshf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAcoshfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -45,7 +44,7 @@ TEST_F(LlvmLibcAcoshfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Acosh, x,
                                    LIBC_NAMESPACE::acoshf(x), 0.5);
diff --git a/test/src/math/asinf_test.cpp b/test/src/math/asinf_test.cpp
index 91e6108..5197810 100644
--- a/test/src/math/asinf_test.cpp
+++ b/test/src/math/asinf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAsinfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -46,7 +45,7 @@ TEST_F(LlvmLibcAsinfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Asin, x,
                                    LIBC_NAMESPACE::asinf(x), 0.5);
diff --git a/test/src/math/asinhf_test.cpp b/test/src/math/asinhf_test.cpp
index b19e26e..ac125c3 100644
--- a/test/src/math/asinhf_test.cpp
+++ b/test/src/math/asinhf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAsinhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -45,7 +44,7 @@ TEST_F(LlvmLibcAsinhfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Asinh, x,
                                    LIBC_NAMESPACE::asinhf(x), 0.5);
diff --git a/test/src/math/atan2_test.cpp b/test/src/math/atan2_test.cpp
new file mode 100644
index 0000000..637ac89
--- /dev/null
+++ b/test/src/math/atan2_test.cpp
@@ -0,0 +1,125 @@
+//===-- Unittests for atan2 -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/atan2.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcAtan2Test = LIBC_NAMESPACE::testing::FPTest<double>;
+using LIBC_NAMESPACE::testing::tlog;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcAtan2Test, TrickyInputs) {
+  mpfr::BinaryInput<double> inputs[] = {
+      {0x1.0853408534085p-2, 0x1.e7b54166c6126p-2},
+      {FPBits::inf().get_val(), 0x0.0000000000001p-1022},
+  };
+
+  for (mpfr::BinaryInput<double> &input : inputs) {
+    double x = input.x;
+    double y = input.y;
+    mpfr::RoundingMode rm = mpfr::RoundingMode::Downward;
+    mpfr::ForceRoundingMode rr(rm);
+    ASSERT_MPFR_MATCH(mpfr::Operation::Atan2, input,
+                      LIBC_NAMESPACE::atan2(x, y), 0.5, rm);
+    input.x = -input.x;
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Atan2, input,
+                                   LIBC_NAMESPACE::atan2(-x, y), 0.5);
+    input.y = -input.y;
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Atan2, input,
+                                   LIBC_NAMESPACE::atan2(-x, -y), 0.5);
+    input.x = -input.x;
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Atan2, input,
+                                   LIBC_NAMESPACE::atan2(x, -y), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcAtan2Test, InDoubleRange) {
+  constexpr uint64_t X_COUNT = 123;
+  constexpr uint64_t X_START = FPBits(0.25).uintval();
+  constexpr uint64_t X_STOP = FPBits(4.0).uintval();
+  constexpr uint64_t X_STEP = (X_STOP - X_START) / X_COUNT;
+
+  constexpr uint64_t Y_COUNT = 137;
+  constexpr uint64_t Y_START = FPBits(0.25).uintval();
+  constexpr uint64_t Y_STOP = FPBits(4.0).uintval();
+  constexpr uint64_t Y_STEP = (Y_STOP - Y_START) / Y_COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode __r(rounding_mode);
+    if (!__r.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t finite_count = 0;
+    uint64_t total_count = 0;
+    double failed_x = 0.0, failed_y = 0.0, failed_r = 0.0;
+    double tol = 0.5;
+
+    for (uint64_t i = 0, v = X_START; i <= X_COUNT; ++i, v += X_STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(x).is_inf_or_nan() || x < 0.0)
+        continue;
+
+      for (uint64_t j = 0, w = Y_START; j <= Y_COUNT; ++j, w += Y_STEP) {
+        double y = FPBits(w).get_val();
+        if (FPBits(y).is_inf_or_nan())
+          continue;
+
+        double result = LIBC_NAMESPACE::atan2(x, y);
+        ++total_count;
+        if (FPBits(result).is_inf_or_nan())
+          continue;
+
+        ++finite_count;
+        mpfr::BinaryInput<double> inputs{x, y};
+
+        if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Atan2, inputs,
+                                               result, 0.5, rounding_mode)) {
+          ++fails;
+          while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(
+              mpfr::Operation::Atan2, inputs, result, tol, rounding_mode)) {
+            failed_x = x;
+            failed_y = y;
+            failed_r = result;
+
+            if (tol > 1000.0)
+              break;
+
+            tol *= 2.0;
+          }
+        }
+      }
+    }
+    if (fails || (finite_count < total_count)) {
+      tlog << " Atan2 failed: " << fails << "/" << finite_count << "/"
+           << total_count << " tests.\n"
+           << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
+    }
+    if (fails) {
+      mpfr::BinaryInput<double> inputs{failed_x, failed_y};
+      EXPECT_MPFR_MATCH(mpfr::Operation::Atan2, inputs, failed_r, 0.5,
+                        rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/atan2f_test.cpp b/test/src/math/atan2f_test.cpp
index 1242b7e..331f428 100644
--- a/test/src/math/atan2f_test.cpp
+++ b/test/src/math/atan2f_test.cpp
@@ -73,18 +73,18 @@ TEST_F(LlvmLibcAtan2fTest, InFloatRange) {
 
     for (uint32_t i = 0, v = X_START; i <= X_COUNT; ++i, v += X_STEP) {
       float x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
 
       for (uint32_t j = 0, w = Y_START; j <= Y_COUNT; ++j, w += Y_STEP) {
         float y = FPBits(w).get_val();
-        if (isnan(y) || isinf(y))
+        if (FPBits(w).is_nan() || FPBits(w).is_inf())
           continue;
 
         LIBC_NAMESPACE::libc_errno = 0;
         float result = LIBC_NAMESPACE::atan2f(x, y);
         ++total_count;
-        if (isnan(result) || isinf(result))
+        if (FPBits(result).is_nan() || FPBits(result).is_inf())
           continue;
 
         ++finite_count;
diff --git a/test/src/math/atanf_test.cpp b/test/src/math/atanf_test.cpp
index 376b472..575ec89 100644
--- a/test/src/math/atanf_test.cpp
+++ b/test/src/math/atanf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAtanfTest = LIBC_NAMESPACE::testing::FPTest<float>;
diff --git a/test/src/math/atanhf_test.cpp b/test/src/math/atanhf_test.cpp
index b0505e4..8b9db1d 100644
--- a/test/src/math/atanhf_test.cpp
+++ b/test/src/math/atanhf_test.cpp
@@ -14,10 +14,10 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAtanhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
+using LIBC_NAMESPACE::Sign;
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
diff --git a/test/src/math/cbrt_test.cpp b/test/src/math/cbrt_test.cpp
new file mode 100644
index 0000000..2e2de16
--- /dev/null
+++ b/test/src/math/cbrt_test.cpp
@@ -0,0 +1,105 @@
+//===-- Unittests for cbrt ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/math_macros.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/cbrt.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCbrtTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcCbrtTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 123'451;
+  uint64_t START = FPBits(1.0).uintval();
+  uint64_t STOP = FPBits(8.0).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode force_rounding(rounding_mode);
+    if (!force_rounding.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t tested = 0;
+    uint64_t total = 0;
+    double worst_input, worst_output = 0.0;
+    double ulp = 0.5;
+
+    for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(x).is_inf_or_nan())
+        continue;
+
+      double result = LIBC_NAMESPACE::cbrt(x);
+      ++total;
+      if (FPBits(result).is_inf_or_nan())
+        continue;
+
+      ++tested;
+
+      if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Cbrt, x, result,
+                                             0.5, rounding_mode)) {
+        ++fails;
+        while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Cbrt, x,
+                                                  result, ulp, rounding_mode)) {
+          worst_input = x;
+          worst_output = result;
+
+          if (ulp > 1000.0)
+            break;
+
+          ulp *= 2.0;
+        }
+      }
+    }
+    if (fails) {
+      tlog << " Cbrt failed: " << fails << "/" << tested << "/" << total
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(ulp) << ".\n";
+      EXPECT_MPFR_MATCH(mpfr::Operation::Cbrt, worst_input, worst_output, 0.5,
+                        rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
+
+TEST_F(LlvmLibcCbrtTest, SpecialValues) {
+  constexpr double INPUTS[] = {
+      0x1.4f61672324c8p-1028, -0x1.fffffffffffffp-1021, 0x1.00152f57068b7p-1,
+      0x1.006509cda9886p-1,   0x1.018369b92e523p-1,     0x1.10af932ef2bf9p-1,
+      0x1.1a41117939fdbp-1,   0x1.2ae8076520d9ap-1,     0x1.a202bfc89ddffp-1,
+      0x1.a6bb8c803147bp-1,   0x1.000197b499b1bp+0,     0x1.00065ed266c6cp+0,
+      0x1.d4306c202c4c2p+0,   0x1.8fd409efe4851p+1,     0x1.95fd0eb31cc4p+1,
+      0x1.7cef1d276e335p+2,   0x1.94910c4fc98p+2,       0x1.a0cc1327bb4c4p+2,
+      0x1.e7d6ebed549c4p+2,
+  };
+  for (double v : INPUTS) {
+    double x = FPBits(v).get_val();
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cbrt, x,
+                                   LIBC_NAMESPACE::cbrt(x), 0.5);
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cbrt, -x,
+                                   LIBC_NAMESPACE::cbrt(-x), 0.5);
+  }
+}
diff --git a/test/src/math/cbrtf_test.cpp b/test/src/math/cbrtf_test.cpp
new file mode 100644
index 0000000..1d7d218
--- /dev/null
+++ b/test/src/math/cbrtf_test.cpp
@@ -0,0 +1,42 @@
+//===-- Unittests for cbrtf -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/math_macros.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/cbrtf.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCbrtfTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcCbrtfTest, InFloatRange) {
+  constexpr uint32_t COUNT = 100'000;
+  const uint32_t STEP = FPBits(inf).uintval() / COUNT;
+  for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
+    float x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cbrt, x,
+                                   LIBC_NAMESPACE::cbrtf(x), 0.5);
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cbrt, -x,
+                                   LIBC_NAMESPACE::cbrtf(-x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcCbrtfTest, SpecialValues) {
+  constexpr float INPUTS[] = {
+      0x1.60451p2f, 0x1.31304cp1f, 0x1.d17cp2f, 0x1.bp-143f, 0x1.338cp2f,
+  };
+  for (float v : INPUTS) {
+    float x = FPBits(v).get_val();
+    mpfr::ForceRoundingMode r(mpfr::RoundingMode::Upward);
+    EXPECT_MPFR_MATCH(mpfr::Operation::Cbrt, x, LIBC_NAMESPACE::cbrtf(x), 0.5,
+                      mpfr::RoundingMode::Upward);
+  }
+}
diff --git a/test/src/math/cos_test.cpp b/test/src/math/cos_test.cpp
index 9a39616..e2d4791 100644
--- a/test/src/math/cos_test.cpp
+++ b/test/src/math/cos_test.cpp
@@ -6,27 +6,123 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/FPUtil/FPBits.h"
 #include "src/math/cos.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include "hdr/math_macros.h"
-
 using LlvmLibcCosTest = LIBC_NAMESPACE::testing::FPTest<double>;
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
-TEST_F(LlvmLibcCosTest, Range) {
-  static constexpr double _2pi = 6.283185307179586;
-  constexpr StorageType COUNT = 100'000;
-  constexpr StorageType STEP = STORAGE_MAX / COUNT;
-  for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
-    double x = FPBits(v).get_val();
-    // TODO: Expand the range of testing after range reduction is implemented.
-    if (isnan(x) || isinf(x) || x > _2pi || x < -_2pi)
-      continue;
-
-    ASSERT_MPFR_MATCH(mpfr::Operation::Cos, x, LIBC_NAMESPACE::cos(x), 1.0);
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcCosTest, TrickyInputs) {
+  constexpr double INPUTS[] = {
+      0x1.8000000000009p-23,    0x1.8000000000024p-22,
+      0x1.800000000009p-21,     0x1.20000000000f3p-20,
+      0x1.800000000024p-20,     0x1.e0000000001c2p-20,
+      0x1.940c877fb7dacp-7,     -0x1.f42fb19b5b9b2p-6,
+      -0x1.0285070f9f1bcp-5,    0x1.23f40dccdef72p+0,
+      0x1.43cf16358c9d7p+0,     0x1.addf3b9722265p+0,
+      0x1.ae78d360afa15p+0,     0x1.e31b55306f22cp+2,
+      0x1.e639103a05997p+2,     -0x1.f7898d5a756ddp+2,
+      0x1.1685973506319p+3,     0x1.5f09cad750ab1p+3,
+      -0x1.aaf85537ea4c7p+3,    0x1.4f2b874135d27p+4,
+      0x1.13114266f9764p+4,     0x1.a211877de55dbp+4,
+      -0x1.a5eece87e8606p+4,    0x1.a65d441ea6dcep+4,
+      0x1.1ffb509f3db15p+5,     0x1.2345d1e090529p+5,
+      0x1.c96e28eb679f8p+5,     0x1.be886d9c2324dp+6,
+      -0x1.ab514bfc61c76p+7,    -0x1.14823229799c2p+7,
+      0x1.48ff1782ca91dp+8,     0x1.dcbfda0c7559ep+8,
+      0x1.dcbfda0c7559ep+8,     0x1.2e566149bf5fdp+9,
+      0x1.cb996c60f437ep+9,     0x1.ae945054939c2p+10,
+      -0x1.119471e9216cdp+10,   0x1.ae945054939c2p+10,
+      0x1.fffffffffdb6p+24,     0x1.fd4da4ef37075p+29,
+      0x1.55202aefde314p+31,    0x1.b951f1572eba5p+31,
+      0x1.7776c2343ba4ep+101,   0x1.85fc0f04c0128p+101,
+      0x1.678309fa50d58p+110,   0x1.fffffffffef4ep+199,
+      0x1.3eec5912ea7cdp+331,   -0x1.3eec5912ea7cdp+331,
+      -0x1.6deb37da81129p+205,  0x1.08087e9aad90bp+887,
+      -0x1.08087e9aad90bp+887,  -0x1.8bb5847d49973p+845,
+      0x1.6ac5b262ca1ffp+849,   0x1.f08b14e1c4d0fp+890,
+      0x1.2b5fe88a9d8d5p+903,   0x1.f6d7518808571p+1023,
+      -0x1.a880417b7b119p+1023, 0x1.00a33764a0a83p-7,
+      0x1.fe81868fc47fep+1,     0x1.0da8cc189b47dp-10,
+      0x1.da1838053b866p+5,     0x1.ffffffffe854bp199,
+  };
+  constexpr int N = sizeof(INPUTS) / sizeof(INPUTS[0]);
+
+  for (int i = 0; i < N; ++i) {
+    double x = INPUTS[i];
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cos, x,
+                                   LIBC_NAMESPACE::cos(x), 0.5);
   }
 }
+
+TEST_F(LlvmLibcCosTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 1'234'51;
+  uint64_t START = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p-50).uintval();
+  uint64_t STOP = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p200).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode __r(rounding_mode);
+    if (!__r.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t tested = 0;
+    uint64_t total = 0;
+    double worst_input, worst_output = 0.0;
+    double ulp = 0.5;
+
+    for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
+        continue;
+
+      double result = LIBC_NAMESPACE::cos(x);
+      ++total;
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
+        continue;
+
+      ++tested;
+
+      if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Cos, x, result,
+                                             0.5, rounding_mode)) {
+        ++fails;
+        while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Cos, x,
+                                                  result, ulp, rounding_mode)) {
+          worst_input = x;
+          worst_output = result;
+
+          if (ulp > 1000.0)
+            break;
+
+          ulp *= 2.0;
+        }
+      }
+    }
+    if (fails) {
+      tlog << " Cos failed: " << fails << "/" << tested << "/" << total
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(ulp) << ".\n";
+      EXPECT_MPFR_MATCH(mpfr::Operation::Cos, worst_input, worst_output, 0.5,
+                        rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/cosf_test.cpp b/test/src/math/cosf_test.cpp
index dab35fa..2143c36 100644
--- a/test/src/math/cosf_test.cpp
+++ b/test/src/math/cosf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/src/math/sdcomp26094.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LIBC_NAMESPACE::testing::SDCOMP26094_VALUES;
@@ -47,7 +46,7 @@ TEST_F(LlvmLibcCosfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cos, x,
                                    LIBC_NAMESPACE::cosf(x), 0.5);
diff --git a/test/src/math/coshf16_test.cpp b/test/src/math/coshf16_test.cpp
new file mode 100644
index 0000000..a0d1fd2
--- /dev/null
+++ b/test/src/math/coshf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for coshf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/coshf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCoshf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcCoshf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cosh, x,
+                                   LIBC_NAMESPACE::coshf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcCoshf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cosh, x,
+                                   LIBC_NAMESPACE::coshf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/coshf_test.cpp b/test/src/math/coshf_test.cpp
index 7c5d663..0d1c322 100644
--- a/test/src/math/coshf_test.cpp
+++ b/test/src/math/coshf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcCoshfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -61,7 +60,7 @@ TEST_F(LlvmLibcCoshfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH(mpfr::Operation::Cosh, x, LIBC_NAMESPACE::coshf(x), 0.5);
   }
diff --git a/test/src/math/cospif16_test.cpp b/test/src/math/cospif16_test.cpp
new file mode 100644
index 0000000..6a32498
--- /dev/null
+++ b/test/src/math/cospif16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for cospif16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cospif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCospif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcCospif16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                   LIBC_NAMESPACE::cospif16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcCospif16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                   LIBC_NAMESPACE::cospif16(x), 0.5);
+  }
+}
diff --git a/test/src/math/cospif_test.cpp b/test/src/math/cospif_test.cpp
new file mode 100644
index 0000000..37ec251
--- /dev/null
+++ b/test/src/math/cospif_test.cpp
@@ -0,0 +1,121 @@
+//===-- Unittests for cospif ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/cospif.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/src/math/sdcomp26094.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCospifTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+using LIBC_NAMESPACE::testing::SDCOMP26094_VALUES;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcCospifTest, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(-0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+TEST_F(LlvmLibcCospifTest, SpecificBitPatterns) {
+  constexpr int N = 38;
+  constexpr uint32_t INPUTS[N] = {
+      0x3f00'0000U, // x = 0.5
+      0x461d'd600U, // x = 10101.5
+      0x3f06'0a92U, // x = pi/6
+      0x3f3a'dc51U, // x = 0x1.75b8a2p-1f
+      0x3f49'0fdbU, // x = pi/4
+      0x3f86'0a92U, // x = pi/3
+      0x3fa7'832aU, // x = 0x1.4f0654p+0f
+      0x3fc9'0fdbU, // x = pi/2
+      0x4017'1973U, // x = 0x1.2e32e6p+1f
+      0x4049'0fdbU, // x = pi
+      0x4096'cbe4U, // x = 0x1.2d97c8p+2f
+      0x40c9'0fdbU, // x = 2*pi
+      0x433b'7490U, // x = 0x1.76e92p+7f
+      0x437c'e5f1U, // x = 0x1.f9cbe2p+7f
+      0x4619'9998U, // x = 0x1.33333p+13f
+      0x474d'246fU, // x = 0x1.9a48dep+15f
+      0x4afd'ece4U, // x = 0x1.fbd9c8p+22f
+      0x4c23'32e9U, // x = 0x1.4665d2p+25f
+      0x50a3'e87fU, // x = 0x1.47d0fep+34f
+      0x5239'47f6U, // x = 0x1.728fecp+37f
+      0x53b1'46a6U, // x = 0x1.628d4cp+40f
+      0x55ca'fb2aU, // x = 0x1.95f654p+44f
+      0x588e'f060U, // x = 0x1.1de0cp+50f
+      0x5c07'bcd0U, // x = 0x1.0f79ap+57f
+      0x5ebc'fddeU, // x = 0x1.79fbbcp+62f
+      0x5fa6'eba7U, // x = 0x1.4dd74ep+64f
+      0x61a4'0b40U, // x = 0x1.48168p+68f
+      0x6386'134eU, // x = 0x1.0c269cp+72f
+      0x6589'8498U, // x = 0x1.13093p+76f
+      0x6600'0001U, // x = 0x1.000002p+77f
+      0x664e'46e4U, // x = 0x1.9c8dc8p+77f
+      0x66b0'14aaU, // x = 0x1.602954p+78f
+      0x67a9'242bU, // x = 0x1.524856p+80f
+      0x6a19'76f1U, // x = 0x1.32ede2p+85f
+      0x6c55'da58U, // x = 0x1.abb4bp+89f
+      0x6f79'be45U, // x = 0x1.f37c8ap+95f
+      0x7276'69d4U, // x = 0x1.ecd3a8p+101f
+      0x7758'4625U, // x = 0x1.b08c4ap+111f
+  };
+
+  for (int i = 0; i < N; ++i) {
+    float x = FPBits(INPUTS[i]).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                   LIBC_NAMESPACE::cospif(x), 0.5);
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, -x,
+                                   LIBC_NAMESPACE::cospif(-x), 0.5);
+  }
+}
+
+// For small values, sinpi(x) is pi * x.
+TEST_F(LlvmLibcCospifTest, SmallValues) {
+  float x = FPBits(0x1780'0000U).get_val();
+  EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                 LIBC_NAMESPACE::cospif(x), 0.5);
+
+  x = FPBits(0x0040'0000U).get_val();
+  EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                 LIBC_NAMESPACE::cospif(x), 0.5);
+}
+
+// SDCOMP-26094: check sinfpi in the cases for which the range reducer
+// returns values furthest beyond its nominal upper bound of pi/4.
+TEST_F(LlvmLibcCospifTest, SDCOMP_26094) {
+  for (uint32_t v : SDCOMP26094_VALUES) {
+    float x = FPBits((v)).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cospi, x,
+                                   LIBC_NAMESPACE::cospif(x), 0.5);
+  }
+}
+
+// sinpi(+n + 0.5) = sinpi(-n + 0.5) = +0.0
+TEST_F(LlvmLibcCospifTest, SignedZeros) {
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(100.5f));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(-100.5f));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(45678.5f));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(-45678.5f));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(8000000.5f));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cospif(-8000000.5f));
+}
diff --git a/test/src/math/daddl_test.cpp b/test/src/math/daddl_test.cpp
new file mode 100644
index 0000000..7a34d96
--- /dev/null
+++ b/test/src/math/daddl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for daddl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/daddl.h"
+
+LIST_ADD_TESTS(double, long double, LIBC_NAMESPACE::daddl)
diff --git a/test/src/math/ddivl_test.cpp b/test/src/math/ddivl_test.cpp
new file mode 100644
index 0000000..7768766
--- /dev/null
+++ b/test/src/math/ddivl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ddivl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/ddivl.h"
+
+LIST_DIV_TESTS(double, long double, LIBC_NAMESPACE::ddivl)
diff --git a/test/src/math/dfmal_test.cpp b/test/src/math/dfmal_test.cpp
new file mode 100644
index 0000000..3c38f5e
--- /dev/null
+++ b/test/src/math/dfmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dfmal -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/dfmal.h"
+
+LIST_NARROWING_FMA_TESTS(double, long double, LIBC_NAMESPACE::dfmal)
diff --git a/test/src/math/dmull_test.cpp b/test/src/math/dmull_test.cpp
new file mode 100644
index 0000000..1b9c9c2
--- /dev/null
+++ b/test/src/math/dmull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dmull -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/dmull.h"
+
+LIST_MUL_TESTS(double, long double, LIBC_NAMESPACE::dmull)
diff --git a/test/src/math/dsqrtl_test.cpp b/test/src/math/dsqrtl_test.cpp
new file mode 100644
index 0000000..c178e38
--- /dev/null
+++ b/test/src/math/dsqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsqrtl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/dsqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(double, long double, LIBC_NAMESPACE::dsqrtl)
diff --git a/test/src/math/dsubl_test.cpp b/test/src/math/dsubl_test.cpp
new file mode 100644
index 0000000..98846e0
--- /dev/null
+++ b/test/src/math/dsubl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsubl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/dsubl.h"
+
+LIST_SUB_TESTS(double, long double, LIBC_NAMESPACE::dsubl)
diff --git a/test/src/math/erff_test.cpp b/test/src/math/erff_test.cpp
index 5c848d7..f9b0337 100644
--- a/test/src/math/erff_test.cpp
+++ b/test/src/math/erff_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcErffTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -64,12 +63,12 @@ TEST_F(LlvmLibcErffTest, InFloatRange) {
 
     for (uint32_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       float x = FPBits(v).get_val();
-      if (isnan(x))
+      if (FPBits(v).is_nan())
         continue;
 
       float result = LIBC_NAMESPACE::erff(x);
       ++cc;
-      if (isnan(result))
+      if (FPBits(result).is_nan())
         continue;
 
       ++count;
diff --git a/test/src/math/exhaustive/cbrtf_test.cpp b/test/src/math/exhaustive/cbrtf_test.cpp
new file mode 100644
index 0000000..e4511e1
--- /dev/null
+++ b/test/src/math/exhaustive/cbrtf_test.cpp
@@ -0,0 +1,33 @@
+//===-- Exhaustive test for cbrtf -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "exhaustive_test.h"
+#include "src/math/cbrtf.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LlvmLibcCbrtfExhaustiveTest =
+    LlvmLibcUnaryOpExhaustiveMathTest<float, mpfr::Operation::Cbrt,
+                                      LIBC_NAMESPACE::cbrtf>;
+
+// Range: [0, Inf];
+static constexpr uint32_t POS_START = 0x0000'0000U;
+static constexpr uint32_t POS_STOP = 0x7f80'0000U;
+
+TEST_F(LlvmLibcCbrtfExhaustiveTest, PostiveRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP);
+}
+
+// Range: [-Inf, 0];
+static constexpr uint32_t NEG_START = 0x8000'0000U;
+static constexpr uint32_t NEG_STOP = 0xff80'0000U;
+
+TEST_F(LlvmLibcCbrtfExhaustiveTest, NegativeRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP);
+}
diff --git a/test/src/math/exhaustive/cospif_test.cpp b/test/src/math/exhaustive/cospif_test.cpp
new file mode 100644
index 0000000..59077d5
--- /dev/null
+++ b/test/src/math/exhaustive/cospif_test.cpp
@@ -0,0 +1,33 @@
+//===-- Exhaustive test for cospif ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "exhaustive_test.h"
+#include "src/math/cospif.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LlvmLibcCospifExhaustiveTest =
+    LlvmLibcUnaryOpExhaustiveMathTest<float, mpfr::Operation::Cospi,
+                                      LIBC_NAMESPACE::cospif>;
+
+static constexpr uint32_t POS_START = 0x0000'0000U;
+static constexpr uint32_t POS_STOP = 0x7f80'0000U;
+
+// Range: [0, Inf]
+TEST_F(LlvmLibcCospifExhaustiveTest, PostiveRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP);
+}
+
+// Range: [-Inf, 0]
+static constexpr uint32_t NEG_START = 0xb000'0000U;
+static constexpr uint32_t NEG_STOP = 0xff80'0000U;
+
+TEST_F(LlvmLibcCospifExhaustiveTest, NegativeRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP);
+}
diff --git a/test/src/math/exhaustive/exhaustive_test.h b/test/src/math/exhaustive/exhaustive_test.h
index 13e2727..94489d2 100644
--- a/test/src/math/exhaustive/exhaustive_test.h
+++ b/test/src/math/exhaustive/exhaustive_test.h
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/properties/types.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
@@ -60,17 +61,54 @@ struct UnaryOpChecker : public virtual LIBC_NAMESPACE::testing::Test {
           TEST_MPFR_MATCH_ROUNDING_SILENTLY(Op, x, Func(x), 0.5, rounding);
       failed += (!correct);
       // Uncomment to print out failed values.
-      // if (!correct) {
-      //   EXPECT_MPFR_MATCH_ROUNDING(Op, x, Func(x), 0.5, rounding);
-      // }
+      if (!correct) {
+        EXPECT_MPFR_MATCH_ROUNDING(Op, x, Func(x), 0.5, rounding);
+      }
     } while (bits++ < stop);
     return failed;
   }
 };
 
+template <typename OutType, typename InType = OutType>
+using BinaryOp = OutType(InType, InType);
+
+template <typename OutType, typename InType, mpfr::Operation Op,
+          BinaryOp<OutType, InType> Func>
+struct BinaryOpChecker : public virtual LIBC_NAMESPACE::testing::Test {
+  using FloatType = InType;
+  using FPBits = LIBC_NAMESPACE::fputil::FPBits<FloatType>;
+  using StorageType = typename FPBits::StorageType;
+
+  // Check in a range, return the number of failures.
+  uint64_t check(StorageType x_start, StorageType x_stop, StorageType y_start,
+                 StorageType y_stop, mpfr::RoundingMode rounding) {
+    mpfr::ForceRoundingMode r(rounding);
+    if (!r.success)
+      return x_stop > x_start || y_stop > y_start;
+    StorageType xbits = x_start;
+    uint64_t failed = 0;
+    do {
+      FloatType x = FPBits(xbits).get_val();
+      StorageType ybits = y_start;
+      do {
+        FloatType y = FPBits(ybits).get_val();
+        mpfr::BinaryInput<FloatType> input{x, y};
+        bool correct = TEST_MPFR_MATCH_ROUNDING_SILENTLY(Op, input, Func(x, y),
+                                                         0.5, rounding);
+        failed += (!correct);
+        // Uncomment to print out failed values.
+        if (!correct) {
+          EXPECT_MPFR_MATCH_ROUNDING(Op, input, Func(x, y), 0.5, rounding);
+        }
+      } while (ybits++ < y_stop);
+    } while (xbits++ < x_stop);
+    return failed;
+  }
+};
+
 // Checker class needs inherit from LIBC_NAMESPACE::testing::Test and provide
 //   StorageType and check method.
-template <typename Checker>
+template <typename Checker, size_t Increment = 1 << 20>
 struct LlvmLibcExhaustiveMathTest
     : public virtual LIBC_NAMESPACE::testing::Test,
       public Checker {
@@ -78,12 +116,35 @@ struct LlvmLibcExhaustiveMathTest
   using FPBits = typename Checker::FPBits;
   using StorageType = typename Checker::StorageType;
 
-  static constexpr StorageType INCREMENT = (1 << 20);
+  void explain_failed_range(std::stringstream &msg, StorageType x_begin,
+                            StorageType x_end) {
+#ifdef LIBC_TYPES_HAS_FLOAT16
+    using T = LIBC_NAMESPACE::cpp::conditional_t<
+        LIBC_NAMESPACE::cpp::is_same_v<FloatType, float16>, float, FloatType>;
+#else
+    using T = FloatType;
+#endif
+
+    msg << x_begin << " to " << x_end << " [0x" << std::hex << x_begin << ", 0x"
+        << x_end << "), [" << std::hexfloat
+        << static_cast<T>(FPBits(x_begin).get_val()) << ", "
+        << static_cast<T>(FPBits(x_end).get_val()) << ")";
+  }
+
+  void explain_failed_range(std::stringstream &msg, StorageType x_begin,
+                            StorageType x_end, StorageType y_begin,
+                            StorageType y_end) {
+    msg << "x ";
+    explain_failed_range(msg, x_begin, x_end);
+    msg << ", y ";
+    explain_failed_range(msg, y_begin, y_end);
+  }
 
   // Break [start, stop) into `nthreads` subintervals and apply *check to each
   // subinterval in parallel.
-  void test_full_range(StorageType start, StorageType stop,
-                       mpfr::RoundingMode rounding) {
+  template <typename... T>
+  void test_full_range(mpfr::RoundingMode rounding, StorageType start,
+                       StorageType stop, T... extra_range_bounds) {
     int n_threads = std::thread::hardware_concurrency();
     std::vector<std::thread> thread_list;
     std::mutex mx_cur_val;
@@ -102,8 +163,8 @@ struct LlvmLibcExhaustiveMathTest
               return;
 
             range_begin = current_value;
-            if (stop >= INCREMENT && stop - INCREMENT >= current_value) {
-              range_end = current_value + INCREMENT;
+            if (stop >= Increment && stop - Increment >= current_value) {
+              range_end = current_value + Increment;
             } else {
               range_end = stop;
             }
@@ -120,15 +181,15 @@ struct LlvmLibcExhaustiveMathTest
             std::cout << msg.str() << std::flush;
           }
 
-          uint64_t failed_in_range =
-              Checker::check(range_begin, range_end, rounding);
+          uint64_t failed_in_range = Checker::check(
+              range_begin, range_end, extra_range_bounds..., rounding);
           if (failed_in_range > 0) {
             std::stringstream msg;
             msg << "Test failed for " << std::dec << failed_in_range
-                << " inputs in range: " << range_begin << " to " << range_end
-                << " [0x" << std::hex << range_begin << ", 0x" << range_end
-                << "), [" << std::hexfloat << FPBits(range_begin).get_val()
-                << ", " << FPBits(range_end).get_val() << ")\n";
+                << " inputs in range: ";
+            explain_failed_range(msg, range_begin, range_end,
+                                 extra_range_bounds...);
+            msg << "\n";
             std::cerr << msg.str() << std::flush;
 
             failed.fetch_add(failed_in_range);
@@ -151,19 +212,46 @@ struct LlvmLibcExhaustiveMathTest
   void test_full_range_all_roundings(StorageType start, StorageType stop) {
     std::cout << "-- Testing for FE_TONEAREST in range [0x" << std::hex << start
               << ", 0x" << stop << ") --" << std::dec << std::endl;
-    test_full_range(start, stop, mpfr::RoundingMode::Nearest);
+    test_full_range(mpfr::RoundingMode::Nearest, start, stop);
 
     std::cout << "-- Testing for FE_UPWARD in range [0x" << std::hex << start
               << ", 0x" << stop << ") --" << std::dec << std::endl;
-    test_full_range(start, stop, mpfr::RoundingMode::Upward);
+    test_full_range(mpfr::RoundingMode::Upward, start, stop);
 
     std::cout << "-- Testing for FE_DOWNWARD in range [0x" << std::hex << start
               << ", 0x" << stop << ") --" << std::dec << std::endl;
-    test_full_range(start, stop, mpfr::RoundingMode::Downward);
+    test_full_range(mpfr::RoundingMode::Downward, start, stop);
 
     std::cout << "-- Testing for FE_TOWARDZERO in range [0x" << std::hex
               << start << ", 0x" << stop << ") --" << std::dec << std::endl;
-    test_full_range(start, stop, mpfr::RoundingMode::TowardZero);
+    test_full_range(mpfr::RoundingMode::TowardZero, start, stop);
+  };
+
+  void test_full_range_all_roundings(StorageType x_start, StorageType x_stop,
+                                     StorageType y_start, StorageType y_stop) {
+    std::cout << "-- Testing for FE_TONEAREST in x range [0x" << std::hex
+              << x_start << ", 0x" << x_stop << "), y range [0x" << y_start
+              << ", 0x" << y_stop << ") --" << std::dec << std::endl;
+    test_full_range(mpfr::RoundingMode::Nearest, x_start, x_stop, y_start,
+                    y_stop);
+
+    std::cout << "-- Testing for FE_UPWARD in x range [0x" << std::hex
+              << x_start << ", 0x" << x_stop << "), y range [0x" << y_start
+              << ", 0x" << y_stop << ") --" << std::dec << std::endl;
+    test_full_range(mpfr::RoundingMode::Upward, x_start, x_stop, y_start,
+                    y_stop);
+
+    std::cout << "-- Testing for FE_DOWNWARD in x range [0x" << std::hex
+              << x_start << ", 0x" << x_stop << "), y range [0x" << y_start
+              << ", 0x" << y_stop << ") --" << std::dec << std::endl;
+    test_full_range(mpfr::RoundingMode::Downward, x_start, x_stop, y_start,
+                    y_stop);
+
+    std::cout << "-- Testing for FE_TOWARDZERO in x range [0x" << std::hex
+              << x_start << ", 0x" << x_stop << "), y range [0x" << y_start
+              << ", 0x" << y_stop << ") --" << std::dec << std::endl;
+    test_full_range(mpfr::RoundingMode::TowardZero, x_start, x_stop, y_start,
+                    y_stop);
   };
 };
 
@@ -175,3 +263,8 @@ template <typename OutType, typename InType, mpfr::Operation Op,
           UnaryOp<OutType, InType> Func>
 using LlvmLibcUnaryNarrowingOpExhaustiveMathTest =
     LlvmLibcExhaustiveMathTest<UnaryOpChecker<OutType, InType, Op, Func>>;
+
+template <typename FloatType, mpfr::Operation Op, BinaryOp<FloatType> Func>
+using LlvmLibcBinaryOpExhaustiveMathTest =
+    LlvmLibcExhaustiveMathTest<BinaryOpChecker<FloatType, FloatType, Op, Func>,
+                               1 << 2>;
diff --git a/test/src/math/exhaustive/exp10m1f_test.cpp b/test/src/math/exhaustive/exp10m1f_test.cpp
new file mode 100644
index 0000000..b9b2290
--- /dev/null
+++ b/test/src/math/exhaustive/exp10m1f_test.cpp
@@ -0,0 +1,33 @@
+//===-- Exhaustive test for exp10m1f --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "exhaustive_test.h"
+#include "src/math/exp10m1f.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LlvmLibcExp10m1fExhaustiveTest =
+    LlvmLibcUnaryOpExhaustiveMathTest<float, mpfr::Operation::Exp10m1,
+                                      LIBC_NAMESPACE::exp10m1f>;
+
+// Range: [0, Inf];
+static constexpr uint32_t POS_START = 0x0000'0000U;
+static constexpr uint32_t POS_STOP = 0x7f80'0000U;
+
+TEST_F(LlvmLibcExp10m1fExhaustiveTest, PostiveRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP);
+}
+
+// Range: [-Inf, 0];
+static constexpr uint32_t NEG_START = 0x8000'0000U;
+static constexpr uint32_t NEG_STOP = 0xff80'0000U;
+
+TEST_F(LlvmLibcExp10m1fExhaustiveTest, NegativeRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP);
+}
diff --git a/test/src/math/exhaustive/fmodf16_test.cpp b/test/src/math/exhaustive/fmodf16_test.cpp
new file mode 100644
index 0000000..067cec9
--- /dev/null
+++ b/test/src/math/exhaustive/fmodf16_test.cpp
@@ -0,0 +1,41 @@
+//===-- Exhaustive test for fmodf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "exhaustive_test.h"
+#include "src/math/fmodf16.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LlvmLibcFmodf16ExhaustiveTest =
+    LlvmLibcBinaryOpExhaustiveMathTest<float16, mpfr::Operation::Fmod,
+                                       LIBC_NAMESPACE::fmodf16>;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcFmodf16ExhaustiveTest, PostivePositiveRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP, POS_START, POS_STOP);
+}
+
+TEST_F(LlvmLibcFmodf16ExhaustiveTest, PostiveNegativeRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP, NEG_START, NEG_STOP);
+}
+
+TEST_F(LlvmLibcFmodf16ExhaustiveTest, NegativePositiveRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP, POS_START, POS_STOP);
+}
+
+TEST_F(LlvmLibcFmodf16ExhaustiveTest, NegativeNegativeRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP, POS_START, POS_STOP);
+}
diff --git a/test/src/math/exhaustive/sinpif_test.cpp b/test/src/math/exhaustive/sinpif_test.cpp
new file mode 100644
index 0000000..81abac0
--- /dev/null
+++ b/test/src/math/exhaustive/sinpif_test.cpp
@@ -0,0 +1,33 @@
+//===-- Exhaustive test for sinpif ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "exhaustive_test.h"
+#include "src/math/sinpif.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LlvmLibcSinpifExhaustiveTest =
+    LlvmLibcUnaryOpExhaustiveMathTest<float, mpfr::Operation::Sinpi,
+                                      LIBC_NAMESPACE::sinpif>;
+
+static constexpr uint32_t POS_START = 0x0000'0000U;
+static constexpr uint32_t POS_STOP = 0x7f80'0000U;
+
+// Range: [0, Inf]
+TEST_F(LlvmLibcSinpifExhaustiveTest, PostiveRange) {
+  test_full_range_all_roundings(POS_START, POS_STOP);
+}
+
+// Range: [-Inf, 0]
+static constexpr uint32_t NEG_START = 0xb000'0000U;
+static constexpr uint32_t NEG_STOP = 0xff80'0000U;
+
+TEST_F(LlvmLibcSinpifExhaustiveTest, NegativeRange) {
+  test_full_range_all_roundings(NEG_START, NEG_STOP);
+}
diff --git a/test/src/math/exp10_test.cpp b/test/src/math/exp10_test.cpp
index 4cbdd16..6fb1d2d 100644
--- a/test/src/math/exp10_test.cpp
+++ b/test/src/math/exp10_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExp10Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -104,12 +103,12 @@ TEST_F(LlvmLibcExp10Test, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::exp10(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/exp10f16_test.cpp b/test/src/math/exp10f16_test.cpp
new file mode 100644
index 0000000..fc49331
--- /dev/null
+++ b/test/src/math/exp10f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for exp10f16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp10f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExp10f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExp10f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10, x,
+                                   LIBC_NAMESPACE::exp10f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExp10f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10, x,
+                                   LIBC_NAMESPACE::exp10f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/exp10f_test.cpp b/test/src/math/exp10f_test.cpp
index e9b2786..001b378 100644
--- a/test/src/math/exp10f_test.cpp
+++ b/test/src/math/exp10f_test.cpp
@@ -111,7 +111,7 @@ TEST_F(LlvmLibcExp10fTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::exp10f(x);
@@ -120,7 +120,8 @@ TEST_F(LlvmLibcExp10fTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10, x,
                                    LIBC_NAMESPACE::exp10f(x), 0.5);
diff --git a/test/src/math/exp10m1f16_test.cpp b/test/src/math/exp10m1f16_test.cpp
new file mode 100644
index 0000000..41bb12f
--- /dev/null
+++ b/test/src/math/exp10m1f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for exp10m1f16 ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp10m1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExp10m1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExp10m1f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10m1, x,
+                                   LIBC_NAMESPACE::exp10m1f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExp10m1f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10m1, x,
+                                   LIBC_NAMESPACE::exp10m1f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/exp10m1f_test.cpp b/test/src/math/exp10m1f_test.cpp
new file mode 100644
index 0000000..cc96032
--- /dev/null
+++ b/test/src/math/exp10m1f_test.cpp
@@ -0,0 +1,97 @@
+//===-- Unittests for exp10m1f --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/math_macros.h"
+#include "src/__support/CPP/array.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/exp10m1f.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+#include <stdint.h>
+
+using LlvmLibcExp10m1fTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcExp10m1fTest, TrickyInputs) {
+  constexpr LIBC_NAMESPACE::cpp::array<float, 39> INPUTS = {
+      // EXP10M1F_EXCEPTS_LO
+      0x1.0fe54ep-11f,
+      0x1.80e6eap-11f,
+      -0x1.2a33bcp-51f,
+      -0x0p+0f,
+      -0x1.b59e08p-31f,
+      -0x1.bf342p-12f,
+      -0x1.6207fp-11f,
+      -0x1.bd0c66p-11f,
+      -0x1.ffd84cp-10f,
+      -0x1.a74172p-9f,
+      -0x1.cb694cp-9f,
+      // EXP10M1F_EXCEPTS_HI
+      0x1.8d31eep-8f,
+      0x1.915fcep-8f,
+      0x1.bcf982p-8f,
+      0x1.99ff0ap-7f,
+      0x1.75ea14p-6f,
+      0x1.f81b64p-6f,
+      0x1.fafecp+3f,
+      -0x1.3bf094p-8f,
+      -0x1.4558bcp-8f,
+      -0x1.4bb43p-8f,
+      -0x1.776cc8p-8f,
+      -0x1.f024cp-8f,
+      -0x1.f510eep-8f,
+      -0x1.0b43c4p-7f,
+      -0x1.245ee4p-7f,
+      -0x1.f9f2dap-7f,
+      -0x1.08e42p-6f,
+      -0x1.0cdc44p-5f,
+      -0x1.ca4322p-5f,
+      // Exceptional integers.
+      8.0f,
+      9.0f,
+      10.0f,
+      // Overflow boundaries.
+      0x1.344134p+5f,
+      0x1.344136p+5f,
+      0x1.344138p+5f,
+      // Underflow boundaries.
+      -0x1.e1a5e0p+2f,
+      -0x1.e1a5e2p+2f,
+      -0x1.e1a5e4p+2f,
+  };
+
+  for (float x : INPUTS) {
+    LIBC_NAMESPACE::libc_errno = 0;
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10m1, x,
+                                   LIBC_NAMESPACE::exp10m1f(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExp10m1fTest, InFloatRange) {
+  constexpr uint32_t COUNT = 100'000;
+  constexpr uint32_t STEP = UINT32_MAX / COUNT;
+  for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
+    float x = FPBits(v).get_val();
+    if (isnan(x) || isinf(x))
+      continue;
+    LIBC_NAMESPACE::libc_errno = 0;
+    float result = LIBC_NAMESPACE::exp10m1f(x);
+
+    // If the computation resulted in an error or did not produce valid result
+    // in the single-precision floating point range, then ignore comparing with
+    // MPFR result as MPFR can still produce valid results because of its
+    // wider precision.
+    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+      continue;
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp10m1, x,
+                                   LIBC_NAMESPACE::exp10m1f(x), 0.5);
+  }
+}
diff --git a/test/src/math/exp2_test.cpp b/test/src/math/exp2_test.cpp
index 73232ed..adfcece 100644
--- a/test/src/math/exp2_test.cpp
+++ b/test/src/math/exp2_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExp2Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -79,12 +78,12 @@ TEST_F(LlvmLibcExp2Test, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::exp2(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/exp2f16_test.cpp b/test/src/math/exp2f16_test.cpp
new file mode 100644
index 0000000..503d8c2
--- /dev/null
+++ b/test/src/math/exp2f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for exp2f16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp2f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExp2f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExp2f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2, x,
+                                   LIBC_NAMESPACE::exp2f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExp2f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2, x,
+                                   LIBC_NAMESPACE::exp2f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/exp2f_test.cpp b/test/src/math/exp2f_test.cpp
index 8ff0ce6..0c4c821 100644
--- a/test/src/math/exp2f_test.cpp
+++ b/test/src/math/exp2f_test.cpp
@@ -8,7 +8,6 @@
 
 #include "hdr/math_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 #include "src/errno/libc_errno.h"
 #include "src/math/exp2f.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -107,7 +106,7 @@ TEST_F(LlvmLibcExp2fTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::exp2f(x);
@@ -116,7 +115,8 @@ TEST_F(LlvmLibcExp2fTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2, x,
                                    LIBC_NAMESPACE::exp2f(x), 0.5);
diff --git a/test/src/math/exp2m1f16_test.cpp b/test/src/math/exp2m1f16_test.cpp
new file mode 100644
index 0000000..bf29911
--- /dev/null
+++ b/test/src/math/exp2m1f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for exp2m1f16 -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/exp2m1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExp2m1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExp2m1f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2m1, x,
+                                   LIBC_NAMESPACE::exp2m1f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExp2m1f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2m1, x,
+                                   LIBC_NAMESPACE::exp2m1f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/exp2m1f_test.cpp b/test/src/math/exp2m1f_test.cpp
index cb94828..793cf0c 100644
--- a/test/src/math/exp2m1f_test.cpp
+++ b/test/src/math/exp2m1f_test.cpp
@@ -49,7 +49,7 @@ TEST_F(LlvmLibcExp2m1fTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::exp2m1f(x);
@@ -58,7 +58,8 @@ TEST_F(LlvmLibcExp2m1fTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp2m1, x,
                                    LIBC_NAMESPACE::exp2m1f(x), 0.5);
diff --git a/test/src/math/exp_test.cpp b/test/src/math/exp_test.cpp
index 64d8198..0ab3a4e 100644
--- a/test/src/math/exp_test.cpp
+++ b/test/src/math/exp_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExpTest = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -77,12 +76,12 @@ TEST_F(LlvmLibcExpTest, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::exp(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/expf16_test.cpp b/test/src/math/expf16_test.cpp
new file mode 100644
index 0000000..ee89a9c
--- /dev/null
+++ b/test/src/math/expf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for expf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/expf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExpf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExpf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp, x,
+                                   LIBC_NAMESPACE::expf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExpf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp, x,
+                                   LIBC_NAMESPACE::expf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/expf_test.cpp b/test/src/math/expf_test.cpp
index 1dce381..26a0bca 100644
--- a/test/src/math/expf_test.cpp
+++ b/test/src/math/expf_test.cpp
@@ -108,7 +108,7 @@ TEST_F(LlvmLibcExpfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::expf(x);
@@ -117,7 +117,8 @@ TEST_F(LlvmLibcExpfTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Exp, x,
                                    LIBC_NAMESPACE::expf(x), 0.5);
diff --git a/test/src/math/explogxf_test.cpp b/test/src/math/explogxf_test.cpp
index bcca87f..01197b8 100644
--- a/test/src/math/explogxf_test.cpp
+++ b/test/src/math/explogxf_test.cpp
@@ -17,6 +17,7 @@
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
 using LlvmLibcExplogfTest = LIBC_NAMESPACE::testing::FPTest<float>;
+using FPBits = LIBC_NAMESPACE::fputil::FPBits<float>;
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
@@ -24,7 +25,8 @@ constexpr int def_count = 100003;
 constexpr float def_prec = 0.500001f;
 
 auto f_normal = [](float x) -> bool {
-  return !(isnan(x) || isinf(x) || LIBC_NAMESPACE::fabs(x) < 2E-38);
+  return !(FPBits(x).is_nan() || FPBits(x).is_inf() ||
+           LIBC_NAMESPACE::fabs(x) < 2E-38);
 };
 
 TEST_F(LlvmLibcExplogfTest, ExpInFloatRange) {
@@ -34,7 +36,7 @@ TEST_F(LlvmLibcExplogfTest, ExpInFloatRange) {
     return static_cast<float>(result.mh * r);
   };
   auto f_check = [](float x) -> bool {
-    return !((isnan(x) || isinf(x) || x < -70 || x > 70 ||
+    return !((FPBits(x).is_nan() || FPBits(x).is_inf() || x < -70 || x > 70 ||
               LIBC_NAMESPACE::fabsf(x) < 0x1.0p-10));
   };
   CHECK_DATA(0.0f, neg_inf, mpfr::Operation::Exp, fx, f_check, def_count,
diff --git a/test/src/math/expm1_test.cpp b/test/src/math/expm1_test.cpp
index 1bf07f1..9720773 100644
--- a/test/src/math/expm1_test.cpp
+++ b/test/src/math/expm1_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExpm1Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -23,34 +22,24 @@ namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 using LIBC_NAMESPACE::testing::tlog;
 
 TEST_F(LlvmLibcExpm1Test, TrickyInputs) {
-  constexpr int N = 21;
-  constexpr uint64_t INPUTS[N] = {
-      0x3FD79289C6E6A5C0, // x=0x1.79289c6e6a5cp-2
-      0x3FD05DE80A173EA0, // x=0x1.05de80a173eap-2
-      0xbf1eb7a4cb841fcc, // x=-0x1.eb7a4cb841fccp-14
-      0xbf19a61fb925970d, // x=-0x1.9a61fb925970dp-14
-      0x3fda7b764e2cf47a, // x=0x1.a7b764e2cf47ap-2
-      0xc04757852a4b93aa, // x=-0x1.757852a4b93aap+5
-      0x4044c19e5712e377, // x=0x1.4c19e5712e377p+5
-      0xbf19a61fb925970d, // x=-0x1.9a61fb925970dp-14
-      0xc039a74cdab36c28, // x=-0x1.9a74cdab36c28p+4
-      0xc085b3e4e2e3bba9, // x=-0x1.5b3e4e2e3bba9p+9
-      0xc086960d591aec34, // x=-0x1.6960d591aec34p+9
-      0xc086232c09d58d91, // x=-0x1.6232c09d58d91p+9
-      0xc0874910d52d3051, // x=-0x1.74910d52d3051p9
-      0xc0867a172ceb0990, // x=-0x1.67a172ceb099p+9
-      0xc08ff80000000000, // x=-0x1.ff8p+9
-      0xbc971547652b82fe, // x=-0x1.71547652b82fep-54
-      0xbce465655f122ff6, // x=-0x1.465655f122ff6p-49
-      0x3d1bc8ee6b28659a, // x=0x1.bc8ee6b28659ap-46
-      0x3f18442b169f672d, // x=0x1.8442b169f672dp-14
-      0xc02b4f0cfb15ca0f, // x=-0x1.b4f0cfb15ca0fp+3
-      0xc042b708872320dd, // x=-0x1.2b708872320ddp+5
+  constexpr double INPUTS[] = {
+      0x1.71547652b82fep-54, 0x1.465655f122ff6p-49, 0x1.bc8ee6b28659ap-46,
+      0x1.8442b169f672dp-14, 0x1.9a61fb925970dp-14, 0x1.eb7a4cb841fccp-14,
+      0x1.05de80a173eap-2,   0x1.79289c6e6a5cp-2,   0x1.a7b764e2cf47ap-2,
+      0x1.b4f0cfb15ca0fp+3,  0x1.9a74cdab36c28p+4,  0x1.2b708872320ddp+5,
+      0x1.4c19e5712e377p+5,  0x1.757852a4b93aap+5,  0x1.77f74111e0894p+6,
+      0x1.a6c3780bbf824p+6,  0x1.e3d57e4c557f6p+6,  0x1.f07560077985ap+6,
+      0x1.1f0da93354198p+7,  0x1.71018579c0758p+7,  0x1.204684c1167e9p+8,
+      0x1.5b3e4e2e3bba9p+9,  0x1.6232c09d58d91p+9,  0x1.67a172ceb099p+9,
+      0x1.6960d591aec34p+9,  0x1.74910d52d3051p+9,  0x1.ff8p+9,
   };
+  constexpr int N = sizeof(INPUTS) / sizeof(INPUTS[0]);
   for (int i = 0; i < N; ++i) {
-    double x = FPBits(INPUTS[i]).get_val();
+    double x = INPUTS[i];
     EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Expm1, x,
                                    LIBC_NAMESPACE::expm1(x), 0.5);
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Expm1, -x,
+                                   LIBC_NAMESPACE::expm1(-x), 0.5);
   }
 }
 
@@ -73,12 +62,12 @@ TEST_F(LlvmLibcExpm1Test, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::expm1(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
@@ -98,10 +87,10 @@ TEST_F(LlvmLibcExpm1Test, InDoubleRange) {
         }
       }
     }
-    tlog << " Expm1 failed: " << fails << "/" << count << "/" << cc
-         << " tests.\n";
-    tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
     if (fails) {
+      tlog << " Expm1 failed: " << fails << "/" << count << "/" << cc
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
       EXPECT_MPFR_MATCH(mpfr::Operation::Expm1, mx, mr, 0.5, rounding_mode);
     }
   };
diff --git a/test/src/math/expm1f16_test.cpp b/test/src/math/expm1f16_test.cpp
new file mode 100644
index 0000000..a6a6fcf
--- /dev/null
+++ b/test/src/math/expm1f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for expm1f16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/expm1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcExpm1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcExpm1f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Expm1, x,
+                                   LIBC_NAMESPACE::expm1f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcExpm1f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Expm1, x,
+                                   LIBC_NAMESPACE::expm1f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/expm1f_test.cpp b/test/src/math/expm1f_test.cpp
index 515f988..274fe3b 100644
--- a/test/src/math/expm1f_test.cpp
+++ b/test/src/math/expm1f_test.cpp
@@ -117,7 +117,7 @@ TEST_F(LlvmLibcExpm1fTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::expm1f(x);
@@ -126,7 +126,8 @@ TEST_F(LlvmLibcExpm1fTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Expm1, x,
                                    LIBC_NAMESPACE::expm1f(x), 0.5);
diff --git a/test/src/math/f16add_test.cpp b/test/src/math/f16add_test.cpp
new file mode 100644
index 0000000..c47ece2
--- /dev/null
+++ b/test/src/math/f16add_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16add ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16add.h"
+
+LIST_ADD_TESTS(float16, double, LIBC_NAMESPACE::f16add)
diff --git a/test/src/math/f16addf_test.cpp b/test/src/math/f16addf_test.cpp
new file mode 100644
index 0000000..1e8b432
--- /dev/null
+++ b/test/src/math/f16addf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16addf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16addf.h"
+
+LIST_ADD_TESTS(float16, float, LIBC_NAMESPACE::f16addf)
diff --git a/test/src/math/f16addl_test.cpp b/test/src/math/f16addl_test.cpp
new file mode 100644
index 0000000..f8e0d9b
--- /dev/null
+++ b/test/src/math/f16addl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16addl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16addl.h"
+
+LIST_ADD_TESTS(float16, long double, LIBC_NAMESPACE::f16addl)
diff --git a/test/src/math/f16div_test.cpp b/test/src/math/f16div_test.cpp
new file mode 100644
index 0000000..0bfa69f
--- /dev/null
+++ b/test/src/math/f16div_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16div ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16div.h"
+
+LIST_DIV_TESTS(float16, double, LIBC_NAMESPACE::f16div)
diff --git a/test/src/math/f16divf_test.cpp b/test/src/math/f16divf_test.cpp
new file mode 100644
index 0000000..85be1eb
--- /dev/null
+++ b/test/src/math/f16divf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16divf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16divf.h"
+
+LIST_DIV_TESTS(float16, float, LIBC_NAMESPACE::f16divf)
diff --git a/test/src/math/f16divl_test.cpp b/test/src/math/f16divl_test.cpp
new file mode 100644
index 0000000..bad3e70
--- /dev/null
+++ b/test/src/math/f16divl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16divl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16divl.h"
+
+LIST_DIV_TESTS(float16, long double, LIBC_NAMESPACE::f16divl)
diff --git a/test/src/math/f16fma_test.cpp b/test/src/math/f16fma_test.cpp
new file mode 100644
index 0000000..2e46b5b
--- /dev/null
+++ b/test/src/math/f16fma_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16fma ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/f16fma.h"
+
+LIST_NARROWING_FMA_TESTS(float16, double, LIBC_NAMESPACE::f16fma)
diff --git a/test/src/math/f16fmaf_test.cpp b/test/src/math/f16fmaf_test.cpp
index e4ca88b..5e3aec7 100644
--- a/test/src/math/f16fmaf_test.cpp
+++ b/test/src/math/f16fmaf_test.cpp
@@ -10,12 +10,4 @@
 
 #include "src/math/f16fmaf.h"
 
-using LlvmLibcF16fmafTest = FmaTestTemplate<float16, float>;
-
-TEST_F(LlvmLibcF16fmafTest, SubnormalRange) {
-  test_subnormal_range(&LIBC_NAMESPACE::f16fmaf);
-}
-
-TEST_F(LlvmLibcF16fmafTest, NormalRange) {
-  test_normal_range(&LIBC_NAMESPACE::f16fmaf);
-}
+LIST_NARROWING_FMA_TESTS(float16, float, LIBC_NAMESPACE::f16fmaf)
diff --git a/test/src/math/f16fmal_test.cpp b/test/src/math/f16fmal_test.cpp
new file mode 100644
index 0000000..5394268
--- /dev/null
+++ b/test/src/math/f16fmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16fmal ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/f16fmal.h"
+
+LIST_NARROWING_FMA_TESTS(float16, long double, LIBC_NAMESPACE::f16fmal)
diff --git a/test/src/math/f16mul_test.cpp b/test/src/math/f16mul_test.cpp
new file mode 100644
index 0000000..49b4438
--- /dev/null
+++ b/test/src/math/f16mul_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mul ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mul.h"
+
+LIST_MUL_TESTS(float16, double, LIBC_NAMESPACE::f16mul)
diff --git a/test/src/math/f16mulf_test.cpp b/test/src/math/f16mulf_test.cpp
new file mode 100644
index 0000000..bf25308
--- /dev/null
+++ b/test/src/math/f16mulf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mulf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mulf.h"
+
+LIST_MUL_TESTS(float16, float, LIBC_NAMESPACE::f16mulf)
diff --git a/test/src/math/f16mull_test.cpp b/test/src/math/f16mull_test.cpp
new file mode 100644
index 0000000..5292ddb
--- /dev/null
+++ b/test/src/math/f16mull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mull ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mull.h"
+
+LIST_MUL_TESTS(float16, long double, LIBC_NAMESPACE::f16mull)
diff --git a/test/src/math/f16sqrt_test.cpp b/test/src/math/f16sqrt_test.cpp
new file mode 100644
index 0000000..759b388
--- /dev/null
+++ b/test/src/math/f16sqrt_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrt ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrt.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, double, LIBC_NAMESPACE::f16sqrt)
diff --git a/test/src/math/f16sqrtf_test.cpp b/test/src/math/f16sqrtf_test.cpp
new file mode 100644
index 0000000..36231ae
--- /dev/null
+++ b/test/src/math/f16sqrtf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrtf --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrtf.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, float, LIBC_NAMESPACE::f16sqrtf)
diff --git a/test/src/math/f16sqrtl_test.cpp b/test/src/math/f16sqrtl_test.cpp
new file mode 100644
index 0000000..4e069bc
--- /dev/null
+++ b/test/src/math/f16sqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrtl --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, long double, LIBC_NAMESPACE::f16sqrtl)
diff --git a/test/src/math/f16sub_test.cpp b/test/src/math/f16sub_test.cpp
new file mode 100644
index 0000000..37b9709
--- /dev/null
+++ b/test/src/math/f16sub_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sub ----------------------------------------------===/
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16sub.h"
+
+LIST_SUB_TESTS(float16, double, LIBC_NAMESPACE::f16sub)
diff --git a/test/src/math/f16subf_test.cpp b/test/src/math/f16subf_test.cpp
new file mode 100644
index 0000000..68ad948
--- /dev/null
+++ b/test/src/math/f16subf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16subf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16subf.h"
+
+LIST_SUB_TESTS(float16, float, LIBC_NAMESPACE::f16subf)
diff --git a/test/src/math/f16subl_test.cpp b/test/src/math/f16subl_test.cpp
new file mode 100644
index 0000000..c41e6e9
--- /dev/null
+++ b/test/src/math/f16subl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16subl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16subl.h"
+
+LIST_SUB_TESTS(float16, long double, LIBC_NAMESPACE::f16subl)
diff --git a/test/src/math/fadd_test.cpp b/test/src/math/fadd_test.cpp
new file mode 100644
index 0000000..fe9ac8b
--- /dev/null
+++ b/test/src/math/fadd_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fadd ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/fadd.h"
+
+LIST_ADD_TESTS(float, double, LIBC_NAMESPACE::fadd)
diff --git a/test/src/math/faddl_test.cpp b/test/src/math/faddl_test.cpp
new file mode 100644
index 0000000..9c99b32
--- /dev/null
+++ b/test/src/math/faddl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for faddl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/faddl.h"
+
+LIST_ADD_TESTS(float, long double, LIBC_NAMESPACE::faddl)
diff --git a/test/src/math/fdiv_test.cpp b/test/src/math/fdiv_test.cpp
new file mode 100644
index 0000000..f0bd602
--- /dev/null
+++ b/test/src/math/fdiv_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fdiv ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/fdiv.h"
+
+LIST_DIV_TESTS(float, double, LIBC_NAMESPACE::fdiv)
diff --git a/test/src/math/fdivl_test.cpp b/test/src/math/fdivl_test.cpp
new file mode 100644
index 0000000..bc2b0e4
--- /dev/null
+++ b/test/src/math/fdivl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fdivl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/fdivl.h"
+
+LIST_DIV_TESTS(float, long double, LIBC_NAMESPACE::fdivl)
diff --git a/test/src/math/ffma_test.cpp b/test/src/math/ffma_test.cpp
new file mode 100644
index 0000000..4b6a25c
--- /dev/null
+++ b/test/src/math/ffma_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ffma ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/ffma.h"
+
+LIST_NARROWING_FMA_TESTS(float, double, LIBC_NAMESPACE::ffma)
diff --git a/test/src/math/ffmal_test.cpp b/test/src/math/ffmal_test.cpp
new file mode 100644
index 0000000..200d9e1
--- /dev/null
+++ b/test/src/math/ffmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ffmal -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/ffmal.h"
+
+LIST_NARROWING_FMA_TESTS(float, long double, LIBC_NAMESPACE::ffmal)
diff --git a/test/src/math/fmaf_test.cpp b/test/src/math/fmaf_test.cpp
index 0e498d4..09e9c50 100644
--- a/test/src/math/fmaf_test.cpp
+++ b/test/src/math/fmaf_test.cpp
@@ -10,12 +10,4 @@
 
 #include "src/math/fmaf.h"
 
-using LlvmLibcFmafTest = FmaTestTemplate<float>;
-
-TEST_F(LlvmLibcFmafTest, SubnormalRange) {
-  test_subnormal_range(&LIBC_NAMESPACE::fmaf);
-}
-
-TEST_F(LlvmLibcFmafTest, NormalRange) {
-  test_normal_range(&LIBC_NAMESPACE::fmaf);
-}
+LIST_FMA_TESTS(float, LIBC_NAMESPACE::fmaf)
diff --git a/test/src/math/fmul_test.cpp b/test/src/math/fmul_test.cpp
new file mode 100644
index 0000000..488e087
--- /dev/null
+++ b/test/src/math/fmul_test.cpp
@@ -0,0 +1,36 @@
+//===-- Unittests for fmul ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/fmul.h"
+
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+LIST_MUL_TESTS(float, double, LIBC_NAMESPACE::fmul)
+
+TEST_F(LlvmLibcMulTest, SpecialInputs) {
+  namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+  double INPUTS[][2] = {
+      {0x1.0100010002p8, 0x1.fffcp14},
+      {0x1.000000b92144p-7, 0x1.62p7},
+  };
+
+  for (size_t i = 0; i < 2; ++i) {
+    double a = INPUTS[i][0];
+
+    for (int j = 0; j < 180; ++j) {
+      a *= 0.5;
+      mpfr::BinaryInput<double> input{a, INPUTS[i][1]};
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Mul, input,
+                                     LIBC_NAMESPACE::fmul(a, INPUTS[i][1]),
+                                     0.5);
+    }
+  }
+}
diff --git a/test/src/math/fmull_test.cpp b/test/src/math/fmull_test.cpp
new file mode 100644
index 0000000..ef69406
--- /dev/null
+++ b/test/src/math/fmull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fmull -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/fmull.h"
+
+LIST_MUL_TESTS(float, long double, LIBC_NAMESPACE::fmull)
diff --git a/test/src/math/fsqrt_test.cpp b/test/src/math/fsqrt_test.cpp
new file mode 100644
index 0000000..8471e3c
--- /dev/null
+++ b/test/src/math/fsqrt_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsqrt -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/fsqrt.h"
+
+LIST_NARROWING_SQRT_TESTS(float, double, LIBC_NAMESPACE::fsqrt)
diff --git a/test/src/math/fsqrtl_test.cpp b/test/src/math/fsqrtl_test.cpp
new file mode 100644
index 0000000..1082a33
--- /dev/null
+++ b/test/src/math/fsqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsqrtl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/fsqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(float, long double, LIBC_NAMESPACE::fsqrtl)
diff --git a/test/src/math/fsub_test.cpp b/test/src/math/fsub_test.cpp
new file mode 100644
index 0000000..3c825f7
--- /dev/null
+++ b/test/src/math/fsub_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsub ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/fsub.h"
+
+LIST_SUB_TESTS(float, double, LIBC_NAMESPACE::fsub)
diff --git a/test/src/math/fsubl_test.cpp b/test/src/math/fsubl_test.cpp
new file mode 100644
index 0000000..8723432
--- /dev/null
+++ b/test/src/math/fsubl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsubl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/fsubl.h"
+
+LIST_SUB_TESTS(float, long double, LIBC_NAMESPACE::fsubl)
diff --git a/test/src/math/log10_test.cpp b/test/src/math/log10_test.cpp
index fd9a615..01aa1f8 100644
--- a/test/src/math/log10_test.cpp
+++ b/test/src/math/log10_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog10Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -100,12 +99,12 @@ TEST_F(LlvmLibcLog10Test, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::log10(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/log10f16_test.cpp b/test/src/math/log10f16_test.cpp
new file mode 100644
index 0000000..a71e330
--- /dev/null
+++ b/test/src/math/log10f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for log10f16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/log10f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcLog10f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcLog10f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log10, x,
+                                   LIBC_NAMESPACE::log10f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcLog10f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log10, x,
+                                   LIBC_NAMESPACE::log10f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/log10f_test.cpp b/test/src/math/log10f_test.cpp
index 4ba1184..b2c1c28 100644
--- a/test/src/math/log10f_test.cpp
+++ b/test/src/math/log10f_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog10fTest = LIBC_NAMESPACE::testing::FPTest<float>;
diff --git a/test/src/math/log1p_test.cpp b/test/src/math/log1p_test.cpp
index 47dfa40..107e965 100644
--- a/test/src/math/log1p_test.cpp
+++ b/test/src/math/log1p_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog1pTest = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -101,12 +100,12 @@ TEST_F(LlvmLibcLog1pTest, InDoubleRange) {
 
     for (uint64_t i = 0, v = start; i <= COUNT; ++i, v += step) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::log1p(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/log1pf_test.cpp b/test/src/math/log1pf_test.cpp
index db0772d..bb181dc 100644
--- a/test/src/math/log1pf_test.cpp
+++ b/test/src/math/log1pf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog1pfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -74,7 +73,7 @@ TEST_F(LlvmLibcLog1pfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log1p, x,
diff --git a/test/src/math/log2_test.cpp b/test/src/math/log2_test.cpp
index 9992c13..8a07991 100644
--- a/test/src/math/log2_test.cpp
+++ b/test/src/math/log2_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog2Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -99,12 +98,12 @@ TEST_F(LlvmLibcLog2Test, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::log2(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/log2f16_test.cpp b/test/src/math/log2f16_test.cpp
new file mode 100644
index 0000000..6630ca8
--- /dev/null
+++ b/test/src/math/log2f16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for log2f16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/log2f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcLog2f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcLog2f16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log2, x,
+                                   LIBC_NAMESPACE::log2f16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcLog2f16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log2, x,
+                                   LIBC_NAMESPACE::log2f16(x), 0.5);
+  }
+}
diff --git a/test/src/math/log2f_test.cpp b/test/src/math/log2f_test.cpp
index 24b51ad..83691fb 100644
--- a/test/src/math/log2f_test.cpp
+++ b/test/src/math/log2f_test.cpp
@@ -50,7 +50,7 @@ TEST_F(LlvmLibcLog2fTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     LIBC_NAMESPACE::libc_errno = 0;
     float result = LIBC_NAMESPACE::log2f(x);
@@ -58,7 +58,8 @@ TEST_F(LlvmLibcLog2fTest, InFloatRange) {
     // in the single-precision floating point range, then ignore comparing with
     // MPFR result as MPFR can still produce valid results because of its
     // wider precision.
-    if (isnan(result) || isinf(result) || LIBC_NAMESPACE::libc_errno != 0)
+    if (FPBits(result).is_nan() || FPBits(result).is_inf() ||
+        LIBC_NAMESPACE::libc_errno != 0)
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log2, x,
                                    LIBC_NAMESPACE::log2f(x), 0.5);
diff --git a/test/src/math/log_test.cpp b/test/src/math/log_test.cpp
index de1e595..969a469 100644
--- a/test/src/math/log_test.cpp
+++ b/test/src/math/log_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLogTest = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -98,12 +97,12 @@ TEST_F(LlvmLibcLogTest, InDoubleRange) {
 
     for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
       double x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
       LIBC_NAMESPACE::libc_errno = 0;
       double result = LIBC_NAMESPACE::log(x);
       ++cc;
-      if (isnan(result) || isinf(result))
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
         continue;
 
       ++count;
diff --git a/test/src/math/logf16_test.cpp b/test/src/math/logf16_test.cpp
new file mode 100644
index 0000000..922918b
--- /dev/null
+++ b/test/src/math/logf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for logf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/logf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcLogf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcLogf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log, x,
+                                   LIBC_NAMESPACE::logf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcLogf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log, x,
+                                   LIBC_NAMESPACE::logf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/logf_test.cpp b/test/src/math/logf_test.cpp
index 28a171d..79d8275 100644
--- a/test/src/math/logf_test.cpp
+++ b/test/src/math/logf_test.cpp
@@ -82,7 +82,7 @@ TEST_F(LlvmLibcLogfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Log, x,
                                    LIBC_NAMESPACE::logf(x), 0.5);
diff --git a/test/src/math/nearbyint_test.cpp b/test/src/math/nearbyint_test.cpp
new file mode 100644
index 0000000..11a5c33
--- /dev/null
+++ b/test/src/math/nearbyint_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for nearbyint -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "NearbyIntTest.h"
+
+#include "src/math/nearbyint.h"
+
+LIST_NEARBYINT_TESTS(double, LIBC_NAMESPACE::nearbyint)
diff --git a/test/src/math/nearbyintf16_test.cpp b/test/src/math/nearbyintf16_test.cpp
new file mode 100644
index 0000000..e6ec250
--- /dev/null
+++ b/test/src/math/nearbyintf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for nearbyintf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "NearbyIntTest.h"
+
+#include "src/math/nearbyintf16.h"
+
+LIST_NEARBYINT_TESTS(float16, LIBC_NAMESPACE::nearbyintf16)
diff --git a/test/src/math/nearbyintf_test.cpp b/test/src/math/nearbyintf_test.cpp
new file mode 100644
index 0000000..fd26153
--- /dev/null
+++ b/test/src/math/nearbyintf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for nearbyintf ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "NearbyIntTest.h"
+
+#include "src/math/nearbyintf.h"
+
+LIST_NEARBYINT_TESTS(float, LIBC_NAMESPACE::nearbyintf)
diff --git a/test/src/math/nearbyintl_test.cpp b/test/src/math/nearbyintl_test.cpp
new file mode 100644
index 0000000..a6d81a1
--- /dev/null
+++ b/test/src/math/nearbyintl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for nearbyintl ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "NearbyIntTest.h"
+
+#include "src/math/nearbyintl.h"
+
+LIST_NEARBYINT_TESTS(long double, LIBC_NAMESPACE::nearbyintl)
diff --git a/test/src/math/performance_testing/BinaryOpSingleOutputPerf.h b/test/src/math/performance_testing/BinaryOpSingleOutputPerf.h
index 3027932..98a1813 100644
--- a/test/src/math/performance_testing/BinaryOpSingleOutputPerf.h
+++ b/test/src/math/performance_testing/BinaryOpSingleOutputPerf.h
@@ -6,32 +6,34 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/algorithm.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "test/src/math/performance_testing/Timer.h"
 
 #include <cstddef>
 #include <fstream>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
-
-template <typename T> class BinaryOpSingleOutputPerf {
-  using FPBits = fputil::FPBits<T>;
+template <typename OutputType, typename InputType>
+class BinaryOpSingleOutputPerf {
+  using FPBits = fputil::FPBits<OutputType>;
   using StorageType = typename FPBits::StorageType;
   static constexpr StorageType UIntMax =
       cpp::numeric_limits<StorageType>::max();
 
 public:
-  typedef T Func(T, T);
+  typedef OutputType Func(InputType, InputType);
 
   static void run_perf_in_range(Func myFunc, Func otherFunc,
                                 StorageType startingBit, StorageType endingBit,
                                 size_t N, size_t rounds, std::ofstream &log) {
-    if (endingBit - startingBit < N)
-      N = endingBit - startingBit;
+    if (sizeof(StorageType) <= sizeof(size_t))
+      N = cpp::min(N, static_cast<size_t>(endingBit - startingBit));
 
     auto runner = [=](Func func) {
-      volatile T result;
+      [[maybe_unused]] volatile OutputType result;
       if (endingBit < startingBit) {
         return;
       }
@@ -40,8 +42,8 @@ public:
       for (size_t i = 0; i < rounds; i++) {
         for (StorageType bitsX = startingBit, bitsY = endingBit;;
              bitsX += step, bitsY -= step) {
-          T x = FPBits(bitsX).get_val();
-          T y = FPBits(bitsY).get_val();
+          InputType x = FPBits(bitsX).get_val();
+          InputType y = FPBits(bitsY).get_val();
           result = func(x, y);
           if (endingBit - bitsX < step) {
             break;
@@ -92,10 +94,11 @@ public:
                       1'000'001, rounds, log);
     log << "\n Performance tests with inputs in normal range with exponents "
            "close to each other:\n";
-    run_perf_in_range(myFunc, otherFunc,
-                      /* startingBit= */ FPBits(T(0x1.0p-10)).uintval(),
-                      /* endingBit= */ FPBits(T(0x1.0p+10)).uintval(),
-                      1'000'001, rounds, log);
+    run_perf_in_range(
+        myFunc, otherFunc,
+        /* startingBit= */ FPBits(OutputType(0x1.0p-10)).uintval(),
+        /* endingBit= */ FPBits(OutputType(0x1.0p+10)).uintval(), 1'000'001,
+        rounds, log);
   }
 
   static void run_diff(Func myFunc, Func otherFunc, const char *logFile) {
@@ -113,28 +116,33 @@ public:
     log << "\n Diff tests with inputs in normal range with exponents "
            "close to each other:\n";
     diffCount += run_diff_in_range(
-        myFunc, otherFunc, /* startingBit= */ FPBits(T(0x1.0p-10)).uintval(),
-        /* endingBit= */ FPBits(T(0x1.0p+10)).uintval(), 10'000'001, log);
+        myFunc, otherFunc,
+        /* startingBit= */ FPBits(OutputType(0x1.0p-10)).uintval(),
+        /* endingBit= */ FPBits(OutputType(0x1.0p+10)).uintval(), 10'000'001,
+        log);
 
     log << "Total number of differing results: " << diffCount << '\n';
   }
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
-#define BINARY_OP_SINGLE_OUTPUT_PERF(T, myFunc, otherFunc, filename)           \
+#define BINARY_OP_SINGLE_OUTPUT_PERF(OutputType, InputType, myFunc, otherFunc, \
+                                     filename)                                 \
   int main() {                                                                 \
-    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<T>::run_perf(            \
-        &myFunc, &otherFunc, 1, filename);                                     \
+    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<                         \
+        OutputType, InputType>::run_perf(&myFunc, &otherFunc, 1, filename);    \
     return 0;                                                                  \
   }
 
-#define BINARY_OP_SINGLE_OUTPUT_PERF_EX(T, myFunc, otherFunc, rounds,          \
-                                        filename)                              \
+#define BINARY_OP_SINGLE_OUTPUT_PERF_EX(OutputType, InputType, myFunc,         \
+                                        otherFunc, rounds, filename)           \
   {                                                                            \
-    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<T>::run_perf(            \
-        &myFunc, &otherFunc, rounds, filename);                                \
-    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<T>::run_perf(            \
-        &myFunc, &otherFunc, rounds, filename);                                \
+    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<                         \
+        OutputType, InputType>::run_perf(&myFunc, &otherFunc, rounds,          \
+                                         filename);                            \
+    LIBC_NAMESPACE::testing::BinaryOpSingleOutputPerf<                         \
+        OutputType, InputType>::run_perf(&myFunc, &otherFunc, rounds,          \
+                                         filename);                            \
   }
diff --git a/test/src/math/performance_testing/SingleInputSingleOutputPerf.h b/test/src/math/performance_testing/SingleInputSingleOutputPerf.h
index b5b3831..efad125 100644
--- a/test/src/math/performance_testing/SingleInputSingleOutputPerf.h
+++ b/test/src/math/performance_testing/SingleInputSingleOutputPerf.h
@@ -6,12 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/algorithm.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/config.h"
 #include "test/src/math/performance_testing/Timer.h"
 
 #include <fstream>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 template <typename T> class SingleInputSingleOutputPerf {
@@ -25,16 +27,21 @@ public:
 
   static void runPerfInRange(Func myFunc, Func otherFunc,
                              StorageType startingBit, StorageType endingBit,
-                             std::ofstream &log) {
+                             size_t rounds, std::ofstream &log) {
+    size_t n = 10'010'001;
+    if (sizeof(StorageType) <= sizeof(size_t))
+      n = cpp::min(n, static_cast<size_t>(endingBit - startingBit));
+
     auto runner = [=](Func func) {
-      constexpr StorageType N = 10'010'001;
-      StorageType step = (endingBit - startingBit) / N;
+      StorageType step = (endingBit - startingBit) / n;
       if (step == 0)
         step = 1;
-      volatile T result;
-      for (StorageType bits = startingBit; bits < endingBit; bits += step) {
-        T x = FPBits(bits).get_val();
-        result = func(x);
+      [[maybe_unused]] volatile T result;
+      for (size_t i = 0; i < rounds; i++) {
+        for (StorageType bits = startingBit; bits < endingBit; bits += step) {
+          T x = FPBits(bits).get_val();
+          result = func(x);
+        }
       }
     };
 
@@ -43,8 +50,7 @@ public:
     runner(myFunc);
     timer.stop();
 
-    StorageType numberOfRuns = endingBit - startingBit + 1;
-    double myAverage = static_cast<double>(timer.nanoseconds()) / numberOfRuns;
+    double myAverage = static_cast<double>(timer.nanoseconds()) / n / rounds;
     log << "-- My function --\n";
     log << "     Total time      : " << timer.nanoseconds() << " ns \n";
     log << "     Average runtime : " << myAverage << " ns/op \n";
@@ -55,8 +61,7 @@ public:
     runner(otherFunc);
     timer.stop();
 
-    double otherAverage =
-        static_cast<double>(timer.nanoseconds()) / numberOfRuns;
+    double otherAverage = static_cast<double>(timer.nanoseconds()) / n / rounds;
     log << "-- Other function --\n";
     log << "     Total time      : " << timer.nanoseconds() << " ns \n";
     log << "     Average runtime : " << otherAverage << " ns/op \n";
@@ -67,24 +72,34 @@ public:
     log << "     Mine / Other's  : " << myAverage / otherAverage << " \n";
   }
 
-  static void runPerf(Func myFunc, Func otherFunc, const char *logFile) {
+  static void runPerf(Func myFunc, Func otherFunc, size_t rounds,
+                      const char *logFile) {
     std::ofstream log(logFile);
     log << " Performance tests with inputs in denormal range:\n";
     runPerfInRange(myFunc, otherFunc, /* startingBit= */ StorageType(0),
-                   /* endingBit= */ FPBits::max_subnormal().uintval(), log);
+                   /* endingBit= */ FPBits::max_subnormal().uintval(), rounds,
+                   log);
     log << "\n Performance tests with inputs in normal range:\n";
     runPerfInRange(myFunc, otherFunc,
                    /* startingBit= */ FPBits::min_normal().uintval(),
-                   /* endingBit= */ FPBits::max_normal().uintval(), log);
+                   /* endingBit= */ FPBits::max_normal().uintval(), rounds,
+                   log);
   }
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define SINGLE_INPUT_SINGLE_OUTPUT_PERF(T, myFunc, otherFunc, filename)        \
   int main() {                                                                 \
     LIBC_NAMESPACE::testing::SingleInputSingleOutputPerf<T>::runPerf(          \
-        &myFunc, &otherFunc, filename);                                        \
+        &myFunc, &otherFunc, 1, filename);                                     \
     return 0;                                                                  \
   }
+
+#define SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(T, myFunc, otherFunc, rounds,       \
+                                           filename)                           \
+  {                                                                            \
+    LIBC_NAMESPACE::testing::SingleInputSingleOutputPerf<T>::runPerf(          \
+        &myFunc, &otherFunc, rounds, filename);                                \
+  }
diff --git a/test/src/math/performance_testing/Timer.cpp b/test/src/math/performance_testing/Timer.cpp
index 979196a..6ab0063 100644
--- a/test/src/math/performance_testing/Timer.cpp
+++ b/test/src/math/performance_testing/Timer.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "Timer.h"
+#include "src/__support/macros/config.h"
 
 #include <chrono>
 #include <fstream>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 struct TimerImplementation {
@@ -39,4 +40,4 @@ uint64_t Timer::nanoseconds() const {
 }
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/math/performance_testing/Timer.h b/test/src/math/performance_testing/Timer.h
index 2327ede..32578ad 100644
--- a/test/src/math/performance_testing/Timer.h
+++ b/test/src/math/performance_testing/Timer.h
@@ -9,9 +9,10 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_PERFORMACE_TESTING_TIMER_H
 #define LLVM_LIBC_TEST_SRC_MATH_PERFORMACE_TESTING_TIMER_H
 
+#include "src/__support/macros/config.h"
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 class Timer {
@@ -28,6 +29,6 @@ public:
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_SRC_MATH_PERFORMANCE_TESTING_TIMER_H
diff --git a/test/src/math/performance_testing/exp10f16_perf.cpp b/test/src/math/performance_testing/exp10f16_perf.cpp
new file mode 100644
index 0000000..b9e76d4
--- /dev/null
+++ b/test/src/math/performance_testing/exp10f16_perf.cpp
@@ -0,0 +1,22 @@
+//===-- Performance test for exp10f16 -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SingleInputSingleOutputPerf.h"
+
+#include "src/math/exp10f16.h"
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+static float16 placeholderf16(float16 x) { return x; }
+
+int main() {
+  SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(float16, LIBC_NAMESPACE::exp10f16,
+                                     ::placeholderf16, 20'000,
+                                     "exp10f16_perf.log")
+}
diff --git a/test/src/math/performance_testing/exp2f16_perf.cpp b/test/src/math/performance_testing/exp2f16_perf.cpp
new file mode 100644
index 0000000..aa58de2
--- /dev/null
+++ b/test/src/math/performance_testing/exp2f16_perf.cpp
@@ -0,0 +1,22 @@
+//===-- Performance test for exp2f16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SingleInputSingleOutputPerf.h"
+
+#include "src/math/exp2f16.h"
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+static float16 placeholderf16(float16 x) { return x; }
+
+int main() {
+  SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(float16, LIBC_NAMESPACE::exp2f16,
+                                     ::placeholderf16, 20'000,
+                                     "exp2f16_perf.log")
+}
diff --git a/test/src/math/performance_testing/expf16_perf.cpp b/test/src/math/performance_testing/expf16_perf.cpp
new file mode 100644
index 0000000..bc9d9f0
--- /dev/null
+++ b/test/src/math/performance_testing/expf16_perf.cpp
@@ -0,0 +1,22 @@
+//===-- Performance test for expf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SingleInputSingleOutputPerf.h"
+
+#include "src/math/expf16.h"
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+static float16 placeholderf16(float16 x) { return x; }
+
+int main() {
+  SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(float16, LIBC_NAMESPACE::expf16,
+                                     ::placeholderf16, 20'000,
+                                     "expf16_perf.log")
+}
diff --git a/test/src/math/performance_testing/fmod_perf.cpp b/test/src/math/performance_testing/fmod_perf.cpp
index fa9b4c6..75a4242 100644
--- a/test/src/math/performance_testing/fmod_perf.cpp
+++ b/test/src/math/performance_testing/fmod_perf.cpp
@@ -12,5 +12,5 @@
 
 #include <math.h>
 
-BINARY_OP_SINGLE_OUTPUT_PERF(double, LIBC_NAMESPACE::fmod, ::fmod,
+BINARY_OP_SINGLE_OUTPUT_PERF(double, double, LIBC_NAMESPACE::fmod, ::fmod,
                              "fmod_perf.log")
diff --git a/test/src/math/performance_testing/fmodf16_perf.cpp b/test/src/math/performance_testing/fmodf16_perf.cpp
index ff01fa6..062bc2d 100644
--- a/test/src/math/performance_testing/fmodf16_perf.cpp
+++ b/test/src/math/performance_testing/fmodf16_perf.cpp
@@ -16,11 +16,11 @@
 #define FMOD_FUNC(U) (LIBC_NAMESPACE::fputil::generic::FMod<float16, U>::eval)
 
 int main() {
-  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, FMOD_FUNC(uint16_t),
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, FMOD_FUNC(uint16_t),
                                   FMOD_FUNC(uint32_t), 5000,
                                   "fmodf16_u16_vs_u32_perf.log")
 
-  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, FMOD_FUNC(uint16_t),
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, FMOD_FUNC(uint16_t),
                                   FMOD_FUNC(uint64_t), 5000,
                                   "fmodf16_u16_vs_u64_perf.log")
   return 0;
diff --git a/test/src/math/performance_testing/fmodf_perf.cpp b/test/src/math/performance_testing/fmodf_perf.cpp
index f13f02e..b4f37ef 100644
--- a/test/src/math/performance_testing/fmodf_perf.cpp
+++ b/test/src/math/performance_testing/fmodf_perf.cpp
@@ -12,5 +12,5 @@
 
 #include <math.h>
 
-BINARY_OP_SINGLE_OUTPUT_PERF(float, LIBC_NAMESPACE::fmodf, ::fmodf,
+BINARY_OP_SINGLE_OUTPUT_PERF(float, float, LIBC_NAMESPACE::fmodf, ::fmodf,
                              "fmodf_perf.log")
diff --git a/test/src/math/performance_testing/fmul_perf.cpp b/test/src/math/performance_testing/fmul_perf.cpp
new file mode 100644
index 0000000..f15cfaf
--- /dev/null
+++ b/test/src/math/performance_testing/fmul_perf.cpp
@@ -0,0 +1,24 @@
+//===-- Performance test for the fmul function ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BinaryOpSingleOutputPerf.h"
+#include "src/__support/FPUtil/generic/mul.h"
+#include "src/math/fmul.h"
+
+static constexpr size_t DOUBLE_ROUNDS = 40;
+
+float fmul_placeholder_binary(double x, double y) {
+  return LIBC_NAMESPACE::fputil::generic::mul<float>(x, y);
+}
+
+int main() {
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, double, LIBC_NAMESPACE::fmul,
+                                  fmul_placeholder_binary, DOUBLE_ROUNDS,
+                                  "fmul_perf.log")
+  return 0;
+}
diff --git a/test/src/math/performance_testing/fmull_perf.cpp b/test/src/math/performance_testing/fmull_perf.cpp
new file mode 100644
index 0000000..058e102
--- /dev/null
+++ b/test/src/math/performance_testing/fmull_perf.cpp
@@ -0,0 +1,23 @@
+//===-- Performance test for the fmull function ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BinaryOpSingleOutputPerf.h"
+#include "src/math/fmull.h"
+
+static constexpr size_t LONG_DOUBLE_ROUNDS = 40;
+
+float fmull_placeholder_binary(long double x, long double y) {
+  return static_cast<float>(x * y);
+}
+
+int main() {
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, long double, LIBC_NAMESPACE::fmull,
+                                  fmull_placeholder_binary, LONG_DOUBLE_ROUNDS,
+                                  "fmull_perf.log")
+  return 0;
+}
diff --git a/test/src/math/performance_testing/hypot_perf.cpp b/test/src/math/performance_testing/hypot_perf.cpp
index 393697b..04a493f 100644
--- a/test/src/math/performance_testing/hypot_perf.cpp
+++ b/test/src/math/performance_testing/hypot_perf.cpp
@@ -12,5 +12,5 @@
 
 #include <math.h>
 
-BINARY_OP_SINGLE_OUTPUT_PERF(double, LIBC_NAMESPACE::hypot, ::hypot,
+BINARY_OP_SINGLE_OUTPUT_PERF(double, double, LIBC_NAMESPACE::hypot, ::hypot,
                              "hypot_perf.log")
diff --git a/test/src/math/performance_testing/hypotf_perf.cpp b/test/src/math/performance_testing/hypotf_perf.cpp
index f711729..8a42f79 100644
--- a/test/src/math/performance_testing/hypotf_perf.cpp
+++ b/test/src/math/performance_testing/hypotf_perf.cpp
@@ -12,5 +12,5 @@
 
 #include <math.h>
 
-BINARY_OP_SINGLE_OUTPUT_PERF(float, LIBC_NAMESPACE::hypotf, ::hypotf,
+BINARY_OP_SINGLE_OUTPUT_PERF(float, float, LIBC_NAMESPACE::hypotf, ::hypotf,
                              "hypotf_perf.log")
diff --git a/test/src/math/performance_testing/max_min_funcs_perf.cpp b/test/src/math/performance_testing/max_min_funcs_perf.cpp
new file mode 100644
index 0000000..b77268d
--- /dev/null
+++ b/test/src/math/performance_testing/max_min_funcs_perf.cpp
@@ -0,0 +1,75 @@
+//===-- Performance test for maximum and minimum functions ----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BinaryOpSingleOutputPerf.h"
+#include "src/math/fmaxf.h"
+#include "src/math/fmaxf16.h"
+#include "src/math/fmaximum_numf.h"
+#include "src/math/fmaximum_numf16.h"
+#include "src/math/fmaximumf.h"
+#include "src/math/fmaximumf16.h"
+#include "src/math/fminf.h"
+#include "src/math/fminf16.h"
+#include "src/math/fminimum_numf.h"
+#include "src/math/fminimum_numf16.h"
+#include "src/math/fminimumf.h"
+#include "src/math/fminimumf16.h"
+
+#include <math.h>
+
+static constexpr size_t FLOAT16_ROUNDS = 20'000;
+static constexpr size_t FLOAT_ROUNDS = 40;
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+float16 placeholder_binaryf16(float16 x, float16 y) { return x; }
+
+// The system libc might not provide the fmaximum* and fminimum* C23 math
+// functions either.
+float placeholder_binaryf(float x, float y) { return x; }
+
+int main() {
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, LIBC_NAMESPACE::fmaxf16,
+                                  placeholder_binaryf16, FLOAT16_ROUNDS,
+                                  "fmaxf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, LIBC_NAMESPACE::fminf16,
+                                  placeholder_binaryf16, FLOAT16_ROUNDS,
+                                  "fminf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, LIBC_NAMESPACE::fmaximumf16,
+                                  placeholder_binaryf16, FLOAT16_ROUNDS,
+                                  "fmaximumf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, LIBC_NAMESPACE::fminimumf16,
+                                  placeholder_binaryf16, FLOAT16_ROUNDS,
+                                  "fminimumf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(
+      float16, float16, LIBC_NAMESPACE::fmaximum_numf16, placeholder_binaryf16,
+      FLOAT16_ROUNDS, "fmaximum_numf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(
+      float16, float16, LIBC_NAMESPACE::fminimum_numf16, placeholder_binaryf16,
+      FLOAT16_ROUNDS, "fminimum_numf16_perf.log")
+
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fmaxf, ::fmaxf,
+                                  FLOAT_ROUNDS, "fmaxf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fminf, ::fminf,
+                                  FLOAT_ROUNDS, "fminf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fmaximumf,
+                                  placeholder_binaryf, FLOAT_ROUNDS,
+                                  "fmaximumf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fminimumf,
+                                  placeholder_binaryf, FLOAT_ROUNDS,
+                                  "fminimumf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fmaximum_numf,
+                                  placeholder_binaryf, FLOAT_ROUNDS,
+                                  "fmaximum_numf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::fminimum_numf,
+                                  placeholder_binaryf, FLOAT_ROUNDS,
+                                  "fminimum_numf_perf.log")
+
+  return 0;
+}
diff --git a/test/src/math/performance_testing/misc_basic_ops_perf.cpp b/test/src/math/performance_testing/misc_basic_ops_perf.cpp
new file mode 100644
index 0000000..9a4522c
--- /dev/null
+++ b/test/src/math/performance_testing/misc_basic_ops_perf.cpp
@@ -0,0 +1,41 @@
+//===-- Performance test for miscellaneous basic operations ---------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BinaryOpSingleOutputPerf.h"
+#include "SingleInputSingleOutputPerf.h"
+#include "src/math/copysignf.h"
+#include "src/math/copysignf16.h"
+#include "src/math/fabsf.h"
+#include "src/math/fabsf16.h"
+
+#include <math.h>
+
+static constexpr size_t FLOAT16_ROUNDS = 20'000;
+static constexpr size_t FLOAT_ROUNDS = 40;
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+float16 placeholder_unaryf16(float16 x) { return x; }
+float16 placeholder_binaryf16(float16 x, float16 y) { return x; }
+
+int main() {
+  SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(float16, LIBC_NAMESPACE::fabsf16,
+                                     placeholder_unaryf16, FLOAT16_ROUNDS,
+                                     "fabsf16_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float16, float16, LIBC_NAMESPACE::copysignf16,
+                                  placeholder_binaryf16, FLOAT16_ROUNDS,
+                                  "copysignf16_perf.log")
+
+  SINGLE_INPUT_SINGLE_OUTPUT_PERF_EX(float, LIBC_NAMESPACE::fabsf, fabsf,
+                                     FLOAT_ROUNDS, "fabsf_perf.log")
+  BINARY_OP_SINGLE_OUTPUT_PERF_EX(float, float, LIBC_NAMESPACE::copysignf,
+                                  copysignf, FLOAT_ROUNDS, "copysignf_perf.log")
+
+  return 0;
+}
diff --git a/test/src/math/performance_testing/nearest_integer_funcs_perf.cpp b/test/src/math/performance_testing/nearest_integer_funcs_perf.cpp
new file mode 100644
index 0000000..b7bd663
--- /dev/null
+++ b/test/src/math/performance_testing/nearest_integer_funcs_perf.cpp
@@ -0,0 +1,199 @@
+//===-- Performance test for nearest integer functions --------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/ceilf.h"
+#include "src/math/ceilf16.h"
+#include "src/math/floorf.h"
+#include "src/math/floorf16.h"
+#include "src/math/rintf.h"
+#include "src/math/rintf16.h"
+#include "src/math/roundevenf.h"
+#include "src/math/roundevenf16.h"
+#include "src/math/roundf.h"
+#include "src/math/roundf16.h"
+#include "src/math/truncf.h"
+#include "src/math/truncf16.h"
+#include "test/UnitTest/RoundingModeUtils.h"
+#include "test/src/math/performance_testing/Timer.h"
+
+#include <fstream>
+#include <math.h>
+
+using LIBC_NAMESPACE::fputil::testing::ForceRoundingMode;
+using LIBC_NAMESPACE::fputil::testing::RoundingMode;
+
+namespace LIBC_NAMESPACE::testing {
+
+template <typename T> class NearestIntegerPerf {
+  using FPBits = fputil::FPBits<T>;
+  using StorageType = typename FPBits::StorageType;
+
+public:
+  typedef T Func(T);
+
+  static void run_perf_in_range(Func my_func, Func other_func,
+                                StorageType starting_bit,
+                                StorageType ending_bit, StorageType step,
+                                size_t rounds, std::ofstream &log) {
+    auto runner = [=](Func func) {
+      [[maybe_unused]] volatile T result;
+      for (size_t i = 0; i < rounds; i++) {
+        for (StorageType bits = starting_bit; bits <= ending_bit;
+             bits += step) {
+          T x = FPBits(bits).get_val();
+          result = func(x);
+        }
+      }
+    };
+
+    Timer timer;
+    timer.start();
+    runner(my_func);
+    timer.stop();
+
+    size_t number_of_runs = (ending_bit - starting_bit) / step + 1;
+    double my_average =
+        static_cast<double>(timer.nanoseconds()) / number_of_runs / rounds;
+    log << "-- My function --\n";
+    log << "     Total time      : " << timer.nanoseconds() << " ns \n";
+    log << "     Average runtime : " << my_average << " ns/op \n";
+    log << "     Ops per second  : "
+        << static_cast<uint64_t>(1'000'000'000.0 / my_average) << " op/s \n";
+
+    timer.start();
+    runner(other_func);
+    timer.stop();
+
+    double other_average =
+        static_cast<double>(timer.nanoseconds()) / number_of_runs / rounds;
+    log << "-- Other function --\n";
+    log << "     Total time      : " << timer.nanoseconds() << " ns \n";
+    log << "     Average runtime : " << other_average << " ns/op \n";
+    log << "     Ops per second  : "
+        << static_cast<uint64_t>(1'000'000'000.0 / other_average) << " op/s \n";
+
+    log << "-- Average runtime ratio --\n";
+    log << "     Mine / Other's  : " << my_average / other_average << " \n";
+  }
+
+  static void run_perf(Func my_func, Func other_func, size_t rounds,
+                       const char *log_file) {
+    std::ofstream log(log_file);
+    log << "Performance tests with inputs in normal integral range:\n";
+    run_perf_in_range(
+        my_func, other_func,
+        /*starting_bit=*/StorageType((FPBits::EXP_BIAS + 1) << FPBits::SIG_LEN),
+        /*ending_bit=*/
+        StorageType((FPBits::EXP_BIAS + FPBits::FRACTION_LEN - 1)
+                    << FPBits::SIG_LEN),
+        /*step=*/StorageType(1 << FPBits::SIG_LEN),
+        rounds * FPBits::EXP_BIAS * FPBits::EXP_BIAS * 2, log);
+    log << "\n Performance tests with inputs in low integral range:\n";
+    run_perf_in_range(
+        my_func, other_func,
+        /*starting_bit=*/StorageType(1 << FPBits::SIG_LEN),
+        /*ending_bit=*/StorageType((FPBits::EXP_BIAS - 1) << FPBits::SIG_LEN),
+        /*step_bit=*/StorageType(1 << FPBits::SIG_LEN),
+        rounds * FPBits::EXP_BIAS * FPBits::EXP_BIAS * 2, log);
+    log << "\n Performance tests with inputs in high integral range:\n";
+    run_perf_in_range(
+        my_func, other_func,
+        /*starting_bit=*/
+        StorageType((FPBits::EXP_BIAS + FPBits::FRACTION_LEN)
+                    << FPBits::SIG_LEN),
+        /*ending_bit=*/
+        StorageType(FPBits::MAX_BIASED_EXPONENT << FPBits::SIG_LEN),
+        /*step=*/StorageType(1 << FPBits::SIG_LEN),
+        rounds * FPBits::EXP_BIAS * FPBits::EXP_BIAS * 2, log);
+    log << "\n Performance tests with inputs in normal fractional range:\n";
+    run_perf_in_range(
+        my_func, other_func,
+        /*starting_bit=*/
+        StorageType(((FPBits::EXP_BIAS + 1) << FPBits::SIG_LEN) + 1),
+        /*ending_bit=*/
+        StorageType(((FPBits::EXP_BIAS + 2) << FPBits::SIG_LEN) - 1),
+        /*step=*/StorageType(1), rounds * 2, log);
+    log << "\n Performance tests with inputs in subnormal fractional range:\n";
+    run_perf_in_range(my_func, other_func, /*starting_bit=*/StorageType(1),
+                      /*ending_bit=*/StorageType(FPBits::SIG_MASK),
+                      /*step=*/StorageType(1), rounds, log);
+  }
+};
+
+} // namespace LIBC_NAMESPACE::testing
+
+#define NEAREST_INTEGER_PERF(T, my_func, other_func, rounds, filename)         \
+  {                                                                            \
+    LIBC_NAMESPACE::testing::NearestIntegerPerf<T>::run_perf(                  \
+        &my_func, &other_func, rounds, filename);                              \
+    LIBC_NAMESPACE::testing::NearestIntegerPerf<T>::run_perf(                  \
+        &my_func, &other_func, rounds, filename);                              \
+  }
+
+static constexpr size_t FLOAT16_ROUNDS = 20'000;
+static constexpr size_t FLOAT_ROUNDS = 40;
+
+// LLVM libc might be the only libc implementation with support for float16 math
+// functions currently. We can't compare our float16 functions against the
+// system libc, so we compare them against this placeholder function.
+float16 placeholderf16(float16 x) { return x; }
+
+// The system libc might not provide the roundeven* C23 math functions either.
+float placeholderf(float x) { return x; }
+
+int main() {
+  NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::ceilf16, ::placeholderf16,
+                       FLOAT16_ROUNDS, "ceilf16_perf.log")
+  NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::floorf16, ::placeholderf16,
+                       FLOAT16_ROUNDS, "floorf16_perf.log")
+  NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::roundf16, ::placeholderf16,
+                       FLOAT16_ROUNDS, "roundf16_perf.log")
+  NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::roundevenf16, ::placeholderf16,
+                       FLOAT16_ROUNDS, "roundevenf16_perf.log")
+  NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::truncf16, ::placeholderf16,
+                       FLOAT16_ROUNDS, "truncf16_perf.log")
+
+  NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::ceilf, ::ceilf, FLOAT_ROUNDS,
+                       "ceilf_perf.log")
+  NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::floorf, ::floorf, FLOAT_ROUNDS,
+                       "floorf_perf.log")
+  NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::roundf, ::roundf, FLOAT_ROUNDS,
+                       "roundf_perf.log")
+  NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::roundevenf, ::placeholderf,
+                       FLOAT_ROUNDS, "roundevenf_perf.log")
+  NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::truncf, ::truncf, FLOAT_ROUNDS,
+                       "truncf_perf.log")
+
+  if (ForceRoundingMode r(RoundingMode::Upward); r.success) {
+    NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::rintf16, ::placeholderf16,
+                         FLOAT16_ROUNDS, "rintf16_upward_perf.log")
+    NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::rintf, ::rintf, FLOAT_ROUNDS,
+                         "rintf_upward_perf.log")
+  }
+  if (ForceRoundingMode r(RoundingMode::Downward); r.success) {
+    NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::rintf16, ::placeholderf16,
+                         FLOAT16_ROUNDS, "rintf16_downward_perf.log")
+    NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::rintf, ::rintf, FLOAT_ROUNDS,
+                         "rintf_downward_perf.log")
+  }
+  if (ForceRoundingMode r(RoundingMode::TowardZero); r.success) {
+    NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::rintf16, ::placeholderf16,
+                         FLOAT16_ROUNDS, "rintf16_towardzero_perf.log")
+    NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::rintf, ::rintf, FLOAT_ROUNDS,
+                         "rintf_towardzero_perf.log")
+  }
+  if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
+    NEAREST_INTEGER_PERF(float16, LIBC_NAMESPACE::rintf16, ::placeholderf16,
+                         FLOAT16_ROUNDS, "rintf16_nearest_perf.log")
+    NEAREST_INTEGER_PERF(float, LIBC_NAMESPACE::rintf, ::rintf, FLOAT_ROUNDS,
+                         "rintf_nearest_perf.log")
+  }
+
+  return 0;
+}
diff --git a/test/src/math/pow_test.cpp b/test/src/math/pow_test.cpp
new file mode 100644
index 0000000..20e3ddf
--- /dev/null
+++ b/test/src/math/pow_test.cpp
@@ -0,0 +1,118 @@
+//===-- Unittests for pow -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/pow.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcPowTest = LIBC_NAMESPACE::testing::FPTest<double>;
+using LIBC_NAMESPACE::testing::tlog;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcPowTest, TrickyInputs) {
+  constexpr mpfr::BinaryInput<double> INPUTS[] = {
+      {0x1.0853408534085p-2, 0x1.0d148e03bcba8p-1},
+      {0x1.65fbd65fbd657p-1, 0x1.f10d148e03bb6p+1},
+      {0x1.c046a084d2e12p-1, 0x1.1f9p+12},
+      {0x1.ae37ed1670326p-1, 0x1.f967df66a202p-1},
+      {0x1.ffffffffffffcp-1, 0x1.fffffffffffffp-2},
+      {0x1.f558a88a8aadep-1, 0x1.88ap+12},
+      {0x1.e84d32731e593p-1, 0x1.2cb8p+13},
+      {0x1.ffffffffffffcp-1, 0x1.fffffffffffffp-2},
+  };
+
+  for (auto input : INPUTS) {
+    double x = input.x;
+    double y = input.y;
+    EXPECT_MPFR_MATCH(mpfr::Operation::Pow, input, LIBC_NAMESPACE::pow(x, y),
+                      1.5);
+  }
+}
+
+TEST_F(LlvmLibcPowTest, InFloatRange) {
+  constexpr uint64_t X_COUNT = 123;
+  constexpr uint64_t X_START = FPBits(0.25).uintval();
+  constexpr uint64_t X_STOP = FPBits(4.0).uintval();
+  constexpr uint64_t X_STEP = (X_STOP - X_START) / X_COUNT;
+
+  constexpr uint64_t Y_COUNT = 137;
+  constexpr uint64_t Y_START = FPBits(0.25).uintval();
+  constexpr uint64_t Y_STOP = FPBits(4.0).uintval();
+  constexpr uint64_t Y_STEP = (Y_STOP - Y_START) / Y_COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode __r(rounding_mode);
+    if (!__r.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t count = 0;
+    uint64_t cc = 0;
+    double mx = 0.0, my = 0.0, mr = 0.0;
+    double tol = 1.5;
+
+    for (uint64_t i = 0, v = X_START; i <= X_COUNT; ++i, v += X_STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(x).is_inf_or_nan() || x < 0.0)
+        continue;
+
+      for (uint64_t j = 0, w = Y_START; j <= Y_COUNT; ++j, w += Y_STEP) {
+        double y = FPBits(w).get_val();
+        if (FPBits(y).is_inf_or_nan())
+          continue;
+
+        double result = LIBC_NAMESPACE::pow(x, y);
+        ++cc;
+        if (FPBits(result).is_inf_or_nan())
+          continue;
+
+        ++count;
+        mpfr::BinaryInput<double> inputs{x, y};
+
+        if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Pow, inputs,
+                                               result, 1.5, rounding_mode)) {
+          ++fails;
+          while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(
+              mpfr::Operation::Pow, inputs, result, tol, rounding_mode)) {
+            mx = x;
+            my = y;
+            mr = result;
+
+            if (tol > 1000.0)
+              break;
+
+            tol *= 2.0;
+          }
+        }
+      }
+    }
+    if (fails || (count < cc)) {
+      tlog << " Pow failed: " << fails << "/" << count << "/" << cc
+           << " tests.\n"
+           << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
+    }
+    if (fails) {
+      mpfr::BinaryInput<double> inputs{mx, my};
+      EXPECT_MPFR_MATCH(mpfr::Operation::Pow, inputs, mr, 1.5, rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/powf_test.cpp b/test/src/math/powf_test.cpp
index 797913e..448dcc00 100644
--- a/test/src/math/powf_test.cpp
+++ b/test/src/math/powf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcPowfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -71,18 +70,18 @@ TEST_F(LlvmLibcPowfTest, InFloatRange) {
 
     for (uint32_t i = 0, v = X_START; i <= X_COUNT; ++i, v += X_STEP) {
       float x = FPBits(v).get_val();
-      if (isnan(x) || isinf(x) || x < 0.0)
+      if (FPBits(v).is_nan() || FPBits(v).is_inf() || x < 0.0)
         continue;
 
       for (uint32_t j = 0, w = Y_START; j <= Y_COUNT; ++j, w += Y_STEP) {
         float y = FPBits(w).get_val();
-        if (isnan(y) || isinf(y))
+        if (FPBits(w).is_nan() || FPBits(w).is_inf())
           continue;
 
         LIBC_NAMESPACE::libc_errno = 0;
         float result = LIBC_NAMESPACE::powf(x, y);
         ++cc;
-        if (isnan(result) || isinf(result))
+        if (FPBits(result).is_nan() || FPBits(result).is_inf())
           continue;
 
         ++count;
diff --git a/test/src/math/sdcomp26094.h b/test/src/math/sdcomp26094.h
index 4a77b2a..bb2b9f1 100644
--- a/test/src/math/sdcomp26094.h
+++ b/test/src/math/sdcomp26094.h
@@ -10,10 +10,11 @@
 #define LLVM_LIBC_TEST_SRC_MATH_SDCOMP26094_H
 
 #include "src/__support/CPP/array.h"
+#include "src/__support/macros/config.h"
 
 #include <stdint.h>
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 static constexpr LIBC_NAMESPACE::cpp::array<uint32_t, 10> SDCOMP26094_VALUES{
@@ -22,6 +23,6 @@ static constexpr LIBC_NAMESPACE::cpp::array<uint32_t, 10> SDCOMP26094_VALUES{
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_SRC_MATH_SDCOMP26094_H
diff --git a/test/src/math/sin_test.cpp b/test/src/math/sin_test.cpp
index 0171b79..d4c6bd4 100644
--- a/test/src/math/sin_test.cpp
+++ b/test/src/math/sin_test.cpp
@@ -12,22 +12,105 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include "hdr/math_macros.h"
-
 using LlvmLibcSinTest = LIBC_NAMESPACE::testing::FPTest<double>;
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
-TEST_F(LlvmLibcSinTest, Range) {
-  static constexpr double _2pi = 6.283185307179586;
-  constexpr StorageType COUNT = 100'000;
-  constexpr StorageType STEP = STORAGE_MAX / COUNT;
-  for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
-    double x = FPBits(v).get_val();
-    // TODO: Expand the range of testing after range reduction is implemented.
-    if (isnan(x) || isinf(x) || x > _2pi || x < -_2pi)
-      continue;
-
-    ASSERT_MPFR_MATCH(mpfr::Operation::Sin, x, LIBC_NAMESPACE::sin(x), 1.0);
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcSinTest, TrickyInputs) {
+  constexpr double INPUTS[] = {
+      0x1.5f09cad750ab1p+3,    0x1.fff781921b61fp15,   -0x1.f635b70b92407p-21,
+      -0x1.3ecf146c39c0cp-20,  0x1.6ac5b262ca1ffp849,  0x1.6c6cbc45dc8dep5,
+      0x1.921fb5443p-7,        0x1.940c877fb7dacp-7,   0x1.fffffffffdb6p24,
+      0x1.fd4da4ef37075p29,    0x1.b951f1572eba5p+31,  0x1.55202aefde314p+31,
+      0x1.85fc0f04c0128p101,   0x1.7776c2343ba4ep101,  0x1.678309fa50d58p110,
+      0x1.fffffffffef4ep199,   -0x1.ab514bfc61c76p+7,  -0x1.f7898d5a756ddp+2,
+      -0x1.f42fb19b5b9b2p-6,   -0x1.14823229799c2p+7,  -0x1.0285070f9f1bcp-5,
+      0x1.23f40dccdef72p+0,    0x1.43cf16358c9d7p+0,   0x1.addf3b9722265p+0,
+      0x1.48ff1782ca91dp+8,    0x1.a211877de55dbp+4,   0x1.dcbfda0c7559ep+8,
+      0x1.1ffb509f3db15p+5,    0x1.2345d1e090529p+5,   0x1.ae945054939c2p+10,
+      0x1.2e566149bf5fdp+9,    0x1.be886d9c2324dp+6,   -0x1.119471e9216cdp+10,
+      -0x1.aaf85537ea4c7p+3,   0x1.cb996c60f437ep+9,   0x1.c96e28eb679f8p+5,
+      -0x1.a5eece87e8606p+4,   0x1.e31b55306f22cp+2,   0x1.ae78d360afa15p+0,
+      0x1.1685973506319p+3,    0x1.4f2b874135d27p+4,   0x1.ae945054939c2p+10,
+      0x1.3eec5912ea7cdp+331,  0x1.dcbfda0c7559ep+8,   0x1.a65d441ea6dcep+4,
+      0x1.e639103a05997p+2,    0x1.13114266f9764p+4,   -0x1.3eec5912ea7cdp+331,
+      0x1.08087e9aad90bp+887,  0x1.2b5fe88a9d8d5p+903, -0x1.a880417b7b119p+1023,
+      -0x1.6deb37da81129p+205, 0x1.08087e9aad90bp+887, 0x1.f6d7518808571p+1023,
+      -0x1.8bb5847d49973p+845, 0x1.f08b14e1c4d0fp+890, 0x1.6ac5b262ca1ffp+849,
+      0x1.e0000000001c2p-20,
+  };
+  constexpr int N = sizeof(INPUTS) / sizeof(INPUTS[0]);
+
+  for (int i = 0; i < N; ++i) {
+    double x = INPUTS[i];
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sin, x,
+                                   LIBC_NAMESPACE::sin(x), 0.5);
   }
 }
+
+TEST_F(LlvmLibcSinTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 1'234'51;
+  uint64_t START = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p-50).uintval();
+  uint64_t STOP = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p200).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode __r(rounding_mode);
+    if (!__r.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t count = 0;
+    uint64_t cc = 0;
+    double mx, mr = 0.0;
+    double tol = 0.5;
+
+    for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
+        continue;
+      LIBC_NAMESPACE::libc_errno = 0;
+      double result = LIBC_NAMESPACE::sin(x);
+      ++cc;
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
+        continue;
+
+      ++count;
+
+      if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Sin, x, result,
+                                             0.5, rounding_mode)) {
+        ++fails;
+        while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Sin, x,
+                                                  result, tol, rounding_mode)) {
+          mx = x;
+          mr = result;
+
+          if (tol > 1000.0)
+            break;
+
+          tol *= 2.0;
+        }
+      }
+    }
+    if (fails) {
+      tlog << " Sin failed: " << fails << "/" << count << "/" << cc
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
+      EXPECT_MPFR_MATCH(mpfr::Operation::Sin, mx, mr, 0.5, rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/sincos_test.cpp b/test/src/math/sincos_test.cpp
new file mode 100644
index 0000000..09c8715
--- /dev/null
+++ b/test/src/math/sincos_test.cpp
@@ -0,0 +1,118 @@
+//===-- Unittests for sincos ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/sincos.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcSincosTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+#define ASSERT_SINCOS_MATCH_ALL_ROUNDING(input)                                \
+  do {                                                                         \
+    double sin_x, cos_x;                                                       \
+    namespace mpfr = LIBC_NAMESPACE::testing::mpfr;                            \
+                                                                               \
+    mpfr::ForceRoundingMode __r1(mpfr::RoundingMode::Nearest);                 \
+    if (__r1.success) {                                                        \
+      LIBC_NAMESPACE::sincos(input, &sin_x, &cos_x);                           \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Sin, input, sin_x, 0.5,               \
+                        mpfr::RoundingMode::Nearest);                          \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Cos, input, cos_x, 0.5,               \
+                        mpfr::RoundingMode::Nearest);                          \
+    }                                                                          \
+                                                                               \
+    mpfr::ForceRoundingMode __r2(mpfr::RoundingMode::Upward);                  \
+    if (__r2.success) {                                                        \
+      LIBC_NAMESPACE::sincos(input, &sin_x, &cos_x);                           \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Sin, input, sin_x, 0.5,               \
+                        mpfr::RoundingMode::Upward);                           \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Cos, input, cos_x, 0.5,               \
+                        mpfr::RoundingMode::Upward);                           \
+    }                                                                          \
+                                                                               \
+    mpfr::ForceRoundingMode __r3(mpfr::RoundingMode::Downward);                \
+    if (__r3.success) {                                                        \
+      LIBC_NAMESPACE::sincos(input, &sin_x, &cos_x);                           \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Sin, input, sin_x, 0.5,               \
+                        mpfr::RoundingMode::Downward);                         \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Cos, input, cos_x, 0.5,               \
+                        mpfr::RoundingMode::Downward);                         \
+    }                                                                          \
+                                                                               \
+    mpfr::ForceRoundingMode __r4(mpfr::RoundingMode::TowardZero);              \
+    if (__r4.success) {                                                        \
+      LIBC_NAMESPACE::sincos(input, &sin_x, &cos_x);                           \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Sin, input, sin_x, 0.5,               \
+                        mpfr::RoundingMode::TowardZero);                       \
+      ASSERT_MPFR_MATCH(mpfr::Operation::Cos, input, cos_x, 0.5,               \
+                        mpfr::RoundingMode::TowardZero);                       \
+    }                                                                          \
+  } while (0)
+
+TEST_F(LlvmLibcSincosTest, TrickyInputs) {
+  constexpr double INPUTS[] = {
+      0x1.8000000000009p-23,    0x1.8000000000024p-22,
+      0x1.800000000009p-21,     0x1.20000000000f3p-20,
+      0x1.800000000024p-20,     0x1.e0000000001c2p-20,
+      0x1.940c877fb7dacp-7,     -0x1.f42fb19b5b9b2p-6,
+      -0x1.0285070f9f1bcp-5,    0x1.23f40dccdef72p+0,
+      0x1.43cf16358c9d7p+0,     0x1.addf3b9722265p+0,
+      0x1.ae78d360afa15p+0,     0x1.e31b55306f22cp+2,
+      0x1.e639103a05997p+2,     -0x1.f7898d5a756ddp+2,
+      0x1.1685973506319p+3,     0x1.5f09cad750ab1p+3,
+      -0x1.aaf85537ea4c7p+3,    0x1.4f2b874135d27p+4,
+      0x1.13114266f9764p+4,     0x1.a211877de55dbp+4,
+      -0x1.a5eece87e8606p+4,    0x1.a65d441ea6dcep+4,
+      0x1.1ffb509f3db15p+5,     0x1.2345d1e090529p+5,
+      0x1.c96e28eb679f8p+5,     0x1.be886d9c2324dp+6,
+      -0x1.ab514bfc61c76p+7,    -0x1.14823229799c2p+7,
+      0x1.48ff1782ca91dp+8,     0x1.dcbfda0c7559ep+8,
+      0x1.dcbfda0c7559ep+8,     0x1.2e566149bf5fdp+9,
+      0x1.cb996c60f437ep+9,     0x1.ae945054939c2p+10,
+      -0x1.119471e9216cdp+10,   0x1.ae945054939c2p+10,
+      0x1.fffffffffdb6p+24,     0x1.fd4da4ef37075p+29,
+      0x1.55202aefde314p+31,    0x1.b951f1572eba5p+31,
+      0x1.7776c2343ba4ep+101,   0x1.85fc0f04c0128p+101,
+      0x1.678309fa50d58p+110,   0x1.fffffffffef4ep+199,
+      0x1.3eec5912ea7cdp+331,   -0x1.3eec5912ea7cdp+331,
+      -0x1.6deb37da81129p+205,  0x1.08087e9aad90bp+887,
+      -0x1.08087e9aad90bp+887,  -0x1.8bb5847d49973p+845,
+      0x1.6ac5b262ca1ffp+849,   0x1.f08b14e1c4d0fp+890,
+      0x1.2b5fe88a9d8d5p+903,   0x1.f6d7518808571p+1023,
+      -0x1.a880417b7b119p+1023, 0x1.00a33764a0a83p-7,
+      0x1.fe81868fc47fep+1,     0x1.0da8cc189b47dp-10,
+      0x1.da1838053b866p+5,
+
+  };
+  constexpr int N = sizeof(INPUTS) / sizeof(INPUTS[0]);
+
+  for (int i = 0; i < N; ++i) {
+    ASSERT_SINCOS_MATCH_ALL_ROUNDING(INPUTS[i]);
+  }
+}
+
+TEST_F(LlvmLibcSincosTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 123'41;
+  uint64_t START = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p-50).uintval();
+  uint64_t STOP = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p200).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+    double x = FPBits(v).get_val();
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
+      continue;
+
+    ASSERT_SINCOS_MATCH_ALL_ROUNDING(x);
+  }
+}
diff --git a/test/src/math/sincosf_test.cpp b/test/src/math/sincosf_test.cpp
index 7c359b3..2823110 100644
--- a/test/src/math/sincosf_test.cpp
+++ b/test/src/math/sincosf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/src/math/sdcomp26094.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinCosfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -101,7 +100,7 @@ TEST_F(LlvmLibcSinCosfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
 
     EXPECT_SINCOS_MATCH_ALL_ROUNDING(x);
diff --git a/test/src/math/sinf_test.cpp b/test/src/math/sinf_test.cpp
index 6a8f8f4..8fd3ed1 100644
--- a/test/src/math/sinf_test.cpp
+++ b/test/src/math/sinf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/src/math/sdcomp26094.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -48,7 +47,7 @@ TEST_F(LlvmLibcSinfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sin, x,
                                    LIBC_NAMESPACE::sinf(x), 0.5);
diff --git a/test/src/math/sinhf16_test.cpp b/test/src/math/sinhf16_test.cpp
new file mode 100644
index 0000000..a16ab92
--- /dev/null
+++ b/test/src/math/sinhf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for sinhf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinhf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcSinhf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcSinhf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinh, x,
+                                   LIBC_NAMESPACE::sinhf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcSinhf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinh, x,
+                                   LIBC_NAMESPACE::sinhf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/sinhf_test.cpp b/test/src/math/sinhf_test.cpp
index cc0552f..6867c7a 100644
--- a/test/src/math/sinhf_test.cpp
+++ b/test/src/math/sinhf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -46,7 +45,7 @@ TEST_F(LlvmLibcSinhfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH(mpfr::Operation::Sinh, x, LIBC_NAMESPACE::sinhf(x), 0.5);
   }
diff --git a/test/src/math/sinpif16_test.cpp b/test/src/math/sinpif16_test.cpp
new file mode 100644
index 0000000..8477124
--- /dev/null
+++ b/test/src/math/sinpif16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for sinpif16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#include "src/math/sinpif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcSinpif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcSinpif16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                   LIBC_NAMESPACE::sinpif16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcSinpif16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                   LIBC_NAMESPACE::sinpif16(x), 0.5);
+  }
+}
diff --git a/test/src/math/sinpif_test.cpp b/test/src/math/sinpif_test.cpp
new file mode 100644
index 0000000..d00fd77
--- /dev/null
+++ b/test/src/math/sinpif_test.cpp
@@ -0,0 +1,126 @@
+//===-- Unittests for sinpif ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/sinpif.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/src/math/sdcomp26094.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+#include <stdint.h>
+
+using LlvmLibcSinpifTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+using LIBC_NAMESPACE::testing::SDCOMP26094_VALUES;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+TEST_F(LlvmLibcSinpifTest, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(-0.0f, LIBC_NAMESPACE::sinpif(-0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+TEST_F(LlvmLibcSinpifTest, SpecificBitPatterns) {
+  constexpr int N = 36;
+  constexpr uint32_t INPUTS[N] = {
+      0x3f06'0a92U, // x = pi/6
+      0x3f3a'dc51U, // x = 0x1.75b8a2p-1f
+      0x3f49'0fdbU, // x = pi/4
+      0x3f86'0a92U, // x = pi/3
+      0x3fa7'832aU, // x = 0x1.4f0654p+0f
+      0x3fc9'0fdbU, // x = pi/2
+      0x4017'1973U, // x = 0x1.2e32e6p+1f
+      0x4049'0fdbU, // x = pi
+      0x4096'cbe4U, // x = 0x1.2d97c8p+2f
+      0x40c9'0fdbU, // x = 2*pi
+      0x433b'7490U, // x = 0x1.76e92p+7f
+      0x437c'e5f1U, // x = 0x1.f9cbe2p+7f
+      0x4619'9998U, // x = 0x1.33333p+13f
+      0x474d'246fU, // x = 0x1.9a48dep+15f
+      0x4afd'ece4U, // x = 0x1.fbd9c8p+22f
+      0x4c23'32e9U, // x = 0x1.4665d2p+25f
+      0x50a3'e87fU, // x = 0x1.47d0fep+34f
+      0x5239'47f6U, // x = 0x1.728fecp+37f
+      0x53b1'46a6U, // x = 0x1.628d4cp+40f
+      0x55ca'fb2aU, // x = 0x1.95f654p+44f
+      0x588e'f060U, // x = 0x1.1de0cp+50f
+      0x5c07'bcd0U, // x = 0x1.0f79ap+57f
+      0x5ebc'fddeU, // x = 0x1.79fbbcp+62f
+      0x5fa6'eba7U, // x = 0x1.4dd74ep+64f
+      0x61a4'0b40U, // x = 0x1.48168p+68f
+      0x6386'134eU, // x = 0x1.0c269cp+72f
+      0x6589'8498U, // x = 0x1.13093p+76f
+      0x6600'0001U, // x = 0x1.000002p+77f
+      0x664e'46e4U, // x = 0x1.9c8dc8p+77f
+      0x66b0'14aaU, // x = 0x1.602954p+78f
+      0x67a9'242bU, // x = 0x1.524856p+80f
+      0x6a19'76f1U, // x = 0x1.32ede2p+85f
+      0x6c55'da58U, // x = 0x1.abb4bp+89f
+      0x6f79'be45U, // x = 0x1.f37c8ap+95f
+      0x7276'69d4U, // x = 0x1.ecd3a8p+101f
+      0x7758'4625U, // x = 0x1.b08c4ap+111f
+  };
+
+  for (int i = 0; i < N; ++i) {
+    float x = FPBits(INPUTS[i]).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                   LIBC_NAMESPACE::sinpif(x), 0.5);
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, -x,
+                                   LIBC_NAMESPACE::sinpif(-x), 0.5);
+  }
+}
+
+// For small values, sinpi(x) is pi * x.
+TEST_F(LlvmLibcSinpifTest, SmallValues) {
+  float x = FPBits(0x1780'0000U).get_val();
+  EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                 LIBC_NAMESPACE::sinpif(x), 0.5);
+
+  x = FPBits(0x0040'0000U).get_val();
+  EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                 LIBC_NAMESPACE::sinpif(x), 0.5);
+}
+
+// SDCOMP-26094: check sinfpi in the cases for which the range reducer
+// returns values furthest beyond its nominal upper bound of pi/4.
+TEST_F(LlvmLibcSinpifTest, SDCOMP_26094) {
+  for (uint32_t v : SDCOMP26094_VALUES) {
+    float x = FPBits((v)).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sinpi, x,
+                                   LIBC_NAMESPACE::sinpif(x), 0.5);
+  }
+}
+
+// sinpi(-n) = -0.0
+// sinpi(+n) = +0.0
+TEST_F(LlvmLibcSinpifTest, SignedZeros) {
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x99));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1p+43));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1.4p+64));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1.cp+106));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1.cp+21));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x9999));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1p+43));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1.4p+64));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1.cp+106));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1.cp+21));
+}
diff --git a/test/src/math/smoke/AddTest.h b/test/src/math/smoke/AddTest.h
new file mode 100644
index 0000000..66b188f
--- /dev/null
+++ b/test/src/math/smoke/AddTest.h
@@ -0,0 +1,150 @@
+//===-- Utility class to test different flavors of float add ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_ADDTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_ADDTEST_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "src/__support/macros/properties/os.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Sign;
+
+template <typename OutType, typename InType>
+class AddTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(OutType)
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  InConstants in;
+
+public:
+  using AddFunc = OutType (*)(InType, InType);
+
+  void test_special_numbers(AddFunc func) {
+    EXPECT_FP_IS_NAN(func(in.aNaN, in.aNaN));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.sNaN, in.sNaN), FE_INVALID);
+
+    InType qnan_42 = InFPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    EXPECT_FP_IS_NAN(func(qnan_42, in.zero));
+    EXPECT_FP_IS_NAN(func(in.zero, qnan_42));
+
+    EXPECT_FP_EQ(inf, func(in.inf, in.zero));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, in.zero));
+    EXPECT_FP_EQ(inf, func(in.inf, in.neg_zero));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, in.neg_zero));
+  }
+
+  void test_invalid_operations(AddFunc func) {
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.neg_inf), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.inf), FE_INVALID);
+  }
+
+  void test_range_errors(AddFunc func) {
+#ifndef LIBC_TARGET_OS_IS_WINDOWS
+    using namespace LIBC_NAMESPACE::fputil::testing;
+
+    if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf,
+                                  func(in.neg_max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(
+          neg_zero, func(in.neg_min_denormal, in.neg_min_denormal),
+          FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::TowardZero); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(
+          neg_zero, func(in.neg_min_denormal, in.neg_min_denormal),
+          FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Downward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf,
+                                  func(in.neg_max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(
+          neg_min_denormal, func(in.neg_min_denormal, in.neg_min_denormal),
+          FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Upward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(min_denormal,
+                                  func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(
+          neg_zero, func(in.neg_min_denormal, in.neg_min_denormal),
+          FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+#endif
+  }
+
+  void test_inexact_results(AddFunc func) {
+    func(InType(1.0), in.min_denormal);
+    EXPECT_FP_EXCEPTION(FE_INEXACT);
+  }
+};
+
+#define LIST_ADD_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcAddTest = AddTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcAddTest, SpecialNumbers) { test_special_numbers(&func); }     \
+  TEST_F(LlvmLibcAddTest, InvalidOperations) {                                 \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcAddTest, RangeErrors) { test_range_errors(&func); }           \
+  TEST_F(LlvmLibcAddTest, InexactResults) { test_inexact_results(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_ADDTEST_H
diff --git a/test/src/math/smoke/CanonicalizeTest.h b/test/src/math/smoke/CanonicalizeTest.h
index 3baf60c..ef75f56 100644
--- a/test/src/math/smoke/CanonicalizeTest.h
+++ b/test/src/math/smoke/CanonicalizeTest.h
@@ -25,6 +25,7 @@
 
 #define TEST_REGULAR(x, y, expected) TEST_SPECIAL(x, y, expected, 0)
 
+using LIBC_NAMESPACE::operator""_u96;
 using LIBC_NAMESPACE::operator""_u128;
 
 template <typename T>
@@ -61,7 +62,11 @@ public:
       // Exponent   |       Significand      | Meaning
       //            | Bits 63-62 | Bits 61-0 |
       // All Ones   |     00     |    Zero   | Pseudo Infinity, Value = SNaN
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test1(0x00007FFF'00000000'00000000_u96);
+#else
       FPBits test1(0x00000000'00007FFF'00000000'00000000_u128);
+#endif
       const T test1_val = test1.get_val();
       TEST_SPECIAL(cx, test1_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
@@ -69,22 +74,38 @@ public:
       // Exponent   |       Significand      | Meaning
       //            | Bits 63-62 | Bits 61-0 |
       // All Ones   |     00     |  Non-Zero | Pseudo NaN, Value = SNaN
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test2_1(0x00007FFF'00000000'00000001_u96);
+#else
       FPBits test2_1(0x00000000'00007FFF'00000000'00000001_u128);
+#endif
       const T test2_1_val = test2_1.get_val();
       TEST_SPECIAL(cx, test2_1_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test2_2(0x00007FFF'00000042'70000001_u96);
+#else
       FPBits test2_2(0x00000000'00007FFF'00000042'70000001_u128);
+#endif
       const T test2_2_val = test2_2.get_val();
       TEST_SPECIAL(cx, test2_2_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test2_3(0x00007FFF'00000000'08261001_u96);
+#else
       FPBits test2_3(0x00000000'00007FFF'00000000'08261001_u128);
+#endif
       const T test2_3_val = test2_3.get_val();
       TEST_SPECIAL(cx, test2_3_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test2_4(0x00007FFF'00007800'08261001_u96);
+#else
       FPBits test2_4(0x00000000'00007FFF'00007800'08261001_u128);
+#endif
       const T test2_4_val = test2_4.get_val();
       TEST_SPECIAL(cx, test2_4_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
@@ -92,22 +113,38 @@ public:
       // Exponent   |       Significand      | Meaning
       //            | Bits 63-62 | Bits 61-0 |
       // All Ones   |     01     | Anything  | Pseudo NaN, Value = SNaN
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test3_1(0x00007FFF'40000000'00000000_u96);
+#else
       FPBits test3_1(0x00000000'00007FFF'40000000'00000000_u128);
+#endif
       const T test3_1_val = test3_1.get_val();
       TEST_SPECIAL(cx, test3_1_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test3_2(0x00007FFF'40000042'70000001_u96);
+#else
       FPBits test3_2(0x00000000'00007FFF'40000042'70000001_u128);
+#endif
       const T test3_2_val = test3_2.get_val();
       TEST_SPECIAL(cx, test3_2_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test3_3(0x00007FFF'40000000'08261001_u96);
+#else
       FPBits test3_3(0x00000000'00007FFF'40000000'08261001_u128);
+#endif
       const T test3_3_val = test3_3.get_val();
       TEST_SPECIAL(cx, test3_3_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test3_4(0x00007FFF'40007800'08261001_u96);
+#else
       FPBits test3_4(0x00000000'00007FFF'40007800'08261001_u128);
+#endif
       const T test3_4_val = test3_4.get_val();
       TEST_SPECIAL(cx, test3_4_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
@@ -116,19 +153,31 @@ public:
       //            |   Bit 63   | Bits 62-0 |
       // All zeroes |   One      | Anything  | Pseudo Denormal, Value =
       //            |            |           | (1)**s  m  2**16382
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test4_1(0x00000000'80000000'00000000_u96);
+#else
       FPBits test4_1(0x00000000'00000000'80000000'00000000_u128);
+#endif
       const T test4_1_val = test4_1.get_val();
       TEST_SPECIAL(cx, test4_1_val, 0, 0);
       EXPECT_FP_EQ(
           cx, FPBits::make_value(test4_1.get_explicit_mantissa(), 0).get_val());
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test4_2(0x00000000'80000042'70000001_u96);
+#else
       FPBits test4_2(0x00000000'00000000'80000042'70000001_u128);
+#endif
       const T test4_2_val = test4_2.get_val();
       TEST_SPECIAL(cx, test4_2_val, 0, 0);
       EXPECT_FP_EQ(
           cx, FPBits::make_value(test4_2.get_explicit_mantissa(), 0).get_val());
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test4_3(0x00000000'80000000'08261001_u96);
+#else
       FPBits test4_3(0x00000000'00000000'80000000'08261001_u128);
+#endif
       const T test4_3_val = test4_3.get_val();
       TEST_SPECIAL(cx, test4_3_val, 0, 0);
       EXPECT_FP_EQ(
@@ -138,32 +187,56 @@ public:
       //            |   Bit 63   | Bits 62-0 |
       // All Other  |   Zero     | Anything  | Unnormal, Value = SNaN
       //  Values    |            |           |
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_1(0x00000040'00000000'00000001_u96);
+#else
       FPBits test5_1(0x00000000'00000040'00000000'00000001_u128);
+#endif
       const T test5_1_val = test5_1.get_val();
       TEST_SPECIAL(cx, test5_1_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_2(0x00000230'00000042'70000001_u96);
+#else
       FPBits test5_2(0x00000000'00000230'00000042'70000001_u128);
+#endif
       const T test5_2_val = test5_2.get_val();
       TEST_SPECIAL(cx, test5_2_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_3(0x00000560'00000000'08261001_u96);
+#else
       FPBits test5_3(0x00000000'00000560'00000000'08261001_u128);
+#endif
       const T test5_3_val = test5_3.get_val();
       TEST_SPECIAL(cx, test5_3_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_4(0x00000780'00000028'16000000_u96);
+#else
       FPBits test5_4(0x00000000'00000780'00000028'16000000_u128);
+#endif
       const T test5_4_val = test5_4.get_val();
       TEST_SPECIAL(cx, test5_4_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_5(0x00000900'00000042'70000001_u96);
+#else
       FPBits test5_5(0x00000000'00000900'00000042'70000001_u128);
+#endif
       const T test5_5_val = test5_5.get_val();
       TEST_SPECIAL(cx, test5_5_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
 
+#if __SIZEOF_LONG_DOUBLE__ == 12
+      FPBits test5_6(0x00000AB0'00000000'08261001_u96);
+#else
       FPBits test5_6(0x00000000'00000AB0'00000000'08261001_u128);
+#endif
       const T test5_6_val = test5_6.get_val();
       TEST_SPECIAL(cx, test5_6_val, 1, FE_INVALID);
       EXPECT_FP_EQ(cx, aNaN);
diff --git a/test/src/math/smoke/CopySignTest.h b/test/src/math/smoke/CopySignTest.h
index 1eb323a..7dc6f5a 100644
--- a/test/src/math/smoke/CopySignTest.h
+++ b/test/src/math/smoke/CopySignTest.h
@@ -42,9 +42,9 @@ public:
     StorageType v = 0;
     for (int i = 0; i <= COUNT; ++i, v += STEP) {
       FPBits x_bits = FPBits(v);
-      T x = T(v);
       if (x_bits.is_nan() || x_bits.is_inf())
         continue;
+      T x = x_bits.get_val();
 
       T res1 = func(x, -x);
       ASSERT_FP_EQ(res1, -x);
diff --git a/test/src/math/smoke/DivTest.h b/test/src/math/smoke/DivTest.h
new file mode 100644
index 0000000..d807479
--- /dev/null
+++ b/test/src/math/smoke/DivTest.h
@@ -0,0 +1,168 @@
+//===-- Utility class to test different flavors of float div --------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_DIVTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_DIVTEST_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/RoundingModeUtils.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Sign;
+
+template <typename OutType, typename InType>
+class DivTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(OutType)
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  InConstants in;
+
+public:
+  using DivFunc = OutType (*)(InType, InType);
+
+  void test_special_numbers(DivFunc func) {
+    EXPECT_FP_IS_NAN(func(in.aNaN, in.aNaN));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.sNaN, in.sNaN), FE_INVALID);
+
+    InType qnan_42 = InFPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    EXPECT_FP_IS_NAN(func(qnan_42, in.zero));
+    EXPECT_FP_IS_NAN(func(in.zero, qnan_42));
+
+    EXPECT_FP_EQ(inf, func(in.inf, in.zero));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, in.zero));
+    EXPECT_FP_EQ(neg_inf, func(in.inf, in.neg_zero));
+    EXPECT_FP_EQ(inf, func(in.neg_inf, in.neg_zero));
+  }
+
+  void test_division_by_zero(DivFunc func) {
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(InType(1.0), in.zero), FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(InType(-1.0), in.zero),
+                                FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(InType(1.0), in.neg_zero),
+                                FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(InType(1.0), in.zero), FE_DIVBYZERO);
+  }
+
+  void test_invalid_operations(DivFunc func) {
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.zero, in.zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_zero, in.zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.zero, in.neg_zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_zero, in.neg_zero), FE_INVALID);
+
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.inf), FE_INVALID);
+    EXPECT_MATH_ERRNO(EDOM);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.inf), FE_INVALID);
+    EXPECT_MATH_ERRNO(EDOM);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.neg_inf), FE_INVALID);
+    EXPECT_MATH_ERRNO(EDOM);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.neg_inf), FE_INVALID);
+    EXPECT_MATH_ERRNO(EDOM);
+  }
+
+  void test_range_errors(DivFunc func) {
+    using namespace LIBC_NAMESPACE::fputil::testing;
+
+    if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.min_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf,
+                                  func(in.neg_max_normal, in.min_denormal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::TowardZero); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.min_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.min_denormal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Downward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.min_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf,
+                                  func(in.neg_max_normal, in.min_denormal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_min_denormal,
+                                  func(in.neg_min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Upward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.min_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.min_denormal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(min_denormal,
+                                  func(in.min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.max_normal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+  }
+
+  void test_inexact_results(DivFunc func) {
+    func(InType(1.0), InType(3.0));
+    EXPECT_FP_EXCEPTION(FE_INEXACT);
+  }
+};
+
+#define LIST_DIV_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcDivTest = DivTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcDivTest, SpecialNumbers) { test_special_numbers(&func); }     \
+  TEST_F(LlvmLibcDivTest, DivisionByZero) { test_division_by_zero(&func); }    \
+  TEST_F(LlvmLibcDivTest, InvalidOperations) {                                 \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcDivTest, RangeErrors) { test_range_errors(&func); }           \
+  TEST_F(LlvmLibcDivTest, InexactResults) { test_inexact_results(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_DIVTEST_H
diff --git a/test/src/math/smoke/FDimTest.h b/test/src/math/smoke/FDimTest.h
index cc0ce3b..56cc70c 100644
--- a/test/src/math/smoke/FDimTest.h
+++ b/test/src/math/smoke/FDimTest.h
@@ -12,6 +12,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class FDimTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
diff --git a/test/src/math/smoke/FMaxTest.h b/test/src/math/smoke/FMaxTest.h
index f4c78b5..1cb105a 100644
--- a/test/src/math/smoke/FMaxTest.h
+++ b/test/src/math/smoke/FMaxTest.h
@@ -25,8 +25,8 @@ public:
   void testNaN(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(aNaN, inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -34,25 +34,25 @@ public:
 
   void testInfArg(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaxFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaxFunc func) {
diff --git a/test/src/math/smoke/FMaximumMagNumTest.h b/test/src/math/smoke/FMaximumMagNumTest.h
index 726f870..b52169e 100644
--- a/test/src/math/smoke/FMaximumMagNumTest.h
+++ b/test/src/math/smoke/FMaximumMagNumTest.h
@@ -30,10 +30,10 @@ public:
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(neg_inf, sNaN), FE_INVALID);
     EXPECT_EQ(FPBits(aNaN).uintval(), FPBits(func(aNaN, aNaN)).uintval());
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
-    EXPECT_FP_EQ_WITH_EXCEPTION(0.0, func(sNaN, 0.0), FE_INVALID);
-    EXPECT_FP_EQ_WITH_EXCEPTION(-0.0, func(-0.0, sNaN), FE_INVALID);
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
+    EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(sNaN, zero), FE_INVALID);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero, func(neg_zero, sNaN), FE_INVALID);
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(T(-1.2345), func(sNaN, T(-1.2345)), FE_INVALID);
@@ -47,25 +47,25 @@ public:
 
   void testInfArg(FMaximumMagNumFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaximumMagNumFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaximumMagNumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaximumMagNumFunc func) {
diff --git a/test/src/math/smoke/FMaximumMagTest.h b/test/src/math/smoke/FMaximumMagTest.h
index b5b2c1c..81a232d 100644
--- a/test/src/math/smoke/FMaximumMagTest.h
+++ b/test/src/math/smoke/FMaximumMagTest.h
@@ -26,8 +26,8 @@ public:
   void testNaN(FMaximumMagFunc func) {
     EXPECT_FP_EQ(aNaN, func(aNaN, inf));
     EXPECT_FP_EQ(aNaN, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(aNaN, func(aNaN, 0.0));
-    EXPECT_FP_EQ(aNaN, func(-0.0, aNaN));
+    EXPECT_FP_EQ(aNaN, func(aNaN, zero));
+    EXPECT_FP_EQ(aNaN, func(neg_zero, aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(aNaN, func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -35,25 +35,25 @@ public:
 
   void testInfArg(FMaximumMagFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaximumMagFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaximumMagFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaximumMagFunc func) {
diff --git a/test/src/math/smoke/FMaximumNumTest.h b/test/src/math/smoke/FMaximumNumTest.h
index ec79135..f4e05b9 100644
--- a/test/src/math/smoke/FMaximumNumTest.h
+++ b/test/src/math/smoke/FMaximumNumTest.h
@@ -29,10 +29,10 @@ public:
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(neg_inf, sNaN), FE_INVALID);
     EXPECT_EQ(FPBits(aNaN).uintval(), FPBits(func(aNaN, aNaN)).uintval());
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
-    EXPECT_FP_EQ_WITH_EXCEPTION(0.0, func(sNaN, 0.0), FE_INVALID);
-    EXPECT_FP_EQ_WITH_EXCEPTION(-0.0, func(-0.0, sNaN), FE_INVALID);
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
+    EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(sNaN, zero), FE_INVALID);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero, func(neg_zero, sNaN), FE_INVALID);
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(T(-1.2345), func(sNaN, T(-1.2345)), FE_INVALID);
@@ -46,25 +46,25 @@ public:
 
   void testInfArg(FMaximumNumFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaximumNumFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaximumNumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaximumNumFunc func) {
diff --git a/test/src/math/smoke/FMaximumTest.h b/test/src/math/smoke/FMaximumTest.h
index 94e4a34..5e71a41 100644
--- a/test/src/math/smoke/FMaximumTest.h
+++ b/test/src/math/smoke/FMaximumTest.h
@@ -25,8 +25,8 @@ public:
   void testNaN(FMaximumFunc func) {
     EXPECT_FP_EQ(aNaN, func(aNaN, inf));
     EXPECT_FP_EQ(aNaN, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(aNaN, func(aNaN, 0.0));
-    EXPECT_FP_EQ(aNaN, func(-0.0, aNaN));
+    EXPECT_FP_EQ(aNaN, func(aNaN, zero));
+    EXPECT_FP_EQ(aNaN, func(neg_zero, aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(aNaN, func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -34,25 +34,25 @@ public:
 
   void testInfArg(FMaximumFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaximumFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaximumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaximumFunc func) {
diff --git a/test/src/math/smoke/FMinTest.h b/test/src/math/smoke/FMinTest.h
index 629aaab..049d94e 100644
--- a/test/src/math/smoke/FMinTest.h
+++ b/test/src/math/smoke/FMinTest.h
@@ -25,8 +25,8 @@ public:
   void testNaN(FMinFunc func) {
     EXPECT_FP_EQ(inf, func(aNaN, inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -34,25 +34,25 @@ public:
 
   void testInfArg(FMinFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(-1.2345), func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMinFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinFunc func) {
diff --git a/test/src/math/smoke/FMinimumMagNumTest.h b/test/src/math/smoke/FMinimumMagNumTest.h
index 2ceca6f..4cec6f0 100644
--- a/test/src/math/smoke/FMinimumMagNumTest.h
+++ b/test/src/math/smoke/FMinimumMagNumTest.h
@@ -30,10 +30,10 @@ public:
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(neg_inf, sNaN), FE_INVALID);
     EXPECT_EQ(FPBits(aNaN).uintval(), FPBits(func(aNaN, aNaN)).uintval());
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
-    EXPECT_FP_EQ_WITH_EXCEPTION(0.0, func(sNaN, 0.0), FE_INVALID);
-    EXPECT_FP_EQ_WITH_EXCEPTION(-0.0, func(-0.0, sNaN), FE_INVALID);
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
+    EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(sNaN, zero), FE_INVALID);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero, func(neg_zero, sNaN), FE_INVALID);
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(T(-1.2345), func(sNaN, T(-1.2345)), FE_INVALID);
@@ -47,25 +47,25 @@ public:
 
   void testInfArg(FMinimumMagNumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(-1.2345), func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMinimumMagNumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinimumMagNumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinimumMagNumFunc func) {
diff --git a/test/src/math/smoke/FMinimumMagTest.h b/test/src/math/smoke/FMinimumMagTest.h
index 9c49446..18b4381 100644
--- a/test/src/math/smoke/FMinimumMagTest.h
+++ b/test/src/math/smoke/FMinimumMagTest.h
@@ -26,8 +26,8 @@ public:
   void testNaN(FMinimumMagFunc func) {
     EXPECT_FP_EQ(aNaN, func(aNaN, inf));
     EXPECT_FP_EQ(aNaN, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(aNaN, func(aNaN, 0.0));
-    EXPECT_FP_EQ(aNaN, func(-0.0, aNaN));
+    EXPECT_FP_EQ(aNaN, func(aNaN, zero));
+    EXPECT_FP_EQ(aNaN, func(neg_zero, aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(aNaN, func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -35,25 +35,25 @@ public:
 
   void testInfArg(FMinimumMagFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(-1.2345), func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMinimumMagFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinimumMagFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinimumMagFunc func) {
diff --git a/test/src/math/smoke/FMinimumNumTest.h b/test/src/math/smoke/FMinimumNumTest.h
index 8004ee9..dddcdc2 100644
--- a/test/src/math/smoke/FMinimumNumTest.h
+++ b/test/src/math/smoke/FMinimumNumTest.h
@@ -29,10 +29,10 @@ public:
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, func(neg_inf, sNaN), FE_INVALID);
     EXPECT_EQ(FPBits(aNaN).uintval(), FPBits(func(aNaN, aNaN)).uintval());
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
-    EXPECT_FP_EQ_WITH_EXCEPTION(0.0, func(sNaN, 0.0), FE_INVALID);
-    EXPECT_FP_EQ_WITH_EXCEPTION(-0.0, func(-0.0, sNaN), FE_INVALID);
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
+    EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(sNaN, zero), FE_INVALID);
+    EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero, func(neg_zero, sNaN), FE_INVALID);
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ_WITH_EXCEPTION(T(-1.2345), func(sNaN, T(-1.2345)), FE_INVALID);
@@ -46,25 +46,25 @@ public:
 
   void testInfArg(FMinimumNumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(-1.2345), func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMinimumNumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinimumNumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinimumNumFunc func) {
diff --git a/test/src/math/smoke/FMinimumTest.h b/test/src/math/smoke/FMinimumTest.h
index 242c857..b5c0e98 100644
--- a/test/src/math/smoke/FMinimumTest.h
+++ b/test/src/math/smoke/FMinimumTest.h
@@ -25,8 +25,8 @@ public:
   void testNaN(FMinimumFunc func) {
     EXPECT_FP_EQ(aNaN, func(aNaN, inf));
     EXPECT_FP_EQ(aNaN, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(aNaN, func(aNaN, 0.0));
-    EXPECT_FP_EQ(aNaN, func(-0.0, aNaN));
+    EXPECT_FP_EQ(aNaN, func(aNaN, zero));
+    EXPECT_FP_EQ(aNaN, func(neg_zero, aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(aNaN, func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -34,25 +34,25 @@ public:
 
   void testInfArg(FMinimumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), inf));
   }
 
   void testNegInfArg(FMinimumFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinimumFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinimumFunc func) {
diff --git a/test/src/math/smoke/FModTest.h b/test/src/math/smoke/FModTest.h
index 405e310..ad9688f 100644
--- a/test/src/math/smoke/FModTest.h
+++ b/test/src/math/smoke/FModTest.h
@@ -35,16 +35,16 @@ public:
 
   void testSpecialNumbers(FModFunc f) {
     // fmod (+0, y) == +0 for y != 0.
-    TEST_SPECIAL(0.0, 3.0, 0.0, false, 0);
-    TEST_SPECIAL(0.0, min_denormal, 0.0, false, 0);
-    TEST_SPECIAL(0.0, -min_denormal, 0.0, false, 0);
-    TEST_SPECIAL(0.0, min_normal, 0.0, false, 0);
-    TEST_SPECIAL(0.0, -min_normal, 0.0, false, 0);
-    TEST_SPECIAL(0.0, max_normal, 0.0, false, 0);
-    TEST_SPECIAL(0.0, -max_normal, 0.0, false, 0);
+    TEST_SPECIAL(zero, T(3.0), zero, false, 0);
+    TEST_SPECIAL(zero, min_denormal, zero, false, 0);
+    TEST_SPECIAL(zero, -min_denormal, zero, false, 0);
+    TEST_SPECIAL(zero, min_normal, zero, false, 0);
+    TEST_SPECIAL(zero, -min_normal, zero, false, 0);
+    TEST_SPECIAL(zero, max_normal, zero, false, 0);
+    TEST_SPECIAL(zero, -max_normal, zero, false, 0);
 
     // fmod (-0, y) == -0 for y != 0.
-    TEST_SPECIAL(neg_zero, 3.0, neg_zero, false, 0);
+    TEST_SPECIAL(neg_zero, T(3.0), neg_zero, false, 0);
     TEST_SPECIAL(neg_zero, min_denormal, neg_zero, false, 0);
     TEST_SPECIAL(neg_zero, -min_denormal, neg_zero, false, 0);
     TEST_SPECIAL(neg_zero, min_normal, neg_zero, false, 0);
@@ -53,9 +53,9 @@ public:
     TEST_SPECIAL(neg_zero, -max_normal, neg_zero, false, 0);
 
     // fmod (+inf, y) == aNaN plus invalid exception.
-    TEST_SPECIAL(inf, 3.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(inf, -1.1L, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(inf, 0.0, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(inf, T(3.0), aNaN, true, FE_INVALID);
+    TEST_SPECIAL(inf, T(-1.1), aNaN, true, FE_INVALID);
+    TEST_SPECIAL(inf, zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, min_denormal, aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, min_normal, aNaN, true, FE_INVALID);
@@ -64,9 +64,9 @@ public:
     TEST_SPECIAL(inf, neg_inf, aNaN, true, FE_INVALID);
 
     // fmod (-inf, y) == aNaN plus invalid exception.
-    TEST_SPECIAL(neg_inf, 3.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(neg_inf, -1.1L, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(neg_inf, 0.0, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(neg_inf, T(3.0), aNaN, true, FE_INVALID);
+    TEST_SPECIAL(neg_inf, T(-1.1), aNaN, true, FE_INVALID);
+    TEST_SPECIAL(neg_inf, zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, min_denormal, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, min_normal, aNaN, true, FE_INVALID);
@@ -75,106 +75,106 @@ public:
     TEST_SPECIAL(neg_inf, neg_inf, aNaN, true, FE_INVALID);
 
     // fmod (x, +0) == aNaN plus invalid exception.
-    TEST_SPECIAL(3.0, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(-1.1L, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(0.0, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(neg_zero, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(min_denormal, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(min_normal, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(max_normal, 0.0, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(T(3.0), zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(T(-1.1), zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(zero, zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(neg_zero, zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(min_denormal, zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(min_normal, zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(max_normal, zero, aNaN, true, FE_INVALID);
 
     // fmod (x, -0) == aNaN plus invalid exception.
-    TEST_SPECIAL(3.0, neg_zero, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(-1.1L, neg_zero, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(0.0, neg_zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(T(3.0), neg_zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(T(-1.1), neg_zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(zero, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_zero, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(min_denormal, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(min_normal, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(max_normal, neg_zero, aNaN, true, FE_INVALID);
 
     // fmod (x, +inf) == x for x not infinite.
-    TEST_SPECIAL(0.0, inf, 0.0, false, 0);
+    TEST_SPECIAL(zero, inf, zero, false, 0);
     TEST_SPECIAL(neg_zero, inf, neg_zero, false, 0);
     TEST_SPECIAL(min_denormal, inf, min_denormal, false, 0);
     TEST_SPECIAL(min_normal, inf, min_normal, false, 0);
     TEST_SPECIAL(max_normal, inf, max_normal, false, 0);
-    TEST_SPECIAL(3.0, inf, 3.0, false, 0);
+    TEST_SPECIAL(T(3.0), inf, T(3.0), false, 0);
     // fmod (x, -inf) == x for x not infinite.
-    TEST_SPECIAL(0.0, neg_inf, 0.0, false, 0);
+    TEST_SPECIAL(zero, neg_inf, zero, false, 0);
     TEST_SPECIAL(neg_zero, neg_inf, neg_zero, false, 0);
     TEST_SPECIAL(min_denormal, neg_inf, min_denormal, false, 0);
     TEST_SPECIAL(min_normal, neg_inf, min_normal, false, 0);
     TEST_SPECIAL(max_normal, neg_inf, max_normal, false, 0);
-    TEST_SPECIAL(3.0, neg_inf, 3.0, false, 0);
+    TEST_SPECIAL(T(3.0), neg_inf, T(3.0), false, 0);
 
-    TEST_SPECIAL(0.0, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(0.0, -aNaN, aNaN, false, 0);
+    TEST_SPECIAL(zero, aNaN, aNaN, false, 0);
+    TEST_SPECIAL(zero, neg_aNaN, aNaN, false, 0);
     TEST_SPECIAL(neg_zero, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(neg_zero, -aNaN, aNaN, false, 0);
-    TEST_SPECIAL(1.0, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(1.0, -aNaN, aNaN, false, 0);
+    TEST_SPECIAL(neg_zero, neg_aNaN, aNaN, false, 0);
+    TEST_SPECIAL(T(1.0), aNaN, aNaN, false, 0);
+    TEST_SPECIAL(T(1.0), neg_aNaN, aNaN, false, 0);
     TEST_SPECIAL(inf, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(inf, -aNaN, aNaN, false, 0);
+    TEST_SPECIAL(inf, neg_aNaN, aNaN, false, 0);
     TEST_SPECIAL(neg_inf, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(neg_inf, -aNaN, aNaN, false, 0);
-    TEST_SPECIAL(0.0, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(0.0, -sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_inf, neg_aNaN, aNaN, false, 0);
+    TEST_SPECIAL(zero, sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(zero, neg_sNaN, aNaN, false, FE_INVALID);
     TEST_SPECIAL(neg_zero, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(neg_zero, -sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(1.0, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(1.0, -sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_zero, neg_sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(T(1.0), sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(T(1.0), neg_sNaN, aNaN, false, FE_INVALID);
     TEST_SPECIAL(inf, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(inf, -sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(inf, neg_sNaN, aNaN, false, FE_INVALID);
     TEST_SPECIAL(neg_inf, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(neg_inf, -sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(aNaN, 0.0, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, 0.0, aNaN, false, 0);
+    TEST_SPECIAL(neg_inf, neg_sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(aNaN, zero, aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, zero, aNaN, false, 0);
     TEST_SPECIAL(aNaN, neg_zero, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, neg_zero, aNaN, false, 0);
-    TEST_SPECIAL(aNaN, 1.0, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, 1.0, aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, neg_zero, aNaN, false, 0);
+    TEST_SPECIAL(aNaN, T(1.0), aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, T(1.0), aNaN, false, 0);
     TEST_SPECIAL(aNaN, inf, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, inf, aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, inf, aNaN, false, 0);
     TEST_SPECIAL(aNaN, neg_inf, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, neg_inf, aNaN, false, 0);
-    TEST_SPECIAL(sNaN, 0.0, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, 0.0, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_aNaN, neg_inf, aNaN, false, 0);
+    TEST_SPECIAL(sNaN, zero, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, zero, aNaN, false, FE_INVALID);
     TEST_SPECIAL(sNaN, neg_zero, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, neg_zero, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(sNaN, 1.0, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, 1.0, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, neg_zero, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(sNaN, T(1.0), aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, T(1.0), aNaN, false, FE_INVALID);
     TEST_SPECIAL(sNaN, inf, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, inf, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, inf, aNaN, false, FE_INVALID);
     TEST_SPECIAL(sNaN, neg_inf, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, neg_inf, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, neg_inf, aNaN, false, FE_INVALID);
     TEST_SPECIAL(aNaN, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(aNaN, -aNaN, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, aNaN, aNaN, false, 0);
-    TEST_SPECIAL(-aNaN, -aNaN, aNaN, false, 0);
+    TEST_SPECIAL(aNaN, neg_aNaN, aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, aNaN, aNaN, false, 0);
+    TEST_SPECIAL(neg_aNaN, neg_aNaN, aNaN, false, 0);
     TEST_SPECIAL(aNaN, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(aNaN, -sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-aNaN, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-aNaN, -sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(aNaN, neg_sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_aNaN, sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_aNaN, neg_sNaN, aNaN, false, FE_INVALID);
     TEST_SPECIAL(sNaN, aNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(sNaN, -aNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, aNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, -aNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(sNaN, neg_aNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, aNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, neg_aNaN, aNaN, false, FE_INVALID);
     TEST_SPECIAL(sNaN, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(sNaN, -sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, sNaN, aNaN, false, FE_INVALID);
-    TEST_SPECIAL(-sNaN, -sNaN, aNaN, false, FE_INVALID);
-
-    TEST_SPECIAL(6.5, 2.25L, 2.0L, false, 0);
-    TEST_SPECIAL(-6.5, 2.25L, -2.0L, false, 0);
-    TEST_SPECIAL(6.5, -2.25L, 2.0L, false, 0);
-    TEST_SPECIAL(-6.5, -2.25L, -2.0L, false, 0);
-
-    TEST_SPECIAL(max_normal, max_normal, 0.0, false, 0);
-    TEST_SPECIAL(max_normal, -max_normal, 0.0, false, 0);
-    TEST_SPECIAL(max_normal, min_normal, 0.0, false, 0);
-    TEST_SPECIAL(max_normal, -min_normal, 0.0, false, 0);
-    TEST_SPECIAL(max_normal, min_denormal, 0.0, false, 0);
-    TEST_SPECIAL(max_normal, -min_denormal, 0.0, false, 0);
+    TEST_SPECIAL(sNaN, neg_sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, sNaN, aNaN, false, FE_INVALID);
+    TEST_SPECIAL(neg_sNaN, neg_sNaN, aNaN, false, FE_INVALID);
+
+    TEST_SPECIAL(T(6.5), T(2.25), T(2.0), false, 0);
+    TEST_SPECIAL(T(-6.5), T(2.25), T(-2.0), false, 0);
+    TEST_SPECIAL(T(6.5), T(-2.25), T(2.0), false, 0);
+    TEST_SPECIAL(T(-6.5), T(-2.25), T(-2.0), false, 0);
+
+    TEST_SPECIAL(max_normal, max_normal, zero, false, 0);
+    TEST_SPECIAL(max_normal, -max_normal, zero, false, 0);
+    TEST_SPECIAL(max_normal, min_normal, zero, false, 0);
+    TEST_SPECIAL(max_normal, -min_normal, zero, false, 0);
+    TEST_SPECIAL(max_normal, min_denormal, zero, false, 0);
+    TEST_SPECIAL(max_normal, -min_denormal, zero, false, 0);
     TEST_SPECIAL(-max_normal, max_normal, neg_zero, false, 0);
     TEST_SPECIAL(-max_normal, -max_normal, neg_zero, false, 0);
     TEST_SPECIAL(-max_normal, min_normal, neg_zero, false, 0);
@@ -184,10 +184,10 @@ public:
 
     TEST_SPECIAL(min_normal, max_normal, min_normal, false, 0);
     TEST_SPECIAL(min_normal, -max_normal, min_normal, false, 0);
-    TEST_SPECIAL(min_normal, min_normal, 0.0, false, 0);
-    TEST_SPECIAL(min_normal, -min_normal, 0.0, false, 0);
-    TEST_SPECIAL(min_normal, min_denormal, 0.0, false, 0);
-    TEST_SPECIAL(min_normal, -min_denormal, 0.0, false, 0);
+    TEST_SPECIAL(min_normal, min_normal, zero, false, 0);
+    TEST_SPECIAL(min_normal, -min_normal, zero, false, 0);
+    TEST_SPECIAL(min_normal, min_denormal, zero, false, 0);
+    TEST_SPECIAL(min_normal, -min_denormal, zero, false, 0);
     TEST_SPECIAL(-min_normal, max_normal, -min_normal, false, 0);
     TEST_SPECIAL(-min_normal, -max_normal, -min_normal, false, 0);
     TEST_SPECIAL(-min_normal, min_normal, neg_zero, false, 0);
@@ -199,8 +199,8 @@ public:
     TEST_SPECIAL(min_denormal, -max_normal, min_denormal, false, 0);
     TEST_SPECIAL(min_denormal, min_normal, min_denormal, false, 0);
     TEST_SPECIAL(min_denormal, -min_normal, min_denormal, false, 0);
-    TEST_SPECIAL(min_denormal, min_denormal, 0.0, false, 0);
-    TEST_SPECIAL(min_denormal, -min_denormal, 0.0, false, 0);
+    TEST_SPECIAL(min_denormal, min_denormal, zero, false, 0);
+    TEST_SPECIAL(min_denormal, -min_denormal, zero, false, 0);
     TEST_SPECIAL(-min_denormal, max_normal, -min_denormal, false, 0);
     TEST_SPECIAL(-min_denormal, -max_normal, -min_denormal, false, 0);
     TEST_SPECIAL(-min_denormal, min_normal, -min_denormal, false, 0);
@@ -212,33 +212,33 @@ public:
   void testRegularExtreme(FModFunc f) {
     if constexpr (sizeof(T) < sizeof(float))
       return;
-    TEST_REGULAR(0x1p127L, 0x3p-149L, 0x1p-149L);
-    TEST_REGULAR(0x1p127L, -0x3p-149L, 0x1p-149L);
-    TEST_REGULAR(0x1p127L, 0x3p-148L, 0x1p-147L);
-    TEST_REGULAR(0x1p127L, -0x3p-148L, 0x1p-147L);
-    TEST_REGULAR(0x1p127L, 0x3p-126L, 0x1p-125L);
-    TEST_REGULAR(0x1p127L, -0x3p-126L, 0x1p-125L);
-    TEST_REGULAR(-0x1p127L, 0x3p-149L, -0x1p-149L);
-    TEST_REGULAR(-0x1p127L, -0x3p-149L, -0x1p-149L);
-    TEST_REGULAR(-0x1p127L, 0x3p-148L, -0x1p-147L);
-    TEST_REGULAR(-0x1p127L, -0x3p-148L, -0x1p-147L);
-    TEST_REGULAR(-0x1p127L, 0x3p-126L, -0x1p-125L);
-    TEST_REGULAR(-0x1p127L, -0x3p-126L, -0x1p-125L);
+    TEST_REGULAR(T(0x1p127), T(0x3p-149), T(0x1p-149));
+    TEST_REGULAR(T(0x1p127), T(-0x3p-149), T(0x1p-149));
+    TEST_REGULAR(T(0x1p127), T(0x3p-148), T(0x1p-147));
+    TEST_REGULAR(T(0x1p127), T(-0x3p-148), T(0x1p-147));
+    TEST_REGULAR(T(0x1p127), T(0x3p-126), T(0x1p-125));
+    TEST_REGULAR(T(0x1p127), T(-0x3p-126), T(0x1p-125));
+    TEST_REGULAR(T(-0x1p127), T(0x3p-149), T(-0x1p-149));
+    TEST_REGULAR(T(-0x1p127), T(-0x3p-149), T(-0x1p-149));
+    TEST_REGULAR(T(-0x1p127), T(0x3p-148), T(-0x1p-147));
+    TEST_REGULAR(T(-0x1p127), T(-0x3p-148), T(-0x1p-147));
+    TEST_REGULAR(T(-0x1p127), T(0x3p-126), T(-0x1p-125));
+    TEST_REGULAR(T(-0x1p127), T(-0x3p-126), T(-0x1p-125));
 
     if constexpr (sizeof(T) < sizeof(double))
       return;
-    TEST_REGULAR(0x1p1023L, 0x3p-1074L, 0x1p-1073L);
-    TEST_REGULAR(0x1p1023L, -0x3p-1074L, 0x1p-1073L);
-    TEST_REGULAR(0x1p1023L, 0x3p-1073L, 0x1p-1073L);
-    TEST_REGULAR(0x1p1023L, -0x3p-1073L, 0x1p-1073L);
-    TEST_REGULAR(0x1p1023L, 0x3p-1022L, 0x1p-1021L);
-    TEST_REGULAR(0x1p1023L, -0x3p-1022L, 0x1p-1021L);
-    TEST_REGULAR(-0x1p1023L, 0x3p-1074L, -0x1p-1073L);
-    TEST_REGULAR(-0x1p1023L, -0x3p-1074L, -0x1p-1073L);
-    TEST_REGULAR(-0x1p1023L, 0x3p-1073L, -0x1p-1073L);
-    TEST_REGULAR(-0x1p1023L, -0x3p-1073L, -0x1p-1073L);
-    TEST_REGULAR(-0x1p1023L, 0x3p-1022L, -0x1p-1021L);
-    TEST_REGULAR(-0x1p1023L, -0x3p-1022L, -0x1p-1021L);
+    TEST_REGULAR(T(0x1p1023), T(0x3p-1074), T(0x1p-1073));
+    TEST_REGULAR(T(0x1p1023), T(-0x3p-1074), T(0x1p-1073));
+    TEST_REGULAR(T(0x1p1023), T(0x3p-1073), T(0x1p-1073));
+    TEST_REGULAR(T(0x1p1023), T(-0x3p-1073), T(0x1p-1073));
+    TEST_REGULAR(T(0x1p1023), T(0x3p-1022), T(0x1p-1021));
+    TEST_REGULAR(T(0x1p1023), T(-0x3p-1022), T(0x1p-1021));
+    TEST_REGULAR(T(-0x1p1023), T(0x3p-1074), T(-0x1p-1073));
+    TEST_REGULAR(T(-0x1p1023), T(-0x3p-1074), T(-0x1p-1073));
+    TEST_REGULAR(T(-0x1p1023), T(0x3p-1073), T(-0x1p-1073));
+    TEST_REGULAR(T(-0x1p1023), T(-0x3p-1073), T(-0x1p-1073));
+    TEST_REGULAR(T(-0x1p1023), T(0x3p-1022), T(-0x1p-1021));
+    TEST_REGULAR(T(-0x1p1023), T(-0x3p-1022), T(-0x1p-1021));
   }
 };
 
diff --git a/test/src/math/smoke/FMulTest.h b/test/src/math/smoke/FMulTest.h
deleted file mode 100644
index 33fb82c..0000000
--- a/test/src/math/smoke/FMulTest.h
+++ /dev/null
@@ -1,104 +0,0 @@
-//===-- Utility class to test fmul[f|l] ---------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_FMULTEST_H
-#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_FMULTEST_H
-
-#include "test/UnitTest/FEnvSafeTest.h"
-#include "test/UnitTest/FPMatcher.h"
-#include "test/UnitTest/Test.h"
-
-template <typename T, typename R>
-class FmulTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
-
-  DECLARE_SPECIAL_CONSTANTS(T)
-
-public:
-  typedef T (*FMulFunc)(R, R);
-
-  void testMul(FMulFunc func) {
-
-    EXPECT_FP_EQ_ALL_ROUNDING(T(15.0), func(3.0, 5.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(T(0x1.0p-130), func(0x1.0p1, 0x1.0p-131));
-    EXPECT_FP_EQ_ALL_ROUNDING(T(0x1.0p-127), func(0x1.0p2, 0x1.0p-129));
-    EXPECT_FP_EQ_ALL_ROUNDING(T(1.0), func(1.0, 1.0));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(T(0.0), func(-0.0, -0.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(T(-0.0), func(0.0, -0.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(T(-0.0), func(-0.0, 0.0));
-
-    EXPECT_FP_EQ_ROUNDING_NEAREST(inf, func(0x1.0p100, 0x1.0p100));
-    EXPECT_FP_EQ_ROUNDING_UPWARD(inf, func(0x1.0p100, 0x1.0p100));
-    EXPECT_FP_EQ_ROUNDING_DOWNWARD(max_normal, func(0x1.0p100, 0x1.0p100));
-    EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO(max_normal, func(0x1.0p100, 0x1.0p100));
-
-    EXPECT_FP_EQ_ROUNDING_NEAREST(
-        0x1p0, func(1.0, 1.0 + 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_DOWNWARD(
-        0x1p0, func(1.0, 1.0 + 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO(
-        0x1p0, func(1.0, 1.0 + 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_UPWARD(
-        0x1p0, func(1.0, 1.0 + 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-
-    EXPECT_FP_EQ_ROUNDING_NEAREST(
-        0x1.0p-128f + 0x1.0p-148f,
-        func(1.0, 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_UPWARD(
-        0x1.0p-128f + 0x1.0p-148f,
-        func(1.0, 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_DOWNWARD(
-        0x1.0p-128f + 0x1.0p-149f,
-        func(1.0, 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-    EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO(
-        0x1.0p-128f + 0x1.0p-149f,
-        func(1.0, 0x1.0p-128 + 0x1.0p-149 + 0x1.0p-150));
-  }
-
-  void testSpecialInputs(FMulFunc func) {
-    EXPECT_FP_EQ_ALL_ROUNDING(inf, func(inf, 0x1.0p-129));
-    EXPECT_FP_EQ_ALL_ROUNDING(inf, func(0x1.0p-129, inf));
-    EXPECT_FP_EQ_ALL_ROUNDING(inf, func(inf, 2.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(inf, func(3.0, inf));
-    EXPECT_FP_EQ_ALL_ROUNDING(0.0, func(0.0, 0.0));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(neg_inf, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(aNaN, neg_inf));
-    EXPECT_FP_EQ_ALL_ROUNDING(inf, func(neg_inf, neg_inf));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0.0, neg_inf));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(neg_inf, 0.0));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, func(neg_inf, 1.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, func(1.0, neg_inf));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, func(neg_inf, 0x1.0p-129));
-    EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, func(0x1.0p-129, neg_inf));
-
-    EXPECT_FP_EQ_ALL_ROUNDING(0.0, func(0.0, 0x1.0p-129));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(inf, 0.0));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0.0, inf));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0.0, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(2.0, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0x1.0p-129, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(inf, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(aNaN, aNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0.0, sNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(2.0, sNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(0x1.0p-129, sNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(inf, sNaN));
-    EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(sNaN, sNaN));
-  }
-};
-
-#define LIST_FMUL_TESTS(T, R, func)                                            \
-  using LlvmLibcFmulTest = FmulTest<T, R>;                                     \
-  TEST_F(LlvmLibcFmulTest, Mul) { testMul(&func); }                            \
-  TEST_F(LlvmLibcFmulTest, NaNInf) { testSpecialInputs(&func); }
-
-#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_FMULTEST_H
diff --git a/test/src/math/smoke/FmaTest.h b/test/src/math/smoke/FmaTest.h
index f942de3..4109342 100644
--- a/test/src/math/smoke/FmaTest.h
+++ b/test/src/math/smoke/FmaTest.h
@@ -9,6 +9,9 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_FMATEST_H
 #define LLVM_LIBC_TEST_SRC_MATH_FMATEST_H
 
+#include "src/__support/CPP/type_traits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/macros/properties/types.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
@@ -37,6 +40,11 @@ class FmaTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   OutConstants out;
   InConstants in;
 
+  const InType in_out_min_normal =
+      LIBC_NAMESPACE::fputil::cast<InType>(out.min_normal);
+  const InType in_out_min_denormal =
+      LIBC_NAMESPACE::fputil::cast<InType>(out.min_denormal);
+
 public:
   using FmaFunc = OutType (*)(InType, InType, InType);
 
@@ -52,7 +60,7 @@ public:
 
     // Test underflow rounding up.
     EXPECT_FP_EQ(OutFPBits(OutStorageType(2)).get_val(),
-                 func(OutType(0.5), out.min_denormal, out.min_denormal));
+                 func(InType(0.5), in_out_min_denormal, in_out_min_denormal));
 
     if constexpr (sizeof(OutType) < sizeof(InType)) {
       EXPECT_FP_EQ(out.zero,
@@ -63,21 +71,33 @@ public:
     OutType v = OutFPBits(static_cast<OutStorageType>(OUT_MIN_NORMAL_U +
                                                       OutStorageType(1)))
                     .get_val();
-    EXPECT_FP_EQ(v, func(OutType(1) / OutType(OUT_MIN_NORMAL_U << 1), v,
-                         out.min_normal));
+    EXPECT_FP_EQ(v, func(InType(1) / InType(OUT_MIN_NORMAL_U << 1),
+                         LIBC_NAMESPACE::fputil::cast<InType>(v),
+                         in_out_min_normal));
 
     if constexpr (sizeof(OutType) < sizeof(InType)) {
+      InFPBits tmp = InFPBits::one();
+      tmp.set_biased_exponent(InFPBits::EXP_BIAS - InFPBits::FRACTION_LEN - 1);
+      InType reciprocal_value = tmp.get_val();
+
       InType v = InFPBits(static_cast<InStorageType>(IN_MIN_NORMAL_U +
                                                      InStorageType(1)))
                      .get_val();
-      EXPECT_FP_EQ(
-          out.min_normal,
-          func(InType(1) / InType(IN_MIN_NORMAL_U << 1), v, out.min_normal));
+      EXPECT_FP_EQ(out.min_normal,
+                   func(reciprocal_value, v, in_out_min_normal));
     }
 
     // Test overflow.
     OutType z = out.max_normal;
-    EXPECT_FP_EQ_ALL_ROUNDING(OutType(0.75) * z, func(InType(1.75), z, -z));
+    InType in_z = LIBC_NAMESPACE::fputil::cast<InType>(out.max_normal);
+#if defined(LIBC_TYPES_HAS_FLOAT16) && !defined(__LIBC_USE_FLOAT16_CONVERSION)
+    // Rounding modes other than the default might not be usable with float16.
+    if constexpr (LIBC_NAMESPACE::cpp::is_same_v<OutType, float16>)
+      EXPECT_FP_EQ(OutType(0.75) * z, func(InType(1.75), in_z, -in_z));
+    else
+#endif
+      EXPECT_FP_EQ_ALL_ROUNDING(OutType(0.75) * z,
+                                func(InType(1.75), in_z, -in_z));
 
     // Exact cancellation.
     EXPECT_FP_EQ_ROUNDING_NEAREST(
diff --git a/test/src/math/smoke/FrexpTest.h b/test/src/math/smoke/FrexpTest.h
index fc2313a..3fb3a2e 100644
--- a/test/src/math/smoke/FrexpTest.h
+++ b/test/src/math/smoke/FrexpTest.h
@@ -21,13 +21,24 @@ public:
   void testSpecialNumbers(FrexpFunc func) {
     int exponent;
     EXPECT_FP_EQ_ALL_ROUNDING(aNaN, func(aNaN, &exponent));
+#ifdef LIBC_FREXP_INF_NAN_EXPONENT
+    EXPECT_EQ(LIBC_FREXP_INF_NAN_EXPONENT, exponent);
+#endif // LIBC_FREXP_INF_NAN_EXPONENT
+
     EXPECT_FP_EQ_ALL_ROUNDING(inf, func(inf, &exponent));
+#ifdef LIBC_FREXP_INF_NAN_EXPONENT
+    EXPECT_EQ(LIBC_FREXP_INF_NAN_EXPONENT, exponent);
+#endif // LIBC_FREXP_INF_NAN_EXPONENT
+
     EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, func(neg_inf, &exponent));
+#ifdef LIBC_FREXP_INF_NAN_EXPONENT
+    EXPECT_EQ(LIBC_FREXP_INF_NAN_EXPONENT, exponent);
+#endif // LIBC_FREXP_INF_NAN_EXPONENT
 
-    EXPECT_FP_EQ_ALL_ROUNDING(0.0, func(0.0, &exponent));
+    EXPECT_FP_EQ_ALL_ROUNDING(zero, func(zero, &exponent));
     EXPECT_EQ(exponent, 0);
 
-    EXPECT_FP_EQ_ALL_ROUNDING(-0.0, func(-0.0, &exponent));
+    EXPECT_FP_EQ_ALL_ROUNDING(-zero, func(-zero, &exponent));
     EXPECT_EQ(exponent, 0);
   }
 
diff --git a/test/src/math/smoke/GetPayloadTest.h b/test/src/math/smoke/GetPayloadTest.h
index 6e30de7..1b1bf4f 100644
--- a/test/src/math/smoke/GetPayloadTest.h
+++ b/test/src/math/smoke/GetPayloadTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class GetPayloadTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
@@ -38,7 +40,14 @@ public:
     EXPECT_FP_EQ(T(0.0), funcWrapper(func, aNaN));
     EXPECT_FP_EQ(T(0.0), funcWrapper(func, neg_aNaN));
 
-    T default_snan_payload = StorageType(1) << (FPBits::SIG_LEN - 2);
+    // Essentially this:
+    //   T default_snan_payload = StorageType(1) << (FPBits::FRACTION_LEN - 2);
+    // but supports StorageType being a BigInt.
+    FPBits default_snan_payload_bits = FPBits::one();
+    default_snan_payload_bits.set_biased_exponent(FPBits::FRACTION_LEN - 2 +
+                                                  FPBits::EXP_BIAS);
+    T default_snan_payload = default_snan_payload_bits.get_val();
+
     EXPECT_FP_EQ(default_snan_payload, funcWrapper(func, sNaN));
     EXPECT_FP_EQ(default_snan_payload, funcWrapper(func, neg_sNaN));
 
diff --git a/test/src/math/smoke/HypotTest.h b/test/src/math/smoke/HypotTest.h
index 80e9bb7..30d57a4 100644
--- a/test/src/math/smoke/HypotTest.h
+++ b/test/src/math/smoke/HypotTest.h
@@ -9,42 +9,33 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_HYPOTTEST_H
 #define LLVM_LIBC_TEST_SRC_MATH_HYPOTTEST_H
 
-#include "src/__support/FPUtil/FPBits.h"
-#include "test/UnitTest/FEnvSafeTest.h"
+#include "src/__support/macros/properties/architectures.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include "hdr/math_macros.h"
-
 template <typename T>
-class HypotTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
-private:
+struct HypotTestTemplate : public LIBC_NAMESPACE::testing::Test {
   using Func = T (*)(T, T);
-  using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
-  using StorageType = typename FPBits::StorageType;
-
-  const T nan = FPBits::quiet_nan().get_val();
-  const T inf = FPBits::inf(Sign::POS).get_val();
-  const T neg_inf = FPBits::inf(Sign::NEG).get_val();
-  const T zero = FPBits::zero(Sign::POS).get_val();
-  const T neg_zero = FPBits::zero(Sign::NEG).get_val();
 
-  const T max_normal = FPBits::max_normal().get_val();
-  const T min_normal = FPBits::min_normal().get_val();
-  const T max_subnormal = FPBits::max_subnormal().get_val();
-  const T min_subnormal = FPBits::min_subnormal().get_val();
+  DECLARE_SPECIAL_CONSTANTS(T)
 
-public:
   void test_special_numbers(Func func) {
     constexpr int N = 4;
     // Pythagorean triples.
     constexpr T PYT[N][3] = {{3, 4, 5}, {5, 12, 13}, {8, 15, 17}, {7, 24, 25}};
 
-    EXPECT_FP_EQ(func(inf, nan), inf);
-    EXPECT_FP_EQ(func(nan, neg_inf), inf);
-    EXPECT_FP_EQ(func(nan, nan), nan);
-    EXPECT_FP_EQ(func(nan, zero), nan);
-    EXPECT_FP_EQ(func(neg_zero, nan), nan);
+#ifndef LIBC_TARGET_ARCH_IS_NVPTX
+    // TODO: Investigate why sNaN tests are failing on nVidia.
+    // https://github.com/llvm/llvm-project/issues/99706.
+    EXPECT_FP_EQ(func(inf, sNaN), aNaN);
+    EXPECT_FP_EQ(func(sNaN, neg_inf), aNaN);
+#endif // !LIBC_TARGET_ARCH_IS_NVPTX
+
+    EXPECT_FP_EQ(func(inf, aNaN), inf);
+    EXPECT_FP_EQ(func(aNaN, neg_inf), inf);
+    EXPECT_FP_EQ(func(aNaN, aNaN), aNaN);
+    EXPECT_FP_EQ(func(aNaN, zero), aNaN);
+    EXPECT_FP_EQ(func(neg_zero, aNaN), aNaN);
 
     for (int i = 0; i < N; ++i) {
       EXPECT_FP_EQ_ALL_ROUNDING(PYT[i][2], func(PYT[i][0], PYT[i][1]));
diff --git a/test/src/math/smoke/ILogbTest.h b/test/src/math/smoke/ILogbTest.h
index 3315ac2..605698e 100644
--- a/test/src/math/smoke/ILogbTest.h
+++ b/test/src/math/smoke/ILogbTest.h
@@ -15,6 +15,8 @@
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename OutType, typename InType>
 class LlvmLibcILogbTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<InType>;
@@ -47,13 +49,13 @@ public:
     EXPECT_EQ(OutType(2), func(InType(-4.0)));
 
     EXPECT_EQ(OutType(3), func(InType(8.0)));
-    EXPECT_EQ(OutType(3), func(-8.0));
+    EXPECT_EQ(OutType(3), func(InType(-8.0)));
 
-    EXPECT_EQ(OutType(4), func(16.0));
-    EXPECT_EQ(OutType(4), func(-16.0));
+    EXPECT_EQ(OutType(4), func(InType(16.0)));
+    EXPECT_EQ(OutType(4), func(InType(-16.0)));
 
-    EXPECT_EQ(OutType(5), func(32.0));
-    EXPECT_EQ(OutType(5), func(-32.0));
+    EXPECT_EQ(OutType(5), func(InType(32.0)));
+    EXPECT_EQ(OutType(5), func(InType(-32.0)));
   }
 
   void test_some_integers(Func func) {
@@ -67,10 +69,10 @@ public:
     EXPECT_EQ(OutType(3), func(InType(-10.0)));
 
     EXPECT_EQ(OutType(4), func(InType(31.0)));
-    EXPECT_EQ(OutType(4), func(-31.0));
+    EXPECT_EQ(OutType(4), func(InType(-31.0)));
 
-    EXPECT_EQ(OutType(5), func(55.0));
-    EXPECT_EQ(OutType(5), func(-55.0));
+    EXPECT_EQ(OutType(5), func(InType(55.0)));
+    EXPECT_EQ(OutType(5), func(InType(-55.0)));
   }
 
   void test_subnormal_range(Func func) {
diff --git a/test/src/math/smoke/IsCanonicalTest.h b/test/src/math/smoke/IsCanonicalTest.h
new file mode 100644
index 0000000..8b6554b
--- /dev/null
+++ b/test/src/math/smoke/IsCanonicalTest.h
@@ -0,0 +1,58 @@
+//===-- Utility class to test different flavors of iscanonical --*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISCANONICALTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISCANONICALTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+template <typename T>
+class IsCanonicalTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsCanonicalFunc)(T);
+
+  void testSpecialNumbers(IsCanonicalFunc func) {
+    EXPECT_EQ(func(aNaN), 1);
+    EXPECT_EQ(func(neg_aNaN), 1);
+    EXPECT_EQ(func(sNaN), 0);
+    EXPECT_EQ(func(neg_sNaN), 0);
+    EXPECT_EQ(func(inf), 1);
+    EXPECT_EQ(func(neg_inf), 1);
+    EXPECT_EQ(func(min_normal), 1);
+    EXPECT_EQ(func(max_normal), 1);
+    EXPECT_EQ(func(neg_max_normal), 1);
+    EXPECT_EQ(func(min_denormal), 1);
+    EXPECT_EQ(func(neg_min_denormal), 1);
+    EXPECT_EQ(func(max_denormal), 1);
+    EXPECT_EQ(func(zero), 1);
+    EXPECT_EQ(func(neg_zero), 1);
+  }
+
+  void testRoundedNumbers(IsCanonicalFunc func) {
+    EXPECT_EQ(func(T(1.0)), 1);
+    EXPECT_EQ(func(T(-1.0)), 1);
+    EXPECT_EQ(func(T(10.0)), 1);
+    EXPECT_EQ(func(T(-10.0)), 1);
+    EXPECT_EQ(func(T(1234.0)), 1);
+    EXPECT_EQ(func(T(-1234.0)), 1);
+  }
+};
+
+#define LIST_ISCANONICAL_TESTS(T, func)                                        \
+  using LlvmLibcIsCanonicalTest = IsCanonicalTest<T>;                          \
+  TEST_F(LlvmLibcIsCanonicalTest, SpecialNumbers) {                            \
+    testSpecialNumbers(&func);                                                 \
+  }                                                                            \
+  TEST_F(LlvmLibcIsCanonicalTest, RoundedNubmers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISCANONICALTEST_H
diff --git a/test/src/math/smoke/IsSignalingTest.h b/test/src/math/smoke/IsSignalingTest.h
new file mode 100644
index 0000000..f52642a
--- /dev/null
+++ b/test/src/math/smoke/IsSignalingTest.h
@@ -0,0 +1,60 @@
+//===-- Utility class to test different flavors of issignaling --*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISSIGNALINGTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISSIGNALINGTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "hdr/math_macros.h"
+
+template <typename T>
+class IsSignalingTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(T)
+
+public:
+  typedef int (*IsSignalingFunc)(T);
+
+  void testSpecialNumbers(IsSignalingFunc func) {
+    EXPECT_EQ(func(aNaN), 0);
+    EXPECT_EQ(func(neg_aNaN), 0);
+    EXPECT_EQ(func(sNaN), 1);
+    EXPECT_EQ(func(neg_sNaN), 1);
+    EXPECT_EQ(func(inf), 0);
+    EXPECT_EQ(func(neg_inf), 0);
+    EXPECT_EQ(func(min_normal), 0);
+    EXPECT_EQ(func(max_normal), 0);
+    EXPECT_EQ(func(neg_max_normal), 0);
+    EXPECT_EQ(func(min_denormal), 0);
+    EXPECT_EQ(func(neg_min_denormal), 0);
+    EXPECT_EQ(func(max_denormal), 0);
+    EXPECT_EQ(func(zero), 0);
+    EXPECT_EQ(func(neg_zero), 0);
+  }
+
+  void testRoundedNumbers(IsSignalingFunc func) {
+    EXPECT_EQ(func(T(1.0)), 0);
+    EXPECT_EQ(func(T(-1.0)), 0);
+    EXPECT_EQ(func(T(10.0)), 0);
+    EXPECT_EQ(func(T(-10.0)), 0);
+    EXPECT_EQ(func(T(1234.0)), 0);
+    EXPECT_EQ(func(T(-1234.0)), 0);
+  }
+};
+
+#define LIST_ISSIGNALING_TESTS(T, func)                                        \
+  using LlvmLibcIsSignalingTest = IsSignalingTest<T>;                          \
+  TEST_F(LlvmLibcIsSignalingTest, SpecialNumbers) {                            \
+    testSpecialNumbers(&func);                                                 \
+  }                                                                            \
+  TEST_F(LlvmLibcIsSignalingTest, RoundedNubmers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_ISSIGNALINGTEST_H
diff --git a/test/src/math/smoke/LdExpTest.h b/test/src/math/smoke/LdExpTest.h
index 7739bd7..094cc7e 100644
--- a/test/src/math/smoke/LdExpTest.h
+++ b/test/src/math/smoke/LdExpTest.h
@@ -18,6 +18,8 @@
 
 #include <stdint.h>
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T, typename U = int>
 class LdExpTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
@@ -48,7 +50,8 @@ public:
 
     if constexpr (sizeof(U) < sizeof(long) || sizeof(long) == sizeof(int))
       return;
-    long long_exp_array[4] = {LONG_MIN, INT_MIN - 1L, INT_MAX + 1L, LONG_MAX};
+    long long_exp_array[4] = {LONG_MIN, static_cast<long>(INT_MIN - 1LL),
+                              static_cast<long>(INT_MAX + 1LL), LONG_MAX};
     for (long exp : long_exp_array) {
       ASSERT_FP_EQ(zero, func(zero, exp));
       ASSERT_FP_EQ(neg_zero, func(neg_zero, exp));
diff --git a/test/src/math/smoke/LogbTest.h b/test/src/math/smoke/LogbTest.h
index 0bb6e12..a9f34e7 100644
--- a/test/src/math/smoke/LogbTest.h
+++ b/test/src/math/smoke/LogbTest.h
@@ -27,8 +27,8 @@ public:
     ASSERT_FP_EQ(aNaN, func(aNaN));
     ASSERT_FP_EQ(inf, func(inf));
     ASSERT_FP_EQ(inf, func(neg_inf));
-    ASSERT_FP_EQ(neg_inf, func(0.0));
-    ASSERT_FP_EQ(neg_inf, func(-0.0));
+    ASSERT_FP_EQ(neg_inf, func(zero));
+    ASSERT_FP_EQ(neg_inf, func(neg_zero));
   }
 
   void testPowersOfTwo(LogbFunc func) {
diff --git a/test/src/math/smoke/ModfTest.h b/test/src/math/smoke/ModfTest.h
index 6226e5d..24cfb11 100644
--- a/test/src/math/smoke/ModfTest.h
+++ b/test/src/math/smoke/ModfTest.h
@@ -97,7 +97,7 @@ public:
 
       T integral;
       T frac = func(x, &integral);
-      ASSERT_TRUE(LIBC_NAMESPACE::fputil::abs(frac) < 1.0l);
+      ASSERT_TRUE(LIBC_NAMESPACE::fputil::abs(frac) < T(1.0));
       ASSERT_TRUE(LIBC_NAMESPACE::fputil::trunc(x) == integral);
       ASSERT_TRUE(integral + frac == x);
     }
diff --git a/test/src/math/smoke/MulTest.h b/test/src/math/smoke/MulTest.h
new file mode 100644
index 0000000..cf7f41a
--- /dev/null
+++ b/test/src/math/smoke/MulTest.h
@@ -0,0 +1,162 @@
+//===-- Utility class to test different flavors of float mul ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_MULTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_MULTEST_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/BasicOperations.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Sign;
+
+template <typename OutType, typename InType>
+class MulTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(OutType)
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  InConstants in;
+
+public:
+  using MulFunc = OutType (*)(InType, InType);
+
+  void test_special_numbers(MulFunc func) {
+    EXPECT_FP_IS_NAN(func(in.aNaN, in.aNaN));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.sNaN, in.sNaN), FE_INVALID);
+
+    InType qnan_42 = InFPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    EXPECT_FP_IS_NAN(func(qnan_42, in.zero));
+    EXPECT_FP_IS_NAN(func(in.zero, qnan_42));
+
+    EXPECT_FP_EQ(inf, func(in.inf, InType(1.0)));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, InType(1.0)));
+    EXPECT_FP_EQ(neg_inf, func(in.inf, InType(-1.0)));
+    EXPECT_FP_EQ(inf, func(in.neg_inf, InType(-1.0)));
+
+    EXPECT_FP_EQ_ALL_ROUNDING(zero, func(in.zero, in.zero));
+    EXPECT_FP_EQ_ALL_ROUNDING(zero, func(in.neg_zero, in.neg_zero));
+    EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, func(in.zero, in.neg_zero));
+    EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, func(in.neg_zero, in.zero));
+
+    EXPECT_FP_EQ_ALL_ROUNDING(OutType(1.0), func(1.0, 1.0));
+    EXPECT_FP_EQ_ALL_ROUNDING(OutType(15.0), func(3.0, 5.0));
+    EXPECT_FP_EQ_ALL_ROUNDING(OutType(0x1.0p-13), func(0x1.0p+1, 0x1.0p-14));
+    EXPECT_FP_EQ_ALL_ROUNDING(OutType(0x1.0p-10), func(0x1.0p+2, 0x1.0p-12));
+  }
+
+  void test_invalid_operations(MulFunc func) {
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.neg_zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.zero), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.neg_zero), FE_INVALID);
+  }
+
+  void test_range_errors(MulFunc func) {
+    using namespace LIBC_NAMESPACE::fputil::testing;
+
+    if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::TowardZero); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Downward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero, func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_min_denormal,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Upward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(min_denormal,
+                                  func(in.min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+  }
+
+  void test_inexact_results(MulFunc func) {
+    InFPBits x_bits = InFPBits::one();
+    x_bits.set_mantissa(InFPBits::SIG_MASK);
+    InType x = x_bits.get_val();
+    func(x, x);
+    EXPECT_FP_EXCEPTION(FE_INEXACT);
+  }
+};
+
+#define LIST_MUL_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcMulTest = MulTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcMulTest, SpecialNumbers) { test_special_numbers(&func); }     \
+  TEST_F(LlvmLibcMulTest, InvalidOperations) {                                 \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcMulTest, RangeErrors) { test_range_errors(&func); }           \
+  TEST_F(LlvmLibcMulTest, InexactResults) { test_inexact_results(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_MULTEST_H
diff --git a/test/src/math/smoke/NearbyIntTest.h b/test/src/math/smoke/NearbyIntTest.h
index 0051ff9..092700e 100644
--- a/test/src/math/smoke/NearbyIntTest.h
+++ b/test/src/math/smoke/NearbyIntTest.h
@@ -15,6 +15,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 static constexpr int ROUNDING_MODES[4] = {FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO,
                                           FE_TONEAREST};
 
diff --git a/test/src/math/smoke/NextAfterTest.h b/test/src/math/smoke/NextAfterTest.h
index 6278f89..e62832e 100644
--- a/test/src/math/smoke/NextAfterTest.h
+++ b/test/src/math/smoke/NextAfterTest.h
@@ -18,6 +18,8 @@
 
 #include "hdr/fenv_macros.h"
 
+using LIBC_NAMESPACE::Sign;
+
 // TODO: Strengthen errno,exception checks and remove these assert macros
 // after new matchers/test fixtures are added
 #define ASSERT_FP_EQ_WITH_EXCEPTION(result, expected, expected_exception)      \
diff --git a/test/src/math/smoke/NextTowardTest.h b/test/src/math/smoke/NextTowardTest.h
index 5992273..a4cd5d0 100644
--- a/test/src/math/smoke/NextTowardTest.h
+++ b/test/src/math/smoke/NextTowardTest.h
@@ -18,6 +18,8 @@
 
 #include "hdr/fenv_macros.h"
 
+using LIBC_NAMESPACE::Sign;
+
 // TODO: Strengthen errno,exception checks and remove these assert macros
 // after new matchers/test fixtures are added
 #define ASSERT_FP_EQ_WITH_EXCEPTION(result, expected, expected_exception)      \
@@ -43,6 +45,8 @@ class NextTowardTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   const T neg_zero = FPBits::zero(Sign::NEG).get_val();
   const T nan = FPBits::quiet_nan().get_val();
 
+  const long double to_inf = ToFPBits::inf(Sign::POS).get_val();
+  const long double to_neg_inf = ToFPBits::inf(Sign::NEG).get_val();
   const long double to_zero = ToFPBits::zero().get_val();
   const long double to_neg_zero = ToFPBits::zero(Sign::NEG).get_val();
   const long double to_nan = ToFPBits::quiet_nan().get_val();
@@ -134,7 +138,7 @@ public:
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ_WITH_UNDERFLOW(result, expected);
 
-    result = func(x, inf);
+    result = func(x, to_inf);
     expected_bits = min_normal + 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
@@ -145,7 +149,7 @@ public:
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ_WITH_UNDERFLOW(result, expected);
 
-    result = func(x, -inf);
+    result = func(x, to_neg_inf);
     expected_bits = FPBits::SIGN_MASK + min_normal + 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
@@ -156,14 +160,14 @@ public:
     expected_bits = max_normal - 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
-    ASSERT_FP_EQ_WITH_OVERFLOW(func(x, inf), inf);
+    ASSERT_FP_EQ_WITH_OVERFLOW(func(x, to_inf), inf);
 
     x = -x;
     result = func(x, 0);
     expected_bits = FPBits::SIGN_MASK + max_normal - 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
-    ASSERT_FP_EQ_WITH_OVERFLOW(func(x, -inf), -inf);
+    ASSERT_FP_EQ_WITH_OVERFLOW(func(x, to_neg_inf), neg_inf);
 
     // 'from' is infinity.
     x = inf;
@@ -171,14 +175,14 @@ public:
     expected_bits = max_normal;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
-    ASSERT_FP_EQ(func(x, inf), inf);
+    ASSERT_FP_EQ(func(x, to_inf), inf);
 
     x = neg_inf;
     result = func(x, 0);
     expected_bits = FPBits::SIGN_MASK + max_normal;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
-    ASSERT_FP_EQ(func(x, neg_inf), neg_inf);
+    ASSERT_FP_EQ(func(x, to_neg_inf), neg_inf);
 
     // 'from' is a power of 2.
     x = T(32.0);
diff --git a/test/src/math/smoke/RIntTest.h b/test/src/math/smoke/RIntTest.h
index 1412c3f..7f14aeb 100644
--- a/test/src/math/smoke/RIntTest.h
+++ b/test/src/math/smoke/RIntTest.h
@@ -17,7 +17,8 @@
 
 #include "hdr/fenv_macros.h"
 #include "hdr/math_macros.h"
-#include <stdio.h>
+
+using LIBC_NAMESPACE::Sign;
 
 static constexpr int ROUNDING_MODES[4] = {FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO,
                                           FE_TONEAREST};
diff --git a/test/src/math/smoke/RemQuoTest.h b/test/src/math/smoke/RemQuoTest.h
index e926326..2fdb594 100644
--- a/test/src/math/smoke/RemQuoTest.h
+++ b/test/src/math/smoke/RemQuoTest.h
@@ -14,6 +14,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class RemQuoTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
   using FPBits = LIBC_NAMESPACE::fputil::FPBits<T>;
diff --git a/test/src/math/smoke/RoundToIntegerTest.h b/test/src/math/smoke/RoundToIntegerTest.h
index fd3fbde..6ae97ce 100644
--- a/test/src/math/smoke/RoundToIntegerTest.h
+++ b/test/src/math/smoke/RoundToIntegerTest.h
@@ -12,13 +12,11 @@
 #include "src/__support/CPP/algorithm.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/macros/properties/architectures.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/math_macros.h"
-#include <errno.h>
 
 static constexpr int ROUNDING_MODES[4] = {FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO,
                                           FE_TONEAREST};
@@ -51,12 +49,10 @@ private:
     // 0 for errno and exceptions, but this doesn't hold for
     // all math functions using RoundToInteger test:
     // https://github.com/llvm/llvm-project/pull/88816
-#ifndef LIBC_TARGET_ARCH_IS_GPU
     if (expectError) {
       ASSERT_FP_EXCEPTION(FE_INVALID);
       ASSERT_MATH_ERRNO(EDOM);
     }
-#endif
   }
 
 public:
@@ -169,7 +165,13 @@ public:
 #define LIST_ROUND_TO_INTEGER_TESTS(F, I, func)                                \
   LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, false)
 
+// The GPU target does not support different rounding modes.
+#ifdef LIBC_TARGET_ARCH_IS_GPU
+#define LIST_ROUND_TO_INTEGER_TESTS_WITH_MODES(F, I, func)                     \
+  LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, false)
+#else
 #define LIST_ROUND_TO_INTEGER_TESTS_WITH_MODES(F, I, func)                     \
   LIST_ROUND_TO_INTEGER_TESTS_HELPER(F, I, func, true)
+#endif
 
 #endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_ROUNDTOINTEGERTEST_H
diff --git a/test/src/math/smoke/SetPayloadSigTest.h b/test/src/math/smoke/SetPayloadSigTest.h
index 7ec3ac0..f480479 100644
--- a/test/src/math/smoke/SetPayloadSigTest.h
+++ b/test/src/math/smoke/SetPayloadSigTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class SetPayloadSigTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
@@ -35,7 +37,13 @@ public:
     EXPECT_EQ(1, func(&res, T(-1.0)));
     EXPECT_EQ(1, func(&res, T(0x42.1p+0)));
     EXPECT_EQ(1, func(&res, T(-0x42.1p+0)));
-    EXPECT_EQ(1, func(&res, T(StorageType(1) << (FPBits::FRACTION_LEN - 1))));
+
+    FPBits default_snan_payload_bits = FPBits::one();
+    default_snan_payload_bits.set_biased_exponent(FPBits::FRACTION_LEN - 1 +
+                                                  FPBits::EXP_BIAS);
+    T default_snan_payload = default_snan_payload_bits.get_val();
+
+    EXPECT_EQ(1, func(&res, default_snan_payload));
   }
 
   void testValidPayloads(SetPayloadSigFunc func) {
@@ -56,7 +64,12 @@ public:
     EXPECT_EQ(FPBits::signaling_nan(Sign::POS, 0x123).uintval(),
               FPBits(res).uintval());
 
-    EXPECT_EQ(0, func(&res, T(FPBits::FRACTION_MASK >> 1)));
+    FPBits nan_payload_bits = FPBits::one();
+    nan_payload_bits.set_biased_exponent(FPBits::FRACTION_LEN - 2 +
+                                         FPBits::EXP_BIAS);
+    nan_payload_bits.set_mantissa(FPBits::SIG_MASK - 3);
+    T nan_payload = nan_payload_bits.get_val();
+    EXPECT_EQ(0, func(&res, nan_payload));
     EXPECT_TRUE(FPBits(res).is_signaling_nan());
     EXPECT_EQ(
         FPBits::signaling_nan(Sign::POS, FPBits::FRACTION_MASK >> 1).uintval(),
diff --git a/test/src/math/smoke/SetPayloadTest.h b/test/src/math/smoke/SetPayloadTest.h
index 4b0dacf..9ede567 100644
--- a/test/src/math/smoke/SetPayloadTest.h
+++ b/test/src/math/smoke/SetPayloadTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class SetPayloadTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
@@ -33,7 +35,12 @@ public:
     EXPECT_EQ(1, func(&res, T(-1.0)));
     EXPECT_EQ(1, func(&res, T(0x42.1p+0)));
     EXPECT_EQ(1, func(&res, T(-0x42.1p+0)));
-    EXPECT_EQ(1, func(&res, T(StorageType(1) << (FPBits::FRACTION_LEN - 1))));
+
+    FPBits nan_payload_bits = FPBits::one();
+    nan_payload_bits.set_biased_exponent(FPBits::FRACTION_LEN - 1 +
+                                         FPBits::EXP_BIAS);
+    T nan_payload = nan_payload_bits.get_val();
+    EXPECT_EQ(1, func(&res, nan_payload));
   }
 
   void testValidPayloads(SetPayloadFunc func) {
@@ -57,7 +64,15 @@ public:
     EXPECT_EQ(FPBits::quiet_nan(Sign::POS, 0x123).uintval(),
               FPBits(res).uintval());
 
-    EXPECT_EQ(0, func(&res, T(FPBits::FRACTION_MASK >> 1)));
+    // The following code is creating a NaN payload manually to prevent a
+    // conversion from BigInt to float128.
+    FPBits nan_payload_bits = FPBits::one();
+    nan_payload_bits.set_biased_exponent(FPBits::FRACTION_LEN - 2 +
+                                         FPBits::EXP_BIAS);
+    nan_payload_bits.set_mantissa(FPBits::SIG_MASK - 3);
+    T nan_payload = nan_payload_bits.get_val();
+
+    EXPECT_EQ(0, func(&res, nan_payload));
     EXPECT_TRUE(FPBits(res).is_quiet_nan());
     EXPECT_EQ(
         FPBits::quiet_nan(Sign::POS, FPBits::FRACTION_MASK >> 1).uintval(),
diff --git a/test/src/math/smoke/SqrtTest.h b/test/src/math/smoke/SqrtTest.h
index ce9f2f8..b5eaee2 100644
--- a/test/src/math/smoke/SqrtTest.h
+++ b/test/src/math/smoke/SqrtTest.h
@@ -15,15 +15,21 @@ class SqrtTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
   DECLARE_SPECIAL_CONSTANTS(OutType)
 
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  InConstants in;
+
 public:
   typedef OutType (*SqrtFunc)(InType);
 
   void test_special_numbers(SqrtFunc func) {
-    ASSERT_FP_EQ(aNaN, func(aNaN));
-    ASSERT_FP_EQ(inf, func(inf));
-    ASSERT_FP_EQ(aNaN, func(neg_inf));
-    ASSERT_FP_EQ(zero, func(zero));
-    ASSERT_FP_EQ(neg_zero, func(neg_zero));
+    ASSERT_FP_EQ(aNaN, func(in.aNaN));
+    ASSERT_FP_EQ(inf, func(in.inf));
+    ASSERT_FP_EQ(aNaN, func(in.neg_inf));
+    ASSERT_FP_EQ(zero, func(in.zero));
+    ASSERT_FP_EQ(neg_zero, func(in.neg_zero));
     ASSERT_FP_EQ(aNaN, func(InType(-1.0)));
     ASSERT_FP_EQ(OutType(1.0), func(InType(1.0)));
     ASSERT_FP_EQ(OutType(2.0), func(InType(4.0)));
diff --git a/test/src/math/smoke/SubTest.h b/test/src/math/smoke/SubTest.h
new file mode 100644
index 0000000..ca95200
--- /dev/null
+++ b/test/src/math/smoke/SubTest.h
@@ -0,0 +1,150 @@
+//===-- Utility class to test different flavors of float sub ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_MATH_SMOKE_SUBTEST_H
+#define LLVM_LIBC_TEST_SRC_MATH_SMOKE_SUBTEST_H
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/macros/properties/os.h"
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::Sign;
+
+template <typename OutType, typename InType>
+class SubTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(OutType)
+
+  struct InConstants {
+    DECLARE_SPECIAL_CONSTANTS(InType)
+  };
+
+  using InFPBits = typename InConstants::FPBits;
+  using InStorageType = typename InConstants::StorageType;
+
+  InConstants in;
+
+public:
+  using SubFunc = OutType (*)(InType, InType);
+
+  void test_special_numbers(SubFunc func) {
+    EXPECT_FP_IS_NAN(func(in.aNaN, in.aNaN));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.sNaN, in.sNaN), FE_INVALID);
+
+    InType qnan_42 = InFPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    EXPECT_FP_IS_NAN(func(qnan_42, in.zero));
+    EXPECT_FP_IS_NAN(func(in.zero, qnan_42));
+
+    EXPECT_FP_EQ(inf, func(in.inf, in.zero));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, in.zero));
+    EXPECT_FP_EQ(inf, func(in.inf, in.neg_zero));
+    EXPECT_FP_EQ(neg_inf, func(in.neg_inf, in.neg_zero));
+  }
+
+  void test_invalid_operations(SubFunc func) {
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.inf, in.inf), FE_INVALID);
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(func(in.neg_inf, in.neg_inf), FE_INVALID);
+  }
+
+  void test_range_errors(SubFunc func) {
+#ifndef LIBC_TARGET_OS_IS_WINDOWS
+    using namespace LIBC_NAMESPACE::fputil::testing;
+
+    if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf, func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero,
+                                  func(in.min_denormal, in.neg_min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::TowardZero); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero,
+                                  func(in.min_denormal, in.neg_min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Downward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(max_normal,
+                                  func(in.max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_FP_EQ_WITH_EXCEPTION(-inf, func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(zero,
+                                  func(in.min_denormal, in.neg_min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_min_denormal,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+
+    if (ForceRoundingMode r(RoundingMode::Upward); r.success) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.neg_max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_max_normal,
+                                  func(in.neg_max_normal, in.max_normal),
+                                  FE_OVERFLOW | FE_INEXACT);
+
+      EXPECT_FP_EQ_WITH_EXCEPTION(min_denormal,
+                                  func(in.min_denormal, in.neg_min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+      EXPECT_FP_EQ_WITH_EXCEPTION(neg_zero,
+                                  func(in.neg_min_denormal, in.min_denormal),
+                                  FE_UNDERFLOW | FE_INEXACT);
+      EXPECT_MATH_ERRNO(ERANGE);
+    }
+#endif
+  }
+
+  void test_inexact_results(SubFunc func) {
+    func(InType(1.0), in.min_denormal);
+    EXPECT_FP_EXCEPTION(FE_INEXACT);
+  }
+};
+
+#define LIST_SUB_TESTS(OutType, InType, func)                                  \
+  using LlvmLibcSubTest = SubTest<OutType, InType>;                            \
+  TEST_F(LlvmLibcSubTest, SpecialNumbers) { test_special_numbers(&func); }     \
+  TEST_F(LlvmLibcSubTest, InvalidOperations) {                                 \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcSubTest, RangeErrors) { test_range_errors(&func); }           \
+  TEST_F(LlvmLibcSubTest, InexactResults) { test_inexact_results(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_SUBTEST_H
diff --git a/test/src/math/smoke/TotalOrderMagTest.h b/test/src/math/smoke/TotalOrderMagTest.h
index 5fe2983..0a13fd2 100644
--- a/test/src/math/smoke/TotalOrderMagTest.h
+++ b/test/src/math/smoke/TotalOrderMagTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class TotalOrderMagTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
@@ -104,24 +106,24 @@ public:
   }
 
   void testNaNPayloads(TotalOrderMagFunc func) {
-    T qnan_123 = FPBits::quiet_nan(Sign::POS, 0x123).get_val();
-    T neg_qnan_123 = FPBits::quiet_nan(Sign::NEG, 0x123).get_val();
-    T snan_123 = FPBits::signaling_nan(Sign::POS, 0x123).get_val();
-    T neg_snan_123 = FPBits::signaling_nan(Sign::NEG, 0x123).get_val();
+    T qnan_0x42 = FPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    T neg_qnan_0x42 = FPBits::quiet_nan(Sign::NEG, 0x42).get_val();
+    T snan_0x42 = FPBits::signaling_nan(Sign::POS, 0x42).get_val();
+    T neg_snan_0x42 = FPBits::signaling_nan(Sign::NEG, 0x42).get_val();
 
     EXPECT_TRUE(funcWrapper(func, aNaN, aNaN));
     EXPECT_TRUE(funcWrapper(func, sNaN, sNaN));
-    EXPECT_TRUE(funcWrapper(func, aNaN, qnan_123));
-    EXPECT_TRUE(funcWrapper(func, sNaN, snan_123));
-    EXPECT_FALSE(funcWrapper(func, qnan_123, aNaN));
-    EXPECT_FALSE(funcWrapper(func, snan_123, sNaN));
+    EXPECT_TRUE(funcWrapper(func, aNaN, qnan_0x42));
+    EXPECT_FALSE(funcWrapper(func, sNaN, snan_0x42));
+    EXPECT_FALSE(funcWrapper(func, qnan_0x42, aNaN));
+    EXPECT_TRUE(funcWrapper(func, snan_0x42, sNaN));
 
     EXPECT_TRUE(funcWrapper(func, neg_aNaN, neg_aNaN));
     EXPECT_TRUE(funcWrapper(func, neg_sNaN, neg_sNaN));
-    EXPECT_TRUE(funcWrapper(func, neg_aNaN, neg_qnan_123));
-    EXPECT_TRUE(funcWrapper(func, neg_sNaN, neg_snan_123));
-    EXPECT_FALSE(funcWrapper(func, neg_qnan_123, neg_aNaN));
-    EXPECT_FALSE(funcWrapper(func, neg_snan_123, neg_sNaN));
+    EXPECT_TRUE(funcWrapper(func, neg_aNaN, neg_qnan_0x42));
+    EXPECT_FALSE(funcWrapper(func, neg_sNaN, neg_snan_0x42));
+    EXPECT_FALSE(funcWrapper(func, neg_qnan_0x42, neg_aNaN));
+    EXPECT_TRUE(funcWrapper(func, neg_snan_0x42, neg_sNaN));
   }
 };
 
diff --git a/test/src/math/smoke/TotalOrderTest.h b/test/src/math/smoke/TotalOrderTest.h
index 281b2a5..e426eb3 100644
--- a/test/src/math/smoke/TotalOrderTest.h
+++ b/test/src/math/smoke/TotalOrderTest.h
@@ -13,6 +13,8 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::Sign;
+
 template <typename T>
 class TotalOrderTestTemplate : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 
@@ -102,24 +104,24 @@ public:
   }
 
   void testNaNPayloads(TotalOrderFunc func) {
-    T qnan_123 = FPBits::quiet_nan(Sign::POS, 0x123).get_val();
-    T neg_qnan_123 = FPBits::quiet_nan(Sign::NEG, 0x123).get_val();
-    T snan_123 = FPBits::signaling_nan(Sign::POS, 0x123).get_val();
-    T neg_snan_123 = FPBits::signaling_nan(Sign::NEG, 0x123).get_val();
+    T qnan_0x42 = FPBits::quiet_nan(Sign::POS, 0x42).get_val();
+    T neg_qnan_0x42 = FPBits::quiet_nan(Sign::NEG, 0x42).get_val();
+    T snan_0x42 = FPBits::signaling_nan(Sign::POS, 0x42).get_val();
+    T neg_snan_0x42 = FPBits::signaling_nan(Sign::NEG, 0x42).get_val();
 
     EXPECT_TRUE(funcWrapper(func, aNaN, aNaN));
     EXPECT_TRUE(funcWrapper(func, sNaN, sNaN));
-    EXPECT_TRUE(funcWrapper(func, aNaN, qnan_123));
-    EXPECT_TRUE(funcWrapper(func, sNaN, snan_123));
-    EXPECT_FALSE(funcWrapper(func, qnan_123, aNaN));
-    EXPECT_FALSE(funcWrapper(func, snan_123, sNaN));
+    EXPECT_TRUE(funcWrapper(func, aNaN, qnan_0x42));
+    EXPECT_FALSE(funcWrapper(func, sNaN, snan_0x42));
+    EXPECT_FALSE(funcWrapper(func, qnan_0x42, aNaN));
+    EXPECT_TRUE(funcWrapper(func, snan_0x42, sNaN));
 
     EXPECT_TRUE(funcWrapper(func, neg_aNaN, neg_aNaN));
     EXPECT_TRUE(funcWrapper(func, neg_sNaN, neg_sNaN));
-    EXPECT_FALSE(funcWrapper(func, neg_aNaN, neg_qnan_123));
-    EXPECT_FALSE(funcWrapper(func, neg_sNaN, neg_snan_123));
-    EXPECT_TRUE(funcWrapper(func, neg_qnan_123, neg_aNaN));
-    EXPECT_TRUE(funcWrapper(func, neg_snan_123, neg_sNaN));
+    EXPECT_FALSE(funcWrapper(func, neg_aNaN, neg_qnan_0x42));
+    EXPECT_TRUE(funcWrapper(func, neg_sNaN, neg_snan_0x42));
+    EXPECT_TRUE(funcWrapper(func, neg_qnan_0x42, neg_aNaN));
+    EXPECT_FALSE(funcWrapper(func, neg_snan_0x42, neg_sNaN));
   }
 };
 
diff --git a/test/src/math/smoke/acosf_test.cpp b/test/src/math/smoke/acosf_test.cpp
index 732c295..e5d56c7 100644
--- a/test/src/math/smoke/acosf_test.cpp
+++ b/test/src/math/smoke/acosf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAcosfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -39,3 +38,27 @@ TEST_F(LlvmLibcAcosfTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::acosf(-2.0f));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAcosfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0x1.921fb6p0f, LIBC_NAMESPACE::acosf(min_denormal));
+}
+
+TEST_F(LlvmLibcAcosfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0x1.921fb6p0f, LIBC_NAMESPACE::acosf(min_denormal));
+}
+
+TEST_F(LlvmLibcAcosfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0x1.921fb6p0f, LIBC_NAMESPACE::acosf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/acoshf_test.cpp b/test/src/math/smoke/acoshf_test.cpp
index 2e94216..c4e8825 100644
--- a/test/src/math/smoke/acoshf_test.cpp
+++ b/test/src/math/smoke/acoshf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAcoshfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,27 @@ TEST_F(LlvmLibcAcoshfTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::acoshf(neg_inf));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAcoshfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_IS_NAN(LIBC_NAMESPACE::acoshf(min_denormal));
+}
+
+TEST_F(LlvmLibcAcoshfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_IS_NAN(LIBC_NAMESPACE::acoshf(min_denormal));
+}
+
+TEST_F(LlvmLibcAcoshfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_IS_NAN(LIBC_NAMESPACE::acoshf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/asinf_test.cpp b/test/src/math/smoke/asinf_test.cpp
index c67d077..ce1576e 100644
--- a/test/src/math/smoke/asinf_test.cpp
+++ b/test/src/math/smoke/asinf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAsinfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -42,3 +41,27 @@ TEST_F(LlvmLibcAsinfTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::asinf(-2.0f));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAsinfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinf(min_denormal));
+}
+
+TEST_F(LlvmLibcAsinfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinf(min_denormal));
+}
+
+TEST_F(LlvmLibcAsinfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/asinhf_test.cpp b/test/src/math/smoke/asinhf_test.cpp
index f951846..5b83ce6 100644
--- a/test/src/math/smoke/asinhf_test.cpp
+++ b/test/src/math/smoke/asinhf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAsinhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,27 @@ TEST_F(LlvmLibcAsinhfTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, LIBC_NAMESPACE::asinhf(neg_inf));
   EXPECT_MATH_ERRNO(0);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAsinhfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinhf(min_denormal));
+}
+
+TEST_F(LlvmLibcAsinhfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinhf(min_denormal));
+}
+
+TEST_F(LlvmLibcAsinhfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::asinhf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/atan2_test.cpp b/test/src/math/smoke/atan2_test.cpp
new file mode 100644
index 0000000..1606c3f
--- /dev/null
+++ b/test/src/math/smoke/atan2_test.cpp
@@ -0,0 +1,59 @@
+//===-- Unittests for atan2 -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/atan2.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcAtan2Test = LIBC_NAMESPACE::testing::FPTest<double>;
+
+TEST_F(LlvmLibcAtan2Test, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::atan2(aNaN, zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::atan2(1.0, aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(0.0, LIBC_NAMESPACE::atan2(zero, zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(-0.0, LIBC_NAMESPACE::atan2(-0.0, zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(0.0, LIBC_NAMESPACE::atan2(1.0, inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(-0.0, LIBC_NAMESPACE::atan2(-1.0, inf));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAtan2Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0x1.921fb54442d18p-1,
+               LIBC_NAMESPACE::atan2(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0x1.0000000000001p-52,
+               LIBC_NAMESPACE::atan2(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0x1.921fb54442d17p0,
+               LIBC_NAMESPACE::atan2(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0x1.921fb54442d18p-1,
+               LIBC_NAMESPACE::atan2(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcAtan2Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcAtan2Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::atan2(max_denormal, max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/atan2f_test.cpp b/test/src/math/smoke/atan2f_test.cpp
index 32a28cf..94ec18d 100644
--- a/test/src/math/smoke/atan2f_test.cpp
+++ b/test/src/math/smoke/atan2f_test.cpp
@@ -58,3 +58,40 @@ TEST_F(LlvmLibcAtan2fTest, SpecialNumbers) {
   // EXPECT_FP_EXCEPTION(0);
   EXPECT_MATH_ERRNO(0);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAtan2fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0x1.921fb6p-1f,
+               LIBC_NAMESPACE::atan2f(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0x1.000002p-23f,
+               LIBC_NAMESPACE::atan2f(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0x1.921fb4p0f,
+               LIBC_NAMESPACE::atan2f(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0x1.921fb6p-1f,
+               LIBC_NAMESPACE::atan2f(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcAtan2fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcAtan2fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atan2f(max_denormal, max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/atanf_test.cpp b/test/src/math/smoke/atanf_test.cpp
index 56bf2f9..346b8e8 100644
--- a/test/src/math/smoke/atanf_test.cpp
+++ b/test/src/math/smoke/atanf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcAtanfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -43,3 +42,27 @@ TEST_F(LlvmLibcAtanfTest, SpecialNumbers) {
   // EXPECT_FP_EXCEPTION(0);
   EXPECT_MATH_ERRNO(0);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAtanfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanf(min_denormal));
+}
+
+TEST_F(LlvmLibcAtanfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanf(min_denormal));
+}
+
+TEST_F(LlvmLibcAtanfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/atanhf_test.cpp b/test/src/math/smoke/atanhf_test.cpp
index 2d2acfe..8300b47 100644
--- a/test/src/math/smoke/atanhf_test.cpp
+++ b/test/src/math/smoke/atanhf_test.cpp
@@ -13,9 +13,10 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
+using LIBC_NAMESPACE::Sign;
+
 using LlvmLibcAtanhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
 
 TEST_F(LlvmLibcAtanhfTest, SpecialNumbers) {
@@ -75,3 +76,27 @@ TEST_F(LlvmLibcAtanhfTest, SpecialNumbers) {
   EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::atanhf(neg_inf), FE_INVALID);
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcAtanhfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanhf(min_denormal));
+}
+
+TEST_F(LlvmLibcAtanhfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanhf(min_denormal));
+}
+
+TEST_F(LlvmLibcAtanhfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::atanhf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/cbrt_test.cpp b/test/src/math/smoke/cbrt_test.cpp
new file mode 100644
index 0000000..092e6dd
--- /dev/null
+++ b/test/src/math/smoke/cbrt_test.cpp
@@ -0,0 +1,64 @@
+//===-- Unittests for cbrt ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cbrt.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCbrtTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcCbrtTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cbrt(aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::cbrt(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, LIBC_NAMESPACE::cbrt(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::cbrt(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::cbrt(neg_zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0, LIBC_NAMESPACE::cbrt(1.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(-1.0, LIBC_NAMESPACE::cbrt(-1.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(2.0, LIBC_NAMESPACE::cbrt(8.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(-2.0, LIBC_NAMESPACE::cbrt(-8.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(3.0, LIBC_NAMESPACE::cbrt(27.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(-3.0, LIBC_NAMESPACE::cbrt(-27.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(5.0, LIBC_NAMESPACE::cbrt(125.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(-5.0, LIBC_NAMESPACE::cbrt(-125.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(0x1.0p42, LIBC_NAMESPACE::cbrt(0x1.0p126));
+  EXPECT_FP_EQ_ALL_ROUNDING(-0x1.0p42, LIBC_NAMESPACE::cbrt(-0x1.0p126));
+  EXPECT_FP_EQ_ALL_ROUNDING(0x1.0p341, LIBC_NAMESPACE::cbrt(0x1.0p1023));
+  EXPECT_FP_EQ_ALL_ROUNDING(-0x1.0p341, LIBC_NAMESPACE::cbrt(-0x1.0p1023));
+  EXPECT_FP_EQ(-0x1.0p-340, LIBC_NAMESPACE::cbrt(-0x1.fffffffffffffp-1021));
+  EXPECT_FP_EQ(2.0, LIBC_NAMESPACE::cbrt(0x1.fffffffffffffp2));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCbrtTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0x1.0p-358, LIBC_NAMESPACE::cbrt(min_denormal));
+  EXPECT_FP_EQ(0x1.428a2f98d728ap-341, LIBC_NAMESPACE::cbrt(max_denormal));
+}
+
+TEST_F(LlvmLibcCbrtTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cbrt(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cbrt(max_denormal));
+}
+
+TEST_F(LlvmLibcCbrtTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cbrt(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::cbrt(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/cbrtf_test.cpp b/test/src/math/smoke/cbrtf_test.cpp
new file mode 100644
index 0000000..202a5ce
--- /dev/null
+++ b/test/src/math/smoke/cbrtf_test.cpp
@@ -0,0 +1,60 @@
+//===-- Unittests for cbrtf -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cbrtf.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCbrtfTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcCbrtfTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cbrtf(aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::cbrtf(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, LIBC_NAMESPACE::cbrtf(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::cbrtf(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::cbrtf(neg_zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0f, LIBC_NAMESPACE::cbrtf(1.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(-1.0f, LIBC_NAMESPACE::cbrtf(-1.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(2.0f, LIBC_NAMESPACE::cbrtf(8.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(-2.0f, LIBC_NAMESPACE::cbrtf(-8.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(3.0f, LIBC_NAMESPACE::cbrtf(27.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(-3.0f, LIBC_NAMESPACE::cbrtf(-27.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(5.0f, LIBC_NAMESPACE::cbrtf(125.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(-5.0f, LIBC_NAMESPACE::cbrtf(-125.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(0x1.0p42f, LIBC_NAMESPACE::cbrtf(0x1.0p126f));
+  EXPECT_FP_EQ_ALL_ROUNDING(-0x1.0p42f, LIBC_NAMESPACE::cbrtf(-0x1.0p126f));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCbrtfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0x1.428a3p-50f, LIBC_NAMESPACE::cbrtf(min_denormal));
+  EXPECT_FP_EQ(0x1.fffffep-43f, LIBC_NAMESPACE::cbrtf(max_denormal));
+}
+
+TEST_F(LlvmLibcCbrtfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::cbrtf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::cbrtf(max_denormal));
+}
+
+TEST_F(LlvmLibcCbrtfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::cbrtf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::cbrtf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/cos_test.cpp b/test/src/math/smoke/cos_test.cpp
new file mode 100644
index 0000000..88d8ead
--- /dev/null
+++ b/test/src/math/smoke/cos_test.cpp
@@ -0,0 +1,53 @@
+//===-- Unittests for cos -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cos.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCosTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcCosTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cos(aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cos(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cos(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0, LIBC_NAMESPACE::cos(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0, LIBC_NAMESPACE::cos(neg_zero));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(0x1.0p-50));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(min_normal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(min_denormal));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCosTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(max_denormal));
+}
+
+TEST_F(LlvmLibcCosTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(max_denormal));
+}
+
+TEST_F(LlvmLibcCosTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::cos(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/cosf_test.cpp b/test/src/math/smoke/cosf_test.cpp
index 7000fe2..2e261f9 100644
--- a/test/src/math/smoke/cosf_test.cpp
+++ b/test/src/math/smoke/cosf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcCosfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,30 @@ TEST_F(LlvmLibcCosfTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::cosf(neg_inf));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCosfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(max_denormal));
+}
+
+TEST_F(LlvmLibcCosfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(max_denormal));
+}
+
+TEST_F(LlvmLibcCosfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/coshf16_test.cpp b/test/src/math/smoke/coshf16_test.cpp
new file mode 100644
index 0000000..08d05ec
--- /dev/null
+++ b/test/src/math/smoke/coshf16_test.cpp
@@ -0,0 +1,90 @@
+//===-- Unittests for coshf16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/coshf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCoshf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcCoshf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::coshf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::coshf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::coshf16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::coshf16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0),
+                            LIBC_NAMESPACE::coshf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0),
+                            LIBC_NAMESPACE::coshf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcCoshf16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::coshf16(max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::coshf16(neg_max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  // round(acosh(2^16), HP, RU);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.794p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(inf, LIBC_NAMESPACE::coshf16(x),
+                                               FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(inf, LIBC_NAMESPACE::coshf16(x),
+                                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::coshf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::coshf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  // round(-acosh(2^16), HP, RD);
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.794p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(inf, LIBC_NAMESPACE::coshf16(x),
+                                               FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(inf, LIBC_NAMESPACE::coshf16(x),
+                                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::coshf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::coshf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
diff --git a/test/src/math/smoke/coshf_test.cpp b/test/src/math/smoke/coshf_test.cpp
index 4d915b1..fd1556b 100644
--- a/test/src/math/smoke/coshf_test.cpp
+++ b/test/src/math/smoke/coshf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcCoshfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -52,3 +51,30 @@ TEST_F(LlvmLibcCoshfTest, Overflow) {
       inf, LIBC_NAMESPACE::coshf(FPBits(0x42d00008U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCoshfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(max_denormal));
+}
+
+TEST_F(LlvmLibcCoshfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(max_denormal));
+}
+
+TEST_F(LlvmLibcCoshfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::coshf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/cospif16_test.cpp b/test/src/math/smoke/cospif16_test.cpp
new file mode 100644
index 0000000..f6d7483
--- /dev/null
+++ b/test/src/math/smoke/cospif16_test.cpp
@@ -0,0 +1,44 @@
+//===-- Unittests for cospif16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/cospif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCospif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcCospif16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+TEST_F(LlvmLibcCospif16Test, Integers) {
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(-0x420));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(-0x1.4p+14));
+  EXPECT_FP_EQ(-1.0f, LIBC_NAMESPACE::cospif16(0x421));
+  EXPECT_FP_EQ(-1.0f, LIBC_NAMESPACE::cospif16(0x333));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(-0x1.28p4));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(-0x1.ffcp9));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(0x1.01p7));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(0x1.f6cp9));
+}
diff --git a/test/src/math/smoke/cospif_test.cpp b/test/src/math/smoke/cospif_test.cpp
new file mode 100644
index 0000000..bf6d86b
--- /dev/null
+++ b/test/src/math/smoke/cospif_test.cpp
@@ -0,0 +1,61 @@
+//===-- Unittests for cospif ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/cospif.h"
+#include "test/UnitTest/FPMatcher.h"
+
+#include <stdint.h>
+
+using LlvmLibcCospifTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+TEST_F(LlvmLibcCospifTest, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(-0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcCospifTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(max_denormal));
+}
+
+TEST_F(LlvmLibcCospifTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(max_denormal));
+}
+
+TEST_F(LlvmLibcCospifTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/daddf128_test.cpp b/test/src/math/smoke/daddf128_test.cpp
new file mode 100644
index 0000000..ca0bbff
--- /dev/null
+++ b/test/src/math/smoke/daddf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for daddf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/daddf128.h"
+
+LIST_ADD_TESTS(double, float128, LIBC_NAMESPACE::daddf128)
diff --git a/test/src/math/smoke/daddl_test.cpp b/test/src/math/smoke/daddl_test.cpp
new file mode 100644
index 0000000..7a34d96
--- /dev/null
+++ b/test/src/math/smoke/daddl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for daddl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/daddl.h"
+
+LIST_ADD_TESTS(double, long double, LIBC_NAMESPACE::daddl)
diff --git a/test/src/math/smoke/ddivf128_test.cpp b/test/src/math/smoke/ddivf128_test.cpp
new file mode 100644
index 0000000..b5f3915
--- /dev/null
+++ b/test/src/math/smoke/ddivf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ddivf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/ddivf128.h"
+
+LIST_DIV_TESTS(double, float128, LIBC_NAMESPACE::ddivf128)
diff --git a/test/src/math/smoke/ddivl_test.cpp b/test/src/math/smoke/ddivl_test.cpp
new file mode 100644
index 0000000..7768766
--- /dev/null
+++ b/test/src/math/smoke/ddivl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ddivl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/ddivl.h"
+
+LIST_DIV_TESTS(double, long double, LIBC_NAMESPACE::ddivl)
diff --git a/test/src/math/smoke/dfmaf128_test.cpp b/test/src/math/smoke/dfmaf128_test.cpp
new file mode 100644
index 0000000..56c1174
--- /dev/null
+++ b/test/src/math/smoke/dfmaf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dfmaf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/dfmaf128.h"
+
+LIST_NARROWING_FMA_TESTS(double, float128, LIBC_NAMESPACE::dfmaf128)
diff --git a/test/src/math/smoke/dfmal_test.cpp b/test/src/math/smoke/dfmal_test.cpp
new file mode 100644
index 0000000..3c38f5e
--- /dev/null
+++ b/test/src/math/smoke/dfmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dfmal -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/dfmal.h"
+
+LIST_NARROWING_FMA_TESTS(double, long double, LIBC_NAMESPACE::dfmal)
diff --git a/test/src/math/smoke/dmulf128_test.cpp b/test/src/math/smoke/dmulf128_test.cpp
new file mode 100644
index 0000000..2ee2d10
--- /dev/null
+++ b/test/src/math/smoke/dmulf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dmulf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/dmulf128.h"
+
+LIST_MUL_TESTS(double, float128, LIBC_NAMESPACE::dmulf128)
diff --git a/test/src/math/smoke/dmull_test.cpp b/test/src/math/smoke/dmull_test.cpp
new file mode 100644
index 0000000..1b9c9c2
--- /dev/null
+++ b/test/src/math/smoke/dmull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dmull -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/dmull.h"
+
+LIST_MUL_TESTS(double, long double, LIBC_NAMESPACE::dmull)
diff --git a/test/src/math/smoke/dsqrtf128_test.cpp b/test/src/math/smoke/dsqrtf128_test.cpp
new file mode 100644
index 0000000..6f98d1c
--- /dev/null
+++ b/test/src/math/smoke/dsqrtf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsqrtf128 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/dsqrtf128.h"
+
+LIST_NARROWING_SQRT_TESTS(double, float128, LIBC_NAMESPACE::dsqrtf128)
diff --git a/test/src/math/smoke/dsqrtl_test.cpp b/test/src/math/smoke/dsqrtl_test.cpp
new file mode 100644
index 0000000..c178e38
--- /dev/null
+++ b/test/src/math/smoke/dsqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsqrtl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/dsqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(double, long double, LIBC_NAMESPACE::dsqrtl)
diff --git a/test/src/math/smoke/dsubf128_test.cpp b/test/src/math/smoke/dsubf128_test.cpp
new file mode 100644
index 0000000..e496cdd
--- /dev/null
+++ b/test/src/math/smoke/dsubf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsubf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/dsubf128.h"
+
+LIST_SUB_TESTS(double, float128, LIBC_NAMESPACE::dsubf128)
diff --git a/test/src/math/smoke/dsubl_test.cpp b/test/src/math/smoke/dsubl_test.cpp
new file mode 100644
index 0000000..98846e0
--- /dev/null
+++ b/test/src/math/smoke/dsubl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for dsubl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/dsubl.h"
+
+LIST_SUB_TESTS(double, long double, LIBC_NAMESPACE::dsubl)
diff --git a/test/src/math/smoke/erff_test.cpp b/test/src/math/smoke/erff_test.cpp
index 102126e..7d2c101 100644
--- a/test/src/math/smoke/erff_test.cpp
+++ b/test/src/math/smoke/erff_test.cpp
@@ -12,7 +12,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcErffTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -24,3 +23,30 @@ TEST_F(LlvmLibcErffTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::erff(zero));
   EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::erff(neg_zero));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcErffTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::erff(min_denormal));
+  EXPECT_FP_EQ(0x1.20dd72p-126f, LIBC_NAMESPACE::erff(max_denormal));
+}
+
+TEST_F(LlvmLibcErffTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::erff(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::erff(max_denormal));
+}
+
+TEST_F(LlvmLibcErffTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::erff(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::erff(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp10_test.cpp b/test/src/math/smoke/exp10_test.cpp
index 7154cb1..ca9fc35 100644
--- a/test/src/math/smoke/exp10_test.cpp
+++ b/test/src/math/smoke/exp10_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExp10Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -33,3 +32,30 @@ TEST_F(LlvmLibcExp10Test, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(100.0, LIBC_NAMESPACE::exp10(2.0));
   EXPECT_FP_EQ_ALL_ROUNDING(1000.0, LIBC_NAMESPACE::exp10(3.0));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExp10Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(max_denormal));
+}
+
+TEST_F(LlvmLibcExp10Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(max_denormal));
+}
+
+TEST_F(LlvmLibcExp10Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp10(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp10f16_test.cpp b/test/src/math/smoke/exp10f16_test.cpp
new file mode 100644
index 0000000..1c4ef2a
--- /dev/null
+++ b/test/src/math/smoke/exp10f16_test.cpp
@@ -0,0 +1,67 @@
+//===-- Unittests for exp10f16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/exp10f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExp10f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExp10f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::exp10f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::exp10f16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::exp10f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::exp10f16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::exp10f16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::exp10f16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp10f16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp10f16(max_normal),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      inf, LIBC_NAMESPACE::exp10f16(LIBC_NAMESPACE::fputil::cast<float16>(5.0)),
+      FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
+
+TEST_F(LlvmLibcExp10f16Test, Underflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(zero, LIBC_NAMESPACE::exp10f16(neg_max_normal),
+                              FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      zero,
+      LIBC_NAMESPACE::exp10f16(LIBC_NAMESPACE::fputil::cast<float16>(-8.0)),
+      FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
diff --git a/test/src/math/smoke/exp10f_test.cpp b/test/src/math/smoke/exp10f_test.cpp
index 9fb15ae..bcbfc96 100644
--- a/test/src/math/smoke/exp10f_test.cpp
+++ b/test/src/math/smoke/exp10f_test.cpp
@@ -54,3 +54,30 @@ TEST_F(LlvmLibcExp10fTest, Overflow) {
       inf, LIBC_NAMESPACE::exp10f(FPBits(0x43000001U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExp10fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp10fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp10fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp10f(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp10m1f16_test.cpp b/test/src/math/smoke/exp10m1f16_test.cpp
new file mode 100644
index 0000000..dfa7fa4
--- /dev/null
+++ b/test/src/math/smoke/exp10m1f16_test.cpp
@@ -0,0 +1,113 @@
+//===-- Unittests for exp10m1f16 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/exp10m1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExp10m1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExp10m1f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::exp10m1f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::exp10m1f16(sNaN),
+                              FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::exp10m1f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                            LIBC_NAMESPACE::exp10m1f16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::exp10m1f16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::exp10m1f16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp10m1f16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp10m1f16(max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  // round(16 * log10(2), HP, RN);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.344p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      inf, LIBC_NAMESPACE::exp10m1f16(x), FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      inf, LIBC_NAMESPACE::exp10m1f16(x), FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp10m1f16Test, ResultNearNegOne) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                              LIBC_NAMESPACE::exp10m1f16(neg_max_normal),
+                              FE_INEXACT);
+
+  // round(-11 * log10(2), HP, RD);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.a8p+1);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  // Next float16 value below -0x1.ce4p+1.
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ce8p+1);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::exp10m1f16(x), FE_INEXACT);
+}
diff --git a/test/src/math/smoke/exp10m1f_test.cpp b/test/src/math/smoke/exp10m1f_test.cpp
new file mode 100644
index 0000000..9c65a38
--- /dev/null
+++ b/test/src/math/smoke/exp10m1f_test.cpp
@@ -0,0 +1,59 @@
+//===-- Unittests for exp10m1f --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/exp10m1f.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExp10m1fTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+TEST_F(LlvmLibcExp10m1fTest, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_EQ(FPBits(aNaN).uintval(),
+            FPBits(LIBC_NAMESPACE::exp10m1f(aNaN)).uintval());
+  EXPECT_EQ(FPBits(neg_aNaN).uintval(),
+            FPBits(LIBC_NAMESPACE::exp10m1f(neg_aNaN)).uintval());
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::exp10m1f(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(-1.0f, LIBC_NAMESPACE::exp10m1f(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::exp10m1f(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::exp10m1f(neg_zero));
+
+  EXPECT_FP_EQ_ALL_ROUNDING(9.0f, LIBC_NAMESPACE::exp10m1f(1.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(99.0f, LIBC_NAMESPACE::exp10m1f(2.0f));
+  EXPECT_FP_EQ_ALL_ROUNDING(999.0f, LIBC_NAMESPACE::exp10m1f(3.0f));
+}
+
+TEST_F(LlvmLibcExp10m1fTest, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp10m1f(0x1.fffffep+127f),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp10m1f(0x1.344136p+5),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp10m1f(0x1.344138p+5),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
+
+TEST_F(LlvmLibcExp10m1fTest, Underflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(-1.0f, LIBC_NAMESPACE::exp10m1f(-max_normal),
+                              FE_UNDERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(-1.0f, LIBC_NAMESPACE::exp10m1f(-0x1.e1a5e4p+2f),
+                              FE_UNDERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
diff --git a/test/src/math/smoke/exp2_test.cpp b/test/src/math/smoke/exp2_test.cpp
index a8ef6cf..d97a384 100644
--- a/test/src/math/smoke/exp2_test.cpp
+++ b/test/src/math/smoke/exp2_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExp2Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -32,3 +31,30 @@ TEST_F(LlvmLibcExp2Test, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(4.0, LIBC_NAMESPACE::exp2(2.0));
   EXPECT_FP_EQ_ALL_ROUNDING(0.25, LIBC_NAMESPACE::exp2(-2.0));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExp2Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp2(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp2f16_test.cpp b/test/src/math/smoke/exp2f16_test.cpp
new file mode 100644
index 0000000..f69b33a
--- /dev/null
+++ b/test/src/math/smoke/exp2f16_test.cpp
@@ -0,0 +1,67 @@
+//===-- Unittests for exp2f16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/exp2f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExp2f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExp2f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::exp2f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::exp2f16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::exp2f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::exp2f16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::exp2f16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::exp2f16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp2f16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp2f16(max_normal),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      inf, LIBC_NAMESPACE::exp2f16(LIBC_NAMESPACE::fputil::cast<float16>(16.0)),
+      FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
+
+TEST_F(LlvmLibcExp2f16Test, Underflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(zero, LIBC_NAMESPACE::exp2f16(neg_max_normal),
+                              FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      zero,
+      LIBC_NAMESPACE::exp2f16(LIBC_NAMESPACE::fputil::cast<float16>(-25.0)),
+      FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
diff --git a/test/src/math/smoke/exp2f_test.cpp b/test/src/math/smoke/exp2f_test.cpp
index 3ef1a4e..d9cdecb 100644
--- a/test/src/math/smoke/exp2f_test.cpp
+++ b/test/src/math/smoke/exp2f_test.cpp
@@ -8,7 +8,6 @@
 
 #include "hdr/math_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 #include "src/errno/libc_errno.h"
 #include "src/math/exp2f.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -56,3 +55,30 @@ TEST_F(LlvmLibcExp2fTest, Overflow) {
       inf, LIBC_NAMESPACE::exp2f(FPBits(0x43000001U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExp2fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::exp2f(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp2m1f16_test.cpp b/test/src/math/smoke/exp2m1f16_test.cpp
new file mode 100644
index 0000000..8be8697
--- /dev/null
+++ b/test/src/math/smoke/exp2m1f16_test.cpp
@@ -0,0 +1,87 @@
+//===-- Unittests for exp2m1f16 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/exp2m1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExp2m1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExp2m1f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::exp2m1f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::exp2m1f16(sNaN),
+                              FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::exp2m1f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(-1.0, LIBC_NAMESPACE::exp2m1f16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::exp2m1f16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::exp2m1f16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp2m1f16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::exp2m1f16(max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  float16 x = 16.0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      inf, LIBC_NAMESPACE::exp2m1f16(x), FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(inf, LIBC_NAMESPACE::exp2m1f16(x),
+                                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExp2m1f16Test, ResultNearNegOne) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(-1.0, LIBC_NAMESPACE::exp2m1f16(neg_max_normal),
+                              FE_INEXACT);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(-0x1.ffcp-1, LIBC_NAMESPACE::exp2m1f16(-11.0));
+
+  float16 x = -12.0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      -1.0, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      -0x1.ffcp-1, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      -1.0, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      -0x1.ffcp-1, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
+}
diff --git a/test/src/math/smoke/exp2m1f_test.cpp b/test/src/math/smoke/exp2m1f_test.cpp
index 2df4353..4657d08 100644
--- a/test/src/math/smoke/exp2m1f_test.cpp
+++ b/test/src/math/smoke/exp2m1f_test.cpp
@@ -61,3 +61,30 @@ TEST_F(LlvmLibcExp2m1fTest, Underflow) {
                               FE_UNDERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExp2m1fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2m1fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(max_denormal));
+}
+
+TEST_F(LlvmLibcExp2m1fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::exp2m1f(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/exp_test.cpp b/test/src/math/smoke/exp_test.cpp
index 2abaa72..d2467ff 100644
--- a/test/src/math/smoke/exp_test.cpp
+++ b/test/src/math/smoke/exp_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExpTest = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -28,3 +27,30 @@ TEST_F(LlvmLibcExpTest, SpecialNumbers) {
   EXPECT_FP_EQ_ALL_ROUNDING(1.0, LIBC_NAMESPACE::exp(0.0));
   EXPECT_FP_EQ_ALL_ROUNDING(1.0, LIBC_NAMESPACE::exp(-0.0));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExpTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(max_denormal));
+}
+
+TEST_F(LlvmLibcExpTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(max_denormal));
+}
+
+TEST_F(LlvmLibcExpTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(min_denormal));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::exp(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/expf16_test.cpp b/test/src/math/smoke/expf16_test.cpp
new file mode 100644
index 0000000..ab745a3
--- /dev/null
+++ b/test/src/math/smoke/expf16_test.cpp
@@ -0,0 +1,68 @@
+//===-- Unittests for expf16 ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/expf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExpf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExpf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::expf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::expf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::expf16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::expf16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::expf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0f),
+                            LIBC_NAMESPACE::expf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExpf16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::expf16(max_normal),
+                              FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      inf, LIBC_NAMESPACE::expf16(LIBC_NAMESPACE::fputil::cast<float16>(12.0)),
+      FE_OVERFLOW);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
+
+TEST_F(LlvmLibcExpf16Test, Underflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(zero, LIBC_NAMESPACE::expf16(neg_max_normal),
+                              FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(
+      zero,
+      LIBC_NAMESPACE::expf16(LIBC_NAMESPACE::fputil::cast<float16>(-18.0)),
+      FE_UNDERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+}
diff --git a/test/src/math/smoke/expf_test.cpp b/test/src/math/smoke/expf_test.cpp
index b954125..11181ed 100644
--- a/test/src/math/smoke/expf_test.cpp
+++ b/test/src/math/smoke/expf_test.cpp
@@ -50,3 +50,30 @@ TEST_F(LlvmLibcExpfTest, Overflow) {
       inf, LIBC_NAMESPACE::expf(FPBits(0x42d00008U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExpfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(max_denormal));
+}
+
+TEST_F(LlvmLibcExpfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(max_denormal));
+}
+
+TEST_F(LlvmLibcExpfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(min_denormal));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::expf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/expm1_test.cpp b/test/src/math/smoke/expm1_test.cpp
index d5f166d..cebd2d7 100644
--- a/test/src/math/smoke/expm1_test.cpp
+++ b/test/src/math/smoke/expm1_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcExpm1Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -34,3 +33,30 @@ TEST_F(LlvmLibcExpm1Test, SpecialNumbers) {
   // log(2^-54)
   EXPECT_FP_EQ(-1.0, LIBC_NAMESPACE::expm1(-0x1.2b708872320e2p5));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExpm1Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(max_denormal));
+}
+
+TEST_F(LlvmLibcExpm1Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(max_denormal));
+}
+
+TEST_F(LlvmLibcExpm1Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::expm1(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/expm1f16_test.cpp b/test/src/math/smoke/expm1f16_test.cpp
new file mode 100644
index 0000000..f297c5d
--- /dev/null
+++ b/test/src/math/smoke/expm1f16_test.cpp
@@ -0,0 +1,112 @@
+//===-- Unittests for expm1f16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/expm1f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcExpm1f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcExpm1f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::expm1f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::expm1f16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::expm1f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                            LIBC_NAMESPACE::expm1f16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::expm1f16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::expm1f16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExpm1f16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::expm1f16(max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  // round(16 * log(2), HP, RN);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.63p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(inf, LIBC_NAMESPACE::expm1f16(x),
+                                               FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(inf, LIBC_NAMESPACE::expm1f16(x),
+                                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcExpm1f16Test, ResultNearNegOne) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                              LIBC_NAMESPACE::expm1f16(neg_max_normal),
+                              FE_INEXACT);
+
+  // round(-11 * log(2), HP, RN);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.e8p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::expm1f16(x),
+      FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.0a4p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::expm1f16(x),
+      FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::expm1f16(x),
+      FE_INEXACT);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::expm1f16(x), FE_INEXACT);
+}
diff --git a/test/src/math/smoke/expm1f_test.cpp b/test/src/math/smoke/expm1f_test.cpp
index 03b6e47..f4138aa 100644
--- a/test/src/math/smoke/expm1f_test.cpp
+++ b/test/src/math/smoke/expm1f_test.cpp
@@ -50,3 +50,30 @@ TEST_F(LlvmLibcExpm1fTest, Overflow) {
       inf, LIBC_NAMESPACE::expm1f(FPBits(0x42d00008U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcExpm1fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(max_denormal));
+}
+
+TEST_F(LlvmLibcExpm1fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(max_denormal));
+}
+
+TEST_F(LlvmLibcExpm1fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::expm1f(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/f16add_test.cpp b/test/src/math/smoke/f16add_test.cpp
new file mode 100644
index 0000000..c47ece2
--- /dev/null
+++ b/test/src/math/smoke/f16add_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16add ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16add.h"
+
+LIST_ADD_TESTS(float16, double, LIBC_NAMESPACE::f16add)
diff --git a/test/src/math/smoke/f16addf128_test.cpp b/test/src/math/smoke/f16addf128_test.cpp
new file mode 100644
index 0000000..8ed123b
--- /dev/null
+++ b/test/src/math/smoke/f16addf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16addf128 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16addf128.h"
+
+LIST_ADD_TESTS(float16, float128, LIBC_NAMESPACE::f16addf128)
diff --git a/test/src/math/smoke/f16addf_test.cpp b/test/src/math/smoke/f16addf_test.cpp
new file mode 100644
index 0000000..1e8b432
--- /dev/null
+++ b/test/src/math/smoke/f16addf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16addf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16addf.h"
+
+LIST_ADD_TESTS(float16, float, LIBC_NAMESPACE::f16addf)
diff --git a/test/src/math/smoke/f16addl_test.cpp b/test/src/math/smoke/f16addl_test.cpp
new file mode 100644
index 0000000..f8e0d9b
--- /dev/null
+++ b/test/src/math/smoke/f16addl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16addl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/f16addl.h"
+
+LIST_ADD_TESTS(float16, long double, LIBC_NAMESPACE::f16addl)
diff --git a/test/src/math/smoke/f16div_test.cpp b/test/src/math/smoke/f16div_test.cpp
new file mode 100644
index 0000000..0bfa69f
--- /dev/null
+++ b/test/src/math/smoke/f16div_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16div ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16div.h"
+
+LIST_DIV_TESTS(float16, double, LIBC_NAMESPACE::f16div)
diff --git a/test/src/math/smoke/f16divf128_test.cpp b/test/src/math/smoke/f16divf128_test.cpp
new file mode 100644
index 0000000..d2ea971
--- /dev/null
+++ b/test/src/math/smoke/f16divf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16divf128 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16divf128.h"
+
+LIST_DIV_TESTS(float16, float128, LIBC_NAMESPACE::f16divf128)
diff --git a/test/src/math/smoke/f16divf_test.cpp b/test/src/math/smoke/f16divf_test.cpp
new file mode 100644
index 0000000..85be1eb
--- /dev/null
+++ b/test/src/math/smoke/f16divf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16divf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16divf.h"
+
+LIST_DIV_TESTS(float16, float, LIBC_NAMESPACE::f16divf)
diff --git a/test/src/math/smoke/f16divl_test.cpp b/test/src/math/smoke/f16divl_test.cpp
new file mode 100644
index 0000000..bad3e70
--- /dev/null
+++ b/test/src/math/smoke/f16divl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16divl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/f16divl.h"
+
+LIST_DIV_TESTS(float16, long double, LIBC_NAMESPACE::f16divl)
diff --git a/test/src/math/smoke/f16fma_test.cpp b/test/src/math/smoke/f16fma_test.cpp
new file mode 100644
index 0000000..2e46b5b
--- /dev/null
+++ b/test/src/math/smoke/f16fma_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16fma ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/f16fma.h"
+
+LIST_NARROWING_FMA_TESTS(float16, double, LIBC_NAMESPACE::f16fma)
diff --git a/test/src/math/smoke/f16fmaf128_test.cpp b/test/src/math/smoke/f16fmaf128_test.cpp
new file mode 100644
index 0000000..ea4003b
--- /dev/null
+++ b/test/src/math/smoke/f16fmaf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16fmaf128 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/f16fmaf128.h"
+
+LIST_NARROWING_FMA_TESTS(float16, float128, LIBC_NAMESPACE::f16fmaf128)
diff --git a/test/src/math/smoke/f16fmal_test.cpp b/test/src/math/smoke/f16fmal_test.cpp
new file mode 100644
index 0000000..5394268
--- /dev/null
+++ b/test/src/math/smoke/f16fmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16fmal ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/f16fmal.h"
+
+LIST_NARROWING_FMA_TESTS(float16, long double, LIBC_NAMESPACE::f16fmal)
diff --git a/test/src/math/smoke/f16mul_test.cpp b/test/src/math/smoke/f16mul_test.cpp
new file mode 100644
index 0000000..49b4438
--- /dev/null
+++ b/test/src/math/smoke/f16mul_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mul ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mul.h"
+
+LIST_MUL_TESTS(float16, double, LIBC_NAMESPACE::f16mul)
diff --git a/test/src/math/smoke/f16mulf128_test.cpp b/test/src/math/smoke/f16mulf128_test.cpp
new file mode 100644
index 0000000..46e52cf
--- /dev/null
+++ b/test/src/math/smoke/f16mulf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mulf128 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mulf128.h"
+
+LIST_MUL_TESTS(float16, float128, LIBC_NAMESPACE::f16mulf128)
diff --git a/test/src/math/smoke/f16mulf_test.cpp b/test/src/math/smoke/f16mulf_test.cpp
new file mode 100644
index 0000000..bf25308
--- /dev/null
+++ b/test/src/math/smoke/f16mulf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mulf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mulf.h"
+
+LIST_MUL_TESTS(float16, float, LIBC_NAMESPACE::f16mulf)
diff --git a/test/src/math/smoke/f16mull_test.cpp b/test/src/math/smoke/f16mull_test.cpp
new file mode 100644
index 0000000..5292ddb
--- /dev/null
+++ b/test/src/math/smoke/f16mull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16mull ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/f16mull.h"
+
+LIST_MUL_TESTS(float16, long double, LIBC_NAMESPACE::f16mull)
diff --git a/test/src/math/smoke/f16sqrt_test.cpp b/test/src/math/smoke/f16sqrt_test.cpp
new file mode 100644
index 0000000..759b388
--- /dev/null
+++ b/test/src/math/smoke/f16sqrt_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrt ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrt.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, double, LIBC_NAMESPACE::f16sqrt)
diff --git a/test/src/math/smoke/f16sqrtf128_test.cpp b/test/src/math/smoke/f16sqrtf128_test.cpp
new file mode 100644
index 0000000..31c9948
--- /dev/null
+++ b/test/src/math/smoke/f16sqrtf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrtf128 -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrtf128.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, float128, LIBC_NAMESPACE::f16sqrtf128)
diff --git a/test/src/math/smoke/f16sqrtl_test.cpp b/test/src/math/smoke/f16sqrtl_test.cpp
new file mode 100644
index 0000000..4e069bc
--- /dev/null
+++ b/test/src/math/smoke/f16sqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sqrtl --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/f16sqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(float16, long double, LIBC_NAMESPACE::f16sqrtl)
diff --git a/test/src/math/smoke/f16sub_test.cpp b/test/src/math/smoke/f16sub_test.cpp
new file mode 100644
index 0000000..4ab347b
--- /dev/null
+++ b/test/src/math/smoke/f16sub_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16sub ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16sub.h"
+
+LIST_SUB_TESTS(float16, double, LIBC_NAMESPACE::f16sub)
diff --git a/test/src/math/smoke/f16subf128_test.cpp b/test/src/math/smoke/f16subf128_test.cpp
new file mode 100644
index 0000000..4936d89
--- /dev/null
+++ b/test/src/math/smoke/f16subf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16subf128 ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16subf128.h"
+
+LIST_SUB_TESTS(float16, float128, LIBC_NAMESPACE::f16subf128)
diff --git a/test/src/math/smoke/f16subf_test.cpp b/test/src/math/smoke/f16subf_test.cpp
new file mode 100644
index 0000000..68ad948
--- /dev/null
+++ b/test/src/math/smoke/f16subf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16subf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16subf.h"
+
+LIST_SUB_TESTS(float16, float, LIBC_NAMESPACE::f16subf)
diff --git a/test/src/math/smoke/f16subl_test.cpp b/test/src/math/smoke/f16subl_test.cpp
new file mode 100644
index 0000000..c41e6e9
--- /dev/null
+++ b/test/src/math/smoke/f16subl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for f16subl ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/f16subl.h"
+
+LIST_SUB_TESTS(float16, long double, LIBC_NAMESPACE::f16subl)
diff --git a/test/src/math/smoke/fadd_test.cpp b/test/src/math/smoke/fadd_test.cpp
new file mode 100644
index 0000000..fe9ac8b
--- /dev/null
+++ b/test/src/math/smoke/fadd_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fadd ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/fadd.h"
+
+LIST_ADD_TESTS(float, double, LIBC_NAMESPACE::fadd)
diff --git a/test/src/math/smoke/faddf128_test.cpp b/test/src/math/smoke/faddf128_test.cpp
new file mode 100644
index 0000000..5a11b5f
--- /dev/null
+++ b/test/src/math/smoke/faddf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for faddf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/faddf128.h"
+
+LIST_ADD_TESTS(float, float128, LIBC_NAMESPACE::faddf128)
diff --git a/test/src/math/smoke/faddl_test.cpp b/test/src/math/smoke/faddl_test.cpp
new file mode 100644
index 0000000..9c99b32
--- /dev/null
+++ b/test/src/math/smoke/faddl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for faddl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/math/faddl.h"
+
+LIST_ADD_TESTS(float, long double, LIBC_NAMESPACE::faddl)
diff --git a/test/src/math/smoke/fdiv_test.cpp b/test/src/math/smoke/fdiv_test.cpp
new file mode 100644
index 0000000..f0bd602
--- /dev/null
+++ b/test/src/math/smoke/fdiv_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fdiv ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/fdiv.h"
+
+LIST_DIV_TESTS(float, double, LIBC_NAMESPACE::fdiv)
diff --git a/test/src/math/smoke/fdivf128_test.cpp b/test/src/math/smoke/fdivf128_test.cpp
new file mode 100644
index 0000000..a687e07
--- /dev/null
+++ b/test/src/math/smoke/fdivf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fdivf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/fdivf128.h"
+
+LIST_DIV_TESTS(float, float128, LIBC_NAMESPACE::fdivf128)
diff --git a/test/src/math/smoke/fdivl_test.cpp b/test/src/math/smoke/fdivl_test.cpp
new file mode 100644
index 0000000..bc2b0e4
--- /dev/null
+++ b/test/src/math/smoke/fdivl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fdivl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "DivTest.h"
+
+#include "src/math/fdivl.h"
+
+LIST_DIV_TESTS(float, long double, LIBC_NAMESPACE::fdivl)
diff --git a/test/src/math/smoke/ffma_test.cpp b/test/src/math/smoke/ffma_test.cpp
new file mode 100644
index 0000000..4b6a25c
--- /dev/null
+++ b/test/src/math/smoke/ffma_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ffma ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/ffma.h"
+
+LIST_NARROWING_FMA_TESTS(float, double, LIBC_NAMESPACE::ffma)
diff --git a/test/src/math/smoke/ffmaf128_test.cpp b/test/src/math/smoke/ffmaf128_test.cpp
new file mode 100644
index 0000000..a8f81e2
--- /dev/null
+++ b/test/src/math/smoke/ffmaf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ffmaf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/ffmaf128.h"
+
+LIST_NARROWING_FMA_TESTS(float, float128, LIBC_NAMESPACE::ffmaf128)
diff --git a/test/src/math/smoke/ffmal_test.cpp b/test/src/math/smoke/ffmal_test.cpp
new file mode 100644
index 0000000..200d9e1
--- /dev/null
+++ b/test/src/math/smoke/ffmal_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for ffmal -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FmaTest.h"
+
+#include "src/math/ffmal.h"
+
+LIST_NARROWING_FMA_TESTS(float, long double, LIBC_NAMESPACE::ffmal)
diff --git a/test/src/math/smoke/fmul_test.cpp b/test/src/math/smoke/fmul_test.cpp
index 0eb664f..3fcf514 100644
--- a/test/src/math/smoke/fmul_test.cpp
+++ b/test/src/math/smoke/fmul_test.cpp
@@ -1,13 +1,32 @@
-//===-- Unittests for fmul-------------------------------------------------===//
+//===-- Unittests for fmul ------------------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
-//===---------------------------------------------------------------------===//
+//===----------------------------------------------------------------------===//
 
-#include "FMulTest.h"
+#include "MulTest.h"
 
 #include "src/math/fmul.h"
 
-LIST_FMUL_TESTS(float, double, LIBC_NAMESPACE::fmul)
+LIST_MUL_TESTS(float, double, LIBC_NAMESPACE::fmul)
+
+TEST_F(LlvmLibcMulTest, SpecialInputs) {
+  constexpr double INPUTS[][2] = {
+      {0x1.0100010002p8, 0x1.fffcp14},
+      {0x1.000000b92144p-7, 0x1.62p7},
+  };
+
+  constexpr float RESULTS[] = {
+      0x1.00fdfep+23f,
+      0x1.620002p0f,
+  };
+
+  constexpr size_t N = sizeof(RESULTS) / sizeof(RESULTS[0]);
+
+  for (size_t i = 0; i < N; ++i) {
+    float result = LIBC_NAMESPACE::fmul(INPUTS[i][0], INPUTS[i][1]);
+    EXPECT_FP_EQ(RESULTS[i], result);
+  }
+}
diff --git a/test/src/math/smoke/fmulf128_test.cpp b/test/src/math/smoke/fmulf128_test.cpp
new file mode 100644
index 0000000..37c8d1c
--- /dev/null
+++ b/test/src/math/smoke/fmulf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fmulf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/fmulf128.h"
+
+LIST_MUL_TESTS(float, float128, LIBC_NAMESPACE::fmulf128)
diff --git a/test/src/math/smoke/fmull_test.cpp b/test/src/math/smoke/fmull_test.cpp
new file mode 100644
index 0000000..ef69406
--- /dev/null
+++ b/test/src/math/smoke/fmull_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fmull -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MulTest.h"
+
+#include "src/math/fmull.h"
+
+LIST_MUL_TESTS(float, long double, LIBC_NAMESPACE::fmull)
diff --git a/test/src/math/smoke/fsqrt_test.cpp b/test/src/math/smoke/fsqrt_test.cpp
new file mode 100644
index 0000000..8471e3c
--- /dev/null
+++ b/test/src/math/smoke/fsqrt_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsqrt -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/fsqrt.h"
+
+LIST_NARROWING_SQRT_TESTS(float, double, LIBC_NAMESPACE::fsqrt)
diff --git a/test/src/math/smoke/fsqrtf128_test.cpp b/test/src/math/smoke/fsqrtf128_test.cpp
new file mode 100644
index 0000000..b125a35
--- /dev/null
+++ b/test/src/math/smoke/fsqrtf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsqrtf128 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/fsqrtf128.h"
+
+LIST_NARROWING_SQRT_TESTS(float, float128, LIBC_NAMESPACE::fsqrtf128)
diff --git a/test/src/math/smoke/fsqrtl_test.cpp b/test/src/math/smoke/fsqrtl_test.cpp
new file mode 100644
index 0000000..1082a33
--- /dev/null
+++ b/test/src/math/smoke/fsqrtl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsqrtl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/fsqrtl.h"
+
+LIST_NARROWING_SQRT_TESTS(float, long double, LIBC_NAMESPACE::fsqrtl)
diff --git a/test/src/math/smoke/fsub_test.cpp b/test/src/math/smoke/fsub_test.cpp
new file mode 100644
index 0000000..3c825f7
--- /dev/null
+++ b/test/src/math/smoke/fsub_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsub ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/fsub.h"
+
+LIST_SUB_TESTS(float, double, LIBC_NAMESPACE::fsub)
diff --git a/test/src/math/smoke/fsubf128_test.cpp b/test/src/math/smoke/fsubf128_test.cpp
new file mode 100644
index 0000000..8f46d91
--- /dev/null
+++ b/test/src/math/smoke/fsubf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsubf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/fsubf128.h"
+
+LIST_SUB_TESTS(float, float128, LIBC_NAMESPACE::fsubf128)
diff --git a/test/src/math/smoke/fsubl_test.cpp b/test/src/math/smoke/fsubl_test.cpp
new file mode 100644
index 0000000..8723432
--- /dev/null
+++ b/test/src/math/smoke/fsubl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for fsubl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/math/fsubl.h"
+
+LIST_SUB_TESTS(float, long double, LIBC_NAMESPACE::fsubl)
diff --git a/test/src/math/smoke/getpayload_test.cpp b/test/src/math/smoke/getpayload_test.cpp
new file mode 100644
index 0000000..f157d45
--- /dev/null
+++ b/test/src/math/smoke/getpayload_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for getpayload ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "GetPayloadTest.h"
+
+#include "src/math/getpayload.h"
+
+LIST_GETPAYLOAD_TESTS(double, LIBC_NAMESPACE::getpayload)
diff --git a/test/src/math/smoke/getpayloadf128_test.cpp b/test/src/math/smoke/getpayloadf128_test.cpp
new file mode 100644
index 0000000..37bb506
--- /dev/null
+++ b/test/src/math/smoke/getpayloadf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for getpayloadf128 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "GetPayloadTest.h"
+
+#include "src/math/getpayloadf128.h"
+
+LIST_GETPAYLOAD_TESTS(float128, LIBC_NAMESPACE::getpayloadf128)
diff --git a/test/src/math/smoke/getpayloadf_test.cpp b/test/src/math/smoke/getpayloadf_test.cpp
new file mode 100644
index 0000000..89ed024
--- /dev/null
+++ b/test/src/math/smoke/getpayloadf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for getpayloadf -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "GetPayloadTest.h"
+
+#include "src/math/getpayloadf.h"
+
+LIST_GETPAYLOAD_TESTS(float, LIBC_NAMESPACE::getpayloadf)
diff --git a/test/src/math/smoke/getpayloadl_test.cpp b/test/src/math/smoke/getpayloadl_test.cpp
new file mode 100644
index 0000000..d783548
--- /dev/null
+++ b/test/src/math/smoke/getpayloadl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for getpayloadl -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "GetPayloadTest.h"
+
+#include "src/math/getpayloadl.h"
+
+LIST_GETPAYLOAD_TESTS(long double, LIBC_NAMESPACE::getpayloadl)
diff --git a/test/src/math/smoke/hypotf_test.cpp b/test/src/math/smoke/hypotf_test.cpp
index 768e7f7..6239948 100644
--- a/test/src/math/smoke/hypotf_test.cpp
+++ b/test/src/math/smoke/hypotf_test.cpp
@@ -15,3 +15,37 @@ using LlvmLibcHypotfTest = HypotTestTemplate<float>;
 TEST_F(LlvmLibcHypotfTest, SpecialNumbers) {
   test_special_numbers(&LIBC_NAMESPACE::hypotf);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcHypotfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0x1.6a09e4p-126f,
+               LIBC_NAMESPACE::hypotf(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcHypotfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(max_denormal, max_denormal));
+}
+
+TEST_F(LlvmLibcHypotfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(min_denormal, max_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(max_denormal, min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::hypotf(max_denormal, max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/iscanonical_test.cpp b/test/src/math/smoke/iscanonical_test.cpp
new file mode 100644
index 0000000..8e8b3e4
--- /dev/null
+++ b/test/src/math/smoke/iscanonical_test.cpp
@@ -0,0 +1,17 @@
+//===-- Unittests for iscanonical -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsCanonicalTest.h"
+
+// The testing framework might include math.h and iscanonical macro definition
+// in overlay mode.
+#undef iscanonical
+
+#include "src/math/iscanonical.h"
+
+LIST_ISCANONICAL_TESTS(double, LIBC_NAMESPACE::iscanonical)
diff --git a/test/src/math/smoke/iscanonicalf128_test.cpp b/test/src/math/smoke/iscanonicalf128_test.cpp
new file mode 100644
index 0000000..0176ae2
--- /dev/null
+++ b/test/src/math/smoke/iscanonicalf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for iscanonicalf128 -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsCanonicalTest.h"
+
+#include "src/math/iscanonicalf128.h"
+
+LIST_ISCANONICAL_TESTS(float128, LIBC_NAMESPACE::iscanonicalf128)
diff --git a/test/src/math/smoke/iscanonicalf16_test.cpp b/test/src/math/smoke/iscanonicalf16_test.cpp
new file mode 100644
index 0000000..d17d79f
--- /dev/null
+++ b/test/src/math/smoke/iscanonicalf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for iscanonicalf16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsCanonicalTest.h"
+
+#include "src/math/iscanonicalf16.h"
+
+LIST_ISCANONICAL_TESTS(float16, LIBC_NAMESPACE::iscanonicalf16)
diff --git a/test/src/math/smoke/iscanonicalf_test.cpp b/test/src/math/smoke/iscanonicalf_test.cpp
new file mode 100644
index 0000000..eba8688
--- /dev/null
+++ b/test/src/math/smoke/iscanonicalf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for iscanonicalf ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsCanonicalTest.h"
+
+#include "src/math/iscanonicalf.h"
+
+LIST_ISCANONICAL_TESTS(float, LIBC_NAMESPACE::iscanonicalf)
diff --git a/test/src/math/smoke/iscanonicall_test.cpp b/test/src/math/smoke/iscanonicall_test.cpp
new file mode 100644
index 0000000..d180bcb
--- /dev/null
+++ b/test/src/math/smoke/iscanonicall_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for iscanonicall ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsCanonicalTest.h"
+
+#include "src/math/iscanonicall.h"
+
+LIST_ISCANONICAL_TESTS(long double, LIBC_NAMESPACE::iscanonicall)
diff --git a/test/src/math/smoke/issignaling_test.cpp b/test/src/math/smoke/issignaling_test.cpp
new file mode 100644
index 0000000..4292cbb
--- /dev/null
+++ b/test/src/math/smoke/issignaling_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for issignaling -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSignalingTest.h"
+
+#include "src/math/issignaling.h"
+
+LIST_ISSIGNALING_TESTS(double, LIBC_NAMESPACE::issignaling)
diff --git a/test/src/math/smoke/issignalingf128_test.cpp b/test/src/math/smoke/issignalingf128_test.cpp
new file mode 100644
index 0000000..929e32a
--- /dev/null
+++ b/test/src/math/smoke/issignalingf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for issignalingf128 -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSignalingTest.h"
+
+#include "src/math/issignalingf128.h"
+
+LIST_ISSIGNALING_TESTS(float128, LIBC_NAMESPACE::issignalingf128)
diff --git a/test/src/math/smoke/issignalingf16_test.cpp b/test/src/math/smoke/issignalingf16_test.cpp
new file mode 100644
index 0000000..fc2a65a
--- /dev/null
+++ b/test/src/math/smoke/issignalingf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for issignalingf16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSignalingTest.h"
+
+#include "src/math/issignalingf16.h"
+
+LIST_ISSIGNALING_TESTS(float16, LIBC_NAMESPACE::issignalingf16)
diff --git a/test/src/math/smoke/issignalingf_test.cpp b/test/src/math/smoke/issignalingf_test.cpp
new file mode 100644
index 0000000..0ceb9a8
--- /dev/null
+++ b/test/src/math/smoke/issignalingf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for issignalingf ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSignalingTest.h"
+
+#include "src/math/issignalingf.h"
+
+LIST_ISSIGNALING_TESTS(float, LIBC_NAMESPACE::issignalingf)
diff --git a/test/src/math/smoke/issignalingl_test.cpp b/test/src/math/smoke/issignalingl_test.cpp
new file mode 100644
index 0000000..0497690
--- /dev/null
+++ b/test/src/math/smoke/issignalingl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for issignalingl ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IsSignalingTest.h"
+
+#include "src/math/issignalingl.h"
+
+LIST_ISSIGNALING_TESTS(long double, LIBC_NAMESPACE::issignalingl)
diff --git a/test/src/math/smoke/log10_test.cpp b/test/src/math/smoke/log10_test.cpp
index 37baf89..9f159f2 100644
--- a/test/src/math/smoke/log10_test.cpp
+++ b/test/src/math/smoke/log10_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog10Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -34,3 +33,29 @@ TEST_F(LlvmLibcLog10Test, SpecialNumbers) {
     EXPECT_FP_EQ_ALL_ROUNDING(static_cast<double>(i), LIBC_NAMESPACE::log10(x));
   }
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog10Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-0x1.434e6420f4374p8, LIBC_NAMESPACE::log10(min_denormal));
+}
+
+TEST_F(LlvmLibcLog10Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log10(min_denormal));
+}
+
+TEST_F(LlvmLibcLog10Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log10(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/log10f16_test.cpp b/test/src/math/smoke/log10f16_test.cpp
new file mode 100644
index 0000000..471e198
--- /dev/null
+++ b/test/src/math/smoke/log10f16_test.cpp
@@ -0,0 +1,50 @@
+//===-- Unittests for log10f16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/log10f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcLog10f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcLog10f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::log10f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::log10f16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::log10f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::log10f16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::log10f16(zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::log10f16(neg_zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      zero,
+      LIBC_NAMESPACE::log10f16(LIBC_NAMESPACE::fputil::cast<float16>(1.0)));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      aNaN,
+      LIBC_NAMESPACE::log10f16(LIBC_NAMESPACE::fputil::cast<float16>(-1.0)));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/log10f_test.cpp b/test/src/math/smoke/log10f_test.cpp
index 721045d..4e3bf65 100644
--- a/test/src/math/smoke/log10f_test.cpp
+++ b/test/src/math/smoke/log10f_test.cpp
@@ -12,7 +12,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog10fTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -33,3 +32,29 @@ TEST_F(LlvmLibcLog10fTest, SpecialNumbers) {
     EXPECT_FP_EQ_ALL_ROUNDING(static_cast<float>(i), LIBC_NAMESPACE::log10f(x));
   }
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog10fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-0x1.66d3e7bd9a403p5f, LIBC_NAMESPACE::log10f(min_denormal));
+}
+
+TEST_F(LlvmLibcLog10fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log10f(min_denormal));
+}
+
+TEST_F(LlvmLibcLog10fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log10f(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/log1p_test.cpp b/test/src/math/smoke/log1p_test.cpp
index 993dbf8..b98c0f2 100644
--- a/test/src/math/smoke/log1p_test.cpp
+++ b/test/src/math/smoke/log1p_test.cpp
@@ -13,9 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
-#include <stdint.h>
-
 using LlvmLibcLog1pTest = LIBC_NAMESPACE::testing::FPTest<double>;
 
 TEST_F(LlvmLibcLog1pTest, SpecialNumbers) {
@@ -27,4 +24,37 @@ TEST_F(LlvmLibcLog1pTest, SpecialNumbers) {
   EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::log1p(-0.0));
   EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, LIBC_NAMESPACE::log1p(-1.0),
                               FE_DIVBYZERO);
+
+  EXPECT_FP_EQ(0x1.62c829bf8fd9dp9,
+               LIBC_NAMESPACE::log1p(0x1.9b536cac3a09dp1023));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog1pTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::log1p(min_denormal));
+  EXPECT_FP_EQ(0x1.62c829bf8fd9dp9,
+               LIBC_NAMESPACE::log1p(0x1.9b536cac3a09dp1023));
 }
+
+TEST_F(LlvmLibcLog1pTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::log1p(min_denormal));
+  EXPECT_FP_EQ(0x1.62c829bf8fd9dp9,
+               LIBC_NAMESPACE::log1p(0x1.9b536cac3a09dp1023));
+}
+
+TEST_F(LlvmLibcLog1pTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::log1p(min_denormal));
+  EXPECT_FP_EQ(0x1.62c829bf8fd9dp9,
+               LIBC_NAMESPACE::log1p(0x1.9b536cac3a09dp1023));
+}
+
+#endif
diff --git a/test/src/math/smoke/log1pf_test.cpp b/test/src/math/smoke/log1pf_test.cpp
index 6127cc8..1b0a1d5 100644
--- a/test/src/math/smoke/log1pf_test.cpp
+++ b/test/src/math/smoke/log1pf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog1pfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -27,3 +26,27 @@ TEST_F(LlvmLibcLog1pfTest, SpecialNumbers) {
   EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, LIBC_NAMESPACE::log1pf(-1.0f),
                               FE_DIVBYZERO);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog1pfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::log1pf(min_denormal));
+}
+
+TEST_F(LlvmLibcLog1pfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::log1pf(min_denormal));
+}
+
+TEST_F(LlvmLibcLog1pfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::log1pf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/log2_test.cpp b/test/src/math/smoke/log2_test.cpp
index b59767e..1570d60 100644
--- a/test/src/math/smoke/log2_test.cpp
+++ b/test/src/math/smoke/log2_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLog2Test = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -28,3 +27,29 @@ TEST_F(LlvmLibcLog2Test, SpecialNumbers) {
   EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::log2(-1.0), FE_INVALID);
   EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::log2(1.0));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog2Test, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-1074.0, LIBC_NAMESPACE::log2(min_denormal));
+}
+
+TEST_F(LlvmLibcLog2Test, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log2(min_denormal));
+}
+
+TEST_F(LlvmLibcLog2Test, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log2(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/log2f16_test.cpp b/test/src/math/smoke/log2f16_test.cpp
new file mode 100644
index 0000000..6d98482
--- /dev/null
+++ b/test/src/math/smoke/log2f16_test.cpp
@@ -0,0 +1,50 @@
+//===-- Unittests for log2f16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/log2f16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcLog2f16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcLog2f16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::log2f16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::log2f16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::log2f16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::log2f16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::log2f16(zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::log2f16(neg_zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      zero,
+      LIBC_NAMESPACE::log2f16(LIBC_NAMESPACE::fputil::cast<float16>(1.0)));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      aNaN,
+      LIBC_NAMESPACE::log2f16(LIBC_NAMESPACE::fputil::cast<float16>(-1.0)));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/log2f_test.cpp b/test/src/math/smoke/log2f_test.cpp
index 00bfb7c..67b2c5b 100644
--- a/test/src/math/smoke/log2f_test.cpp
+++ b/test/src/math/smoke/log2f_test.cpp
@@ -28,3 +28,28 @@ TEST_F(LlvmLibcLog2fTest, SpecialNumbers) {
   EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::log2f(-1.0f), FE_INVALID);
   EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::log2f(1.0f));
 }
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLog2fTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-149.0f, LIBC_NAMESPACE::log2f(min_denormal));
+}
+
+TEST_F(LlvmLibcLog2fTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log2f(min_denormal));
+}
+
+TEST_F(LlvmLibcLog2fTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log2f(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/log_test.cpp b/test/src/math/smoke/log_test.cpp
index fd527de..20b974d 100644
--- a/test/src/math/smoke/log_test.cpp
+++ b/test/src/math/smoke/log_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcLogTest = LIBC_NAMESPACE::testing::FPTest<double>;
@@ -27,3 +26,29 @@ TEST_F(LlvmLibcLogTest, SpecialNumbers) {
   EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::log(-1.0), FE_INVALID);
   EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::log(1.0));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLogTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-0x1.74385446d71c3p9, LIBC_NAMESPACE::log(min_denormal));
+}
+
+TEST_F(LlvmLibcLogTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log(min_denormal));
+}
+
+TEST_F(LlvmLibcLogTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::log(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/logf16_test.cpp b/test/src/math/smoke/logf16_test.cpp
new file mode 100644
index 0000000..c7232aa
--- /dev/null
+++ b/test/src/math/smoke/logf16_test.cpp
@@ -0,0 +1,49 @@
+//===-- Unittests for logf16 ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/logf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcLogf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcLogf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::logf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::logf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::logf16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::logf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::logf16(zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ALL_ROUNDING(
+      neg_inf, LIBC_NAMESPACE::logf16(neg_zero), FE_DIVBYZERO);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      zero, LIBC_NAMESPACE::logf16(LIBC_NAMESPACE::fputil::cast<float16>(1.0)));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      aNaN,
+      LIBC_NAMESPACE::logf16(LIBC_NAMESPACE::fputil::cast<float16>(-1.0)));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/logf_test.cpp b/test/src/math/smoke/logf_test.cpp
index a272060..1a3102a 100644
--- a/test/src/math/smoke/logf_test.cpp
+++ b/test/src/math/smoke/logf_test.cpp
@@ -27,3 +27,28 @@ TEST_F(LlvmLibcLogfTest, SpecialNumbers) {
   EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::logf(-1.0f), FE_INVALID);
   EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::logf(1.0f));
 }
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcLogfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(-0x1.9d1d9fccf477p6f, LIBC_NAMESPACE::logf(min_denormal));
+}
+
+TEST_F(LlvmLibcLogfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::logf(min_denormal));
+}
+
+TEST_F(LlvmLibcLogfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(FPBits::inf(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::logf(min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/nan_test.cpp b/test/src/math/smoke/nan_test.cpp
index 2ddef58..46b9e9a 100644
--- a/test/src/math/smoke/nan_test.cpp
+++ b/test/src/math/smoke/nan_test.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/sanitizer.h"
 #include "src/math/nan.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
-#include <signal.h>
 
 class LlvmLibcNanTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
@@ -43,8 +44,8 @@ TEST_F(LlvmLibcNanTest, RandomString) {
   run_test("123 ", 0x7ff8000000000000);
 }
 
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
+#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
 TEST_F(LlvmLibcNanTest, InvalidInput) {
   EXPECT_DEATH([] { LIBC_NAMESPACE::nan(nullptr); }, WITH_SIGNAL(SIGSEGV));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf128_test.cpp b/test/src/math/smoke/nanf128_test.cpp
index 8c15c53..25dd2ef 100644
--- a/test/src/math/smoke/nanf128_test.cpp
+++ b/test/src/math/smoke/nanf128_test.cpp
@@ -6,7 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/sanitizer.h"
 #include "src/__support/uint128.h"
 #include "src/math/nanf128.h"
 #include "test/UnitTest/FEnvSafeTest.h"
@@ -53,9 +55,8 @@ TEST_F(LlvmLibcNanf128Test, RandomString) {
            QUIET_NAN);
 }
 
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
-#include <signal.h>
+#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
 TEST_F(LlvmLibcNanf128Test, InvalidInput) {
   EXPECT_DEATH([] { LIBC_NAMESPACE::nanf128(nullptr); }, WITH_SIGNAL(SIGSEGV));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf16_test.cpp b/test/src/math/smoke/nanf16_test.cpp
index ec17a73..ec640a3 100644
--- a/test/src/math/smoke/nanf16_test.cpp
+++ b/test/src/math/smoke/nanf16_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/math/nanf16.h"
@@ -13,8 +14,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <signal.h>
-
 class LlvmLibcNanf16Test : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
   using StorageType = LIBC_NAMESPACE::fputil::FPBits<float16>::StorageType;
@@ -44,8 +43,8 @@ TEST_F(LlvmLibcNanf16Test, RandomString) {
   run_test("123 ", 0x7e00);
 }
 
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
+#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
 TEST_F(LlvmLibcNanf16Test, InvalidInput) {
   EXPECT_DEATH([] { LIBC_NAMESPACE::nanf16(nullptr); }, WITH_SIGNAL(SIGSEGV));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf_test.cpp b/test/src/math/smoke/nanf_test.cpp
index 71f888c..dd3124e 100644
--- a/test/src/math/smoke/nanf_test.cpp
+++ b/test/src/math/smoke/nanf_test.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/sanitizer.h"
 #include "src/math/nanf.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
-#include <signal.h>
 
 class LlvmLibcNanfTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
 public:
@@ -42,8 +43,8 @@ TEST_F(LlvmLibcNanfTest, RandomString) {
   run_test("123 ", 0x7fc00000);
 }
 
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
+#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
 TEST_F(LlvmLibcNanfTest, InvalidInput) {
   EXPECT_DEATH([] { LIBC_NAMESPACE::nanf(nullptr); }, WITH_SIGNAL(SIGSEGV));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanl_test.cpp b/test/src/math/smoke/nanl_test.cpp
index 7fff20b..ef3f9c1 100644
--- a/test/src/math/smoke/nanl_test.cpp
+++ b/test/src/math/smoke/nanl_test.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/macros/sanitizer.h"
 #include "src/math/nanl.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
-#include <signal.h>
 
 #if defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
 #define SELECT_LONG_DOUBLE(val, _, __) val
@@ -70,8 +71,8 @@ TEST_F(LlvmLibcNanlTest, RandomString) {
   run_test("123 ", expected);
 }
 
-#ifndef LIBC_HAVE_ADDRESS_SANITIZER
+#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
 TEST_F(LlvmLibcNanlTest, InvalidInput) {
   EXPECT_DEATH([] { LIBC_NAMESPACE::nanl(nullptr); }, WITH_SIGNAL(SIGSEGV));
 }
-#endif // LIBC_HAVE_ADDRESS_SANITIZER
+#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/pow_test.cpp b/test/src/math/smoke/pow_test.cpp
new file mode 100644
index 0000000..f9db7f1
--- /dev/null
+++ b/test/src/math/smoke/pow_test.cpp
@@ -0,0 +1,219 @@
+//===-- Unittests for pow -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/math/pow.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcPowTest = LIBC_NAMESPACE::testing::FPTest<double>;
+using LIBC_NAMESPACE::fputil::testing::ForceRoundingMode;
+using LIBC_NAMESPACE::fputil::testing::RoundingMode;
+
+TEST_F(LlvmLibcPowTest, SpecialNumbers) {
+  constexpr double NEG_ODD_INTEGER = -3.0;
+  constexpr double NEG_EVEN_INTEGER = -6.0;
+  constexpr double NEG_NON_INTEGER = -1.1;
+  constexpr double POS_ODD_INTEGER = 5.0;
+  constexpr double POS_EVEN_INTEGER = 8.0;
+  constexpr double POS_NON_INTEGER = 1.1;
+  constexpr double ONE_HALF = 0.5;
+
+  for (int i = 0; i < N_ROUNDING_MODES; ++i) {
+    ForceRoundingMode __r(ROUNDING_MODES[i]);
+    if (!__r.success)
+      continue;
+
+    // pow( 0.0, exponent )
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::pow(zero, NEG_ODD_INTEGER),
+                                FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(
+        inf, LIBC_NAMESPACE::pow(zero, NEG_EVEN_INTEGER), FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::pow(zero, NEG_NON_INTEGER),
+                                FE_DIVBYZERO);
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(zero, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(zero, POS_EVEN_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(zero, POS_NON_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(zero, ONE_HALF));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(zero, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(zero, neg_zero));
+    EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::pow(zero, inf));
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::pow(zero, neg_inf),
+                                FE_DIVBYZERO);
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(zero, aNaN));
+
+    // pow( -0.0, exponent )
+    EXPECT_FP_EQ_WITH_EXCEPTION(
+        neg_inf, LIBC_NAMESPACE::pow(neg_zero, NEG_ODD_INTEGER), FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(
+        inf, LIBC_NAMESPACE::pow(neg_zero, NEG_EVEN_INTEGER), FE_DIVBYZERO);
+    EXPECT_FP_EQ_WITH_EXCEPTION(
+        inf, LIBC_NAMESPACE::pow(neg_zero, NEG_NON_INTEGER), FE_DIVBYZERO);
+    EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::pow(neg_zero, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_zero, POS_EVEN_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_zero, POS_NON_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_zero, ONE_HALF));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(neg_zero, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(neg_zero, neg_zero));
+    EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::pow(neg_zero, inf));
+    EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::pow(neg_zero, neg_inf),
+                                FE_DIVBYZERO);
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(neg_zero, aNaN));
+
+    // pow( 1.0, exponent )
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, neg_zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, 1.0));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, -1.0));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, NEG_ODD_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, NEG_EVEN_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, NEG_NON_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, POS_EVEN_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, POS_NON_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, inf));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, neg_inf));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(1.0, aNaN));
+
+    // pow( 1.0, exponent )
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, neg_zero));
+    EXPECT_FP_EQ(-1.0, LIBC_NAMESPACE::pow(-1.0, 1.0));
+    EXPECT_FP_EQ(-1.0, LIBC_NAMESPACE::pow(-1.0, -1.0));
+    EXPECT_FP_EQ(-1.0, LIBC_NAMESPACE::pow(-1.0, NEG_ODD_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, NEG_EVEN_INTEGER));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::pow(-1.0, NEG_NON_INTEGER),
+                                    FE_INVALID);
+    EXPECT_FP_EQ(-1.0, LIBC_NAMESPACE::pow(-1.0, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, POS_EVEN_INTEGER));
+    EXPECT_FP_IS_NAN_WITH_EXCEPTION(LIBC_NAMESPACE::pow(-1.0, POS_NON_INTEGER),
+                                    FE_INVALID);
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, inf));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(-1.0, neg_inf));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(-1.0, aNaN));
+
+    // pow( inf, exponent )
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(inf, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(inf, neg_zero));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, 1.0));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(inf, -1.0));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(inf, NEG_ODD_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(inf, NEG_EVEN_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(inf, NEG_NON_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, POS_EVEN_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, POS_NON_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, ONE_HALF));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(inf, inf));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(inf, neg_inf));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(inf, aNaN));
+
+    // pow( -inf, exponent )
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(neg_inf, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(neg_inf, neg_zero));
+    EXPECT_FP_EQ(neg_inf, LIBC_NAMESPACE::pow(neg_inf, 1.0));
+    EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::pow(neg_inf, -1.0));
+    EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::pow(neg_inf, NEG_ODD_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_inf, NEG_EVEN_INTEGER));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_inf, NEG_NON_INTEGER));
+    EXPECT_FP_EQ(neg_inf, LIBC_NAMESPACE::pow(neg_inf, POS_ODD_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(neg_inf, POS_EVEN_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(neg_inf, POS_NON_INTEGER));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(neg_inf, ONE_HALF));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(neg_inf, inf));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(neg_inf, neg_inf));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(neg_inf, aNaN));
+
+    // pow ( aNaN, exponent )
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(aNaN, zero));
+    EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(aNaN, neg_zero));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, 1.0));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, -1.0));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, NEG_ODD_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, NEG_EVEN_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, NEG_NON_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, POS_ODD_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, POS_EVEN_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, POS_NON_INTEGER));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, inf));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, neg_inf));
+    EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(aNaN, aNaN));
+
+    // pow ( base, inf )
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(0.1, inf));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(-0.1, inf));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(1.1, inf));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(-1.1, inf));
+
+    // pow ( base, -inf )
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(0.1, neg_inf));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::pow(-0.1, neg_inf));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(1.1, neg_inf));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::pow(-1.1, neg_inf));
+
+    // Exact powers of 2:
+    // TODO: Enable these tests when we use exp2.
+    // EXPECT_FP_EQ(0x1.0p15, LIBC_NAMESPACE::pow(2.0, 15.0));
+    // EXPECT_FP_EQ(0x1.0p126, LIBC_NAMESPACE::pow(2.0, 126.0));
+    // EXPECT_FP_EQ(0x1.0p-45, LIBC_NAMESPACE::pow(2.0, -45.0));
+    // EXPECT_FP_EQ(0x1.0p-126, LIBC_NAMESPACE::pow(2.0, -126.0));
+    // EXPECT_FP_EQ(0x1.0p-149, LIBC_NAMESPACE::pow(2.0, -149.0));
+
+    // Exact powers of 10:
+    // TODO: Enable these tests when we use exp10
+    // EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(10.0, 0.0));
+    // EXPECT_FP_EQ(10.0, LIBC_NAMESPACE::pow(10.0, 1.0));
+    // EXPECT_FP_EQ(100.0, LIBC_NAMESPACE::pow(10.0, 2.0));
+    // EXPECT_FP_EQ(1000.0, LIBC_NAMESPACE::pow(10.0, 3.0));
+    // EXPECT_FP_EQ(10000.0, LIBC_NAMESPACE::pow(10.0, 4.0));
+    // EXPECT_FP_EQ(100000.0, LIBC_NAMESPACE::pow(10.0, 5.0));
+    // EXPECT_FP_EQ(1000000.0, LIBC_NAMESPACE::pow(10.0, 6.0));
+    // EXPECT_FP_EQ(10000000.0, LIBC_NAMESPACE::pow(10.0, 7.0));
+    // EXPECT_FP_EQ(100000000.0, LIBC_NAMESPACE::pow(10.0, 8.0));
+    // EXPECT_FP_EQ(1000000000.0, LIBC_NAMESPACE::pow(10.0, 9.0));
+    // EXPECT_FP_EQ(10000000000.0, LIBC_NAMESPACE::pow(10.0, 10.0));
+
+    // Overflow / Underflow:
+    if (ROUNDING_MODES[i] != RoundingMode::Downward &&
+        ROUNDING_MODES[i] != RoundingMode::TowardZero) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::pow(3.1, 2001.0),
+                                  FE_OVERFLOW);
+    }
+    if (ROUNDING_MODES[i] != RoundingMode::Upward) {
+      EXPECT_FP_EQ_WITH_EXCEPTION(0.0, LIBC_NAMESPACE::pow(3.1, -2001.0),
+                                  FE_UNDERFLOW);
+    }
+  }
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcPowTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_IS_NAN(LIBC_NAMESPACE::pow(-min_denormal, 0.5));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(2.0, min_denormal));
+}
+
+TEST_F(LlvmLibcPowTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::pow(-min_denormal, 0.5));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(2.0, min_denormal));
+}
+
+TEST_F(LlvmLibcPowTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::pow(-min_denormal, 0.5));
+  EXPECT_FP_EQ(1.0, LIBC_NAMESPACE::pow(2.0, min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/powf_test.cpp b/test/src/math/smoke/powf_test.cpp
index 98a532f..9cc95ce 100644
--- a/test/src/math/smoke/powf_test.cpp
+++ b/test/src/math/smoke/powf_test.cpp
@@ -12,7 +12,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcPowfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -25,7 +24,8 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
   constexpr float neg_non_integer = -1.1f;
   constexpr float pos_odd_integer = 5.0f;
   constexpr float pos_even_integer = 8.0f;
-  constexpr float pos_non_integer = 1.1f;
+  constexpr float pos_non_integer = 1.3f;
+  constexpr float one_half = 0.5f;
 
   for (int i = 0; i < N_ROUNDING_MODES; ++i) {
     ForceRoundingMode __r(ROUNDING_MODES[i]);
@@ -42,6 +42,7 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(zero, pos_odd_integer));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(zero, pos_even_integer));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(zero, pos_non_integer));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(zero, one_half));
     EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(zero, zero));
     EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(zero, neg_zero));
     EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::powf(zero, inf));
@@ -59,6 +60,7 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
     EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::powf(neg_zero, pos_odd_integer));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(neg_zero, pos_even_integer));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(neg_zero, pos_non_integer));
+    EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(neg_zero, one_half));
     EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(neg_zero, zero));
     EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(neg_zero, neg_zero));
     EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::powf(neg_zero, inf));
@@ -109,6 +111,7 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(inf, pos_odd_integer));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(inf, pos_even_integer));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(inf, pos_non_integer));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(inf, one_half));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(inf, inf));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(inf, neg_inf));
     EXPECT_FP_IS_NAN(LIBC_NAMESPACE::powf(inf, aNaN));
@@ -124,6 +127,7 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
     EXPECT_FP_EQ(neg_inf, LIBC_NAMESPACE::powf(neg_inf, pos_odd_integer));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(neg_inf, pos_even_integer));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(neg_inf, pos_non_integer));
+    EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(neg_inf, one_half));
     EXPECT_FP_EQ(inf, LIBC_NAMESPACE::powf(neg_inf, inf));
     EXPECT_FP_EQ(zero, LIBC_NAMESPACE::powf(neg_inf, neg_inf));
     EXPECT_FP_IS_NAN(LIBC_NAMESPACE::powf(neg_inf, aNaN));
@@ -186,4 +190,34 @@ TEST_F(LlvmLibcPowfTest, SpecialNumbers) {
                                   FE_UNDERFLOW);
     }
   }
+
+  EXPECT_FP_EQ(-0.0f, LIBC_NAMESPACE::powf(-0.015625f, 25.0f));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::powf(-0.015625f, 26.0f));
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcPowfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_IS_NAN(LIBC_NAMESPACE::powf(-min_denormal, 0.5f));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(2.0f, min_denormal));
+}
+
+TEST_F(LlvmLibcPowfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::powf(-min_denormal, 0.5f));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(2.0f, min_denormal));
+}
+
+TEST_F(LlvmLibcPowfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::powf(-min_denormal, 0.5f));
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::powf(2.0f, min_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/scalbln_test.cpp b/test/src/math/smoke/scalbln_test.cpp
new file mode 100644
index 0000000..eaf7b8e
--- /dev/null
+++ b/test/src/math/smoke/scalbln_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for scalbln ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ScalbnTest.h"
+
+#include "src/math/scalbln.h"
+
+LIST_SCALBN_TESTS(double, long, LIBC_NAMESPACE::scalbln)
diff --git a/test/src/math/smoke/scalblnf128_test.cpp b/test/src/math/smoke/scalblnf128_test.cpp
new file mode 100644
index 0000000..9ee1b38
--- /dev/null
+++ b/test/src/math/smoke/scalblnf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for scalblnf128 -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ScalbnTest.h"
+
+#include "src/math/scalblnf128.h"
+
+LIST_SCALBN_TESTS(float128, long, LIBC_NAMESPACE::scalblnf128)
diff --git a/test/src/math/smoke/scalblnf_test.cpp b/test/src/math/smoke/scalblnf_test.cpp
new file mode 100644
index 0000000..a40d7aa
--- /dev/null
+++ b/test/src/math/smoke/scalblnf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for scalblnf --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ScalbnTest.h"
+
+#include "src/math/scalblnf.h"
+
+LIST_SCALBN_TESTS(float, long, LIBC_NAMESPACE::scalblnf)
diff --git a/test/src/math/smoke/scalblnl_test.cpp b/test/src/math/smoke/scalblnl_test.cpp
new file mode 100644
index 0000000..ccfbe1e
--- /dev/null
+++ b/test/src/math/smoke/scalblnl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for scalblnl --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ScalbnTest.h"
+
+#include "src/math/scalblnl.h"
+
+LIST_SCALBN_TESTS(long double, long, LIBC_NAMESPACE::scalblnl)
diff --git a/test/src/math/smoke/setpayload_test.cpp b/test/src/math/smoke/setpayload_test.cpp
new file mode 100644
index 0000000..e41b3f8
--- /dev/null
+++ b/test/src/math/smoke/setpayload_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayload ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadTest.h"
+
+#include "src/math/setpayload.h"
+
+LIST_SETPAYLOAD_TESTS(double, LIBC_NAMESPACE::setpayload)
diff --git a/test/src/math/smoke/setpayloadf128_test.cpp b/test/src/math/smoke/setpayloadf128_test.cpp
new file mode 100644
index 0000000..4b17bfe
--- /dev/null
+++ b/test/src/math/smoke/setpayloadf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadf128 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadTest.h"
+
+#include "src/math/setpayloadf128.h"
+
+LIST_SETPAYLOAD_TESTS(float128, LIBC_NAMESPACE::setpayloadf128)
diff --git a/test/src/math/smoke/setpayloadf_test.cpp b/test/src/math/smoke/setpayloadf_test.cpp
new file mode 100644
index 0000000..51e285f
--- /dev/null
+++ b/test/src/math/smoke/setpayloadf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadf -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadTest.h"
+
+#include "src/math/setpayloadf.h"
+
+LIST_SETPAYLOAD_TESTS(float, LIBC_NAMESPACE::setpayloadf)
diff --git a/test/src/math/smoke/setpayloadl_test.cpp b/test/src/math/smoke/setpayloadl_test.cpp
new file mode 100644
index 0000000..45bc6fd
--- /dev/null
+++ b/test/src/math/smoke/setpayloadl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadl -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadTest.h"
+
+#include "src/math/setpayloadl.h"
+
+LIST_SETPAYLOAD_TESTS(long double, LIBC_NAMESPACE::setpayloadl)
diff --git a/test/src/math/smoke/setpayloadsig_test.cpp b/test/src/math/smoke/setpayloadsig_test.cpp
new file mode 100644
index 0000000..4a7dea7
--- /dev/null
+++ b/test/src/math/smoke/setpayloadsig_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadsig ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadSigTest.h"
+
+#include "src/math/setpayloadsig.h"
+
+LIST_SETPAYLOADSIG_TESTS(double, LIBC_NAMESPACE::setpayloadsig)
diff --git a/test/src/math/smoke/setpayloadsigf128_test.cpp b/test/src/math/smoke/setpayloadsigf128_test.cpp
new file mode 100644
index 0000000..ea7d026
--- /dev/null
+++ b/test/src/math/smoke/setpayloadsigf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadsigf128 -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadSigTest.h"
+
+#include "src/math/setpayloadsigf128.h"
+
+LIST_SETPAYLOADSIG_TESTS(float128, LIBC_NAMESPACE::setpayloadsigf128)
diff --git a/test/src/math/smoke/setpayloadsigf_test.cpp b/test/src/math/smoke/setpayloadsigf_test.cpp
new file mode 100644
index 0000000..dd8ca2f
--- /dev/null
+++ b/test/src/math/smoke/setpayloadsigf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadsigf --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadSigTest.h"
+
+#include "src/math/setpayloadsigf.h"
+
+LIST_SETPAYLOADSIG_TESTS(float, LIBC_NAMESPACE::setpayloadsigf)
diff --git a/test/src/math/smoke/setpayloadsigl_test.cpp b/test/src/math/smoke/setpayloadsigl_test.cpp
new file mode 100644
index 0000000..6fc878c
--- /dev/null
+++ b/test/src/math/smoke/setpayloadsigl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for setpayloadsigl --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SetPayloadSigTest.h"
+
+#include "src/math/setpayloadsigl.h"
+
+LIST_SETPAYLOADSIG_TESTS(long double, LIBC_NAMESPACE::setpayloadsigl)
diff --git a/test/src/math/smoke/sin_test.cpp b/test/src/math/smoke/sin_test.cpp
new file mode 100644
index 0000000..7dd1b7f
--- /dev/null
+++ b/test/src/math/smoke/sin_test.cpp
@@ -0,0 +1,53 @@
+//===-- Unittests for sin -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sin.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcSinTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcSinTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::sin(aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::sin(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::sin(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::sin(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::sin(neg_zero));
+  EXPECT_FP_EQ(0x1.0p-50, LIBC_NAMESPACE::sin(0x1.0p-50));
+  EXPECT_FP_EQ(min_normal, LIBC_NAMESPACE::sin(min_normal));
+  EXPECT_FP_EQ(min_denormal, LIBC_NAMESPACE::sin(min_denormal));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcSinTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(max_denormal));
+}
+
+TEST_F(LlvmLibcSinTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(max_denormal));
+}
+
+TEST_F(LlvmLibcSinTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sin(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/sincos_test.cpp b/test/src/math/smoke/sincos_test.cpp
new file mode 100644
index 0000000..371c0ad
--- /dev/null
+++ b/test/src/math/smoke/sincos_test.cpp
@@ -0,0 +1,41 @@
+//===-- Unittests for sincos ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sincos.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcSincosTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+TEST_F(LlvmLibcSincosTest, SpecialNumbers) {
+  double sin_x, cos_x;
+
+  LIBC_NAMESPACE::sincos(aNaN, &sin_x, &cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, sin_x);
+
+  LIBC_NAMESPACE::sincos(zero, &sin_x, &cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0, cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(0.0, sin_x);
+
+  LIBC_NAMESPACE::sincos(neg_zero, &sin_x, &cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(1.0, cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, sin_x);
+
+  LIBC_NAMESPACE::sincos(inf, &sin_x, &cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, sin_x);
+
+  LIBC_NAMESPACE::sincos(neg_inf, &sin_x, &cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, cos_x);
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, sin_x);
+
+  LIBC_NAMESPACE::sincos(0x1.0p-28, &sin_x, &cos_x);
+  EXPECT_FP_EQ(1.0, cos_x);
+  EXPECT_FP_EQ(0x1.0p-28, sin_x);
+}
diff --git a/test/src/math/smoke/sincosf_test.cpp b/test/src/math/smoke/sincosf_test.cpp
index 8c35953..e6896ca 100644
--- a/test/src/math/smoke/sincosf_test.cpp
+++ b/test/src/math/smoke/sincosf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinCosfTest = LIBC_NAMESPACE::testing::FPTest<float>;
diff --git a/test/src/math/smoke/sinf_test.cpp b/test/src/math/smoke/sinf_test.cpp
index 9fc208d..776c66d 100644
--- a/test/src/math/smoke/sinf_test.cpp
+++ b/test/src/math/smoke/sinf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,30 @@ TEST_F(LlvmLibcSinfTest, SpecialNumbers) {
   EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinf(neg_inf));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcSinfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(max_denormal));
+}
+
+TEST_F(LlvmLibcSinfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(max_denormal));
+}
+
+TEST_F(LlvmLibcSinfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/sinhf16_test.cpp b/test/src/math/smoke/sinhf16_test.cpp
new file mode 100644
index 0000000..4f21d33
--- /dev/null
+++ b/test/src/math/smoke/sinhf16_test.cpp
@@ -0,0 +1,88 @@
+//===-- Unittests for sinhf16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/sinhf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcSinhf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcSinhf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::sinhf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::sinhf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(inf, LIBC_NAMESPACE::sinhf16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_inf, LIBC_NAMESPACE::sinhf16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::sinhf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::sinhf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcSinhf16Test, Overflow) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(inf, LIBC_NAMESPACE::sinhf16(max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(neg_inf, LIBC_NAMESPACE::sinhf16(neg_max_normal),
+                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  // round(asinh(2^16), HP, RU);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.794p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(inf, LIBC_NAMESPACE::sinhf16(x),
+                                               FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(inf, LIBC_NAMESPACE::sinhf16(x),
+                                              FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      max_normal, LIBC_NAMESPACE::sinhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      max_normal, LIBC_NAMESPACE::sinhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  // round(asinh(-2^16), HP, RD);
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.794p+3);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      neg_inf, LIBC_NAMESPACE::sinhf16(x), FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      neg_max_normal, LIBC_NAMESPACE::sinhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      neg_inf, LIBC_NAMESPACE::sinhf16(x), FE_OVERFLOW | FE_INEXACT);
+  EXPECT_MATH_ERRNO(ERANGE);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      neg_max_normal, LIBC_NAMESPACE::sinhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
diff --git a/test/src/math/smoke/sinhf_test.cpp b/test/src/math/smoke/sinhf_test.cpp
index 1e05298..3cc0656 100644
--- a/test/src/math/smoke/sinhf_test.cpp
+++ b/test/src/math/smoke/sinhf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcSinhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -63,3 +62,30 @@ TEST_F(LlvmLibcSinhfTest, Overflow) {
       inf, LIBC_NAMESPACE::sinhf(FPBits(0x42d00008U).get_val()), FE_OVERFLOW);
   EXPECT_MATH_ERRNO(ERANGE);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcSinhfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(max_denormal));
+}
+
+TEST_F(LlvmLibcSinhfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(max_denormal));
+}
+
+TEST_F(LlvmLibcSinhfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinhf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/sinpif16_test.cpp b/test/src/math/smoke/sinpif16_test.cpp
new file mode 100644
index 0000000..0bcd38a
--- /dev/null
+++ b/test/src/math/smoke/sinpif16_test.cpp
@@ -0,0 +1,42 @@
+//===-- Unittests for sinpif16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/sinpif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcSinpif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcSinpif16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+TEST_F(LlvmLibcSinpif16Test, Integers) {
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x420));
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x1p+10));
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x1.4p+14));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x420));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x1.cp+15));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x1.cp+7));
+}
diff --git a/test/src/math/smoke/sinpif_test.cpp b/test/src/math/smoke/sinpif_test.cpp
new file mode 100644
index 0000000..11bda0b
--- /dev/null
+++ b/test/src/math/smoke/sinpif_test.cpp
@@ -0,0 +1,70 @@
+//===-- Unittests for sinpif ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/sinpif.h"
+#include "test/UnitTest/FPMatcher.h"
+
+#include <stdint.h>
+
+using LlvmLibcSinpifTest = LIBC_NAMESPACE::testing::FPTest<float>;
+
+TEST_F(LlvmLibcSinpifTest, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(-0.0f, LIBC_NAMESPACE::sinpif(-0.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinpif(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
+
+TEST_F(LlvmLibcSinpifTest, Integers) {
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x420));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1p+43));
+  EXPECT_FP_EQ(-0.0, LIBC_NAMESPACE::sinpif(-0x1.4p+64));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x420));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1.cp+106));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::sinpif(0x1.cp+21));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcSinpifTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(min_denormal));
+  EXPECT_FP_EQ(0x1.921fb2p-125f, LIBC_NAMESPACE::sinpif(max_denormal));
+}
+
+TEST_F(LlvmLibcSinpifTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(max_denormal));
+}
+
+TEST_F(LlvmLibcSinpifTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::sinpif(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/sqrtf16_test.cpp b/test/src/math/smoke/sqrtf16_test.cpp
new file mode 100644
index 0000000..d620496
--- /dev/null
+++ b/test/src/math/smoke/sqrtf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for sqrtf16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/sqrtf16.h"
+
+LIST_SQRT_TESTS(float16, LIBC_NAMESPACE::sqrtf16)
diff --git a/test/src/math/smoke/tan_test.cpp b/test/src/math/smoke/tan_test.cpp
new file mode 100644
index 0000000..aa5c23d
--- /dev/null
+++ b/test/src/math/smoke/tan_test.cpp
@@ -0,0 +1,53 @@
+//===-- Unittests for tan -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tan.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcTanTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcTanTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::tan(aNaN));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::tan(inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::tan(neg_inf));
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::tan(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::tan(neg_zero));
+  EXPECT_FP_EQ(0x1.0p-50, LIBC_NAMESPACE::tan(0x1.0p-50));
+  EXPECT_FP_EQ(min_normal, LIBC_NAMESPACE::tan(min_normal));
+  EXPECT_FP_EQ(min_denormal, LIBC_NAMESPACE::tan(min_denormal));
+}
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcTanTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(max_denormal));
+}
+
+TEST_F(LlvmLibcTanTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(max_denormal));
+}
+
+TEST_F(LlvmLibcTanTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(min_denormal));
+  EXPECT_FP_EQ(0.0, LIBC_NAMESPACE::tan(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/tanf_test.cpp b/test/src/math/smoke/tanf_test.cpp
index ab3f7c1..93fbfde 100644
--- a/test/src/math/smoke/tanf_test.cpp
+++ b/test/src/math/smoke/tanf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcTanfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,30 @@ TEST_F(LlvmLibcTanfTest, SpecialNumbers) {
   EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanf(neg_inf));
   EXPECT_MATH_ERRNO(EDOM);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcTanfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(max_denormal));
+}
+
+TEST_F(LlvmLibcTanfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(max_denormal));
+}
+
+TEST_F(LlvmLibcTanfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/tanhf16_test.cpp b/test/src/math/smoke/tanhf16_test.cpp
new file mode 100644
index 0000000..fa6328e
--- /dev/null
+++ b/test/src/math/smoke/tanhf16_test.cpp
@@ -0,0 +1,143 @@
+//===-- Unittests for tanhf16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/errno/libc_errno.h"
+#include "src/math/tanhf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcTanhf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcTanhf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::tanhf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::tanhf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(1.0),
+                            LIBC_NAMESPACE::tanhf16(inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                            LIBC_NAMESPACE::tanhf16(neg_inf));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::tanhf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::tanhf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+}
+
+TEST_F(LlvmLibcTanhf16Test, ResultNearBounds) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(LIBC_NAMESPACE::fputil::cast<float16>(1.0),
+                              LIBC_NAMESPACE::tanhf16(max_normal), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(LIBC_NAMESPACE::fputil::cast<float16>(-1.0),
+                              LIBC_NAMESPACE::tanhf16(neg_max_normal),
+                              FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  // round(atanh(1 - 2^-11), HP, RU);
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.0a4p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  x = LIBC_NAMESPACE::fputil::cast<float16>(0x1.208p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  // round(atanh(-1 + 2^-11), HP, RD);
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.0a4p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  x = LIBC_NAMESPACE::fputil::cast<float16>(-0x1.208p+2);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_UPWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_DOWNWARD(
+      LIBC_NAMESPACE::fputil::cast<float16>(-1.0), LIBC_NAMESPACE::tanhf16(x),
+      FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_TOWARD_ZERO(
+      LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp-1),
+      LIBC_NAMESPACE::tanhf16(x), FE_INEXACT);
+  EXPECT_MATH_ERRNO(0);
+}
diff --git a/test/src/math/smoke/tanhf_test.cpp b/test/src/math/smoke/tanhf_test.cpp
index ddae021..3b7faa8 100644
--- a/test/src/math/smoke/tanhf_test.cpp
+++ b/test/src/math/smoke/tanhf_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcTanhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -36,3 +35,30 @@ TEST_F(LlvmLibcTanhfTest, SpecialNumbers) {
   EXPECT_FP_EQ(-1.0f, LIBC_NAMESPACE::tanhf(neg_inf));
   EXPECT_MATH_ERRNO(0);
 }
+
+#ifdef LIBC_TEST_FTZ_DAZ
+
+using namespace LIBC_NAMESPACE::testing;
+
+TEST_F(LlvmLibcTanhfTest, FTZMode) {
+  ModifyMXCSR mxcsr(FTZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(max_denormal));
+}
+
+TEST_F(LlvmLibcTanhfTest, DAZMode) {
+  ModifyMXCSR mxcsr(DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(max_denormal));
+}
+
+TEST_F(LlvmLibcTanhfTest, FTZDAZMode) {
+  ModifyMXCSR mxcsr(FTZ | DAZ);
+
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(min_denormal));
+  EXPECT_FP_EQ(0.0f, LIBC_NAMESPACE::tanhf(max_denormal));
+}
+
+#endif
diff --git a/test/src/math/smoke/tanpif16_test.cpp b/test/src/math/smoke/tanpif16_test.cpp
new file mode 100644
index 0000000..a378cfb
--- /dev/null
+++ b/test/src/math/smoke/tanpif16_test.cpp
@@ -0,0 +1,33 @@
+//===-- Unittests for tanpif16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/tanpif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcTanpif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcTanpif16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanpif16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::tanpif16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::tanpif16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanpif16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanpif16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/totalorder_test.cpp b/test/src/math/smoke/totalorder_test.cpp
new file mode 100644
index 0000000..21f49c3
--- /dev/null
+++ b/test/src/math/smoke/totalorder_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalorder ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderTest.h"
+
+#include "src/math/totalorder.h"
+
+LIST_TOTALORDER_TESTS(double, LIBC_NAMESPACE::totalorder)
diff --git a/test/src/math/smoke/totalorderf128_test.cpp b/test/src/math/smoke/totalorderf128_test.cpp
new file mode 100644
index 0000000..6f7fd6a
--- /dev/null
+++ b/test/src/math/smoke/totalorderf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalorderf128 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderTest.h"
+
+#include "src/math/totalorderf128.h"
+
+LIST_TOTALORDER_TESTS(float128, LIBC_NAMESPACE::totalorderf128)
diff --git a/test/src/math/smoke/totalorderf_test.cpp b/test/src/math/smoke/totalorderf_test.cpp
new file mode 100644
index 0000000..71db87c
--- /dev/null
+++ b/test/src/math/smoke/totalorderf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalorderf -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderTest.h"
+
+#include "src/math/totalorderf.h"
+
+LIST_TOTALORDER_TESTS(float, LIBC_NAMESPACE::totalorderf)
diff --git a/test/src/math/smoke/totalorderl_test.cpp b/test/src/math/smoke/totalorderl_test.cpp
new file mode 100644
index 0000000..fc2353f
--- /dev/null
+++ b/test/src/math/smoke/totalorderl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalorderl -----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderTest.h"
+
+#include "src/math/totalorderl.h"
+
+LIST_TOTALORDER_TESTS(long double, LIBC_NAMESPACE::totalorderl)
diff --git a/test/src/math/smoke/totalordermag_test.cpp b/test/src/math/smoke/totalordermag_test.cpp
new file mode 100644
index 0000000..6c3b6dd
--- /dev/null
+++ b/test/src/math/smoke/totalordermag_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalordermag ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderMagTest.h"
+
+#include "src/math/totalordermag.h"
+
+LIST_TOTALORDERMAG_TESTS(double, LIBC_NAMESPACE::totalordermag)
diff --git a/test/src/math/smoke/totalordermagf128_test.cpp b/test/src/math/smoke/totalordermagf128_test.cpp
new file mode 100644
index 0000000..6cbe24f
--- /dev/null
+++ b/test/src/math/smoke/totalordermagf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalordermagf128 -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderMagTest.h"
+
+#include "src/math/totalordermagf128.h"
+
+LIST_TOTALORDERMAG_TESTS(float128, LIBC_NAMESPACE::totalordermagf128)
diff --git a/test/src/math/smoke/totalordermagf_test.cpp b/test/src/math/smoke/totalordermagf_test.cpp
new file mode 100644
index 0000000..c54cea2
--- /dev/null
+++ b/test/src/math/smoke/totalordermagf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalordermagf --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderMagTest.h"
+
+#include "src/math/totalordermagf.h"
+
+LIST_TOTALORDERMAG_TESTS(float, LIBC_NAMESPACE::totalordermagf)
diff --git a/test/src/math/smoke/totalordermagl_test.cpp b/test/src/math/smoke/totalordermagl_test.cpp
new file mode 100644
index 0000000..bdb9f61
--- /dev/null
+++ b/test/src/math/smoke/totalordermagl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for totalordermagl --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TotalOrderMagTest.h"
+
+#include "src/math/totalordermagl.h"
+
+LIST_TOTALORDERMAG_TESTS(long double, LIBC_NAMESPACE::totalordermagl)
diff --git a/test/src/math/sqrtf16_test.cpp b/test/src/math/sqrtf16_test.cpp
new file mode 100644
index 0000000..f6e8996
--- /dev/null
+++ b/test/src/math/sqrtf16_test.cpp
@@ -0,0 +1,28 @@
+//===-- Exhaustive test for sqrtf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sqrtf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcSqrtf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+TEST_F(LlvmLibcSqrtf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x,
+                                   LIBC_NAMESPACE::sqrtf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/tan_test.cpp b/test/src/math/tan_test.cpp
index d813dcc..12dfc02 100644
--- a/test/src/math/tan_test.cpp
+++ b/test/src/math/tan_test.cpp
@@ -6,27 +6,121 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/FPUtil/FPBits.h"
 #include "src/math/tan.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include "hdr/math_macros.h"
-
 using LlvmLibcTanTest = LIBC_NAMESPACE::testing::FPTest<double>;
 
 namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
 
-TEST_F(LlvmLibcTanTest, Range) {
-  static constexpr double _2pi = 6.283185307179586;
-  constexpr StorageType COUNT = 100'000;
-  constexpr StorageType STEP = STORAGE_MAX / COUNT;
-  for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
-    double x = FPBits(v).get_val();
-    // TODO: Expand the range of testing after range reduction is implemented.
-    if (isnan(x) || isinf(x) || x > _2pi || x < -_2pi)
-      continue;
-
-    ASSERT_MPFR_MATCH(mpfr::Operation::Tan, x, LIBC_NAMESPACE::tan(x), 1.0);
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcTanTest, TrickyInputs) {
+  constexpr double INPUTS[] = {
+      0x0.0000000000001p-1022, 0x1.d130383d17321p-27,  0x1.8000000000009p-23,
+      0x1.8000000000024p-22,   0x1.800000000009p-21,   0x1.20000000000f3p-20,
+      0x1.800000000024p-20,    0x1.e0000000001c2p-20,  0x1.00452f0e0134dp-13,
+      0x1.0da8cc189b47dp-10,   0x1.00a33764a0a83p-7,   0x1.911a18779813fp-7,
+      0x1.940c877fb7dacp-7,    0x1.f42fb19b5b9b2p-6,   0x1.0285070f9f1bcp-5,
+      0x1.90e833c6969c7p-4,    0x1.91d4b77c527eap-3,   0x1.89f0f5241255bp-2,
+      0x1.6ca9ef729af76p-1,    0x1.23f40dccdef72p+0,   0x1.43cf16358c9d7p+0,
+      0x1.90f422b49115ep+0,    0x1.9220efee9fc7ep+0,   0x1.a224411cdebcep+0,
+      0x1.addf3b9722265p+0,    0x1.ae78d360afa15p+0,   0x1.fe81868fc47fep+1,
+      0x1.e31b55306f22cp+2,    0x1.e639103a05997p+2,   0x1.f69d074a3358fp+2,
+      0x1.f7898d5a756ddp+2,    0x1.1685973506319p+3,   0x1.5f09cad750ab1p+3,
+      0x1.aaf85537ea4c7p+3,    0x1.c50ddc4f513b4p+3,   0x1.13114266f9764p+4,
+      0x1.4f2b874135d27p+4,    0x1.a211877de55dbp+4,   0x1.a5eece87e8606p+4,
+      0x1.a65d441ea6dcep+4,    0x1.ab8c2f8ab5b7p+4,    0x1.045457ae3994p+5,
+      0x1.1ffb509f3db15p+5,    0x1.2345d1e090529p+5,   0x1.c96e28eb679f8p+5,
+      0x1.da1838053b866p+5,    0x1.be886d9c2324dp+6,   0x1.ab514bfc61c76p+7,
+      0x1.14823229799c2p+7,    0x1.48ff1782ca91dp+8,   0x1.dcbfda0c7559ep+8,
+      0x1.dcbfda0c7559ep+8,    0x1.2e566149bf5fdp+9,   0x1.cb996c60f437ep+9,
+      0x1.119471e9216cdp+10,   0x1.ae945054939c2p+10,  0x1.fffffffffdb6p+24,
+      0x1.fd4da4ef37075p+29,   0x1.55202aefde314p+31,  0x1.b951f1572eba5p+31,
+      0x1.76e86a7485a46p59,    0x1.7776c2343ba4ep+101, 0x1.85fc0f04c0128p+101,
+      0x1.678309fa50d58p+110,  0x1.524489232dc4ap+178, 0x1.fffffffffef4ep+199,
+      0x1.6deb37da81129p+205,  0x1.3eec5912ea7cdp+331, 0x1.08087e9aad90bp+887,
+      0x1.6ac5b262ca1ffp+843,  0x1.8bb5847d49973p+845, 0x1.6ac5b262ca1ffp+849,
+      0x1.f08b14e1c4d0fp+890,  0x1.2b5fe88a9d8d5p+903, 0x1.a880417b7b119p+1023,
+      0x1.f6d7518808571p+1023,
+
+  };
+  constexpr int N = sizeof(INPUTS) / sizeof(INPUTS[0]);
+
+  for (int i = 0; i < N; ++i) {
+    double x = INPUTS[i];
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tan, x,
+                                   LIBC_NAMESPACE::tan(x), 0.5);
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tan, -x,
+                                   LIBC_NAMESPACE::tan(-x), 0.5);
   }
 }
+
+TEST_F(LlvmLibcTanTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 1'234'51;
+  uint64_t START = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p-50).uintval();
+  uint64_t STOP = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p200).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode force_rounding(rounding_mode);
+    if (!force_rounding.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t tested = 0;
+    uint64_t total = 0;
+    double worst_input, worst_output = 0.0;
+    double ulp = 0.5;
+
+    for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
+        continue;
+
+      double result = LIBC_NAMESPACE::tan(x);
+      ++total;
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
+        continue;
+
+      ++tested;
+
+      if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Tan, x, result,
+                                             0.5, rounding_mode)) {
+        ++fails;
+        while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Tan, x,
+                                                  result, ulp, rounding_mode)) {
+          worst_input = x;
+          worst_output = result;
+
+          if (ulp > 1000.0)
+            break;
+
+          ulp *= 2.0;
+        }
+      }
+    }
+    if (fails) {
+      tlog << " Tan failed: " << fails << "/" << tested << "/" << total
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(ulp) << ".\n";
+      EXPECT_MPFR_MATCH(mpfr::Operation::Tan, worst_input, worst_output, 0.5,
+                        rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/tanf_test.cpp b/test/src/math/tanf_test.cpp
index e624d30..9061cf6 100644
--- a/test/src/math/tanf_test.cpp
+++ b/test/src/math/tanf_test.cpp
@@ -15,7 +15,6 @@
 #include "test/src/math/sdcomp26094.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcTanfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -48,7 +47,7 @@ TEST_F(LlvmLibcTanfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tan, x,
                                    LIBC_NAMESPACE::tanf(x), 0.5);
diff --git a/test/src/math/tanhf16_test.cpp b/test/src/math/tanhf16_test.cpp
new file mode 100644
index 0000000..7124a83
--- /dev/null
+++ b/test/src/math/tanhf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for tanhf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanhf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcTanhf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf];
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0];
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcTanhf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tanh, x,
+                                   LIBC_NAMESPACE::tanhf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcTanhf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tanh, x,
+                                   LIBC_NAMESPACE::tanhf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/tanhf_test.cpp b/test/src/math/tanhf_test.cpp
index c34efe8..389abe4 100644
--- a/test/src/math/tanhf_test.cpp
+++ b/test/src/math/tanhf_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/Test.h"
 #include "utils/MPFRWrapper/MPFRUtils.h"
 
-#include <errno.h>
 #include <stdint.h>
 
 using LlvmLibcTanhfTest = LIBC_NAMESPACE::testing::FPTest<float>;
@@ -45,7 +44,7 @@ TEST_F(LlvmLibcTanhfTest, InFloatRange) {
   constexpr uint32_t STEP = UINT32_MAX / COUNT;
   for (uint32_t i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
     float x = FPBits(v).get_val();
-    if (isnan(x) || isinf(x))
+    if (FPBits(v).is_nan() || FPBits(v).is_inf())
       continue;
     ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tanh, x,
                                    LIBC_NAMESPACE::tanhf(x), 0.5);
diff --git a/test/src/math/tanpif16_test.cpp b/test/src/math/tanpif16_test.cpp
new file mode 100644
index 0000000..629ba96
--- /dev/null
+++ b/test/src/math/tanpif16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for cospif16 --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanpif16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcTanpif16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcTanpif16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tanpi, x,
+                                   LIBC_NAMESPACE::tanpif16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcTanpif16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tanpi, x,
+                                   LIBC_NAMESPACE::tanpif16(x), 0.5);
+  }
+}
diff --git a/test/src/network/htonl_test.cpp b/test/src/network/htonl_test.cpp
index d3b930d..f2e2541 100644
--- a/test/src/network/htonl_test.cpp
+++ b/test/src/network/htonl_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
 #include "src/network/htonl.h"
 #include "src/network/ntohl.h"
 #include "test/UnitTest/Test.h"
diff --git a/test/src/network/htons_test.cpp b/test/src/network/htons_test.cpp
index d38fab8..9668162 100644
--- a/test/src/network/htons_test.cpp
+++ b/test/src/network/htons_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
 #include "src/network/htons.h"
 #include "src/network/ntohs.h"
 #include "test/UnitTest/Test.h"
diff --git a/test/src/network/ntohl_test.cpp b/test/src/network/ntohl_test.cpp
index b06f8e1..b72456b 100644
--- a/test/src/network/ntohl_test.cpp
+++ b/test/src/network/ntohl_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
 #include "src/network/htonl.h"
 #include "src/network/ntohl.h"
 #include "test/UnitTest/Test.h"
diff --git a/test/src/network/ntohs_test.cpp b/test/src/network/ntohs_test.cpp
index 654a396..1104356 100644
--- a/test/src/network/ntohs_test.cpp
+++ b/test/src/network/ntohs_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/endian.h"
+#include "src/__support/endian_internal.h"
 #include "src/network/htons.h"
 #include "src/network/ntohs.h"
 #include "test/UnitTest/Test.h"
diff --git a/test/src/pthread/pthread_attr_test.cpp b/test/src/pthread/pthread_attr_test.cpp
index 1af585a..bee9a1c 100644
--- a/test/src/pthread/pthread_attr_test.cpp
+++ b/test/src/pthread/pthread_attr_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/errno_macros.h"
 #include "src/pthread/pthread_attr_destroy.h"
 #include "src/pthread/pthread_attr_getdetachstate.h"
 #include "src/pthread/pthread_attr_getguardsize.h"
@@ -19,7 +20,6 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <linux/param.h> // For EXEC_PAGESIZE.
 #include <pthread.h>
 
diff --git a/test/src/pthread/pthread_mutexattr_test.cpp b/test/src/pthread/pthread_mutexattr_test.cpp
index a7acd58..7fbdd2e 100644
--- a/test/src/pthread/pthread_mutexattr_test.cpp
+++ b/test/src/pthread/pthread_mutexattr_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/errno_macros.h"
 #include "src/pthread/pthread_mutexattr_destroy.h"
 #include "src/pthread/pthread_mutexattr_getpshared.h"
 #include "src/pthread/pthread_mutexattr_getrobust.h"
@@ -15,8 +16,6 @@
 #include "src/pthread/pthread_mutexattr_setrobust.h"
 #include "src/pthread/pthread_mutexattr_settype.h"
 #include "test/UnitTest/Test.h"
-
-#include <errno.h>
 #include <pthread.h>
 
 TEST(LlvmLibcPThreadMutexAttrTest, InitAndDestroy) {
diff --git a/test/src/search/hsearch_test.cpp b/test/src/search/hsearch_test.cpp
index f7d9479..01805d8 100644
--- a/test/src/search/hsearch_test.cpp
+++ b/test/src/search/hsearch_test.cpp
@@ -15,7 +15,6 @@
 #include "src/search/hsearch.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
-#include <asm-generic/errno-base.h>
 
 TEST(LlvmLibcHsearchTest, CreateTooLarge) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
diff --git a/test/src/search/lfind_test.cpp b/test/src/search/lfind_test.cpp
new file mode 100644
index 0000000..00384f7
--- /dev/null
+++ b/test/src/search/lfind_test.cpp
@@ -0,0 +1,46 @@
+//===-- Unittests for lfind -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/search/lfind.h"
+#include "test/UnitTest/Test.h"
+
+int compar(const void *a, const void *b) {
+  return *reinterpret_cast<const int *>(a) != *reinterpret_cast<const int *>(b);
+}
+
+TEST(LlvmLibcLfindTest, SearchHead) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 1;
+  void *ret = LIBC_NAMESPACE::lfind(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[0]);
+}
+
+TEST(LlvmLibcLfindTest, SearchMiddle) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 2;
+  void *ret = LIBC_NAMESPACE::lfind(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[1]);
+}
+
+TEST(LlvmLibcLfindTest, SearchTail) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 3;
+  void *ret = LIBC_NAMESPACE::lfind(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[2]);
+}
+
+TEST(LlvmLibcLfindTest, SearchNonExistent) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 5;
+  void *ret = LIBC_NAMESPACE::lfind(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == nullptr);
+}
diff --git a/test/src/signal/sigaction_test.cpp b/test/src/signal/sigaction_test.cpp
index 262469c..a12d798 100644
--- a/test/src/signal/sigaction_test.cpp
+++ b/test/src/signal/sigaction_test.cpp
@@ -6,15 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/errno_macros.h"
+#include "hdr/signal_macros.h"
 #include "src/signal/raise.h"
 #include "src/signal/sigaction.h"
-
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
-#include <signal.h>
-
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 
diff --git a/test/src/signal/sigaddset_test.cpp b/test/src/signal/sigaddset_test.cpp
index ac9334f..bc33750 100644
--- a/test/src/signal/sigaddset_test.cpp
+++ b/test/src/signal/sigaddset_test.cpp
@@ -11,7 +11,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <signal.h>
 
 // This tests invalid inputs and ensures errno is properly set.
diff --git a/test/src/signal/sigaltstack_test.cpp b/test/src/signal/sigaltstack_test.cpp
index 12bf2bf..cc392da 100644
--- a/test/src/signal/sigaltstack_test.cpp
+++ b/test/src/signal/sigaltstack_test.cpp
@@ -6,17 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/signal_macros.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/errno/libc_errno.h"
 #include "src/signal/linux/signal_utils.h"
 #include "src/signal/raise.h"
 #include "src/signal/sigaction.h"
 #include "src/signal/sigaltstack.h"
-
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <signal.h>
 #include <stdint.h>
 #include <sys/syscall.h>
 
diff --git a/test/src/signal/sigdelset_test.cpp b/test/src/signal/sigdelset_test.cpp
index aeae66f..622f1a3 100644
--- a/test/src/signal/sigdelset_test.cpp
+++ b/test/src/signal/sigdelset_test.cpp
@@ -14,7 +14,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <signal.h>
 
 TEST(LlvmLibcSigdelset, Invalid) {
diff --git a/test/src/signal/sigfillset_test.cpp b/test/src/signal/sigfillset_test.cpp
index 7922b3a..0604bc2 100644
--- a/test/src/signal/sigfillset_test.cpp
+++ b/test/src/signal/sigfillset_test.cpp
@@ -13,7 +13,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <signal.h>
 
 TEST(LlvmLibcSigfillset, Invalid) {
diff --git a/test/src/signal/signal_test.cpp b/test/src/signal/signal_test.cpp
index 70e95a8..4b57311 100644
--- a/test/src/signal/signal_test.cpp
+++ b/test/src/signal/signal_test.cpp
@@ -13,14 +13,14 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <signal.h>
+#include "hdr/types/sighandler_t.h"
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 
 TEST(LlvmLibcSignal, Invalid) {
   LIBC_NAMESPACE::libc_errno = 0;
-  LIBC_NAMESPACE::sighandler_t valid = +[](int) {};
+  sighandler_t valid = +[](int) {};
   EXPECT_THAT((void *)LIBC_NAMESPACE::signal(0, valid),
               Fails(EINVAL, (void *)SIG_ERR));
   EXPECT_THAT((void *)LIBC_NAMESPACE::signal(65, valid),
diff --git a/test/src/spawn/posix_spawn_file_actions_test.cpp b/test/src/spawn/posix_spawn_file_actions_test.cpp
index 008167e..c1edf56 100644
--- a/test/src/spawn/posix_spawn_file_actions_test.cpp
+++ b/test/src/spawn/posix_spawn_file_actions_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/errno/libc_errno.h"
 #include "src/spawn/file_actions.h"
 #include "src/spawn/posix_spawn_file_actions_addclose.h"
 #include "src/spawn/posix_spawn_file_actions_adddup2.h"
@@ -14,7 +15,6 @@
 #include "src/spawn/posix_spawn_file_actions_init.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <spawn.h>
 #include <stdint.h>
 
diff --git a/test/src/stdbit/stdc_bit_floor_ui_test.cpp b/test/src/stdbit/stdc_bit_floor_ui_test.cpp
index 5379040..1e3d933 100644
--- a/test/src/stdbit/stdc_bit_floor_ui_test.cpp
+++ b/test/src/stdbit/stdc_bit_floor_ui_test.cpp
@@ -15,7 +15,11 @@ TEST(LlvmLibcStdcBitfloorUiTest, Zero) {
 }
 
 TEST(LlvmLibcStdcBitfloorUiTest, Ones) {
-  for (unsigned i = 0U; i != INT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_floor_ui(UINT_MAX >> i),
-              1U << (UINT_WIDTH - i - 1));
+  for (unsigned i = 0U; i != LIBC_NAMESPACE::cpp::numeric_limits<int>::digits;
+       ++i)
+    EXPECT_EQ(
+        LIBC_NAMESPACE::stdc_bit_floor_ui(
+            LIBC_NAMESPACE::cpp::numeric_limits<unsigned int>::max() >> i),
+        1U << (LIBC_NAMESPACE::cpp::numeric_limits<unsigned int>::digits - i -
+               1));
 }
diff --git a/test/src/stdbit/stdc_leading_zeros_ui_test.cpp b/test/src/stdbit/stdc_leading_zeros_ui_test.cpp
index 2bd6bb5..c047457 100644
--- a/test/src/stdbit/stdc_leading_zeros_ui_test.cpp
+++ b/test/src/stdbit/stdc_leading_zeros_ui_test.cpp
@@ -13,11 +13,14 @@
 
 TEST(LlvmLibcStdcLeadingZerosUiTest, Zero) {
   EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_ui(0U),
-            static_cast<unsigned>(INT_WIDTH));
+            static_cast<unsigned>(
+                LIBC_NAMESPACE::cpp::numeric_limits<unsigned int>::digits));
 }
 
 TEST(LlvmLibcStdcLeadingZerosUiTest, OneHot) {
-  for (unsigned i = 0U; i != INT_WIDTH; ++i)
+  for (unsigned i = 0U;
+       i != LIBC_NAMESPACE::cpp::numeric_limits<unsigned int>::digits; ++i)
     EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_ui(1U << i),
-              INT_WIDTH - i - 1);
+              LIBC_NAMESPACE::cpp::numeric_limits<unsigned int>::digits - i -
+                  1);
 }
diff --git a/test/src/stdfix/FxBitsTest.h b/test/src/stdfix/FxBitsTest.h
new file mode 100644
index 0000000..ae04cc1
--- /dev/null
+++ b/test/src/stdfix/FxBitsTest.h
@@ -0,0 +1,55 @@
+//===-- Utility class to test int to fixed point conversions ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "test/UnitTest/Test.h"
+
+#include "include/llvm-libc-types/stdfix-types.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/fixed_point/fx_bits.h"
+
+template <typename T, typename XType>
+class FxBitsTest : public LIBC_NAMESPACE::testing::Test {
+  using FXRep = LIBC_NAMESPACE::fixed_point::FXRep<T>;
+  static constexpr T zero = FXRep::ZERO();
+  static constexpr T min = FXRep::MIN();
+  static constexpr T max = FXRep::MAX();
+  static constexpr T half = static_cast<T>(0.5);
+  static constexpr T quarter = static_cast<T>(0.25);
+  static constexpr T one =
+      (FXRep::INTEGRAL_LEN > 0) ? static_cast<T>(1) : FXRep::MAX();
+  static constexpr T eps = FXRep::EPS();
+  constexpr XType get_one_or_saturated_fraction() {
+    if (FXRep::INTEGRAL_LEN > 0) {
+      return static_cast<XType>(static_cast<XType>(0x1) << FXRep::FRACTION_LEN);
+    } else {
+      return static_cast<XType>(
+          LIBC_NAMESPACE::mask_trailing_ones<typename FXRep::StorageType,
+                                             FXRep::FRACTION_LEN>());
+    }
+  }
+
+public:
+  typedef T (*FxBitsFunc)(XType);
+
+  void test_special_numbers(FxBitsFunc func) {
+    EXPECT_EQ(zero, func(0));
+    EXPECT_EQ(eps, func(0x1));
+    // x.1000...
+    EXPECT_EQ(half, func(static_cast<XType>(0x1) << (FXRep::FRACTION_LEN - 1)));
+    // Occupy the bit to the left of the fixed point for Accum types
+    // Saturate fraction portion for Fract types
+    EXPECT_EQ(one, func(get_one_or_saturated_fraction()));
+  }
+};
+
+#define LIST_FXBITS_TEST(Name, T, XType, func)                                 \
+  using LlvmLibc##Name##BitsTest = FxBitsTest<T, XType>;                       \
+  TEST_F(LlvmLibc##Name##BitsTest, SpecialNumbers) {                           \
+    test_special_numbers(&func);                                               \
+  }                                                                            \
+  static_assert(true, "Require semicolon.")
diff --git a/test/src/stdfix/hkbits_test.cpp b/test/src/stdfix/hkbits_test.cpp
new file mode 100644
index 0000000..c4b55e1
--- /dev/null
+++ b/test/src/stdfix/hkbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for hkbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/hkbits.h"
+
+LIST_FXBITS_TEST(hk, short accum, int_hk_t, LIBC_NAMESPACE::hkbits);
diff --git a/test/src/stdfix/hrbits_test.cpp b/test/src/stdfix/hrbits_test.cpp
new file mode 100644
index 0000000..d47456a
--- /dev/null
+++ b/test/src/stdfix/hrbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for hrbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/hrbits.h"
+
+LIST_FXBITS_TEST(hr, short fract, int_hr_t, LIBC_NAMESPACE::hrbits);
diff --git a/test/src/stdfix/kbits_test.cpp b/test/src/stdfix/kbits_test.cpp
new file mode 100644
index 0000000..f646e13
--- /dev/null
+++ b/test/src/stdfix/kbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for kbits -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/kbits.h"
+
+LIST_FXBITS_TEST(k, accum, int_k_t, LIBC_NAMESPACE::kbits);
diff --git a/test/src/stdfix/lkbits_test.cpp b/test/src/stdfix/lkbits_test.cpp
new file mode 100644
index 0000000..f8fd3a6
--- /dev/null
+++ b/test/src/stdfix/lkbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for lkbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/lkbits.h"
+
+LIST_FXBITS_TEST(lk, long accum, int_lk_t, LIBC_NAMESPACE::lkbits);
diff --git a/test/src/stdfix/lrbits_test.cpp b/test/src/stdfix/lrbits_test.cpp
new file mode 100644
index 0000000..881a8c9
--- /dev/null
+++ b/test/src/stdfix/lrbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for lrbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/lrbits.h"
+
+LIST_FXBITS_TEST(lr, long fract, int_lr_t, LIBC_NAMESPACE::lrbits);
diff --git a/test/src/stdfix/rbits_test.cpp b/test/src/stdfix/rbits_test.cpp
new file mode 100644
index 0000000..12c95a5
--- /dev/null
+++ b/test/src/stdfix/rbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for rbits -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/rbits.h"
+
+LIST_FXBITS_TEST(r, fract, int_r_t, LIBC_NAMESPACE::rbits);
diff --git a/test/src/stdfix/uhkbits_test.cpp b/test/src/stdfix/uhkbits_test.cpp
new file mode 100644
index 0000000..b57e23b
--- /dev/null
+++ b/test/src/stdfix/uhkbits_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for uhkbits ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/uhkbits.h"
+
+LIST_FXBITS_TEST(uhk, unsigned short accum, uint_uhk_t,
+                 LIBC_NAMESPACE::uhkbits);
diff --git a/test/src/stdfix/uhrbits_test.cpp b/test/src/stdfix/uhrbits_test.cpp
new file mode 100644
index 0000000..1a9d2c6
--- /dev/null
+++ b/test/src/stdfix/uhrbits_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for uhrbits ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/uhrbits.h"
+
+LIST_FXBITS_TEST(uhr, unsigned short fract, uint_uhr_t,
+                 LIBC_NAMESPACE::uhrbits);
diff --git a/test/src/stdfix/ukbits_test.cpp b/test/src/stdfix/ukbits_test.cpp
new file mode 100644
index 0000000..bad707f
--- /dev/null
+++ b/test/src/stdfix/ukbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for ukbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/ukbits.h"
+
+LIST_FXBITS_TEST(uk, unsigned accum, uint_uk_t, LIBC_NAMESPACE::ukbits);
diff --git a/test/src/stdfix/ulkbits_test.cpp b/test/src/stdfix/ulkbits_test.cpp
new file mode 100644
index 0000000..3ee54be
--- /dev/null
+++ b/test/src/stdfix/ulkbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for ulkbits ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/ulkbits.h"
+
+LIST_FXBITS_TEST(ulk, unsigned long accum, uint_ulk_t, LIBC_NAMESPACE::ulkbits);
diff --git a/test/src/stdfix/ulrbits_test.cpp b/test/src/stdfix/ulrbits_test.cpp
new file mode 100644
index 0000000..a248deb
--- /dev/null
+++ b/test/src/stdfix/ulrbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for ulrbits ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/ulrbits.h"
+
+LIST_FXBITS_TEST(ulr, unsigned long fract, uint_ulr_t, LIBC_NAMESPACE::ulrbits);
diff --git a/test/src/stdfix/urbits_test.cpp b/test/src/stdfix/urbits_test.cpp
new file mode 100644
index 0000000..285b017
--- /dev/null
+++ b/test/src/stdfix/urbits_test.cpp
@@ -0,0 +1,12 @@
+//===-- Unittests for urbits ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "FxBitsTest.h"
+#include "src/stdfix/urbits.h"
+
+LIST_FXBITS_TEST(ur, unsigned fract, uint_ur_t, LIBC_NAMESPACE::urbits);
diff --git a/test/src/stdio/asprintf_test.cpp b/test/src/stdio/asprintf_test.cpp
new file mode 100644
index 0000000..9292ceb
--- /dev/null
+++ b/test/src/stdio/asprintf_test.cpp
@@ -0,0 +1,87 @@
+//===-- Unittests for asprintf--------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/asprintf.h"
+#include "src/stdio/sprintf.h"
+#include "src/string/memset.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcASPrintfTest, SimpleNoConv) {
+  char *buff = nullptr;
+  int written;
+  written =
+      LIBC_NAMESPACE::asprintf(&buff, "A simple string with no conversions.");
+  EXPECT_EQ(written, 36);
+  ASSERT_STREQ(buff, "A simple string with no conversions.");
+  free(buff);
+}
+
+TEST(LlvmLibcASPrintfTest, PercentConv) {
+  char *buff = nullptr;
+  int written;
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "%%");
+  EXPECT_EQ(written, 1);
+  ASSERT_STREQ(buff, "%");
+  free(buff);
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "abc %% def");
+  EXPECT_EQ(written, 9);
+  ASSERT_STREQ(buff, "abc % def");
+  free(buff);
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "%%%%%%");
+  EXPECT_EQ(written, 3);
+  ASSERT_STREQ(buff, "%%%");
+  free(buff);
+}
+
+TEST(LlvmLibcASPrintfTest, CharConv) {
+  char *buff = nullptr;
+  int written;
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "%c", 'a');
+  EXPECT_EQ(written, 1);
+  ASSERT_STREQ(buff, "a");
+  free(buff);
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "%3c %-3c", '1', '2');
+  EXPECT_EQ(written, 7);
+  ASSERT_STREQ(buff, "  1 2  ");
+  free(buff);
+
+  written = LIBC_NAMESPACE::asprintf(&buff, "%*c", 2, '3');
+  EXPECT_EQ(written, 2);
+  ASSERT_STREQ(buff, " 3");
+  free(buff);
+}
+
+TEST(LlvmLibcASPrintfTest, LargeStringNoConv) {
+  char *buff = nullptr;
+  char long_str[1001];
+  LIBC_NAMESPACE::memset(long_str, 'a', 1000);
+  long_str[1000] = '\0';
+  int written;
+  written = LIBC_NAMESPACE::asprintf(&buff, long_str);
+  EXPECT_EQ(written, 1000);
+  ASSERT_STREQ(buff, long_str);
+  free(buff);
+}
+
+TEST(LlvmLibcASPrintfTest, ManyReAlloc) {
+  char *buff = nullptr;
+  char long_str[1001];
+  auto expected_num_chars =
+      LIBC_NAMESPACE::sprintf(long_str, "%200s%200s%200s", "a", "b", "c");
+  long_str[expected_num_chars] = '\0';
+  int written;
+  written = LIBC_NAMESPACE::asprintf(&buff, long_str);
+  EXPECT_EQ(written, expected_num_chars);
+  ASSERT_STREQ(buff, long_str);
+  free(buff);
+}
diff --git a/test/src/stdio/fgetc_test.cpp b/test/src/stdio/fgetc_test.cpp
index 989bb31..2cc8436 100644
--- a/test/src/stdio/fgetc_test.cpp
+++ b/test/src/stdio/fgetc_test.cpp
@@ -16,8 +16,8 @@
 #include "src/stdio/getc.h"
 #include "test/UnitTest/Test.h"
 
+#include "hdr/stdio_macros.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 class LlvmLibcGetcTest : public LIBC_NAMESPACE::testing::Test {
 public:
diff --git a/test/src/stdio/fgetc_unlocked_test.cpp b/test/src/stdio/fgetc_unlocked_test.cpp
index 48d7a04..46cf12c 100644
--- a/test/src/stdio/fgetc_unlocked_test.cpp
+++ b/test/src/stdio/fgetc_unlocked_test.cpp
@@ -19,8 +19,8 @@
 #include "src/stdio/getc_unlocked.h"
 #include "test/UnitTest/Test.h"
 
+#include "hdr/stdio_macros.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 class LlvmLibcGetcTest : public LIBC_NAMESPACE::testing::Test {
 public:
diff --git a/test/src/stdio/fgets_test.cpp b/test/src/stdio/fgets_test.cpp
index d005a71..a8a2c62 100644
--- a/test/src/stdio/fgets_test.cpp
+++ b/test/src/stdio/fgets_test.cpp
@@ -15,7 +15,6 @@
 #include "test/UnitTest/Test.h"
 
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 TEST(LlvmLibcFgetsTest, WriteAndReadCharacters) {
   constexpr char FILENAME[] = "testdata/fgets.test";
@@ -43,6 +42,8 @@ TEST(LlvmLibcFgetsTest, WriteAndReadCharacters) {
   file = LIBC_NAMESPACE::fopen(FILENAME, "r");
   ASSERT_FALSE(file == nullptr);
 
+  // The GPU build relies on the host C library, so this check may be different.
+#ifndef LIBC_TARGET_ARCH_IS_GPU
   // If we request just 1 byte, it should return just a null byte and not
   // advance the read head. This is implementation defined.
   output = LIBC_NAMESPACE::fgets(buff, 1, file);
@@ -54,6 +55,7 @@ TEST(LlvmLibcFgetsTest, WriteAndReadCharacters) {
   // This is also implementation defined.
   output = LIBC_NAMESPACE::fgets(buff, 0, file);
   ASSERT_TRUE(output == nullptr);
+#endif
 
   const char *output_arr[] = {
       "1234567", "89\n", "1234567", "\n", "123456\n", "1",
diff --git a/test/src/stdio/fileop_test.cpp b/test/src/stdio/fileop_test.cpp
index 0fbe19c..98ead6e 100644
--- a/test/src/stdio/fileop_test.cpp
+++ b/test/src/stdio/fileop_test.cpp
@@ -20,8 +20,8 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
+#include "hdr/stdio_macros.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::EQ;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::NE;
diff --git a/test/src/stdio/fopencookie_test.cpp b/test/src/stdio/fopencookie_test.cpp
index 6c86b87..61ce2a2 100644
--- a/test/src/stdio/fopencookie_test.cpp
+++ b/test/src/stdio/fopencookie_test.cpp
@@ -18,9 +18,9 @@
 #include "test/UnitTest/MemoryMatcher.h"
 #include "test/UnitTest/Test.h"
 
+#include "hdr/stdio_macros.h"
+#include "hdr/types/size_t.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
-#include <stdlib.h>
 
 using MemoryView = LIBC_NAMESPACE::testing::MemoryView;
 
diff --git a/test/src/stdio/fprintf_test.cpp b/test/src/stdio/fprintf_test.cpp
index 08b3179..82a3e03 100644
--- a/test/src/stdio/fprintf_test.cpp
+++ b/test/src/stdio/fprintf_test.cpp
@@ -17,8 +17,6 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 namespace printf_test {
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 using LIBC_NAMESPACE::fclose;
diff --git a/test/src/stdio/fscanf_test.cpp b/test/src/stdio/fscanf_test.cpp
index 7010907..e5b8c4f 100644
--- a/test/src/stdio/fscanf_test.cpp
+++ b/test/src/stdio/fscanf_test.cpp
@@ -19,8 +19,6 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 namespace scanf_test {
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 using LIBC_NAMESPACE::fclose;
diff --git a/test/src/stdio/ftell_test.cpp b/test/src/stdio/ftell_test.cpp
index 62745e2..01ff071 100644
--- a/test/src/stdio/ftell_test.cpp
+++ b/test/src/stdio/ftell_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/stdio_macros.h"
 #include "src/stdio/fclose.h"
 #include "src/stdio/fopen.h"
 #include "src/stdio/fread.h"
@@ -17,8 +18,6 @@
 #include "src/stdio/setvbuf.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 class LlvmLibcFTellTest : public LIBC_NAMESPACE::testing::Test {
 protected:
   void test_with_bufmode(int bufmode) {
diff --git a/test/src/stdio/printf_core/parser_test.cpp b/test/src/stdio/printf_core/parser_test.cpp
index 66d6dd0..c277b30 100644
--- a/test/src/stdio/printf_core/parser_test.cpp
+++ b/test/src/stdio/printf_core/parser_test.cpp
@@ -316,6 +316,47 @@ TEST(LlvmLibcPrintfParserTest, EvalThreeArgs) {
   ASSERT_PFORMAT_EQ(expected2, format_arr[2]);
 }
 
+TEST(LlvmLibcPrintfParserTest, EvalOneArgWithOverflowingWidthAndPrecision) {
+  LIBC_NAMESPACE::printf_core::FormatSection format_arr[10];
+  const char *str = "%-999999999999.999999999999d";
+  int arg1 = 12345;
+  evaluate(format_arr, str, arg1);
+
+  LIBC_NAMESPACE::printf_core::FormatSection expected;
+  expected.has_conv = true;
+
+  expected.raw_string = {str, 28};
+  expected.flags = LIBC_NAMESPACE::printf_core::FormatFlags::LEFT_JUSTIFIED;
+  expected.min_width = INT_MAX;
+  expected.precision = INT_MAX;
+  expected.conv_val_raw = arg1;
+  expected.conv_name = 'd';
+
+  ASSERT_PFORMAT_EQ(expected, format_arr[0]);
+}
+
+TEST(LlvmLibcPrintfParserTest,
+     EvalOneArgWithOverflowingWidthAndPrecisionAsArgs) {
+  LIBC_NAMESPACE::printf_core::FormatSection format_arr[10];
+  const char *str = "%*.*d";
+  int arg1 = INT_MIN; // INT_MIN = -2147483648 if int is 32 bits.
+  int arg2 = INT_MIN;
+  int arg3 = 12345;
+  evaluate(format_arr, str, arg1, arg2, arg3);
+
+  LIBC_NAMESPACE::printf_core::FormatSection expected;
+  expected.has_conv = true;
+
+  expected.raw_string = {str, 5};
+  expected.flags = LIBC_NAMESPACE::printf_core::FormatFlags::LEFT_JUSTIFIED;
+  expected.min_width = INT_MAX;
+  expected.precision = arg2;
+  expected.conv_val_raw = arg3;
+  expected.conv_name = 'd';
+
+  ASSERT_PFORMAT_EQ(expected, format_arr[0]);
+}
+
 #ifndef LIBC_COPT_PRINTF_DISABLE_INDEX_MODE
 
 TEST(LlvmLibcPrintfParserTest, IndexModeOneArg) {
diff --git a/test/src/stdio/putc_test.cpp b/test/src/stdio/putc_test.cpp
index 7349a97..e881a0e 100644
--- a/test/src/stdio/putc_test.cpp
+++ b/test/src/stdio/putc_test.cpp
@@ -15,8 +15,6 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 TEST(LlvmLibcPutcTest, WriteToFile) {
   constexpr char FILENAME[] = "testdata/putc_output.test";
   ::FILE *file = LIBC_NAMESPACE::fopen(FILENAME, "w");
diff --git a/test/src/stdio/scanf_core/converter_test.cpp b/test/src/stdio/scanf_core/converter_test.cpp
index c760deb..d1aecd4 100644
--- a/test/src/stdio/scanf_core/converter_test.cpp
+++ b/test/src/stdio/scanf_core/converter_test.cpp
@@ -10,13 +10,12 @@
 #include "src/stdio/scanf_core/converter.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
-#include "src/stdio/scanf_core/string_reader.h"
 
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcScanfConverterTest, RawMatchBasic) {
   const char *str = "abcdef";
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   // Reading "abc" should succeed.
@@ -52,7 +51,7 @@ TEST(LlvmLibcScanfConverterTest, RawMatchBasic) {
 
 TEST(LlvmLibcScanfConverterTest, RawMatchSpaces) {
   const char *str = " a \t\n b   cd";
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   // Reading "a" should fail and not advance.
@@ -99,7 +98,7 @@ TEST(LlvmLibcScanfConverterTest, RawMatchSpaces) {
 TEST(LlvmLibcScanfConverterTest, StringConvSimple) {
   const char *str = "abcDEF123 654LKJihg";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
@@ -121,7 +120,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvSimple) {
 
 TEST(LlvmLibcScanfConverterTest, StringConvNoWrite) {
   const char *str = "abcDEF123 654LKJihg";
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
@@ -142,7 +141,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvNoWrite) {
 TEST(LlvmLibcScanfConverterTest, StringConvWidth) {
   const char *str = "abcDEF123 654LKJihg";
   char result[6];
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
@@ -176,7 +175,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvWidth) {
 TEST(LlvmLibcScanfConverterTest, CharsConv) {
   const char *str = "abcDEF123 654LKJihg MNOpqr&*(";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
@@ -231,7 +230,7 @@ TEST(LlvmLibcScanfConverterTest, CharsConv) {
 TEST(LlvmLibcScanfConverterTest, ScansetConv) {
   const char *str = "abcDEF[123] 654LKJihg";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::StringReader str_reader(str);
+  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
   LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
diff --git a/test/src/stdio/setbuf_test.cpp b/test/src/stdio/setbuf_test.cpp
index b0abca4..25fea59 100644
--- a/test/src/stdio/setbuf_test.cpp
+++ b/test/src/stdio/setbuf_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/stdio_macros.h"
 #include "src/stdio/fclose.h"
 #include "src/stdio/fopen.h"
 #include "src/stdio/fread.h"
@@ -14,8 +15,6 @@
 #include "src/stdio/ungetc.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 TEST(LlvmLibcSetbufTest, DefaultBufsize) {
   // The idea in this test is to change the buffer after opening a file and
   // ensure that read and write work as expected.
diff --git a/test/src/stdio/setvbuf_test.cpp b/test/src/stdio/setvbuf_test.cpp
index d42ebac..a1e1fee 100644
--- a/test/src/stdio/setvbuf_test.cpp
+++ b/test/src/stdio/setvbuf_test.cpp
@@ -13,8 +13,8 @@
 #include "src/stdio/setvbuf.h"
 #include "test/UnitTest/Test.h"
 
+#include "hdr/stdio_macros.h"
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 TEST(LlvmLibcSetvbufTest, SetNBFBuffer) {
   // The idea in this test is that we open a file for writing and reading, and
diff --git a/test/src/stdio/snprintf_test.cpp b/test/src/stdio/snprintf_test.cpp
index d898f2b..baaa664 100644
--- a/test/src/stdio/snprintf_test.cpp
+++ b/test/src/stdio/snprintf_test.cpp
@@ -41,6 +41,9 @@ TEST(LlvmLibcSNPrintfTest, CutOff) {
   // passing null as the output pointer is allowed as long as buffsz is 0.
   written = LIBC_NAMESPACE::snprintf(nullptr, 0, "%s and more", "1234567890");
   EXPECT_EQ(written, 19);
+
+  written = LIBC_NAMESPACE::snprintf(nullptr, 0, "%*s", INT_MIN, "nothing");
+  EXPECT_EQ(written, INT_MAX);
 }
 
 TEST(LlvmLibcSNPrintfTest, NoCutOff) {
diff --git a/test/src/stdio/sprintf_test.cpp b/test/src/stdio/sprintf_test.cpp
index 8e9870f..e8303ff 100644
--- a/test/src/stdio/sprintf_test.cpp
+++ b/test/src/stdio/sprintf_test.cpp
@@ -6,9 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include "src/stdio/sprintf.h"
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/errno/libc_errno.h"
 #include "test/UnitTest/RoundingModeUtils.h"
 #include "test/UnitTest/Test.h"
 #include <inttypes.h>
@@ -16,16 +18,10 @@
 // TODO: Add a comment here explaining the printf format string.
 
 // #include <stdio.h>
-// namespace LIBC_NAMESPACE {
+// namespace LIBC_NAMESPACE_DECL {
 // using ::sprintf;
 // }
 
-class LlvmLibcSPrintfTest : public LIBC_NAMESPACE::testing::Test {
-protected:
-  char buff[1000];
-  int written;
-};
-
 using LIBC_NAMESPACE::fputil::testing::ForceRoundingMode;
 using LIBC_NAMESPACE::fputil::testing::RoundingMode;
 
@@ -39,18 +35,19 @@ using LIBC_NAMESPACE::fputil::testing::RoundingMode;
     for (char &c : buff) {                                                     \
       c = 0;                                                                   \
     }                                                                          \
-    LIBC_NAMESPACE::sprintf(buff, "%" FMT, X);                                 \
-    ASSERT_STREQ(buff, expected);                                              \
+    written = LIBC_NAMESPACE::sprintf(buff, "%" FMT, X);                       \
+    ASSERT_STREQ_LEN(written, buff, expected);                                 \
   } while (0)
 
 TEST(LlvmLibcSPrintfTest, Macros) {
   char buff[128];
+  int written;
   macro_test(PRIu8, 1, "1");
   macro_test(PRIX16, 0xAA, "AA");
   macro_test(PRId32, -123, "-123");
   macro_test(PRIX32, 0xFFFFFF85, "FFFFFF85");
   macro_test(PRIo8, 0xFF, "377");
-  macro_test(PRIo64, 0123, "123");
+  macro_test(PRIo64, 0123456712345671234567ll, "123456712345671234567");
 }
 
 TEST(LlvmLibcSPrintfTest, SimpleNoConv) {
@@ -59,8 +56,7 @@ TEST(LlvmLibcSPrintfTest, SimpleNoConv) {
 
   written =
       LIBC_NAMESPACE::sprintf(buff, "A simple string with no conversions.");
-  EXPECT_EQ(written, 36);
-  ASSERT_STREQ(buff, "A simple string with no conversions.");
+  ASSERT_STREQ_LEN(written, buff, "A simple string with no conversions.");
 }
 
 TEST(LlvmLibcSPrintfTest, PercentConv) {
@@ -68,16 +64,13 @@ TEST(LlvmLibcSPrintfTest, PercentConv) {
   int written;
 
   written = LIBC_NAMESPACE::sprintf(buff, "%%");
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "%");
+  ASSERT_STREQ_LEN(written, buff, "%");
 
   written = LIBC_NAMESPACE::sprintf(buff, "abc %% def");
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "abc % def");
+  ASSERT_STREQ_LEN(written, buff, "abc % def");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%%%%%%");
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "%%%");
+  ASSERT_STREQ_LEN(written, buff, "%%%");
 }
 
 TEST(LlvmLibcSPrintfTest, CharConv) {
@@ -85,16 +78,13 @@ TEST(LlvmLibcSPrintfTest, CharConv) {
   int written;
 
   written = LIBC_NAMESPACE::sprintf(buff, "%c", 'a');
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "a");
+  ASSERT_STREQ_LEN(written, buff, "a");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%3c %-3c", '1', '2');
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  1 2  ");
+  ASSERT_STREQ_LEN(written, buff, "  1 2  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%*c", 2, '3');
-  EXPECT_EQ(written, 2);
-  ASSERT_STREQ(buff, " 3");
+  ASSERT_STREQ_LEN(written, buff, " 3");
 }
 
 TEST(LlvmLibcSPrintfTest, StringConv) {
@@ -102,27 +92,22 @@ TEST(LlvmLibcSPrintfTest, StringConv) {
   int written;
 
   written = LIBC_NAMESPACE::sprintf(buff, "%s", "abcDEF123");
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "abcDEF123");
+  ASSERT_STREQ_LEN(written, buff, "abcDEF123");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10s %-10s", "centered", "title");
-  EXPECT_EQ(written, 21);
-  ASSERT_STREQ(buff, "  centered title     ");
+  ASSERT_STREQ_LEN(written, buff, "  centered title     ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5.4s%-4.4s", "words can describe",
                                     "soups most delicious");
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "word soup");
+  ASSERT_STREQ_LEN(written, buff, "word soup");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%*s %.*s %*.*s", 10, "beginning", 2,
                                     "isn't", 12, 10, "important. Ever.");
-  EXPECT_EQ(written, 26);
-  ASSERT_STREQ(buff, " beginning is   important.");
+  ASSERT_STREQ_LEN(written, buff, " beginning is   important.");
 
 #ifndef LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
   written = LIBC_NAMESPACE::sprintf(buff, "%s", nullptr);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "(null)");
+  ASSERT_STREQ_LEN(written, buff, "(null)");
 #endif // LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
 }
 
@@ -133,73 +118,57 @@ TEST(LlvmLibcSPrintfTest, IntConv) {
   // Basic Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%d", 123);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "123");
+  ASSERT_STREQ_LEN(written, buff, "123");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%i", -456);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "-456");
+  ASSERT_STREQ_LEN(written, buff, "-456");
 
   // Length Modifier Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%hhu", 257); // 0x101
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "1");
+  ASSERT_STREQ_LEN(written, buff, "1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%llu", 18446744073709551615ull);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "18446744073709551615"); // ull max
+  ASSERT_STREQ_LEN(written, buff, "18446744073709551615"); // ull max
 
   written = LIBC_NAMESPACE::sprintf(buff, "%u", ~0);
   if (sizeof(int) == 4) {
-    EXPECT_EQ(written, 10);
-    ASSERT_STREQ(buff, "4294967295");
+    ASSERT_STREQ_LEN(written, buff, "4294967295");
   }
 
   written = LIBC_NAMESPACE::sprintf(buff, "%tu", ~ptrdiff_t(0));
   if (sizeof(ptrdiff_t) == 8) {
-    EXPECT_EQ(written, 20);
-    ASSERT_STREQ(buff, "18446744073709551615");
+    ASSERT_STREQ_LEN(written, buff, "18446744073709551615");
   } else if (sizeof(ptrdiff_t) == 4) {
-    EXPECT_EQ(written, 10);
-    ASSERT_STREQ(buff, "4294967295");
+    ASSERT_STREQ_LEN(written, buff, "4294967295");
   }
 
   written = LIBC_NAMESPACE::sprintf(buff, "%lld", -9223372036854775807ll - 1ll);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "-9223372036854775808"); // ll min
+  ASSERT_STREQ_LEN(written, buff, "-9223372036854775808"); // ll min
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w3d", 5807);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "7");
+  ASSERT_STREQ_LEN(written, buff, "7");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w3d", 1);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "1");
+  ASSERT_STREQ_LEN(written, buff, "1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w64d", 9223372036854775807ll);
-  EXPECT_EQ(written, 19);
-  ASSERT_STREQ(buff, "9223372036854775807");
+  ASSERT_STREQ_LEN(written, buff, "9223372036854775807");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w-1d", 5807);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "%w-1d");
+  ASSERT_STREQ_LEN(written, buff, "%w-1d");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w0d", 5807);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "%w0d");
+  ASSERT_STREQ_LEN(written, buff, "%w0d");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w999d", 9223372036854775807ll);
-  EXPECT_EQ(written, 19);
-  ASSERT_STREQ(buff, "9223372036854775807");
+  ASSERT_STREQ_LEN(written, buff, "9223372036854775807");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%winvalid%w1d", 5807, 5807);
-  EXPECT_EQ(written, 10);
-  ASSERT_STREQ(buff, "%winvalid1");
+  ASSERT_STREQ_LEN(written, buff, "%winvalid1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w-1d%w1d", 5807, 5807);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "%w-1d1");
+  ASSERT_STREQ_LEN(written, buff, "%w-1d1");
 
   char format[64];
   char uintmax[128];
@@ -211,157 +180,122 @@ TEST(LlvmLibcSPrintfTest, IntConv) {
   ASSERT_STREQ(buff, uintmax);
 
   written = LIBC_NAMESPACE::sprintf(buff, "%w64u", 18446744073709551615ull);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "18446744073709551615"); // ull max
+  ASSERT_STREQ_LEN(written, buff, "18446744073709551615"); // ull max
 
   written =
       LIBC_NAMESPACE::sprintf(buff, "%w64d", -9223372036854775807ll - 1ll);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "-9223372036854775808"); // ll min
+  ASSERT_STREQ_LEN(written, buff, "-9223372036854775808"); // ll min
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf3d", 5807);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "7");
+  ASSERT_STREQ_LEN(written, buff, "7");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf3d", 1);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "1");
+  ASSERT_STREQ_LEN(written, buff, "1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf64u", 18446744073709551615ull);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "18446744073709551615"); // ull max
+  ASSERT_STREQ_LEN(written, buff, "18446744073709551615"); // ull max
 
   written =
       LIBC_NAMESPACE::sprintf(buff, "%wf64d", -9223372036854775807ll - 1ll);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "-9223372036854775808"); // ll min
+  ASSERT_STREQ_LEN(written, buff, "-9223372036854775808"); // ll min
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf0d", 5807);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "%wf0d");
+  ASSERT_STREQ_LEN(written, buff, "%wf0d");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf-1d", 5807);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "%wf-1d");
+  ASSERT_STREQ_LEN(written, buff, "%wf-1d");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wfinvalid%wf1d", 5807, 5807);
-  EXPECT_EQ(written, 11);
-  ASSERT_STREQ(buff, "%wfinvalid1");
+  ASSERT_STREQ_LEN(written, buff, "%wfinvalid1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf-1d%wf1d", 5807, 5807);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "%wf-1d1");
+  ASSERT_STREQ_LEN(written, buff, "%wf-1d1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%wf999d", 9223372036854775807ll);
-  EXPECT_EQ(written, 19);
-  ASSERT_STREQ(buff, "9223372036854775807");
+  ASSERT_STREQ_LEN(written, buff, "9223372036854775807");
 
   // Min Width Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%4d", 789);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, " 789");
+  ASSERT_STREQ_LEN(written, buff, " 789");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%2d", 987);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "987");
+  ASSERT_STREQ_LEN(written, buff, "987");
 
   // Precision Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%d", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.0d", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5d", 654);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00654");
+  ASSERT_STREQ_LEN(written, buff, "00654");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5d", -321);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "-00321");
+  ASSERT_STREQ_LEN(written, buff, "-00321");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.2d", 135);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "135");
+  ASSERT_STREQ_LEN(written, buff, "135");
 
   // Flag Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5d", -321);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "-00321");
+  ASSERT_STREQ_LEN(written, buff, "-00321");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5d", 246);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "246  ");
+  ASSERT_STREQ_LEN(written, buff, "246  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5d", -147);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "-147 ");
+  ASSERT_STREQ_LEN(written, buff, "-147 ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%+d", 258);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "+258");
+  ASSERT_STREQ_LEN(written, buff, "+258");
 
   written = LIBC_NAMESPACE::sprintf(buff, "% d", 369);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, " 369");
+  ASSERT_STREQ_LEN(written, buff, " 369");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%05d", 470);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00470");
+  ASSERT_STREQ_LEN(written, buff, "00470");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%05d", -581);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "-0581");
+  ASSERT_STREQ_LEN(written, buff, "-0581");
 
   // Combined Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%+ u", 692);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "692");
+  ASSERT_STREQ_LEN(written, buff, "692");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%+ -05d", 703);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "+703 ");
+  ASSERT_STREQ_LEN(written, buff, "+703 ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5d", 814);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  00814");
+  ASSERT_STREQ_LEN(written, buff, "  00814");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5d", -925);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, " -00925");
+  ASSERT_STREQ_LEN(written, buff, " -00925");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5d", 159);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  00159");
+  ASSERT_STREQ_LEN(written, buff, "  00159");
 
   written = LIBC_NAMESPACE::sprintf(buff, "% -7.5d", 260);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, " 00260 ");
+  ASSERT_STREQ_LEN(written, buff, " 00260 ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%5.4d", 10000);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "10000");
+  ASSERT_STREQ_LEN(written, buff, "10000");
 
   // Multiple Conversion Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10d %-10d", 456, -789);
-  EXPECT_EQ(written, 21);
-  ASSERT_STREQ(buff, "       456 -789      ");
+  ASSERT_STREQ_LEN(written, buff, "       456 -789      ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5.4d%+.4u", 75, 25);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "0075 0025");
+  ASSERT_STREQ_LEN(written, buff, "0075 0025");
 
   written = LIBC_NAMESPACE::sprintf(buff, "% 05hhi %+-0.5llu %-+ 06.3zd",
                                     256 + 127, 68719476736ll, size_t(2));
-  EXPECT_EQ(written, 24);
-  ASSERT_STREQ(buff, " 0127 68719476736 +002  ");
+  ASSERT_STREQ_LEN(written, buff, " 0127 68719476736 +002  ");
 }
 
 TEST(LlvmLibcSPrintfTest, HexConv) {
@@ -371,130 +305,102 @@ TEST(LlvmLibcSPrintfTest, HexConv) {
   // Basic Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%x", 0x123a);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "123a");
+  ASSERT_STREQ_LEN(written, buff, "123a");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%X", 0x456b);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "456B");
+  ASSERT_STREQ_LEN(written, buff, "456B");
 
   // Length Modifier Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%hhx", 0x10001);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "1");
+  ASSERT_STREQ_LEN(written, buff, "1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%llx", 0xffffffffffffffffull);
-  EXPECT_EQ(written, 16);
-  ASSERT_STREQ(buff, "ffffffffffffffff"); // ull max
+  ASSERT_STREQ_LEN(written, buff, "ffffffffffffffff"); // ull max
 
   written = LIBC_NAMESPACE::sprintf(buff, "%tX", ~ptrdiff_t(0));
   if (sizeof(ptrdiff_t) == 8) {
-    EXPECT_EQ(written, 16);
-    ASSERT_STREQ(buff, "FFFFFFFFFFFFFFFF");
+    ASSERT_STREQ_LEN(written, buff, "FFFFFFFFFFFFFFFF");
   } else if (sizeof(ptrdiff_t) == 4) {
-    EXPECT_EQ(written, 8);
-    ASSERT_STREQ(buff, "FFFFFFFF");
+    ASSERT_STREQ_LEN(written, buff, "FFFFFFFF");
   }
 
   // Min Width Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%4x", 0x789);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, " 789");
+  ASSERT_STREQ_LEN(written, buff, " 789");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%2X", 0x987);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "987");
+  ASSERT_STREQ_LEN(written, buff, "987");
 
   // Precision Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%x", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.0x", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5x", 0x1F3);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "001f3");
+  ASSERT_STREQ_LEN(written, buff, "001f3");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.2x", 0x135);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "135");
+  ASSERT_STREQ_LEN(written, buff, "135");
 
   // Flag Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5x", 0x246);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "246  ");
+  ASSERT_STREQ_LEN(written, buff, "246  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#x", 0xd3f);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "0xd3f");
+  ASSERT_STREQ_LEN(written, buff, "0xd3f");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#x", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#X", 0xE40);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "0XE40");
+  ASSERT_STREQ_LEN(written, buff, "0XE40");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%05x", 0x470);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00470");
+  ASSERT_STREQ_LEN(written, buff, "00470");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%0#6x", 0x8c3);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "0x08c3");
+  ASSERT_STREQ_LEN(written, buff, "0x08c3");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-#6x", 0x5f0);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "0x5f0 ");
+  ASSERT_STREQ_LEN(written, buff, "0x5f0 ");
 
   // Combined Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#-07x", 0x703);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "0x703  ");
+  ASSERT_STREQ_LEN(written, buff, "0x703  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5x", 0x814);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  00814");
+  ASSERT_STREQ_LEN(written, buff, "  00814");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#9.5X", 0x9d4);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "  0X009D4");
+  ASSERT_STREQ_LEN(written, buff, "  0X009D4");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#.x", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-7.5x", 0x260);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "00260  ");
+  ASSERT_STREQ_LEN(written, buff, "00260  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%5.4x", 0x10000);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "10000");
+  ASSERT_STREQ_LEN(written, buff, "10000");
 
   // Multiple Conversion Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10X %-#10x", 0x45b, 0x789);
-  EXPECT_EQ(written, 21);
-  ASSERT_STREQ(buff, "       45B 0x789     ");
+  ASSERT_STREQ_LEN(written, buff, "       45B 0x789     ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5.4x%#.4x", 0x75, 0x25);
-  EXPECT_EQ(written, 11);
-  ASSERT_STREQ(buff, "0075 0x0025");
+  ASSERT_STREQ_LEN(written, buff, "0075 0x0025");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%04hhX %#.5llx %-6.3zX", 256 + 0x7f,
                                     0x1000000000ll, size_t(2));
-  EXPECT_EQ(written, 24);
-  ASSERT_STREQ(buff, "007F 0x1000000000 002   ");
+  ASSERT_STREQ_LEN(written, buff, "007F 0x1000000000 002   ");
 }
 
 TEST(LlvmLibcSPrintfTest, BinConv) {
@@ -504,110 +410,86 @@ TEST(LlvmLibcSPrintfTest, BinConv) {
   // Basic Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%b", 42);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "101010");
+  ASSERT_STREQ_LEN(written, buff, "101010");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%B", 12081991);
-  EXPECT_EQ(written, 24);
-  ASSERT_STREQ(buff, "101110000101101101000111");
+  ASSERT_STREQ_LEN(written, buff, "101110000101101101000111");
 
   // Min Width Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10b", 0b101010);
-  EXPECT_EQ(written, 10);
-  ASSERT_STREQ(buff, "    101010");
+  ASSERT_STREQ_LEN(written, buff, "    101010");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%2B", 0b101010);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "101010");
+  ASSERT_STREQ_LEN(written, buff, "101010");
 
   // Precision Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%b", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.0b", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5b", 0b111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00111");
+  ASSERT_STREQ_LEN(written, buff, "00111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.2b", 0b111);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "111");
+  ASSERT_STREQ_LEN(written, buff, "111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%3b", 0b111);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "111");
+  ASSERT_STREQ_LEN(written, buff, "111");
 
   // Flag Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5b", 0b111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "111  ");
+  ASSERT_STREQ_LEN(written, buff, "111  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#b", 0b111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "0b111");
+  ASSERT_STREQ_LEN(written, buff, "0b111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#b", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#B", 0b111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "0B111");
+  ASSERT_STREQ_LEN(written, buff, "0B111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%05b", 0b111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00111");
+  ASSERT_STREQ_LEN(written, buff, "00111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%0#6b", 0b111);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "0b0111");
+  ASSERT_STREQ_LEN(written, buff, "0b0111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-#6b", 0b111);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "0b111 ");
+  ASSERT_STREQ_LEN(written, buff, "0b111 ");
 
   // Combined Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#-07b", 0b111);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "0b111  ");
+  ASSERT_STREQ_LEN(written, buff, "0b111  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5b", 0b111);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  00111");
+  ASSERT_STREQ_LEN(written, buff, "  00111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#9.5B", 0b111);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "  0B00111");
+  ASSERT_STREQ_LEN(written, buff, "  0B00111");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#.b", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-7.5b", 0b111);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "00111  ");
+  ASSERT_STREQ_LEN(written, buff, "00111  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%5.4b", 0b1111);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, " 1111");
+  ASSERT_STREQ_LEN(written, buff, " 1111");
 
   // Multiple Conversion Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10B %-#10b", 0b101, 0b110);
-  EXPECT_EQ(written, 21);
-  ASSERT_STREQ(buff, "       101 0b110     ");
+  ASSERT_STREQ_LEN(written, buff, "       101 0b110     ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5.4b%#.4b", 0b101, 0b110);
-  EXPECT_EQ(written, 11);
-  ASSERT_STREQ(buff, "0101 0b0110");
+  ASSERT_STREQ_LEN(written, buff, "0101 0b0110");
 }
 
 TEST(LlvmLibcSPrintfTest, PointerConv) {
@@ -615,61 +497,51 @@ TEST(LlvmLibcSPrintfTest, PointerConv) {
   int written;
 
   written = LIBC_NAMESPACE::sprintf(buff, "%p", nullptr);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "(nullptr)");
+  ASSERT_STREQ_LEN(written, buff, "(nullptr)");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%p", 0x1a2b3c4d);
-  EXPECT_EQ(written, 10);
-  ASSERT_STREQ(buff, "0x1a2b3c4d");
+  ASSERT_STREQ_LEN(written, buff, "0x1a2b3c4d");
 
   if constexpr (sizeof(void *) > 4) {
     written = LIBC_NAMESPACE::sprintf(buff, "%p", 0x1a2b3c4d5e6f7081);
-    EXPECT_EQ(written, 18);
-    ASSERT_STREQ(buff, "0x1a2b3c4d5e6f7081");
+    ASSERT_STREQ_LEN(written, buff, "0x1a2b3c4d5e6f7081");
   }
 
-  written = LIBC_NAMESPACE::sprintf(buff, "%p", buff);
+  written = LIBC_NAMESPACE::sprintf(buff, "%p", &written);
   EXPECT_GT(written, 0);
 
   // Width tests:
 
   written = LIBC_NAMESPACE::sprintf(buff, "%20p", nullptr);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "           (nullptr)");
+  ASSERT_STREQ_LEN(written, buff, "           (nullptr)");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%20p", 0x1a2b3c4d);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "          0x1a2b3c4d");
+  ASSERT_STREQ_LEN(written, buff, "          0x1a2b3c4d");
 
   // Flag tests:
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-20p", nullptr);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "(nullptr)           ");
+  ASSERT_STREQ_LEN(written, buff, "(nullptr)           ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-20p", 0x1a2b3c4d);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "0x1a2b3c4d          ");
+  ASSERT_STREQ_LEN(written, buff, "0x1a2b3c4d          ");
 
   // Using the 0 flag is technically undefined, but here we're following the
   // convention of matching the behavior of %#x.
   written = LIBC_NAMESPACE::sprintf(buff, "%020p", 0x1a2b3c4d);
-  EXPECT_EQ(written, 20);
-  ASSERT_STREQ(buff, "0x00000000001a2b3c4d");
+  ASSERT_STREQ_LEN(written, buff, "0x00000000001a2b3c4d");
 
   // Precision tests:
   // These are all undefined behavior. The precision option is undefined for %p.
 
   // Precision specifies the number of characters for a string conversion.
   written = LIBC_NAMESPACE::sprintf(buff, "%.5p", nullptr);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "(null");
+  ASSERT_STREQ_LEN(written, buff, "(null");
 
   // Precision specifies the number of digits to be written for %x conversions,
   // and the "0x" doesn't count as part of the digits.
   written = LIBC_NAMESPACE::sprintf(buff, "%.20p", 0x1a2b3c4d);
-  EXPECT_EQ(written, 22);
-  ASSERT_STREQ(buff, "0x0000000000001a2b3c4d");
+  ASSERT_STREQ_LEN(written, buff, "0x0000000000001a2b3c4d");
 }
 
 TEST(LlvmLibcSPrintfTest, OctConv) {
@@ -679,131 +551,107 @@ TEST(LlvmLibcSPrintfTest, OctConv) {
   // Basic Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%o", 01234);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "1234");
+  ASSERT_STREQ_LEN(written, buff, "1234");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%o", 04567);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "4567");
+  ASSERT_STREQ_LEN(written, buff, "4567");
 
   // Length Modifier Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%hho", 0401);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "1");
+  ASSERT_STREQ_LEN(written, buff, "1");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%llo", 01777777777777777777777ull);
-  EXPECT_EQ(written, 22);
-  ASSERT_STREQ(buff, "1777777777777777777777"); // ull max
+  ASSERT_STREQ_LEN(written, buff, "1777777777777777777777"); // ull max
 
   written = LIBC_NAMESPACE::sprintf(buff, "%to", ~ptrdiff_t(0));
   if (sizeof(ptrdiff_t) == 8) {
-    EXPECT_EQ(written, 22);
-    ASSERT_STREQ(buff, "1777777777777777777777");
+    ASSERT_STREQ_LEN(written, buff, "1777777777777777777777");
   } else if (sizeof(ptrdiff_t) == 4) {
-    EXPECT_EQ(written, 11);
-    ASSERT_STREQ(buff, "37777777777");
+    ASSERT_STREQ_LEN(written, buff, "37777777777");
   }
 
   // Min Width Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%4o", 0701);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, " 701");
+  ASSERT_STREQ_LEN(written, buff, " 701");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%2o", 0107);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "107");
+  ASSERT_STREQ_LEN(written, buff, "107");
 
   // Precision Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%o", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.0o", 0);
-  EXPECT_EQ(written, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.5o", 0153);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00153");
+  ASSERT_STREQ_LEN(written, buff, "00153");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.2o", 0135);
-  EXPECT_EQ(written, 3);
-  ASSERT_STREQ(buff, "135");
+  ASSERT_STREQ_LEN(written, buff, "135");
 
   // Flag Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5o", 0246);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "246  ");
+  ASSERT_STREQ_LEN(written, buff, "246  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#o", 0234);
-  EXPECT_EQ(written, 4);
-  ASSERT_STREQ(buff, "0234");
+  ASSERT_STREQ_LEN(written, buff, "0234");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#o", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%05o", 0470);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "00470");
+  ASSERT_STREQ_LEN(written, buff, "00470");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%0#6o", 0753);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "000753");
+  ASSERT_STREQ_LEN(written, buff, "000753");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-#6o", 0642);
-  EXPECT_EQ(written, 6);
-  ASSERT_STREQ(buff, "0642  ");
+  ASSERT_STREQ_LEN(written, buff, "0642  ");
 
   // Combined Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#-07o", 0703);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "0703   ");
+  ASSERT_STREQ_LEN(written, buff, "0703   ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#.o", 0);
-  EXPECT_EQ(written, 1);
-  ASSERT_STREQ(buff, "0");
+  ASSERT_STREQ_LEN(written, buff, "0");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%7.5o", 0314);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "  00314");
+  ASSERT_STREQ_LEN(written, buff, "  00314");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%#9.5o", 0234);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "    00234");
+  ASSERT_STREQ_LEN(written, buff, "    00234");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-7.5o", 0260);
-  EXPECT_EQ(written, 7);
-  ASSERT_STREQ(buff, "00260  ");
+  ASSERT_STREQ_LEN(written, buff, "00260  ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%5.4o", 010000);
-  EXPECT_EQ(written, 5);
-  ASSERT_STREQ(buff, "10000");
+  ASSERT_STREQ_LEN(written, buff, "10000");
 
   // Multiple Conversion Tests.
 
   written = LIBC_NAMESPACE::sprintf(buff, "%10o %-#10o", 0456, 0123);
-  EXPECT_EQ(written, 21);
-  ASSERT_STREQ(buff, "       456 0123      ");
+  ASSERT_STREQ_LEN(written, buff, "       456 0123      ");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%-5.4o%#.4o", 075, 025);
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "0075 0025");
+  ASSERT_STREQ_LEN(written, buff, "0075 0025");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%04hho %#.5llo %-6.3zo", 256 + 077,
                                     01000000000000ll, size_t(2));
-  EXPECT_EQ(written, 26);
-  ASSERT_STREQ(buff, "0077 01000000000000 002   ");
+  ASSERT_STREQ_LEN(written, buff, "0077 01000000000000 002   ");
 }
 
 #ifndef LIBC_COPT_PRINTF_DISABLE_FLOAT
 
-TEST_F(LlvmLibcSPrintfTest, FloatHexExpConv) {
+TEST(LlvmLibcSPrintfTest, FloatHexExpConv) {
+  char buff[128];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
   double inf = LIBC_NAMESPACE::fputil::FPBits<double>::inf().get_val();
   double nan = LIBC_NAMESPACE::fputil::FPBits<double>::quiet_nan().get_val();
@@ -1167,7 +1015,10 @@ TEST_F(LlvmLibcSPrintfTest, FloatHexExpConv) {
       " 0x1.00000000000000000000000000000000000000000000000000p+0");
 }
 
-TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
+TEST(LlvmLibcSPrintfTest, FloatDecimalConv) {
+  char buff[1500];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
   double inf = LIBC_NAMESPACE::fputil::FPBits<double>::inf().get_val();
   double nan = LIBC_NAMESPACE::fputil::FPBits<double>::quiet_nan().get_val();
@@ -1176,9 +1027,6 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
   long double ld_nan =
       LIBC_NAMESPACE::fputil::FPBits<long double>::quiet_nan().get_val();
 
-  char big_buff[10000]; // Used for long doubles and other extremely wide
-                        // numbers.
-
   written = LIBC_NAMESPACE::sprintf(buff, "%f", 1.0);
   ASSERT_STREQ_LEN(written, buff, "1.000000");
 
@@ -1194,6 +1042,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%f", 1.5);
   ASSERT_STREQ_LEN(written, buff, "1.500000");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%f", 1e300);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -1202,6 +1051,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
       "218478670698284838720092657580373783023379478809005936895323497079994508"
       "111903896764088007465274278014249457925878882005684283811566947219638686"
       "5459400540160.000000");
+#endif // LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
 
   written = LIBC_NAMESPACE::sprintf(buff, "%f", 0.1);
   ASSERT_STREQ_LEN(written, buff, "0.100000");
@@ -1347,6 +1197,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%.9f", 1.9999999999999514);
   ASSERT_STREQ_LEN(written, buff, "2.000000000");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   // The number continues after the literal because floating point numbers can't
   // represent every value. The printed value is the closest value a double can
   // represent, rounded to the requested precision.
@@ -1358,14 +1209,15 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
       "131959884853339045938639911360973972585316399767392273697826861241937664"
       "824105639342441431495119762431744054912109728706985341609159156917030486"
       "5110665559768676757812");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.36f", 9.9e-77);
   ASSERT_STREQ_LEN(written, buff, "0.000000000000000000000000000000000000");
 
-  written =
-      LIBC_NAMESPACE::sprintf(big_buff, "%.1071f", 2.0226568751604562E-314);
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
+  written = LIBC_NAMESPACE::sprintf(buff, "%.1071f", 2.0226568751604562E-314);
   ASSERT_STREQ_LEN(
-      written, big_buff,
+      written, buff,
       "0."
       "000000000000000000000000000000000000000000000000000000000000000000000000"
       "000000000000000000000000000000000000000000000000000000000000000000000000"
@@ -1382,6 +1234,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
       "242480201291872969114441104973910102402751449901108484914924879541248714"
       "939096548775588293353689592872854495101242645279589976452453829724479805"
       "750016448075109469332839157162950982637994457036256790161132812");
+#endif
 
   // If no precision is specified it defaults to 6 for %f.
   written = LIBC_NAMESPACE::sprintf(buff, "%f", 2325885.4901960781);
@@ -1439,26 +1292,6 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
       "000000000000000000000000000000000000000000000000000000000000000000000000"
       "000000000000000000000000000000000004940656");
 
-  /*
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La", 0.1L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0xc.dp-7");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #endif
-
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La",
-  0xf.fffffffffffffffp16380L); #if
-  defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80) ASSERT_STREQ_LEN(written, buff,
-  "0x1.0p+16384"); #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "inf");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x2.0p+16383");
-  #endif
-  */
-
   // Rounding Mode Tests.
 
   if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
@@ -1682,11 +1515,11 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalConv) {
 
 // The long double tests are separated so that their performance can be directly
 // measured.
-TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
-  ForceRoundingMode r(RoundingMode::Nearest);
+TEST(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
+  char buff[1000];
+  int written;
 
-  char big_buff[10000]; // Used for long doubles and other extremely wide
-                        // numbers.
+  ForceRoundingMode r(RoundingMode::Nearest);
 
   // Length Modifier Tests.
 
@@ -1703,10 +1536,12 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
 
 #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 1e100L);
   ASSERT_STREQ_LEN(written, buff,
                    "99999999999999999996693535322073426194986990198284960792713"
                    "91541752018669482644324418977840117055488.000000");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 0xd.96ed1192687859ap-24L);
   ASSERT_STREQ_LEN(written, buff, "0.000001");
@@ -1714,6 +1549,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 10000000000000000.25L);
   ASSERT_STREQ_LEN(written, buff, "10000000000000000.250000");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.510Lf", 0x8p-503L);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -1726,6 +1562,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
       "948791366338993705251636497892270212003524508209121908744820211960149463"
       "721109340307985507678283651836204093399373959982767701148986816406250000"
       "000000");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.500Lf", -4327677766926336.0L);
   ASSERT_STREQ_LEN(
@@ -1739,6 +1576,9 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
       "000000000000000000000000000000000000000000000000000000000000000000000000"
       "00000000000000000000000000000000000000000000000000000000000000000000");
 
+  char big_buff[10000]; // Used for extremely wide numbers.
+
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(big_buff, "%Lf", 1e1000L);
   ASSERT_STREQ_LEN(
       written, big_buff,
@@ -1904,10 +1744,12 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
       "542411931794417513706468964386151771884986701034153254238591108962471088"
       "538580868883777725864856414593426212108664758848926003176234596076950884"
       "9149662444156604419552086811989770240.000000");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(big_buff, "%.10Lf", 1e-10L);
   ASSERT_STREQ_LEN(written, big_buff, "0.0000000001");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(big_buff, "%.7500Lf", 1e-4900L);
   ASSERT_STREQ_LEN(
       written, big_buff,
@@ -2017,10 +1859,14 @@ TEST_F(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
       "570449525088342437216896462077260223998756027453411520977536701491759878"
       "422771447006016890777855573925295187921971811871399320142563330377888532"
       "179817332113");
+#endif
 #endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
 }
 
-TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
+TEST(LlvmLibcSPrintfTest, FloatExponentConv) {
+  char buff[1000];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
   double inf = LIBC_NAMESPACE::fputil::FPBits<double>::inf().get_val();
   double nan = LIBC_NAMESPACE::fputil::FPBits<double>::quiet_nan().get_val();
@@ -2185,12 +2031,14 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%.0e", 9.059E+200);
   ASSERT_STREQ_LEN(written, buff, "9e+200");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.166e", 1.131959884853339E-72);
   ASSERT_STREQ_LEN(written, buff,
                    "1."
                    "13195988485333904593863991136097397258531639976739227369782"
                    "68612419376648241056393424414314951197624317440549121097287"
                    "069853416091591569170304865110665559768676757812e-72");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.0e", 9.5);
   ASSERT_STREQ_LEN(written, buff, "1e+01");
@@ -2209,6 +2057,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
 
   // Subnormal Precision Tests
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.310e", 0x1.0p-1022);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -2218,10 +2067,12 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
       "385377718821130777993532002330479610147442583636071921565046942503734208"
       "375250806650616658158948720491179968591639648500635908770118304874799780"
       "8877537499494515804516e-308");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.30e", 0x1.0p-1022);
   ASSERT_STREQ_LEN(written, buff, "2.225073858507201383090232717332e-308");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.310e", 0x1.0p-1023);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -2231,6 +2082,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
       "192688859410565388996766001165239805073721291818035960782523471251867104"
       "187625403325308329079474360245589984295819824250317954385059152437399890"
       "4438768749747257902258e-308");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.6e", 9.99999e-310);
   ASSERT_STREQ_LEN(written, buff, "9.999990e-310");
@@ -2256,26 +2108,6 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%.10e", 0x1.0p-1074);
   ASSERT_STREQ_LEN(written, buff, "4.9406564584e-324");
 
-  /*
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La", 0.1L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0xc.dp-7");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #endif
-
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La",
-  0xf.fffffffffffffffp16380L); #if
-  defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80) ASSERT_STREQ_LEN(written, buff,
-  "0x1.0p+16384"); #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "inf");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x2.0p+16383");
-  #endif
-  */
-
   // Rounding Mode Tests.
 
   if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
@@ -2506,128 +2338,44 @@ TEST_F(LlvmLibcSPrintfTest, FloatExponentConv) {
   ASSERT_STREQ_LEN(written, buff, "+1.256e-01    001.256e+03");
 }
 
-TEST_F(LlvmLibcSPrintfTest, FloatExponentLongDoubleConv) {
+TEST(LlvmLibcSPrintfTest, FloatExponentLongDoubleConv) {
+  char buff[1000];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
   // Length Modifier Tests.
 
-#if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
   written = LIBC_NAMESPACE::sprintf(buff, "%.9Le", 1000000000500000000.1L);
   ASSERT_STREQ_LEN(written, buff, "1.000000001e+18");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.9Le", 1000000000500000000.0L);
   ASSERT_STREQ_LEN(written, buff, "1.000000000e+18");
 
+  written = LIBC_NAMESPACE::sprintf(buff, "%Le", 1e100L);
+  ASSERT_STREQ_LEN(written, buff, "1.000000e+100");
+
+  written = LIBC_NAMESPACE::sprintf(buff, "%Le", 1.0L);
+  ASSERT_STREQ_LEN(written, buff, "1.000000e+00");
+
+#if !defined(LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE)
   written = LIBC_NAMESPACE::sprintf(buff, "%Le", 0xf.fffffffffffffffp+16380L);
   ASSERT_STREQ_LEN(written, buff, "1.189731e+4932");
-#endif
-
-  // TODO: Fix long doubles (needs bigger table or alternate algorithm.)
-  // Currently the table values are generated, which is very slow.
-  /*
-  written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 1e100L);
-  ASSERT_STREQ_LEN(written, buff,
-                   "99999999999999999996693535322073426194986990198284960792713"
-                   "91541752018669482644324418977840117055488.000000");
 
-  written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 1.0L);
-  ASSERT_STREQ_LEN(written, buff, "1.000000");
+  written = LIBC_NAMESPACE::sprintf(buff, "%Le", 1e1000L);
+  ASSERT_STREQ_LEN(written, buff, "1.000000e+1000");
 
-  char big_buff[10000];
-  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lf", 1e1000L);
-  ASSERT_STREQ_LEN(
-      written, big_buff,
-      "999999999999999999973107317669562353428234857594552594925899449376328728"
-      "202461036775511405481186963193066642191664822065529414252060696836533522"
-      "387143501724276282079456797058697369889056407118642873669166717313763499"
-      "277025985141177344925615052465165938514140943010597323750202561187880136"
-      "174810574553749194614479541820148407958204853833697063267336294787191005"
-      "628217462261955103745349844675732989944229689277833828743730290177882029"
-      "042613704915899149603539993716885598351951895974316347947147507970269673"
-      "097709017164643598452451201499004104341931127294141495501309305995449742"
-      "273419524803597130450457553871345958049837885085168840317195672271085085"
-      "950520957945970913451088104971436093671776829538796532762184174216651692"
-      "640931965387852083906784898823494867055070322768919156031682291829761007"
-      "101483799978382119231551218582499361996919560548090784230386907125151658"
-      "086767207295524036170321059257942621398084478974000973622199163292708506"
-      "2431457550909271560663602154947063707982236377366647567795879936."
-      "000000");
+  written = LIBC_NAMESPACE::sprintf(buff, "%Le", 1e4900L);
+  ASSERT_STREQ_LEN(written, buff, "1.000000e+4900");
 
-  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lf", 1e4900L);
-  ASSERT_STREQ_LEN(
-      written, big_buff,
-      "100000000000000000002708312230690349833224052504078834346502930111959028"
-      "517260692666637048230414374897655201843766090626319971729765251179632020"
-      "313912652522792711197087872698264530532442630109549129842736280196919130"
-      "242615101228133188193853826983121366159061148351354364472807590931218045"
-      "387490935930967150336231085015126034696883068553581691802388371635128003"
-      "615577299166097675723780877126495909902479233742826339471026068806070433"
-      "075629449530819183550315434973800271862658869400009022028602967197463980"
-      "126881829804282202449930132940824361207087494829502385835258094836304011"
-      "876250359661206802659650567866176246063987902366800491980400341950657151"
-      "370854446585517805253310195469184699955519312761482572080479702840420595"
-      "377369017651259376039167277822106875560385309101650382998482652792335482"
-      "865443482342801545877390859444282105890147577937366066315975231014810320"
-      "888482059656248277607763361589359794524314002443575149260630989130103550"
-      "443177966380769341050735632338583912575890190136462629316287947355057647"
-      "111088565611192544631519843618778618820046304429723908484879583579178075"
-      "456701368334212923379389029311286386996015804122917416008806233549005183"
-      "152461084266176543129004016414959261473645240454289630182591200574019087"
-      "358223489767381636349719510715487188747217311279465814538495924567014916"
-      "238565628036285599497236493491668884212847699052761266207598941300449276"
-      "447201387520841811835583254242213093566548778954711633721122784159793843"
-      "766802019309395771984693609426401362800013936338891483689127845928572536"
-      "790651156184721483511507878883282891696900630100211914227950790472211403"
-      "392549466062537498185758854079775888444518306635752468713312357556380082"
-      "275500658967283696421824354930077523691855699312544373220921962817907078"
-      "445538421941800259027487429330768616490865438859612697367766323925013940"
-      "918384858952407145253573823848733994146335416209309233074165707437420756"
-      "438833918763109580759409985573826485055208965115587885226774453455112406"
-      "581351429640282227888764449360534584421929291565334894907337572527922691"
-      "473242328379737396430908523008687037407295838014450772162091496534584696"
-      "605157436893236842602956298545594095307060870397506421786236892553632163"
-      "491468601982681381011940409602294892199042638682530687578982576819839451"
-      "907594697546439533559153604700750696252355362322662219852740143212566818"
-      "745528402265116534684566273868361460640280523251242059850044328669692159"
-      "629900374576027104298177006629276014371540945261309319363704125592775129"
-      "543526908667388673739382491147471395192495459318806593271282662311169392"
-      "196897003517840025298267505925987901751541005546610016067658227181318892"
-      "914686508281007582655667597441346214499847364272258631922040641860333431"
-      "409838623713258383681350233064164940590695888300919626215847587544298023"
-      "636416943680102708406086295669759876682046839368574433996997648445207805"
-      "615784339667691231286807666753972942872019850432610318031627872612657513"
-      "588188267160616660825719678199868371370527508463011236193719286066916786"
-      "169956541349011494927225747024994619057884118692213564790598702879596058"
-      "672338334720925179141906809470606964896245458600635183723159228561689808"
-      "246141482736625197373238197777325580142168245885279594913851700941789475"
-      "252421784152262567254611571822468808675893407728003047921107885664474662"
-      "930921581384003950729114103689170603748380178682003976896397305836815761"
-      "717676338115866650889936516794601457549097578905329423919798362140648664"
-      "569177147076571576101649257502509463877402424847669830852345415301684820"
-      "395813946416649808062227494112874521812750160935760825922220707178083076"
-      "380203450993589198835885505461509442443773367592842795410339065860781804"
-      "024975272228687688301824830333940416256885455008512598774611538878683158"
-      "183931461086893832255176926531299425504132104728730288984598001187854507"
-      "900417184206801359847651992484444933900133130832052346600926424167009902"
-      "829803553087005800387704758687923428053612864451456596148162238935900033"
-      "917094683141205188616000211702577553792389670853917118547527592495253773"
-      "028135298405566315903922235989614934474805789300370437580494193066066314"
-      "056627605207631392651010580925826419831250810981343093764403877594495896"
-      "516881097415880926429607388979497471571321217205535961262051641426436441"
-      "668989765107456413733909427384182109285933511623871034309722437967253289"
-      "084018145083721513211807496392673952789642893241520398827805325610653506"
-      "029060153153064455898648607959013571280930834475689835845791849456112104"
-      "462337569019001580859906425911782967213265389744605395555069797947978230"
-      "708108432086217134763779632408473684293543722127232658767439906910370146"
-      "716836295909075482355827087389127370874842532825987593970846704144140471"
-      "956027276735614286138656432085771988513977140957180090146798065497158947"
-      "229765733489703157617307078835099906185890777007500964162371428641176460"
-      "739074789794941408428328217107759915202650066155868439585510978709442590"
-      "231934194956788626761834746430104077432547436359522462253411168467463134"
-      "24896.000000");
-*/
+  written = LIBC_NAMESPACE::sprintf(buff, "%Le", 1.2345678e4900L);
+  ASSERT_STREQ_LEN(written, buff, "1.234568e+4900");
+#endif
 }
 
-TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
+TEST(LlvmLibcSPrintfTest, FloatAutoConv) {
+  char buff[1000];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
   double inf = LIBC_NAMESPACE::fputil::FPBits<double>::inf().get_val();
   double nan = LIBC_NAMESPACE::fputil::FPBits<double>::quiet_nan().get_val();
@@ -2820,6 +2568,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
   ASSERT_STREQ_LEN(written, buff, "1e+01");
 
   // Subnormal Precision Tests
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.310g", 0x1.0p-1022);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -2829,10 +2578,12 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
       "385377718821130777993532002330479610147442583636071921565046942503734208"
       "375250806650616658158948720491179968591639648500635908770118304874799780"
       "887753749949451580452e-308");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.30g", 0x1.0p-1022);
   ASSERT_STREQ_LEN(written, buff, "2.22507385850720138309023271733e-308");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
   written = LIBC_NAMESPACE::sprintf(buff, "%.310g", 0x1.0p-1023);
   ASSERT_STREQ_LEN(
       written, buff,
@@ -2842,6 +2593,7 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
       "192688859410565388996766001165239805073721291818035960782523471251867104"
       "187625403325308329079474360245589984295819824250317954385059152437399890"
       "443876874974725790226e-308");
+#endif
 
   written = LIBC_NAMESPACE::sprintf(buff, "%.7g", 9.99999e-310);
   ASSERT_STREQ_LEN(written, buff, "9.99999e-310");
@@ -2870,38 +2622,6 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%.10g", 0x1.0p-1074);
   ASSERT_STREQ_LEN(written, buff, "4.940656458e-324");
 
-#if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-
-  written = LIBC_NAMESPACE::sprintf(buff, "%.60Lg", 0xa.aaaaaaaaaaaaaabp-7L);
-  ASSERT_STREQ_LEN(
-      written, buff,
-      "0.0833333333333333333355920878593448009041821933351457118988037");
-
-#endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
-
-  // Long double precision tests.
-  // These are currently commented out because they require long double support
-  // that isn't ready yet.
-  /*
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La", 0.1L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0xc.dp-7");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.ap-4");
-  #endif
-
-    written = LIBC_NAMESPACE::sprintf(buff, "%.1La",
-  0xf.fffffffffffffffp16380L); #if
-  defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80) ASSERT_STREQ_LEN(written, buff,
-  "0x1.0p+16384"); #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "inf");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x2.0p+16383");
-  #endif
-  */
-
   // Rounding Mode Tests.
 
   if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
@@ -3135,11 +2855,15 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoConv) {
   ASSERT_STREQ_LEN(written, buff, "+0.126        0001.26e+03");
 }
 
-TEST_F(LlvmLibcSPrintfTest, FloatAutoLongDoubleConv) {
+TEST(LlvmLibcSPrintfTest, FloatAutoLongDoubleConv) {
+  char buff[1000];
+  int written;
+
   ForceRoundingMode r(RoundingMode::Nearest);
 
   // Length Modifier Tests.
 
+// TODO: Tests for other long double types
 #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
 
   written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 0xf.fffffffffffffffp+16380L);
@@ -3148,149 +2872,42 @@ TEST_F(LlvmLibcSPrintfTest, FloatAutoLongDoubleConv) {
   written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 0xa.aaaaaaaaaaaaaabp-7L);
   ASSERT_STREQ_LEN(written, buff, "0.0833333");
 
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
+  written = LIBC_NAMESPACE::sprintf(buff, "%.60Lg", 0xa.aaaaaaaaaaaaaabp-7L);
+  ASSERT_STREQ_LEN(
+      written, buff,
+      "0.0833333333333333333355920878593448009041821933351457118988037");
+#endif
+
+#endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
+
   written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 9.99999999999e-100L);
   ASSERT_STREQ_LEN(written, buff, "1e-99");
 
-#endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
+  written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 1e100L);
+  ASSERT_STREQ_LEN(written, buff, "1e+100");
 
-  // TODO: Uncomment the below tests after long double support is added
-  /*
-  written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 1e100L);
-  ASSERT_STREQ_LEN(written, buff,
-                   "99999999999999999996693535322073426194986990198284960792713"
-                   "91541752018669482644324418977840117055488.000000");
+  written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 1.0L);
+  ASSERT_STREQ_LEN(written, buff, "1");
 
-  written = LIBC_NAMESPACE::sprintf(buff, "%Lf", 1.0L);
-  ASSERT_STREQ_LEN(written, buff, "1.000000");
+  written = LIBC_NAMESPACE::sprintf(buff, "%Lg", 0.1L);
+  ASSERT_STREQ_LEN(written, buff, "0.1");
 
   char big_buff[10000];
-  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lf", 1e1000L);
-  ASSERT_STREQ_LEN(
-      written, big_buff,
-      "999999999999999999973107317669562353428234857594552594925899449376328728"
-      "202461036775511405481186963193066642191664822065529414252060696836533522"
-      "387143501724276282079456797058697369889056407118642873669166717313763499"
-      "277025985141177344925615052465165938514140943010597323750202561187880136"
-      "174810574553749194614479541820148407958204853833697063267336294787191005"
-      "628217462261955103745349844675732989944229689277833828743730290177882029"
-      "042613704915899149603539993716885598351951895974316347947147507970269673"
-      "097709017164643598452451201499004104341931127294141495501309305995449742"
-      "273419524803597130450457553871345958049837885085168840317195672271085085"
-      "950520957945970913451088104971436093671776829538796532762184174216651692"
-      "640931965387852083906784898823494867055070322768919156031682291829761007"
-      "101483799978382119231551218582499361996919560548090784230386907125151658"
-      "086767207295524036170321059257942621398084478974000973622199163292708506"
-      "2431457550909271560663602154947063707982236377366647567795879936."
-      "000000");
+  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lg", 1e1000L);
+  ASSERT_STREQ_LEN(written, big_buff, "1e+1000");
 
-  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lf", 1e4900L);
-  ASSERT_STREQ_LEN(
-      written, big_buff,
-      "100000000000000000002708312230690349833224052504078834346502930111959028"
-      "517260692666637048230414374897655201843766090626319971729765251179632020"
-      "313912652522792711197087872698264530532442630109549129842736280196919130"
-      "242615101228133188193853826983121366159061148351354364472807590931218045"
-      "387490935930967150336231085015126034696883068553581691802388371635128003"
-      "615577299166097675723780877126495909902479233742826339471026068806070433"
-      "075629449530819183550315434973800271862658869400009022028602967197463980"
-      "126881829804282202449930132940824361207087494829502385835258094836304011"
-      "876250359661206802659650567866176246063987902366800491980400341950657151"
-      "370854446585517805253310195469184699955519312761482572080479702840420595"
-      "377369017651259376039167277822106875560385309101650382998482652792335482"
-      "865443482342801545877390859444282105890147577937366066315975231014810320"
-      "888482059656248277607763361589359794524314002443575149260630989130103550"
-      "443177966380769341050735632338583912575890190136462629316287947355057647"
-      "111088565611192544631519843618778618820046304429723908484879583579178075"
-      "456701368334212923379389029311286386996015804122917416008806233549005183"
-      "152461084266176543129004016414959261473645240454289630182591200574019087"
-      "358223489767381636349719510715487188747217311279465814538495924567014916"
-      "238565628036285599497236493491668884212847699052761266207598941300449276"
-      "447201387520841811835583254242213093566548778954711633721122784159793843"
-      "766802019309395771984693609426401362800013936338891483689127845928572536"
-      "790651156184721483511507878883282891696900630100211914227950790472211403"
-      "392549466062537498185758854079775888444518306635752468713312357556380082"
-      "275500658967283696421824354930077523691855699312544373220921962817907078"
-      "445538421941800259027487429330768616490865438859612697367766323925013940"
-      "918384858952407145253573823848733994146335416209309233074165707437420756"
-      "438833918763109580759409985573826485055208965115587885226774453455112406"
-      "581351429640282227888764449360534584421929291565334894907337572527922691"
-      "473242328379737396430908523008687037407295838014450772162091496534584696"
-      "605157436893236842602956298545594095307060870397506421786236892553632163"
-      "491468601982681381011940409602294892199042638682530687578982576819839451"
-      "907594697546439533559153604700750696252355362322662219852740143212566818"
-      "745528402265116534684566273868361460640280523251242059850044328669692159"
-      "629900374576027104298177006629276014371540945261309319363704125592775129"
-      "543526908667388673739382491147471395192495459318806593271282662311169392"
-      "196897003517840025298267505925987901751541005546610016067658227181318892"
-      "914686508281007582655667597441346214499847364272258631922040641860333431"
-      "409838623713258383681350233064164940590695888300919626215847587544298023"
-      "636416943680102708406086295669759876682046839368574433996997648445207805"
-      "615784339667691231286807666753972942872019850432610318031627872612657513"
-      "588188267160616660825719678199868371370527508463011236193719286066916786"
-      "169956541349011494927225747024994619057884118692213564790598702879596058"
-      "672338334720925179141906809470606964896245458600635183723159228561689808"
-      "246141482736625197373238197777325580142168245885279594913851700941789475"
-      "252421784152262567254611571822468808675893407728003047921107885664474662"
-      "930921581384003950729114103689170603748380178682003976896397305836815761"
-      "717676338115866650889936516794601457549097578905329423919798362140648664"
-      "569177147076571576101649257502509463877402424847669830852345415301684820"
-      "395813946416649808062227494112874521812750160935760825922220707178083076"
-      "380203450993589198835885505461509442443773367592842795410339065860781804"
-      "024975272228687688301824830333940416256885455008512598774611538878683158"
-      "183931461086893832255176926531299425504132104728730288984598001187854507"
-      "900417184206801359847651992484444933900133130832052346600926424167009902"
-      "829803553087005800387704758687923428053612864451456596148162238935900033"
-      "917094683141205188616000211702577553792389670853917118547527592495253773"
-      "028135298405566315903922235989614934474805789300370437580494193066066314"
-      "056627605207631392651010580925826419831250810981343093764403877594495896"
-      "516881097415880926429607388979497471571321217205535961262051641426436441"
-      "668989765107456413733909427384182109285933511623871034309722437967253289"
-      "084018145083721513211807496392673952789642893241520398827805325610653506"
-      "029060153153064455898648607959013571280930834475689835845791849456112104"
-      "462337569019001580859906425911782967213265389744605395555069797947978230"
-      "708108432086217134763779632408473684293543722127232658767439906910370146"
-      "716836295909075482355827087389127370874842532825987593970846704144140471"
-      "956027276735614286138656432085771988513977140957180090146798065497158947"
-      "229765733489703157617307078835099906185890777007500964162371428641176460"
-      "739074789794941408428328217107759915202650066155868439585510978709442590"
-      "231934194956788626761834746430104077432547436359522462253411168467463134"
-      "24896.000000");
-*/
-  /*
-    written = LIBC_NAMESPACE::sprintf(buff, "%La", 0.1L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0xc.ccccccccccccccdp-7");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "0x1.999999999999ap-4");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.999999999999999999999999999ap-4");
-  #endif
-
-    written = LIBC_NAMESPACE::sprintf(buff, "%La", 1.0e1000L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0xf.38db1f9dd3dac05p+3318");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "inf");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.e71b63f3ba7b580af1a52d2a7379p+3321");
-  #endif
-
-    written = LIBC_NAMESPACE::sprintf(buff, "%La", 1.0e-1000L);
-  #if defined(LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80)
-    ASSERT_STREQ_LEN(written, buff, "0x8.68a9188a89e1467p-3325");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64)
-    ASSERT_STREQ_LEN(written, buff, "0x0p+0");
-  #elif defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
-    ASSERT_STREQ_LEN(written, buff, "0x1.0d152311513c28ce202627c06ec2p-3322");
-  #endif
-  */
+  written = LIBC_NAMESPACE::sprintf(big_buff, "%Lg", 1e4900L);
+  ASSERT_STREQ_LEN(written, big_buff, "1e+4900");
 }
 
 #endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
 
 #if defined(LIBC_COMPILER_HAS_FIXED_POINT) &&                                  \
     !defined(LIBC_COPT_PRINTF_DISABLE_FIXED_POINT)
-TEST_F(LlvmLibcSPrintfTest, FixedConv) {
+TEST(LlvmLibcSPrintfTest, FixedConv) {
+  char buff[1000];
+  int written;
 
   // These numeric tests are potentially a little weak, but the fuzz test is
   // more thorough than my handwritten tests tend to be.
@@ -3350,7 +2967,7 @@ TEST_F(LlvmLibcSPrintfTest, FixedConv) {
       LIBC_NAMESPACE::sprintf(buff, "%hR", 0xff); // unsigned short fract max
   ASSERT_STREQ_LEN(written, buff, "0.996094");
 
-  written = LIBC_NAMESPACE::sprintf(buff, "%lk", 0x0); // 0.0
+  written = LIBC_NAMESPACE::sprintf(buff, "%lk", 0x0ll); // 0.0
   ASSERT_STREQ_LEN(written, buff, "0.000000");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%lk",
@@ -3364,7 +2981,7 @@ TEST_F(LlvmLibcSPrintfTest, FixedConv) {
                                     0xffffffff); //-long fract max
   ASSERT_STREQ_LEN(written, buff, "-1.000000");
 
-  written = LIBC_NAMESPACE::sprintf(buff, "%lK", 0x0); // 0.0
+  written = LIBC_NAMESPACE::sprintf(buff, "%lK", 0x0ll); // 0.0
   ASSERT_STREQ_LEN(written, buff, "0.000000");
 
   written =
@@ -3492,13 +3109,197 @@ TEST_F(LlvmLibcSPrintfTest, FixedConv) {
   ASSERT_STREQ_LEN(written, buff, "       0.100 256.000     ");
 
   written =
-      LIBC_NAMESPACE::sprintf(buff, "%+-#12.3lk % 012.3k", 0x000000001013a92a,
+      LIBC_NAMESPACE::sprintf(buff, "%+-#12.3lk % 012.3k", 0x000000001013a92all,
                               0x02740000); // 0.126, 1256.0
   ASSERT_STREQ_LEN(written, buff, "+0.126        0001256.000");
 }
 #endif // defined(LIBC_COMPILER_HAS_FIXED_POINT) &&
        // !defined(LIBC_COPT_PRINTF_DISABLE_FIXED_POINT)
 
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+TEST(LlvmLibcSPrintfTest, StrerrorConv) {
+  char buff[1000];
+  int written;
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%m");
+  ASSERT_STREQ_LEN(written, buff, "Success");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%m");
+  ASSERT_STREQ_LEN(written, buff, "Numerical result out of range");
+
+  // Check that it correctly consumes no arguments.
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%m %d", 1);
+  ASSERT_STREQ_LEN(written, buff, "Success 1");
+
+  // Width Tests
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%10m");
+  ASSERT_STREQ_LEN(written, buff, "   Success");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%10m");
+  ASSERT_STREQ_LEN(written, buff, "Numerical result out of range");
+
+  // Precision Tests
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%.10m");
+  ASSERT_STREQ_LEN(written, buff, "Success");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%.10m");
+  ASSERT_STREQ_LEN(written, buff, "Numerical ");
+
+  // Flag Tests (Only '-' since the others only affect ints)
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%-10m");
+  ASSERT_STREQ_LEN(written, buff, "Success   ");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%-10m");
+  ASSERT_STREQ_LEN(written, buff, "Numerical result out of range");
+
+  // Alt Mode Tests
+  // Since alt mode here is effectively a completely separate conversion, it
+  // gets separate tests.
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#m");
+  ASSERT_STREQ_LEN(written, buff, "0");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  // Alt Mode Width
+
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#10m");
+  ASSERT_STREQ_LEN(written, buff, "         0");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#10m");
+  ASSERT_STREQ_LEN(written, buff, "    ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#10m");
+  ASSERT_STREQ_LEN(written, buff, "     -9999");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#3m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#3m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  // Alt Mode Precision
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.10m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.10m");
+  ASSERT_STREQ_LEN(written, buff, "-0000009999");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.3m");
+  ASSERT_STREQ_LEN(written, buff, "ERA");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.3m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  // We don't test precision (or int flags) on errno = 0 because it behaves
+  // weirdly, see the docs for more information.
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.1m");
+  ASSERT_STREQ_LEN(written, buff, "0");
+
+  // Alt Mode Flags
+
+  // '-' flag
+  LIBC_NAMESPACE::libc_errno = 0;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#-10m");
+  ASSERT_STREQ_LEN(written, buff, "0         ");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#-10m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE    ");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#-10m");
+  ASSERT_STREQ_LEN(written, buff, "-9999     ");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#-3m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#-3m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  // '+' flag
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#+m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#+m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  // Technically 9999 could be a valid error, since the standard just says errno
+  // macros are "distinct positive values". In practice I don't expect this to
+  // come up, but I've avoided it for the other %m tests for ease of
+  // refactoring if necessary. Here it needs to be positive to test that the
+  // flags that only affect positive signed integers are properly passed along.
+  LIBC_NAMESPACE::libc_errno = 9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#+m");
+  ASSERT_STREQ_LEN(written, buff, "+9999");
+
+  // ' ' flag
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%# m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%# m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+
+  LIBC_NAMESPACE::libc_errno = 9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%# m");
+  ASSERT_STREQ_LEN(written, buff, " 9999");
+
+  // '0' flag
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#010m");
+  ASSERT_STREQ_LEN(written, buff, "    ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#010m");
+  ASSERT_STREQ_LEN(written, buff, "-000009999");
+
+  LIBC_NAMESPACE::libc_errno = ERANGE;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#03m");
+  ASSERT_STREQ_LEN(written, buff, "ERANGE");
+
+  LIBC_NAMESPACE::libc_errno = -9999;
+  written = LIBC_NAMESPACE::sprintf(buff, "%#03m");
+  ASSERT_STREQ_LEN(written, buff, "-9999");
+}
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
+
 #ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
 TEST(LlvmLibcSPrintfTest, WriteIntConv) {
   char buff[64];
@@ -3507,27 +3308,23 @@ TEST(LlvmLibcSPrintfTest, WriteIntConv) {
 
   test_val = -1;
   written = LIBC_NAMESPACE::sprintf(buff, "12345%n67890", &test_val);
-  EXPECT_EQ(written, 10);
   EXPECT_EQ(test_val, 5);
-  ASSERT_STREQ(buff, "1234567890");
+  ASSERT_STREQ_LEN(written, buff, "1234567890");
 
   test_val = -1;
   written = LIBC_NAMESPACE::sprintf(buff, "%n", &test_val);
-  EXPECT_EQ(written, 0);
   EXPECT_EQ(test_val, 0);
-  ASSERT_STREQ(buff, "");
+  ASSERT_STREQ_LEN(written, buff, "");
 
   test_val = 0x100;
   written = LIBC_NAMESPACE::sprintf(buff, "ABC%hhnDEF", &test_val);
-  EXPECT_EQ(written, 6);
   EXPECT_EQ(test_val, 0x103);
-  ASSERT_STREQ(buff, "ABCDEF");
+  ASSERT_STREQ_LEN(written, buff, "ABCDEF");
 
   test_val = -1;
   written = LIBC_NAMESPACE::sprintf(buff, "%s%n", "87654321", &test_val);
-  EXPECT_EQ(written, 8);
   EXPECT_EQ(test_val, 8);
-  ASSERT_STREQ(buff, "87654321");
+  ASSERT_STREQ_LEN(written, buff, "87654321");
 
 #ifndef LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
   written = LIBC_NAMESPACE::sprintf(buff, "abc123%n", nullptr);
@@ -3542,23 +3339,20 @@ TEST(LlvmLibcSPrintfTest, IndexModeParsing) {
   int written;
 
   written = LIBC_NAMESPACE::sprintf(buff, "%1$s", "abcDEF123");
-  EXPECT_EQ(written, 9);
-  ASSERT_STREQ(buff, "abcDEF123");
+  ASSERT_STREQ_LEN(written, buff, "abcDEF123");
 
   written = LIBC_NAMESPACE::sprintf(buff, "%1$s %%", "abcDEF123");
-  EXPECT_EQ(written, 11);
-  ASSERT_STREQ(buff, "abcDEF123 %");
+  ASSERT_STREQ_LEN(written, buff, "abcDEF123 %");
 
   written =
       LIBC_NAMESPACE::sprintf(buff, "%3$s %1$s %2$s", "is", "hard", "ordering");
-  EXPECT_EQ(written, 16);
-  ASSERT_STREQ(buff, "ordering is hard");
+  ASSERT_STREQ_LEN(written, buff, "ordering is hard");
 
   written = LIBC_NAMESPACE::sprintf(
       buff, "%10$s %9$s %8$c %7$s %6$s, %6$s %5$s %4$-*1$s %3$.*11$s %2$s. %%",
       6, "pain", "alphabetical", "such", "is", "this", "do", 'u', "would",
       "why", 1);
-  EXPECT_EQ(written, 45);
-  ASSERT_STREQ(buff, "why would u do this, this is such   a pain. %");
+  ASSERT_STREQ_LEN(written, buff,
+                   "why would u do this, this is such   a pain. %");
 }
 #endif // LIBC_COPT_PRINTF_DISABLE_INDEX_MODE
diff --git a/test/src/stdio/sscanf_test.cpp b/test/src/stdio/sscanf_test.cpp
index 741815b..18addb6 100644
--- a/test/src/stdio/sscanf_test.cpp
+++ b/test/src/stdio/sscanf_test.cpp
@@ -6,13 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/CPP/limits.h"
-#include "src/__support/FPUtil/FPBits.h"
-
 #include "src/stdio/sscanf.h"
 
-#include <stdio.h> // For EOF
-
+#include "hdr/stdio_macros.h" // For EOF
+#include "src/__support/CPP/limits.h"
+#include "src/__support/FPUtil/FPBits.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
 
@@ -179,13 +177,25 @@ TEST(LlvmLibcSScanfTest, IntConvMaxLengthTests) {
   EXPECT_EQ(ret_val, 1);
   EXPECT_EQ(result, 0);
 
+  result = -999;
+
+  // 0x is a valid prefix, but not a valid number. This should be a matching
+  // failure and should not modify the values.
   ret_val = LIBC_NAMESPACE::sscanf("0x1", "%2i", &result);
-  EXPECT_EQ(ret_val, 1);
-  EXPECT_EQ(result, 0);
+  EXPECT_EQ(ret_val, 0);
+  EXPECT_EQ(result, -999);
 
   ret_val = LIBC_NAMESPACE::sscanf("-0x1", "%3i", &result);
+  EXPECT_EQ(ret_val, 0);
+  EXPECT_EQ(result, -999);
+
+  ret_val = LIBC_NAMESPACE::sscanf("0x1", "%3i", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_EQ(result, 0);
+  EXPECT_EQ(result, 1);
+
+  ret_val = LIBC_NAMESPACE::sscanf("-0x1", "%4i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, -1);
 
   ret_val = LIBC_NAMESPACE::sscanf("-0x123", "%4i", &result);
   EXPECT_EQ(ret_val, 1);
@@ -214,7 +224,7 @@ TEST(LlvmLibcSScanfTest, IntConvNoWriteTests) {
   EXPECT_EQ(result, 0);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x1", "%*2i", &result);
-  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(ret_val, 0);
   EXPECT_EQ(result, 0);
 
   ret_val = LIBC_NAMESPACE::sscanf("a", "%*i", &result);
@@ -226,6 +236,7 @@ TEST(LlvmLibcSScanfTest, IntConvNoWriteTests) {
   EXPECT_EQ(result, 0);
 }
 
+#ifndef LIBC_COPT_SCANF_DISABLE_FLOAT
 TEST(LlvmLibcSScanfTest, FloatConvSimple) {
   int ret_val;
   float result = 0;
@@ -580,7 +591,9 @@ TEST(LlvmLibcSScanfTest, FloatConvNoWrite) {
   ret_val = LIBC_NAMESPACE::sscanf("Not a float", "%*f", &result);
   EXPECT_EQ(ret_val, 0);
 }
+#endif
 
+#ifndef LIBC_COPT_SCANF_DISABLE_INDEX_MODE
 TEST(LlvmLibcSScanfTest, CurPosCombined) {
   int ret_val;
   int result = -1;
@@ -628,6 +641,7 @@ TEST(LlvmLibcSScanfTest, CurPosCombined) {
   EXPECT_EQ(ret_val, 1);
   EXPECT_EQ(result, 320);
 }
+#endif
 
 TEST(LlvmLibcSScanfTest, PointerConvCombined) {
   int ret_val;
@@ -677,13 +691,17 @@ TEST(LlvmLibcSScanfTest, CombinedConv) {
   EXPECT_EQ(result, 123);
   ASSERT_STREQ(buffer, "abc");
 
+  result = -1;
+
+  // 0x is a valid prefix, but not a valid number. This should be a matching
+  // failure and should not modify the values.
   ret_val = LIBC_NAMESPACE::sscanf("0xZZZ", "%i%s", &result, buffer);
-  EXPECT_EQ(ret_val, 2);
-  EXPECT_EQ(result, 0);
-  ASSERT_STREQ(buffer, "ZZZ");
+  EXPECT_EQ(ret_val, 0);
+  EXPECT_EQ(result, -1);
+  ASSERT_STREQ(buffer, "abc");
 
   ret_val = LIBC_NAMESPACE::sscanf("0xZZZ", "%X%s", &result, buffer);
-  EXPECT_EQ(ret_val, 2);
-  EXPECT_EQ(result, 0);
-  ASSERT_STREQ(buffer, "ZZZ");
+  EXPECT_EQ(ret_val, 0);
+  EXPECT_EQ(result, -1);
+  ASSERT_STREQ(buffer, "abc");
 }
diff --git a/test/src/stdio/ungetc_test.cpp b/test/src/stdio/ungetc_test.cpp
index c98995f..b9d7530 100644
--- a/test/src/stdio/ungetc_test.cpp
+++ b/test/src/stdio/ungetc_test.cpp
@@ -6,16 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/stdio/ungetc.h"
+
+#include "hdr/stdio_macros.h"
 #include "src/stdio/fclose.h"
 #include "src/stdio/fopen.h"
 #include "src/stdio/fread.h"
 #include "src/stdio/fseek.h"
 #include "src/stdio/fwrite.h"
-#include "src/stdio/ungetc.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 TEST(LlvmLibcUngetcTest, UngetAndReadBack) {
   constexpr char FILENAME[] = "testdata/ungetc_test.test";
   ::FILE *file = LIBC_NAMESPACE::fopen(FILENAME, "w");
diff --git a/test/src/stdio/unlocked_fileop_test.cpp b/test/src/stdio/unlocked_fileop_test.cpp
index 09697a6..67f1b0f 100644
--- a/test/src/stdio/unlocked_fileop_test.cpp
+++ b/test/src/stdio/unlocked_fileop_test.cpp
@@ -18,7 +18,6 @@
 #include "test/UnitTest/Test.h"
 
 #include "src/errno/libc_errno.h"
-#include <stdio.h>
 
 TEST(LlvmLibcFILETest, UnlockedReadAndWrite) {
   constexpr char fNAME[] = "testdata/unlocked_read_and_write.test";
diff --git a/test/src/stdio/vasprintf_test.cpp b/test/src/stdio/vasprintf_test.cpp
new file mode 100644
index 0000000..2eb1be3
--- /dev/null
+++ b/test/src/stdio/vasprintf_test.cpp
@@ -0,0 +1,99 @@
+//===-- Unittests for vasprintf--------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/sprintf.h"
+#include "src/stdio/vasprintf.h"
+#include "src/string/memset.h"
+#include "test/UnitTest/Test.h"
+
+int call_vasprintf(char **__restrict buffer, const char *__restrict format,
+                   ...) {
+  va_list vlist;
+  va_start(vlist, format);
+  int ret = LIBC_NAMESPACE::vasprintf(buffer, format, vlist);
+  va_end(vlist);
+  return ret;
+}
+
+TEST(LlvmLibcVASPrintfTest, SimpleNoConv) {
+  char *buff = nullptr;
+  int written;
+  written = call_vasprintf(&buff, "A simple string with no conversions.");
+  EXPECT_EQ(written, 36);
+  ASSERT_STREQ(buff, "A simple string with no conversions.");
+  free(buff);
+}
+
+TEST(LlvmLibcVASPrintfTest, PercentConv) {
+  char *buff = nullptr;
+  int written;
+
+  written = call_vasprintf(&buff, "%%");
+  EXPECT_EQ(written, 1);
+  ASSERT_STREQ(buff, "%");
+  free(buff);
+
+  written = call_vasprintf(&buff, "abc %% def");
+  EXPECT_EQ(written, 9);
+  ASSERT_STREQ(buff, "abc % def");
+  free(buff);
+
+  written = call_vasprintf(&buff, "%%%%%%");
+  EXPECT_EQ(written, 3);
+  ASSERT_STREQ(buff, "%%%");
+  free(buff);
+}
+
+TEST(LlvmLibcVASPrintfTest, CharConv) {
+  char *buff = nullptr;
+  int written;
+
+  written = call_vasprintf(&buff, "%c", 'a');
+  EXPECT_EQ(written, 1);
+  ASSERT_STREQ(buff, "a");
+  free(buff);
+
+  written = call_vasprintf(&buff, "%3c %-3c", '1', '2');
+  EXPECT_EQ(written, 7);
+  ASSERT_STREQ(buff, "  1 2  ");
+  free(buff);
+
+  written = call_vasprintf(&buff, "%*c", 2, '3');
+  EXPECT_EQ(written, 2);
+  ASSERT_STREQ(buff, " 3");
+  free(buff);
+}
+
+TEST(LlvmLibcVASPrintfTest, LargeStringNoConv) {
+  char *buff = nullptr;
+  char long_str[1001];
+  LIBC_NAMESPACE::memset(long_str, 'a', 1000);
+  long_str[1000] = '\0';
+  int written;
+  written = call_vasprintf(&buff, long_str);
+  EXPECT_EQ(written, 1000);
+  ASSERT_STREQ(buff, long_str);
+  free(buff);
+}
+
+TEST(LlvmLibcVASPrintfTest, ManyReAlloc) {
+  char *buff = nullptr;
+  const int expected_num_chars = 600;
+  int written = call_vasprintf(&buff, "%200s%200s%200s", "", "", "");
+  EXPECT_EQ(written, expected_num_chars);
+
+  bool isPadding = true;
+  for (int i = 0; i < expected_num_chars; i++) {
+    if (buff[i] != ' ') {
+      isPadding = false;
+      break;
+    }
+  }
+  EXPECT_TRUE(isPadding);
+  free(buff);
+}
diff --git a/test/src/stdio/vfprintf_test.cpp b/test/src/stdio/vfprintf_test.cpp
index 9bad2c8..80d4845 100644
--- a/test/src/stdio/vfprintf_test.cpp
+++ b/test/src/stdio/vfprintf_test.cpp
@@ -21,8 +21,6 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdio.h>
-
 namespace printf_test {
 #ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
 using LIBC_NAMESPACE::fclose;
diff --git a/test/src/stdio/vfscanf_test.cpp b/test/src/stdio/vfscanf_test.cpp
new file mode 100644
index 0000000..b665386
--- /dev/null
+++ b/test/src/stdio/vfscanf_test.cpp
@@ -0,0 +1,96 @@
+//===-- Unittests for vfscanf ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/CPP/string_view.h"
+
+#ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
+#include "src/stdio/fclose.h"
+#include "src/stdio/ferror.h"
+#include "src/stdio/fopen.h"
+#include "src/stdio/fwrite.h"
+#endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
+
+#include "src/stdio/vfscanf.h"
+
+#include "test/UnitTest/Test.h"
+
+namespace scanf_test {
+#ifndef LIBC_COPT_STDIO_USE_SYSTEM_FILE
+using LIBC_NAMESPACE::fclose;
+using LIBC_NAMESPACE::ferror;
+using LIBC_NAMESPACE::fopen;
+using LIBC_NAMESPACE::fwrite;
+#else  // defined(LIBC_COPT_STDIO_USE_SYSTEM_FILE)
+using ::fclose;
+using ::ferror;
+using ::fopen;
+using ::fwrite;
+#endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
+} // namespace scanf_test
+
+static int call_vfscanf(::FILE *stream, const char *__restrict format, ...) {
+  va_list vlist;
+  va_start(vlist, format);
+  int ret = LIBC_NAMESPACE::vfscanf(stream, format, vlist);
+  va_end(vlist);
+  return ret;
+}
+
+TEST(LlvmLibcVFScanfTest, WriteToFile) {
+  const char *FILENAME = "vfscanf_output.test";
+  auto FILE_PATH = libc_make_test_file_path(FILENAME);
+  ::FILE *file = scanf_test::fopen(FILE_PATH, "w");
+  ASSERT_FALSE(file == nullptr);
+
+  int read;
+
+  constexpr char simple[] = "A simple string with no conversions.\n";
+
+  ASSERT_EQ(sizeof(simple) - 1,
+            scanf_test::fwrite(simple, 1, sizeof(simple) - 1, file));
+
+  constexpr char numbers[] = "1234567890\n";
+
+  ASSERT_EQ(sizeof(numbers) - 1,
+            scanf_test::fwrite(numbers, 1, sizeof(numbers) - 1, file));
+
+  constexpr char numbers_and_more[] = "1234 and more\n";
+
+  ASSERT_EQ(sizeof(numbers_and_more) - 1,
+            scanf_test::fwrite(numbers_and_more, 1,
+                               sizeof(numbers_and_more) - 1, file));
+
+  read = call_vfscanf(file, "Reading from a write-only file should fail.");
+  EXPECT_LT(read, 0);
+
+  ASSERT_EQ(0, scanf_test::fclose(file));
+
+  file = scanf_test::fopen(FILE_PATH, "r");
+  ASSERT_FALSE(file == nullptr);
+
+  char data[50];
+  read = call_vfscanf(file, "%[A-Za-z .\n]", data);
+  ASSERT_EQ(read, 1);
+  ASSERT_STREQ(simple, data);
+
+  read = call_vfscanf(file, "%s", data);
+  ASSERT_EQ(read, 1);
+  ASSERT_EQ(LIBC_NAMESPACE::cpp::string_view(numbers, 10),
+            LIBC_NAMESPACE::cpp::string_view(data));
+
+  // The format string starts with a space to handle the fact that the %s leaves
+  // a trailing \n and %c doesn't strip leading whitespace.
+  read = call_vfscanf(file, " %50c", data);
+  ASSERT_EQ(read, 1);
+  ASSERT_EQ(
+      LIBC_NAMESPACE::cpp::string_view(numbers_and_more),
+      LIBC_NAMESPACE::cpp::string_view(data, sizeof(numbers_and_more) - 1));
+
+  ASSERT_EQ(scanf_test::ferror(file), 0);
+  ASSERT_EQ(scanf_test::fclose(file), 0);
+}
diff --git a/test/src/stdio/vsscanf_test.cpp b/test/src/stdio/vsscanf_test.cpp
new file mode 100644
index 0000000..4194e10
--- /dev/null
+++ b/test/src/stdio/vsscanf_test.cpp
@@ -0,0 +1,159 @@
+//===-- Unittests for sscanf ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vsscanf.h"
+
+#include "test/UnitTest/Test.h"
+
+int call_vsscanf(const char *__restrict buffer, const char *__restrict format,
+                 ...) {
+  va_list vlist;
+  va_start(vlist, format);
+  int ret = LIBC_NAMESPACE::vsscanf(buffer, format, vlist);
+  va_end(vlist);
+  return ret;
+}
+
+TEST(LlvmLibcVSScanfTest, SimpleStringConv) {
+  int ret_val;
+  char buffer[10];
+  char buffer2[10];
+  ret_val = call_vsscanf("abc123", "abc %s", buffer);
+  ASSERT_EQ(ret_val, 1);
+  ASSERT_STREQ(buffer, "123");
+
+  ret_val = call_vsscanf("abc123", "%3s %3s", buffer, buffer2);
+  ASSERT_EQ(ret_val, 2);
+  ASSERT_STREQ(buffer, "abc");
+  ASSERT_STREQ(buffer2, "123");
+
+  ret_val = call_vsscanf("abc 123", "%3s%3s", buffer, buffer2);
+  ASSERT_EQ(ret_val, 2);
+  ASSERT_STREQ(buffer, "abc");
+  ASSERT_STREQ(buffer2, "123");
+}
+
+TEST(LlvmLibcVSScanfTest, IntConvSimple) {
+  int ret_val;
+  int result = 0;
+  ret_val = call_vsscanf("123", "%d", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 123);
+
+  ret_val = call_vsscanf("456", "%i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 456);
+
+  ret_val = call_vsscanf("789", "%x", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 0x789);
+
+  ret_val = call_vsscanf("012", "%o", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 012);
+
+  ret_val = call_vsscanf("345", "%u", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 345);
+
+  // 288 characters
+  ret_val = call_vsscanf("10000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000"
+                         "00000000000000000000000000000000",
+                         "%d", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, int(LIBC_NAMESPACE::cpp::numeric_limits<intmax_t>::max()));
+
+  ret_val = call_vsscanf("Not an integer", "%d", &result);
+  EXPECT_EQ(ret_val, 0);
+}
+
+TEST(LlvmLibcVSScanfTest, IntConvLengthModifier) {
+  int ret_val;
+  uintmax_t max_result = 0;
+  int int_result = 0;
+  char char_result = 0;
+
+  ret_val = call_vsscanf("123", "%ju", &max_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(max_result, uintmax_t(123));
+
+  // Check overflow handling
+  ret_val =
+      call_vsscanf("999999999999999999999999999999999999", "%ju", &max_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(max_result, LIBC_NAMESPACE::cpp::numeric_limits<uintmax_t>::max());
+
+  // Because this is unsigned, any out of range value should return the maximum,
+  // even with a negative sign.
+  ret_val =
+      call_vsscanf("-999999999999999999999999999999999999", "%ju", &max_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(max_result, LIBC_NAMESPACE::cpp::numeric_limits<uintmax_t>::max());
+
+  ret_val = call_vsscanf("-18446744073709551616", "%ju", &max_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(max_result, LIBC_NAMESPACE::cpp::numeric_limits<uintmax_t>::max());
+
+  // But any number below the maximum should have the - sign applied.
+  ret_val = call_vsscanf("-1", "%ju", &max_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(max_result, uintmax_t(-1));
+
+  ret_val = call_vsscanf("-1", "%u", &int_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(int_result, -1);
+
+  max_result = 0xff00ff00ff00ff00;
+  char_result = 0x6f;
+
+  // Overflows for sizes larger than the maximum are handled by casting.
+  ret_val = call_vsscanf("8589967360", "%d", &int_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(int_result, int(8589967360)); // 2^33 + 2^15
+
+  // Check that the adjacent values weren't touched by the overflow.
+  ASSERT_EQ(max_result, uintmax_t(0xff00ff00ff00ff00));
+  ASSERT_EQ(char_result, char(0x6f));
+
+  ret_val = call_vsscanf("-8589967360", "%d", &int_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(int_result, int(-8589967360));
+  ASSERT_EQ(max_result, uintmax_t(0xff00ff00ff00ff00));
+  ASSERT_EQ(char_result, char(0x6f));
+
+  ret_val = call_vsscanf("25", "%hhd", &char_result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(char_result, char(25));
+}
+
+TEST(LlvmLibcVSScanfTest, IntConvBaseSelection) {
+  int ret_val;
+  int result = 0;
+  ret_val = call_vsscanf("0xabc123", "%i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 0xabc123);
+
+  ret_val = call_vsscanf("0456", "%i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 0456);
+
+  ret_val = call_vsscanf("0999", "%i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 0);
+
+  ret_val = call_vsscanf("123abc456", "%i", &result);
+  EXPECT_EQ(ret_val, 1);
+  EXPECT_EQ(result, 123);
+}
diff --git a/test/src/stdlib/SortingTest.h b/test/src/stdlib/SortingTest.h
new file mode 100644
index 0000000..d34584e
--- /dev/null
+++ b/test/src/stdlib/SortingTest.h
@@ -0,0 +1,377 @@
+//===-- Unittests for sorting routines ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/macros/config.h"
+#include "src/stdlib/qsort_data.h"
+#include "test/UnitTest/Test.h"
+
+class SortingTest : public LIBC_NAMESPACE::testing::Test {
+
+  using Array = LIBC_NAMESPACE::internal::Array;
+  using Comparator = LIBC_NAMESPACE::internal::Comparator;
+  using SortingRoutine = LIBC_NAMESPACE::internal::SortingRoutine;
+
+public:
+  static int int_compare(const void *l, const void *r) {
+    int li = *reinterpret_cast<const int *>(l);
+    int ri = *reinterpret_cast<const int *>(r);
+    if (li == ri)
+      return 0;
+    else if (li > ri)
+      return 1;
+    else
+      return -1;
+  }
+
+  void test_sorted_array(SortingRoutine sort_func) {
+    int array[25] = {10,   23,   33,   35,   55,   70,    71,   100,  110,
+                     123,  133,  135,  155,  170,  171,   1100, 1110, 1123,
+                     1133, 1135, 1155, 1170, 1171, 11100, 12310};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_LE(array[0], 10);
+    ASSERT_LE(array[1], 23);
+    ASSERT_LE(array[2], 33);
+    ASSERT_LE(array[3], 35);
+    ASSERT_LE(array[4], 55);
+    ASSERT_LE(array[5], 70);
+    ASSERT_LE(array[6], 71);
+    ASSERT_LE(array[7], 100);
+    ASSERT_LE(array[8], 110);
+    ASSERT_LE(array[9], 123);
+    ASSERT_LE(array[10], 133);
+    ASSERT_LE(array[11], 135);
+    ASSERT_LE(array[12], 155);
+    ASSERT_LE(array[13], 170);
+    ASSERT_LE(array[14], 171);
+    ASSERT_LE(array[15], 1100);
+    ASSERT_LE(array[16], 1110);
+    ASSERT_LE(array[17], 1123);
+    ASSERT_LE(array[18], 1133);
+    ASSERT_LE(array[19], 1135);
+    ASSERT_LE(array[20], 1155);
+    ASSERT_LE(array[21], 1170);
+    ASSERT_LE(array[22], 1171);
+    ASSERT_LE(array[23], 11100);
+    ASSERT_LE(array[24], 12310);
+  }
+
+  void test_reversed_sorted_array(SortingRoutine sort_func) {
+    int array[] = {25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13,
+                   12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    for (int i = 0; i < int(ARRAY_SIZE - 1); ++i)
+      ASSERT_EQ(array[i], i + 1);
+  }
+
+  void test_all_equal_elements(SortingRoutine sort_func) {
+    int array[] = {100, 100, 100, 100, 100, 100, 100, 100, 100,
+                   100, 100, 100, 100, 100, 100, 100, 100, 100,
+                   100, 100, 100, 100, 100, 100, 100};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    for (size_t i = 0; i < ARRAY_SIZE; ++i)
+      ASSERT_EQ(array[i], 100);
+  }
+
+  void test_unsorted_array_1(SortingRoutine sort_func) {
+    int array[25] = {10,  23,  8,    35,   55,   45,  40,  100, 110,
+                     123, 90,  80,   70,   60,   171, 11,  1,   -1,
+                     -5,  -10, 1155, 1170, 1171, 12,  -100};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], -100);
+    ASSERT_EQ(array[1], -10);
+    ASSERT_EQ(array[2], -5);
+    ASSERT_EQ(array[3], -1);
+    ASSERT_EQ(array[4], 1);
+    ASSERT_EQ(array[5], 8);
+    ASSERT_EQ(array[6], 10);
+    ASSERT_EQ(array[7], 11);
+    ASSERT_EQ(array[8], 12);
+    ASSERT_EQ(array[9], 23);
+    ASSERT_EQ(array[10], 35);
+    ASSERT_EQ(array[11], 40);
+    ASSERT_EQ(array[12], 45);
+    ASSERT_EQ(array[13], 55);
+    ASSERT_EQ(array[14], 60);
+    ASSERT_EQ(array[15], 70);
+    ASSERT_EQ(array[16], 80);
+    ASSERT_EQ(array[17], 90);
+    ASSERT_EQ(array[18], 100);
+    ASSERT_EQ(array[19], 110);
+    ASSERT_EQ(array[20], 123);
+    ASSERT_EQ(array[21], 171);
+    ASSERT_EQ(array[22], 1155);
+    ASSERT_EQ(array[23], 1170);
+    ASSERT_EQ(array[24], 1171);
+  }
+
+  void test_unsorted_array_2(SortingRoutine sort_func) {
+    int array[7] = {10, 40, 45, 55, 35, 23, 60};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 10);
+    ASSERT_EQ(array[1], 23);
+    ASSERT_EQ(array[2], 35);
+    ASSERT_EQ(array[3], 40);
+    ASSERT_EQ(array[4], 45);
+    ASSERT_EQ(array[5], 55);
+    ASSERT_EQ(array[6], 60);
+  }
+
+  void test_unsorted_array_duplicated_1(SortingRoutine sort_func) {
+    int array[6] = {10, 10, 20, 20, 5, 5};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 5);
+    ASSERT_EQ(array[1], 5);
+    ASSERT_EQ(array[2], 10);
+    ASSERT_EQ(array[3], 10);
+    ASSERT_EQ(array[4], 20);
+    ASSERT_EQ(array[5], 20);
+  }
+
+  void test_unsorted_array_duplicated_2(SortingRoutine sort_func) {
+    int array[10] = {20, 10, 10, 10, 10, 20, 21, 21, 21, 21};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 10);
+    ASSERT_EQ(array[1], 10);
+    ASSERT_EQ(array[2], 10);
+    ASSERT_EQ(array[3], 10);
+    ASSERT_EQ(array[4], 20);
+    ASSERT_EQ(array[5], 20);
+    ASSERT_EQ(array[6], 21);
+    ASSERT_EQ(array[7], 21);
+    ASSERT_EQ(array[8], 21);
+    ASSERT_EQ(array[9], 21);
+  }
+
+  void test_unsorted_array_duplicated_3(SortingRoutine sort_func) {
+    int array[10] = {20, 30, 30, 30, 30, 20, 21, 21, 21, 21};
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 20);
+    ASSERT_EQ(array[1], 20);
+    ASSERT_EQ(array[2], 21);
+    ASSERT_EQ(array[3], 21);
+    ASSERT_EQ(array[4], 21);
+    ASSERT_EQ(array[5], 21);
+    ASSERT_EQ(array[6], 30);
+    ASSERT_EQ(array[7], 30);
+    ASSERT_EQ(array[8], 30);
+    ASSERT_EQ(array[9], 30);
+  }
+
+  void test_unsorted_three_element_1(SortingRoutine sort_func) {
+    int array[3] = {14999024, 0, 3};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 0);
+    ASSERT_EQ(array[1], 3);
+    ASSERT_EQ(array[2], 14999024);
+  }
+
+  void test_unsorted_three_element_2(SortingRoutine sort_func) {
+    int array[3] = {3, 14999024, 0};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 0);
+    ASSERT_EQ(array[1], 3);
+    ASSERT_EQ(array[2], 14999024);
+  }
+
+  void test_unsorted_three_element_3(SortingRoutine sort_func) {
+    int array[3] = {3, 0, 14999024};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 0);
+    ASSERT_EQ(array[1], 3);
+    ASSERT_EQ(array[2], 14999024);
+  }
+
+  void test_same_three_element(SortingRoutine sort_func) {
+    int array[3] = {12345, 12345, 12345};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 12345);
+    ASSERT_EQ(array[1], 12345);
+    ASSERT_EQ(array[2], 12345);
+  }
+
+  void test_unsorted_two_element_1(SortingRoutine sort_func) {
+    int array[] = {14999024, 0};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 0);
+    ASSERT_EQ(array[1], 14999024);
+  }
+
+  void test_unsorted_two_element_2(SortingRoutine sort_func) {
+    int array[] = {0, 14999024};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 0);
+    ASSERT_EQ(array[1], 14999024);
+  }
+
+  void test_same_two_element(SortingRoutine sort_func) {
+    int array[] = {12345, 12345};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 12345);
+    ASSERT_EQ(array[1], 12345);
+  }
+
+  void test_single_element(SortingRoutine sort_func) {
+    int array[] = {12345};
+
+    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+
+    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
+                     sizeof(int), Comparator(int_compare));
+
+    sort_func(arr);
+
+    ASSERT_EQ(array[0], 12345);
+  }
+};
+
+#define LIST_SORTING_TESTS(Name, Func)                                         \
+  using LlvmLibc##Name##Test = SortingTest;                                    \
+  TEST_F(LlvmLibc##Name##Test, SortedArray) { test_sorted_array(Func); }       \
+  TEST_F(LlvmLibc##Name##Test, ReverseSortedArray) {                           \
+    test_reversed_sorted_array(Func);                                          \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, AllEqualElements) {                             \
+    test_all_equal_elements(Func);                                             \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedArray1) {                               \
+    test_unsorted_array_1(Func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedArray2) {                               \
+    test_unsorted_array_2(Func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedArrayDuplicateElements1) {              \
+    test_unsorted_array_duplicated_1(Func);                                    \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedArrayDuplicateElements2) {              \
+    test_unsorted_array_duplicated_2(Func);                                    \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedArrayDuplicateElements3) {              \
+    test_unsorted_array_duplicated_3(Func);                                    \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedThreeElementArray1) {                   \
+    test_unsorted_three_element_1(Func);                                       \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedThreeElementArray2) {                   \
+    test_unsorted_three_element_2(Func);                                       \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedThreeElementArray3) {                   \
+    test_unsorted_three_element_3(Func);                                       \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, SameElementThreeElementArray) {                 \
+    test_same_three_element(Func);                                             \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedTwoElementArray1) {                     \
+    test_unsorted_two_element_1(Func);                                         \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, UnsortedTwoElementArray2) {                     \
+    test_unsorted_two_element_2(Func);                                         \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, SameElementTwoElementArray) {                   \
+    test_same_two_element(Func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, SingleElementArray) {                           \
+    test_single_element(Func);                                                 \
+  }                                                                            \
+  static_assert(true)
diff --git a/test/src/stdlib/StrfromTest.h b/test/src/stdlib/StrfromTest.h
index 0db507e..5209472 100644
--- a/test/src/stdlib/StrfromTest.h
+++ b/test/src/stdlib/StrfromTest.h
@@ -156,6 +156,9 @@ public:
     written = func(buff, 99, "%f", 1.5);
     ASSERT_STREQ_LEN(written, buff, "1.500000");
 
+// Dyadic float is only accurate to ~50 digits, so skip this 300 digit test.
+// TODO: Create way to test just the first ~50 digits of a number.
+#ifndef LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
     written = func(buff, 499, "%f", 1e300);
     ASSERT_STREQ_LEN(written, buff,
                      "100000000000000005250476025520442024870446858110815915491"
@@ -167,6 +170,7 @@ public:
                      "111903896764088007465274278014249457925878882005684283811"
                      "566947219638686"
                      "5459400540160.000000");
+#endif // DLIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION
 
     written = func(buff, 99, "%f", 0.1);
     ASSERT_STREQ_LEN(written, buff, "0.100000");
diff --git a/test/src/stdlib/_Exit_test.cpp b/test/src/stdlib/_Exit_test.cpp
index 9ca0fc5..333277d 100644
--- a/test/src/stdlib/_Exit_test.cpp
+++ b/test/src/stdlib/_Exit_test.cpp
@@ -10,8 +10,6 @@
 #include "src/stdlib/exit.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdlib.h>
-
 TEST(LlvmLibcStdlib, _Exit) {
   EXPECT_EXITS([] { LIBC_NAMESPACE::_Exit(1); }, 1);
   EXPECT_EXITS([] { LIBC_NAMESPACE::_Exit(65); }, 65);
diff --git a/test/src/stdlib/abort_test.cpp b/test/src/stdlib/abort_test.cpp
index 766c8d5..8c5fd0c 100644
--- a/test/src/stdlib/abort_test.cpp
+++ b/test/src/stdlib/abort_test.cpp
@@ -10,7 +10,6 @@
 #include "test/UnitTest/Test.h"
 
 #include <signal.h>
-#include <stdlib.h>
 
 TEST(LlvmLibcStdlib, abort) {
   // -1 matches against any signal, which is necessary for now until
diff --git a/test/src/stdlib/at_quick_exit_test.cpp b/test/src/stdlib/at_quick_exit_test.cpp
index e0a258d..c0aac4d 100644
--- a/test/src/stdlib/at_quick_exit_test.cpp
+++ b/test/src/stdlib/at_quick_exit_test.cpp
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/utility.h"
+#include "src/stdlib/_Exit.h"
 #include "src/stdlib/at_quick_exit.h"
 #include "src/stdlib/quick_exit.h"
 #include "test/UnitTest/Test.h"
@@ -33,7 +34,7 @@ TEST(LlvmLibcAtQuickExit, Basic) {
 
 TEST(LlvmLibcAtQuickExit, AtQuickExitCallsSysExit) {
   auto test = [] {
-    LIBC_NAMESPACE::at_quick_exit(+[] { _Exit(1); });
+    LIBC_NAMESPACE::at_quick_exit(+[] { LIBC_NAMESPACE::_Exit(1); });
     LIBC_NAMESPACE::quick_exit(0);
   };
   EXPECT_EXITS(test, 1);
diff --git a/test/src/stdlib/atexit_test.cpp b/test/src/stdlib/atexit_test.cpp
index 8a785cc..c25202f 100644
--- a/test/src/stdlib/atexit_test.cpp
+++ b/test/src/stdlib/atexit_test.cpp
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/utility.h"
+#include "src/stdlib/_Exit.h"
 #include "src/stdlib/atexit.h"
 #include "src/stdlib/exit.h"
 #include "test/UnitTest/Test.h"
@@ -33,7 +34,7 @@ TEST(LlvmLibcAtExit, Basic) {
 
 TEST(LlvmLibcAtExit, AtExitCallsSysExit) {
   auto test = [] {
-    LIBC_NAMESPACE::atexit(+[] { _Exit(1); });
+    LIBC_NAMESPACE::atexit(+[] { LIBC_NAMESPACE::_Exit(1); });
     LIBC_NAMESPACE::exit(0);
   };
   EXPECT_EXITS(test, 1);
diff --git a/test/src/stdlib/bsearch_test.cpp b/test/src/stdlib/bsearch_test.cpp
index 6891458..4240adc 100644
--- a/test/src/stdlib/bsearch_test.cpp
+++ b/test/src/stdlib/bsearch_test.cpp
@@ -10,7 +10,7 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
 
 static int int_compare(const void *l, const void *r) {
   int li = *reinterpret_cast<const int *>(l);
diff --git a/test/src/stdlib/div_test.cpp b/test/src/stdlib/div_test.cpp
index d06b834..a1dedbb 100644
--- a/test/src/stdlib/div_test.cpp
+++ b/test/src/stdlib/div_test.cpp
@@ -8,8 +8,7 @@
 
 #include "DivTest.h"
 
+#include "hdr/types/div_t.h"
 #include "src/stdlib/div.h"
 
-#include <stdlib.h>
-
 LIST_DIV_TESTS(int, div_t, LIBC_NAMESPACE::div)
diff --git a/test/src/stdlib/heap_sort_test.cpp b/test/src/stdlib/heap_sort_test.cpp
new file mode 100644
index 0000000..d70e3dc
--- /dev/null
+++ b/test/src/stdlib/heap_sort_test.cpp
@@ -0,0 +1,16 @@
+//===-- Unittests for heap sort -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SortingTest.h"
+#include "src/stdlib/heap_sort.h"
+
+void sort(const LIBC_NAMESPACE::internal::Array &array) {
+  LIBC_NAMESPACE::internal::heap_sort(array);
+}
+
+LIST_SORTING_TESTS(HeapSort, sort);
diff --git a/test/src/stdlib/ldiv_test.cpp b/test/src/stdlib/ldiv_test.cpp
index 6b84163..258cbfe 100644
--- a/test/src/stdlib/ldiv_test.cpp
+++ b/test/src/stdlib/ldiv_test.cpp
@@ -8,8 +8,7 @@
 
 #include "DivTest.h"
 
+#include "hdr/types/ldiv_t.h"
 #include "src/stdlib/ldiv.h"
 
-#include <stdlib.h>
-
 LIST_DIV_TESTS(long, ldiv_t, LIBC_NAMESPACE::ldiv)
diff --git a/test/src/stdlib/lldiv_test.cpp b/test/src/stdlib/lldiv_test.cpp
index d803894..72e24ae 100644
--- a/test/src/stdlib/lldiv_test.cpp
+++ b/test/src/stdlib/lldiv_test.cpp
@@ -8,8 +8,7 @@
 
 #include "DivTest.h"
 
+#include "hdr/types/lldiv_t.h"
 #include "src/stdlib/lldiv.h"
 
-#include <stdlib.h>
-
 LIST_DIV_TESTS(long long, lldiv_t, LIBC_NAMESPACE::lldiv)
diff --git a/test/src/stdlib/qsort_r_test.cpp b/test/src/stdlib/qsort_r_test.cpp
index 2c810f4..6893fdc 100644
--- a/test/src/stdlib/qsort_r_test.cpp
+++ b/test/src/stdlib/qsort_r_test.cpp
@@ -10,7 +10,7 @@
 
 #include "test/UnitTest/Test.h"
 
-#include <stdlib.h>
+#include "hdr/types/size_t.h"
 
 static int int_compare_count(const void *l, const void *r, void *count_arg) {
   int li = *reinterpret_cast<const int *>(l);
diff --git a/test/src/stdlib/qsort_test.cpp b/test/src/stdlib/qsort_test.cpp
index 0822d49..1e921a8 100644
--- a/test/src/stdlib/qsort_test.cpp
+++ b/test/src/stdlib/qsort_test.cpp
@@ -6,260 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "SortingTest.h"
 #include "src/stdlib/qsort.h"
 
-#include "test/UnitTest/Test.h"
-
-#include <stdlib.h>
-
-static int int_compare(const void *l, const void *r) {
-  int li = *reinterpret_cast<const int *>(l);
-  int ri = *reinterpret_cast<const int *>(r);
-  if (li == ri)
-    return 0;
-  else if (li > ri)
-    return 1;
-  else
-    return -1;
+void sort(const LIBC_NAMESPACE::internal::Array &array) {
+  LIBC_NAMESPACE::qsort(reinterpret_cast<void *>(array.get(0)), array.size(),
+                        sizeof(int), SortingTest::int_compare);
 }
 
-TEST(LlvmLibcQsortTest, SortedArray) {
-  int array[25] = {10,   23,   33,   35,   55,   70,    71,   100,  110,
-                   123,  133,  135,  155,  170,  171,   1100, 1110, 1123,
-                   1133, 1135, 1155, 1170, 1171, 11100, 12310};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 10);
-  ASSERT_LE(array[1], 23);
-  ASSERT_LE(array[2], 33);
-  ASSERT_LE(array[3], 35);
-  ASSERT_LE(array[4], 55);
-  ASSERT_LE(array[5], 70);
-  ASSERT_LE(array[6], 71);
-  ASSERT_LE(array[7], 100);
-  ASSERT_LE(array[8], 110);
-  ASSERT_LE(array[9], 123);
-  ASSERT_LE(array[10], 133);
-  ASSERT_LE(array[11], 135);
-  ASSERT_LE(array[12], 155);
-  ASSERT_LE(array[13], 170);
-  ASSERT_LE(array[14], 171);
-  ASSERT_LE(array[15], 1100);
-  ASSERT_LE(array[16], 1110);
-  ASSERT_LE(array[17], 1123);
-  ASSERT_LE(array[18], 1133);
-  ASSERT_LE(array[19], 1135);
-  ASSERT_LE(array[20], 1155);
-  ASSERT_LE(array[21], 1170);
-  ASSERT_LE(array[22], 1171);
-  ASSERT_LE(array[23], 11100);
-  ASSERT_LE(array[24], 12310);
-}
-
-TEST(LlvmLibcQsortTest, ReverseSortedArray) {
-  int array[25] = {25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13,
-                   12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  for (int i = 0; i < int(ARRAY_SIZE - 1); ++i)
-    ASSERT_LE(array[i], i + 1);
-}
-
-TEST(LlvmLibcQsortTest, AllEqualElements) {
-  int array[25] = {100, 100, 100, 100, 100, 100, 100, 100, 100,
-                   100, 100, 100, 100, 100, 100, 100, 100, 100,
-                   100, 100, 100, 100, 100, 100, 100};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  for (size_t i = 0; i < ARRAY_SIZE - 1; ++i)
-    ASSERT_LE(array[i], 100);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedArray1) {
-  int array[25] = {10, 23,  8,  35, 55, 45, 40,  100,  110,  123,  90, 80,  70,
-                   60, 171, 11, 1,  -1, -5, -10, 1155, 1170, 1171, 12, -100};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], -100);
-  ASSERT_LE(array[1], -10);
-  ASSERT_LE(array[2], -5);
-  ASSERT_LE(array[3], -1);
-  ASSERT_LE(array[4], 1);
-  ASSERT_LE(array[5], 8);
-  ASSERT_LE(array[6], 10);
-  ASSERT_LE(array[7], 11);
-  ASSERT_LE(array[8], 12);
-  ASSERT_LE(array[9], 23);
-  ASSERT_LE(array[10], 35);
-  ASSERT_LE(array[11], 40);
-  ASSERT_LE(array[12], 45);
-  ASSERT_LE(array[13], 55);
-  ASSERT_LE(array[14], 60);
-  ASSERT_LE(array[15], 70);
-  ASSERT_LE(array[16], 80);
-  ASSERT_LE(array[17], 90);
-  ASSERT_LE(array[18], 100);
-  ASSERT_LE(array[19], 110);
-  ASSERT_LE(array[20], 123);
-  ASSERT_LE(array[21], 171);
-  ASSERT_LE(array[22], 1155);
-  ASSERT_LE(array[23], 1170);
-  ASSERT_LE(array[24], 1171);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedArray2) {
-  int array[7] = {10, 40, 45, 55, 35, 23, 60};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 10);
-  ASSERT_LE(array[1], 23);
-  ASSERT_LE(array[2], 35);
-  ASSERT_LE(array[3], 40);
-  ASSERT_LE(array[4], 45);
-  ASSERT_LE(array[5], 55);
-  ASSERT_LE(array[6], 60);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedArrayDuplicateElements1) {
-  int array[6] = {10, 10, 20, 20, 5, 5};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 5);
-  ASSERT_LE(array[1], 5);
-  ASSERT_LE(array[2], 10);
-  ASSERT_LE(array[3], 10);
-  ASSERT_LE(array[4], 20);
-  ASSERT_LE(array[5], 20);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedArrayDuplicateElements2) {
-  int array[10] = {20, 10, 10, 10, 10, 20, 21, 21, 21, 21};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 10);
-  ASSERT_LE(array[1], 10);
-  ASSERT_LE(array[2], 10);
-  ASSERT_LE(array[3], 10);
-  ASSERT_LE(array[4], 20);
-  ASSERT_LE(array[5], 20);
-  ASSERT_LE(array[6], 21);
-  ASSERT_LE(array[7], 21);
-  ASSERT_LE(array[8], 21);
-  ASSERT_LE(array[9], 21);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedArrayDuplicateElements3) {
-  int array[10] = {20, 30, 30, 30, 30, 20, 21, 21, 21, 21};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 20);
-  ASSERT_LE(array[1], 20);
-  ASSERT_LE(array[2], 21);
-  ASSERT_LE(array[3], 21);
-  ASSERT_LE(array[4], 21);
-  ASSERT_LE(array[5], 21);
-  ASSERT_LE(array[6], 30);
-  ASSERT_LE(array[7], 30);
-  ASSERT_LE(array[8], 30);
-  ASSERT_LE(array[9], 30);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedThreeElementArray1) {
-  int array[3] = {14999024, 0, 3};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 0);
-  ASSERT_LE(array[1], 3);
-  ASSERT_LE(array[2], 14999024);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedThreeElementArray2) {
-  int array[3] = {3, 14999024, 0};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 0);
-  ASSERT_LE(array[1], 3);
-  ASSERT_LE(array[2], 14999024);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedThreeElementArray3) {
-  int array[3] = {3, 0, 14999024};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 0);
-  ASSERT_LE(array[1], 3);
-  ASSERT_LE(array[2], 14999024);
-}
-
-TEST(LlvmLibcQsortTest, SameElementThreeElementArray) {
-  int array[3] = {12345, 12345, 12345};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 12345);
-  ASSERT_LE(array[1], 12345);
-  ASSERT_LE(array[2], 12345);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedTwoElementArray1) {
-  int array[2] = {14999024, 0};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 0);
-  ASSERT_LE(array[1], 14999024);
-}
-
-TEST(LlvmLibcQsortTest, UnsortedTwoElementArray2) {
-  int array[2] = {0, 14999024};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 0);
-  ASSERT_LE(array[1], 14999024);
-}
-
-TEST(LlvmLibcQsortTest, SameElementTwoElementArray) {
-  int array[2] = {12345, 12345};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], 12345);
-  ASSERT_LE(array[1], 12345);
-}
-
-TEST(LlvmLibcQSortTest, SingleElementArray) {
-  constexpr int ELEM = 12345;
-  int array[1] = {ELEM};
-  constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-  LIBC_NAMESPACE::qsort(array, ARRAY_SIZE, sizeof(int), int_compare);
-
-  ASSERT_LE(array[0], ELEM);
-}
+LIST_SORTING_TESTS(Qsort, sort);
diff --git a/test/src/stdlib/quick_sort_test.cpp b/test/src/stdlib/quick_sort_test.cpp
new file mode 100644
index 0000000..d6bf77e
--- /dev/null
+++ b/test/src/stdlib/quick_sort_test.cpp
@@ -0,0 +1,16 @@
+//===-- Unittests for quick sort ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SortingTest.h"
+#include "src/stdlib/quick_sort.h"
+
+void sort(const LIBC_NAMESPACE::internal::Array &array) {
+  LIBC_NAMESPACE::internal::quick_sort(array);
+}
+
+LIST_SORTING_TESTS(QuickSort, sort);
diff --git a/test/src/stdlib/rand_test.cpp b/test/src/stdlib/rand_test.cpp
index 7934dc1..c8672d4 100644
--- a/test/src/stdlib/rand_test.cpp
+++ b/test/src/stdlib/rand_test.cpp
@@ -11,7 +11,6 @@
 #include "test/UnitTest/Test.h"
 
 #include <stddef.h>
-#include <stdlib.h>
 
 TEST(LlvmLibcRandTest, UnsetSeed) {
   static int vals[1000];
@@ -23,15 +22,12 @@ TEST(LlvmLibcRandTest, UnsetSeed) {
     vals[i] = val;
   }
 
-  // FIXME: The GPU implementation cannot initialize the seed correctly.
-#ifndef LIBC_TARGET_ARCH_IS_GPU
   // The C standard specifies that if 'srand' is never called it should behave
   // as if 'srand' was called with a value of 1. If we seed the value with 1 we
   // should get the same sequence as the unseeded version.
   LIBC_NAMESPACE::srand(1);
   for (size_t i = 0; i < 1000; ++i)
     ASSERT_EQ(LIBC_NAMESPACE::rand(), vals[i]);
-#endif
 }
 
 TEST(LlvmLibcRandTest, SetSeed) {
diff --git a/test/src/stdlib/strtof_test.cpp b/test/src/stdlib/strtof_test.cpp
index d799174..6a716c9 100644
--- a/test/src/stdlib/strtof_test.cpp
+++ b/test/src/stdlib/strtof_test.cpp
@@ -200,7 +200,7 @@ TEST_F(LlvmLibcStrToFTest, NaNWithParenthesesValidSequenceInvalidNumberTests) {
   run_test("NaN(1a)", 7, 0x7fc00000);
   run_test("NaN(asdf)", 9, 0x7fc00000);
   run_test("NaN(1A1)", 8, 0x7fc00000);
-  run_test("NaN(why_does_this_work)", 23, 0x7fc00000);
+  run_test("NaN(underscores_are_ok)", 23, 0x7fc00000);
   run_test(
       "NaN(1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_)",
       68, 0x7fc00000);
diff --git a/test/src/stdlib/strtoint32_test.cpp b/test/src/stdlib/strtoint32_test.cpp
index a7c9141..17df432 100644
--- a/test/src/stdlib/strtoint32_test.cpp
+++ b/test/src/stdlib/strtoint32_test.cpp
@@ -8,13 +8,14 @@
 
 #include <stdint.h>
 
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
 #include "StrtolTest.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int32_t strtoint32(const char *__restrict str, char **__restrict str_end,
                    int base) {
@@ -39,7 +40,7 @@ uint32_t strtouint32(const char *__restrict str, char **__restrict str_end,
 
   return result;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 STRTOL_TEST(Strtoint32, LIBC_NAMESPACE::strtoint32)
 STRTOL_TEST(Strtouint32, LIBC_NAMESPACE::strtouint32)
diff --git a/test/src/stdlib/strtoint64_test.cpp b/test/src/stdlib/strtoint64_test.cpp
index 350b5ac..b5fe69d 100644
--- a/test/src/stdlib/strtoint64_test.cpp
+++ b/test/src/stdlib/strtoint64_test.cpp
@@ -8,13 +8,14 @@
 
 #include <stdint.h>
 
+#include "src/__support/macros/config.h"
 #include "src/__support/str_to_integer.h"
 #include "src/errno/libc_errno.h"
 
 #include "StrtolTest.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 int64_t strtoint64(const char *__restrict str, char **__restrict str_end,
                    int base) {
@@ -39,7 +40,7 @@ uint64_t strtouint64(const char *__restrict str, char **__restrict str_end,
 
   return result;
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 STRTOL_TEST(Strtoint64, LIBC_NAMESPACE::strtoint64)
 STRTOL_TEST(Strtouint64, LIBC_NAMESPACE::strtouint64)
diff --git a/test/src/stdlib/strtold_test.cpp b/test/src/stdlib/strtold_test.cpp
index 2c9f542..b209c85 100644
--- a/test/src/stdlib/strtold_test.cpp
+++ b/test/src/stdlib/strtold_test.cpp
@@ -75,8 +75,9 @@ public:
     //         +-- 15 Exponent Bits
     char *str_end = nullptr;
 
-    LIBC_NAMESPACE::fputil::FPBits<long double> expected_fp =
-        LIBC_NAMESPACE::fputil::FPBits<long double>(expectedRawData);
+    using FPBits = LIBC_NAMESPACE::fputil::FPBits<long double>;
+    FPBits expected_fp =
+        FPBits(static_cast<FPBits::StorageType>(expectedRawData));
     const int expected_errno = expectedErrno;
 
     LIBC_NAMESPACE::libc_errno = 0;
diff --git a/test/src/string/StrchrTest.h b/test/src/string/StrchrTest.h
index 74e172d..8c3fe52 100644
--- a/test/src/string/StrchrTest.h
+++ b/test/src/string/StrchrTest.h
@@ -40,14 +40,16 @@ template <auto Func> struct StrchrTest : public LIBC_NAMESPACE::testing::Test {
     const char *src = "abcde";
 
     // Should return null terminator.
-    ASSERT_STREQ(Func(src, '\0'), "");
+    const char *nul_terminator = Func(src, '\0');
+    ASSERT_NE(nul_terminator, nullptr);
+    ASSERT_STREQ(nul_terminator, "");
     // Source string should not change.
     ASSERT_STREQ(src, "abcde");
   }
 
   void characterNotWithinStringShouldReturnNullptr() {
     // Since 'z' is not within the string, should return nullptr.
-    ASSERT_STREQ(Func("123?", 'z'), nullptr);
+    ASSERT_EQ(Func("123?", 'z'), nullptr);
   }
 
   void theSourceShouldNotChange() {
@@ -74,11 +76,13 @@ template <auto Func> struct StrchrTest : public LIBC_NAMESPACE::testing::Test {
 
   void emptyStringShouldOnlyMatchNullTerminator() {
     // Null terminator should match.
-    ASSERT_STREQ(Func("", '\0'), "");
+    const char empty_string[] = "";
+    ASSERT_EQ(static_cast<const char *>(Func(empty_string, '\0')),
+              empty_string);
     // All other characters should not match.
-    ASSERT_STREQ(Func("", 'Z'), nullptr);
-    ASSERT_STREQ(Func("", '3'), nullptr);
-    ASSERT_STREQ(Func("", '*'), nullptr);
+    ASSERT_EQ(Func("", 'Z'), nullptr);
+    ASSERT_EQ(Func("", '3'), nullptr);
+    ASSERT_EQ(Func("", '*'), nullptr);
   }
 };
 
@@ -114,7 +118,9 @@ template <auto Func> struct StrrchrTest : public LIBC_NAMESPACE::testing::Test {
     const char *src = "abcde";
 
     // Should return null terminator.
-    ASSERT_STREQ(Func(src, '\0'), "");
+    const char *nul_terminator = Func(src, '\0');
+    ASSERT_NE(nul_terminator, nullptr);
+    ASSERT_STREQ(nul_terminator, "");
     // Source string should not change.
     ASSERT_STREQ(src, "abcde");
   }
@@ -122,9 +128,9 @@ template <auto Func> struct StrrchrTest : public LIBC_NAMESPACE::testing::Test {
   void findsLastBehindFirstNullTerminator() {
     static const char src[6] = {'a', 'a', '\0', 'b', '\0', 'c'};
     // 'b' is behind a null terminator, so should not be found.
-    ASSERT_STREQ(Func(src, 'b'), nullptr);
+    ASSERT_EQ(Func(src, 'b'), nullptr);
     // Same goes for 'c'.
-    ASSERT_STREQ(Func(src, 'c'), nullptr);
+    ASSERT_EQ(Func(src, 'c'), nullptr);
 
     // Should find the second of the two a's.
     ASSERT_STREQ(Func(src, 'a'), "a");
@@ -132,7 +138,7 @@ template <auto Func> struct StrrchrTest : public LIBC_NAMESPACE::testing::Test {
 
   void characterNotWithinStringShouldReturnNullptr() {
     // Since 'z' is not within the string, should return nullptr.
-    ASSERT_STREQ(Func("123?", 'z'), nullptr);
+    ASSERT_EQ(Func("123?", 'z'), nullptr);
   }
 
   void shouldFindLastOfDuplicates() {
@@ -146,11 +152,13 @@ template <auto Func> struct StrrchrTest : public LIBC_NAMESPACE::testing::Test {
 
   void emptyStringShouldOnlyMatchNullTerminator() {
     // Null terminator should match.
-    ASSERT_STREQ(Func("", '\0'), "");
+    const char empty_string[] = "";
+    ASSERT_EQ(static_cast<const char *>(Func(empty_string, '\0')),
+              empty_string);
     // All other characters should not match.
-    ASSERT_STREQ(Func("", 'A'), nullptr);
-    ASSERT_STREQ(Func("", '2'), nullptr);
-    ASSERT_STREQ(Func("", '*'), nullptr);
+    ASSERT_EQ(Func("", 'A'), nullptr);
+    ASSERT_EQ(Func("", '2'), nullptr);
+    ASSERT_EQ(Func("", '*'), nullptr);
   }
 };
 
diff --git a/test/src/string/bcmp_test.cpp b/test/src/string/bcmp_test.cpp
index fa89e4d..c639040 100644
--- a/test/src/string/bcmp_test.cpp
+++ b/test/src/string/bcmp_test.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/bcmp.h"
 #include "test/UnitTest/Test.h"
 #include "test/UnitTest/TestLogger.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcBcmpTest, CmpZeroByte) {
   const char *lhs = "ab";
@@ -57,4 +58,4 @@ TEST(LlvmLibcBcmpTest, SizeSweep) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/bcopy_test.cpp b/test/src/string/bcopy_test.cpp
index f8cb920..04772bb 100644
--- a/test/src/string/bcopy_test.cpp
+++ b/test/src/string/bcopy_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include "src/string/bcopy.h"
 
 #include "memory_utils/memory_check_utils.h"
@@ -16,7 +17,7 @@
 using LIBC_NAMESPACE::cpp::array;
 using LIBC_NAMESPACE::cpp::span;
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcBcopyTest, MoveZeroByte) {
   char Buffer[] = {'a', 'b', 'y', 'z'};
@@ -95,4 +96,4 @@ TEST(LlvmLibcBcopyTest, SizeSweep) {
     }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/bzero_test.cpp b/test/src/string/bzero_test.cpp
index 7382490..a240436 100644
--- a/test/src/string/bzero_test.cpp
+++ b/test/src/string/bzero_test.cpp
@@ -7,10 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/bzero.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Adapt CheckMemset signature to bzero.
 static inline void Adaptor(cpp::span<char> p1, uint8_t value, size_t size) {
@@ -26,4 +27,4 @@ TEST(LlvmLibcBzeroTest, SizeSweep) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memcmp_test.cpp b/test/src/string/memcmp_test.cpp
index ca7a5c7..9f85a6d 100644
--- a/test/src/string/memcmp_test.cpp
+++ b/test/src/string/memcmp_test.cpp
@@ -7,11 +7,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memcmp.h"
 #include "test/UnitTest/Test.h"
 #include "test/UnitTest/TestLogger.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcMemcmpTest, CmpZeroByte) {
   const char *lhs = "ab";
@@ -64,4 +65,4 @@ TEST(LlvmLibcMemcmpTest, SizeSweep) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memcpy_test.cpp b/test/src/string/memcpy_test.cpp
index 1ac9631..adf6ef7 100644
--- a/test/src/string/memcpy_test.cpp
+++ b/test/src/string/memcpy_test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/os.h" // LIBC_TARGET_OS_IS_LINUX
 #include "src/string/memcpy.h"
 #include "test/UnitTest/Test.h"
@@ -15,7 +16,7 @@
 #include "memory_utils/protected_pages.h"
 #endif // !defined(LIBC_FULL_BUILD) && defined(LIBC_TARGET_OS_IS_LINUX)
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Adapt CheckMemcpy signature to memcpy.
 static inline void Adaptor(cpp::span<char> dst, cpp::span<char> src,
@@ -71,4 +72,4 @@ TEST(LlvmLibcMemcpyTest, CheckAccess) {
 
 #endif // !defined(LIBC_FULL_BUILD) && defined(LIBC_TARGET_OS_IS_LINUX)
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memmem_test.cpp b/test/src/string/memmem_test.cpp
index 56d4b7f..539f6a1 100644
--- a/test/src/string/memmem_test.cpp
+++ b/test/src/string/memmem_test.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include "src/string/memmem.h"
 #include "test/UnitTest/Test.h"
 
 #include "src/string/string_utils.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcMemmemTest, EmptyHaystackEmptyNeedleReturnsHaystck) {
   char *h = nullptr;
@@ -126,4 +127,4 @@ TEST(LlvmLibcMemmemTest, ReturnNullIfInadequateHaystackLength) {
     ASSERT_EQ(result, static_cast<void *>(nullptr));
   }
 }
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memmove_test.cpp b/test/src/string/memmove_test.cpp
index b076e86..e280b5d 100644
--- a/test/src/string/memmove_test.cpp
+++ b/test/src/string/memmove_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/config.h"
 #include "src/string/memmove.h"
 
 #include "memory_utils/memory_check_utils.h"
@@ -16,7 +17,7 @@
 using LIBC_NAMESPACE::cpp::array;
 using LIBC_NAMESPACE::cpp::span;
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 TEST(LlvmLibcMemmoveTest, MoveZeroByte) {
   char Buffer[] = {'a', 'b', 'y', 'z'};
@@ -101,4 +102,4 @@ TEST(LlvmLibcMemmoveTest, SizeSweep) {
     }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memory_utils/memory_check_utils.h b/test/src/string/memory_utils/memory_check_utils.h
index 9504230..3ddd15b 100644
--- a/test/src/string/memory_utils/memory_check_utils.h
+++ b/test/src/string/memory_utils/memory_check_utils.h
@@ -11,13 +11,14 @@
 
 #include "src/__support/CPP/span.h"
 #include "src/__support/libc_assert.h" // LIBC_ASSERT
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/sanitizer.h"
 #include "src/string/memory_utils/utils.h"
 #include <stddef.h> // size_t
 #include <stdint.h> // uintxx_t
 #include <stdlib.h> // malloc/free
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Simple structure to allocate a buffer of a particular size.
 // When ASAN is present it also poisons the whole memory.
@@ -198,6 +199,6 @@ inline bool CheckMemmove(cpp::span<char> buffer, size_t size, int overlap) {
   return true;
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LIBC_TEST_SRC_STRING_MEMORY_UTILS_MEMORY_CHECK_UTILS_H
diff --git a/test/src/string/memory_utils/op_tests.cpp b/test/src/string/memory_utils/op_tests.cpp
index 703a26b..c6197d1 100644
--- a/test/src/string/memory_utils/op_tests.cpp
+++ b/test/src/string/memory_utils/op_tests.cpp
@@ -7,6 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_check_utils.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/os.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT64
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_builtin.h"
@@ -15,7 +17,7 @@
 #include "src/string/memory_utils/op_x86.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 template <typename T> struct has_head_tail {
   template <typename C> static char sfinae(decltype(&C::head_tail));
@@ -191,6 +193,13 @@ TYPED_TEST(LlvmLibcOpTest, Memset, MemsetImplementations) {
   }
 }
 
+#ifdef LIBC_TARGET_ARCH_IS_X86_64
+// Prevent GCC warning due to ignored __aligned__ attributes when passing x86
+// SIMD types as template arguments.
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wignored-attributes"
+#endif // LIBC_TARGET_ARCH_IS_X86_64
+
 using BcmpImplementations = testing::TypeList<
 #ifdef LIBC_TARGET_ARCH_IS_X86_64
 #ifdef __SSE4_1__
@@ -223,6 +232,10 @@ using BcmpImplementations = testing::TypeList<
     generic::BcmpSequence<uint8_t, uint8_t, uint8_t>, //
     generic::Bcmp<uint8_t>>;
 
+#ifdef LIBC_TARGET_ARCH_IS_X86_64
+#pragma GCC diagnostic pop
+#endif // LIBC_TARGET_ARCH_IS_X86_64
+
 // Adapt CheckBcmp signature to op implementation signatures.
 template <auto FnImpl>
 int CmpAdaptor(cpp::span<char> p1, cpp::span<char> p2, size_t size) {
@@ -274,8 +287,15 @@ TYPED_TEST(LlvmLibcOpTest, Bcmp, BcmpImplementations) {
   }
 }
 
-using MemcmpImplementations = testing::TypeList<
 #ifdef LIBC_TARGET_ARCH_IS_X86_64
+// Prevent GCC warning due to ignored __aligned__ attributes when passing x86
+// SIMD types as template arguments.
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wignored-attributes"
+#endif // LIBC_TARGET_ARCH_IS_X86_64
+
+using MemcmpImplementations = testing::TypeList<
+#if defined(LIBC_TARGET_ARCH_IS_X86_64) && !defined(LIBC_TARGET_OS_IS_WINDOWS)
 #ifdef __SSE2__
     generic::Memcmp<__m128i>, //
 #endif
@@ -303,6 +323,10 @@ using MemcmpImplementations = testing::TypeList<
     generic::MemcmpSequence<uint8_t, uint8_t, uint8_t>,
     generic::Memcmp<uint8_t>>;
 
+#ifdef LIBC_TARGET_ARCH_IS_X86_64
+#pragma GCC diagnostic pop
+#endif // LIBC_TARGET_ARCH_IS_X86_64
+
 TYPED_TEST(LlvmLibcOpTest, Memcmp, MemcmpImplementations) {
   using Impl = ParamType;
   constexpr size_t kSize = Impl::SIZE;
@@ -344,4 +368,4 @@ TYPED_TEST(LlvmLibcOpTest, Memcmp, MemcmpImplementations) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memory_utils/utils_test.cpp b/test/src/string/memory_utils/utils_test.cpp
index 5ed35b0..4c1accd 100644
--- a/test/src/string/memory_utils/utils_test.cpp
+++ b/test/src/string/memory_utils/utils_test.cpp
@@ -7,10 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/array.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memory_utils/utils.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 using UINT = uintptr_t;
 
@@ -137,4 +138,4 @@ TEST(LlvmLibcUtilsTest, LoadStoreAligned) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memset_explicit_test.cpp b/test/src/string/memset_explicit_test.cpp
index bb5111b..4842f45 100644
--- a/test/src/string/memset_explicit_test.cpp
+++ b/test/src/string/memset_explicit_test.cpp
@@ -7,10 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/string/memset_explicit.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Apply the same tests as memset
 
@@ -28,4 +29,4 @@ TEST(LlvmLibcmemsetExplicitTest, SizeSweep) {
   }
 }
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/memset_test.cpp b/test/src/string/memset_test.cpp
index d78b579..774a321 100644
--- a/test/src/string/memset_test.cpp
+++ b/test/src/string/memset_test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "memory_utils/memory_check_utils.h"
+#include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/os.h" // LIBC_TARGET_OS_IS_LINUX
 #include "src/string/memset.h"
 #include "test/UnitTest/Test.h"
@@ -15,7 +16,7 @@
 #include "memory_utils/protected_pages.h"
 #endif // !defined(LIBC_FULL_BUILD) && defined(LIBC_TARGET_OS_IS_LINUX)
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 
 // Adapt CheckMemset signature to memset.
 static inline void Adaptor(cpp::span<char> p1, uint8_t value, size_t size) {
@@ -58,4 +59,4 @@ TEST(LlvmLibcMemsetTest, CheckAccess) {
 
 #endif // !defined(LIBC_FULL_BUILD) && defined(LIBC_TARGET_OS_IS_LINUX)
 
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/strdup_test.cpp b/test/src/string/strdup_test.cpp
index fd3ccea..20b85c3 100644
--- a/test/src/string/strdup_test.cpp
+++ b/test/src/string/strdup_test.cpp
@@ -10,8 +10,6 @@
 #include "src/string/strdup.h"
 #include "test/UnitTest/Test.h"
 
-#include <stdlib.h>
-
 TEST(LlvmLibcStrDupTest, EmptyString) {
   const char *empty = "";
 
diff --git a/test/src/string/strerror_test.cpp b/test/src/string/strerror_test.cpp
index cfc7948..6c59c70 100644
--- a/test/src/string/strerror_test.cpp
+++ b/test/src/string/strerror_test.cpp
@@ -6,153 +6,16 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/StringUtil/platform_errors.h"
+#include "src/__support/macros/properties/architectures.h"
 #include "src/string/strerror.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStrErrorTest, KnownErrors) {
   ASSERT_STREQ(LIBC_NAMESPACE::strerror(0), "Success");
 
-  const char *message_array[] = {
-      "Success",
-      "Operation not permitted",
-      "No such file or directory",
-      "No such process",
-      "Interrupted system call",
-      "Input/output error",
-      "No such device or address",
-      "Argument list too long",
-      "Exec format error",
-      "Bad file descriptor",
-      "No child processes",
-      "Resource temporarily unavailable",
-      "Cannot allocate memory",
-      "Permission denied",
-      "Bad address",
-      "Block device required",
-      "Device or resource busy",
-      "File exists",
-      "Invalid cross-device link",
-      "No such device",
-      "Not a directory",
-      "Is a directory",
-      "Invalid argument",
-      "Too many open files in system",
-      "Too many open files",
-      "Inappropriate ioctl for device",
-      "Text file busy",
-      "File too large",
-      "No space left on device",
-      "Illegal seek",
-      "Read-only file system",
-      "Too many links",
-      "Broken pipe",
-      "Numerical argument out of domain",
-      "Numerical result out of range",
-      "Resource deadlock avoided",
-      "File name too long",
-      "No locks available",
-      "Function not implemented",
-      "Directory not empty",
-      "Too many levels of symbolic links",
-      "Unknown error 41", // Unknown
-      "No message of desired type",
-      "Identifier removed",
-      "Channel number out of range",
-      "Level 2 not synchronized",
-      "Level 3 halted",
-      "Level 3 reset",
-      "Link number out of range",
-      "Protocol driver not attached",
-      "No CSI structure available",
-      "Level 2 halted",
-      "Invalid exchange",
-      "Invalid request descriptor",
-      "Exchange full",
-      "No anode",
-      "Invalid request code",
-      "Invalid slot",
-      "Unknown error 58", // Unknown
-      "Bad font file format",
-      "Device not a stream",
-      "No data available",
-      "Timer expired",
-      "Out of streams resources",
-      "Machine is not on the network",
-      "Package not installed",
-      "Object is remote",
-      "Link has been severed",
-      "Advertise error",
-      "Srmount error",
-      "Communication error on send",
-      "Protocol error",
-      "Multihop attempted",
-      "RFS specific error",
-      "Bad message",
-      "Value too large for defined data type",
-      "Name not unique on network",
-      "File descriptor in bad state",
-      "Remote address changed",
-      "Can not access a needed shared library",
-      "Accessing a corrupted shared library",
-      ".lib section in a.out corrupted",
-      "Attempting to link in too many shared libraries",
-      "Cannot exec a shared library directly",
-      "Unknown error 84", // Unknown
-      "Interrupted system call should be restarted",
-      "Streams pipe error",
-      "Too many users",
-      "Socket operation on non-socket",
-      "Destination address required",
-      "Message too long",
-      "Protocol wrong type for socket",
-      "Protocol not available",
-      "Protocol not supported",
-      "Socket type not supported",
-      "Operation not supported",
-      "Protocol family not supported",
-      "Address family not supported by protocol",
-      "Address already in use",
-      "Cannot assign requested address",
-      "Network is down",
-      "Network is unreachable",
-      "Network dropped connection on reset",
-      "Software caused connection abort",
-      "Connection reset by peer",
-      "No buffer space available",
-      "Transport endpoint is already connected",
-      "Transport endpoint is not connected",
-      "Cannot send after transport endpoint shutdown",
-      "Too many references: cannot splice",
-      "Connection timed out",
-      "Connection refused",
-      "Host is down",
-      "No route to host",
-      "Operation already in progress",
-      "Operation now in progress",
-      "Stale file handle",
-      "Structure needs cleaning",
-      "Not a XENIX named type file",
-      "No XENIX semaphores available",
-      "Is a named type file",
-      "Remote I/O error",
-      "Disk quota exceeded",
-      "No medium found",
-      "Wrong medium type",
-      "Operation canceled",
-      "Required key not available",
-      "Key has expired",
-      "Key has been revoked",
-      "Key was rejected by service",
-      "Owner died",
-      "State not recoverable",
-      "Operation not possible due to RF-kill",
-      "Memory page has hardware error",
-  };
-
-  for (size_t i = 0; i < (sizeof(message_array) / sizeof(char *)); ++i) {
-    EXPECT_STREQ(LIBC_NAMESPACE::strerror(static_cast<int>(i)),
-                 message_array[i]);
-  }
+  for (auto [i, msg] : LIBC_NAMESPACE::PLATFORM_ERRORS)
+    EXPECT_STREQ(LIBC_NAMESPACE::strerror(static_cast<int>(i)), msg.begin());
 }
 
 TEST(LlvmLibcStrErrorTest, UnknownErrors) {
diff --git a/test/src/string/strlcat_test.cpp b/test/src/string/strlcat_test.cpp
index 1ffa4b0..0829737 100644
--- a/test/src/string/strlcat_test.cpp
+++ b/test/src/string/strlcat_test.cpp
@@ -8,7 +8,6 @@
 
 #include "src/string/strlcat.h"
 #include "test/UnitTest/Test.h"
-#include <stdlib.h>
 
 TEST(LlvmLibcStrlcatTest, TooBig) {
   const char *str = "cd";
@@ -27,6 +26,15 @@ TEST(LlvmLibcStrlcatTest, Smaller) {
   EXPECT_STREQ(buf, "abcd");
 }
 
+TEST(LlvmLibcStrlcatTest, SmallerNoOverwriteAfter0) {
+  const char *str = "cd";
+  char buf[8]{"ab\0\0efg"};
+
+  EXPECT_EQ(LIBC_NAMESPACE::strlcat(buf, str, 8), size_t(4));
+  EXPECT_STREQ(buf, "abcd");
+  EXPECT_STREQ(buf + 5, "fg");
+}
+
 TEST(LlvmLibcStrlcatTest, No0) {
   const char *str = "cd";
   char buf[7]{"ab"};
diff --git a/test/src/string/strlcpy_test.cpp b/test/src/string/strlcpy_test.cpp
index 5a1e30c..0914257 100644
--- a/test/src/string/strlcpy_test.cpp
+++ b/test/src/string/strlcpy_test.cpp
@@ -8,7 +8,6 @@
 
 #include "src/string/strlcpy.h"
 #include "test/UnitTest/Test.h"
-#include <stdlib.h>
 
 TEST(LlvmLibcStrlcpyTest, TooBig) {
   const char *str = "abc";
@@ -25,6 +24,5 @@ TEST(LlvmLibcStrlcpyTest, Smaller) {
 
   EXPECT_EQ(LIBC_NAMESPACE::strlcpy(buf, str, 7), size_t(3));
   EXPECT_STREQ(buf, "abc");
-  for (const char *p = buf + 3; p < buf + 7; p++)
-    EXPECT_EQ(*p, '\0');
+  EXPECT_STREQ(buf + 4, "11");
 }
diff --git a/test/src/string/strndup_test.cpp b/test/src/string/strndup_test.cpp
index 3adcd9b..3e7129b 100644
--- a/test/src/string/strndup_test.cpp
+++ b/test/src/string/strndup_test.cpp
@@ -8,7 +8,6 @@
 
 #include "src/string/strndup.h"
 #include "test/UnitTest/Test.h"
-#include <stdlib.h>
 
 TEST(LlvmLibcstrndupTest, EmptyString) {
   const char *empty = "";
diff --git a/test/src/sys/epoll/linux/epoll_create_test.cpp b/test/src/sys/epoll/linux/epoll_create_test.cpp
index fdcdcf8..9c4bad1 100644
--- a/test/src/sys/epoll/linux/epoll_create_test.cpp
+++ b/test/src/sys/epoll/linux/epoll_create_test.cpp
@@ -10,6 +10,7 @@
 #include "src/unistd/close.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
+#include <sys/syscall.h> // For syscall numbers.
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
 
@@ -21,6 +22,8 @@ TEST(LlvmLibcEpollCreateTest, Basic) {
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
 }
 
+#ifdef SYS_epoll_create
 TEST(LlvmLibcEpollCreateTest, Fails) {
   ASSERT_THAT(LIBC_NAMESPACE::epoll_create(0), Fails(EINVAL));
 }
+#endif
diff --git a/test/src/sys/mman/linux/mincore_test.cpp b/test/src/sys/mman/linux/mincore_test.cpp
index 8e0c29c..e49e300 100644
--- a/test/src/sys/mman/linux/mincore_test.cpp
+++ b/test/src/sys/mman/linux/mincore_test.cpp
@@ -16,7 +16,6 @@
 #include "src/sys/mman/munmap.h"
 #include "src/unistd/sysconf.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/mman.h>
diff --git a/test/src/sys/mman/linux/mlock_test.cpp b/test/src/sys/mman/linux/mlock_test.cpp
index 804038a..48cde13 100644
--- a/test/src/sys/mman/linux/mlock_test.cpp
+++ b/test/src/sys/mman/linux/mlock_test.cpp
@@ -20,11 +20,8 @@
 #include "src/sys/resource/getrlimit.h"
 #include "src/unistd/sysconf.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
 #include "test/UnitTest/Test.h"
 
-#include <asm-generic/errno-base.h>
-#include <asm-generic/mman.h>
 #include <linux/capability.h>
 #include <sys/mman.h>
 #include <sys/resource.h>
diff --git a/test/src/sys/mman/linux/mremap_test.cpp b/test/src/sys/mman/linux/mremap_test.cpp
new file mode 100644
index 0000000..12e4485
--- /dev/null
+++ b/test/src/sys/mman/linux/mremap_test.cpp
@@ -0,0 +1,68 @@
+//===-- Unittests for mremap ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/sys/mman/mmap.h"
+#include "src/sys/mman/mremap.h"
+#include "src/sys/mman/munmap.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/mman.h>
+
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+
+TEST(LlvmLibcMremapTest, NoError) {
+  size_t initial_size = 128;
+  size_t new_size = 256;
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  // Allocate memory using mmap.
+  void *addr =
+      LIBC_NAMESPACE::mmap(nullptr, initial_size, PROT_READ | PROT_WRITE,
+                           MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+  ASSERT_ERRNO_SUCCESS();
+  EXPECT_NE(addr, MAP_FAILED);
+
+  int *array = reinterpret_cast<int *>(addr);
+  // Writing to the memory should not crash the test.
+  array[0] = 123;
+  EXPECT_EQ(array[0], 123);
+
+  // Re-map the memory using mremap with an increased size.
+  void *new_addr =
+      LIBC_NAMESPACE::mremap(addr, initial_size, new_size, MREMAP_MAYMOVE);
+  ASSERT_ERRNO_SUCCESS();
+  EXPECT_NE(new_addr, MAP_FAILED);
+  EXPECT_EQ(reinterpret_cast<int *>(new_addr)[0],
+            123); // Verify data is preserved.
+
+  // Clean up memory by unmapping it.
+  EXPECT_THAT(LIBC_NAMESPACE::munmap(new_addr, new_size), Succeeds());
+}
+
+TEST(LlvmLibcMremapTest, Error_InvalidSize) {
+  size_t initial_size = 128;
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  // Allocate memory using mmap.
+  void *addr =
+      LIBC_NAMESPACE::mmap(nullptr, initial_size, PROT_READ | PROT_WRITE,
+                           MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+  ASSERT_ERRNO_SUCCESS();
+  EXPECT_NE(addr, MAP_FAILED);
+
+  // Attempt to re-map the memory with an invalid new size (0).
+  void *new_addr =
+      LIBC_NAMESPACE::mremap(addr, initial_size, 0, MREMAP_MAYMOVE);
+  EXPECT_THAT(new_addr, Fails(EINVAL, MAP_FAILED));
+
+  // Clean up the original mapping.
+  EXPECT_THAT(LIBC_NAMESPACE::munmap(addr, initial_size), Succeeds());
+}
diff --git a/test/src/sys/mman/linux/msync_test.cpp b/test/src/sys/mman/linux/msync_test.cpp
index 0d60415..65eedb2 100644
--- a/test/src/sys/mman/linux/msync_test.cpp
+++ b/test/src/sys/mman/linux/msync_test.cpp
@@ -14,7 +14,6 @@
 #include "src/sys/mman/munmap.h"
 #include "src/unistd/sysconf.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
 #include "test/UnitTest/Test.h"
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
diff --git a/test/src/sys/mman/linux/process_mrelease_test.cpp b/test/src/sys/mman/linux/process_mrelease_test.cpp
new file mode 100644
index 0000000..71cde7a
--- /dev/null
+++ b/test/src/sys/mman/linux/process_mrelease_test.cpp
@@ -0,0 +1,70 @@
+//===-- Unittests for process_mrelease ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/errno/libc_errno.h"
+#include "src/signal/kill.h"
+#include "src/signal/raise.h"
+#include "src/stdlib/exit.h"
+#include "src/sys/mman/process_mrelease.h"
+#include "src/unistd/close.h"
+#include "src/unistd/fork.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/LibcTest.h"
+
+#include <sys/syscall.h>
+#if defined(SYS_process_mrelease) && defined(SYS_pidfd_open)
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+int pidfd_open(pid_t pid, unsigned int flags) {
+  return LIBC_NAMESPACE::syscall_impl(SYS_pidfd_open, pid, flags);
+}
+
+TEST(LlvmLibcProcessMReleaseTest, NoError) {
+  pid_t child_pid = fork();
+  EXPECT_GE(child_pid, 0);
+
+  if (child_pid == 0) {
+    // pause the child process
+    LIBC_NAMESPACE::raise(SIGSTOP);
+  } else {
+    // Parent process: wait a bit and then kill the child.
+    // Give child process some time to start.
+    int pidfd = pidfd_open(child_pid, 0);
+    EXPECT_GE(pidfd, 0);
+
+    // Send SIGKILL to child process
+    LIBC_NAMESPACE::kill(child_pid, SIGKILL);
+
+    EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(pidfd, 0), Succeeds());
+
+    LIBC_NAMESPACE::close(pidfd);
+  }
+}
+
+TEST(LlvmLibcProcessMReleaseTest, ErrorNotKilled) {
+  pid_t child_pid = fork();
+  EXPECT_GE(child_pid, 0);
+
+  if (child_pid == 0) {
+    // pause the child process
+    LIBC_NAMESPACE::raise(SIGSTOP);
+  } else {
+    int pidfd = pidfd_open(child_pid, 0);
+    EXPECT_GE(pidfd, 0);
+
+    EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(pidfd, 0), Fails(EINVAL));
+
+    LIBC_NAMESPACE::close(pidfd);
+  }
+}
+
+TEST(LlvmLibcProcessMReleaseTest, ErrorNonExistingPidfd) {
+  EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(-1, 0), Fails(EBADF));
+}
+#endif
diff --git a/test/src/sys/mman/linux/remap_file_pages_test.cpp b/test/src/sys/mman/linux/remap_file_pages_test.cpp
new file mode 100644
index 0000000..267f759
--- /dev/null
+++ b/test/src/sys/mman/linux/remap_file_pages_test.cpp
@@ -0,0 +1,93 @@
+//===-- Unittests for remap_file_pages ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/fcntl/open.h"
+#include "src/sys/mman/mmap.h"
+#include "src/sys/mman/munmap.h"
+#include "src/sys/mman/remap_file_pages.h"
+#include "src/unistd/close.h"
+#include "src/unistd/sysconf.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/mman.h>
+#include <sys/stat.h> // For S_IRWXU
+
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+
+TEST(LlvmLibcRemapFilePagesTest, NoError) {
+  size_t page_size = sysconf(_SC_PAGE_SIZE);
+  ASSERT_GT(page_size, size_t(0));
+
+  // Create a file-backed mapping
+  constexpr const char *file_name = "remap_file_pages.test.noerror";
+  auto test_file = libc_make_test_file_path(file_name);
+  int fd = LIBC_NAMESPACE::open(test_file, O_RDWR | O_CREAT, S_IRWXU);
+  ASSERT_GT(fd, 0);
+
+  // First, allocate some memory using mmap
+  size_t alloc_size = 2 * page_size;
+  LIBC_NAMESPACE::libc_errno = 0;
+  void *addr = LIBC_NAMESPACE::mmap(nullptr, alloc_size, PROT_READ | PROT_WRITE,
+                                    MAP_SHARED, fd, 0);
+  ASSERT_ERRNO_SUCCESS();
+  EXPECT_NE(addr, MAP_FAILED);
+
+  // Now try to remap the pages
+  EXPECT_THAT(LIBC_NAMESPACE::remap_file_pages(addr, page_size, 0, 1, 0),
+              Succeeds());
+
+  // Reset error number for the new function
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  // Clean up
+  EXPECT_THAT(LIBC_NAMESPACE::munmap(addr, alloc_size), Succeeds());
+  EXPECT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
+}
+
+TEST(LlvmLibcRemapFilePagesTest, ErrorInvalidFlags) {
+  size_t page_size = sysconf(_SC_PAGE_SIZE);
+  ASSERT_GT(page_size, size_t(0));
+
+  // Create a file-backed mapping
+  constexpr const char *file_name = "remap_file_pages.test.error";
+  auto test_file = libc_make_test_file_path(file_name);
+  int fd = LIBC_NAMESPACE::open(test_file, O_RDWR | O_CREAT, S_IRWXU);
+  ASSERT_GT(fd, 0);
+
+  // First, allocate some memory using mmap
+  size_t alloc_size = 2 * page_size;
+  LIBC_NAMESPACE::libc_errno = 0;
+  void *addr = LIBC_NAMESPACE::mmap(nullptr, alloc_size, PROT_READ | PROT_WRITE,
+                                    MAP_SHARED, fd, 0);
+  ASSERT_ERRNO_SUCCESS();
+  EXPECT_NE(addr, MAP_FAILED);
+
+  // Try to remap pages with an invalid flag MAP_PRIVATE
+  EXPECT_THAT(LIBC_NAMESPACE::remap_file_pages(addr, page_size, PROT_READ, 0,
+                                               MAP_PRIVATE),
+              Fails(EINVAL));
+
+  // Clean up
+  EXPECT_THAT(LIBC_NAMESPACE::munmap(addr, page_size), Succeeds());
+  EXPECT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
+}
+
+TEST(LlvmLibcRemapFilePagesTest, ErrorInvalidAddress) {
+  size_t page_size = sysconf(_SC_PAGESIZE);
+  ASSERT_GT(page_size, size_t(0));
+
+  // Use an address that we haven't mapped
+  void *invalid_addr = reinterpret_cast<void *>(0x12345000);
+
+  EXPECT_THAT(LIBC_NAMESPACE::remap_file_pages(invalid_addr, page_size,
+                                               PROT_READ, 0, 0),
+              Fails(EINVAL));
+}
diff --git a/test/src/sys/mman/linux/shm_test.cpp b/test/src/sys/mman/linux/shm_test.cpp
index 3b1a2aa..7f4be18 100644
--- a/test/src/sys/mman/linux/shm_test.cpp
+++ b/test/src/sys/mman/linux/shm_test.cpp
@@ -6,7 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/fcntl_macros.h"
 #include "src/__support/OSUtil/syscall.h"
+#include "src/fcntl/fcntl.h"
 #include "src/sys/mman/mmap.h"
 #include "src/sys/mman/munmap.h"
 #include "src/sys/mman/shm_open.h"
@@ -14,8 +16,7 @@
 #include "src/unistd/close.h"
 #include "src/unistd/ftruncate.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
-#include <asm-generic/fcntl.h>
+#include "test/UnitTest/Test.h"
 #include <sys/syscall.h>
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
@@ -29,9 +30,7 @@ TEST(LlvmLibcShmTest, Basic) {
               returns(GE(0)).with_errno(EQ(0)));
 
   // check that FD_CLOEXEC is set by default.
-  // TODO: use fcntl when implemented.
-  // https://github.com/llvm/llvm-project/issues/84968
-  long flag = LIBC_NAMESPACE::syscall_impl(SYS_fcntl, fd, F_GETFD);
+  long flag = LIBC_NAMESPACE::fcntl(fd, F_GETFD);
   ASSERT_GE(static_cast<int>(flag), 0);
   EXPECT_NE(static_cast<int>(flag) & FD_CLOEXEC, 0);
 
diff --git a/test/src/sys/prctl/linux/prctl_test.cpp b/test/src/sys/prctl/linux/prctl_test.cpp
index b528edc..987c35d 100644
--- a/test/src/sys/prctl/linux/prctl_test.cpp
+++ b/test/src/sys/prctl/linux/prctl_test.cpp
@@ -9,7 +9,6 @@
 #include "src/errno/libc_errno.h"
 #include "src/sys/prctl/prctl.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include <errno.h>
 #include <sys/prctl.h>
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
diff --git a/test/src/sys/select/select_failure_test.cpp b/test/src/sys/select/select_failure_test.cpp
index 61df532..a4990bf 100644
--- a/test/src/sys/select/select_failure_test.cpp
+++ b/test/src/sys/select/select_failure_test.cpp
@@ -11,7 +11,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <sys/select.h>
 #include <unistd.h>
 
diff --git a/test/src/sys/sendfile/sendfile_test.cpp b/test/src/sys/sendfile/sendfile_test.cpp
index 5902543..a658212 100644
--- a/test/src/sys/sendfile/sendfile_test.cpp
+++ b/test/src/sys/sendfile/sendfile_test.cpp
@@ -17,7 +17,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 namespace cpp = LIBC_NAMESPACE::cpp;
diff --git a/test/src/sys/socket/linux/send_recv_test.cpp b/test/src/sys/socket/linux/send_recv_test.cpp
new file mode 100644
index 0000000..a5d4880
--- /dev/null
+++ b/test/src/sys/socket/linux/send_recv_test.cpp
@@ -0,0 +1,73 @@
+//===-- Unittests for send/recv -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recv.h"
+#include "src/sys/socket/send.h"
+#include "src/sys/socket/socketpair.h"
+
+#include "src/unistd/close.h"
+
+#include "src/errno/libc_errno.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
+
+TEST(LlvmLibcSendRecvTest, SucceedsWithSocketPair) {
+  const char TEST_MESSAGE[] = "connection successful";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  int sockpair[2] = {0, 0};
+
+  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  ssize_t send_result =
+      LIBC_NAMESPACE::send(sockpair[0], TEST_MESSAGE, MESSAGE_LEN, 0);
+  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  char buffer[256];
+
+  ssize_t recv_result =
+      LIBC_NAMESPACE::recv(sockpair[1], buffer, sizeof(buffer), 0);
+  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  ASSERT_STREQ(buffer, TEST_MESSAGE);
+
+  // close both ends of the socket
+  result = LIBC_NAMESPACE::close(sockpair[0]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  result = LIBC_NAMESPACE::close(sockpair[1]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+}
+
+TEST(LlvmLibcSendRecvTest, SendFails) {
+  const char TEST_MESSAGE[] = "connection terminated";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  ssize_t send_result = LIBC_NAMESPACE::send(-1, TEST_MESSAGE, MESSAGE_LEN, 0);
+  EXPECT_EQ(send_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
+
+TEST(LlvmLibcSendRecvTest, RecvFails) {
+  char buffer[256];
+
+  ssize_t recv_result = LIBC_NAMESPACE::recv(-1, buffer, sizeof(buffer), 0);
+  ASSERT_EQ(recv_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
diff --git a/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp b/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp
new file mode 100644
index 0000000..abcb0a3
--- /dev/null
+++ b/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp
@@ -0,0 +1,125 @@
+//===-- Unittests for sendmsg/recvmsg -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recvmsg.h"
+#include "src/sys/socket/sendmsg.h"
+#include "src/sys/socket/socketpair.h"
+
+#include "src/unistd/close.h"
+
+#include "src/errno/libc_errno.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
+
+TEST(LlvmLibcSendMsgRecvMsgTest, SucceedsWithSocketPair) {
+  const char TEST_MESSAGE[] = "connection successful";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  int sockpair[2] = {0, 0};
+
+  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  iovec send_msg_text;
+  send_msg_text.iov_base =
+      reinterpret_cast<void *>(const_cast<char *>(TEST_MESSAGE));
+  send_msg_text.iov_len = MESSAGE_LEN;
+
+  msghdr send_message;
+  send_message.msg_name = nullptr;
+  send_message.msg_namelen = 0;
+  send_message.msg_iov = &send_msg_text;
+  send_message.msg_iovlen = 1;
+  send_message.msg_control = nullptr;
+  send_message.msg_controllen = 0;
+  send_message.msg_flags = 0;
+
+  ssize_t send_result = LIBC_NAMESPACE::sendmsg(sockpair[0], &send_message, 0);
+  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  char buffer[256];
+
+  iovec recv_msg_text;
+  recv_msg_text.iov_base = reinterpret_cast<void *>(buffer);
+  recv_msg_text.iov_len = sizeof(buffer);
+
+  msghdr recv_message;
+  recv_message.msg_name = nullptr;
+  recv_message.msg_namelen = 0;
+  recv_message.msg_iov = &recv_msg_text;
+  recv_message.msg_iovlen = 1;
+  recv_message.msg_control = nullptr;
+  recv_message.msg_controllen = 0;
+  recv_message.msg_flags = 0;
+
+  ssize_t recv_result = LIBC_NAMESPACE::recvmsg(sockpair[1], &recv_message, 0);
+  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  ASSERT_STREQ(buffer, TEST_MESSAGE);
+
+  // close both ends of the socket
+  result = LIBC_NAMESPACE::close(sockpair[0]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  result = LIBC_NAMESPACE::close(sockpair[1]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+}
+
+TEST(LlvmLibcSendMsgRecvMsgTest, SendFails) {
+  const char TEST_MESSAGE[] = "connection terminated";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  iovec send_msg_text;
+  send_msg_text.iov_base =
+      reinterpret_cast<void *>(const_cast<char *>(TEST_MESSAGE));
+  send_msg_text.iov_len = MESSAGE_LEN;
+
+  msghdr send_message;
+  send_message.msg_name = nullptr;
+  send_message.msg_namelen = 0;
+  send_message.msg_iov = &send_msg_text;
+  send_message.msg_iovlen = 1;
+  send_message.msg_control = nullptr;
+  send_message.msg_controllen = 0;
+  send_message.msg_flags = 0;
+
+  ssize_t send_result = LIBC_NAMESPACE::sendmsg(-1, &send_message, 0);
+  EXPECT_EQ(send_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
+
+TEST(LlvmLibcSendMsgRecvMsgTest, RecvFails) {
+  char buffer[256];
+
+  iovec recv_msg_text;
+  recv_msg_text.iov_base = reinterpret_cast<void *>(buffer);
+  recv_msg_text.iov_len = sizeof(buffer);
+
+  msghdr recv_message;
+  recv_message.msg_name = nullptr;
+  recv_message.msg_namelen = 0;
+  recv_message.msg_iov = &recv_msg_text;
+  recv_message.msg_iovlen = 1;
+  recv_message.msg_control = nullptr;
+  recv_message.msg_controllen = 0;
+  recv_message.msg_flags = 0;
+
+  ssize_t recv_result = LIBC_NAMESPACE::recvmsg(-1, &recv_message, 0);
+  ASSERT_EQ(recv_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
diff --git a/test/src/sys/socket/linux/sendto_recvfrom_test.cpp b/test/src/sys/socket/linux/sendto_recvfrom_test.cpp
new file mode 100644
index 0000000..e91b333
--- /dev/null
+++ b/test/src/sys/socket/linux/sendto_recvfrom_test.cpp
@@ -0,0 +1,75 @@
+//===-- Unittests for sendto/recvfrom -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/recvfrom.h"
+#include "src/sys/socket/sendto.h"
+#include "src/sys/socket/socketpair.h"
+
+#include "src/unistd/close.h"
+
+#include "src/errno/libc_errno.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
+
+TEST(LlvmLibcSendToRecvFromTest, SucceedsWithSocketPair) {
+  const char TEST_MESSAGE[] = "connection successful";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  int sockpair[2] = {0, 0};
+
+  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  ssize_t send_result = LIBC_NAMESPACE::sendto(sockpair[0], TEST_MESSAGE,
+                                               MESSAGE_LEN, 0, nullptr, 0);
+  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  char buffer[256];
+
+  ssize_t recv_result = LIBC_NAMESPACE::recvfrom(sockpair[1], buffer,
+                                                 sizeof(buffer), 0, nullptr, 0);
+  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
+  ASSERT_ERRNO_SUCCESS();
+
+  ASSERT_STREQ(buffer, TEST_MESSAGE);
+
+  // close both ends of the socket
+  result = LIBC_NAMESPACE::close(sockpair[0]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  result = LIBC_NAMESPACE::close(sockpair[1]);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+}
+
+TEST(LlvmLibcSendToRecvFromTest, SendToFails) {
+  const char TEST_MESSAGE[] = "connection terminated";
+  const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
+
+  ssize_t send_result =
+      LIBC_NAMESPACE::sendto(-1, TEST_MESSAGE, MESSAGE_LEN, 0, nullptr, 0);
+  EXPECT_EQ(send_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
+
+TEST(LlvmLibcSendToRecvFromTest, RecvFromFails) {
+  char buffer[256];
+
+  ssize_t recv_result =
+      LIBC_NAMESPACE::recvfrom(-1, buffer, sizeof(buffer), 0, nullptr, 0);
+  ASSERT_EQ(recv_result, ssize_t(-1));
+  ASSERT_ERRNO_FAILURE();
+
+  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+}
diff --git a/test/src/sys/socket/linux/socketpair_test.cpp b/test/src/sys/socket/linux/socketpair_test.cpp
new file mode 100644
index 0000000..9393ddd
--- /dev/null
+++ b/test/src/sys/socket/linux/socketpair_test.cpp
@@ -0,0 +1,37 @@
+//===-- Unittests for socketpair ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sys/socket/socketpair.h"
+
+#include "src/unistd/close.h"
+
+#include "src/errno/libc_errno.h"
+#include "test/UnitTest/Test.h"
+
+#include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
+
+TEST(LlvmLibcSocketPairTest, LocalSocket) {
+  int sockpair[2] = {-1, -1};
+  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_DGRAM, 0, sockpair);
+  ASSERT_EQ(result, 0);
+  ASSERT_ERRNO_SUCCESS();
+
+  ASSERT_GE(sockpair[0], 0);
+  ASSERT_GE(sockpair[1], 0);
+
+  LIBC_NAMESPACE::close(sockpair[0]);
+  LIBC_NAMESPACE::close(sockpair[1]);
+  ASSERT_ERRNO_SUCCESS();
+}
+
+TEST(LlvmLibcSocketPairTest, SocketFails) {
+  int sockpair[2] = {-1, -1};
+  int result = LIBC_NAMESPACE::socketpair(-1, -1, -1, sockpair);
+  ASSERT_EQ(result, -1);
+  ASSERT_ERRNO_FAILURE();
+}
diff --git a/test/src/sys/stat/chmod_test.cpp b/test/src/sys/stat/chmod_test.cpp
index c688996..83ab0f4 100644
--- a/test/src/sys/stat/chmod_test.cpp
+++ b/test/src/sys/stat/chmod_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcChmodTest, ChangeAndOpen) {
diff --git a/test/src/sys/stat/fchmod_test.cpp b/test/src/sys/stat/fchmod_test.cpp
index 91c0f68..03eb79d 100644
--- a/test/src/sys/stat/fchmod_test.cpp
+++ b/test/src/sys/stat/fchmod_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcChmodTest, ChangeAndOpen) {
diff --git a/test/src/sys/stat/fchmodat_test.cpp b/test/src/sys/stat/fchmodat_test.cpp
index c43ef8a..09970b6 100644
--- a/test/src/sys/stat/fchmodat_test.cpp
+++ b/test/src/sys/stat/fchmodat_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcFchmodatTest, ChangeAndOpen) {
diff --git a/test/src/sys/stat/fstat_test.cpp b/test/src/sys/stat/fstat_test.cpp
index 1379eae..34c675d 100644
--- a/test/src/sys/stat/fstat_test.cpp
+++ b/test/src/sys/stat/fstat_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcFStatTest, CreatAndReadMode) {
diff --git a/test/src/sys/stat/lstat_test.cpp b/test/src/sys/stat/lstat_test.cpp
index b44b3d1..a723d5a 100644
--- a/test/src/sys/stat/lstat_test.cpp
+++ b/test/src/sys/stat/lstat_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcLStatTest, CreatAndReadMode) {
diff --git a/test/src/sys/stat/mkdirat_test.cpp b/test/src/sys/stat/mkdirat_test.cpp
index cbacc16..85e013d 100644
--- a/test/src/sys/stat/mkdirat_test.cpp
+++ b/test/src/sys/stat/mkdirat_test.cpp
@@ -11,7 +11,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 TEST(LlvmLibcMkdiratTest, CreateAndRemove) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
diff --git a/test/src/sys/stat/stat_test.cpp b/test/src/sys/stat/stat_test.cpp
index baf3633..0ddd8ba 100644
--- a/test/src/sys/stat/stat_test.cpp
+++ b/test/src/sys/stat/stat_test.cpp
@@ -14,7 +14,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>
 
 TEST(LlvmLibcStatTest, CreatAndReadMode) {
diff --git a/test/src/sys/statvfs/linux/fstatvfs_test.cpp b/test/src/sys/statvfs/linux/fstatvfs_test.cpp
index bd5195c..f4d71e9 100644
--- a/test/src/sys/statvfs/linux/fstatvfs_test.cpp
+++ b/test/src/sys/statvfs/linux/fstatvfs_test.cpp
@@ -1,42 +1,59 @@
-#include "llvm-libc-macros/linux/fcntl-macros.h"
+//===-- Unittests for fstatvfs --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
 #include "src/fcntl/open.h"
+#include "src/sys/stat/mkdirat.h"
 #include "src/sys/statvfs/fstatvfs.h"
-#include "src/sys/statvfs/linux/statfs_utils.h"
 #include "src/unistd/close.h"
+#include "src/unistd/rmdir.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
-#include <linux/magic.h>
+#include "test/UnitTest/Test.h"
+
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
 
-namespace LIBC_NAMESPACE {
-static int fstatfs(int fd, struct statfs *buf) {
-  using namespace statfs_utils;
-  if (cpp::optional<LinuxStatFs> result = linux_fstatfs(fd)) {
-    *buf = *result;
-    return 0;
-  }
-  return -1;
-}
-} // namespace LIBC_NAMESPACE
-
-struct PathFD {
-  int fd;
-  explicit PathFD(const char *path)
-      : fd(LIBC_NAMESPACE::open(path, O_CLOEXEC | O_PATH)) {}
-  ~PathFD() { LIBC_NAMESPACE::close(fd); }
-  operator int() const { return fd; }
-};
-
-TEST(LlvmLibcSysStatvfsTest, FstatfsBasic) {
-  struct statfs buf;
-  ASSERT_THAT(LIBC_NAMESPACE::fstatfs(PathFD("/"), &buf), Succeeds());
-  ASSERT_THAT(LIBC_NAMESPACE::fstatfs(PathFD("/proc"), &buf), Succeeds());
-  ASSERT_EQ(buf.f_type, static_cast<decltype(buf.f_type)>(PROC_SUPER_MAGIC));
-  ASSERT_THAT(LIBC_NAMESPACE::fstatfs(PathFD("/sys"), &buf), Succeeds());
-  ASSERT_EQ(buf.f_type, static_cast<decltype(buf.f_type)>(SYSFS_MAGIC));
+TEST(LlvmLibcSysFStatvfsTest, FStatvfsBasic) {
+  struct statvfs buf;
+
+  int fd = LIBC_NAMESPACE::open("/", O_PATH);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(fd, 0);
+
+  // The root of the file directory must always exist
+  ASSERT_THAT(LIBC_NAMESPACE::fstatvfs(fd, &buf), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
 
-TEST(LlvmLibcSysStatvfsTest, FstatvfsInvalidFD) {
+TEST(LlvmLibcSysFStatvfsTest, FStatvfsInvalidPath) {
   struct statvfs buf;
-  ASSERT_THAT(LIBC_NAMESPACE::fstatvfs(-1, &buf), Fails(EBADF));
+
+  constexpr const char *FILENAME = "fstatvfs.testdir";
+  auto TEST_DIR = libc_make_test_file_path(FILENAME);
+
+  // Always delete the folder so that we start in a consistent state.
+  LIBC_NAMESPACE::rmdir(TEST_DIR);
+  LIBC_NAMESPACE::libc_errno = 0; // Reset errno
+
+  ASSERT_THAT(LIBC_NAMESPACE::mkdirat(AT_FDCWD, TEST_DIR, S_IRWXU),
+              Succeeds(0));
+
+  int fd = LIBC_NAMESPACE::open(TEST_DIR, O_PATH);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(fd, 0);
+
+  // create the file, assert it exists, then delete it and assert it doesn't
+  // exist anymore.
+
+  ASSERT_THAT(LIBC_NAMESPACE::fstatvfs(fd, &buf), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
+
+  ASSERT_THAT(LIBC_NAMESPACE::rmdir(TEST_DIR), Succeeds(0));
+
+  ASSERT_THAT(LIBC_NAMESPACE::fstatvfs(fd, &buf), Fails(EBADF));
 }
diff --git a/test/src/sys/statvfs/linux/statvfs_test.cpp b/test/src/sys/statvfs/linux/statvfs_test.cpp
index 695d2c0..32f8120 100644
--- a/test/src/sys/statvfs/linux/statvfs_test.cpp
+++ b/test/src/sys/statvfs/linux/statvfs_test.cpp
@@ -1,47 +1,48 @@
-#include "src/sys/statvfs/linux/statfs_utils.h"
+//===-- Unittests for statvfs ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/fcntl_macros.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include "src/sys/stat/mkdirat.h"
 #include "src/sys/statvfs/statvfs.h"
+#include "src/unistd/rmdir.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
-#include <linux/magic.h>
+#include "test/UnitTest/Test.h"
+
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
 
-namespace LIBC_NAMESPACE {
-static int statfs(const char *path, struct statfs *buf) {
-  using namespace statfs_utils;
-  if (cpp::optional<LinuxStatFs> result = linux_statfs(path)) {
-    *buf = *result;
-    return 0;
-  }
-  return -1;
-}
-} // namespace LIBC_NAMESPACE
-
-TEST(LlvmLibcSysStatfsTest, StatfsBasic) {
-  struct statfs buf;
-  ASSERT_THAT(LIBC_NAMESPACE::statfs("/", &buf), Succeeds());
-  ASSERT_THAT(LIBC_NAMESPACE::statfs("/proc", &buf), Succeeds());
-  ASSERT_EQ(buf.f_type, static_cast<decltype(buf.f_type)>(PROC_SUPER_MAGIC));
-  ASSERT_THAT(LIBC_NAMESPACE::statfs("/sys", &buf), Succeeds());
-  ASSERT_EQ(buf.f_type, static_cast<decltype(buf.f_type)>(SYSFS_MAGIC));
+TEST(LlvmLibcSysStatvfsTest, StatvfsBasic) {
+  struct statvfs buf;
+  // The root of the file directory must always exist
+  ASSERT_THAT(LIBC_NAMESPACE::statvfs("/", &buf), Succeeds());
 }
 
-TEST(LlvmLibcSysStatfsTest, StatvfsInvalidPath) {
+TEST(LlvmLibcSysStatvfsTest, StatvfsInvalidPath) {
   struct statvfs buf;
+
   ASSERT_THAT(LIBC_NAMESPACE::statvfs("", &buf), Fails(ENOENT));
-  ASSERT_THAT(LIBC_NAMESPACE::statvfs("/nonexistent", &buf), Fails(ENOENT));
-  ASSERT_THAT(LIBC_NAMESPACE::statvfs("/dev/null/whatever", &buf),
-              Fails(ENOTDIR));
-  ASSERT_THAT(LIBC_NAMESPACE::statvfs(nullptr, &buf), Fails(EFAULT));
-}
 
-TEST(LlvmLibcSysStatfsTest, StatvfsNameTooLong) {
-  struct statvfs buf;
-  ASSERT_THAT(LIBC_NAMESPACE::statvfs("/", &buf), Succeeds());
-  char *name = static_cast<char *>(__builtin_alloca(buf.f_namemax + 3));
-  name[0] = '/';
-  name[buf.f_namemax + 2] = '\0';
-  for (unsigned i = 1; i < buf.f_namemax + 2; ++i) {
-    name[i] = 'a';
-  }
-  ASSERT_THAT(LIBC_NAMESPACE::statvfs(name, &buf), Fails(ENAMETOOLONG));
+  // create the file, assert it exists, then delete it and assert it doesn't
+  // exist anymore.
+  constexpr const char *FILENAME = "statvfs.testdir";
+  auto TEST_DIR = libc_make_test_file_path(FILENAME);
+
+  // Always delete the folder so that we start in a consistent state.
+  LIBC_NAMESPACE::rmdir(TEST_DIR);
+  LIBC_NAMESPACE::libc_errno = 0; // Reset errno
+
+  ASSERT_THAT(LIBC_NAMESPACE::mkdirat(AT_FDCWD, TEST_DIR, S_IRWXU),
+              Succeeds(0));
+
+  ASSERT_THAT(LIBC_NAMESPACE::statvfs(TEST_DIR, &buf), Succeeds());
+
+  ASSERT_THAT(LIBC_NAMESPACE::rmdir(TEST_DIR), Succeeds(0));
+
+  ASSERT_THAT(LIBC_NAMESPACE::statvfs(TEST_DIR, &buf), Fails(ENOENT));
 }
diff --git a/test/src/sys/utsname/uname_test.cpp b/test/src/sys/utsname/uname_test.cpp
index 79822c1..6452021 100644
--- a/test/src/sys/utsname/uname_test.cpp
+++ b/test/src/sys/utsname/uname_test.cpp
@@ -12,7 +12,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <sys/utsname.h>
 
 TEST(LlvmLibcUnameTest, GetMachineName) {
diff --git a/test/src/sys/wait/wait4_test.cpp b/test/src/sys/wait/wait4_test.cpp
index 70d4d43..c408004 100644
--- a/test/src/sys/wait/wait4_test.cpp
+++ b/test/src/sys/wait/wait4_test.cpp
@@ -10,7 +10,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <sys/wait.h>
 
 // The test here is a simpl test for WNOHANG functionality. For a more
diff --git a/test/src/sys/wait/waitpid_test.cpp b/test/src/sys/wait/waitpid_test.cpp
index b2ace26..fb456bf 100644
--- a/test/src/sys/wait/waitpid_test.cpp
+++ b/test/src/sys/wait/waitpid_test.cpp
@@ -10,7 +10,6 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <errno.h>
 #include <sys/wait.h>
 
 // The test here is a simpl test for WNOHANG functionality. For a more
diff --git a/test/src/time/TmHelper.h b/test/src/time/TmHelper.h
index 1621094..5ae2584 100644
--- a/test/src/time/TmHelper.h
+++ b/test/src/time/TmHelper.h
@@ -11,11 +11,12 @@
 
 #include <time.h>
 
+#include "src/__support/macros/config.h"
 #include "src/time/time_utils.h"
 
 using LIBC_NAMESPACE::time_utils::TimeConstants;
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace tmhelper {
 namespace testing {
 
@@ -38,6 +39,6 @@ static inline void initialize_tm_data(struct tm *tm_data, int year, int month,
 
 } // namespace testing
 } // namespace tmhelper
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_TEST_SRC_TIME_TMHELPER_H
diff --git a/test/src/time/TmMatcher.h b/test/src/time/TmMatcher.h
index 7cdc2c4..630956b 100644
--- a/test/src/time/TmMatcher.h
+++ b/test/src/time/TmMatcher.h
@@ -11,9 +11,10 @@
 
 #include <time.h>
 
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
-namespace LIBC_NAMESPACE {
+namespace LIBC_NAMESPACE_DECL {
 namespace testing {
 
 class StructTmMatcher : public Matcher<::tm> {
@@ -57,7 +58,7 @@ public:
 };
 
 } // namespace testing
-} // namespace LIBC_NAMESPACE
+} // namespace LIBC_NAMESPACE_DECL
 
 #define EXPECT_TM_EQ(expected, actual)                                         \
   EXPECT_THAT((actual), LIBC_NAMESPACE::testing::StructTmMatcher((expected)))
diff --git a/test/src/time/clock_gettime_test.cpp b/test/src/time/clock_gettime_test.cpp
index 6367ae7..43715c0 100644
--- a/test/src/time/clock_gettime_test.cpp
+++ b/test/src/time/clock_gettime_test.cpp
@@ -6,22 +6,29 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/macros/properties/architectures.h"
 #include "src/time/clock_gettime.h"
 #include "test/UnitTest/Test.h"
 
 #include <time.h>
 
 TEST(LlvmLibcClockGetTime, RealTime) {
-  struct timespec tp;
+  timespec tp;
   int result;
   result = LIBC_NAMESPACE::clock_gettime(CLOCK_REALTIME, &tp);
+  // The GPU does not implement CLOCK_REALTIME but provides it so programs will
+  // compile.
+#ifdef LIBC_TARGET_ARCH_IS_GPU
+  ASSERT_EQ(result, -1);
+#else
   ASSERT_EQ(result, 0);
   ASSERT_GT(tp.tv_sec, time_t(0));
+#endif
 }
 
 #ifdef CLOCK_MONOTONIC
 TEST(LlvmLibcClockGetTime, MonotonicTime) {
-  struct timespec tp1, tp2;
+  timespec tp1, tp2;
   int result;
   result = LIBC_NAMESPACE::clock_gettime(CLOCK_MONOTONIC, &tp1);
   ASSERT_EQ(result, 0);
diff --git a/test/src/time/ctime_r_test.cpp b/test/src/time/ctime_r_test.cpp
new file mode 100644
index 0000000..9ce6f75
--- /dev/null
+++ b/test/src/time/ctime_r_test.cpp
@@ -0,0 +1,58 @@
+//===-- Unittests for ctime_r ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/time/ctime_r.h"
+#include "src/time/time_utils.h"
+#include "test/UnitTest/Test.h"
+#include "test/src/time/TmHelper.h"
+
+using LIBC_NAMESPACE::time_utils::TimeConstants;
+
+TEST(LlvmLibcCtimeR, Nullptr) {
+  char *result;
+  result = LIBC_NAMESPACE::ctime_r(nullptr, nullptr);
+  ASSERT_STREQ(nullptr, result);
+
+  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  result = LIBC_NAMESPACE::ctime_r(nullptr, buffer);
+  ASSERT_STREQ(nullptr, result);
+
+  time_t t;
+  result = LIBC_NAMESPACE::ctime_r(&t, nullptr);
+  ASSERT_STREQ(nullptr, result);
+}
+
+TEST(LlvmLibcCtimeR, ValidUnixTimestamp0) {
+  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  time_t t;
+  char *result;
+  // 1970-01-01 00:00:00. Test with a valid buffer size.
+  t = 0;
+  result = LIBC_NAMESPACE::ctime_r(&t, buffer);
+  ASSERT_STREQ("Thu Jan  1 00:00:00 1970\n", result);
+}
+
+TEST(LlvmLibcCtime, ValidUnixTimestamp32Int) {
+  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  time_t t;
+  char *result;
+  // 2038-01-19 03:14:07. Test with a valid buffer size.
+  t = 2147483647;
+  result = LIBC_NAMESPACE::ctime_r(&t, buffer);
+  ASSERT_STREQ("Tue Jan 19 03:14:07 2038\n", result);
+}
+
+TEST(LlvmLibcCtimeR, InvalidArgument) {
+  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  time_t t;
+  char *result;
+  t = 2147483648;
+  result = LIBC_NAMESPACE::ctime_r(&t, buffer);
+  ASSERT_STREQ(nullptr, result);
+}
diff --git a/test/src/time/ctime_test.cpp b/test/src/time/ctime_test.cpp
new file mode 100644
index 0000000..7ec71bb
--- /dev/null
+++ b/test/src/time/ctime_test.cpp
@@ -0,0 +1,42 @@
+//===-- Unittests for ctime -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/time/ctime.h"
+#include "test/UnitTest/Test.h"
+#include "test/src/time/TmHelper.h"
+
+TEST(LlvmLibcCtime, NULL) {
+  char *result;
+  result = LIBC_NAMESPACE::ctime(NULL);
+  ASSERT_STREQ(NULL, result);
+}
+
+TEST(LlvmLibcCtime, ValidUnixTimestamp0) {
+  time_t t;
+  char *result;
+  t = 0;
+  result = LIBC_NAMESPACE::ctime(&t);
+  ASSERT_STREQ("Thu Jan  1 00:00:00 1970\n", result);
+}
+
+TEST(LlvmLibcCtime, ValidUnixTimestamp32Int) {
+  time_t t;
+  char *result;
+  t = 2147483647;
+  result = LIBC_NAMESPACE::ctime(&t);
+  ASSERT_STREQ("Tue Jan 19 03:14:07 2038\n", result);
+}
+
+TEST(LlvmLibcCtime, InvalidArgument) {
+  time_t t;
+  char *result;
+  t = 2147483648;
+  result = LIBC_NAMESPACE::ctime(&t);
+  ASSERT_STREQ(NULL, result);
+}
diff --git a/test/src/time/mktime_test.cpp b/test/src/time/mktime_test.cpp
index 3142a4f..84e6c7e 100644
--- a/test/src/time/mktime_test.cpp
+++ b/test/src/time/mktime_test.cpp
@@ -380,22 +380,115 @@ TEST(LlvmLibcMkTime, InvalidDays) {
 TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   // Test for maximum value of a signed 32-bit integer.
   // Test implementation can encode time for Tue 19 January 2038 03:14:07 UTC.
-  struct tm tm_data {
-    .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
-    .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-    .tm_yday = 0, .tm_isdst = 0
-  };
-  EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(0x7FFFFFFF));
-  EXPECT_TM_EQ((tm{.tm_sec = 7,
-                   .tm_min = 14,
-                   .tm_hour = 3,
-                   .tm_mday = 19,
-                   .tm_mon = Month::JANUARY,
-                   .tm_year = tm_year(2038),
-                   .tm_wday = 2,
-                   .tm_yday = 7,
-                   .tm_isdst = 0}),
-               tm_data);
+  {
+    struct tm tm_data {
+      .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
+      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
+      .tm_yday = 0, .tm_isdst = 0
+    };
+    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(0x7FFFFFFF));
+    EXPECT_TM_EQ((tm{.tm_sec = 7,
+                     .tm_min = 14,
+                     .tm_hour = 3,
+                     .tm_mday = 19,
+                     .tm_mon = Month::JANUARY,
+                     .tm_year = tm_year(2038),
+                     .tm_wday = 2,
+                     .tm_yday = 7,
+                     .tm_isdst = 0}),
+                 tm_data);
+  }
+
+  // Now test some times before that, to ensure they are not rejected.
+  {
+    // 2038-01-19 03:13:59 tests that even a large seconds field is
+    // accepted if the minutes field is smaller.
+    struct tm tm_data {
+      .tm_sec = 59, .tm_min = 13, .tm_hour = 3, .tm_mday = 19,
+      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
+      .tm_yday = 0, .tm_isdst = 0
+    };
+    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(0x7FFFFFFF - 8));
+    EXPECT_TM_EQ((tm{.tm_sec = 59,
+                     .tm_min = 13,
+                     .tm_hour = 3,
+                     .tm_mday = 19,
+                     .tm_mon = Month::JANUARY,
+                     .tm_year = tm_year(2038),
+                     .tm_wday = 2,
+                     .tm_yday = 7,
+                     .tm_isdst = 0}),
+                 tm_data);
+  }
+
+  {
+    // 2038-01-19 02:59:59 tests that large seconds and minutes are
+    // accepted if the hours field is smaller.
+    struct tm tm_data {
+      .tm_sec = 59, .tm_min = 59, .tm_hour = 2, .tm_mday = 19,
+      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
+      .tm_yday = 0, .tm_isdst = 0
+    };
+    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
+                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN));
+    EXPECT_TM_EQ((tm{.tm_sec = 59,
+                     .tm_min = 59,
+                     .tm_hour = 2,
+                     .tm_mday = 19,
+                     .tm_mon = Month::JANUARY,
+                     .tm_year = tm_year(2038),
+                     .tm_wday = 2,
+                     .tm_yday = 7,
+                     .tm_isdst = 0}),
+                 tm_data);
+  }
+
+  {
+    // 2038-01-18 23:59:59 tests that large seconds, minutes and hours
+    // are accepted if the days field is smaller.
+    struct tm tm_data {
+      .tm_sec = 59, .tm_min = 59, .tm_hour = 23, .tm_mday = 18,
+      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
+      .tm_yday = 0, .tm_isdst = 0
+    };
+    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
+                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN -
+                         3 * TimeConstants::SECONDS_PER_HOUR));
+    EXPECT_TM_EQ((tm{.tm_sec = 59,
+                     .tm_min = 59,
+                     .tm_hour = 23,
+                     .tm_mday = 18,
+                     .tm_mon = Month::JANUARY,
+                     .tm_year = tm_year(2038),
+                     .tm_wday = 2,
+                     .tm_yday = 7,
+                     .tm_isdst = 0}),
+                 tm_data);
+  }
+
+  {
+    // 2038-01-18 23:59:59 tests that the final second of 2037 is
+    // accepted.
+    struct tm tm_data {
+      .tm_sec = 59, .tm_min = 59, .tm_hour = 23, .tm_mday = 31,
+      .tm_mon = Month::DECEMBER, .tm_year = tm_year(2037), .tm_wday = 0,
+      .tm_yday = 0, .tm_isdst = 0
+    };
+    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
+                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN -
+                         3 * TimeConstants::SECONDS_PER_HOUR -
+                         18 * TimeConstants::SECONDS_PER_DAY));
+    EXPECT_TM_EQ((tm{.tm_sec = 59,
+                     .tm_min = 59,
+                     .tm_hour = 23,
+                     .tm_mday = 31,
+                     .tm_mon = Month::DECEMBER,
+                     .tm_year = tm_year(2037),
+                     .tm_wday = 2,
+                     .tm_yday = 7,
+                     .tm_isdst = 0}),
+                 tm_data);
+  }
 }
 
 TEST(LlvmLibcMkTime, Max64BitYear) {
diff --git a/test/src/unistd/access_test.cpp b/test/src/unistd/access_test.cpp
index 808cd5f..0643b2b 100644
--- a/test/src/unistd/access_test.cpp
+++ b/test/src/unistd/access_test.cpp
@@ -12,7 +12,6 @@
 #include "src/unistd/close.h"
 #include "src/unistd/unlink.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
diff --git a/test/src/unistd/chdir_test.cpp b/test/src/unistd/chdir_test.cpp
index 51dc7bb..e1bdcd7 100644
--- a/test/src/unistd/chdir_test.cpp
+++ b/test/src/unistd/chdir_test.cpp
@@ -13,7 +13,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   // The idea of this test is that we will first open an existing test file
diff --git a/test/src/unistd/fchdir_test.cpp b/test/src/unistd/fchdir_test.cpp
index ae88e1f..0e39fde 100644
--- a/test/src/unistd/fchdir_test.cpp
+++ b/test/src/unistd/fchdir_test.cpp
@@ -13,7 +13,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   // The idea of this test is that we will first open an existing test file
diff --git a/test/src/unistd/fpathconf_test.cpp b/test/src/unistd/fpathconf_test.cpp
new file mode 100644
index 0000000..fe63e5e
--- /dev/null
+++ b/test/src/unistd/fpathconf_test.cpp
@@ -0,0 +1,30 @@
+//===-- Unittests for fpathconf -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "hdr/fcntl_macros.h"
+#include "hdr/limits_macros.h"
+#include "hdr/sys_stat_macros.h"
+#include "hdr/unistd_macros.h"
+#include "src/fcntl/open.h"
+#include "src/unistd/close.h"
+#include "src/unistd/fpathconf.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+TEST(LlvmLibcPipeTest, SmokeTest) {
+  constexpr const char *FILENAME = "fpathconf.test";
+  auto TEST_FILE = libc_make_test_file_path(FILENAME);
+  int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
+  EXPECT_EQ(LIBC_NAMESPACE::fpathconf(fd, _PC_SYNC_IO), -1l);
+  EXPECT_EQ(LIBC_NAMESPACE::fpathconf(fd, _PC_PATH_MAX),
+            static_cast<long>(_POSIX_PATH_MAX));
+  LIBC_NAMESPACE::close(fd);
+}
+
+// TODO: Functionality tests
diff --git a/test/src/unistd/getopt_test.cpp b/test/src/unistd/getopt_test.cpp
index 1ca7c99..e6e8772 100644
--- a/test/src/unistd/getopt_test.cpp
+++ b/test/src/unistd/getopt_test.cpp
@@ -13,8 +13,6 @@
 #include "src/stdio/fflush.h"
 #include "src/stdio/fopencookie.h"
 
-#include <stdio.h>
-
 using LIBC_NAMESPACE::cpp::array;
 
 namespace test_globals {
diff --git a/test/src/unistd/pathconf_test.cpp b/test/src/unistd/pathconf_test.cpp
new file mode 100644
index 0000000..3dc4b2c
--- /dev/null
+++ b/test/src/unistd/pathconf_test.cpp
@@ -0,0 +1,30 @@
+//===-- Unittests for pathconf --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "hdr/fcntl_macros.h"
+#include "hdr/limits_macros.h"
+#include "hdr/sys_stat_macros.h"
+#include "hdr/unistd_macros.h"
+#include "src/fcntl/open.h"
+#include "src/unistd/close.h"
+#include "src/unistd/pathconf.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+TEST(LlvmLibcPipeTest, SmokeTest) {
+  constexpr const char *FILENAME = "pathconf.test";
+  auto TEST_FILE = libc_make_test_file_path(FILENAME);
+  int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
+  EXPECT_EQ(LIBC_NAMESPACE::pathconf(FILENAME, _PC_SYNC_IO), -1l);
+  EXPECT_EQ(LIBC_NAMESPACE::pathconf(FILENAME, _PC_PATH_MAX),
+            static_cast<long>(_POSIX_PATH_MAX));
+  LIBC_NAMESPACE::close(fd);
+}
+
+// TODO: Functionality tests
diff --git a/test/src/unistd/pipe2_test.cpp b/test/src/unistd/pipe2_test.cpp
new file mode 100644
index 0000000..795ec78
--- /dev/null
+++ b/test/src/unistd/pipe2_test.cpp
@@ -0,0 +1,28 @@
+//===-- Unittests for pipe2 -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "src/errno/libc_errno.h"
+#include "src/unistd/close.h"
+#include "src/unistd/pipe2.h"
+
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+TEST(LlvmLibcPipe2Test, SmokeTest) {
+  int pipefd[2];
+  ASSERT_THAT(LIBC_NAMESPACE::pipe2(pipefd, 0), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::close(pipefd[0]), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::close(pipefd[1]), Succeeds());
+}
+
+TEST(LlvmLibcPipe2ErrTest, SmokeTest) {
+  int pipefd[2];
+  ASSERT_THAT(LIBC_NAMESPACE::pipe2(pipefd, -1), Fails(EINVAL));
+  ASSERT_THAT(LIBC_NAMESPACE::pipe2(nullptr, 0), Fails(EFAULT));
+}
diff --git a/test/src/unistd/readlink_test.cpp b/test/src/unistd/readlink_test.cpp
index 20f3951..6b27294 100644
--- a/test/src/unistd/readlink_test.cpp
+++ b/test/src/unistd/readlink_test.cpp
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/string_view.h"
 #include "src/errno/libc_errno.h"
+#include "src/string/string_utils.h"
 #include "src/unistd/readlink.h"
 #include "src/unistd/symlink.h"
 #include "src/unistd/unlink.h"
@@ -18,9 +19,9 @@ namespace cpp = LIBC_NAMESPACE::cpp;
 
 TEST(LlvmLibcReadlinkTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
-  constexpr const char *FILENAME = "readlink_test_value";
+  constexpr const char *FILENAME = "readlink_test_file";
   auto LINK_VAL = libc_make_test_file_path(FILENAME);
-  constexpr const char *FILENAME2 = "readlink.test.link";
+  constexpr const char *FILENAME2 = "readlink_test_file.link";
   auto LINK = libc_make_test_file_path(FILENAME2);
   LIBC_NAMESPACE::libc_errno = 0;
 
@@ -30,8 +31,9 @@ TEST(LlvmLibcReadlinkTest, CreateAndUnlink) {
   //   3. Cleanup the symlink created in step #1.
   ASSERT_THAT(LIBC_NAMESPACE::symlink(LINK_VAL, LINK), Succeeds(0));
 
-  char buf[sizeof(LINK_VAL)];
-  ssize_t len = LIBC_NAMESPACE::readlink(LINK, buf, sizeof(buf));
+  char buf[256];
+  ssize_t len = LIBC_NAMESPACE::readlink(
+      LINK, buf, LIBC_NAMESPACE::internal::string_length(FILENAME));
   ASSERT_ERRNO_SUCCESS();
   ASSERT_EQ(cpp::string_view(buf, len), cpp::string_view(LINK_VAL));
 
@@ -40,7 +42,8 @@ TEST(LlvmLibcReadlinkTest, CreateAndUnlink) {
 
 TEST(LlvmLibcReadlinkTest, ReadlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
-  char buf[8];
-  ASSERT_THAT(LIBC_NAMESPACE::readlink("non-existent-link", buf, sizeof(buf)),
+  constexpr auto LEN = 8;
+  char buf[LEN];
+  ASSERT_THAT(LIBC_NAMESPACE::readlink("non-existent-link", buf, LEN),
               Fails(ENOENT));
 }
diff --git a/test/src/unistd/readlinkat_test.cpp b/test/src/unistd/readlinkat_test.cpp
index 39d81d9..9e4bb9a 100644
--- a/test/src/unistd/readlinkat_test.cpp
+++ b/test/src/unistd/readlinkat_test.cpp
@@ -8,21 +8,22 @@
 
 #include "src/__support/CPP/string_view.h"
 #include "src/errno/libc_errno.h"
+#include "src/string/string_utils.h"
 #include "src/unistd/readlinkat.h"
 #include "src/unistd/symlink.h"
 #include "src/unistd/unlink.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 namespace cpp = LIBC_NAMESPACE::cpp;
 
 TEST(LlvmLibcReadlinkatTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
-  constexpr const char *FILENAME = "readlinkat_test_value";
+  constexpr const char *FILENAME = "readlinkat_test_file";
   auto LINK_VAL = libc_make_test_file_path(FILENAME);
-  constexpr const char *FILENAME2 = "readlinkat.test.link";
+  constexpr const char *FILENAME2 = "readlinkat_test_file.link";
   auto LINK = libc_make_test_file_path(FILENAME2);
   LIBC_NAMESPACE::libc_errno = 0;
 
@@ -32,8 +33,9 @@ TEST(LlvmLibcReadlinkatTest, CreateAndUnlink) {
   //   3. Cleanup the symlink created in step #1.
   ASSERT_THAT(LIBC_NAMESPACE::symlink(LINK_VAL, LINK), Succeeds(0));
 
-  char buf[sizeof(LINK_VAL)];
-  ssize_t len = LIBC_NAMESPACE::readlinkat(AT_FDCWD, LINK, buf, sizeof(buf));
+  char buf[256];
+  ssize_t len = LIBC_NAMESPACE::readlinkat(
+      AT_FDCWD, LINK, buf, LIBC_NAMESPACE::internal::string_length(FILENAME));
   ASSERT_ERRNO_SUCCESS();
   ASSERT_EQ(cpp::string_view(buf, len), cpp::string_view(LINK_VAL));
 
@@ -42,8 +44,9 @@ TEST(LlvmLibcReadlinkatTest, CreateAndUnlink) {
 
 TEST(LlvmLibcReadlinkatTest, ReadlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
-  char buf[8];
-  ASSERT_THAT(LIBC_NAMESPACE::readlinkat(AT_FDCWD, "non-existent-link", buf,
-                                         sizeof(buf)),
-              Fails(ENOENT));
+  constexpr auto LEN = 8;
+  char buf[LEN];
+  ASSERT_THAT(
+      LIBC_NAMESPACE::readlinkat(AT_FDCWD, "non-existent-link", buf, LEN),
+      Fails(ENOENT));
 }
diff --git a/test/src/unistd/rmdir_test.cpp b/test/src/unistd/rmdir_test.cpp
index 93cb0f3..4f4cd94 100644
--- a/test/src/unistd/rmdir_test.cpp
+++ b/test/src/unistd/rmdir_test.cpp
@@ -12,7 +12,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 
 TEST(LlvmLibcRmdirTest, CreateAndRemove) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
diff --git a/test/src/unistd/syscall_test.cpp b/test/src/unistd/syscall_test.cpp
index cee29bd..f6cc3ea 100644
--- a/test/src/unistd/syscall_test.cpp
+++ b/test/src/unistd/syscall_test.cpp
@@ -11,7 +11,7 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include <fcntl.h>
+#include "hdr/fcntl_macros.h"
 #include <sys/stat.h>    // For S_* flags.
 #include <sys/syscall.h> // For syscall numbers.
 #include <unistd.h>
diff --git a/test/src/wchar/btowc_test.cpp b/test/src/wchar/btowc_test.cpp
index b5fcb45..8479d54 100644
--- a/test/src/wchar/btowc_test.cpp
+++ b/test/src/wchar/btowc_test.cpp
@@ -6,10 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <wchar.h> //for WEOF
-
+#include "hdr/wchar_macros.h" // for WEOF
 #include "src/wchar/btowc.h"
-
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcBtowc, DefaultLocale) {
diff --git a/test/src/wchar/wctob_test.cpp b/test/src/wchar/wctob_test.cpp
index 3f91188..977224b 100644
--- a/test/src/wchar/wctob_test.cpp
+++ b/test/src/wchar/wctob_test.cpp
@@ -6,10 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <stdio.h> //for EOF
-
+#include "hdr/stdio_macros.h" //for EOF
 #include "src/wchar/wctob.h"
-
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcWctob, DefaultLocale) {
diff --git a/test/utils/FPUtil/x86_long_double_test.cpp b/test/utils/FPUtil/x86_long_double_test.cpp
index 87796b5..8d16869 100644
--- a/test/utils/FPUtil/x86_long_double_test.cpp
+++ b/test/utils/FPUtil/x86_long_double_test.cpp
@@ -27,8 +27,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
     // If exponent has the max value and the implicit bit is 0,
     // then the number is a NaN for all values of mantissa.
     bits.set_mantissa(i);
-    long double nan = bits.get_val();
-    ASSERT_NE(static_cast<int>(isnan(nan)), 0);
     ASSERT_TRUE(bits.is_nan());
   }
 
@@ -38,8 +36,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
     // then the number is a NaN for all non-zero values of mantissa.
     // Note the initial value of |i| of 1 to avoid a zero mantissa.
     bits.set_mantissa(i);
-    long double nan = bits.get_val();
-    ASSERT_NE(static_cast<int>(isnan(nan)), 0);
     ASSERT_TRUE(bits.is_nan());
   }
 
@@ -49,8 +45,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
     // If exponent is non-zero and also not max, and the implicit bit is 0,
     // then the number is a NaN for all values of mantissa.
     bits.set_mantissa(i);
-    long double nan = bits.get_val();
-    ASSERT_NE(static_cast<int>(isnan(nan)), 0);
     ASSERT_TRUE(bits.is_nan());
   }
 
@@ -60,8 +54,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
     // If exponent is non-zero and also not max, and the implicit bit is 1,
     // then the number is normal value for all values of mantissa.
     bits.set_mantissa(i);
-    long double valid = bits.get_val();
-    ASSERT_EQ(static_cast<int>(isnan(valid)), 0);
     ASSERT_FALSE(bits.is_nan());
   }
 
@@ -70,8 +62,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
   for (unsigned int i = 0; i < COUNT; ++i) {
     // If exponent is zero, then the number is a valid but denormal value.
     bits.set_mantissa(i);
-    long double valid = bits.get_val();
-    ASSERT_EQ(static_cast<int>(isnan(valid)), 0);
     ASSERT_FALSE(bits.is_nan());
   }
 
@@ -80,8 +70,6 @@ TEST(LlvmLibcX86LongDoubleTest, is_nan) {
   for (unsigned int i = 0; i < COUNT; ++i) {
     // If exponent is zero, then the number is a valid but denormal value.
     bits.set_mantissa(i);
-    long double valid = bits.get_val();
-    ASSERT_EQ(static_cast<int>(isnan(valid)), 0);
     ASSERT_FALSE(bits.is_nan());
   }
 }
```

